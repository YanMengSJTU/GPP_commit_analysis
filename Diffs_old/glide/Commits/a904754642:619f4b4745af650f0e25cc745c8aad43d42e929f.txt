diff --git a/.github/stale.yml b/.github/stale.yml
new file mode 100644
index 000000000..d20444829
--- /dev/null
+++ b/.github/stale.yml
@@ -0,0 +1,21 @@
+# Number of days of inactivity before an issue becomes stale
+daysUntilStale: 7
+# Number of days of inactivity before a stale issue is closed
+daysUntilClose: 7
+# Issues with these labels will never be considered stale
+exemptLabels:
+  - bug
+  - enhancement
+  - feature
+  - documentation
+  - build stability
+# Label to use when marking an issue as stale
+staleLabel: stale
+# Comment to post when marking an issue as stale. Set to `false` to disable
+markComment: >
+  This issue has been automatically marked as stale because it has not had
+  activity in the last seven days. It will be closed if no further activity
+  occurs within the next seven days. Thank you for your contributions.
+# Comment to post when closing a stale issue. Set to `false` to disable
+closeComment: false
+unmarkComment: false
diff --git a/.gitignore b/.gitignore
index 6a64b1779..0fdd65869 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,12 +2,11 @@
 local.properties
 *.keystore
 *.DS_Store
-proguard-project.txt
 
 # Gradle
-**/.gradle
-**/.settings
-**/build
+.gradle
+build
+jacoco.exec
 
 # gh-pages
 doc/**
@@ -19,24 +18,15 @@ docs/**/*
 *.swp
 *.swo
 
-# Intellij 
-*.ipr
+# sed
+*.bak
+
+# Intellij
 *.iml
+*.ipr
 *.iws
-**/.idea/.name
-**/.idea/compiler.xml
-**/.idea/copyright/profiles_settings.xml
-**/.idea/encodings.xml
-**/.idea/misc.xml
-**/.idea/modules.xml
-**/.idea/scopes/scope_settings.xml
-**/.idea/vcs.xml
-**/.idea/libraries
-**/.idea/workspace.xml
-**/.idea/tasks.xml
-**/.idea/gradle.xml
-**/.idea/dictionaries
-**/.idea/dataSources.ids
-**/.idea/datasources.xml
-**/.idea/uiDesigner.xml
-**/.idea/runConfigurations.xml
+.idea/**
+!.idea/codeStyleSettings.xml
+!.idea/inspectionProfiles
+!.idea/inspectionProfiles/Project_Default.xml
+
diff --git a/.gitmodules b/.gitmodules
index 525eef67a..e69de29bb 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,12 +0,0 @@
-[submodule "third_party/volley/volley"]
-	path = third_party/volley/volley
-	url = https://android.googlesource.com/platform/frameworks/volley
-[submodule "third_party/disklrucache"]
-	path = third_party/disklrucache
-	url = https://github.com/sjudd/DiskLruCache.git
-[submodule "library/src/androidTest/resources/exif-orientation-examples"]
-	path = library/src/androidTest/resources/exif-orientation-examples
-	url = https://github.com/recurser/exif-orientation-examples.git
-[submodule "library/src/test/resources/exif-orientation-examples"]
-	path = library/src/test/resources/exif-orientation-examples
-	url = https://github.com/recurser/exif-orientation-examples
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index fe060621a..ebd90ff05 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -15,245 +15,17 @@
             <option name="USE_RELATIVE_INDENTS" value="false" />
           </value>
         </option>
-        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
-        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+        <option name="INSERT_INNER_CLASS_IMPORTS" value="true" />
+        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
+          <value />
+        </option>
         <option name="IMPORT_LAYOUT_TABLE">
           <value>
             <package name="" withSubpackages="true" static="true" />
             <emptyLine />
-            <package name="com.google" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="android" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="antenna" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="antlr" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ar" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="asposewobfuscated" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="asquare" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="atg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="au" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="beaver" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bibtex" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bmsi" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bsh" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ccl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cern" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ChartDirector" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="checkers" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="com" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="COM" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="common" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="contribs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="corejava" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cryptix" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cybervillains" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="dalvik" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="danbikel" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="de" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="EDU" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="eg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="eu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="examples" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fat" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fit" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fitlibrary" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fmpp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="freemarker" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="gnu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovy" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovyjarjarantlr" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovyjarjarasm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="hak" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="hep" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ie" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="imageinfo" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="info" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="it" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jal" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="Jama" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="japa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="japacheckers" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jas" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jasmin" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javancss" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javanet" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javassist" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javazoom" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="java_cup" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jcifs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jetty" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="JFlex" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jj2000" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jline" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="JSci" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jsr166y" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="junit" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jxl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jxxload_help" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="kawa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="kea" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="libcore" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="libsvm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="lti" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="memetic" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="mt" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="mx4j" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="net" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="netscape" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="nl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="nu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="oauth" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ognl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="opennlp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="oracle" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="org" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="penn2dg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="pennconverter" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="pl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="prefuse" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="proguard" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="repackage" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="scm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="se" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="serp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="simple" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="soot" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sqlj" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="src" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ssa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sun" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sunlabs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="tcl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testdata" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testshell" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testsuite" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="twitter4j" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="uk" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ViolinStrings" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="weka" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="wet" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="winstone" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="woolfel" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="wowza" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="java" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javax" withSubpackages="true" static="false" />
-            <emptyLine />
             <package name="" withSubpackages="true" static="false" />
-            <emptyLine />
-            <emptyLine />
           </value>
         </option>
         <option name="RIGHT_MARGIN" value="100" />
@@ -263,20 +35,13 @@
         <option name="JD_KEEP_EMPTY_RETURN" value="false" />
         <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
         <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
-        <option name="BLANK_LINES_AFTER_CLASS_HEADER" value="1" />
-        <option name="ALIGN_MULTILINE_PARAMETERS_IN_CALLS" value="true" />
-        <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="true" />
-        <option name="ALIGN_MULTILINE_ASSIGNMENT" value="true" />
-        <option name="ALIGN_MULTILINE_TERNARY_OPERATION" value="true" />
-        <option name="ALIGN_MULTILINE_THROWS_LIST" value="true" />
-        <option name="ALIGN_MULTILINE_EXTENDS_LIST" value="true" />
-        <option name="ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION" value="true" />
-        <option name="ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION" value="true" />
+        <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="0" />
+        <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+        <option name="ALIGN_MULTILINE_FOR" value="false" />
+        <option name="SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE" value="true" />
         <option name="CALL_PARAMETERS_WRAP" value="1" />
         <option name="METHOD_PARAMETERS_WRAP" value="1" />
         <option name="EXTENDS_LIST_WRAP" value="1" />
-        <option name="THROWS_LIST_WRAP" value="1" />
-        <option name="EXTENDS_KEYWORD_WRAP" value="1" />
         <option name="THROWS_KEYWORD_WRAP" value="1" />
         <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
         <option name="BINARY_OPERATION_WRAP" value="1" />
@@ -285,70 +50,515 @@
         <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
         <option name="FOR_STATEMENT_WRAP" value="1" />
         <option name="ARRAY_INITIALIZER_WRAP" value="1" />
-        <option name="ASSIGNMENT_WRAP" value="5" />
         <option name="WRAP_COMMENTS" value="true" />
         <option name="IF_BRACE_FORCE" value="3" />
         <option name="DOWHILE_BRACE_FORCE" value="3" />
         <option name="WHILE_BRACE_FORCE" value="3" />
         <option name="FOR_BRACE_FORCE" value="3" />
-        <Objective-C-extensions>
-          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />
-          <option name="RELEASE_STYLE" value="IVAR" />
-          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />
-          <file>
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
-          </file>
-          <class>
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
-            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
-          </class>
-          <extensions>
-            <pair source="cpp" header="h" />
-            <pair source="c" header="h" />
-          </extensions>
-        </Objective-C-extensions>
+        <AndroidXmlCodeStyleSettings>
+          <option name="USE_CUSTOM_SETTINGS" value="true" />
+          <option name="LAYOUT_SETTINGS">
+            <value>
+              <option name="INSERT_BLANK_LINE_BEFORE_TAG" value="false" />
+            </value>
+          </option>
+        </AndroidXmlCodeStyleSettings>
+        <JSCodeStyleSettings>
+          <option name="INDENT_CHAINED_CALLS" value="false" />
+        </JSCodeStyleSettings>
+        <JavaCodeStyleSettings>
+          <option name="DO_NOT_WRAP_AFTER_SINGLE_ANNOTATION" value="true" />
+        </JavaCodeStyleSettings>
+        <Python>
+          <option name="USE_CONTINUATION_INDENT_FOR_ARGUMENTS" value="true" />
+        </Python>
+        <TypeScriptCodeStyleSettings>
+          <option name="INDENT_CHAINED_CALLS" value="false" />
+        </TypeScriptCodeStyleSettings>
         <XML>
+          <option name="XML_ALIGN_ATTRIBUTES" value="false" />
           <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
         </XML>
-        <ADDITIONAL_INDENT_OPTIONS fileType="haml">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="java">
-          <option name="INDENT_SIZE" value="2" />
-          <option name="CONTINUATION_INDENT_SIZE" value="4" />
-          <option name="TAB_SIZE" value="8" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="js">
-          <option name="CONTINUATION_INDENT_SIZE" value="4" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="sass">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="yml">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
+        <codeStyleSettings language="CSS">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ECMA Script Level 4">
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+        </codeStyleSettings>
+        <codeStyleSettings language="HTML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
         <codeStyleSettings language="JAVA">
+          <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_RESOURCES" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="THROWS_KEYWORD_WRAP" value="1" />
+          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="KEEP_SIMPLE_BLOCKS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_METHODS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_CLASSES_IN_ONE_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JSON">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JavaScript">
+          <option name="RIGHT_MARGIN" value="80" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
           <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ObjectiveC">
+          <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="1" />
+          <option name="BLANK_LINES_BEFORE_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AFTER_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AROUND_CLASS" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD_IN_INTERFACE" value="0" />
+          <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="false" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ASSIGNMENT_WRAP" value="1" />
           <indentOptions>
             <option name="INDENT_SIZE" value="2" />
             <option name="CONTINUATION_INDENT_SIZE" value="4" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="PROTO">
+          <option name="RIGHT_MARGIN" value="80" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="Python">
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="RIGHT_MARGIN" value="80" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="SASS">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="SCSS">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="TypeScript">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="XML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+          <arrangement>
+            <rules>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:android</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:id</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:.*Style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_width</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_height</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_weight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_margin</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:padding</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res-auto</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/tools</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>.*</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+            </rules>
+          </arrangement>
+        </codeStyleSettings>
+        <codeStyleSettings language="protobuf">
+          <option name="RIGHT_MARGIN" value="80" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
             <option name="TAB_SIZE" value="2" />
           </indentOptions>
         </codeStyleSettings>
       </value>
     </option>
-    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
   </component>
-</project>
\ No newline at end of file
+</project>
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
index 000000000..1c2b4c84f
--- /dev/null
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -0,0 +1,9 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="SerializableHasSerialVersionUIDField" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="ignoreAnonymousInnerClasses" value="false" />
+      <option name="superClassString" value="" />
+    </inspection_tool>
+  </profile>
+</component>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index a980a467d..5fa2230b2 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,17 +1,18 @@
 language: android
-sudo: required
+sudo: false
 dist: trusty
 
+before_install:
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55\nd56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  - echo -e "\n84831b9409646a918e30573bab4c9c91346d8abd\n504667f4c0de7af1a06de9f4b1727b84351f2910" > "$ANDROID_HOME/licenses/android-sdk-preview-license"
+  - yes | $ANDROID_HOME/tools/bin/sdkmanager "build-tools;28.0.3" "platforms;android-28"
+
 android:
   components:
-  - tools
-  - platform-tools
-  - tools
-  - build-tools-26.0.1
-  - android-26
-
-licenses:
-  - 'android-sdk-license.*'
+    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943
+    - tools
+    - tools
 
 jdk:
   - oraclejdk8
@@ -19,9 +20,6 @@ jdk:
 env:
   matrix:
     - COMPONENT=unit
-    - COMPONENT=firebase
-    - COMPONENT=instrumentation ANDROID_TARGET=16
-    - COMPONENT=instrumentation ANDROID_TARGET=22
     - COMPONENT=samples
 
 before_script:
diff --git a/README.md b/README.md
index 4a3e2fa91..f4bb5ed31 100644
--- a/README.md
+++ b/README.md
@@ -18,6 +18,8 @@ also effective for almost any case where you need to fetch, resize, and display
 
 Download
 --------
+For detailed instructions and requirements, see Glide's [download and setup docs page][28].
+
 You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
@@ -25,12 +27,12 @@ Or use Gradle:
 ```gradle
 repositories {
   mavenCentral()
-  maven { url 'https://maven.google.com' }
+  google()
 }
 
 dependencies {
-  compile 'com.github.bumptech.glide:glide:4.2.0'
-  annotationProcessor 'com.github.bumptech.glide:compiler:4.2.0'
+  implementation 'com.github.bumptech.glide:glide:4.9.0'
+  annotationProcessor 'com.github.bumptech.glide:compiler:4.9.0'
 }
 ```
 
@@ -40,31 +42,26 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>4.2.0</version>
-</dependency>
-<dependency>
-  <groupId>com.google.android</groupId>
-  <artifactId>support-v4</artifactId>
-  <version>r7</version>
+  <version>4.9.0</version>
 </dependency>
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>compiler</artifactId>
-  <version>4.2.0</version>
+  <version>4.9.0</version>
   <optional>true</optional>
 </dependency>
 ```
 
-For info on using the bleeding edge, see the [Snapshots][17] wiki page.
+For info on using the bleeding edge, see the [Snapshots][17] docs page.
 
 ProGuard
 --------
-Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):
+Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see the [Download and Setup docs page][25] for more details):
 
 ```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
 -keep public class * extends com.bumptech.glide.module.AppGlideModule
--keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
+-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {
   **[] $VALUES;
   public *;
 }
@@ -79,7 +76,7 @@ Check out the [documentation][20] for pages on a variety of topics, and see the
 
 For Glide v3, see the [wiki][2].
 
-Simple use cases with Glide's [generated API][21] will look something like this:
+Simple use cases will look something like this:
 
 ```java
 // For a simple view:
@@ -87,7 +84,7 @@ Simple use cases with Glide's [generated API][21] will look something like this:
   ...
   ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
-  GlideApp.with(this).load("http://goo.gl/gEgYUd").into(imageView);
+  Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
 // For a simple image list:
@@ -101,7 +98,7 @@ Simple use cases with Glide's [generated API][21] will look something like this:
 
   String url = myUrls.get(position);
 
-  GlideApp
+  Glide
     .with(myFragment)
     .load(url)
     .centerCrop()
@@ -114,20 +111,20 @@ Simple use cases with Glide's [generated API][21] will look something like this:
 
 Status
 ------
-Version 4 is now released and stable. Updates are currently released at least monthly with new features and bug fixes.
+Version 4 is now released and stable. Updates are released periodically with new features and bug fixes.
 
 Comments/bugs/questions/pull requests are always welcome! Please read [CONTRIBUTING.md][5] on how to report issues.
 
 Compatibility
 -------------
 
- * **Minimum Android SDK**: Glide requires a minimum API level of 14.
- * **Compile Android SDK**: Glide requires you to compile against API 26.
+ * **Minimum Android SDK**: Glide v4 requires a minimum API level of 14.
+ * **Compile Android SDK**: Glide v4 requires you to compile against API 26 or later.
 
- If you need to support older versions, consider staying on [Glide v3][14], which works on API 10, but not actively maintained.
- * **OkHttp 2.x**: there are optional dependencies available called `okhttp-integration`, see [Integration Libraries][12] wiki page.
- * **OkHttp 3.x**: there are optional dependencies available called `okhttp3-integration`, see [Integration Libraries][12] wiki page.
- * **Volley**: there are optional dependencies available called `volley-integration`, see [Integration Libraries][12] wiki page.
+ If you need to support older versions of Android, consider staying on [Glide v3][14], which works on API 10, but is not actively maintained.
+
+ * **OkHttp 3.x**: There is an optional dependency available called `okhttp3-integration`, see the [docs page][23].
+ * **Volley**: There is an optional dependency available called `volley-integration`, see the [docs page][24].
  * **Round Pictures**: `CircleImageView`/`CircularImageView`/`RoundedImageView` are known to have [issues][18] with `TransitionDrawable` (`.crossFade()` with `.thumbnail()` or `.placeholder()`) and animated GIFs, use a [`BitmapTransformation`][19] (`.circleCrop()` will be available in v4) or `.dontAnimate()` to fix the issue.
  * **Huge Images** (maps, comic strips): Glide can load huge images by downsampling them, but does not support zooming and panning `ImageView`s as they require special resource optimizations (such as tiling) to work without `OutOfMemoryError`s.
 
@@ -136,9 +133,8 @@ Build
 Building Glide with gradle is fairly straight forward:
 
 ```shell
-git clone git@github.com:bumptech/glide.git # use https://github.com/bumptech/glide.git if "Permission Denied"
+git clone https://github.com/bumptech/glide.git
 cd glide
-git submodule init && git submodule update
 ./gradlew jar
 ```
 
@@ -160,14 +156,16 @@ You may also find precompiled APKs on the [releases page][1].
 Development
 -----------
 Follow the steps in the [Build](#build) section to setup the project and then edit the files however you wish.
-[Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
+[Android Studio][26] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
-To open the project in IntelliJ IDEA:
+To open the project in Android Studio:
 
 1. Go to *File* menu or the *Welcome Screen*
 2. Click on *Open...*
 3. Navigate to Glide's root directory.
-4. Select `build.gradle`
+4. Select `setting.gradle`
+
+For more details, see the [Contributing docs page][27].
 
 Getting Help
 ------------
@@ -200,7 +198,7 @@ This is not an official Google product.
 
 [1]: https://github.com/bumptech/glide/releases
 [2]: https://github.com/bumptech/glide/wiki
-[3]: http://bumptech.github.io/glide/ref/javadocs.html
+[3]: https://bumptech.github.io/glide/ref/javadocs.html
 [4]: https://www.jetbrains.com/idea/download/
 [5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
@@ -214,9 +212,14 @@ This is not an official Google product.
 [14]: https://github.com/bumptech/glide/tree/3.0
 [15]: https://github.com/bumptech/glide/tree/master
 [16]: https://github.com/bumptech/glide/blob/master/LICENSE
-[17]: https://github.com/bumptech/glide/wiki/Snapshots
+[17]: http://bumptech.github.io/glide/dev/snapshots.html
 [18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
 [19]: https://github.com/wasabeef/glide-transformations
-[20]: http://bumptech.github.io/glide/
-[21]: http://bumptech.github.io/glide/doc/generatedapi.html
+[20]: https://bumptech.github.io/glide/
 [22]: https://muyangmin.github.io/glide-docs-cn/
+[23]: http://bumptech.github.io/glide/int/okhttp3.html
+[24]: http://bumptech.github.io/glide/int/volley.html
+[25]: http://bumptech.github.io/glide/doc/download-setup.html#proguard
+[26]: https://developer.android.com/studio/index.html
+[27]: http://bumptech.github.io/glide/dev/contributing.html
+[28]: http://bumptech.github.io/glide/doc/download-setup.html
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
index 22a02a63a..453d9877a 100644
--- a/annotation/compiler/build.gradle
+++ b/annotation/compiler/build.gradle
@@ -13,15 +13,18 @@ dependencies {
     // from https://code.google.com/archive/p/jarjar/downloads
     jarjar files('libs/jarjar-1.4.jar')
 
-    compileOnly 'com.squareup:javapoet:1.9.0'
-    compileOnly 'com.google.auto.service:auto-service:1.0-rc3'
-    compileOnly 'com.google.code.findbugs:jsr305:3.0.1'
-
+    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}"
+    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
+    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compile project(':annotation')
-    // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator.
+    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator.
     compile files(Jvm.current().getToolsJar())
+    annotationProcessor "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
 }
 
+// Make sure running `gradlew :annotation:compiler:check` actually does full quality control.
+test.dependsOn ':annotation:compiler:test:test'
+
 def packagingFolder = file("${buildDir}/intermediates")
 def repackagedJar = file("${packagingFolder}/repackaged.jar")
 def proguardedJar = file("${packagingFolder}/proguarded.jar")
@@ -35,7 +38,7 @@ task compiledJar(type: Jar, dependsOn: classes) {
 // Repackage compileOnly dependencies to avoid namespace collisions.
 task jarjar(dependsOn: [tasks.compiledJar, configurations.compileOnly]) {
     // Set up inputs and outputs to only rebuild when necessary (code change, dependency change).
-    inputs.file compiledJar
+    inputs.files compiledJar
     inputs.files configurations.compileOnly
     outputs.file repackagedJar
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
index 3e62fb816..4a2aabcae 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -4,16 +4,26 @@
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeSpec.Builder;
 import com.squareup.javapoet.WildcardTypeName;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules
@@ -26,6 +36,7 @@
  * runtime.
  *
  * <p>The generated class looks something like this:
+ *
  * <pre>
  * <code>
  *  final class GeneratedAppGlideModuleImpl extends com.bumptech.glide.GeneratedAppGlideModule {
@@ -61,7 +72,8 @@
  *    }
  *
  *    {@literal @java.lang.Override}
- *    public java.util.Set<java.lang.Class<?>> getExcludedModuleClasses() {
+ *    {@literal @androidx.annotation.NonNull}
+ *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {
  *      return appGlideModule.getExcludedModuleClasses();
  *    }
  *  }
@@ -71,26 +83,34 @@
 final class AppModuleGenerator {
   static final String GENERATED_ROOT_MODULE_PACKAGE_NAME = "com.bumptech.glide";
   private static final String GLIDE_LOG_TAG = "Glide";
-  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =
-      "GeneratedAppGlideModuleImpl";
+  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME = "GeneratedAppGlideModuleImpl";
   private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";
+
+  private final ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
 
-  AppModuleGenerator(ProcessorUtil processorUtil) {
+  AppModuleGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
     this.processorUtil = processorUtil;
   }
 
   TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {
     ClassName appGlideModuleClassName = ClassName.get(appGlideModule);
-    Set<String> excludedGlideModuleClassNames =
-        getExcludedGlideModuleClassNames(appGlideModule);
+    List<String> excludedGlideModuleClassNames = getExcludedGlideModuleClassNames(appGlideModule);
+
+    List<String> orderedLibraryGlideModuleClassNames =
+        new ArrayList<>(libraryGlideModuleClassNames);
+    Collections.sort(orderedLibraryGlideModuleClassNames);
 
     MethodSpec constructor =
         generateConstructor(
-            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+            appGlideModuleClassName,
+            orderedLibraryGlideModuleClassNames,
+            excludedGlideModuleClassNames);
 
     MethodSpec registerComponents =
-        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+        generateRegisterComponents(
+            orderedLibraryGlideModuleClassNames, excludedGlideModuleClassNames);
 
     MethodSpec getExcludedModuleClasses =
         generateGetExcludedModuleClasses(excludedGlideModuleClassNames);
@@ -99,8 +119,15 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
         MethodSpec.methodBuilder("applyOptions")
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(ClassName.get("android.content", "Context"), "context")
-            .addParameter(ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("android.content", "Context"), "context")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(
+                        ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
             .addStatement("appGlideModule.applyOptions(context, builder)", appGlideModule)
             .build();
 
@@ -112,21 +139,22 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
             .addStatement("return appGlideModule.isManifestParsingEnabled()", appGlideModule)
             .build();
 
-    Builder builder = TypeSpec.classBuilder(GENERATED_APP_MODULE_IMPL_SIMPLE_NAME)
-        .addModifiers(Modifier.FINAL)
-        .addAnnotation(
-            AnnotationSpec.builder(SuppressWarnings.class)
-                .addMember("value", "$S", "deprecation")
-                .build()
-        )
-        .superclass(
-            ClassName.get(GENERATED_ROOT_MODULE_PACKAGE_NAME, GENERATED_ROOT_MODULE_SIMPLE_NAME))
-        .addField(appGlideModuleClassName, "appGlideModule", Modifier.PRIVATE, Modifier.FINAL)
-        .addMethod(constructor)
-        .addMethod(applyOptions)
-        .addMethod(registerComponents)
-        .addMethod(isManifestParsingEnabled)
-        .addMethod(getExcludedModuleClasses);
+    Builder builder =
+        TypeSpec.classBuilder(GENERATED_APP_MODULE_IMPL_SIMPLE_NAME)
+            .addModifiers(Modifier.FINAL)
+            .addAnnotation(
+                AnnotationSpec.builder(SuppressWarnings.class)
+                    .addMember("value", "$S", "deprecation")
+                    .build())
+            .superclass(
+                ClassName.get(
+                    GENERATED_ROOT_MODULE_PACKAGE_NAME, GENERATED_ROOT_MODULE_SIMPLE_NAME))
+            .addField(appGlideModuleClassName, "appGlideModule", Modifier.PRIVATE, Modifier.FINAL)
+            .addMethod(constructor)
+            .addMethod(applyOptions)
+            .addMethod(registerComponents)
+            .addMethod(isManifestParsingEnabled)
+            .addMethod(getExcludedModuleClasses);
 
     ClassName generatedRequestManagerFactoryClassName =
         ClassName.get(
@@ -136,6 +164,7 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
     builder.addMethod(
         MethodSpec.methodBuilder("getRequestManagerFactory")
             .addAnnotation(Override.class)
+            .addAnnotation(processorUtil.nonNull())
             .returns(generatedRequestManagerFactoryClassName)
             .addStatement("return new $T()", generatedRequestManagerFactoryClassName)
             .build());
@@ -143,7 +172,7 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
   }
 
   // TODO: When we drop support for parsing GlideModules from AndroidManifests, remove this method.
-  private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNames) {
+  private MethodSpec generateGetExcludedModuleClasses(Collection<String> excludedClassNames) {
     TypeName wildCardOfObject = WildcardTypeName.subtypeOf(Object.class);
     ParameterizedTypeName classOfWildcardOfObjet =
         ParameterizedTypeName.get(ClassName.get(Class.class), wildCardOfObject);
@@ -151,16 +180,19 @@ private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNam
         ParameterizedTypeName.get(ClassName.get(Set.class), classOfWildcardOfObjet);
     ParameterizedTypeName hashSetOfClassOfWildcardOfObject =
         ParameterizedTypeName.get(ClassName.get(HashSet.class), classOfWildcardOfObjet);
-    MethodSpec.Builder builder = MethodSpec.methodBuilder("getExcludedModuleClasses")
-        .addModifiers(Modifier.PUBLIC)
-        .addAnnotation(Override.class)
-        .returns(setOfClassOfWildcardOfObject);
+    MethodSpec.Builder builder =
+        MethodSpec.methodBuilder("getExcludedModuleClasses")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addAnnotation(processorUtil.nonNull())
+            .returns(setOfClassOfWildcardOfObject);
 
     if (excludedClassNames.isEmpty()) {
       builder.addStatement("return $T.emptySet()", Collections.class);
     } else {
       builder.addStatement(
-          "$T excludedClasses = new $T()", setOfClassOfWildcardOfObject,
+          "$T excludedClasses = new $T()",
+          setOfClassOfWildcardOfObject,
           hashSetOfClassOfWildcardOfObject);
       for (String excludedClassName : excludedClassNames) {
         // TODO: Remove this when we no longer support manifest parsing.
@@ -174,15 +206,25 @@ private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNam
     return builder.build();
   }
 
-  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,
-      Set<String> excludedGlideModuleClassNames) {
+  private MethodSpec generateRegisterComponents(
+      Collection<String> libraryGlideModuleClassNames,
+      Collection<String> excludedGlideModuleClassNames) {
     MethodSpec.Builder registerComponents =
         MethodSpec.methodBuilder("registerComponents")
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(ClassName.get("android.content", "Context"), "context")
-            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide")
-            .addParameter(ClassName.get("com.bumptech.glide", "Registry"), "registry");
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("android.content", "Context"), "context")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("com.bumptech.glide", "Glide"), "glide")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("com.bumptech.glide", "Registry"), "registry")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build());
 
     for (String glideModule : libraryGlideModuleClassNames) {
       if (excludedGlideModuleClassNames.contains(glideModule)) {
@@ -197,35 +239,89 @@ private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClas
     return registerComponents.build();
   }
 
-  private MethodSpec generateConstructor(ClassName appGlideModule,
-      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {
-    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
-    constructorBuilder.addStatement("appGlideModule = new $T()", appGlideModule);
+  private boolean doesAppGlideModuleConstructorAcceptContext(ClassName appGlideModule) {
+    TypeElement appGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(appGlideModule.reflectionName());
+
+    for (Element enclosed : appGlideModuleType.getEnclosedElements()) {
+      if (enclosed.getKind() == ElementKind.CONSTRUCTOR) {
+        ExecutableElement constructor = (ExecutableElement) enclosed;
+        List<? extends VariableElement> parameters = constructor.getParameters();
+        if (parameters.isEmpty()) {
+          return false;
+        } else if (parameters.size() > 1) {
+          throw new IllegalStateException(
+              "Constructor for "
+                  + appGlideModule
+                  + " accepts too many parameters"
+                  + ", it should accept no parameters, or a single Context");
+        } else {
+          VariableElement parameter = parameters.get(0);
+          TypeMirror parameterType = parameter.asType();
+          TypeMirror contextType =
+              processingEnv.getElementUtils().getTypeElement("android.content.Context").asType();
+          if (!processingEnv.getTypeUtils().isSameType(parameterType, contextType)) {
+            throw new IllegalStateException("Unrecognized type: " + parameterType);
+          }
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private MethodSpec generateConstructor(
+      ClassName appGlideModule,
+      Collection<String> libraryGlideModuleClassNames,
+      Collection<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder constructorBuilder =
+        MethodSpec.constructorBuilder()
+            .addModifiers(Modifier.PUBLIC)
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("android.content", "Context"), "context")
+                    .build());
+
+    if (doesAppGlideModuleConstructorAcceptContext(appGlideModule)) {
+      constructorBuilder.addStatement("appGlideModule = new $T(context)", appGlideModule);
+    } else {
+      constructorBuilder.addStatement("appGlideModule = new $T()", appGlideModule);
+    }
 
     ClassName androidLogName = ClassName.get("android.util", "Log");
 
     // Add some log lines to indicate to developers which modules where discovered.
-    constructorBuilder.beginControlFlow("if ($T.isLoggable($S, $T.DEBUG))",
-        androidLogName, GLIDE_LOG_TAG, androidLogName);
-    constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+    constructorBuilder.beginControlFlow(
+        "if ($T.isLoggable($S, $T.DEBUG))", androidLogName, GLIDE_LOG_TAG, androidLogName);
+    constructorBuilder.addStatement(
+        "$T.d($S, $S)",
+        androidLogName,
+        GLIDE_LOG_TAG,
         "Discovered AppGlideModule from annotation: " + appGlideModule);
     // Excluded GlideModule classes from the manifest are logged in Glide's singleton.
     for (String glideModule : libraryGlideModuleClassNames) {
-      ClassName moduleClassName = ClassName.bestGuess(glideModule);
       if (excludedGlideModuleClassNames.contains(glideModule)) {
-        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
-            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);
+        constructorBuilder.addStatement(
+            "$T.d($S, $S)",
+            androidLogName,
+            GLIDE_LOG_TAG,
+            "AppGlideModule excludes LibraryGlideModule from annotation: " + glideModule);
       } else {
-        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
-            "Discovered LibraryGlideModule from annotation: " + moduleClassName);
+        constructorBuilder.addStatement(
+            "$T.d($S, $S)",
+            androidLogName,
+            GLIDE_LOG_TAG,
+            "Discovered LibraryGlideModule from annotation: " + glideModule);
       }
     }
     constructorBuilder.endControlFlow();
     return constructorBuilder.build();
   }
 
-  private Set<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
-    return processorUtil.findClassValuesFromAnnotationOnClassAsNames(
-        appGlideModule, Excludes.class);
+  private List<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
+    Set<String> names =
+        processorUtil.findClassValuesFromAnnotationOnClassAsNames(appGlideModule, Excludes.class);
+    List<String> result = new ArrayList<>(names);
+    Collections.sort(result);
+    return result;
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
index 063f8681a..1d2f8b8f5 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -14,9 +14,8 @@
 import javax.lang.model.element.TypeElement;
 
 /**
- * Runs the final steps of Glide's annotation process and generates the combined
- * {@code AppGlideModule}, {@code com.bumptech.glide.Glide},
- * {@code com.bumptech.glide.RequestManager}, and
+ * Runs the final steps of Glide's annotation process and generates the combined {@code
+ * AppGlideModule}, {@code com.bumptech.glide.Glide}, {@code com.bumptech.glide.RequestManager}, and
  * {@code com.bumptech.glide.request.RequestOptions} classes.
  */
 final class AppModuleProcessor {
@@ -37,20 +36,21 @@
     this.processingEnv = processingEnv;
     this.processorUtil = processorUtil;
 
-    appModuleGenerator = new AppModuleGenerator(processorUtil);
+    appModuleGenerator = new AppModuleGenerator(processingEnv, processorUtil);
     requestOptionsGenerator = new RequestOptionsGenerator(processingEnv, processorUtil);
     requestManagerGenerator = new RequestManagerGenerator(processingEnv, processorUtil);
-    requestManagerFactoryGenerator = new RequestManagerFactoryGenerator(processingEnv);
+    requestManagerFactoryGenerator =
+        new RequestManagerFactoryGenerator(processingEnv, processorUtil);
     glideGenerator = new GlideGenerator(processingEnv, processorUtil);
     requestBuilderGenerator = new RequestBuilderGenerator(processingEnv, processorUtil);
   }
 
   void processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
-     for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
-       if (processorUtil.isAppGlideModule(element)) {
-         appGlideModules.add(element);
-       }
-     }
+    for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+      if (processorUtil.isAppGlideModule(element)) {
+        appGlideModules.add(element);
+      }
+    }
 
     processorUtil.debugLog("got app modules: " + appGlideModules);
 
@@ -84,16 +84,19 @@ boolean maybeWriteAppModule() {
     String generatedCodePackageName = appModule.getEnclosingElement().toString();
 
     TypeSpec generatedRequestOptions =
-          requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
-      writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
+        requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
+    writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
 
     TypeSpec generatedRequestBuilder =
-        requestBuilderGenerator.generate(generatedCodePackageName, generatedRequestOptions);
+        requestBuilderGenerator.generate(
+            generatedCodePackageName, indexedClassNames.extensions, generatedRequestOptions);
     writeRequestBuilder(generatedCodePackageName, generatedRequestBuilder);
 
     TypeSpec requestManager =
         requestManagerGenerator.generate(
-            generatedCodePackageName, generatedRequestOptions, generatedRequestBuilder,
+            generatedCodePackageName,
+            generatedRequestOptions,
+            generatedRequestBuilder,
             indexedClassNames.extensions);
     writeRequestManager(generatedCodePackageName, requestManager);
 
@@ -166,8 +169,8 @@ private void writeRequestBuilder(String packageName, TypeSpec requestBuilder) {
   }
 
   private static final class FoundIndexedClassNames {
-    final Set<String> glideModules;
-    final Set<String> extensions;
+    private final Set<String> glideModules;
+    private final Set<String> extensions;
 
     private FoundIndexedClassNames(Set<String> glideModules, Set<String> extensions) {
       this.glideModules = glideModules;
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
index 4d6ac80c8..0e0ebfd1d 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
@@ -5,27 +5,33 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.TypeElement;
 
 /**
- * Writes Indexer classes annotated with {@link Index} for all
- * classes found annotated with {@link GlideExtension}.
+ * Writes Indexer classes annotated with {@link Index} for all classes found annotated with {@link
+ * GlideExtension}.
  */
 final class ExtensionProcessor {
   private final ProcessorUtil processorUtil;
   private final IndexerGenerator indexerGenerator;
+  private final GlideExtensionValidator extensionValidator;
 
-  ExtensionProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+  ExtensionProcessor(
+      ProcessingEnvironment processingEnvironment,
+      ProcessorUtil processorUtil,
+      IndexerGenerator indexerGenerator) {
     this.processorUtil = processorUtil;
     this.indexerGenerator = indexerGenerator;
+    extensionValidator = new GlideExtensionValidator(processingEnvironment, processorUtil);
   }
 
-  boolean processExtensions(Set<? extends TypeElement> set, RoundEnvironment env) {
+  boolean processExtensions(RoundEnvironment env) {
     List<TypeElement> elements = processorUtil.getElementsFor(GlideExtension.class, env);
     processorUtil.debugLog("Processing types : " + elements);
     for (TypeElement typeElement : elements) {
-      GlideExtensionValidator.validateExtension(typeElement);
+      extensionValidator.validateExtension(typeElement);
       processorUtil.debugLog("Processing elements: " + typeElement.getEnclosedElements());
     }
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
index 0c356b316..e7c6250dd 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -16,52 +16,48 @@
  * Generates classes based on Glide's annotations that configure Glide, add support for additional
  * resource types, and/or extend Glide's API.
  *
- * <p>This processor discovers all {@code AppGlideModule} and
- * {@code LibraryGlideModule} implementations that are
- * annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any implementations missing the
- * annotation will be ignored.
+ * <p>This processor discovers all {@code AppGlideModule} and {@code LibraryGlideModule}
+ * implementations that are annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any
+ * implementations missing the annotation will be ignored.
  *
  * <p>This processor also discovers all {@link com.bumptech.glide.annotation.GlideExtension}
  * annotated classes.
  *
  * <p>Multiple classes are generated by this processor:
+ *
  * <ul>
- *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a
- *      specific package that will later be used by the processor to discover all
- *      {@code LibraryGlideModule} classes.
- *   <li>For {@code AppGlideModule}s - A single
- *      {@code AppGlideModule} implementation
- *     ({@code com.bumptech.glide.GeneratedAppGlideModule}) that calls all
- *     {@code LibraryGlideModule}s and the
- *     original {@code AppGlideModule} in the correct order when Glide is
- *     initialized.
+ *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a specific package that will
+ *       later be used by the processor to discover all {@code LibraryGlideModule} classes.
+ *   <li>For {@code AppGlideModule}s - A single {@code AppGlideModule} implementation ({@code
+ *       com.bumptech.glide.GeneratedAppGlideModule}) that calls all {@code LibraryGlideModule}s and
+ *       the original {@code AppGlideModule} in the correct order when Glide is initialized.
  *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
- *   <ul>
- *     <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains
- *     static versions of all builder methods in the base class and both static and instance
- *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
- *     <li>If one or more methods in one or more
- *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
- *     {@link GlideType}:
- *     <ul>
- *       <li>A {@code com.bumptech.glide.RequestManager} implementation containing a generated
- *       method for each method annotated with
- *       {@link GlideType}.
- *       <li>A {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
- *       implementation that produces the generated {@code com.bumptech.glide.RequestManager}s.
- *       <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static methods in
- *       the {@code com.bumptech.glide.Glide} singleton and returns the generated
- *       {@code com.bumptech.glide.RequestManager} implementation when appropriate.
- *     </ul>
- *   </ul>
+ *       <ul>
+ *         <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains
+ *             static versions of all builder methods in the base class and both static and instance
+ *             versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
+ *         <li>If one or more methods in one or more {@link
+ *             com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
+ *             {@link GlideType}:
+ *             <ul>
+ *               <li>A {@code com.bumptech.glide.RequestManager} implementation containing a
+ *                   generated method for each method annotated with {@link GlideType}.
+ *               <li>A {@code
+ *                   com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ *                   implementation that produces the generated {@code
+ *                   com.bumptech.glide.RequestManager}s.
+ *               <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static
+ *                   methods in the {@code com.bumptech.glide.Glide} singleton and returns the
+ *                   generated {@code com.bumptech.glide.RequestManager} implementation when
+ *                   appropriate.
+ *             </ul>
+ *       </ul>
  * </ul>
  *
- * <p>{@code AppGlideModule} implementations must only be included in
- * applications, not in libraries. There must be exactly one
- * {@code AppGlideModule} implementation per
- * Application. The {@code AppGlideModule} class is
- * used as a signal that all modules have been found and that the final merged
- * {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
+ * <p>{@code AppGlideModule} implementations must only be included in applications, not in
+ * libraries. There must be exactly one {@code AppGlideModule} implementation per Application. The
+ * {@code AppGlideModule} class is used as a signal that all modules have been found and that the
+ * final merged {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
  */
 @AutoService(Processor.class)
 public final class GlideAnnotationProcessor extends AbstractProcessor {
@@ -79,7 +75,8 @@ public synchronized void init(ProcessingEnvironment processingEnvironment) {
     IndexerGenerator indexerGenerator = new IndexerGenerator(processorUtil);
     libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);
     appModuleProcessor = new AppModuleProcessor(processingEnvironment, processorUtil);
-    extensionProcessor = new ExtensionProcessor(processorUtil, indexerGenerator);
+    extensionProcessor =
+        new ExtensionProcessor(processingEnvironment, processorUtil, indexerGenerator);
   }
 
   @Override
@@ -95,25 +92,25 @@ public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
   }
 
-   /**
-    * Each round we do the following:
-    * <ol>
-    *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1).
-    *   <li>Find all {@code LibraryGlideModule}s
-    *   <li>For each {@code LibraryGlideModule},
-    *       write an {@code Indexer} with an Annotation with the class name.
-    *   <li>If we wrote any {@code Indexer}s, return and wait for the next round.
-    *   <li>If we didn't write any {@code Indexer}s and there is a {@code AppGlideModule},
-    *       write the {@code GeneratedAppGlideModule}.
-    *       Once the {@code GeneratedAppGlideModule} is written, we expect to be finished.
-    *       Any further generation of related classes will result in errors.
-    * </ol>
-    */
+  /**
+   * Each round we do the following:
+   *
+   * <ol>
+   *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1).
+   *   <li>Find all {@code LibraryGlideModule}s
+   *   <li>For each {@code LibraryGlideModule}, write an {@code Indexer} with an Annotation with the
+   *       class name.
+   *   <li>If we wrote any {@code Indexer}s, return and wait for the next round.
+   *   <li>If we didn't write any {@code Indexer}s and there is a {@code AppGlideModule}, write the
+   *       {@code GeneratedAppGlideModule}. Once the {@code GeneratedAppGlideModule} is written, we
+   *       expect to be finished. Any further generation of related classes will result in errors.
+   * </ol>
+   */
   @Override
   public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {
     processorUtil.process();
-    boolean newModulesWritten = libraryModuleProcessor.processModules(set, env);
-    boolean newExtensionWritten = extensionProcessor.processExtensions(set, env);
+    boolean newModulesWritten = libraryModuleProcessor.processModules(env);
+    boolean newExtensionWritten = extensionProcessor.processExtensions(env);
     appModuleProcessor.processModules(set, env);
 
     if (newExtensionWritten || newModulesWritten) {
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
index 488c5578f..6d4652b76 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -1,15 +1,26 @@
 package com.bumptech.glide.annotation.compiler;
 
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNulls;
+
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.squareup.javapoet.ClassName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
 
 /**
  * Validates that classes annotated with {@link com.bumptech.glide.annotation.GlideExtension}
@@ -20,75 +31,262 @@
  * for an Application.
  */
 final class GlideExtensionValidator {
+  private final ProcessingEnvironment processingEnvironment;
+  private final ProcessorUtil processorUtil;
 
-  private GlideExtensionValidator() { }
+  GlideExtensionValidator(
+      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
+    this.processingEnvironment = processingEnvironment;
+    this.processorUtil = processorUtil;
+  }
 
-  static void validateExtension(TypeElement typeElement) {
+  void validateExtension(TypeElement typeElement) {
     if (!typeElement.getModifiers().contains(Modifier.PUBLIC)) {
-      throw new IllegalArgumentException("RequestOptionsExtensions must be public");
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, including: " + getName(typeElement));
     }
     for (Element element : typeElement.getEnclosedElements()) {
       if (element.getKind() == ElementKind.CONSTRUCTOR) {
-        if (!element.getModifiers().contains(Modifier.PRIVATE)) {
-          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
-              + " constructors and only static methods. Found a non-private constructor");
-        }
-        ExecutableElement executableElement = (ExecutableElement) element;
-        if (!executableElement.getParameters().isEmpty()) {
-          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
-              + " constructors and only static methods. Found parameters in the constructor");
-        }
-        continue;
-      }
-      if (element.getKind() == ElementKind.METHOD) {
+        validateExtensionConstructor(element);
+      } else if (element.getKind() == ElementKind.METHOD) {
         ExecutableElement executableElement = (ExecutableElement) element;
         if (executableElement.getAnnotation(GlideOption.class) != null) {
-          validateExtendsRequestOptions(executableElement);
+          validateGlideOption(executableElement);
         } else if (executableElement.getAnnotation(GlideType.class) != null) {
-          validateExtendsRequestManager(executableElement);
+          validateGlideType(executableElement);
         }
       }
     }
   }
 
-  private static void validateExtendsRequestOptions(ExecutableElement executableElement) {
-    validateStaticVoid(executableElement, GlideOption.class);
+  private static String getQualifiedMethodName(ExecutableElement executableElement) {
+    return getEnclosingClassName(executableElement) + "#" + getName(executableElement);
+  }
+
+  private static String getEnclosingClassName(Element element) {
+    return element.getEnclosingElement().toString();
+  }
+
+  private static String getName(Element element) {
+    return element.toString();
+  }
+
+  private static void validateExtensionConstructor(Element element) {
+    if (!element.getModifiers().contains(Modifier.PRIVATE)) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found a non-private constructor in: "
+              + getEnclosingClassName(element));
+    }
+    ExecutableElement executableElement = (ExecutableElement) element;
+    if (!executableElement.getParameters().isEmpty()) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found parameters in the constructor of: "
+              + getEnclosingClassName(element));
+    }
+  }
+
+  private void validateGlideOption(ExecutableElement executableElement) {
+    validateGlideOptionAnnotations(executableElement);
+    validateGlideOptionParameters(executableElement);
+    TypeMirror returnType = executableElement.getReturnType();
+    if (!isBaseRequestOptions(returnType)) {
+      throw new IllegalArgumentException(
+          "@GlideOption methods should return a"
+              + " BaseRequestOptions<?> object, but "
+              + getQualifiedMethodName(executableElement)
+              + " returns "
+              + returnType
+              + ". If you're using old style @GlideOption methods, your"
+              + " method may have a void return type, but doing so is deprecated and support will"
+              + " be removed in a future version");
+    }
+    validateGlideOptionOverride(executableElement);
+  }
+
+  private void validateGlideOptionAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private static void validateGlideOptionParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().isEmpty()) {
-      throw new IllegalArgumentException("@GlideOption methods must take a "
-          + "RequestOptions object as their first parameter, but given none");
+      throw new IllegalArgumentException(
+          "@GlideOption methods must take a "
+              + "BaseRequestOptions<?> object as their first parameter, but "
+              + getQualifiedMethodName(executableElement)
+              + " has none");
     }
     VariableElement first = executableElement.getParameters().get(0);
     TypeMirror expected = first.asType();
-    if (!expected.toString().equals(
-        "com.bumptech.glide.request.RequestOptions")) {
-      throw new IllegalArgumentException("@GlideOption methods must take a"
-          + " RequestOptions object as their first parameter, but given: " + expected);
+    if (!isBaseRequestOptions(expected)) {
+      throw new IllegalArgumentException(
+          "@GlideOption methods must take a"
+              + " BaseRequestOptions<?> object as their first parameter, but the first parameter"
+              + " in "
+              + getQualifiedMethodName(executableElement)
+              + " is "
+              + expected);
+    }
+  }
+
+  private static boolean isBaseRequestOptions(TypeMirror typeMirror) {
+    return typeMirror.toString().equals("com.bumptech.glide.request.BaseRequestOptions<?>");
+  }
+
+  private void validateGlideOptionOverride(ExecutableElement element) {
+    int overrideType = processorUtil.getOverrideType(element);
+    boolean isOverridingBaseRequestOptionsMethod = isMethodInBaseRequestOptions(element);
+    if (isOverridingBaseRequestOptionsMethod && overrideType == GlideOption.OVERRIDE_NONE) {
+      throw new IllegalArgumentException(
+          "Accidentally attempting to override a method in"
+              + " BaseRequestOptions. Add an 'override' value in the @GlideOption annotation"
+              + " if this is intentional. Offending method: "
+              + getQualifiedMethodName(element));
+    } else if (!isOverridingBaseRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {
+      throw new IllegalArgumentException(
+          "Requested to override an existing method in"
+              + " BaseRequestOptions, but no such method was found. Offending method: "
+              + getQualifiedMethodName(element));
     }
   }
 
-  private static void validateExtendsRequestManager(ExecutableElement executableElement) {
-    validateStaticVoid(executableElement, GlideType.class);
+  private boolean isMethodInBaseRequestOptions(ExecutableElement toFind) {
+    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
+    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
+    // first type.
+    TypeElement requestOptionsType =
+        processingEnvironment
+            .getElementUtils()
+            .getTypeElement(RequestOptionsGenerator.BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
+    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
+    String toFindSimpleName = toFind.getSimpleName().toString();
+    for (Element element : requestOptionsType.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.METHOD) {
+        continue;
+      }
+      ExecutableElement inBase = (ExecutableElement) element;
+      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
+        List<String> parameterNamesInBase =
+            getComparableParameterNames(inBase, false /*skipFirst*/);
+        if (parameterNamesInBase.equals(toFindParameterNames)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static List<String> getComparableParameterNames(
+      ExecutableElement element, boolean skipFirst) {
+    List<? extends VariableElement> parameters = element.getParameters();
+    if (skipFirst) {
+      parameters = parameters.subList(1, parameters.size());
+    }
+    List<String> result = new ArrayList<>(parameters.size());
+    for (VariableElement parameter : parameters) {
+      result.add(parameter.asType().toString());
+    }
+    return result;
+  }
+
+  private void validateGlideType(ExecutableElement executableElement) {
+    TypeMirror returnType = executableElement.getReturnType();
+    validateGlideTypeAnnotations(executableElement);
+    if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {
+      String expectedClassName = getGlideTypeValue(executableElement);
+      throw new IllegalArgumentException(
+          "@GlideType methods should return a RequestBuilder<"
+              + expectedClassName
+              + "> object, but "
+              + getQualifiedMethodName(executableElement)
+              + " returns: "
+              + returnType
+              + ". If you're using old style @GlideType methods, your"
+              + " method may have a void return type, but doing so is deprecated and support will"
+              + " be removed in a future version");
+    }
+    validateGlideTypeParameters(executableElement);
+  }
+
+  private String getGlideTypeValue(ExecutableElement executableElement) {
+    return processorUtil
+        .findClassValuesFromAnnotationOnClassAsNames(executableElement, GlideType.class)
+        .iterator()
+        .next();
+  }
+
+  private boolean typeMatchesExpected(TypeMirror returnType, ExecutableElement executableElement) {
+    if (!(returnType instanceof DeclaredType)) {
+      return false;
+    }
+    List<? extends TypeMirror> typeArguments = ((DeclaredType) returnType).getTypeArguments();
+    if (typeArguments.size() != 1) {
+      return false;
+    }
+    TypeMirror argument = typeArguments.get(0);
+    String expected = getGlideTypeValue(executableElement);
+    return argument.toString().equals(expected);
+  }
+
+  private boolean isRequestBuilder(TypeMirror typeMirror) {
+    TypeMirror toCompare = processingEnvironment.getTypeUtils().erasure(typeMirror);
+    return toCompare.toString().equals("com.bumptech.glide.RequestBuilder");
+  }
+
+  private static void validateGlideTypeParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().size() != 1) {
-      throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestOptions object as their first and only parameter, found multiple for: "
-      + executableElement.getEnclosingElement() + "#" + executableElement);
+      throw new IllegalArgumentException(
+          "@GlideType methods must take a"
+              + " RequestBuilder object as their first and only parameter, but given multiple for: "
+              + getQualifiedMethodName(executableElement));
     }
 
     VariableElement first = executableElement.getParameters().get(0);
-    TypeMirror expected = first.asType();
-    if (!expected.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
-      throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestBuilder object as their first parameter, but given: " + expected);
+    TypeMirror argumentType = first.asType();
+    if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
+      throw new IllegalArgumentException(
+          "@GlideType methods must take a"
+              + " RequestBuilder object as their first and only parameter, but given: "
+              + argumentType
+              + " for: "
+              + getQualifiedMethodName(executableElement));
     }
   }
 
-  private static void validateStaticVoid(ExecutableElement executableElement, Class<?> clazz) {
-    if (!executableElement.getModifiers().contains(Modifier.STATIC)) {
-      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must be static");
+  private void validateGlideTypeAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private void validateAnnotatedNonNull(ExecutableElement executableElement) {
+    Set<String> annotationNames =
+        FluentIterable.from(executableElement.getAnnotationMirrors())
+            .transform(
+                new Function<AnnotationMirror, String>() {
+                  @Override
+                  public String apply(AnnotationMirror input) {
+                    return input.getAnnotationType().asElement().toString();
+                  }
+                })
+            .toSet();
+    boolean noNonNull = true;
+    for (ClassName nonNull : nonNulls()) {
+      if (annotationNames.contains(nonNull.reflectionName())) {
+        noNonNull = false;
+        break;
+      }
     }
-    TypeMirror returnType = executableElement.getReturnType();
-    if (returnType.getKind() != TypeKind.VOID) {
-      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must return void");
+    if (noNonNull) {
+      processingEnvironment
+          .getMessager()
+          .printMessage(
+              Kind.WARNING,
+              getQualifiedMethodName(executableElement)
+                  + " is missing the "
+                  + processorUtil.nonNull().reflectionName()
+                  + " annotation,"
+                  + " please add it to ensure that your extension methods are always returning"
+                  + " non-null values");
     }
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
index b367a9999..1f70b8ccd 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -7,6 +7,7 @@
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.MethodSpec.Builder;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
 import java.util.ArrayList;
@@ -16,15 +17,15 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.Elements;
 
 /**
  * Generates a Glide look-alike that acts as the entry point to the generated API
  * (GlideApp.with(...)).
  *
- * <p>>Generated {@code com.bumptech.glide.Glide} look-alikes look like this (note that the name
- * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
+ * <p>Generated {@code com.bumptech.glide.Glide} look-alikes look like this (note that the name is
+ * configurable in {@link com.bumptech.glide.annotation.GlideModule}):
+ *
  * <pre>
  * <code>
  * public final class GlideApp {
@@ -63,26 +64,19 @@
  *     return (GeneratedRequestManager) Glide.with(fragment);
  *   }
  *
- *   public static GeneratedRequestManager with(android.support.v4.app.Fragment fragment) {
+ *   public static GeneratedRequestManager with(androidx.fragment.app.Fragment fragment) {
  *     return (GeneratedRequestManager) Glide.with(fragment);
  *   }
  * </code>
  * </pre>
  */
 final class GlideGenerator {
-  private static final String GLIDE_QUALIFIED_NAME =
-      "com.bumptech.glide.Glide";
-
-  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
-      "com.bumptech.glide.RequestManager";
+  private static final String GLIDE_QUALIFIED_NAME = "com.bumptech.glide.Glide";
 
-  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME =
-      "android.support.annotation.VisibleForTesting";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME = "com.bumptech.glide.RequestManager";
 
-  private static final String SUPPRESS_LINT_PACKAGE_NAME =
-      "android.annotation";
-  private static final String SUPPRESS_LINT_CLASS_NAME =
-      "SuppressLint";
+  private static final String SUPPRESS_LINT_PACKAGE_NAME = "android.annotation";
+  private static final String SUPPRESS_LINT_CLASS_NAME = "SuppressLint";
 
   private final ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
@@ -111,11 +105,11 @@ TypeSpec generate(
                 + "\n"
                 + "<p>This class is generated and should not be modified"
                 + "\n"
-                + "@see $T\n", GlideExtension.class, glideType)
+                + "@see $T\n",
+            GlideExtension.class,
+            glideType)
         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
-        .addMethod(MethodSpec.constructorBuilder()
-            .addModifiers(Modifier.PRIVATE)
-            .build())
+        .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build())
         .addMethods(
             generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager))
         .build();
@@ -123,7 +117,8 @@ TypeSpec generate(
 
   private List<MethodSpec> generateOverridesForGlideMethods(
       final String generatedCodePackageName, final TypeSpec generatedRequestManager) {
-    return Lists.transform(discoverGlideMethodsToOverride(),
+    return Lists.transform(
+        discoverGlideMethodsToOverride(),
         new Function<ExecutableElement, MethodSpec>() {
           @Override
           public MethodSpec apply(ExecutableElement input) {
@@ -138,7 +133,7 @@ public MethodSpec apply(ExecutableElement input) {
   }
 
   private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride) {
-    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);
 
     TypeElement element =
         (TypeElement) processingEnv.getTypeUtils().asElement(methodToOverride.getReturnType());
@@ -147,54 +142,56 @@ private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride)
         MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
             .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
-            .addParameters(Lists.transform(parameters,
-                new Function<VariableElement, ParameterSpec>() {
-                  @Override
-                  public ParameterSpec apply(VariableElement input) {
-                    return ParameterSpec.get(input);
-                  }
-            }));
-
-    TypeElement visibleForTestingType =
-        processingEnv
-            .getElementUtils()
-            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);
-    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
-      builder.addAnnotation(AnnotationSpec.get(mirror));
+            .addParameters(parameters);
 
-      // Suppress a lint warning if we're overriding a VisibleForTesting method.
-      // See #1977.
-      if (mirror.getAnnotationType().asElement().equals(visibleForTestingType)) {
-        builder.addAnnotation(
-            AnnotationSpec.builder(
-                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
-                .addMember("value", "$S", "VisibleForTests")
-                .build());
-      }
-    }
+    addReturnAnnotations(builder, methodToOverride);
 
     boolean returnsValue = element != null;
     if (returnsValue) {
       builder.returns(ClassName.get(element));
     }
 
-    String code = returnsValue ? "return " : "";
-    code += "$T.$N(";
+    StringBuilder code = new StringBuilder(returnsValue ? "return " : "");
+    code.append("$T.$N(");
     List<Object> args = new ArrayList<>();
     args.add(ClassName.get(glideType));
     args.add(methodToOverride.getSimpleName());
     if (!parameters.isEmpty()) {
-      for (VariableElement param : parameters) {
-        code += "$L, ";
-        args.add(param.getSimpleName());
+      for (ParameterSpec param : parameters) {
+        code.append("$L, ");
+        args.add(param.name);
       }
-      code = code.substring(0, code.length() - 2);
+      code = new StringBuilder(code.substring(0, code.length() - 2));
     }
-    code += ")";
-    builder.addStatement(code, args.toArray(new Object[0]));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
     return builder.build();
   }
 
+  private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {
+    Elements elements = processingEnv.getElementUtils();
+    TypeElement visibleForTestingTypeElement =
+        elements.getTypeElement(processorUtil.visibleForTesting().reflectionName());
+    String visibleForTestingTypeQualifiedName = visibleForTestingTypeElement.toString();
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+
+      // Suppress a lint warning if we're overriding a VisibleForTesting method.
+      // See #1977.
+      String annotationQualifiedName = mirror.getAnnotationType().toString();
+      if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {
+        builder.addAnnotation(
+            AnnotationSpec.builder(
+                    ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
+                .addMember("value", "$S", "VisibleForTests")
+                .build());
+      }
+    }
+
+    return builder;
+  }
+
   private List<ExecutableElement> discoverGlideMethodsToOverride() {
     return processorUtil.findStaticMethods(glideType);
   }
@@ -207,19 +204,24 @@ private MethodSpec overrideGlideWithMethod(
       String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {
     ClassName generatedRequestManagerClassName =
         ClassName.get(packageName, generatedRequestManager.name);
-    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);
     Preconditions.checkArgument(
         parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
-    VariableElement parameter = parameters.iterator().next();
-    return MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
-        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
-        .returns(generatedRequestManagerClassName)
-        .addParameter(ClassName.get(parameter.asType()), parameter.getSimpleName().toString())
-        .addStatement("return ($T) $T.$N($L)",
-            generatedRequestManagerClassName, glideType,
-            methodToOverride.getSimpleName().toString(),
-            parameter.getSimpleName())
-        .build();
+    ParameterSpec parameter = parameters.iterator().next();
+
+    Builder builder =
+        MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+            .addParameters(parameters)
+            .returns(generatedRequestManagerClassName)
+            .addStatement(
+                "return ($T) $T.$N($L)",
+                generatedRequestManagerClassName,
+                glideType,
+                methodToOverride.getSimpleName().toString(),
+                parameter.name);
+
+    return addReturnAnnotations(builder, methodToOverride).build();
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
index afae52f38..cd8038ce8 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
@@ -20,6 +20,7 @@
  * AppGlideModule in an application.
  *
  * <p>The output file generated by this class with a LibraryGlideModule looks like this:
+ *
  * <pre>
  * <code>
  *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
@@ -32,6 +33,7 @@
  * </pre>
  *
  * <p>The output file generated by this class with a GlideExtension looks like this:
+ *
  * <pre>
  * <code>
  *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
@@ -41,7 +43,6 @@
  *  }
  * </code>
  * </pre>
- * </p>
  */
 final class IndexerGenerator {
   private static final String INDEXER_NAME_PREFIX = "GlideIndexer_";
@@ -52,7 +53,7 @@
   }
 
   TypeSpec generate(List<TypeElement> types) {
-    List<TypeElement> modules =  new ArrayList<>();
+    List<TypeElement> modules = new ArrayList<>();
     List<TypeElement> extensions = new ArrayList<>();
     for (TypeElement element : types) {
       if (processorUtil.isExtension(element)) {
@@ -64,8 +65,12 @@ TypeSpec generate(List<TypeElement> types) {
       }
     }
     if (!modules.isEmpty() && !extensions.isEmpty()) {
-      throw new IllegalArgumentException("Given both modules and extensions, expected one or the "
-          + "other. Modules: " + modules + " Extensions: " + extensions);
+      throw new IllegalArgumentException(
+          "Given both modules and extensions, expected one or the "
+              + "other. Modules: "
+              + modules
+              + " Extensions: "
+              + extensions);
     }
     if (!modules.isEmpty()) {
       return generate(types, GlideModule.class);
@@ -74,24 +79,24 @@ TypeSpec generate(List<TypeElement> types) {
     }
   }
 
-  private static TypeSpec generate(List<TypeElement> libraryModules,
-      Class<? extends Annotation> annotation) {
-    AnnotationSpec.Builder annotationBuilder =
-        AnnotationSpec.builder(Index.class);
+  private static TypeSpec generate(
+      List<TypeElement> libraryModules, Class<? extends Annotation> annotation) {
+    AnnotationSpec.Builder annotationBuilder = AnnotationSpec.builder(Index.class);
 
     String value = getAnnotationValue(annotation);
     for (TypeElement childModule : libraryModules) {
       annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
     }
 
-    String indexerName = INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_";
+    StringBuilder indexerName =
+        new StringBuilder(INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");
     for (TypeElement element : libraryModules) {
-      indexerName += element.getQualifiedName().toString().replace(".", "_");
-      indexerName += "_";
+      indexerName.append(element.getQualifiedName().toString().replace(".", "_"));
+      indexerName.append("_");
     }
-    indexerName = indexerName.substring(0, indexerName.length() - 1);
+    indexerName = new StringBuilder(indexerName.substring(0, indexerName.length() - 1));
 
-    return TypeSpec.classBuilder(indexerName)
+    return TypeSpec.classBuilder(indexerName.toString())
         .addAnnotation(annotationBuilder.build())
         .addModifiers(Modifier.PUBLIC)
         .build();
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
index 85027ea18..96054f414 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
@@ -9,21 +9,18 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.TypeElement;
 
-/**
- * Generates Indexer classes annotated with {@link Index} for all
- * {@code LibraryGlideModule}s.
- */
+/** Generates Indexer classes annotated with {@link Index} for all {@code LibraryGlideModule}s. */
 final class LibraryModuleProcessor {
-  private ProcessorUtil processorUtil;
-  private IndexerGenerator indexerGenerator;
+  private final ProcessorUtil processorUtil;
+  private final IndexerGenerator indexerGenerator;
 
   LibraryModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
     this.processorUtil = processorUtil;
     this.indexerGenerator = indexerGenerator;
   }
 
-  boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
-     // Order matters here, if we find an Indexer below, we return before writing the root module.
+  boolean processModules(RoundEnvironment env) {
+    // Order matters here, if we find an Indexer below, we return before writing the root module.
     // If we fail to add to appModules before then, we might accidentally skip a valid RootModule.
     List<TypeElement> libraryGlideModules = new ArrayList<>();
     for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
@@ -32,8 +29,10 @@ boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
       if (processorUtil.isAppGlideModule(element)) {
         continue;
       } else if (!processorUtil.isLibraryGlideModule(element)) {
-        throw new IllegalStateException("@GlideModule can only be applied to LibraryGlideModule"
-            + " and AppGlideModule implementations, not: " + element);
+        throw new IllegalStateException(
+            "@GlideModule can only be applied to LibraryGlideModule"
+                + " and AppGlideModule implementations, not: "
+                + element);
       }
 
       libraryGlideModules.add(element);
@@ -46,9 +45,10 @@ boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
 
     TypeSpec indexer = indexerGenerator.generate(libraryGlideModules);
     processorUtil.writeIndexer(indexer);
-    processorUtil.debugLog("Wrote an Indexer this round, skipping the app module to ensure all "
-        + "indexers are found");
-     // If I write an Indexer in a round in the target package, then try to find all classes in
+    processorUtil.debugLog(
+        "Wrote an Indexer this round, skipping the app module to ensure all "
+            + "indexers are found");
+    // If I write an Indexer in a round in the target package, then try to find all classes in
     // the target package, my newly written Indexer won't be found. Since we wrote a class with
     // an Annotation handled by this processor, we know we will be called again in the next round
     // and we can safely wait to write our AppGlideModule until then.
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
index ff0dbb20f..7ead6eb16 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -3,10 +3,12 @@
 import static com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor.DEBUG;
 
 import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
@@ -20,6 +22,8 @@
 import com.sun.tools.javac.code.Attribute;
 import com.sun.tools.javac.code.Type.ClassType;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -44,12 +48,11 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-/**
- * Utilities for writing classes and logging.
- */
+/** Utilities for writing classes and logging. */
 final class ProcessorUtil {
   private static final String GLIDE_MODULE_PACKAGE_NAME = "com.bumptech.glide.module";
   private static final String APP_GLIDE_MODULE_SIMPLE_NAME = "AppGlideModule";
@@ -60,6 +63,20 @@
       GLIDE_MODULE_PACKAGE_NAME + "." + LIBRARY_GLIDE_MODULE_SIMPLE_NAME;
   private static final String COMPILER_PACKAGE_NAME =
       GlideAnnotationProcessor.class.getPackage().getName();
+  private static final ClassName SUPPORT_NONNULL_ANNOTATION =
+      ClassName.get("android.support.annotation", "NonNull");
+  private static final ClassName JETBRAINS_NOTNULL_ANNOTATION =
+      ClassName.get("org.jetbrains.annotations", "NotNull");
+  private static final ClassName ANDROIDX_NONNULL_ANNOTATION =
+      ClassName.get("androidx.annotation", "NonNull");
+  private static final ClassName SUPPORT_CHECK_RESULT_ANNOTATION =
+      ClassName.get("android.support.annotation", "CheckResult");
+  private static final ClassName ANDROIDX_CHECK_RESULT_ANNOTATION =
+      ClassName.get("androidx.annotation", "CheckResult");
+  private static final ClassName SUPPORT_VISIBLE_FOR_TESTING =
+      ClassName.get("android.support.annotation", "VisibleForTesting");
+  private static final ClassName ANDROIDX_VISIBLE_FOR_TESTING =
+      ClassName.get("androidx.annotation", "VisibleForTesting");
 
   private final ProcessingEnvironment processingEnv;
   private final TypeElement appGlideModuleType;
@@ -80,19 +97,24 @@ void process() {
   }
 
   boolean isAppGlideModule(TypeElement element) {
-    return processingEnv.getTypeUtils().isAssignable(element.asType(),
-        appGlideModuleType.asType());
+    return processingEnv.getTypeUtils().isAssignable(element.asType(), appGlideModuleType.asType());
   }
 
   boolean isLibraryGlideModule(TypeElement element) {
-    return processingEnv.getTypeUtils().isAssignable(element.asType(),
-        libraryGlideModuleType.asType());
+    return processingEnv
+        .getTypeUtils()
+        .isAssignable(element.asType(), libraryGlideModuleType.asType());
   }
 
   boolean isExtension(TypeElement element) {
     return element.getAnnotation(GlideExtension.class) != null;
   }
 
+  int getOverrideType(ExecutableElement element) {
+    GlideOption glideOption = element.getAnnotation(GlideOption.class);
+    return glideOption.override();
+  }
+
   void writeIndexer(TypeSpec indexer) {
     writeClass(COMPILER_PACKAGE_NAME, indexer);
   }
@@ -100,7 +122,10 @@ void writeIndexer(TypeSpec indexer) {
   void writeClass(String packageName, TypeSpec clazz) {
     try {
       debugLog("Writing class:\n" + clazz);
-      JavaFile.builder(packageName, clazz).build().writeTo(processingEnv.getFiler());
+      JavaFile.builder(packageName, clazz)
+          .skipJavaLangImports(true)
+          .build()
+          .writeTo(processingEnv.getFiler());
     } catch (Throwable e) {
       throw new RuntimeException(e);
     }
@@ -110,8 +135,8 @@ void writeClass(String packageName, TypeSpec clazz) {
       Set<String> classNames, Class<? extends Annotation> annotationClass) {
     List<ExecutableElement> result = new ArrayList<>();
     for (String glideExtensionClassName : classNames) {
-      TypeElement glideExtension = processingEnv.getElementUtils()
-          .getTypeElement(glideExtensionClassName);
+      TypeElement glideExtension =
+          processingEnv.getElementUtils().getTypeElement(glideExtensionClassName);
       for (Element element : glideExtension.getEnclosedElements()) {
         if (element.getAnnotation(annotationClass) != null) {
           result.add((ExecutableElement) element);
@@ -121,17 +146,17 @@ void writeClass(String packageName, TypeSpec clazz) {
     return result;
   }
 
-  List<TypeElement> getElementsFor(
-      Class<? extends Annotation> clazz, RoundEnvironment env) {
+  List<TypeElement> getElementsFor(Class<? extends Annotation> clazz, RoundEnvironment env) {
     Collection<? extends Element> annotatedElements = env.getElementsAnnotatedWith(clazz);
     return ElementFilter.typesIn(annotatedElements);
   }
 
   /**
-   * Generates a Javadoc code block for generated methods that delegate to methods in
-   * {@link GlideExtension}s.
+   * Generates a Javadoc code block for generated methods that delegate to methods in {@link
+   * GlideExtension}s.
    *
    * <p>The generated block looks something like this:
+   *
    * <pre>
    * <code>
    *   {@literal @see} com.extension.package.name.ExtensionClassName#extensionMethod(arg1, argN)
@@ -139,7 +164,7 @@ void writeClass(String packageName, TypeSpec clazz) {
    * </pre>
    *
    * @param method The method from the {@link GlideExtension} annotated class that the generated
-   * method this Javadoc will be attached to delegates to.
+   *     method this Javadoc will be attached to delegates to.
    */
   CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
     // Use the simple name of the containing type instead of just the containing type's TypeMirror
@@ -148,30 +173,38 @@ CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
     // With this we get @see RequestOptions#methodName().
     // With just ClassName.get(element.getEnclosingElement().asType()), we get:
     // @see RequestOptions<CHILD>#methodName().
-    return generateSeeMethodJavadoc(getJavadocSafeName(method.getEnclosingElement()),
-        method.getSimpleName().toString(), method.getParameters());
+    return generateSeeMethodJavadoc(
+        getJavadocSafeName(method.getEnclosingElement()),
+        method.getSimpleName().toString(),
+        method.getParameters());
   }
 
   /**
    * Generates a Javadoc block for generated methods that delegate to other methods.
    *
    * <p>The generated block looks something like this:
+   *
    * <pre>
    * <code>
    *     {@literal @see} com.package.ClassContainingMethod.methodSimpleName(
    *         methodParam1, methodParamN)
    * </code>
    * </pre>
+   *
    * @param nameOfClassContainingMethod The simple class name of the class containing the method
-   * without any generic types like {@literal <T>}.
+   *     without any generic types like {@literal <T>}.
    * @param methodSimpleName The name of the method.
    * @param methodParameters A maybe empty list of all the parameters for the method in question.
    */
   CodeBlock generateSeeMethodJavadoc(
-      TypeName nameOfClassContainingMethod, String methodSimpleName,
+      TypeName nameOfClassContainingMethod,
+      String methodSimpleName,
       List<? extends VariableElement> methodParameters) {
-    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
-        methodSimpleName, Lists.transform(methodParameters,
+    return generateSeeMethodJavadocInternal(
+        nameOfClassContainingMethod,
+        methodSimpleName,
+        Lists.transform(
+            methodParameters,
             new Function<VariableElement, Object>() {
               @Override
               public Object apply(VariableElement input) {
@@ -180,10 +213,12 @@ public Object apply(VariableElement input) {
             }));
   }
 
-  CodeBlock generateSeeMethodJavadoc(
-      TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {
-    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
-        methodSpec.name, Lists.transform(methodSpec.parameters,
+  CodeBlock generateSeeMethodJavadoc(TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {
+    return generateSeeMethodJavadocInternal(
+        nameOfClassContainingMethod,
+        methodSpec.name,
+        Lists.transform(
+            methodSpec.parameters,
             new Function<ParameterSpec, Object>() {
               @Override
               public Object apply(ParameterSpec input) {
@@ -193,30 +228,28 @@ public Object apply(ParameterSpec input) {
   }
 
   private CodeBlock generateSeeMethodJavadocInternal(
-      TypeName nameOfClassContainingMethod, String methodName,
-      List<Object> safeParameterNames) {
-     String javadocString = "@see $T#$L(";
+      TypeName nameOfClassContainingMethod, String methodName, List<Object> safeParameterNames) {
+    StringBuilder javadocString = new StringBuilder("@see $T#$L(");
     List<Object> javadocArgs = new ArrayList<>();
     javadocArgs.add(nameOfClassContainingMethod);
     javadocArgs.add(methodName);
 
     for (Object param : safeParameterNames) {
-      javadocString += "$T, ";
+      javadocString.append("$T, ");
       javadocArgs.add(param);
     }
     if (javadocArgs.size() > 2) {
-      javadocString = javadocString.substring(0, javadocString.length() - 2);
+      javadocString = new StringBuilder(javadocString.substring(0, javadocString.length() - 2));
     }
-    javadocString += ")\n";
-    return CodeBlock.of(javadocString, javadocArgs.toArray(new Object[0]));
+    javadocString.append(")\n");
+    return CodeBlock.of(javadocString.toString(), javadocArgs.toArray(new Object[0]));
   }
 
-
-   /**
+  /**
    * Returns a safe String to use in a Javadoc that will function in a link.
    *
-   * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
-   * in {@literal RequestOptions<T>} for example).
+   * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>} in
+   * {@literal RequestOptions<T>} for example).
    */
   private TypeName getJavadocSafeName(Element element) {
     Types typeUtils = processingEnv.getTypeUtils();
@@ -239,18 +272,18 @@ void infoLog(String toLog) {
     processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "[" + round + "] " + toLog);
   }
 
-  static CodeBlock generateCastingSuperCall(TypeName toReturn, ExecutableElement method) {
+  static CodeBlock generateCastingSuperCall(TypeName toReturn, MethodSpec method) {
     return CodeBlock.builder()
-        .add("return ($T) super.$N(", toReturn, method.getSimpleName())
+        .add("return ($T) super.$N(", toReturn, method.name)
         .add(
-            FluentIterable.from(method.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Nullable
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
+            FluentIterable.from(method.parameters)
+                .transform(
+                    new Function<ParameterSpec, String>() {
+                      @Override
+                      public String apply(ParameterSpec input) {
+                        return input.name;
+                      }
+                    })
                 .join(Joiner.on(",")))
         .add(");\n")
         .build();
@@ -259,8 +292,7 @@ public String apply(VariableElement input) {
   static MethodSpec.Builder overriding(ExecutableElement method) {
     String methodName = method.getSimpleName().toString();
 
-    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
-        .addAnnotation(Override.class);
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName).addAnnotation(Override.class);
 
     Set<Modifier> modifiers = method.getModifiers();
     modifiers = new LinkedHashSet<>(modifiers);
@@ -281,9 +313,11 @@ public String apply(VariableElement input) {
       builder = builder.addTypeVariable(TypeVariableName.get(var));
     }
 
-    builder = builder.returns(TypeName.get(method.getReturnType()))
-        .addParameters(getParameters(method))
-        .varargs(method.isVarArgs());
+    builder =
+        builder
+            .returns(TypeName.get(method.getReturnType()))
+            .addParameters(getParameters(method))
+            .varargs(method.isVarArgs());
 
     for (TypeMirror thrownType : method.getThrownTypes()) {
       builder = builder.addException(TypeName.get(thrownType));
@@ -301,18 +335,121 @@ public String apply(VariableElement input) {
     for (VariableElement parameter : parameters) {
       result.add(getParameter(parameter));
     }
-    return result;
+    return dedupedParameters(result);
+  }
+
+  private static List<ParameterSpec> dedupedParameters(List<ParameterSpec> parameters) {
+    boolean hasDupes = false;
+    Set<String> names = new HashSet<>();
+    for (ParameterSpec parameter : parameters) {
+      String name = parameter.name;
+      if (names.contains(name)) {
+        hasDupes = true;
+      } else {
+        names.add(name);
+      }
+    }
+
+    if (hasDupes) {
+      List<ParameterSpec> copy = parameters;
+      parameters = new ArrayList<>();
+      for (int i = 0; i < copy.size(); i++) {
+        ParameterSpec parameter = copy.get(i);
+        parameters.add(
+            ParameterSpec.builder(parameter.type, parameter.name + i)
+                .addModifiers(parameter.modifiers)
+                .addAnnotations(parameter.annotations)
+                .build());
+      }
+    }
+
+    return parameters;
   }
 
-  private static ParameterSpec getParameter(VariableElement method) {
-    TypeName type = TypeName.get(method.asType());
-    String name = method.getSimpleName().toString();
-    return ParameterSpec.builder(type, name)
-        .addModifiers(method.getModifiers())
-        .addAnnotations(getAnnotations(method))
+  private static ParameterSpec getParameter(VariableElement parameter) {
+    TypeName type = TypeName.get(parameter.asType());
+    return ParameterSpec.builder(type, computeParameterName(parameter, type))
+        .addModifiers(parameter.getModifiers())
+        .addAnnotations(getAnnotations(parameter))
         .build();
   }
 
+  private static String computeParameterName(VariableElement parameter, TypeName type) {
+    String rawClassName = type.withoutAnnotations().toString();
+
+    String name;
+
+    if (type.isPrimitive() || type.isBoxedPrimitive()) {
+      name = getSmartPrimitiveParameterName(parameter);
+    } else {
+      if (rawClassName.contains("<") && rawClassName.contains(">")) {
+        String[] preGenericSplit = rawClassName.split("<");
+        String preGeneric = preGenericSplit[0];
+        String[] postGenericSplit = rawClassName.split(">");
+        String postGeneric = postGenericSplit[postGenericSplit.length - 1];
+        if (postGenericSplit.length > 1) {
+          rawClassName = preGeneric + postGeneric;
+        } else {
+          rawClassName = preGeneric;
+        }
+      }
+
+      String[] qualifiers = rawClassName.split("\\.");
+      rawClassName = qualifiers[qualifiers.length - 1];
+
+      rawClassName = applySmartParameterNameReplacements(rawClassName);
+
+      boolean allCaps = true;
+      for (char c : rawClassName.toCharArray()) {
+        if (Character.isLowerCase(c)) {
+          allCaps = false;
+          break;
+        }
+      }
+      if (allCaps) {
+        name = rawClassName.toLowerCase();
+      } else {
+        int indexOfLastWordStart = 0;
+        char[] chars = rawClassName.toCharArray();
+        for (int i = 0, charArrayLength = chars.length; i < charArrayLength; i++) {
+          char c = chars[i];
+          if (Character.isUpperCase(c)) {
+            indexOfLastWordStart = i;
+          }
+        }
+        rawClassName = rawClassName.substring(indexOfLastWordStart, rawClassName.length());
+
+        name =
+            Character.toLowerCase(rawClassName.charAt(0))
+                + rawClassName.substring(1, rawClassName.length());
+      }
+    }
+
+    return name;
+  }
+
+  private static String getSmartPrimitiveParameterName(VariableElement parameter) {
+    for (AnnotationMirror annotation : parameter.getAnnotationMirrors()) {
+      String annotationName = annotation.getAnnotationType().toString().toUpperCase();
+      if (annotationName.endsWith("RES")) {
+        // Catch annotations like StringRes
+        return "id";
+      } else if (annotationName.endsWith("RANGE")) {
+        // Catch annotations like IntRange
+        return "value";
+      }
+    }
+
+    return parameter.getSimpleName().toString();
+  }
+
+  private static String applySmartParameterNameReplacements(String name) {
+    name = name.replace("[]", "s");
+    name = name.replace(Class.class.getSimpleName(), "clazz");
+    name = name.replace(Object.class.getSimpleName(), "o");
+    return name;
+  }
+
   private static List<AnnotationSpec> getAnnotations(VariableElement element) {
     List<AnnotationSpec> result = new ArrayList<>();
     for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
@@ -321,6 +458,35 @@ private static ParameterSpec getParameter(VariableElement method) {
     return result;
   }
 
+  ClassName visibleForTesting() {
+    return findAnnotationClassName(ANDROIDX_VISIBLE_FOR_TESTING, SUPPORT_VISIBLE_FOR_TESTING);
+  }
+
+  ClassName nonNull() {
+    return findAnnotationClassName(ANDROIDX_NONNULL_ANNOTATION, SUPPORT_NONNULL_ANNOTATION);
+  }
+
+  ClassName checkResult() {
+    return findAnnotationClassName(
+        ANDROIDX_CHECK_RESULT_ANNOTATION, SUPPORT_CHECK_RESULT_ANNOTATION);
+  }
+
+  static List<ClassName> nonNulls() {
+    return ImmutableList.of(
+        SUPPORT_NONNULL_ANNOTATION, JETBRAINS_NOTNULL_ANNOTATION, ANDROIDX_NONNULL_ANNOTATION);
+  }
+
+  private ClassName findAnnotationClassName(ClassName androidxName, ClassName supportName) {
+    Elements elements = processingEnv.getElementUtils();
+    TypeElement visibleForTestingTypeElement =
+        elements.getTypeElement(androidxName.reflectionName());
+    if (visibleForTestingTypeElement != null) {
+      return androidxName;
+    }
+
+    return supportName;
+  }
+
   List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
     return FluentIterable.from(clazz.getEnclosedElements())
         .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
@@ -368,8 +534,13 @@ private static ParameterSpec getParameter(VariableElement method) {
         throw new IllegalArgumentException("Expected single value, but found: " + values);
       }
       excludedModuleAnnotationValue = values.iterator().next().getValue();
-      if (excludedModuleAnnotationValue == null) {
-        throw new NullPointerException("Failed to find Excludes#value");
+      if (excludedModuleAnnotationValue == null
+          || excludedModuleAnnotationValue instanceof Attribute.UnresolvedClass) {
+        throw new IllegalArgumentException(
+            "Failed to find value for: "
+                + annotationClass
+                + " from mirrors: "
+                + clazz.getAnnotationMirrors());
       }
     }
     if (excludedModuleAnnotationValue == null) {
@@ -377,11 +548,10 @@ private static ParameterSpec getParameter(VariableElement method) {
     }
     Object value = excludedModuleAnnotationValue.getValue();
     if (value instanceof List) {
-      List values = (List) value;
+      List<?> values = (List<?>) value;
       Set<String> result = new HashSet<>(values.size());
       for (Object current : values) {
-        Attribute.Class currentClass = (Attribute.Class) current;
-        result.add(currentClass.getValue().toString());
+        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));
       }
       return result;
     } else {
@@ -390,22 +560,49 @@ private static ParameterSpec getParameter(VariableElement method) {
     }
   }
 
+  // We should be able to cast to Attribute.Class rather than use reflection, but there are some
+  // compilers that seem to break when we do so. See #2673 for an example.
+  private static String getExcludedModuleClassFromAnnotationAttribute(
+      Element clazz, Object attribute) {
+    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {
+      throw new IllegalArgumentException(
+          "Failed to parse @Excludes for: "
+              + clazz
+              + ", one or more excluded Modules could not be found at compile time. Ensure that all"
+              + "excluded Modules are included in your classpath.");
+    }
+    Method[] methods = attribute.getClass().getDeclaredMethods();
+    if (methods == null || methods.length == 0) {
+      throw new IllegalArgumentException(
+          "Failed to parse @Excludes for: " + clazz + ", invalid exclude: " + attribute);
+    }
+    for (Method method : methods) {
+      if (method.getName().equals("getValue")) {
+        try {
+          return method.invoke(attribute).toString();
+        } catch (IllegalAccessException | InvocationTargetException e) {
+          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);
+        }
+      }
+    }
+    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);
+  }
+
   private enum MethodType {
     STATIC,
     INSTANCE
   }
 
   private final class FilterPublicMethods implements Predicate<Element> {
-    @Nullable
-    private final TypeMirror returnType;
+    @Nullable private final TypeMirror returnType;
     private final MethodType methodType;
 
-    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType)  {
+    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType) {
       this.returnType = returnType;
       this.methodType = methodType;
     }
 
-    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType)  {
+    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType) {
       this(returnType != null ? returnType.asType() : null, methodType);
     }
 
@@ -423,10 +620,7 @@ public boolean apply(@Nullable Element input) {
         return false;
       }
       ExecutableElement method = (ExecutableElement) input;
-      if (returnType == null) {
-        return true;
-      }
-      return isReturnValueTypeMatching(method, returnType);
+      return returnType == null || isReturnValueTypeMatching(method, returnType);
     }
   }
 
@@ -436,8 +630,7 @@ boolean isReturnValueTypeMatching(ExecutableElement method, TypeElement expected
 
   private boolean isReturnValueTypeMatching(
       ExecutableElement method, TypeMirror expectedReturnType) {
-    return processingEnv.getTypeUtils().isAssignable(
-        method.getReturnType(), expectedReturnType);
+    return processingEnv.getTypeUtils().isAssignable(method.getReturnType(), expectedReturnType);
   }
 
   private static final class ToMethod implements Function<Element, ExecutableElement> {
@@ -448,5 +641,4 @@ public ExecutableElement apply(@Nullable Element input) {
       return (ExecutableElement) input;
     }
   }
-
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
index 7e852e18a..a6152bc96 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -20,25 +20,27 @@
 import com.squareup.javapoet.TypeVariableName;
 import com.squareup.javapoet.WildcardTypeName;
 import java.io.File;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /**
- * Generates a {@code com.bumptech.glide.RequestBuilder} subclass containing all methods from
- * the base class, all methods from {@code com.bumptech.glide.request.RequestOptions} and all
- * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
- * classes.
+ * Generates a {@code com.bumptech.glide.RequestBuilder} subclass containing all methods from the
+ * base class, all methods from {@code com.bumptech.glide.request.RequestOptions} and all
+ * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated classes.
  *
  * <p>Generated code looks like this:
+ *
  * <pre>
  * <code>
  * public final class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> {
@@ -96,62 +98,68 @@
   private static final String GENERATED_REQUEST_BUILDER_SIMPLE_NAME = "GlideRequest";
 
   /**
-   * An arbitrary name of the Generic type in the generated RequestBuilder.
-   * e.g. RequestBuilder<TranscodeType>
+   * An arbitrary name of the Generic type in the generated RequestBuilder. e.g.
+   * RequestBuilder<TranscodeType>
    */
   private static final String TRANSCODE_TYPE_NAME = "TranscodeType";
   /** A set of method names to avoid overriding from RequestOptions. */
   private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =
       ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
-  private static final ClassName CHECK_RESULT_CLASS_NAME =
-      ClassName.get("android.support.annotation", "CheckResult");
 
   private final ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
-  private ClassName generatedRequestBuilderClassName;
   private final TypeVariableName transcodeTypeName;
-  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
   private final TypeElement requestOptionsType;
   private final TypeElement requestBuilderType;
+  private ClassName generatedRequestBuilderClassName;
   private ClassName requestOptionsClassName;
+  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
 
   RequestBuilderGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
     this.processingEnv = processingEnv;
     this.processorUtil = processorUtil;
 
-    requestBuilderType = processingEnv.getElementUtils()
-        .getTypeElement(REQUEST_BUILDER_QUALIFIED_NAME);
+    requestBuilderType =
+        processingEnv.getElementUtils().getTypeElement(REQUEST_BUILDER_QUALIFIED_NAME);
 
     transcodeTypeName = TypeVariableName.get(TRANSCODE_TYPE_NAME);
 
-    requestOptionsType = processingEnv.getElementUtils().getTypeElement(
-        REQUEST_OPTIONS_QUALIFIED_NAME);
+    requestOptionsType =
+        processingEnv.getElementUtils().getTypeElement(REQUEST_OPTIONS_QUALIFIED_NAME);
   }
 
-  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {
-    generatedRequestBuilderClassName =
-        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);
-    generatedRequestBuilderOfTranscodeType =
-        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);
-
+  TypeSpec generate(
+      String generatedCodePackageName,
+      Set<String> glideExtensionClassNames,
+      @Nullable TypeSpec generatedOptions) {
     if (generatedOptions != null) {
-      requestOptionsClassName =
-          ClassName.get(generatedCodePackageName, generatedOptions.name);
+      requestOptionsClassName = ClassName.get(generatedCodePackageName, generatedOptions.name);
     } else {
       requestOptionsClassName =
           ClassName.get(
               RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,
-              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);
+              RequestOptionsGenerator.BASE_REQUEST_OPTIONS_SIMPLE_NAME);
     }
 
+    generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);
+    generatedRequestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);
+    RequestOptionsExtensionGenerator requestOptionsExtensionGenerator =
+        new RequestOptionsExtensionGenerator(generatedRequestBuilderOfTranscodeType, processorUtil);
+
     ParameterizedTypeName requestBuilderOfTranscodeType =
         ParameterizedTypeName.get(
             ClassName.get(REQUEST_BUILDER_PACKAGE_NAME, REQUEST_BUILDER_SIMPLE_NAME),
             transcodeTypeName);
 
+    List<MethodSpec> requestOptionsExtensionMethods =
+        requestOptionsExtensionGenerator.generateInstanceMethodsForExtensions(
+            glideExtensionClassNames);
+
     return TypeSpec.classBuilder(GENERATED_REQUEST_BUILDER_SIMPLE_NAME)
-        .addJavadoc("Contains all public methods from {@link $T}, all options from\n",
-            requestBuilderType)
+        .addJavadoc(
+            "Contains all public methods from {@link $T}, all options from\n", requestBuilderType)
         .addJavadoc("{@link $T} and all generated options from\n", requestOptionsType)
         .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class)
         .addJavadoc("{@link $T} annotated classes.\n", GlideExtension.class)
@@ -171,10 +179,171 @@ TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedO
         .addSuperinterface(Cloneable.class)
         .addMethods(generateConstructors())
         .addMethod(generateDownloadOnlyRequestMethod())
-        .addMethods(generateGeneratedRequestOptionsEquivalents(generatedOptions))
+        .addMethods(
+            generateGeneratedRequestOptionsEquivalents(
+                requestOptionsExtensionMethods, generatedOptions))
         .addMethods(generateRequestBuilderOverrides())
+        .addMethods(requestOptionsExtensionMethods)
         .build();
   }
+  /**
+   * Generates methods with equivalent names and arguments to methods annotated with {@link
+   * GlideOption} in {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
+   * {@code com.bumptech.glide.RequestBuilder} subclass.
+   */
+  private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
+      final List<MethodSpec> requestOptionsExtensionMethods,
+      @Nullable final TypeSpec generatedOptions) {
+    if (generatedOptions == null) {
+      return Collections.emptyList();
+    }
+    return FluentIterable.from(generatedOptions.methodSpecs)
+        .filter(
+            new Predicate<MethodSpec>() {
+              @Override
+              public boolean apply(MethodSpec input) {
+                return isUsefulGeneratedRequestOption(requestOptionsExtensionMethods, input);
+              }
+            })
+        .transform(
+            new Function<MethodSpec, MethodSpec>() {
+              @Override
+              public MethodSpec apply(MethodSpec input) {
+                return generateGeneratedRequestOptionEquivalent(input);
+              }
+            })
+        .toList();
+  }
+
+  /**
+   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our {@code
+   * com.bumptech.glide.RequestBuilder} subclass.
+   *
+   * <p>Only newly generated methods will be included in the generated {@code
+   * com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out methods
+   * that override other methods to avoid duplicates.
+   */
+  private boolean isUsefulGeneratedRequestOption(
+      List<MethodSpec> requestOptionsExtensionMethods, final MethodSpec requestOptionsMethod) {
+    return !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionsMethod.name)
+        && requestOptionsMethod.hasModifier(Modifier.PUBLIC)
+        && !requestOptionsMethod.hasModifier(Modifier.STATIC)
+        && requestOptionsMethod.returnType.toString().equals(requestOptionsClassName.toString())
+        && !isExtensionMethod(requestOptionsExtensionMethods, requestOptionsMethod);
+  }
+
+  private boolean isExtensionMethod(
+      List<MethodSpec> requestOptionsExtensionMethods, final MethodSpec requestOptionsMethod) {
+    return FluentIterable.from(requestOptionsExtensionMethods)
+        .anyMatch(
+            new Predicate<MethodSpec>() {
+              @Override
+              public boolean apply(MethodSpec input) {
+                return input.name.equals(requestOptionsMethod.name)
+                    && input.parameters.equals(requestOptionsMethod.parameters);
+              }
+            });
+  }
+
+  /**
+   * Generates a particular method with an equivalent name and arguments to the given method from
+   * the generated {@code com.bumptech.glide.request.BaseRequestBuilder} subclass.
+   */
+  private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
+    CodeBlock callRequestOptionsMethod =
+        CodeBlock.builder()
+            .add(".$N(", requestOptionMethod.name)
+            .add(
+                FluentIterable.from(requestOptionMethod.parameters)
+                    .transform(
+                        new Function<ParameterSpec, String>() {
+                          @Override
+                          public String apply(ParameterSpec input) {
+                            return input.name;
+                          }
+                        })
+                    .join(Joiner.on(", ")))
+            .add(");\n")
+            .build();
+
+    MethodSpec.Builder result =
+        MethodSpec.methodBuilder(requestOptionMethod.name)
+            .addJavadoc(
+                processorUtil.generateSeeMethodJavadoc(
+                    requestOptionsClassName, requestOptionMethod))
+            .addModifiers(Modifier.PUBLIC)
+            .varargs(requestOptionMethod.varargs)
+            .addAnnotations(
+                FluentIterable.from(requestOptionMethod.annotations)
+                    .filter(
+                        new Predicate<AnnotationSpec>() {
+                          @Override
+                          public boolean apply(AnnotationSpec input) {
+                            return !input.type.equals(TypeName.get(Override.class))
+                                // SafeVarargs can only be applied to final methods. GlideRequest is
+                                // non-final to allow for mocking.
+                                && !input.type.equals(TypeName.get(SafeVarargs.class))
+                                // We need to combine warnings below.
+                                && !input.type.equals(TypeName.get(SuppressWarnings.class));
+                          }
+                        })
+                    .toList())
+            .addTypeVariables(requestOptionMethod.typeVariables)
+            .addParameters(requestOptionMethod.parameters)
+            .returns(generatedRequestBuilderOfTranscodeType)
+            .addCode("return ($T) super", generatedRequestBuilderOfTranscodeType)
+            .addCode(callRequestOptionsMethod);
+
+    AnnotationSpec suppressWarnings = buildSuppressWarnings(requestOptionMethod);
+    if (suppressWarnings != null) {
+      result.addAnnotation(suppressWarnings);
+    }
+    return result.build();
+  }
+
+  @Nullable
+  private AnnotationSpec buildSuppressWarnings(MethodSpec requestOptionMethod) {
+    Set<String> suppressions = new HashSet<>();
+    if (requestOptionMethod.annotations.contains(
+        AnnotationSpec.builder(SuppressWarnings.class).build())) {
+      for (AnnotationSpec annotation : requestOptionMethod.annotations) {
+        if (annotation.type.equals(TypeName.get(SuppressWarnings.class))) {
+          List<CodeBlock> codeBlocks = annotation.members.get("value");
+          suppressions.addAll(
+              FluentIterable.from(codeBlocks)
+                  .transform(
+                      new Function<CodeBlock, String>() {
+                        @Override
+                        public String apply(CodeBlock input) {
+                          return input.toString();
+                        }
+                      })
+                  .toSet());
+        }
+      }
+    }
+
+    if (requestOptionMethod.annotations.contains(
+        AnnotationSpec.builder(SafeVarargs.class).build())) {
+      suppressions.add("unchecked");
+      suppressions.add("varargs");
+    }
+
+    if (suppressions.isEmpty()) {
+      return null;
+    }
+    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the
+    // order produced by the Set additions above.)
+    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);
+    Collections.sort(suppressionsList);
+
+    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class);
+    for (String suppression : suppressionsList) {
+      builder.addMember("value", "$S", suppression);
+    }
+
+    return builder.build();
+  }
 
   /**
    * Generates overrides of all methods in {@code com.bumptech.glide.RequestBuilder} that return
@@ -207,19 +376,24 @@ private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOver
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
-        .returns(generatedRequestBuilderOfType)
-        .addCode(CodeBlock.builder()
-            .add("return ($T) super.$N(",
-                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
-            .add(FluentIterable.from(methodToOverride.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
-                .join(Joiner.on(", ")))
+    MethodSpec.Builder builder =
+        ProcessorUtil.overriding(methodToOverride).returns(generatedRequestBuilderOfType);
+    builder.addCode(
+        CodeBlock.builder()
+            .add(
+                "return ($T) super.$N(",
+                generatedRequestBuilderOfType,
+                methodToOverride.getSimpleName())
+            .add(
+                FluentIterable.from(builder.build().parameters)
+                    .transform(
+                        new Function<ParameterSpec, String>() {
+                          @Override
+                          public String apply(ParameterSpec input) {
+                            return input.name;
+                          }
+                        })
+                    .join(Joiner.on(", ")))
             .add(");\n")
             .build());
 
@@ -228,122 +402,19 @@ public String apply(VariableElement input) {
     }
 
     if (methodToOverride.isVarArgs()) {
-      builder = builder
-          .addModifiers(Modifier.FINAL)
-          .addAnnotation(SafeVarargs.class);
+      builder =
+          builder
+              .addModifiers(Modifier.FINAL)
+              .addAnnotation(SafeVarargs.class)
+              .addAnnotation(
+                  AnnotationSpec.builder(SuppressWarnings.class)
+                      .addMember("value", "$S", "varargs")
+                      .build());
     }
 
     return builder.build();
   }
 
-  /**
-   * Generates methods with equivalent names and arguments to methods annotated with
-   * {@link GlideOption} in
-   * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
-   * {@code com.bumptech.glide.RequestBuilder} subclass.
-   */
-  private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
-      @Nullable final TypeSpec generatedOptions) {
-    if (generatedOptions == null) {
-      return Collections.emptyList();
-    }
-    return FluentIterable
-        .from(generatedOptions.methodSpecs)
-        .filter(new Predicate<MethodSpec>() {
-          @Override
-          public boolean apply(MethodSpec input) {
-            return isUsefulGeneratedRequestOption(input);
-          }
-        })
-        .transform(new Function<MethodSpec, MethodSpec>() {
-          @Override
-          public MethodSpec apply(MethodSpec input) {
-            return generateGeneratedRequestOptionEquivalent(input);
-          }
-        })
-        .toList();
-  }
-
-  /**
-   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our
-   * {@code com.bumptech.glide.RequestBuilder} subclass.
-   *
-   * <p>Only newly generated methods will be included in the generated
-   * {@code com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
-   * methods that override other methods to avoid duplicates.
-   */
-  private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
-    return
-        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionMethod.name)
-        && requestOptionMethod.hasModifier(Modifier.PUBLIC)
-        && !requestOptionMethod.hasModifier(Modifier.STATIC)
-        && requestOptionMethod.returnType.toString()
-            .equals(requestOptionsClassName.toString());
-  }
-
-   /**
-   * Generates a particular method with  an equivalent name and arguments to the given method
-   * from the generated {@code com.bumptech.glide.request.BaseRequestBuilder} subclass.
-   */
-  private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
-    CodeBlock callRequestOptionsMethod = CodeBlock.builder()
-        .add(".$N(", requestOptionMethod.name)
-        .add(FluentIterable.from(requestOptionMethod.parameters)
-            .transform(new Function<ParameterSpec, String>() {
-              @Override
-              public String apply(ParameterSpec input) {
-                return input.name;
-              }
-            })
-            .join(Joiner.on(", ")))
-        .add(");\n")
-        .build();
-
-    MethodSpec.Builder result = MethodSpec.methodBuilder(requestOptionMethod.name)
-        .addJavadoc(
-            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod))
-        .addModifiers(Modifier.PUBLIC)
-        .varargs(requestOptionMethod.varargs)
-        .addAnnotations(
-            FluentIterable.from(requestOptionMethod.annotations)
-                .filter(new Predicate<AnnotationSpec>() {
-                  @Override
-                  public boolean apply(AnnotationSpec input) {
-                    return !input.type.equals(TypeName.get(Override.class))
-                        // SafeVarargs can only be applied to final methods. GlideRequest is
-                        // non-final to allow for mocking.
-                        && !input.type.equals(TypeName.get(SafeVarargs.class));
-                  }
-                })
-                .toList()
-        )
-        .addTypeVariables(requestOptionMethod.typeVariables)
-        .addParameters(requestOptionMethod.parameters)
-        .returns(generatedRequestBuilderOfTranscodeType)
-        .beginControlFlow(
-            "if (getMutableOptions() instanceof $T)", requestOptionsClassName)
-        .addCode("this.requestOptions = (($T) getMutableOptions())",
-            requestOptionsClassName)
-        .addCode(callRequestOptionsMethod)
-        .nextControlFlow("else")
-        .addCode(CodeBlock.of("this.requestOptions = new $T().apply(this.requestOptions)",
-            requestOptionsClassName))
-        .addCode(callRequestOptionsMethod)
-        .endControlFlow()
-        .addStatement("return this");
-
-    if (requestOptionMethod.annotations.contains(
-        AnnotationSpec.builder(SafeVarargs.class).build())) {
-      result.addAnnotation(
-          AnnotationSpec.builder(SuppressWarnings.class)
-              .addMember("value", "$S", "unchecked")
-              .addMember("value", "$S", "varargs")
-              .build());
-    }
-
-    return result.build();
-  }
-
   private List<MethodSpec> generateConstructors() {
     ParameterizedTypeName classOfTranscodeType =
         ParameterizedTypeName.get(ClassName.get(Class.class), transcodeTypeName);
@@ -354,20 +425,38 @@ public boolean apply(AnnotationSpec input) {
 
     MethodSpec firstConstructor =
         MethodSpec.constructorBuilder()
-            .addParameter(classOfTranscodeType, "transcodeClass")
-            .addParameter(requestBuilderOfWildcardOfObject, "other")
-        .addStatement("super($N, $N)", "transcodeClass", "other")
-        .build();
+            .addParameter(
+                ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(requestBuilderOfWildcardOfObject, "other")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
+            .addStatement("super($N, $N)", "transcodeClass", "other")
+            .build();
 
     ClassName context = ClassName.get("android.content", "Context");
     ClassName glide = ClassName.get("com.bumptech.glide", "Glide");
     ClassName requestManager = ClassName.get("com.bumptech.glide", "RequestManager");
     MethodSpec secondConstructor =
         MethodSpec.constructorBuilder()
-            .addParameter(glide, "glide")
-            .addParameter(requestManager, "requestManager")
-            .addParameter(classOfTranscodeType, "transcodeClass")
-            .addParameter(context, "context")
+            .addParameter(
+                ParameterSpec.builder(glide, "glide")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(requestManager, "requestManager")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(context, "context")
+                    .addAnnotation(processorUtil.nonNull())
+                    .build())
             .addStatement(
                 "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context")
             .build();
@@ -379,15 +468,19 @@ public boolean apply(AnnotationSpec input) {
    * return our generated subclass instead.
    */
   private MethodSpec generateDownloadOnlyRequestMethod() {
-    ParameterizedTypeName generatedRequestBuilderOfFile
-        = ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
+    ParameterizedTypeName generatedRequestBuilderOfFile =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
     return MethodSpec.methodBuilder("getDownloadOnlyRequest")
         .addAnnotation(Override.class)
-        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(processorUtil.checkResult())
+        .addAnnotation(processorUtil.nonNull())
         .returns(generatedRequestBuilderOfFile)
         .addModifiers(Modifier.PROTECTED)
-        .addStatement("return new $T<>($T.class, $N).apply($N)",
-            generatedRequestBuilderClassName, File.class, "this",
+        .addStatement(
+            "return new $T<>($T.class, $N).apply($N)",
+            generatedRequestBuilderClassName,
+            File.class,
+            "this",
             "DOWNLOAD_ONLY_OPTIONS")
         .build();
   }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
index bc059256b..4396828f4 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
@@ -2,6 +2,7 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
@@ -9,12 +10,13 @@
 import javax.lang.model.util.Elements;
 
 /**
- * Generates an implementation of
- * {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
+ * Generates an implementation of {@code
+ * com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
  * generated {@code com.bumptech.glide.RequestManager} implementation.
  *
  * <p>Generated {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
  * classes look like this:
+ *
  * <pre>
  * <code>
  * public class GeneratedRequestManagerFactory
@@ -29,21 +31,16 @@
  * </pre>
  */
 final class RequestManagerFactoryGenerator {
-  private static final String GLIDE_QUALIFIED_NAME =
-      "com.bumptech.glide.Glide";
-  private static final String LIFECYCLE_QUALIFIED_NAME =
-      "com.bumptech.glide.manager.Lifecycle";
+  private static final String GLIDE_QUALIFIED_NAME = "com.bumptech.glide.Glide";
+  private static final String LIFECYCLE_QUALIFIED_NAME = "com.bumptech.glide.manager.Lifecycle";
   private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
       "com.bumptech.glide.manager.RequestManagerTreeNode";
   private static final String REQUEST_MANAGER_FACTORY_QUALIFIED_NAME =
       "com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory";
-  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
-      "com.bumptech.glide.RequestManager";
-  private static final ClassName CONTEXT_CLASS_NAME =
-      ClassName.get("android.content", "Context");
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME = "com.bumptech.glide.RequestManager";
+  private static final ClassName CONTEXT_CLASS_NAME = ClassName.get("android.content", "Context");
 
-  static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME =
-      "com.bumptech.glide";
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME = "com.bumptech.glide";
   static final String GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME =
       "GeneratedRequestManagerFactory";
 
@@ -52,8 +49,10 @@
   private final TypeElement requestManagerTreeNodeType;
   private final TypeElement requestManagerFactoryInterface;
   private final ClassName requestManagerClassName;
+  private final ProcessorUtil processorUtil;
 
-  RequestManagerFactoryGenerator(ProcessingEnvironment processingEnv) {
+  RequestManagerFactoryGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
     Elements elementUtils = processingEnv.getElementUtils();
     glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
     lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
@@ -65,7 +64,6 @@
 
     TypeElement requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
     requestManagerClassName = ClassName.get(requestManagerType);
-
   }
 
   TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestManagerSpec) {
@@ -77,16 +75,28 @@ TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestMana
             MethodSpec.methodBuilder("build")
                 .addModifiers(Modifier.PUBLIC)
                 .addAnnotation(Override.class)
+                .addAnnotation(processorUtil.nonNull())
                 .returns(requestManagerClassName)
-                .addParameter(ClassName.get(glideType), "glide")
-                .addParameter(ClassName.get(lifecycleType), "lifecycle")
-                .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
-                .addParameter(CONTEXT_CLASS_NAME, "context")
+                .addParameter(
+                    ParameterSpec.builder(ClassName.get(glideType), "glide")
+                        .addAnnotation(processorUtil.nonNull())
+                        .build())
+                .addParameter(
+                    ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+                        .addAnnotation(processorUtil.nonNull())
+                        .build())
+                .addParameter(
+                    ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                        .addAnnotation(processorUtil.nonNull())
+                        .build())
+                .addParameter(
+                    ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+                        .addAnnotation(processorUtil.nonNull())
+                        .build())
                 .addStatement(
                     "return new $T(glide, lifecycle, treeNode, context)",
                     ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name))
-                .build()
-        )
+                .build())
         .build();
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
index 9e7d618c8..f4a798d57 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -10,6 +10,7 @@
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.MethodSpec.Builder;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeSpec;
@@ -24,6 +25,7 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
@@ -32,6 +34,7 @@
  * methods from {@link GlideExtension}s and {@link GlideType}.
  *
  * <p>Generated {@code com.bumptech.glide.RequestManager} implementations look like this:
+ *
  * <pre>
  * <code>
  * public final class GeneratedRequestManager extends RequestManager {
@@ -49,21 +52,14 @@
  * </pre>
  */
 final class RequestManagerGenerator {
-  private static final String GLIDE_QUALIFIED_NAME =
-      "com.bumptech.glide.Glide";
-  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
-      "com.bumptech.glide.RequestManager";
-  private static final String LIFECYCLE_QUALIFIED_NAME =
-      "com.bumptech.glide.manager.Lifecycle";
+  private static final String GLIDE_QUALIFIED_NAME = "com.bumptech.glide.Glide";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME = "com.bumptech.glide.RequestManager";
+  private static final String LIFECYCLE_QUALIFIED_NAME = "com.bumptech.glide.manager.Lifecycle";
   private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
       "com.bumptech.glide.manager.RequestManagerTreeNode";
-  private static final ClassName CHECK_RESULT_CLASS_NAME =
-      ClassName.get("android.support.annotation", "CheckResult");
-  private static final ClassName CONTEXT_CLASS_NAME =
-      ClassName.get("android.content", "Context");
+  private static final ClassName CONTEXT_CLASS_NAME = ClassName.get("android.content", "Context");
 
-  private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME =
-      "GlideRequests";
+  private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME = "GlideRequests";
 
   private ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
@@ -94,66 +90,86 @@
     glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
   }
 
-  @Nullable
   TypeSpec generate(
-      String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,
+      String generatedCodePackageName,
+      @Nullable TypeSpec requestOptions,
+      TypeSpec requestBuilder,
       Set<String> glideExtensions) {
     generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);
     return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_SIMPLE_NAME)
-         .superclass(requestManagerClassName)
-         .addJavadoc("Includes all additions from methods in {@link $T}s\n"
-                 + "annotated with {@link $T}\n"
-                 + "\n"
-                 + "<p>Generated code, do not modify\n",
-             GlideExtension.class, GlideType.class)
+        .superclass(requestManagerClassName)
+        .addJavadoc(
+            "Includes all additions from methods in {@link $T}s\n"
+                + "annotated with {@link $T}\n"
+                + "\n"
+                + "<p>Generated code, do not modify\n",
+            GlideExtension.class,
+            GlideType.class)
         .addAnnotation(
             AnnotationSpec.builder(SuppressWarnings.class)
                 .addMember("value", "$S", "deprecation")
                 .build())
-         .addModifiers(Modifier.PUBLIC)
-         .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
-         .addMethod(generateCallSuperConstructor())
-         .addMethods(generateExtensionRequestManagerMethods(glideExtensions))
-         .addMethods(generateRequestManagerRequestManagerMethodOverrides(generatedCodePackageName))
-         .addMethods(generateRequestManagerRequestBuilderMethodOverrides())
-         .addMethods(
-             FluentIterable.from(
-                 Collections.singletonList(
-                     generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
-                 .filter(Predicates.<MethodSpec>notNull()))
-         .build();
+        .addModifiers(Modifier.PUBLIC)
+        .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
+        .addMethod(generateCallSuperConstructor())
+        .addMethods(generateExtensionRequestManagerMethods(glideExtensions))
+        .addMethods(generateRequestManagerRequestManagerMethodOverrides(generatedCodePackageName))
+        .addMethods(generateRequestManagerRequestBuilderMethodOverrides())
+        .addMethods(
+            FluentIterable.from(
+                    Collections.singletonList(
+                        generateOverrideSetRequestOptions(
+                            generatedCodePackageName, requestOptions)))
+                .filter(Predicates.<MethodSpec>notNull()))
+        .build();
   }
 
   private MethodSpec generateCallSuperConstructor() {
     return MethodSpec.constructorBuilder()
         .addModifiers(Modifier.PUBLIC)
-        .addParameter(ClassName.get(glideType), "glide")
-        .addParameter(ClassName.get(lifecycleType), "lifecycle")
-        .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
-        .addParameter(CONTEXT_CLASS_NAME, "context")
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(glideType), "glide")
+                .addAnnotation(processorUtil.nonNull())
+                .build())
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+                .addAnnotation(processorUtil.nonNull())
+                .build())
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                .addAnnotation(processorUtil.nonNull())
+                .build())
+        .addParameter(
+            ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+                .addAnnotation(processorUtil.nonNull())
+                .build())
         .addStatement("super(glide, lifecycle, treeNode, context)")
         .build();
   }
 
   private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec requestBuilder) {
     TypeVariableName resourceType = TypeVariableName.get("ResourceType");
-    ParameterizedTypeName classOfResouceType = ParameterizedTypeName
-        .get(ClassName.get(Class.class), resourceType);
+    ParameterizedTypeName classOfResouceType =
+        ParameterizedTypeName.get(ClassName.get(Class.class), resourceType);
 
     ClassName generatedRequestBuilderClassName =
         ClassName.get(generatedCodePackageName, requestBuilder.name);
 
-    ParameterizedTypeName requestBuilderOfResourceType = ParameterizedTypeName
-        .get(generatedRequestBuilderClassName, resourceType);
+    ParameterizedTypeName requestBuilderOfResourceType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, resourceType);
 
     return MethodSpec.methodBuilder("as")
         .addModifiers(Modifier.PUBLIC)
         .addAnnotation(Override.class)
+        .addAnnotation(processorUtil.checkResult())
+        .addAnnotation(processorUtil.nonNull())
         .addTypeVariable(TypeVariableName.get("ResourceType"))
-        .addParameter(classOfResouceType, "resourceClass")
-        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
         .returns(requestBuilderOfResourceType)
-        .addStatement("return new $T<>(glide, this, resourceClass, context)",
+        .addParameter(
+            classOfResouceType.annotated(AnnotationSpec.builder(processorUtil.nonNull()).build()),
+            "resourceClass")
+        .addStatement(
+            "return new $T<>(glide, this, resourceClass, context)",
             this.generatedRequestBuilderClassName)
         .build();
   }
@@ -162,14 +178,15 @@ private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec re
   private List<MethodSpec> generateRequestManagerRequestManagerMethodOverrides(
       final String generatedPackageName) {
     return FluentIterable.from(
-        processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType))
-        .transform(new Function<ExecutableElement, MethodSpec>() {
-          @Nullable
-          @Override
-          public MethodSpec apply(@Nullable ExecutableElement input) {
-            return generateRequestManagerRequestManagerMethodOverride(generatedPackageName, input);
-          }
-        })
+            processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType))
+        .transform(
+            new Function<ExecutableElement, MethodSpec>() {
+              @Override
+              public MethodSpec apply(@Nullable ExecutableElement input) {
+                return generateRequestManagerRequestManagerMethodOverride(
+                    generatedPackageName, input);
+              }
+            })
         .toList();
   }
 
@@ -177,9 +194,13 @@ private MethodSpec generateRequestManagerRequestManagerMethodOverride(
       String generatedPackageName, ExecutableElement method) {
     ClassName generatedRequestManagerName =
         ClassName.get(generatedPackageName, GENERATED_REQUEST_MANAGER_SIMPLE_NAME);
-    return ProcessorUtil.overriding(method)
-        .returns(generatedRequestManagerName)
-        .addCode(ProcessorUtil.generateCastingSuperCall(generatedRequestManagerName, method))
+    Builder returns =
+        ProcessorUtil.overriding(method)
+            .addAnnotation(processorUtil.nonNull())
+            .returns(generatedRequestManagerName);
+    return returns
+        .addCode(
+            ProcessorUtil.generateCastingSuperCall(generatedRequestManagerName, returns.build()))
         .build();
   }
 
@@ -188,24 +209,26 @@ private MethodSpec generateRequestManagerRequestManagerMethodOverride(
     // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
     // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
     // assignable to the raw RequestBuilder.
-    TypeMirror rawRequestBuilder = processingEnv.getTypeUtils()
-        .erasure(requestBuilderType.asType());
+    TypeMirror rawRequestBuilder =
+        processingEnv.getTypeUtils().erasure(requestBuilderType.asType());
 
     return FluentIterable.from(
-        processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
-        .filter(new Predicate<ExecutableElement>() {
-          @Override
-          public boolean apply(ExecutableElement input) {
-            // Skip the <T> as(Class<T>) method.
-            return !input.getSimpleName().toString().equals("as");
-          }
-        })
-        .transform(new Function<ExecutableElement, MethodSpec>() {
-          @Override
-          public MethodSpec apply(ExecutableElement input) {
-            return generateRequestManagerRequestBuilderMethodOverride(input);
-          }
-        })
+            processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
+        .filter(
+            new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement input) {
+                // Skip the <T> as(Class<T>) method.
+                return !input.getSimpleName().toString().equals("as");
+              }
+            })
+        .transform(
+            new Function<ExecutableElement, MethodSpec>() {
+              @Override
+              public MethodSpec apply(ExecutableElement input) {
+                return generateRequestManagerRequestBuilderMethodOverride(input);
+              }
+            })
         .toList();
   }
 
@@ -215,7 +238,7 @@ public MethodSpec apply(ExecutableElement input) {
    */
   private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
       ExecutableElement methodToOverride) {
-     // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
     // exactly one type argument, so this is safe unless those assumptions change.
     TypeMirror typeArgument =
         ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
@@ -223,11 +246,10 @@ private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
-        .returns(generatedRequestBuilderOfType)
-        .addCode(
-            ProcessorUtil.generateCastingSuperCall(
-                generatedRequestBuilderOfType, methodToOverride));
+    MethodSpec.Builder builder =
+        ProcessorUtil.overriding(methodToOverride).returns(generatedRequestBuilderOfType);
+    builder.addCode(
+        ProcessorUtil.generateCastingSuperCall(generatedRequestBuilderOfType, builder.build()));
 
     for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
       builder.addAnnotation(AnnotationSpec.get(mirror));
@@ -235,12 +257,12 @@ private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
     return builder.build();
   }
 
-  private List<MethodSpec> generateExtensionRequestManagerMethods(
-      Set<String> glideExtensions) {
+  private List<MethodSpec> generateExtensionRequestManagerMethods(Set<String> glideExtensions) {
     List<ExecutableElement> requestManagerExtensionMethods =
         processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
 
-    return Lists.transform(requestManagerExtensionMethods,
+    return Lists.transform(
+        requestManagerExtensionMethods,
         new Function<ExecutableElement, MethodSpec>() {
           @Override
           public MethodSpec apply(ExecutableElement input) {
@@ -251,8 +273,20 @@ public MethodSpec apply(ExecutableElement input) {
 
   // Generates methods added to RequestManager via GlideExtensions.
   private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement extensionMethod) {
-    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
-        GlideType.class).iterator().next();
+    if (extensionMethod.getReturnType().getKind() == TypeKind.VOID) {
+      return generateAdditionalRequestManagerMethodLegacy(extensionMethod);
+    } else {
+      return generateAdditionalRequestManagerMethodNew(extensionMethod);
+    }
+  }
+
+  private MethodSpec generateAdditionalRequestManagerMethodLegacy(
+      ExecutableElement extensionMethod) {
+    String returnType =
+        processorUtil
+            .findClassValuesFromAnnotationOnClassAsNames(extensionMethod, GlideType.class)
+            .iterator()
+            .next();
     ClassName returnTypeClassName = ClassName.bestGuess(returnType);
     ParameterizedTypeName parameterizedTypeName =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
@@ -261,18 +295,47 @@ private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement exte
         .addModifiers(Modifier.PUBLIC)
         .returns(parameterizedTypeName)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(processorUtil.nonNull())
+        .addAnnotation(processorUtil.checkResult())
         .addStatement(
             "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
-        .addStatement("$T.$N(requestBuilder)",
-            extensionMethod.getEnclosingElement(), extensionMethod.getSimpleName())
+        .addStatement(
+            "$T.$N(requestBuilder)",
+            extensionMethod.getEnclosingElement(),
+            extensionMethod.getSimpleName())
         .addStatement("return requestBuilder")
         .build();
   }
 
+  private MethodSpec generateAdditionalRequestManagerMethodNew(ExecutableElement extensionMethod) {
+    String returnType =
+        processorUtil
+            .findClassValuesFromAnnotationOnClassAsNames(extensionMethod, GlideType.class)
+            .iterator()
+            .next();
+    ClassName returnTypeClassName = ClassName.bestGuess(returnType);
+    ParameterizedTypeName parameterizedTypeName =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
+
+    return MethodSpec.methodBuilder(extensionMethod.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC)
+        .returns(parameterizedTypeName)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(processorUtil.nonNull())
+        .addAnnotation(processorUtil.checkResult())
+        .addStatement(
+            "return ($T) $T.$N(this.as($T.class))",
+            parameterizedTypeName,
+            extensionMethod.getEnclosingElement(),
+            extensionMethod.getSimpleName(),
+            returnTypeClassName)
+        .build();
+  }
+
   /**
-   * The {@code RequestOptions} subclass should always be our
-   * generated subclass type to avoid inadvertent errors where a different subclass is applied that
-   * accidentally wipes out some logic in overidden methods in our generated subclass.
+   * The {@code RequestOptions} subclass should always be our generated subclass type to avoid
+   * inadvertent errors where a different subclass is applied that accidentally wipes out some logic
+   * in overidden methods in our generated subclass.
    */
   @Nullable
   private MethodSpec generateOverrideSetRequestOptions(
@@ -283,10 +346,7 @@ private MethodSpec generateOverrideSetRequestOptions(
 
     Elements elementUtils = processingEnv.getElementUtils();
     TypeElement requestOptionsType =
-            elementUtils.getTypeElement(
-                RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
-    TypeElement androidNonNullType =
-            elementUtils.getTypeElement("android.support.annotation.NonNull");
+        elementUtils.getTypeElement(RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
 
     // This class may have just been generated and therefore may not be found if we try to obtain
     // it via Elements, so use just the String version instead.
@@ -301,14 +361,16 @@ private MethodSpec generateOverrideSetRequestOptions(
         .addModifiers(Modifier.PROTECTED)
         .addParameter(
             ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
-                .addAnnotation(ClassName.get(androidNonNullType))
+                .addAnnotation(processorUtil.nonNull())
                 .build())
-        .beginControlFlow("if ($N instanceof $L)",
-            parameterName, generatedRequestOptionsQualifiedName)
+        .beginControlFlow(
+            "if ($N instanceof $L)", parameterName, generatedRequestOptionsQualifiedName)
         .addStatement("super.$N($N)", methodName, parameterName)
         .nextControlFlow("else")
-        .addStatement("super.setRequestOptions(new $L().apply($N))",
-            generatedRequestOptionsQualifiedName, parameterName)
+        .addStatement(
+            "super.setRequestOptions(new $L().apply($N))",
+            generatedRequestOptionsQualifiedName,
+            parameterName)
         .endControlFlow()
         .build();
   }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java
new file mode 100644
index 000000000..baf187935
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java
@@ -0,0 +1,140 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
+
+import com.bumptech.glide.annotation.GlideOption;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+
+/**
+ * Generates method overrides for classes that want to mix in {@link GlideOption} annotated methods
+ * in Glide extensions.
+ */
+final class RequestOptionsExtensionGenerator {
+  private TypeName containingClassName;
+  private ProcessorUtil processorUtil;
+
+  RequestOptionsExtensionGenerator(TypeName containingClassName, ProcessorUtil processorUtil) {
+    this.containingClassName = containingClassName;
+    this.processorUtil = processorUtil;
+  }
+
+  /**
+   * Returns the set of {@link GlideOption} annotated methods in the classes that correspond to the
+   * given extension class names.
+   */
+  List<ExecutableElement> getRequestOptionExtensionMethods(Set<String> glideExtensionClassNames) {
+    return processorUtil.findAnnotatedElementsInClasses(
+        glideExtensionClassNames, GlideOption.class);
+  }
+
+  /**
+   * Returns a list containing an override {@link MethodSpec} for all {@link GlideOption} annotated
+   * methods in the classes that correspond to the given extension class names.
+   */
+  List<MethodSpec> generateInstanceMethodsForExtensions(Set<String> glideExtensionClassNames) {
+    List<ExecutableElement> requestOptionExtensionMethods =
+        getRequestOptionExtensionMethods(glideExtensionClassNames);
+
+    List<MethodSpec> result = new ArrayList<>(requestOptionExtensionMethods.size());
+    for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
+      result.add(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
+    }
+
+    return result;
+  }
+
+  private MethodSpec generateMethodsForRequestOptionsExtension(ExecutableElement element) {
+    // Assert for legacy versions
+    if (element.getReturnType().getKind() == TypeKind.VOID) {
+      throw new IllegalArgumentException(
+          "The "
+              + element.getSimpleName()
+              + " method annotated with @GlideOption in the "
+              + element.getEnclosingElement().getSimpleName()
+              + " @GlideExtension is using a legacy"
+              + " format that is no longer supported. Please change your method definition so that"
+              + " your @GlideModule annotated methods return BaseRequestOptions<?> objects instead"
+              + " of null.");
+    }
+
+    int overrideType = processorUtil.getOverrideType(element);
+
+    String methodName = element.getSimpleName().toString();
+    MethodSpec.Builder builder =
+        MethodSpec.methodBuilder(methodName)
+            .addModifiers(Modifier.PUBLIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+            .varargs(element.isVarArgs())
+            .returns(containingClassName)
+            .addAnnotation(
+                AnnotationSpec.builder(SuppressWarnings.class)
+                    .addMember("value", "$S", "unchecked")
+                    .build());
+
+    // The 0th element is expected to be a RequestOptions object.
+    List<? extends VariableElement> paramElements =
+        element.getParameters().subList(1, element.getParameters().size());
+    List<ParameterSpec> parameters = ProcessorUtil.getParameters(paramElements);
+    builder.addParameters(parameters);
+
+    String extensionRequestOptionsArgument;
+    if (overrideType == OVERRIDE_EXTEND) {
+      builder
+          .addJavadoc(
+              processorUtil.generateSeeMethodJavadoc(
+                  containingClassName, methodName, paramElements))
+          .addAnnotation(Override.class);
+
+      List<Object> methodArgs = new ArrayList<>();
+      methodArgs.add(element.getSimpleName().toString());
+      StringBuilder methodLiterals = new StringBuilder();
+      if (!parameters.isEmpty()) {
+        for (ParameterSpec parameter : parameters) {
+          methodLiterals.append("$L, ");
+          methodArgs.add(parameter.name);
+        }
+        methodLiterals =
+            new StringBuilder(methodLiterals.substring(0, methodLiterals.length() - 2));
+      }
+      extensionRequestOptionsArgument =
+          CodeBlock.builder()
+              .add("super.$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
+              .build()
+              .toString();
+    } else {
+      extensionRequestOptionsArgument = "this";
+    }
+
+    List<Object> args = new ArrayList<>();
+    StringBuilder code = new StringBuilder("return ($T) $T.$L($L, ");
+    args.add(containingClassName);
+    args.add(ClassName.get(element.getEnclosingElement().asType()));
+    args.add(element.getSimpleName().toString());
+    args.add(extensionRequestOptionsArgument);
+    if (!parameters.isEmpty()) {
+      for (ParameterSpec parameter : parameters) {
+        code.append("$L, ");
+        args.add(parameter.name);
+      }
+    }
+    code = new StringBuilder(code.substring(0, code.length() - 2));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
+
+    builder.addAnnotation(processorUtil.checkResult()).addAnnotation(processorUtil.nonNull());
+
+    return builder.build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
index 32a62649a..45052aeb5 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.annotation.compiler;
 
-import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
-import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_NONE;
-
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.base.Objects;
+import com.google.common.base.Preconditions;
+import com.google.common.base.Predicate;
 import com.google.common.base.Strings;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -28,9 +26,6 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -38,12 +33,12 @@
 import javax.lang.model.element.VariableElement;
 
 /**
- * Generates a new implementation of {@code com.bumptech.glide.request.RequestOptions}
- * containing static versions of methods included in the base class and static and instance versions
- * of all methods annotated with {@link GlideOption} in classes annotated with
- * {@link GlideExtension}.
+ * Generates a new implementation of {@code com.bumptech.glide.request.RequestOptions} containing
+ * static versions of methods included in the base class and static and instance versions of all
+ * methods annotated with {@link GlideOption} in classes annotated with {@link GlideExtension}.
  *
  * <p>The generated class looks something like this:
+ *
  * <pre>
  * <code>
  * public final class GlideOptions extends com.bumptech.glide.request.RequestOptions {
@@ -68,7 +63,6 @@
  * }
  * </code>
  * </pre>
- * </p>
  */
 final class RequestOptionsGenerator {
   private static final String GENERATED_REQUEST_OPTIONS_SIMPLE_NAME = "GlideOptions";
@@ -76,47 +70,91 @@
   private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
   static final String REQUEST_OPTIONS_QUALIFIED_NAME =
       REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
-  private static final ClassName CHECK_RESULT_CLASS_NAME =
-      ClassName.get("android.support.annotation", "CheckResult");
 
-  private final ProcessingEnvironment processingEnvironment;
+  static final String BASE_REQUEST_OPTIONS_SIMPLE_NAME = "BaseRequestOptions";
+  static final String BASE_REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + BASE_REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private int nextFieldId;
+
   private final ClassName requestOptionsName;
   private final TypeElement requestOptionsType;
   private final ProcessorUtil processorUtil;
+  private final RequestOptionsOverrideGenerator requestOptionsOverrideGenerator;
+
   private ClassName glideOptionsName;
-  private int nextStaticFieldUniqueId;
 
   RequestOptionsGenerator(
       ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
-    this.processingEnvironment = processingEnvironment;
     this.processorUtil = processorUtil;
 
-    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME,
-        REQUEST_OPTIONS_SIMPLE_NAME);
+    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME, REQUEST_OPTIONS_SIMPLE_NAME);
+
+    requestOptionsType =
+        processingEnvironment.getElementUtils().getTypeElement(REQUEST_OPTIONS_QUALIFIED_NAME);
 
-    requestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
-        REQUEST_OPTIONS_QUALIFIED_NAME);
+    requestOptionsOverrideGenerator =
+        new RequestOptionsOverrideGenerator(processingEnvironment, processorUtil);
   }
 
   TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionClassNames) {
     glideOptionsName =
         ClassName.get(generatedCodePackageName, GENERATED_REQUEST_OPTIONS_SIMPLE_NAME);
 
-    List<MethodAndStaticVar> methodsForExtensions =
-        generateMethodsForExtensions(glideExtensionClassNames);
+    RequestOptionsExtensionGenerator requestOptionsExtensionGenerator =
+        new RequestOptionsExtensionGenerator(glideOptionsName, processorUtil);
+    List<MethodAndStaticVar> instanceMethodsForExtensions =
+        FluentIterable.from(
+                requestOptionsExtensionGenerator.generateInstanceMethodsForExtensions(
+                    glideExtensionClassNames))
+            .transform(
+                new Function<MethodSpec, MethodAndStaticVar>() {
+                  @Override
+                  public MethodAndStaticVar apply(MethodSpec input) {
+                    return new MethodAndStaticVar(input);
+                  }
+                })
+            .toList();
+
+    List<MethodAndStaticVar> staticMethodsForExtensions =
+        FluentIterable.from(
+                requestOptionsExtensionGenerator.getRequestOptionExtensionMethods(
+                    glideExtensionClassNames))
+            .filter(
+                new Predicate<ExecutableElement>() {
+                  @Override
+                  public boolean apply(ExecutableElement input) {
+                    return !skipStaticMethod(input);
+                  }
+                })
+            .transform(
+                new Function<ExecutableElement, MethodAndStaticVar>() {
+                  @Override
+                  public MethodAndStaticVar apply(ExecutableElement input) {
+                    return generateStaticMethodEquivalentForExtensionMethod(input);
+                  }
+                })
+            .toList();
+
+    List<MethodAndStaticVar> methodsForExtensions = new ArrayList<>();
+    methodsForExtensions.addAll(instanceMethodsForExtensions);
+    methodsForExtensions.addAll(staticMethodsForExtensions);
 
-    Set<MethodSignature> extensionMethodSignatures = ImmutableSet.copyOf(
-        Iterables.transform(methodsForExtensions,
-            new Function<MethodAndStaticVar, MethodSignature>() {
-              @Nullable
-              @Override
-              public MethodSignature apply(MethodAndStaticVar f) {
-                return new MethodSignature(f.method);
-              }
-            }));
+    Set<MethodSignature> extensionMethodSignatures =
+        ImmutableSet.copyOf(
+            Iterables.transform(
+                methodsForExtensions,
+                new Function<MethodAndStaticVar, MethodSignature>() {
+                  @Override
+                  public MethodSignature apply(MethodAndStaticVar f) {
+                    return new MethodSignature(f.method);
+                  }
+                }));
 
     List<MethodAndStaticVar> staticOverrides = generateStaticMethodOverridesForRequestOptions();
-    List<MethodSpec> instanceOverrides = generateInstanceMethodOverridesForRequestOptions();
+    List<MethodSpec> instanceOverrides =
+        requestOptionsOverrideGenerator.generateInstanceMethodOverridesForRequestOptions(
+            glideOptionsName);
 
     List<MethodAndStaticVar> allMethodsAndStaticVars = new ArrayList<>();
     for (MethodAndStaticVar item : staticOverrides) {
@@ -133,16 +171,17 @@ public MethodSignature apply(MethodAndStaticVar f) {
     }
     allMethodsAndStaticVars.addAll(methodsForExtensions);
 
-    TypeSpec.Builder classBuilder = TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
-        .addAnnotation(
-            AnnotationSpec.builder(SuppressWarnings.class)
-                .addMember("value", "$S", "deprecation")
-                .build())
-        .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
-        .addModifiers(Modifier.FINAL)
-        .addModifiers(Modifier.PUBLIC)
-        .addSuperinterface(Cloneable.class)
-        .superclass(requestOptionsName);
+    TypeSpec.Builder classBuilder =
+        TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
+            .addAnnotation(
+                AnnotationSpec.builder(SuppressWarnings.class)
+                    .addMember("value", "$S", "deprecation")
+                    .build())
+            .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
+            .addModifiers(Modifier.FINAL)
+            .addModifiers(Modifier.PUBLIC)
+            .addSuperinterface(Cloneable.class)
+            .superclass(requestOptionsName);
 
     for (MethodAndStaticVar methodAndStaticVar : allMethodsAndStaticVars) {
       if (methodAndStaticVar.method != null) {
@@ -156,11 +195,13 @@ public MethodSignature apply(MethodAndStaticVar f) {
   }
 
   private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
-    Builder builder = CodeBlock.builder()
-        .add("Automatically generated from {@link $T} annotated classes.\n",
-            GlideExtension.class)
-        .add("\n")
-        .add("@see $T\n", requestOptionsName);
+    Builder builder =
+        CodeBlock.builder()
+            .add(
+                "Automatically generated from {@link $T} annotated classes.\n",
+                GlideExtension.class)
+            .add("\n")
+            .add("@see $T\n", requestOptionsName);
 
     for (String glideExtensionClass : glideExtensionClassNames) {
       builder.add("@see $T\n", ClassName.bestGuess(glideExtensionClass));
@@ -168,143 +209,6 @@ private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
     return builder.build();
   }
 
-  private List<MethodAndStaticVar> generateMethodsForExtensions(
-      Set<String> glideExtensionClassNames) {
-    List<ExecutableElement> requestOptionExtensionMethods =
-        processorUtil.findAnnotatedElementsInClasses(
-            glideExtensionClassNames, GlideOption.class);
-
-    List<MethodAndStaticVar> result = new ArrayList<>(requestOptionExtensionMethods.size());
-    for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
-      result.addAll(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
-    }
-
-    return result;
-  }
-
-  private List<MethodSpec> generateInstanceMethodOverridesForRequestOptions() {
-    return Lists.transform(
-        processorUtil.findInstanceMethodsReturning(requestOptionsType, requestOptionsType),
-        new Function<ExecutableElement, MethodSpec>() {
-          @Override
-          public MethodSpec apply(ExecutableElement input) {
-            return generateRequestOptionOverride(input);
-          }
-        });
-  }
-
-  private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
-    MethodSpec.Builder result = ProcessorUtil.overriding(methodToOverride)
-        .returns(glideOptionsName)
-        .addModifiers(Modifier.FINAL)
-        .addCode(CodeBlock.builder()
-            .add("return ($T) super.$N(", glideOptionsName, methodToOverride.getSimpleName())
-            .add(FluentIterable.from(methodToOverride.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
-                .join(Joiner.on(", ")))
-            .add(");\n")
-            .build());
-
-    if (methodToOverride.getSimpleName().toString().equals("transforms")) {
-      result.addAnnotation(
-          AnnotationSpec.builder(SafeVarargs.class)
-              .build());
-    }
-
-    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
-      result.addAnnotation(AnnotationSpec.get(mirror));
-    }
-
-    return result.build();
-  }
-
-  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtension(
-      ExecutableElement element) {
-    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
-    int overrideType = getOverrideType(element);
-    if (isOverridingRequestOptionsMethod && overrideType == OVERRIDE_NONE) {
-      throw new IllegalArgumentException("Accidentally attempting to override a method in"
-          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
-          + " if this is intentional. Offending method: "
-          + element.getEnclosingElement() + "#" + element);
-    } else if (!isOverridingRequestOptionsMethod && overrideType != OVERRIDE_NONE) {
-      throw new IllegalArgumentException("Requested to override an existing method in"
-          + " RequestOptions, but no such method was found. Offending method: "
-          + element.getEnclosingElement() + "#" + element);
-    }
-    String methodName = element.getSimpleName().toString();
-    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
-        .addModifiers(Modifier.PUBLIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
-        .varargs(element.isVarArgs())
-        .returns(glideOptionsName);
-
-    // The 0th element is expected to be a RequestOptions object.
-    List<? extends VariableElement> parameters =
-        element.getParameters().subList(1, element.getParameters().size());
-
-    // Generates the String and list of arguments to pass in when calling this method or super.
-    // IE centerCrop(context) creates methodLiterals="%L" and methodArgs=[centerCrop, context].
-    List<Object> methodArgs = new ArrayList<>();
-    methodArgs.add(element.getSimpleName().toString());
-    String methodLiterals = "";
-    if (!parameters.isEmpty()) {
-      for (VariableElement variable : parameters) {
-        methodLiterals += "$L, ";
-        methodArgs.add(variable.getSimpleName().toString());
-      }
-      methodLiterals = methodLiterals.substring(0, methodLiterals.length() - 2);
-    }
-
-    builder.beginControlFlow("if (isAutoCloneEnabled())")
-        .addStatement(
-            "return clone().$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
-        .endControlFlow();
-
-    // Add the correct super() call.
-    if (overrideType == OVERRIDE_EXTEND) {
-      String callSuper = "super.$L(" + methodLiterals + ")";
-      builder.addStatement(callSuper, methodArgs.toArray(new Object[0]))
-          .addJavadoc(processorUtil.generateSeeMethodJavadoc(
-              requestOptionsName, methodName, parameters))
-          .addAnnotation(Override.class);
-    }
-
-    builder.addParameters(ProcessorUtil.getParameters(parameters));
-
-    // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
-    List<Object> args = new ArrayList<>();
-    String code = "$T.$L($L, ";
-    args.add(ClassName.get(element.getEnclosingElement().asType()));
-    args.add(element.getSimpleName().toString());
-    args.add("this");
-    if (!parameters.isEmpty()) {
-      for (VariableElement variable : parameters) {
-        code += "$L, ";
-        args.add(variable.getSimpleName().toString());
-      }
-    }
-    code = code.substring(0, code.length() - 2);
-    code += ")";
-    builder.addStatement(code, args.toArray(new Object[0]));
-
-    builder.addStatement("return this");
-
-    List<MethodAndStaticVar> result = new ArrayList<>();
-
-    builder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
-
-    result.add(new MethodAndStaticVar(builder.build()));
-    result.add(generateStaticMethodEquivalentForExtensionMethod(element));
-
-    return result;
-  }
-
   private List<MethodAndStaticVar> generateStaticMethodOverridesForRequestOptions() {
     List<ExecutableElement> staticMethodsThatReturnRequestOptions =
         processorUtil.findStaticMethodsReturning(requestOptionsType, requestOptionsType);
@@ -321,12 +225,12 @@ public String apply(VariableElement input) {
   /**
    * This method is a bit of a hack, but it lets us tie the static version of a method with the
    * instance version. In turn that lets us call the instance versions on the generated subclass,
-   * instead of just delegating to the RequestOptions static methods. Using the instance methods
-   * on the generated subclass allows our static methods to properly call code that overrides
-   * an existing method in RequestOptions.
+   * instead of just delegating to the RequestOptions static methods. Using the instance methods on
+   * the generated subclass allows our static methods to properly call code that overrides an
+   * existing method in RequestOptions.
    *
-   * <p>The string names here just map between the static methods in
-   * {@code com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   * <p>The string names here just map between the static methods in {@code
+   * com.bumptech.glide.request.RequestOptions} and the instance methods they call.
    */
   private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
     String equivalentInstanceMethodName;
@@ -361,25 +265,12 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
     MethodSpec.Builder methodSpecBuilder =
         MethodSpec.methodBuilder(staticMethodName)
             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
-        .returns(glideOptionsName);
-
-    List<? extends VariableElement> parameters = staticMethod.getParameters();
-    String createNewOptionAndCall = "new $T().$N(";
-    if (!parameters.isEmpty()) {
-      methodSpecBuilder.addParameters(ProcessorUtil.getParameters(staticMethod));
-      for (VariableElement parameter : parameters) {
-        createNewOptionAndCall += parameter.getSimpleName().toString();
-        // use the Application Context to avoid memory leaks.
-        if (memoize && isAndroidContext(parameter)) {
-          createNewOptionAndCall += ".getApplicationContext()";
-        }
-        createNewOptionAndCall += ", ";
-      }
-      createNewOptionAndCall =
-          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
-    }
-    createNewOptionAndCall += ")";
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
+            .returns(glideOptionsName);
+
+    StringBuilder createNewOptionAndCall =
+        createNewOptionAndCall(
+            memoize, methodSpecBuilder, "new $T().$N(", ProcessorUtil.getParameters(staticMethod));
 
     FieldSpec requiredStaticField = null;
     if (memoize) {
@@ -389,14 +280,19 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
       // }
 
       // Mix in an incrementing unique id to handle method overloading.
-      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
-      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
-          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
-          .build();
-      methodSpecBuilder.beginControlFlow(
-          "if ($T.$N == null)", glideOptionsName, staticVariableName)
-          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
-              glideOptionsName, staticVariableName, glideOptionsName, equivalentInstanceMethodName,
+      String staticVariableName = staticMethodName + nextFieldId++;
+      requiredStaticField =
+          FieldSpec.builder(glideOptionsName, staticVariableName)
+              .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+              .build();
+      methodSpecBuilder
+          .beginControlFlow("if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement(
+              "$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName,
+              staticVariableName,
+              glideOptionsName,
+              equivalentInstanceMethodName,
               "autoClone()")
           .endControlFlow()
           .addStatement("return $T.$N", glideOptionsName, staticVariableName);
@@ -413,7 +309,9 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
           TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
     }
 
-    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
+    methodSpecBuilder
+        .addAnnotation(processorUtil.checkResult())
+        .addAnnotation(processorUtil.nonNull());
 
     return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
   }
@@ -421,16 +319,44 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
   private static boolean memoizeStaticMethodFromArguments(ExecutableElement staticMethod) {
     return staticMethod.getParameters().isEmpty()
         || (staticMethod.getParameters().size() == 1
-        && staticMethod.getParameters().get(0).getSimpleName().toString()
-        .equals("android.content.Context"));
+            && staticMethod
+                .getParameters()
+                .get(0)
+                .getSimpleName()
+                .toString()
+                .equals("android.content.Context"));
+  }
+
+  private StringBuilder createNewOptionAndCall(
+      boolean memoize,
+      MethodSpec.Builder methodSpecBuilder,
+      String start,
+      List<ParameterSpec> specs) {
+    StringBuilder createNewOptionAndCall = new StringBuilder(start);
+    if (!specs.isEmpty()) {
+      methodSpecBuilder.addParameters(specs);
+      for (ParameterSpec parameter : specs) {
+        createNewOptionAndCall.append(parameter.name);
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall.append(".getApplicationContext()");
+        }
+        createNewOptionAndCall.append(", ");
+      }
+      createNewOptionAndCall =
+          new StringBuilder(
+              createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2));
+    }
+    createNewOptionAndCall.append(")");
+    return createNewOptionAndCall;
+  }
+
+  private boolean isAndroidContext(ParameterSpec parameter) {
+    return parameter.type.toString().equals("android.content.Context");
   }
 
   private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
       ExecutableElement instanceMethod) {
-    boolean skipStaticMethod = skipStaticMethod(instanceMethod);
-    if (skipStaticMethod) {
-      return new MethodAndStaticVar();
-    }
     String staticMethodName = getStaticMethodName(instanceMethod);
     String instanceMethodName = instanceMethod.getSimpleName().toString();
     if (Strings.isNullOrEmpty(staticMethodName)) {
@@ -442,11 +368,14 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     }
     boolean memoize = memoizeStaticMethodFromAnnotation(instanceMethod);
 
-    MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
-        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
-        .varargs(instanceMethod.isVarArgs())
-        .returns(glideOptionsName);
+    //noinspection ResultOfMethodCallIgnored
+    Preconditions.checkNotNull(staticMethodName);
+    MethodSpec.Builder methodSpecBuilder =
+        MethodSpec.methodBuilder(staticMethodName)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+            .varargs(instanceMethod.isVarArgs())
+            .returns(glideOptionsName);
 
     List<? extends VariableElement> parameters = instanceMethod.getParameters();
 
@@ -454,47 +383,41 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     // actual method we want to generate will pass the RequestOptions in to the extension method,
     // but should not itself require a RequestOptions object to be passed in.
     if (parameters.isEmpty()) {
-      throw new IllegalArgumentException(
-          "Expected non-empty parameters for: " + instanceMethod);
+      throw new IllegalArgumentException("Expected non-empty parameters for: " + instanceMethod);
     }
     // Remove is not supported.
     parameters = parameters.subList(1, parameters.size());
 
-    String createNewOptionAndCall = "new $T().$L(";
-    if (!parameters.isEmpty()) {
-      methodSpecBuilder.addParameters(ProcessorUtil.getParameters(parameters));
-      for (VariableElement parameter : parameters) {
-        createNewOptionAndCall += parameter.getSimpleName().toString();
-        // use the Application Context to avoid memory leaks.
-        if (memoize && isAndroidContext(parameter)) {
-          createNewOptionAndCall += ".getApplicationContext()";
-        }
-        createNewOptionAndCall += ", ";
-      }
-      createNewOptionAndCall =
-          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
-    }
-    createNewOptionAndCall += ")";
+    StringBuilder createNewOptionAndCall =
+        createNewOptionAndCall(
+            memoize, methodSpecBuilder, "new $T().$L(", ProcessorUtil.getParameters(parameters));
 
     FieldSpec requiredStaticField = null;
     if (memoize) {
+      // Generates code that looks like:
       // if (GlideOptions.<methodName> == null) {
       //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
       // }
 
       // Mix in an incrementing unique id to handle method overloading.
-      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
-      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
-          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
-          .build();
-      methodSpecBuilder.beginControlFlow(
-          "if ($T.$N == null)", glideOptionsName, staticVariableName)
-          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
-              glideOptionsName, staticVariableName, glideOptionsName, instanceMethodName,
+      String staticVariableName = staticMethodName + nextFieldId++;
+      requiredStaticField =
+          FieldSpec.builder(glideOptionsName, staticVariableName)
+              .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+              .build();
+      methodSpecBuilder
+          .beginControlFlow("if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement(
+              "$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName,
+              staticVariableName,
+              glideOptionsName,
+              instanceMethodName,
               "autoClone()")
           .endControlFlow()
           .addStatement("return $T.$N", glideOptionsName, staticVariableName);
     } else {
+      // Generates code that looks like:
       // return new GlideOptions().<methodName>()
       methodSpecBuilder.addStatement(
           "return " + createNewOptionAndCall, glideOptionsName, instanceMethodName);
@@ -506,86 +429,31 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
           TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
     }
 
-    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
+    methodSpecBuilder.addAnnotation(processorUtil.checkResult());
 
     return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
   }
 
-  private boolean isAndroidContext(VariableElement variableElement) {
-    Element element = processingEnvironment.getTypeUtils().asElement(variableElement.asType());
-    return element.toString().equals("android.content.Context");
-  }
-
-  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
-    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
-    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
-    // first type.
-    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
-    String toFindSimpleName = toFind.getSimpleName().toString();
-    for (Element element : requestOptionsType.getEnclosedElements()) {
-      if (element.getKind() != ElementKind.METHOD) {
-        continue;
-      }
-      ExecutableElement inBase = (ExecutableElement) element;
-      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
-        List<String> parameterNamesInBase =
-            getComparableParameterNames(inBase, false /*skipFirst*/);
-        if (parameterNamesInBase.equals(toFindParameterNames)) {
-          return true;
-        }
-      }
-    }
-    return false;
-  }
-
-  private static List<String> getComparableParameterNames(
-      ExecutableElement element, boolean skipFirst) {
-    List<? extends VariableElement> parameters = element.getParameters();
-    if (skipFirst) {
-      parameters = parameters.subList(1, parameters.size());
-    }
-    List<String> result = new ArrayList<>(parameters.size());
-    for (VariableElement parameter : parameters) {
-      result.add(parameter.asType().toString());
-    }
-    return result;
-  }
-
-  private static int getOverrideType(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
-    return glideOption.override();
-  }
-
   @Nullable
   private static String getStaticMethodName(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
+    GlideOption glideOption = element.getAnnotation(GlideOption.class);
     String result = glideOption != null ? glideOption.staticMethodName() : null;
     return Strings.emptyToNull(result);
   }
 
   private static boolean memoizeStaticMethodFromAnnotation(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
+    GlideOption glideOption = element.getAnnotation(GlideOption.class);
     return glideOption != null && glideOption.memoizeStaticMethod();
   }
 
   private static boolean skipStaticMethod(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
+    GlideOption glideOption = element.getAnnotation(GlideOption.class);
     return glideOption != null && glideOption.skipStaticMethod();
   }
 
   private static final class MethodAndStaticVar {
-    @Nullable
-    final MethodSpec method;
-    @Nullable
-    final FieldSpec staticField;
-
-    MethodAndStaticVar() {
-      this(null /*method*/);
-    }
+    @Nullable final MethodSpec method;
+    @Nullable final FieldSpec staticField;
 
     MethodAndStaticVar(@Nullable MethodSpec method) {
       this(method, null /*staticField*/);
@@ -600,22 +468,23 @@ private static boolean skipStaticMethod(ExecutableElement element) {
   private static final class MethodSignature {
     private final TypeName returnType;
     private final List<TypeName> parameterTypes;
-    private final Set<Modifier> modifiers;
+    private final boolean isStatic;
     private final String name;
 
     MethodSignature(MethodSpec spec) {
       name = spec.name;
-      modifiers = spec.modifiers;
+      isStatic = spec.modifiers.contains(Modifier.STATIC);
       returnType = spec.returnType;
       parameterTypes =
-          Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
-            @Nullable
-            @Override
-            public TypeName apply(ParameterSpec parameterSpec) {
-              return parameterSpec.type;
-
-            }
-          });
+          Lists.transform(
+              spec.parameters,
+              new Function<ParameterSpec, TypeName>() {
+                @Nullable
+                @Override
+                public TypeName apply(ParameterSpec parameterSpec) {
+                  return parameterSpec.type;
+                }
+              });
     }
 
     @Override
@@ -625,14 +494,14 @@ public boolean equals(Object o) {
         return name.equals(other.name)
             && returnType.equals(other.returnType)
             && parameterTypes.equals(other.parameterTypes)
-            && modifiers.equals(other.modifiers);
+            && isStatic == other.isStatic;
       }
       return false;
     }
 
     @Override
     public int hashCode() {
-      return Objects.hashCode(name, returnType, parameterTypes, modifiers);
+      return Objects.hashCode(name, returnType, parameterTypes, isStatic);
     }
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
new file mode 100644
index 000000000..6dea2d18d
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
@@ -0,0 +1,104 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.RequestOptionsGenerator.BASE_REQUEST_OPTIONS_QUALIFIED_NAME;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates overrides for BaseRequestOptions methods so that subclasses' methods return the
+ * subclass type, not just BaseRequestOptions.
+ */
+final class RequestOptionsOverrideGenerator {
+
+  private final TypeElement baseRequestOptionsType;
+  private ProcessorUtil processorUtil;
+
+  RequestOptionsOverrideGenerator(
+      ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+
+    this.processorUtil = processorUtil;
+    baseRequestOptionsType =
+        processingEnv.getElementUtils().getTypeElement(BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  List<MethodSpec> generateInstanceMethodOverridesForRequestOptions(TypeName typeToOverrideIn) {
+    return generateInstanceMethodOverridesForRequestOptions(
+        typeToOverrideIn, Collections.<String>emptySet());
+  }
+
+  List<MethodSpec> generateInstanceMethodOverridesForRequestOptions(
+      final TypeName typeToOverrideIn, final Set<String> excludedMethods) {
+    return FluentIterable.from(
+            processorUtil.findInstanceMethodsReturning(
+                baseRequestOptionsType, baseRequestOptionsType))
+        .filter(
+            new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement input) {
+                return !excludedMethods.contains(input.getSimpleName().toString());
+              }
+            })
+        .transform(
+            new Function<ExecutableElement, MethodSpec>() {
+              @Override
+              public MethodSpec apply(ExecutableElement input) {
+                return generateRequestOptionOverride(typeToOverrideIn, input);
+              }
+            })
+        .toList();
+  }
+
+  private MethodSpec generateRequestOptionOverride(
+      TypeName typeToOverrideIn, ExecutableElement methodToOverride) {
+    MethodSpec.Builder result =
+        ProcessorUtil.overriding(methodToOverride).returns(typeToOverrideIn);
+    result.addCode(
+        CodeBlock.builder()
+            .add("return ($T) super.$N(", typeToOverrideIn, methodToOverride.getSimpleName())
+            .add(
+                FluentIterable.from(result.build().parameters)
+                    .transform(
+                        new Function<ParameterSpec, String>() {
+                          @Override
+                          public String apply(ParameterSpec input) {
+                            return input.name;
+                          }
+                        })
+                    .join(Joiner.on(", ")))
+            .add(");\n")
+            .build());
+
+    if (methodToOverride.getSimpleName().toString().contains("transform")
+        && methodToOverride.isVarArgs()) {
+      result
+          .addModifiers(Modifier.FINAL)
+          .addAnnotation(SafeVarargs.class)
+          .addAnnotation(
+              AnnotationSpec.builder(SuppressWarnings.class)
+                  .addMember("value", "$S", "varargs")
+                  .build());
+    }
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      result.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    return result.build();
+  }
+}
diff --git a/annotation/compiler/src/main/resources/META-INF/gradle/incremental.annotation.processors b/annotation/compiler/src/main/resources/META-INF/gradle/incremental.annotation.processors
new file mode 100644
index 000000000..1b2cafe7f
--- /dev/null
+++ b/annotation/compiler/src/main/resources/META-INF/gradle/incremental.annotation.processors
@@ -0,0 +1 @@
+com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating
diff --git a/annotation/compiler/test/.gitignore b/annotation/compiler/test/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/compiler/test/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/compiler/test/build.gradle b/annotation/compiler/test/build.gradle
new file mode 100644
index 000000000..31b35b527
--- /dev/null
+++ b/annotation/compiler/test/build.gradle
@@ -0,0 +1,100 @@
+import org.gradle.internal.jvm.Jvm
+
+apply plugin: 'com.android.library'
+
+android {
+    sourceSets {
+        test {
+            resources {
+                // *.java is excluded by default...
+                setExcludes([])
+            }
+            // TODO: Re-enable these tests after fixing import orders.
+            java {
+                exclude "**/AppGlideModuleWithExcludesTest.java"
+                exclude "**/AppGlideModuleWithLibraryInPackageTest.java"
+                exclude "**/AppGlideModuleWithMultipleExcludesTest.java"
+                exclude "**/EmptyAppAndLibraryGlideModulesTest.java"
+                exclude "**/GlideExtensionWithOptionTest.java"
+                exclude "**/GlideExtensionWithTypeTest.java"
+                exclude "**/GlideExtensionWithTypeTest.java"
+            }
+        }
+    }
+}
+
+afterEvaluate {
+    lint.enabled = false
+    compileDebugJavaWithJavac.enabled = false
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
+    testOptions {
+        unitTests {
+            all { Test testTask ->
+                testTask.maxParallelForks = 2
+            }
+        }
+    }
+}
+
+// This special test only submodule exists because adding the :glide dependency seems to break
+// the annotation processor dependency chain for the internal sample apps. It's also somewhat
+// easier to parse as a separate module given the existing complexity here and in the compiler
+// build.gradle file.
+dependencies {
+    testImplementation project(':glide')
+    testImplementation project(':annotation:compiler')
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "com.squareup:javapoet:${JAVAPOET_VERSION}"
+    testImplementation "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    // Using 0.10 of compile-testing is required for Android Studio to function, but not for the
+    // gradle build. Not yet clear why, but it looks like some kind of version conflict between
+    // javapoet, guava and/or truth.
+    //noinspection GradleDependency
+    testImplementation ("com.google.testing.compile:compile-testing:0.10") {
+        // We don't use this and including it requires us to list it separatel which would be
+        // confusing.
+        exclude group: "com.google.auto.value", module: "auto-value"
+    }
+    testImplementation "androidx.annotation:annotation:${ANDROID_X_VERSION}"
+    testImplementation "androidx.fragment:fragment:${ANDROID_X_VERSION}"
+    testImplementation "androidx.legacy:legacy-support-v4:${ANDROID_X_VERSION}"
+    // TODO: this seems excessive, but it works...
+    testImplementation files(Jvm.current().getJre().homeDir.getAbsolutePath()+'/lib/rt.jar')
+
+    testAnnotationProcessor project(':annotation:compiler')
+    testAnnotationProcessor "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
+}
+
+task regenerateTestResources {
+    group 'Verification'
+    description 'Regenerates all test resource files under annotation/compiler/test/src/test/resources that are compared against the current output to detect regressions'
+    tasks.withType(Test) {
+        systemProperties.put("com.bumptech.glide.annotation.compiler.test.regenerate.path", projectDir)
+    }
+    doFirst {
+        println("Regenerating test resources....")
+    }
+    doLast {
+        println("Finished regenerating test resources")
+    }
+}
+
+afterEvaluate {
+    regenerateTestResources.finalizedBy(testDebugUnitTest)
+}
+
diff --git a/annotation/compiler/test/src/main/AndroidManifest.xml b/annotation/compiler/test/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..a41245187
--- /dev/null
+++ b/annotation/compiler/test/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.annotation.compiler.test">
+  <application />
+</manifest>
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
new file mode 100644
index 000000000..695a8d36e
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
@@ -0,0 +1,95 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class. */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithExcludesTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(forResource("AppModuleWithExcludes.java"), emptyLibraryModule());
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .hasSourceEquivalentTo(appResource("GlideOptions.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java
new file mode 100644
index 000000000..24d316d31
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class in a
+ * strangely named subpackage.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithLibraryInPackageTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithLibraryInPackage.java"),
+                forResource("LibraryModuleInPackage.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .hasSourceEquivalentTo(appResource("GlideOptions.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
new file mode 100644
index 000000000..e6484cdac
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation with multiple excluded Module classes.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithMultipleExcludesTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithMultipleExcludes.java"),
+                forResource("EmptyLibraryModule1.java"),
+                forResource("EmptyLibraryModule2.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .hasSourceEquivalentTo(appResource("GlideOptions.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
new file mode 100644
index 000000000..f0717103a
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
@@ -0,0 +1,117 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.libraryResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding both an empty {@link com.bumptech.glide.module.AppGlideModule} and an empty {@link
+ * com.bumptech.glide.module.LibraryGlideModule} in a single project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyAppAndLibraryGlideModulesTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(emptyAppModule(), emptyLibraryModule());
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .hasSourceEquivalentTo(appResource("GlideOptions.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedIndexer() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .hasSourceEquivalentTo(libraryResource(expectedClassName + ".java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
new file mode 100644
index 000000000..f1f241d6c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
@@ -0,0 +1,93 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests adding a single {@link com.bumptech.glide.test.EmptyAppModule} in a project. */
+@RunWith(JUnit4.class)
+public class EmptyAppGlideModuleTest implements CompilationProvider {
+  private static final String MODULE_NAME = "EmptyAppModule.java";
+
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac().withProcessors(new GlideAnnotationProcessor()).compile(forResource(MODULE_NAME));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(6);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .hasSourceEquivalentTo(forResource("GlideOptions.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .hasSourceEquivalentTo(forResource("GlideRequest.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .hasSourceEquivalentTo(forResource("GlideRequests.java"));
+  }
+
+  @Test
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .hasSourceEquivalentTo(forResource("GlideApp.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .hasSourceEquivalentTo(forResource("GeneratedRequestManagerFactory.java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
new file mode 100644
index 000000000..935bd0528
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
@@ -0,0 +1,58 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests adding a single {@link com.bumptech.glide.module.LibraryGlideModule} in a project. */
+@RunWith(JUnit4.class)
+public class EmptyLibraryGlideModuleTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private static final String MODULE_NAME = "EmptyLibraryModule.java";
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac().withProcessors(new GlideAnnotationProcessor()).compile(forResource(MODULE_NAME));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(1);
+  }
+
+  @Test
+  public void compilation_generatesExpectedIndexer() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .hasSourceEquivalentTo(forResource(expectedClassName + ".java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
new file mode 100644
index 000000000..196275e97
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
@@ -0,0 +1,145 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.SubDirectory;
+import com.bumptech.glide.annotation.compiler.test.TestDescription;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies only the output we expect to change based on the various configurations of GlideOptions.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionOptionsTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  @Rule public final TestDescription testDescription = new TestDescription();
+  private static final String EXTENSION_NAME = "Extension.java";
+  private Compilation currentCompilation;
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtendMultipleArguments")
+  public void compilation_withOverrideReplace_andMultipleArguments_validOptions()
+      throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtendMultipleArguments")
+  public void compilation_withOverrideReplace_andMultipleArguments_validRequest()
+      throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return currentCompilation;
+  }
+
+  private enum Subject {
+    GlideOptions,
+    GlideRequest;
+
+    String file() {
+      return name() + ".java";
+    }
+  }
+
+  private void runTest(Subject subject) {
+    String subDir = getSubDirectoryName();
+    currentCompilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(emptyAppModule(), extension(subDir));
+    assertThat(currentCompilation).succeededWithoutWarnings();
+
+    assertThat(currentCompilation)
+        .generatedSourceFile(subpackage(subject.name()))
+        .hasSourceEquivalentTo(forResource(subDir, subject.file()));
+  }
+
+  private String getSubDirectoryName() {
+    return testDescription.getDescription().getAnnotation(SubDirectory.class).value();
+  }
+
+  private JavaFileObject extension(String subdir) {
+    return forResource(subdir, EXTENSION_NAME);
+  }
+
+  private JavaFileObject forResource(String subdir, String name) {
+    return Util.forResource(getClass().getSimpleName(), subdir + "/" + name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
new file mode 100644
index 000000000..6159908d1
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
@@ -0,0 +1,103 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension option in the new option
+ * style where extension methods always return values.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionWithOptionTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(emptyAppModule(), forResource("ExtensionWithOption.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .hasSourceEquivalentTo(forResource("GlideOptions.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .hasSourceEquivalentTo(forResource("GlideRequest.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .hasSourceEquivalentTo(appResource("GeneratedAppGlideModuleImpl.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
new file mode 100644
index 000000000..8ed47e14c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
@@ -0,0 +1,100 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Verifies the output of the processor with a simple single extension type. */
+@RunWith(JUnit4.class)
+public class GlideExtensionWithTypeTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(emptyAppModule(), forResource("ExtensionWithType.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .hasSourceEquivalentTo(forResource("GlideOptions.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .hasSourceEquivalentTo(forResource("GlideRequests.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .hasSourceEquivalentTo(appResource("GeneratedAppGlideModuleImpl.java"));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
new file mode 100644
index 000000000..36cd916be
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
@@ -0,0 +1,80 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.assertThrows;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests AppGlideModules with invalid usages of the @Excludes annotation. */
+// Ignore warnings since most methods use assertThrows
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidAppGlideModuleWithExcludesTest {
+  @Test
+  public void compilation_withMissingExcludedModuleClass_throws() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    JavaFileObjects.forSourceLines(
+                        "AppModuleWithExcludes",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.Excludes;",
+                        "import com.bumptech.glide.annotation.GlideModule;",
+                        "import com.bumptech.glide.module.AppGlideModule;",
+                        "import com.bumptech.glide.test.EmptyLibraryModule;",
+                        "@GlideModule",
+                        "@Excludes(EmptyLibraryModule.class)",
+                        "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withEmptyExcludes_fails() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "AppModuleWithExcludes",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.Excludes;",
+                    "import com.bumptech.glide.annotation.GlideModule;",
+                    "import com.bumptech.glide.module.AppGlideModule;",
+                    "import com.bumptech.glide.test.EmptyLibraryModule;",
+                    "@GlideModule",
+                    "@Excludes",
+                    "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+    assertThat(compilation).failed();
+  }
+
+  @Test
+  public void compilation_withNonGlideModule_throws() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "AppModuleWithExcludes",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.Excludes;",
+                    "import com.bumptech.glide.annotation.GlideModule;",
+                    "import com.bumptech.glide.module.AppGlideModule;",
+                    "import com.bumptech.glide.test.EmptyLibraryModule;",
+                    "@GlideModule",
+                    "@Excludes(Object.class)",
+                    "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+    assertThat(compilation).failed();
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
new file mode 100644
index 000000000..ae7568cc8
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
@@ -0,0 +1,125 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s themselves. */
+// Avoid warnings when asserting on exceptions.
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideExtensionTest {
+  @Test
+  public void compilation_withPublicConstructor_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PublicConstructor",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class PublicConstructor { }"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("non-private constructor");
+      Truth.assertThat(cause.getMessage()).contains("PublicConstructor");
+    }
+  }
+
+  @Test
+  public void compilation_withPackagePrivateExtension_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PackagePrivateExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "class PackagePrivateExtension {",
+                  "  private PackagePrivateExtension() {}",
+                  "}"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("must be public");
+      Truth.assertThat(cause.getMessage()).contains("PackagePrivateExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withConstructorWithParameters_throws() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "ConstructorParametersExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class ConstructorParametersExtension {",
+                  "  private ConstructorParametersExtension(int failParam) {}",
+                  "  public void doSomething() {}",
+                  "}"));
+      fail("Failed to get expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("parameters in the constructor");
+      Truth.assertThat(cause.getMessage()).contains("ConstructorParametersExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withNonStaticMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  public void doSomething() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withStaticMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  public static void doSomething() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
new file mode 100644
index 000000000..170b37ecc
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
@@ -0,0 +1,391 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s for methods annotated
+ * with {@link com.bumptech.glide.annotation.GlideOption}.
+ */
+// Ignore warnings since most methods use assertThrows.
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideOptionsExtensionTest {
+  @Test
+  public void compilation_withAnnotatedNonStaticMethod_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideOption;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideOption",
+                        "  public void doSomething() {}",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgInWrongOrder_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "NonRequestOptionsFirstArgExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.BaseRequestOptions;",
+                  "@GlideExtension",
+                  "public class NonRequestOptionsFirstArgExtension{",
+                  "  private NonRequestOptionsFirstArgExtension() {}",
+                  "  @GlideOption",
+                  "  public static BaseRequestOptions<?> doSomething(",
+                  "      Object arg1, BaseRequestOptions<?> options) {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("BaseRequestOptions<?> object as their first parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("NonRequestOptionsFirstArgExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArg_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption",
+                    "  public static BaseRequestOptions<?> doSomething(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgAndOtherArg_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption",
+                    "  public static BaseRequestOptions<?> doSomething(",
+                    "      BaseRequestOptions<?> options, Object arg2) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void compilation_overridingOptionWithoutAnnotationType_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideOption;",
+                        "import com.bumptech.glide.request.BaseRequestOptions;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideOption",
+                        "  public static BaseRequestOptions<?> centerCrop(",
+                        "      BaseRequestOptions<?> options) {",
+                        "    return options;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withOverrideExtend_butNotOverridingMethod_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideOption;",
+                        "import com.bumptech.glide.request.BaseRequestOptions;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                        "  public static BaseRequestOptions<?> something(",
+                        "      BaseRequestOptions<?> options) {",
+                        "    return options;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withOverrideExtend_andOverridingMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                    "  public static BaseRequestOptions<?> centerCrop(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void compilation_withOverrideReplace_butNotOverridingMethod_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideOption;",
+                        "import com.bumptech.glide.request.BaseRequestOptions;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                        "  public static BaseRequestOptions<?> something(",
+                        "      BaseRequestOptions<?> options) {",
+                        "    return options;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withOverrideReplace_andOverridingMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                    "  public static BaseRequestOptions<?> centerCrop(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void compilation_withRequestOptionsReturnValue_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import androidx.annotation.NonNull;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideOption",
+                    "  public static BaseRequestOptions<?> doSomething(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withNonRequestOptionsReturnValue_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import androidx.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.BaseRequestOptions;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static Object doSomething(BaseRequestOptions<?> options) {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideOption methods should return a BaseRequestOptions<?> object");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withMissingNonNullAnnotation_warns() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption",
+                    "  public static BaseRequestOptions<?> doSomething(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("androidx.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#doSomething");
+  }
+
+  @Test
+  public void compilation_withNoOptionParameters_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "MissingRequestOptionsExtension",
+                  "package com.bumptech.glide.test;",
+                  "import androidx.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.BaseRequestOptions;",
+                  "@GlideExtension",
+                  "public class MissingRequestOptionsExtension {",
+                  "  private MissingRequestOptionsExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static BaseRequestOptions<?> doSomething() {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("BaseRequestOptions<?> object as their first parameter");
+      Truth.assertThat(message).contains("doSomething");
+      Truth.assertThat(message).contains("MissingRequestOptionsExtension");
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
new file mode 100644
index 000000000..21f3ae81c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
@@ -0,0 +1,413 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s for methods annotated
+ * with {@link com.bumptech.glide.annotation.GlideType}.
+ */
+// Ignore warnings since most methods use assertThrows.
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideTypeExtensionTest {
+  @Test
+  public void compilation_withAnnotatedNonStaticMethod_fails() {
+    assertThrows(
+        "@GlideType methods must be static",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import androidx.annotation.NonNull;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideType;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @NonNull",
+                        "  @GlideType(Number.class)",
+                        "  public RequestBuilder<Number> doSomething(",
+                        "      RequestBuilder<Number> builder) {",
+                        "    return builder;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withoutRequestBuilderArg_fails() {
+    assertThrows(
+        "@GlideType methods must take a RequestBuilder object as their first and only"
+            + " parameter, but given multiple for:"
+            + " com.bumptech.glide.test.Extension#doSomething()",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideType;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideType(Number.class)",
+                        "  public static RequestBuilder<Number> doSomething() {",
+                        "    return null;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestBuilderArg_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import androidx.annotation.NonNull;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> type(RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withNonRequestBuilderArg_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongParameterTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import androidx.annotation.NonNull;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongParameterTypeExtension {",
+                  "  private WrongParameterTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Number> type(Object arg) {",
+                  "    return null;",
+                  "  }",
+                  "}"));
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestBuilder object as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongParameterTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestBuilderArgAndOtherArg_fails() {
+    assertThrows(
+        "@GlideType methods must take a RequestBuilder object as their first and only"
+            + " parameter, but given multiple for:"
+            + " com.bumptech.glide.test.Extension#type("
+            + "com.bumptech.glide.RequestBuilder<java.lang.Number>,"
+            + "java.lang.Object)",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import androidx.annotation.NonNull;",
+                        "import com.bumptech.glide.RequestBuilder;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideType;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @NonNull",
+                        "  @GlideType(Number.class)",
+                        "  public static RequestBuilder<Number> type(",
+                        "      RequestBuilder<Number> builder, Object arg2) {",
+                        "    return builder;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_overridingExistingType_fails() {
+    final Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.graphics.drawable.Drawable;",
+                    "import androidx.annotation.NonNull;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideType(Drawable.class)",
+                    "  public static RequestBuilder<Drawable> asDrawable(",
+                    "      RequestBuilder<Drawable> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+
+    assertThrows(
+        "error: method asDrawable() is already defined in class"
+            + " com.bumptech.glide.test.GlideRequests",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            compilation.generatedSourceFile(subpackage("GlideRequests"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import androidx.annotation.NonNull;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningNonRequestBuilder_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import androidx.annotation.NonNull;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideType(Number.class)",
+                  "  public static Object asNumber(",
+                  "      RequestBuilder<Number> builder) {",
+                  "    return new Object();",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods should return a RequestBuilder");
+      Truth.assertThat(message).contains("Number");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilderWithIncorrectType_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongBuilderTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import androidx.annotation.NonNull;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongBuilderTypeExtension {",
+                  "  private WrongBuilderTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Object> asNumber(",
+                  "      RequestBuilder<Object> builder) {",
+                  "    return builder;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideType methods should return a RequestBuilder<java.lang.Number>");
+      Truth.assertThat(message).contains("WrongBuilderTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilder_andMultipleParams_fails() {
+    assertThrows(
+        "@GlideType methods must take a RequestBuilder object as their first and only parameter,"
+            + " but given multiple for:"
+            + " com.bumptech.glide.test.Extension#asNumber("
+            + "com.bumptech.glide.RequestBuilder<java.lang.Number>,java.lang.Object)",
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import androidx.annotation.NonNull;",
+                        "import com.bumptech.glide.RequestBuilder;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideType;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @NonNull",
+                        "  @GlideType(Number.class)",
+                        "  public static RequestBuilder<Number> asNumber(",
+                        "      RequestBuilder<Number> builder, Object arg1) {",
+                        "    return builder;",
+                        "  }",
+                        "}"));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilder_nonBuilderParam_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "IncorrectParameterExtension",
+                  "package com.bumptech.glide.test;",
+                  "import androidx.annotation.NonNull;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class IncorrectParameterExtension {",
+                  "  private IncorrectParameterExtension() {}",
+                  "  @NonNull",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Number> asNumber(",
+                  "      Object arg) {",
+                  "    return null;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains(
+              "@GlideType methods must take a RequestBuilder object"
+                  + " as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("IncorrectParameterExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_missingNonNull_warns() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("androidx.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#asNumber");
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
new file mode 100644
index 000000000..3cec01e4a
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
@@ -0,0 +1,70 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.assertThrows;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Ensures that adding more than one {@link com.bumptech.glide.module.AppGlideModule} to a project
+ * will fail.
+ */
+@RunWith(JUnit4.class)
+public class MultipleAppGlideModuleTest implements CompilationProvider {
+  private static final String FIRST_MODULE = "EmptyAppModule1.java";
+  private static final String SECOND_MODULE = "EmptyAppModule2.java";
+
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  // Throws.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void compilation_withTwoAppModules_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(forResource(FIRST_MODULE), forResource(SECOND_MODULE));
+          }
+        });
+  }
+
+  @Test
+  public void compilation_withFirstModuleOnly_succeeds() {
+    compilation =
+        javac().withProcessors(new GlideAnnotationProcessor()).compile(forResource(FIRST_MODULE));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withSecondModuleOnly_succeeds() {
+    compilation =
+        javac().withProcessors(new GlideAnnotationProcessor()).compile(forResource(SECOND_MODULE));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
new file mode 100644
index 000000000..5d6f6947f
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests adding multiple {@link com.bumptech.glide.module.LibraryGlideModule}s in a project. */
+@RunWith(JUnit4.class)
+public class MultipleEmptyLibraryGlideModuleTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("EmptyLibraryModule1.java"), forResource("EmptyLibraryModule2.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(1);
+  }
+
+  @Test
+  public void compilation_generatesExpectedIndexerForModules() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide"
+            + "_test_EmptyLibraryModule2";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .hasSourceEquivalentTo(forResource(expectedClassName + ".java"));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/CompilationProvider.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/CompilationProvider.java
new file mode 100644
index 000000000..41688bf9d
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/CompilationProvider.java
@@ -0,0 +1,8 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import com.google.testing.compile.Compilation;
+
+/** Provides the {@link Compilation} used to compile test code. */
+public interface CompilationProvider {
+  Compilation getCompilation();
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
new file mode 100644
index 000000000..c3366c323
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the method in question is referencing a test resource that it doesn't "own" and
+ * should not attempt to regenerate.
+ *
+ * <p>Used by {@link RegenerateResourcesRule} to ensure that if we are regenerating resources, we're
+ * only regenerating them for a single class and only for the single class that has the correct name
+ * and directory sequence so that we update the correct file.
+ *
+ * <p>Ideally this wouldn't be necessary. It would be great if we could find a way to go from the
+ * test failure more directly to the actual path of the resource used. Right now we're basically
+ * guessing based on this annotation, the class name of the test class, and any values from {@link
+ * SubDirectory}. Without this annotation, we'd end up writing files that were never used.
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ReferencedResource {}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
new file mode 100644
index 000000000..2ab2d50a5
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
@@ -0,0 +1,112 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+
+import androidx.annotation.NonNull;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import javax.tools.JavaFileObject;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Regenerates test resources for annotation compiler tests when the {@link
+ * Util#REGENERATE_TEST_RESOURCES_PROPERTY_NAME} property is set to the directory containing the
+ * project.
+ *
+ * <p>This can easily be used via gradle by running: {@code ./gradlew
+ * :annotation:compiler:test:regenerateTestResources }
+ *
+ * <p>Our regenerate task will set the appropriate environment variables that will allow the logic
+ * here to succeed. When running the tests normally, this class will do nothing.
+ */
+public final class RegenerateResourcesRule implements TestRule {
+
+  private CompilationProvider test;
+
+  public RegenerateResourcesRule(CompilationProvider test) {
+    this.test = test;
+  }
+
+  @Override
+  public Statement apply(final Statement base, final Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } catch (AssertionError e) {
+          String projectRoot = Util.getProjectRootIfRegeneratingTestResources();
+          if (projectRoot == null || description.getAnnotation(ReferencedResource.class) != null) {
+            throw e;
+          }
+          updateResourceFile(e, projectRoot, description);
+        }
+      }
+    };
+  }
+
+  private void updateResourceFile(
+      AssertionError e, @NonNull String projectDirectory, Description description) {
+    String testClassName = test.getClass().getSimpleName();
+    String testFileName = parseFileNameFromMessage(e);
+    String testDirectory = projectDirectory + "/src/test/resources/" + testClassName;
+    String subDirectorySegment =
+        description.getAnnotation(SubDirectory.class) != null
+            ? description.getAnnotation(SubDirectory.class).value() + "/"
+            : "";
+
+    File expectedDirectory = new File(testDirectory + "/" + subDirectorySegment);
+    if (!expectedDirectory.exists() && !expectedDirectory.mkdirs()) {
+      throw new IllegalStateException(
+          "Failed to generate expected directory: " + expectedDirectory);
+    }
+    if (!expectedDirectory.isDirectory()) {
+      throw new IllegalStateException(
+          "Expected a directory, but found a file: " + expectedDirectory);
+    }
+
+    File expectedFile = new File(expectedDirectory, testFileName);
+    Writer writer = null;
+    try {
+      writer = new FileWriter(expectedFile);
+      writer.write(asUnixChars(parseActual(testFileName)).toString());
+      writer.close();
+    } catch (IOException e1) {
+      throw new RuntimeException("Failed to regenerate test file", e1);
+    } finally {
+      if (writer != null) {
+        try {
+          writer.close();
+        } catch (IOException exception) {
+          // Ignore.
+        }
+      }
+    }
+  }
+
+  private String parseActual(String fileName) {
+    for (JavaFileObject javaFileObject : test.getCompilation().generatedSourceFiles()) {
+      if (javaFileObject.getName().contains(fileName)) {
+        try {
+          return javaFileObject.getCharContent(true).toString();
+        } catch (IOException e) {
+          throw new IllegalStateException(e);
+        }
+      }
+    }
+    throw new IllegalStateException("Failed to find source file for name: " + fileName);
+  }
+
+  // Parses </SOURCE_OUTPUT/com/bumptech/glide/test/GlideOptions.java> to GlideOptions.java.
+  private static String parseFileNameFromMessage(AssertionError e) {
+    String message = e.getMessage();
+    int firstGreaterThanIndex = message.indexOf('>');
+    String substring = message.substring(0, firstGreaterThanIndex);
+    int lastForwardSlashIndex = substring.lastIndexOf('/');
+    return substring.substring(lastForwardSlashIndex + 1, substring.length());
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
new file mode 100644
index 000000000..ad1d0eb23
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
@@ -0,0 +1,19 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates the subdirectory for a particular test that contains the test resource(s) used for the
+ * method.
+ *
+ * <p>Used both by tests to extract the correct subdirectory and by the {@link
+ * RegenerateResourcesRule} for the same purpose.
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SubDirectory {
+  String value();
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
new file mode 100644
index 000000000..1df6aa6c1
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import org.junit.rules.TestWatcher;
+import org.junit.runner.Description;
+
+/**
+ * Exposes the {@link Description} for the current test, similar to {@link
+ * org.junit.rules.TestName}.
+ */
+public final class TestDescription extends TestWatcher {
+  private Description description;
+
+  @Override
+  protected void starting(Description description) {
+    this.description = description;
+  }
+
+  public Description getDescription() {
+    return description;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
new file mode 100644
index 000000000..85d51e38c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
@@ -0,0 +1,88 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+
+/** Test utilities. */
+public final class Util {
+  private static final String REGENERATE_TEST_RESOURCES_PROPERTY_NAME =
+      "com.bumptech.glide.annotation.compiler.test.regenerate.path";
+  private static final String GLIDE_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String SUB_PACKAGE_NAME = qualified(GLIDE_PACKAGE_NAME, "test");
+  private static final String ANNOTATION_PACKAGE_NAME = "com.bumptech.glide.annotation.compiler";
+  private static final String DEFAULT_APP_DIR_NAME = "EmptyAppGlideModuleTest";
+  private static final String DEFAULT_LIBRARY_DIR_NAME = "EmptyLibraryGlideModuleTest";
+  /**
+   * Hardcoded file separator to workaround {@code JavaFileObjects.forResource(...)} defaulting to
+   * the unix one.
+   */
+  private static final String FILE_SEPARATOR = "/";
+
+  private static final String LINE_SEPARATOR = "\n";
+
+  private Util() {
+    // Utility class.
+  }
+
+  /**
+   * Returns the {@code String} from a system property that is expected to contain the project
+   * directory for the module containing these tests or {@code null} if we're not currently
+   * attempting to regenerate test resources.
+   */
+  static String getProjectRootIfRegeneratingTestResources() {
+    return System.getProperty(REGENERATE_TEST_RESOURCES_PROPERTY_NAME);
+  }
+
+  public static JavaFileObject emptyAppModule() {
+    return appResource("EmptyAppModule.java");
+  }
+
+  public static JavaFileObject emptyLibraryModule() {
+    return libraryResource("EmptyLibraryModule.java");
+  }
+
+  public static JavaFileObject appResource(String className) {
+    return forResource(DEFAULT_APP_DIR_NAME, className);
+  }
+
+  public static JavaFileObject libraryResource(String className) {
+    return forResource(DEFAULT_LIBRARY_DIR_NAME, className);
+  }
+
+  public static JavaFileObject forResource(String directoryName, String name) {
+    try {
+      return JavaFileObjects.forResource(directoryName + FILE_SEPARATOR + name);
+    } catch (IllegalArgumentException e) {
+      // IllegalArgumentException will be thrown if the resource is missing. If we're trying to
+      // generate test resources for a new test, we want to avoid this exception because it does not
+      // contain any expected output that we can write to a file. By returning an empty file, we
+      // avoid the exception and get the output from our comparison tests that we can then write
+      // out.
+      // If we're not regenerating test resources, we should throw the normal exception.
+      if (getProjectRootIfRegeneratingTestResources() != null) {
+        return JavaFileObjects.forSourceString("com.bumptech.test.empty", "");
+      }
+      throw e;
+    }
+  }
+
+  public static String annotation(String className) {
+    return qualified(ANNOTATION_PACKAGE_NAME, className);
+  }
+
+  public static String subpackage(String className) {
+    return qualified(SUB_PACKAGE_NAME, className);
+  }
+
+  public static String glide(String className) {
+    return qualified(GLIDE_PACKAGE_NAME, className);
+  }
+
+  public static CharSequence asUnixChars(CharSequence chars) {
+    return chars.toString().replace(System.lineSeparator(), LINE_SEPARATOR);
+  }
+
+  private static String qualified(String packageName, String className) {
+    return packageName + '.' + className;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java
new file mode 100644
index 000000000..f935829d6
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+@Excludes(EmptyLibraryModule.class)
+public final class AppModuleWithExcludes extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..65601ab29
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import androidx.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithExcludes;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithExcludes appGlideModule;
+
+  public GeneratedAppGlideModuleImpl(Context context) {
+    appGlideModule = new AppModuleWithExcludes();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithExcludes");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/AppModuleWithLibraryInPackage.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/AppModuleWithLibraryInPackage.java
new file mode 100644
index 000000000..78dd983d2
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/AppModuleWithLibraryInPackage.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.test._package.LibraryModuleInPackage;
+
+@GlideModule
+@Excludes(LibraryModuleInPackage.class)
+public final class AppModuleWithLibraryInPackage extends AppGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..02d9b660f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import androidx.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithLibraryInPackage;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithLibraryInPackage appGlideModule;
+
+  public GeneratedAppGlideModuleImpl(Context context) {
+    appGlideModule = new AppModuleWithLibraryInPackage();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithLibraryInPackage");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test._package.LibraryModuleInPackage");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test._package.LibraryModuleInPackage.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/LibraryModuleInPackage.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/LibraryModuleInPackage.java
new file mode 100644
index 000000000..88f305b24
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/LibraryModuleInPackage.java
@@ -0,0 +1,8 @@
+// _ in the name is important otherwise everything would work
+package com.bumptech.glide.test._package;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class LibraryModuleInPackage extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java
new file mode 100644
index 000000000..94600d8e4
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+@Excludes({EmptyLibraryModule1.class, EmptyLibraryModule2.class})
+public final class AppModuleWithMultipleExcludes extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java
new file mode 100644
index 000000000..236008a91
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule1 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java
new file mode 100644
index 000000000..8a43eb292
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule2 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..6b285af41
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,53 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import androidx.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithMultipleExcludes;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithMultipleExcludes appGlideModule;
+
+  public GeneratedAppGlideModuleImpl(Context context) {
+    appGlideModule = new AppModuleWithMultipleExcludes();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithMultipleExcludes");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule1");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule2");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule1.class);
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule2.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..7180b6f62
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import androidx.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.EmptyAppModule;
+import com.bumptech.glide.test.EmptyLibraryModule;
+import java.util.Collections;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final EmptyAppModule appGlideModule;
+
+  public GeneratedAppGlideModuleImpl(Context context) {
+    appGlideModule = new EmptyAppModule();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.EmptyAppModule");
+      Log.d("Glide", "Discovered LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    new EmptyLibraryModule().registerComponents(context, glide, registry);
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    return Collections.emptySet();
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java
new file mode 100644
index 000000000..203f9df63
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..8ed710b2b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,48 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import androidx.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.EmptyAppModule;
+import java.util.Collections;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final EmptyAppModule appGlideModule;
+
+  public GeneratedAppGlideModuleImpl(Context context) {
+    appGlideModule = new EmptyAppModule();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.EmptyAppModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    return Collections.emptySet();
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
new file mode 100644
index 000000000..1cbd21422
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.test.GlideRequests;
+
+/**
+ * Generated code, do not modify
+ */
+final class GeneratedRequestManagerFactory implements RequestManagerRetriever.RequestManagerFactory {
+  @Override
+  @NonNull
+  public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    return new GlideRequests(glide, lifecycle, treeNode, context);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
new file mode 100644
index 000000000..a4daa3be3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
@@ -0,0 +1,129 @@
+package com.bumptech.glide.test;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.Context;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
+import android.view.View;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import java.io.File;
+
+/**
+ * The entry point for interacting with Glide for Applications
+ *
+ * <p>Includes all generated APIs from all
+ * {@link com.bumptech.glide.annotation.GlideExtension}s in source and dependent libraries.
+ *
+ * <p>This class is generated and should not be modified
+ * @see Glide
+ */
+public final class GlideApp {
+  private GlideApp() {
+  }
+
+  /**
+   * @see Glide#getPhotoCacheDir(Context)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(@NonNull Context context) {
+    return Glide.getPhotoCacheDir(context);
+  }
+
+  /**
+   * @see Glide#getPhotoCacheDir(Context, String)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(@NonNull Context context, @NonNull String string) {
+    return Glide.getPhotoCacheDir(context, string);
+  }
+
+  /**
+   * @see Glide#get(Context)
+   */
+  @NonNull
+  public static Glide get(@NonNull Context context) {
+    return Glide.get(context);
+  }
+
+  /**
+   * @see Glide#init(Glide)
+   */
+  @Deprecated
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void init(Glide glide) {
+    Glide.init(glide);
+  }
+
+  /**
+   * @see Glide#init(Context, GlideBuilder)
+   */
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void init(@NonNull Context context, @NonNull GlideBuilder builder) {
+    Glide.init(context, builder);
+  }
+
+  /**
+   * @see Glide#tearDown()
+   */
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void tearDown() {
+    Glide.tearDown();
+  }
+
+  /**
+   * @see Glide#with(Context)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Context context) {
+    return (GlideRequests) Glide.with(context);
+  }
+
+  /**
+   * @see Glide#with(Activity)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Activity activity) {
+    return (GlideRequests) Glide.with(activity);
+  }
+
+  /**
+   * @see Glide#with(FragmentActivity)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull FragmentActivity activity) {
+    return (GlideRequests) Glide.with(activity);
+  }
+
+  /**
+   * @see Glide#with(Fragment)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Fragment fragment) {
+    return (GlideRequests) Glide.with(fragment);
+  }
+
+  /**
+   * @see Glide#with(Fragment)
+   */
+  @Deprecated
+  @NonNull
+  public static GlideRequests with(@NonNull android.app.Fragment fragment) {
+    return (GlideRequests) Glide.with(fragment);
+  }
+
+  /**
+   * @see Glide#with(View)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull View view) {
+    return (GlideRequests) Glide.with(view);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
new file mode 100644
index 000000000..5dd7fb40d
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
@@ -0,0 +1,624 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
new file mode 100644
index 000000000..d36a6ab8f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
@@ -0,0 +1,577 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @Deprecated
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
new file mode 100644
index 000000000..c06ec6f43
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
@@ -0,0 +1,173 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  @Override
+  @NonNull
+  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {
+    return (GlideRequests) super.applyDefaultRequestOptions(options);
+  }
+
+  @Override
+  @NonNull
+  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {
+    return (GlideRequests) super.setDefaultRequestOptions(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {
+    return (GlideRequests) super.addDefaultRequestListener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<Drawable>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable drawable) {
+    return (GlideRequest<Drawable>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String string) {
+    return (GlideRequest<Drawable>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri uri) {
+    return (GlideRequest<Drawable>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File file) {
+    return (GlideRequest<Drawable>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<Drawable>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL url) {
+    return (GlideRequest<Drawable>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] bytes) {
+    return (GlideRequest<Drawable>) super.load(bytes);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object o) {
+    return (GlideRequest<Drawable>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object o) {
+    return (GlideRequest<File>) super.download(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java
new file mode 100644
index 000000000..60ad52260
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java
new file mode 100644
index 000000000..b18a61cd1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.annotation.compiler;
+
+@Index(
+    modules = "com.bumptech.glide.test.EmptyLibraryModule"
+)
+public class GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule {
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
new file mode 100644
index 000000000..945f2eadc
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(memoizeStaticMethod = true)
+  public static BaseRequestOptions<?> test(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..fb87788ee
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -0,0 +1,649 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform1;
+
+  private static GlideOptions centerInsideTransform2;
+
+  private static GlideOptions centerCropTransform3;
+
+  private static GlideOptions circleCropTransform4;
+
+  private static GlideOptions noTransformation5;
+
+  private static GlideOptions noAnimation6;
+
+  private static GlideOptions testOf0;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform1 == null) {
+      GlideOptions.fitCenterTransform1 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform2 == null) {
+      GlideOptions.centerInsideTransform2 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform2;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform3 == null) {
+      GlideOptions.centerCropTransform3 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform4 == null) {
+      GlideOptions.circleCropTransform4 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform4;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation5 == null) {
+      GlideOptions.noTransformation5 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation5;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation6 == null) {
+      GlideOptions.noAnimation6 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation6;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testOf() {
+    if (GlideOptions.testOf0 == null) {
+      GlideOptions.testOf0 =
+          new GlideOptions().test().autoClone();
+    }
+    return GlideOptions.testOf0;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..27d73e3c7
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -0,0 +1,587 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @Deprecated
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    return (GlideRequest<TranscodeType>) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
new file mode 100644
index 000000000..f524ab384
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static BaseRequestOptions<?> centerCrop(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
new file mode 100644
index 000000000..a82287e29
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -0,0 +1,638 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   * @see GlideOptions#centerCrop()
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    return (GlideOptions) Extension.centerCrop(super.centerCrop());
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
new file mode 100644
index 000000000..9380cb30c
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -0,0 +1,580 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @Deprecated
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   * @see GlideRequest<TranscodeType>#centerCrop()
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) Extension.centerCrop(super.centerCrop());
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
new file mode 100644
index 000000000..54998461a
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static BaseRequestOptions<?> override(BaseRequestOptions<?> requestOptions, int width, int height) {
+    return requestOptions
+        .override(width, height)
+        .centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
new file mode 100644
index 000000000..7d173f964
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
@@ -0,0 +1,629 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#override(BaseRequestOptions, int, int)
+   * @see GlideOptions#override(int, int)
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) Extension.override(super.override(width, height), width, height);
+  }
+
+  /**
+   * @see Extension#override(BaseRequestOptions, int, int)
+   */
+  @CheckResult
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
new file mode 100644
index 000000000..242845fdc
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
@@ -0,0 +1,580 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @Deprecated
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#override(BaseRequestOptions, int, int)
+   * @see GlideRequest<TranscodeType>#override(int, int)
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) Extension.override(super.override(width, height), width, height);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
new file mode 100644
index 000000000..d25140598
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)
+  public static BaseRequestOptions<?> centerCrop(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
new file mode 100644
index 000000000..87872751e
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -0,0 +1,636 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    return (GlideOptions) Extension.centerCrop(this);
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
new file mode 100644
index 000000000..09983c84d
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -0,0 +1,578 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @Deprecated
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#centerCrop(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) Extension.centerCrop(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
new file mode 100644
index 000000000..80f98f64e
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(skipStaticMethod = true)
+  public static BaseRequestOptions<?> test(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..6b39a0ee2
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -0,0 +1,635 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..27d73e3c7
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -0,0 +1,587 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @Deprecated
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    return (GlideRequest<TranscodeType>) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
new file mode 100644
index 000000000..ef4ea24cf
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(staticMethodName = "testSomething")
+  public static BaseRequestOptions<?> test(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
new file mode 100644
index 000000000..da781b5c0
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -0,0 +1,643 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testSomething() {
+    return new GlideOptions().test();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
new file mode 100644
index 000000000..27d73e3c7
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -0,0 +1,587 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @Deprecated
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see Extension#test(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    return (GlideRequest<TranscodeType>) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
new file mode 100644
index 000000000..bd8b35c0f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+
+@GlideExtension
+public final class ExtensionWithOption {
+
+  private ExtensionWithOption() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption
+  public static BaseRequestOptions<?> squareThumb(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
new file mode 100644
index 000000000..0eae3c878
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
@@ -0,0 +1,643 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithOption
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideOptions squareThumb() {
+    return (GlideOptions) ExtensionWithOption.squareThumb(this);
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(BaseRequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions squareThumbOf() {
+    return new GlideOptions().squareThumb();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
new file mode 100644
index 000000000..223012ce9
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
@@ -0,0 +1,587 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link com.bumptech.glide.request.RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see com.bumptech.glide.request.RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideRequest<TranscodeType>) super.sizeMultiplier(value);
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.useAnimationPool(flag);
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    return (GlideRequest<TranscodeType>) super.onlyRetrieveFromCache(flag);
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority priority) {
+    return (GlideRequest<TranscodeType>) super.priority(priority);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.placeholder(drawable);
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.placeholder(id);
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.fallback(drawable);
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.fallback(id);
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.error(drawable);
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int id) {
+    return (GlideRequest<TranscodeType>) super.error(id);
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme theme) {
+    return (GlideRequest<TranscodeType>) super.theme(theme);
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    return (GlideRequest<TranscodeType>) super.skipMemoryCache(skip);
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    return (GlideRequest<TranscodeType>) super.override(width, height);
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    return (GlideRequest<TranscodeType>) super.override(size);
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key key) {
+    return (GlideRequest<TranscodeType>) super.signature(key);
+  }
+
+  /**
+   * @see GlideOptions#set(Option<Y>, Y)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideRequest<TranscodeType>) super.set(option, y);
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> clazz) {
+    return (GlideRequest<TranscodeType>) super.decode(clazz);
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideRequest<TranscodeType>) super.encodeFormat(format);
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideRequest<TranscodeType>) super.encodeQuality(value);
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long value) {
+    return (GlideRequest<TranscodeType>) super.frame(value);
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat format) {
+    return (GlideRequest<TranscodeType>) super.format(format);
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    return (GlideRequest<TranscodeType>) super.disallowHardwareConfig();
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideRequest<TranscodeType>) super.downsample(strategy);
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int value) {
+    return (GlideRequest<TranscodeType>) super.timeout(value);
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterCrop();
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    return (GlideRequest<TranscodeType>) super.centerCrop();
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    return (GlideRequest<TranscodeType>) super.optionalFitCenter();
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    return (GlideRequest<TranscodeType>) super.fitCenter();
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    return (GlideRequest<TranscodeType>) super.optionalCenterInside();
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    return (GlideRequest<TranscodeType>) super.centerInside();
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    return (GlideRequest<TranscodeType>) super.optionalCircleCrop();
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    return (GlideRequest<TranscodeType>) super.circleCrop();
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @Deprecated
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transforms(transformations);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(transformation);
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.optionalTransform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<Y>, Transformation<Y>)
+   */
+  @NonNull
+  @CheckResult
+  public <Y> GlideRequest<TranscodeType> transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideRequest<TranscodeType>) super.transform(clazz, transformation);
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    return (GlideRequest<TranscodeType>) super.dontTransform();
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    return (GlideRequest<TranscodeType>) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideRequest<TranscodeType>) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> options) {
+    return (GlideRequest<TranscodeType>) super.transition(options);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.listener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {
+    return (GlideRequest<TranscodeType>) super.addListener(listener);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.error(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> builder) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builder);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... builders) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(builders);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object o) {
+    return (GlideRequest<TranscodeType>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<TranscodeType>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable drawable) {
+    return (GlideRequest<TranscodeType>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String string) {
+    return (GlideRequest<TranscodeType>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri uri) {
+    return (GlideRequest<TranscodeType>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File file) {
+    return (GlideRequest<TranscodeType>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<TranscodeType>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL url) {
+    return (GlideRequest<TranscodeType>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] bytes) {
+    return (GlideRequest<TranscodeType>) super.load(bytes);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(BaseRequestOptions)
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> squareThumb() {
+    return (GlideRequest<TranscodeType>) ExtensionWithOption.squareThumb(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
new file mode 100644
index 000000000..3aec03e10
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+
+@GlideExtension
+public final class ExtensionWithType {
+
+  private ExtensionWithType() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideType(Number.class)
+  public static RequestBuilder<Number> asNumber(RequestBuilder<Number> builder) {
+    return builder;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
new file mode 100644
index 000000000..821a835b9
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
@@ -0,0 +1,625 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestOptions;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithType
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return new GlideOptions().sizeMultiplier(value);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy strategy) {
+    return new GlideOptions().diskCacheStrategy(strategy);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority priority) {
+    return new GlideOptions().priority(priority);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable drawable) {
+    return new GlideOptions().placeholder(drawable);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int id) {
+    return new GlideOptions().placeholder(id);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable drawable) {
+    return new GlideOptions().error(drawable);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int id) {
+    return new GlideOptions().error(id);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(int size) {
+    return new GlideOptions().override(size);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key key) {
+    return new GlideOptions().signature(key);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new GlideOptions().transform(transformation);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> option, @NonNull T t) {
+    return new GlideOptions().set(option, t);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> clazz) {
+    return new GlideOptions().decode(clazz);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat format) {
+    return new GlideOptions().format(format);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long value) {
+    return new GlideOptions().frame(value);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new GlideOptions().downsample(strategy);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int value) {
+    return new GlideOptions().timeout(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int value) {
+    return new GlideOptions().encodeQuality(value);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new GlideOptions().encodeFormat(format);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float value) {
+    return (GlideOptions) super.sizeMultiplier(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    return (GlideOptions) super.diskCacheStrategy(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions priority(@NonNull Priority priority) {
+    return (GlideOptions) super.priority(priority);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@Nullable Drawable drawable) {
+    return (GlideOptions) super.placeholder(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions placeholder(@DrawableRes int id) {
+    return (GlideOptions) super.placeholder(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@Nullable Drawable drawable) {
+    return (GlideOptions) super.fallback(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fallback(@DrawableRes int id) {
+    return (GlideOptions) super.fallback(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@Nullable Drawable drawable) {
+    return (GlideOptions) super.error(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions error(@DrawableRes int id) {
+    return (GlideOptions) super.error(id);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions theme(@Nullable Resources.Theme theme) {
+    return (GlideOptions) super.theme(theme);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions signature(@NonNull Key key) {
+    return (GlideOptions) super.signature(key);
+  }
+
+  @Override
+  @CheckResult
+  public GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions set(@NonNull Option<Y> option, @NonNull Y y) {
+    return (GlideOptions) super.set(option, y);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions decode(@NonNull Class<?> clazz) {
+    return (GlideOptions) super.decode(clazz);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return (GlideOptions) super.encodeFormat(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int value) {
+    return (GlideOptions) super.encodeQuality(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions frame(@IntRange(from = 0) long value) {
+    return (GlideOptions) super.frame(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions format(@NonNull DecodeFormat format) {
+    return (GlideOptions) super.format(format);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return (GlideOptions) super.downsample(strategy);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions timeout(@IntRange(from = 0) int value) {
+    return (GlideOptions) super.timeout(value);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.transform(transformation);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transforms(transformations);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return (GlideOptions) super.optionalTransform(transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions optionalTransform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.optionalTransform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public <Y> GlideOptions transform(@NonNull Class<Y> clazz,
+      @NonNull Transformation<Y> transformation) {
+    return (GlideOptions) super.transform(clazz, transformation);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideOptions apply(@NonNull BaseRequestOptions<?> options) {
+    return (GlideOptions) super.apply(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
new file mode 100644
index 000000000..8e3a2093c
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
@@ -0,0 +1,182 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  /**
+   * @see ExtensionWithType#asNumber(RequestBuilder)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<Number> asNumber() {
+    return (GlideRequest<Number>) ExtensionWithType.asNumber(this.as(Number.class));
+  }
+
+  @Override
+  @NonNull
+  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {
+    return (GlideRequests) super.applyDefaultRequestOptions(options);
+  }
+
+  @Override
+  @NonNull
+  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {
+    return (GlideRequests) super.setDefaultRequestOptions(options);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {
+    return (GlideRequests) super.addDefaultRequestListener(listener);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap bitmap) {
+    return (GlideRequest<Drawable>) super.load(bitmap);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable drawable) {
+    return (GlideRequest<Drawable>) super.load(drawable);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String string) {
+    return (GlideRequest<Drawable>) super.load(string);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri uri) {
+    return (GlideRequest<Drawable>) super.load(uri);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File file) {
+    return (GlideRequest<Drawable>) super.load(file);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@RawRes @DrawableRes @Nullable Integer id) {
+    return (GlideRequest<Drawable>) super.load(id);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL url) {
+    return (GlideRequest<Drawable>) super.load(url);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] bytes) {
+    return (GlideRequest<Drawable>) super.load(bytes);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object o) {
+    return (GlideRequest<Drawable>) super.load(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object o) {
+    return (GlideRequest<File>) super.download(o);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java
new file mode 100644
index 000000000..a05259d66
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule1 extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java
new file mode 100644
index 000000000..fb46c0c13
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule2 extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java
new file mode 100644
index 000000000..236008a91
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule1 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java
new file mode 100644
index 000000000..8a43eb292
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule2 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java
new file mode 100644
index 000000000..d4284aa69
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.annotation.compiler;
+
+@Index(
+    modules = {
+        "com.bumptech.glide.test.EmptyLibraryModule1",
+        "com.bumptech.glide.test.EmptyLibraryModule2"
+    }
+)
+public class GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2 {
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
index 0a15f5a0d..ec5b5cdef 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
@@ -6,8 +6,8 @@
 import java.lang.annotation.Target;
 
 /**
- * Specifies a set of GlideModule and/or LibraryGlideModule classes that should be excluded
- * from an application.
+ * Specifies a set of GlideModule and/or LibraryGlideModule classes that should be excluded from an
+ * application.
  *
  * <p>Used only on AppGlideModules. Adding this annotation to other classes will have no affect.
  *
@@ -16,5 +16,5 @@
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Excludes {
-  Class[] value();
+  Class<?>[] value();
 }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
index bb525c849..2792e5507 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
@@ -11,5 +11,5 @@
  * @see GlideOption
  */
 @Target(ElementType.TYPE)
-@Retention(RetentionPolicy.SOURCE)
-public @interface GlideExtension { }
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideExtension {}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
index dc91418e2..b6fdb2942 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -12,11 +12,11 @@
  * <p>Replaces <meta-data /> tags in AndroidManifest.xml.
  */
 @Target(ElementType.TYPE)
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS)
 public @interface GlideModule {
   /**
-   * Returns the name of the class that will be used as a replacement for
-   * {@code com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
+   * Returns the name of the class that will be used as a replacement for {@code
+   * com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
    */
   String glideName() default "GlideApp";
 }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
index 70d7b4cbb..c2f3c3229 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -6,23 +6,67 @@
 import java.lang.annotation.Target;
 
 /**
- * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@code com.bumptech.glide.request.RequestOptions}.
+ * Identifies methods in {@link GlideExtension} annotated classes that extend {@code
+ * com.bumptech.glide.request.RequestOptions}.
  *
- * <p>All annotated methods will be added to a single
- * {@code com.bumptech.glide.request.RequestOptions} implementation generated per application.
- * Overlapping method names in different extensions may cause errors at compile time.
+ * <p>All annotated methods will be added to a single {@code
+ * com.bumptech.glide.request.RequestOptions} implementation generated per application. Overlapping
+ * method names in different extensions may cause errors at compile time.
  *
  * <p>Static equivalents of annotated methods will also be generated.
  *
  * <p>Methods with this annotation will only be found if they belong to classes annotated with
  * {@link GlideExtension}.
+ *
+ * <p>The preferred way of writing extension methods returns the provided {@code
+ * com.bumptech.glide.request.RequestOptions} object with one or more methods called on it. You must
+ * not return a newly instantiated {@code com.bumptech.glide.request.RequestOptions} object as doing
+ * so my cause a {@code ClassCastException} at runtime. Calling either {@code
+ * com.bumptech.glide.request.RequestOptions#autoClone()} or {@code
+ * com.bumptech.glide.request.RequestOptions#lock()} is safe, but unnecessary and should typically
+ * be avoided. The preferred style looks like:
+ *
+ * <pre>{@code
+ * {@link @}GlideExtension
+ * public class MyExtension {
+ *   private MyExtension() {}
+ *
+ *   {@literal @}GlideOption
+ *   public static RequestOptions myOption(RequestOptions options) {
+ *     return options
+ *         .optionOne()
+ *         .optionTwo();
+ *   }
+ * }
+ * }</pre>
+ *
+ * <p>The deprecated way of writing extension methods is simply a static void method. The {@code
+ * com.bumptech.glide.request.RequestOptions} object is cloned before it is passed to this method to
+ * avoid an option method returning a new instance, but using methods like {@code
+ * com.bumptech.glide.request.RequestOptions#clone()} or {@code
+ * com.bumptech.glide.request.RequestOptions#autoClone()} can result in options applied in the
+ * method being silently ignored. Prefer the new style whenever possible.
+ *
+ * <pre>{@code
+ * {@literal @}GlideExtension
+ * public class MyExtension {
+ *   private MyExtension() {}
+ *
+ *   // Deprecated! Use the new style of GlideOption extensions instead.
+ *   {@literal @}GlideOption
+ *   public static void myOption(RequestOptions options) {
+ *     options
+ *         .optionOne()
+ *         .optionTwo();
+ *   }
+ * }
+ * }</pre>
  */
 @Target(ElementType.METHOD)
 // Needs to be parsed from class files in JAR.
 @Retention(RetentionPolicy.CLASS)
 public @interface GlideOption {
-   /** Does not intend to override a method in a super class. */
+  /** Does not intend to override a method in a super class. */
   int OVERRIDE_NONE = 0;
   /** Expects to call super and then add additional functionality to an overridden method. */
   int OVERRIDE_EXTEND = 1;
@@ -63,11 +107,12 @@
   /**
    * {@code true} to prevent a static builder method from being generated.
    *
-   * <p>By default static methods are generated for all methods annotated with
-   * {@link GlideOption}. These static factory methods allow for a cleaner API when used
-   * with {@code com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
-   * simply creates a new {@code com.bumptech.glide.request.RequestOptions} object, calls the
-   * instance version of the method on it and returns it. For example:
+   * <p>By default static methods are generated for all methods annotated with {@link GlideOption}.
+   * These static factory methods allow for a cleaner API when used with {@code
+   * com.bumptech.glide.RequestBuilder#apply}. The static factory method by default simply creates a
+   * new {@code com.bumptech.glide.request.RequestOptions} object, calls the instance version of the
+   * method on it and returns it. For example:
+   *
    * <pre>
    * <code>
    * public static GlideOptions noAnimation() {
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
index 4b51ed1c6..9cf17c836 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -6,8 +6,8 @@
 import java.lang.annotation.Target;
 
 /**
- * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@code com.bumptech.glide.RequestManager}.
+ * Identifies methods in {@link GlideExtension} annotated classes that extend {@code
+ * com.bumptech.glide.RequestManager}.
  *
  * <p>If one or more method is found with this annotation, an additional API entry point that
  * exposes a generated {@code com.bumptech.glide.RequestManager} subclass will be created. The
@@ -21,9 +21,12 @@
  * <p>Methods with this annotation will only be found if they are contained in a class annotated
  * with {@link GlideExtension}.
  *
- * <p>Methods annotated with GlideType must have a single parameter. The type of the
- * single parameter must be {@code com.bumptech.glide.request.RequestOptions}, with a type
- * matching the value of {@link #value()}.
+ * <p>Methods annotated with GlideType must have a single parameter. The type of the single
+ * parameter must be {@code com.bumptech.glide.RequestBuilder}, with a type matching the value of
+ * {@link #value()}.
+ *
+ * <p>Compilation will fail if a method annotated with this method is identical to a method in
+ * {@code com.bumptech.glide.RequestManager}
  */
 @Target(ElementType.METHOD)
 // Needs to be parsed from class files in JAR.
@@ -33,7 +36,8 @@
   /**
    * A Resource class name, like GifDrawable.class, Bitmap.class etc.
    *
-   * <p>Must match the type of the {@code com.bumptech.glide.request.RequestOptions} parameter.
+   * <p>Must match the type of the {@code com.bumptech.glide.RequestBuilder} parameter in the
+   * annotated method.
    */
   Class<?> value();
 }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
index 81ba54ae1..f9c9d541f 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
@@ -16,5 +16,6 @@
 @Retention(RetentionPolicy.CLASS)
 @interface Index {
   String[] modules() default {};
+
   String[] extensions() default {};
 }
diff --git a/build.gradle b/build.gradle
index a0f6158a8..586fdb9d2 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,14 +1,25 @@
+import org.gradle.api.tasks.testing.logging.TestExceptionFormat
+import se.bjurr.violations.gradle.plugin.ViolationsTask
+
 buildscript {
     repositories {
+        google()
         jcenter()
         maven {
             url "https://oss.sonatype.org/content/repositories/snapshots"
         }
+        maven {
+            url "https://plugins.gradle.org/m2/"
+        }
     }
 
     dependencies {
         classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
-        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
+        if (!hasProperty('DISABLE_ERROR_PRONE')) {
+            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}"
+        }
+        classpath "se.bjurr.violations:violations-gradle-plugin:${VIOLATIONS_PLUGIN_VERSION}"
+        classpath "com.diffplug.spotless:spotless-plugin-gradle:3.23.0"
     }
 }
 
@@ -21,33 +32,88 @@ if (JavaVersion.current().isJava8Compatible()) {
     }
 }
 
-subprojects {
+subprojects { project ->
+
+    repositories {
+        google()
+        jcenter()
+        maven {
+            url "https://oss.sonatype.org/content/repositories/snapshots"
+        }
+    }
+
     tasks.withType(JavaCompile) {
         sourceCompatibility = 1.7
         targetCompatibility = 1.7
+
+        options.setBootstrapClasspath(files("${System.getProperty('java.home')}/lib/rt.jar"))
+        // gifencoder is a legacy project that has a ton of warnings and is basically never
+        // modified, so we're not going to worry about cleaning it up.
+        // Imgur uses generated code from dagger that has warnings.
+        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {
+          options.compilerArgs \
+                /*
+                 * Treat all warnings as errors.
+                 */ \
+                << "-Werror" \
+                /*
+                 * Enable all warnings.
+                 */ \
+                << "-Xlint:all" \
+                /*
+                 * Java expects every annotation to have a processor, but we use
+                 * javax.annotation.Nullable, which doesn't have one.
+                 */ \
+                << "-Xlint:-processing" \
+                /*
+                 * See https://github.com/google/dagger/issues/945
+                 * and https://bugs.openjdk.java.net/browse/JDK-8190452
+                 */ \
+                << "-Xlint:-classfile" \
+                /*
+                 * Disable deprecation warnings for ViewTarget/BaseTarget for now.
+                 */ \
+                << "-Xlint:-deprecation"
+
+            if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
+                // It's often useful to track individual objects when debugging object pooling.
+                options.compilerArgs << "-Xep:ObjectToString:OFF"
+            }
+        }
+    }
+
+    tasks.withType(Test) {
+        testLogging {
+            exceptionFormat = TestExceptionFormat.FULL
+        }
     }
 
     // Avoid issues like #2452.
     tasks.withType(Jar) {
         duplicatesStrategy = DuplicatesStrategy.FAIL
     }
-}
 
-subprojects { project ->
-    repositories {
-        jcenter()
-        maven {
-            url "https://oss.sonatype.org/content/repositories/snapshots"
-        }
-        maven {
-            url "https://maven.google.com"
+    def isDisallowedProject =
+            project.name in ["third_party", "gif_decoder", "gif_encoder", "disklrucache"]
+    if (!isDisallowedProject) {
+        apply plugin: "com.diffplug.gradle.spotless"
+
+        spotless {
+            java {
+                target fileTree('.') {
+                    include '**/*.java'
+                    exclude '**/resources/**'
+                    exclude '**/build/**'
+                }
+                googleJavaFormat()
+            }
         }
     }
 
     apply plugin: 'checkstyle'
 
     checkstyle {
-        toolVersion = '6.12.1'
+        toolVersion = '8.5'
     }
 
     checkstyle {
@@ -59,26 +125,60 @@ subprojects { project ->
         source 'src'
         include '**/*.java'
         exclude '**/gen/**'
+        // Caught by the violations plugin.
+        ignoreFailures = true
 
         // empty classpath
         classpath = files()
     }
 
+    apply plugin: "se.bjurr.violations.violations-gradle-plugin"
+
+    task violations(type: ViolationsTask) {
+        minSeverity 'INFO'
+        detailLevel 'VERBOSE'
+        maxViolations = 0
+        diffMaxViolations = 0
+
+        // Formats are listed here: https://github.com/tomasbjerre/violations-lib
+        def dir = projectDir.absolutePath
+        violations = [
+                ["FINDBUGS",    dir, ".*/findbugs/.*\\.xml\$",   "Findbugs"],
+                ["PMD",         dir, ".*/pmd/.*\\.xml\$",        "PMD"],
+                ["ANDROIDLINT", dir, ".*/lint-results\\.xml\$",  "AndroidLint"],
+                ["CHECKSTYLE",  dir, ".*/checkstyle/.*\\.xml\$", "Checkstyle"],
+        ]
+    }
+
     afterEvaluate {
         if (project.tasks.findByName('check')) {
             check.dependsOn('checkstyle')
+            check.finalizedBy violations
         }
-    }
 
-    gradle.projectsEvaluated {
-        tasks.withType(JavaCompile) {
-            options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
+        if (project.hasProperty("android")
+                && project.name != 'pmd'
+                && project.name != 'findbugs') {
+            android {
+                lintOptions {
+                    warningsAsErrors true
+                    quiet true
+                    // Caught by the violations plugin.
+                    abortOnError false
+                }
+            }
+
+            android.variantFilter { variant ->
+                if(variant.buildType.name == 'release') {
+                    variant.setIgnore(true)
+                }
+            }
         }
-    }
-}
 
-task wrapper(type: Wrapper) {
-    gradleVersion = '4.1'
-    distributionType = Wrapper.DistributionType.ALL
+        if (project.plugins.hasPlugin('com.android.library')) {
+            android.libraryVariants.all {
+                it.generateBuildConfigProvider.configure { enabled = false }
+            }
+        }
+    }
 }
-
diff --git a/checkstyle.xml b/checkstyle.xml
index 821938198..9a3d19a94 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -73,7 +73,7 @@
 
         <!-- Allow common trailing comments used to describe suppressions -->
         <module name="TrailingComment">
-          <property name="legalComment" value="Public API" />
+            <property name="legalComment" value="^Public API.?$|^NOPMD.*$" />
         </module>
 
         <!-- Checks for imports. -->
@@ -94,34 +94,8 @@
         <!-- Prevent importing Mockito matchers directly -->
         <module name="IllegalImport">
             <property name="illegalPkgs" value="org.mockito.internal" />
-            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />
+            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers." />
         </module>
-        <module name="ImportOrder">
-          <!-- Checks for out of order import statements. -->
-
-          <property name="sortStaticImportsAlphabetically" value="true"/>
-           <property name="severity" value="error"/>
-           <property name="groups" value="*"/>
-           <!-- This ensures that static imports go first. -->
-           <property name="option" value="top"/>
-           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
-         </module>
-
-        <!-- Checks for whitespace. -->
-        <!-- See http://checkstyle.sourceforge.net/config_whitespace.html -->
-        <module name="GenericWhitespace" />
-        <module name="MethodParamPad" />
-        <module name="NoWhitespaceAfter">
-            <property name="tokens"
-                      value="BNOT, DEC, DOT, INC, LNOT, UNARY_MINUS, UNARY_PLUS" />
-        </module>
-        <module name="NoWhitespaceBefore" />
-        <module name="OperatorWrap" />
-        <module name="ParenPad" />
-        <module name="TypecastParenPad" />
-        <module name="WhitespaceAfter" />
-        <module name="WhitespaceAround" />
-
 
         <!-- Modifier Checks. -->
         <!-- See http://checkstyle.sourceforge.net/config_modifier.html -->
@@ -130,7 +104,7 @@
         <!-- Checks for blocks. -->
         <!-- See http://checkstyle.sourceforge.net/config_blocks.html -->
         <module name="AvoidNestedBlocks">
-          <property name="allowInSwitchCase" value="true" />
+            <property name="allowInSwitchCase" value="true" />
         </module>
         <module name="EmptyBlock" >
             <property name="option" value="text"/>
@@ -140,7 +114,7 @@
         <module name="LeftCurly" />
         <module name="RightCurly">
             <property name="tokens"
-                      value="LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_ELSE" />
+              value="LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_ELSE" />
         </module>
 
         <!-- Checks for common coding problems. -->
@@ -157,13 +131,10 @@
         <module name="SimplifyBooleanReturn" />
         <module name="StringLiteralEquality" />
         <module name="UnnecessaryParentheses" />
-        <module name="LineLength">
-            <property name="max" value="100" />
-        </module>
 
         <!-- Checks for class design. -->
         <!-- See http://checkstyle.sourceforge.net/config_design.html -->
         <module name="FinalClass" />
         <module name="InterfaceIsType" />
     </module>
-</module>
+</module>
\ No newline at end of file
diff --git a/checkstyle_suppressions.xml b/checkstyle_suppressions.xml
index 0293de43a..1bfebbe01 100644
--- a/checkstyle_suppressions.xml
+++ b/checkstyle_suppressions.xml
@@ -5,7 +5,10 @@
     "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">
 
 <suppressions>
-    <suppress files=".*[/\\]library[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]library[/\\]src[/\\]main[/\\]java[/\\]com[/\\]bumptech[/\\]glide[/\\]util[/\\]CachedHashCodeArrayMap.java" checks="EqualsHashCodeCheck"/>
+    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]annotation[/\\]compiler[/\\]test[/\\]src[/\\]test[/\\]resources[/\\].*" checks=".*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\].*" checks="Javadoc.*"/>
     <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>
     <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>
     <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>
diff --git a/debug.keystore b/debug.keystore
new file mode 100644
index 000000000..425f3d6a1
Binary files /dev/null and b/debug.keystore differ
diff --git a/glide/build.gradle b/glide/build.gradle
index a5f480f66..004bd95be 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -4,12 +4,7 @@ apply plugin: 'java'
 
 // The paths of Android projects that should be included in the jar and javadoc.
 static def getAndroidPathsForJar() {
-    [':third_party:gif_decoder', ':library']
-}
-
-// The paths of Java projects that should be included in the jar and javadoc.
-static def getJavaPathsForJar() {
-    [':third_party:disklrucache']
+    [':third_party:gif_decoder', ':library', ':third_party:disklrucache' ]
 }
 
 // The paths of Android projects that should be included only in Javadoc, not in the jar.
@@ -19,17 +14,16 @@ static def getAndroidPathsForJavadoc() {
             ':integration:okhttp3',
             ':integration:volley',
             ':integration:gifencoder',
-            ':integration:recyclerview'
+            ':integration:recyclerview',
     ]
 }
 
 // The paths of Java projects that should be included only in Javadoc, not in the jar.
 static def getJavaPathsForJavadoc() {
-    [':annotation', ':annotation:compiler']
+    [':annotation']
 }
 
-(getAndroidPathsForJavadoc() + getAndroidPathsForJar() +
-        getJavaPathsForJar() + getJavaPathsForJavadoc()).each {
+(getAndroidPathsForJavadoc() + getAndroidPathsForJar() + getJavaPathsForJavadoc()).each {
     evaluationDependsOn(it)
 }
 
@@ -49,20 +43,12 @@ def getInternalAndroidProjectsForJar() {
     asProjects(getAndroidPathsForJar())
 }
 
-def getInternalJavaProjectsForJar() {
-    asProjects(getJavaPathsForJar())
-}
-
 def getInternalAndroidProjectsForJavadoc() {
     asProjects(getAndroidPathsForJavadoc())
 }
 
-def getInternalJavaProjectsForJavadoc() {
-    asProjects(getJavaPathsForJavadoc())
-}
-
-def getReleaseVariantAndroidProjectsForJar() {
-    getAndroidLibraryVariantsForJar('release')
+def getAndroidProjectsForJar() {
+    getAndroidLibraryVariantsForJar('debug')
 }
 
 def getAndroidLibraryVariantsForJar(variantName) {
@@ -82,13 +68,17 @@ static def getAndroidLibraryVariants(projects, variantName) {
 }
 
 def getSourceFilesForVariantJar(variantName) {
-    getAndroidLibraryVariantsForJar(variantName).collect { it.javaCompile.source } +
-            getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
+    getAndroidLibraryVariantsForJar(variantName).collect { variant -> 
+        variant.getJavaCompileProvider().get().source.findAll { 
+            return !it.getName().equals("R.java")
+        }
+    }
 }
 
 def getSourceFilesForVariantJavadoc(variantName) {
-    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.javaCompile.source } +
-            getInternalJavaProjectsForJavadoc().collect { it.sourceSets.main.allJava }
+    getAndroidLibraryVariantsForJavadoc(variantName).collect { 
+        it.getJavaCompileProvider().get().source 
+    }
 }
 
 def getAndroidJar() {
@@ -99,48 +89,40 @@ project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
 
 // Generate javadocs and sources containing batched documentation and sources for all internal
 // projects.
-['release', 'debug'].each { variantName ->
-
-    task("${variantName}SourceJar", type: Jar) {
-        from getSourceFilesForVariantJar(variantName)
-    }
+['debug'].each { variantName ->
 
     def javadocTask = tasks.create("${variantName}Javadoc", Javadoc) {
         source = getSourceFilesForVariantJar(variantName)
         source += getSourceFilesForVariantJavadoc(variantName)
-
-        classpath = project.files(
-                getAndroidJar(),
-                getAndroidLibraryVariantsForJar(variantName).collect { LibraryVariant lib ->
-                    lib.javaCompile.classpath.files
-                },
-                getAndroidLibraryVariantsForJavadoc(variantName).collect { LibraryVariant lib ->
-                    lib.javaCompile.classpath.files
-                },
-                getInternalJavaProjectsForJavadoc().collect { Project project ->
-                    project.sourceSets.main.compileClasspath.files
-                },
-                getInternalJavaProjectsForJar().collect { Project project ->
-                    project.sourceSets.main.compileClasspath.files
-                },
-                // Finds dependencies of Android packages that would otherwise be ignored (Volley in
-                // particular)
-                getInternalAndroidProjectsForJavadoc().collect { Project project ->
-                    project.file('build/intermediates/classes/release')
-                }
-        )
+      
+        doFirst {
+            it.classpath =
+                    project.files(
+                            getAndroidJar(),
+                            getAndroidLibraryVariantsForJar(variantName).collect {
+                                LibraryVariant lib ->
+                                    lib.getJavaCompileProvider().get().classpath.files
+                            },
+                            getAndroidLibraryVariantsForJavadoc(variantName).collect {
+                                LibraryVariant lib ->
+                                    lib.getJavaCompileProvider().get().classpath.files
+                            },
+                            // Finds dependencies of Android packages that would otherwise be
+                            // ignored (Volley in particular)
+                            getInternalAndroidProjectsForJavadoc().collect { Project project ->
+                                project.file('build/intermediates/classes/debug')
+                            }
+            )
+        }
 
         options {
             links("http://docs.oracle.com/javase/7/docs/api/")
             links("https://square.github.io/okhttp/3.x/okhttp/")
             links("https://square.github.io/okhttp/2.x/okhttp/")
-            // TODO: Ideally this would point to something hosted by Android.
-            links("http://afzaln.com/volley/")
             linksOffline("http://d.android.com/reference",
                     "${getAndroidSdkDirectory()}/docs/reference")
         }
 
-        exclude '**/BuildConfig.java'
         exclude '**/R.java'
     }
 
@@ -157,31 +139,24 @@ project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
 
 jar {
     from files(
-            getReleaseVariantAndroidProjectsForJar().collect { LibraryVariant variant ->
-                variant.javaCompile.destinationDir
+            getAndroidProjectsForJar().collect { LibraryVariant variant ->
+                variant.getJavaCompileProvider().get().destinationDir
             }
     )
     exclude "**/R.class"
-    exclude "**/BuildConfig.class"
-    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
+    exclude "**/R\$*.class"
+    exclude "android/**"
 }
 
-def getAllInternalProjectBuildDeps() {
-    getInternalAndroidProjectsForJar() + getInternalJavaProjectsForJar() +
-            getInternalJavaProjectsForJavadoc() + getInternalAndroidProjectsForJavadoc()
-}
-
-getAllInternalProjectBuildDeps().each { project ->
-    releaseJavadoc.dependsOn(project.tasks.assemble)
-    debugJavadoc.dependsOn(project.tasks.assemble)
-    jar.dependsOn(project.tasks.build)
+(getInternalAndroidProjectsForJar() + getInternalAndroidProjectsForJavadoc()).each {
+    project ->
+        debugJavadoc.dependsOn(project.tasks.compileDebugSources)
+        jar.dependsOn(project.tasks.compileDebugSources)
 }
 
 artifacts {
-    archives releaseJavadocJar {
+    archives debugJavadocJar {
         classifier 'javadoc'
     }
-    archives releaseSourceJar {
-        classifier 'sources'
-    }
 }
+
diff --git a/gradle.properties b/gradle.properties
index 97bb544a9..c8c1dc88d 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,9 +1,9 @@
 org.gradle.daemon=true
-org.gradle.configureondemand=true
+org.gradle.configureondemand=false
 
-VERSION_NAME=4.3.0-SNAPSHOT
+VERSION_NAME=4.10.0-SNAPSHOT
 VERSION_MAJOR=4
-VERSION_MINOR=3
+VERSION_MINOR=10
 VERSION_PATCH=0
 GROUP=com.github.bumptech.glide
 
@@ -15,29 +15,35 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
-ANDROID_SUPPORT_VERSION=26.0.2
-VOLLEY_VERSION=1.0.0
-OK_HTTP_VERSION=3.9.0
-ANDROID_GRADLE_VERSION=2.3.3
-DAGGER_VERSION=2.11
+ANDROID_SUPPORT_VERSION=27.1.1
+ANDROID_X_VERSION=1.0.0
+ANDROIDX_TEST_VERSION=1.1.0
+VOLLEY_VERSION=1.1.0
+OK_HTTP_VERSION=3.9.1
+ANDROID_GRADLE_VERSION=3.3.0
+DAGGER_VERSION=2.15
 
-COVERALLS_GRADLE_VERSION=2.4.0
-JUNIT_VERSION=4.12
+JUNIT_VERSION=4.13-SNAPSHOT
 # Matches the version in Google.
-MOCKITO_VERSION=1.9.5
-MOCKITO_ANDROID_VERSION=2.11.0
-ROBOLECTRIC_VERSION=3.3.2
+MOCKITO_VERSION=2.23.4
+MOCKITO_ANDROID_VERSION=2.24.0
+ROBOLECTRIC_VERSION=4.3-beta-1
 MOCKWEBSERVER_VERSION=3.0.0-RC1
-TRUTH_VERSION=0.26
+TRUTH_VERSION=0.45
+JSR_305_VERSION=3.0.2
+AUTO_SERVICE_VERSION=1.0-rc3
+JAVAPOET_VERSION=1.9.0
+GUAVA_VERSION=27.0.1-android
 
-PMD_VERSION=5.4.0
+PMD_VERSION=6.0.0
 FINDBUGS_VERSION=3.0.0
-JACOCO_VERSION=0.7.1.201405082137
+ERROR_PRONE_VERSION=2.3.1
+ERROR_PRONE_PLUGIN_VERSION=0.0.13
+VIOLATIONS_PLUGIN_VERSION=1.8
 
-COMPILE_SDK_VERSION=26
-BUILD_TOOLS_VERSION=26.0.1
-TARGET_SDK_VERSION=26
+COMPILE_SDK_VERSION=28
+TARGET_SDK_VERSION=27
 MIN_SDK_VERSION=14
 
-org.gradle.jvmargs=-Xmx2048M
-TEST_JVM_MEMORY_SIZE=2048M
+org.gradle.jvmargs=-Xmx4096M
+TEST_JVM_MEMORY_SIZE=4096M
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index ed88a042a..f6b961fd5 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index c583957d2..910703705 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,6 @@
+#Mon Mar 04 18:37:29 PST 2019
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip
diff --git a/gradlew.bat b/gradlew.bat
index e95643d6a..f9553162f 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -1,84 +1,84 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windows variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/instrumentation/build.gradle b/instrumentation/build.gradle
index 6f2fc3073..1fa7b9394 100644
--- a/instrumentation/build.gradle
+++ b/instrumentation/build.gradle
@@ -1,22 +1,30 @@
+tasks.whenTaskAdded { task ->
+    if (task.name == "lint") {
+        task.enabled = false
+    }
+}
 apply plugin: 'com.android.application'
 
 dependencies {
-    // Appcompat is required to ensure that Glide's runtime detection the v7 support Drawable
-    // loading classes functions. It's not clear why androidTestCompile isn't sufficient, but for
-    // whatever reason, compile is the only dependency that seems to work.
-    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
-    androidTestCompile project(':library')
-    androidTestCompile "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}"
-    androidTestCompile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
-    androidTestCompile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
-    androidTestCompile 'com.android.support.test:runner:0.5'
-    androidTestCompile 'com.android.support.test:rules:0.5'
-    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
+    annotationProcessor project(":annotation:compiler")
+    implementation project(":library")
+
+    androidTestImplementation project(':library')
+    androidTestImplementation "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}"
+    androidTestImplementation "androidx.test.ext:junit:${ANDROIDX_TEST_VERSION}"
+    androidTestImplementation "androidx.test:rules:${ANDROIDX_TEST_VERSION}"
+    androidTestImplementation "androidx.test:core:${ANDROIDX_TEST_VERSION}"
+    androidTestImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    androidTestImplementation "junit:junit:${JUNIT_VERSION}"
+    androidTestImplementation "androidx.exifinterface:exifinterface:${ANDROID_X_VERSION}"
+
+    // Not totally clear why this is required, but it seems to be missing when tests are run on
+    // 4.1.2 and 4.2.0 emulators.
+    androidTestImplementation 'com.google.code.findbugs:jsr305:3.0.2'
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.instrumentation'
@@ -24,7 +32,7 @@ android {
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
         versionName '1.0'
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
 
     compileOptions {
diff --git a/instrumentation/gradle.properties b/instrumentation/gradle.properties
new file mode 100644
index 000000000..e69de29bb
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
new file mode 100644
index 000000000..e696d9988
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
@@ -0,0 +1,202 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class AsBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
+  }
+
+  @Test
+  public void loadImageResourceId_asBytes_providesBytesOfBitmap() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context).as(byte[].class).load(ResourceIds.raw.canonical).submit());
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmap_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data = concurrency.get(Glide.with(context).as(byte[].class).load(bitmap).submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmapDrawable_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(new BitmapDrawable(context.getResources(), bitmap))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(Glide.with(context).as(byte[].class).load(ResourceIds.raw.video).submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_withFrameTime_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(Glide.with(context).as(byte[].class).load(writeVideoToFile()).submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context).as(byte[].class).load(Uri.fromFile(writeVideoToFile())).submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  private File writeVideoToFile() throws IOException {
+    byte[] videoData = loadVideoBytes();
+    File parent = context.getCacheDir();
+    if (!parent.mkdirs() && (!parent.exists() || !parent.isDirectory())) {
+      throw new IllegalStateException("Failed to mkdirs for: " + parent);
+    }
+    File toWrite = new File(parent, "temp.jpeg");
+    if (toWrite.exists() && !toWrite.delete()) {
+      throw new IllegalStateException("Failed to delete existing temp file: " + toWrite);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(toWrite));
+      os.write(videoData);
+      os.close();
+    } finally {
+      if (os != null) {
+        os.close();
+      }
+    }
+    return toWrite;
+  }
+
+  private byte[] loadVideoBytes() throws IOException {
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(ResourceIds.raw.video);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
new file mode 100644
index 000000000..6b8b7202b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
@@ -0,0 +1,121 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.content.Context;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.MockModelLoader;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class AsFileTest {
+  private static final String URL = "https://imgs.xkcd.com/comics/mc_hammer_age.png";
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = ApplicationProvider.getApplicationContext();
+
+  @Before
+  public void setUp() {
+    MockModelLoader.mock(URL, getData());
+  }
+
+  @Test
+  public void asFile_withUrl_succeeds() {
+    File file = concurrency.get(GlideApp.with(context).asFile().load(URL).submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyAutomatic_succeeds() {
+    File file =
+        concurrency.get(
+            GlideApp.with(context)
+                .asFile()
+                .diskCacheStrategy(DiskCacheStrategy.AUTOMATIC)
+                .load(URL)
+                .submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyData_succeeds() {
+    File file =
+        concurrency.get(
+            GlideApp.with(context)
+                .asFile()
+                .diskCacheStrategy(DiskCacheStrategy.DATA)
+                .load(URL)
+                .submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyResource_fails() {
+    try {
+      concurrency.get(
+          GlideApp.with(context)
+              .asFile()
+              .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+              .load(URL)
+              .submit());
+      fail();
+    } catch (RuntimeException e) {
+      // expected.
+    }
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyAll_fails() {
+    try {
+      concurrency.get(
+          GlideApp.with(context)
+              .asFile()
+              .diskCacheStrategy(DiskCacheStrategy.ALL)
+              .load(URL)
+              .submit());
+      fail();
+    } catch (RuntimeException e) {
+      // Expected.
+    }
+  }
+
+  private InputStream getData() {
+    InputStream is = null;
+    try {
+      is = context.getResources().openRawResource(ResourceIds.raw.canonical);
+      byte[] buffer = new byte[1024 * 1024];
+      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+      int read;
+      while ((read = is.read(buffer)) != -1) {
+        outputStream.write(buffer, 0, read);
+      }
+      byte[] data = outputStream.toByteArray();
+      return new ByteArrayInputStream(data);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
new file mode 100644
index 000000000..cf22ce353
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -0,0 +1,490 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+import static org.mockito.AdditionalMatchers.not;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.ImageView;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests various aspects of memory and disk caching to verify resources can be retrieved as we
+ * expect.
+ */
+@RunWith(AndroidJUnit4.class)
+public class CachingTest {
+  private static final int IMAGE_SIZE_PIXELS = 500;
+  // Store at least 10 500x500 pixel Bitmaps with the ARGB_8888 config to be safe.
+  private static final long CACHE_SIZE_BYTES = IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
+
+    Glide.init(context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));
+  }
+
+  @Test
+  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {
+    Glide.init(context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    FutureTarget<Drawable> first = GlideApp.with(context).load(raw.canonical).submit();
+    concurrency.get(first);
+
+    concurrency.get(
+        GlideApp.with(context).load(ResourceIds.raw.canonical).listener(requestListener).submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {
+    Glide.init(context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    // Allow the request to be run and GCed without being cleared.
+    concurrency.loadOnOtherThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            FutureTarget<Drawable> first = GlideApp.with(context).load(raw.canonical).submit();
+            concurrency.get(first);
+          }
+        });
+
+    // Wait for the weak reference to be cleared and the request to be removed from active
+    // resources.
+    // De-flake by allowing multiple tries
+    boolean isWeakRefCleared = false;
+    for (int j = 0; j < 100; j++) {
+      Runtime.getRuntime().gc();
+      concurrency.pokeMainThread();
+      try {
+        // Loading again here won't shuffle our resource around because it only changes our
+        // reference count from 1 to 2 and back. The reference we're waiting for will only be
+        // decremented when the target is GCed.
+        Target<Drawable> target =
+            concurrency.wait(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .onlyRetrieveFromCache(true)
+                    .diskCacheStrategy(DiskCacheStrategy.NONE)
+                    .submit());
+        GlideApp.with(context).clear(target);
+      } catch (RuntimeException e) {
+        // The item has been cleared from active resources.
+        isWeakRefCleared = true;
+        break;
+      }
+    }
+
+    if (!isWeakRefCleared) {
+      fail("Failed to clear weak ref.");
+    }
+
+    concurrency.get(
+        GlideApp.with(context).load(ResourceIds.raw.canonical).listener(requestListener).submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache() {
+    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob
+    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race
+    // by making our clear and EngineJob's clear run on the same thread.
+    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setSourceExecutor(mainThreadExecutor)
+            .setDiskCacheExecutor(mainThreadExecutor)
+            .setAnimationExecutor(mainThreadExecutor));
+
+    FutureTarget<Drawable> future =
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache() {
+    // We can't allow any mocks (RequestListner, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap() {
+    // We can't allow any mocks (RequestListener, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.canonical)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
+
+    FutureTarget<Bitmap> future =
+        GlideApp.with(context)
+            .asBitmap()
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    Glide.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    BitmapSubject.assertThat(bitmap).isNotRecycled();
+  }
+
+  @Test
+  public void clearDiskCache_doesNotPreventFutureLoads() {
+    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob
+    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race
+    // by making our clear and EngineJob's clear run on the same thread.
+    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setSourceExecutor(mainThreadExecutor)
+            .setDiskCacheExecutor(mainThreadExecutor)
+            .setAnimationExecutor(mainThreadExecutor));
+
+    // Load the request once.
+    FutureTarget<Drawable> future =
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    // Clear the result from all of our caches.
+    GlideApp.with(context).clear(future);
+    clearMemoryCacheOnMainThread();
+    GlideApp.get(context).clearDiskCache();
+
+    // Load the request a second time into the disk cache.
+    future =
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    // Clear the second request from everywhere but the disk cache.
+    GlideApp.with(context).clear(future);
+    clearMemoryCacheOnMainThread();
+
+    // Load the request a third time.
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Assert that the third request comes from the disk cache (which was populated by the second
+    // request).
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  // Tests #2428.
+  @Test
+  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {
+    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    FutureTarget<Drawable> loadFromSourceFuture = GlideApp.with(context).load(waitModel).submit();
+
+    FutureTarget<Drawable> onlyFromCacheFuture =
+        GlideApp.with(context).load(waitModel).onlyRetrieveFromCache(true).submit();
+    try {
+      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);
+      fail("Expected only from cache Future to time out");
+    } catch (InterruptedException | TimeoutException e) {
+      throw new RuntimeException(e);
+    } catch (ExecutionException e) {
+      // Expected.
+    }
+    waitModel.countDown();
+
+    assertThat(concurrency.get(loadFromSourceFuture)).isNotNull();
+  }
+
+  // Tests #2428.
+  @Test
+  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {
+    // Block the main thread so that we know that both requests will be queued but not started at
+    // the same time.
+    final CountDownLatch blockMainThread = new CountDownLatch(1);
+    new Handler(Looper.getMainLooper())
+        .post(
+            new Runnable() {
+              @Override
+              public void run() {
+                try {
+                  blockMainThread.await();
+                } catch (InterruptedException e) {
+                  throw new RuntimeException(e);
+                }
+              }
+            });
+
+    // Queue the retrieve from cache request first.
+    final Future<Drawable> firstQueuedFuture =
+        GlideApp.with(context).load(ResourceIds.raw.canonical).onlyRetrieveFromCache(true).submit();
+
+    // Then queue the normal request.
+    FutureTarget<Drawable> expectedFuture =
+        GlideApp.with(context).load(ResourceIds.raw.canonical).submit();
+
+    // Run the requests.
+    blockMainThread.countDown();
+
+    // Verify that the request that didn't have retrieve from cache succeeds
+    assertThat(concurrency.get(expectedFuture)).isNotNull();
+    // The first request only from cache should fail because the item is not in cache.
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            concurrency.get(firstQueuedFuture);
+          }
+        });
+  }
+
+  @Test
+  public void loadIntoView_withoutSkipMemoryCache_loadsFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform(),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we
+    // do end up re-using the old Target, our wait will always timeout anyway if we use
+    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener
+    // below, which expects to be called synchronously.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .listener(requestListener)
+                .dontTransform()
+                .into(imageView);
+          }
+        });
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadIntoView_withSkipMemoryCacheFalse_loadsFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .skipMemoryCache(false)
+            .dontTransform(),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we
+    // do end up re-using the old Target, our wait will always timeout anyway if we use
+    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener
+    // below, which expects to be called synchronously.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .listener(requestListener)
+                .skipMemoryCache(false)
+                .dontTransform()
+                .into(imageView);
+          }
+        });
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadIntoView_withSkipMemoryCache_doesNotLoadFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform()
+            .skipMemoryCache(true),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // If this test fails due to a timeout, it's because we re-used the Target from the previous
+    // request, which breaks the logic in loadOnMainThread that expects a new Target's
+    // onResourceReady callback to be called. This can be confirmed by changing this to
+    // runOnMainThread and verifying that the RequestListener assertion below fails because
+    // the DataSource was from the memory cache.
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform()
+            .skipMemoryCache(true),
+        imageView);
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
+  private void clearMemoryCacheOnMainThread() {
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
new file mode 100644
index 000000000..d298bc047
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
@@ -0,0 +1,96 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@RegressionTest
+@SplitByCpu
+@SplitBySdk({24, 21, 16})
+public class CenterCropRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void centerCrop_withSquareSmallerThanImage_returnsSquareImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(50));
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(50);
+  }
+
+  @Test
+  public void centerCrop_withRectangleSmallerThanImage_returnsRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(60, 70));
+    assertThat(result.getWidth()).isEqualTo(60);
+    assertThat(result.getHeight()).isEqualTo(70);
+  }
+
+  @Test
+  public void centerCrop_withSquareLargerThanImage_returnsUpscaledRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(canonical.getWidth() * 2));
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() * 2);
+  }
+
+  @Test
+  public void centerCrop_withRectangleLargerThanImage_returnsUpscaledRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(canonical.getWidth() * 2, canonical.getHeight() * 2));
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() * 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
new file mode 100644
index 000000000..8749cbc89
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
@@ -0,0 +1,103 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({24, 21, 16})
+@RegressionTest
+public class CenterInsideRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void centerInside_withSquareSmallerThanImage_returnsImageFitWithinSquare()
+      throws ExecutionException, InterruptedException {
+
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(37);
+  }
+
+  @Test
+  public void centerInside_withSquareLargerThanImage_returnsOriginalImage()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth());
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight());
+  }
+
+  @Test
+  public void centerInside_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
+  }
+
+  @Test
+  public void centerInside_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
new file mode 100644
index 000000000..4858c3906
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
@@ -0,0 +1,102 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({26, 24, 23, 21, 18, 16})
+@RegressionTest
+public class CircleCropRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void circleCrop_withSquareSmallerThanImage_returnsSquaredImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(50);
+  }
+
+  @Test
+  public void circleCrop_withSquareLargerThanImage_returnsUpscaledFitImage()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(multipliedWidth);
+    assertThat(result.getHeight()).isEqualTo(multipliedWidth);
+  }
+
+  @Test
+  public void circleCrop_withNarrowRectangle_cropsWithin()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() / 10);
+  }
+
+  @Test
+  public void circleCrop_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getHeight() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
new file mode 100644
index 000000000..df1731680
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.util.Base64;
+import androidx.core.content.ContextCompat;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Preconditions;
+import java.io.ByteArrayOutputStream;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DataUriTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = ApplicationProvider.getApplicationContext();
+
+  @Test
+  public void load_withJpegAsDataUriString_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context).asBitmap().load(getDataUriString(CompressFormat.JPEG)).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withPngDataUriString_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context).asBitmap().load(getDataUriString(CompressFormat.PNG)).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withJpegAsDataUri_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context).asBitmap().load(getDataUri(CompressFormat.JPEG)).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withPngAsDataUri_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context).asBitmap().load(getDataUri(CompressFormat.PNG)).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  private Uri getDataUri(CompressFormat format) {
+    return Uri.parse(getDataUriString(format));
+  }
+
+  private String getDataUriString(CompressFormat format) {
+    String bytes = getBase64BitmapBytes(format);
+    String imageType;
+    switch (format) {
+      case PNG:
+        imageType = "png";
+        break;
+      case JPEG:
+        imageType = "jpeg";
+        break;
+      case WEBP:
+        imageType = "webp";
+        break;
+      default:
+        throw new IllegalArgumentException("Unrecognized format: " + format);
+    }
+
+    String mimeType = "image/" + imageType;
+    return "data:" + mimeType + ";base64," + bytes;
+  }
+
+  @SuppressWarnings("deprecation")
+  private String getBase64BitmapBytes(CompressFormat format) {
+    ByteArrayOutputStream bos = new ByteArrayOutputStream();
+    Drawable drawable =
+        Preconditions.checkNotNull(ContextCompat.getDrawable(context, ResourceIds.raw.canonical));
+    Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();
+    bitmap.compress(format, 100, bos);
+    byte[] data = bos.toByteArray();
+    return Base64.encodeToString(data, /*flags=*/ 0);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
new file mode 100644
index 000000000..5873ce58b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
@@ -0,0 +1,204 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.BitmapSubject.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.os.Build;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DownsampleVideoTest {
+  // The dimensions of the test video.
+  private static final int WIDTH = 1080;
+  private static final int HEIGHT = 1920;
+
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = ApplicationProvider.getApplicationContext();
+
+  @Before
+  public void setUp() {
+    assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1);
+  }
+
+  @Test
+  public void loadVideo_downsampleStrategyNone_returnsOriginalVideoDimensions() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .downsample(DownsampleStrategy.NONE)
+                .submit(10, 10));
+
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleStrategyNone_doesNotUpscale() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .downsample(DownsampleStrategy.NONE)
+                .submit(WIDTH * 2, HEIGHT * 2));
+
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleDefault_downsamplesVideo() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context).asBitmap().load(ResourceIds.raw.video).submit(10, 10));
+
+    assertThat(bitmap).hasDimensions(10, 18);
+  }
+
+  @Test
+  public void loadVideo_downsampleAtMost_downsamplesToSmallerSize() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_MOST)
+                .load(ResourceIds.raw.video)
+                .submit(540, 959));
+    assertThat(bitmap).hasDimensions(270, 480);
+  }
+
+  @Test
+  public void loadVideo_downsampleAtMost_doesNotUpscale() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_MOST)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleAtLeast_downsamplesToLargerSize() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_LEAST)
+                .load(ResourceIds.raw.video)
+                .submit(270, 481));
+    assertThat(bitmap).hasDimensions(540, 960);
+  }
+
+  @Test
+  public void loadVideo_downsampleAtLeast_doesNotUpscale() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_LEAST)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleCenterInside_downsamplesWithinBox() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.CENTER_INSIDE)
+                .load(ResourceIds.raw.video)
+                .submit(270, 481));
+    assertThat(bitmap).hasDimensions(270, 480);
+  }
+
+  @Test
+  public void loadVideo_downsampleCenterInside_doesNotUpscale() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.CENTER_INSIDE)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+
+  @Test
+  public void loadVideo_downsampleCenterOutside_downsamplesOutsideBox() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.CENTER_OUTSIDE)
+                .load(ResourceIds.raw.video)
+                .submit(270, 481));
+    assertThat(bitmap).hasDimensions(271, 481);
+  }
+
+  @Test
+  public void loadVideo_downsampleCenterOutside_upsacles() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.CENTER_OUTSIDE)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH * 2, HEIGHT * 2);
+  }
+
+  @Test
+  public void loadVideo_downsampleFitCenter_downsamplesInsideBox() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.FIT_CENTER)
+                .load(ResourceIds.raw.video)
+                .submit(270, 481));
+    assertThat(bitmap).hasDimensions(270, 480);
+  }
+
+  @Test
+  public void loadVideo_downsampleFitCenter_upscales() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.FIT_CENTER)
+                .load(ResourceIds.raw.video)
+                .submit(WIDTH * 2, HEIGHT * 2));
+    assertThat(bitmap).hasDimensions(WIDTH * 2, HEIGHT * 2);
+  }
+
+  @Test
+  public void loadVideo_withSizeOriginal_ignoresDownsampleStrategy() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .downsample(DownsampleStrategy.AT_MOST)
+                .load(ResourceIds.raw.video)
+                .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL));
+
+    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
new file mode 100644
index 000000000..7bc31c24b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
@@ -0,0 +1,235 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.TransformationUtils;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.GlideApp;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DrawableTransformationTest {
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.get(context).clearDiskCache();
+    Glide.tearDown();
+  }
+
+  @Test
+  public void load_withColorDrawable_sizeOriginal_optionalTransform_returnsColorDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+    Drawable result =
+        Glide.with(context)
+            .load(colorDrawable)
+            .apply(new RequestOptions().optionalCenterCrop())
+            .submit()
+            .get();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  /** Transformations that do nothing can simply return the original Bitmap. */
+  @Test
+  public void load_withColorDrawable_fixedSize_requiredUnitTransform_returnsOriginalDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    Drawable result =
+        Glide.with(context)
+            .load(colorDrawable)
+            .apply(new RequestOptions().centerCrop())
+            .submit(100, 100)
+            .get();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Transformations that produce a different output color/shape/image etc will end up returning a
+   * {@link Bitmap} based on the original {@link Drawable} but with the transformation applied.
+   */
+  @Test
+  public void load_withColorDrawable_fixedSize_nonUnitRequiredTransform_returnsBitmapDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    Drawable result =
+        Glide.with(context)
+            .load(colorDrawable)
+            .apply(new RequestOptions().circleCrop())
+            .submit(100, 100)
+            .get();
+
+    Bitmap redSquare = Bitmap.createBitmap(100, 100, Config.ARGB_8888);
+    Canvas canvas = new Canvas(redSquare);
+    canvas.drawColor(Color.RED);
+
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+    when(bitmapPool.get(100, 100, Bitmap.Config.ARGB_8888))
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    Bitmap expected = TransformationUtils.circleCrop(bitmapPool, redSquare, 100, 100);
+
+    assertThat(result).isInstanceOf(BitmapDrawable.class);
+    Bitmap bitmap = ((BitmapDrawable) result).getBitmap();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(100);
+    for (int x = 0; x < bitmap.getWidth(); x++) {
+      for (int y = 0; y < bitmap.getHeight(); y++) {
+        assertThat(bitmap.getPixel(x, y)).isEqualTo(expected.getPixel(x, y));
+      }
+    }
+  }
+
+  @Test
+  public void load_withColorDrawable_sizeOriginal_requiredTransform_fails()
+      throws ExecutionException, InterruptedException {
+    final Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    // The following section is a hack to workaround a weird behavior where a post in RequestManager
+    // can cause a failed request to be started twice in a row if the first attempt happens before.
+    // the post. This seems rather unlikely to happen in real applications and it only occurs when
+    // the request fails unexpectedly, so we're working around this weird behavior in this test.
+    // See #3551.
+
+    // Trigger the Glide application RequestManager to be created.
+    Glide.get(context).getRequestManagerRetriever().get(context);
+    // Wait until it's added as a lifecycle observer.
+    final CountDownLatch latch = new CountDownLatch(1);
+    new Handler(Looper.getMainLooper())
+        .post(
+            new Runnable() {
+              @Override
+              public void run() {
+                latch.countDown();
+              }
+            });
+    latch.await(5, TimeUnit.SECONDS);
+
+    // End hacks.
+
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            Glide.with(context)
+                .load(colorDrawable)
+                .apply(new RequestOptions().centerCrop())
+                .submit()
+                .get();
+          }
+        });
+  }
+
+  @Test
+  public void load_withBitmapDrawable_andDoNothingTransformation_doesNotRecycleBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+
+    Drawable result =
+        GlideApp.with(context)
+            .load(drawable)
+            .fitCenter()
+            .override(bitmap.getWidth(), bitmap.getHeight())
+            .submit()
+            .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+  }
+
+  @Test
+  public void load_withBitmapDrawable_andFunctionalTransformation_doesNotRecycleBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+
+    Drawable result =
+        GlideApp.with(context)
+            .load(drawable)
+            .fitCenter()
+            .override(bitmap.getWidth() / 2, bitmap.getHeight() / 2)
+            .submit()
+            .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+  }
+
+  @Test
+  public void load_withColorDrawable_fixedSize_unitBitmapTransform_recyclesIntermediates()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    int width = 100;
+    int height = 200;
+
+    GlideApp.with(context).load(colorDrawable).fitCenter().override(width, height).submit().get();
+
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    // Make sure we didn't put the same Bitmap twice.
+    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);
+    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);
+
+    assertThat(first).isNotSameInstanceAs(second);
+  }
+
+  @Test
+  public void load_withColorDrawable_fixedSize_functionalBitmapTransform_doesNotRecycleOutput()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    int width = 100;
+    int height = 200;
+
+    Drawable result =
+        GlideApp.with(context)
+            .load(colorDrawable)
+            .circleCrop()
+            .override(width, height)
+            .submit()
+            .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    // Make sure we didn't put the same Bitmap twice.
+    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);
+    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);
+
+    assertThat(first).isNotSameInstanceAs(second);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
new file mode 100644
index 000000000..943e76c58
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
@@ -0,0 +1,153 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.File;
+import java.util.concurrent.CountDownLatch;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class ErrorHandlingTest {
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
+  }
+
+  // ResourceEncoders are expected not to throw and to return true or false. If they do throw, it's
+  // a developer error, so we expect UncaughtThrowableStrategy to be called.
+  @Test
+  public void load_whenEncoderFails_callsUncaughtThrowableStrategy() {
+    WaitForErrorStrategy strategy = new WaitForErrorStrategy();
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
+            .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
+            .setDiskCacheExecutor(GlideExecutor.newDiskCacheExecutor(strategy)));
+    Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
+
+    concurrency.get(
+        Glide.with(context).load(ResourceIds.raw.canonical).listener(requestListener).submit());
+
+    // Writing to the disk cache and therefore the exception caused by our FailEncoder may happen
+    // after the request completes, so we should wait for the expected error explicitly.
+    ConcurrencyHelper.waitOnLatch(strategy.latch);
+    assertThat(strategy.error).isEqualTo(FailEncoder.TO_THROW);
+
+    verify(requestListener, never())
+        .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
+  }
+
+  @Test
+  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {
+    WaitForErrorStrategy strategy = new WaitForErrorStrategy();
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
+            .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
+            .setDiskCacheExecutor(GlideExecutor.newDiskCacheExecutor(strategy)));
+    Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
+
+    concurrency.get(
+        Glide.with(context).load(ResourceIds.raw.canonical).listener(requestListener).submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), any(DataSource.class), anyBoolean());
+    verify(requestListener, never())
+        .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
+  }
+
+  @Test
+  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {
+    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    FutureTarget<Drawable> target =
+        Glide.with(context)
+            .load((Object) null)
+            .error(Glide.with(context).load(errorModel).listener(requestListener))
+            .submit();
+
+    Glide.with(context).clear(target);
+    errorModel.countDown();
+
+    // Make sure any pending requests run.
+    concurrency.pokeMainThread();
+    Glide.tearDown();
+    // Make sure that any callbacks posted back to the main thread run.
+    concurrency.pokeMainThread();
+  }
+
+  private static final class WaitForErrorStrategy implements UncaughtThrowableStrategy {
+    final CountDownLatch latch = new CountDownLatch(1);
+    @Nullable Throwable error = null;
+
+    @Override
+    public void handle(Throwable t) {
+      if (error != null) {
+        throw new IllegalArgumentException("Received second error", t);
+      }
+      error = t;
+      latch.countDown();
+    }
+  }
+
+  private static final class FailEncoder implements ResourceEncoder<Bitmap> {
+
+    static final RuntimeException TO_THROW = new RuntimeException();
+
+    @NonNull
+    @Override
+    public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
+      return EncodeStrategy.TRANSFORMED;
+    }
+
+    @Override
+    public boolean encode(
+        @NonNull Resource<Bitmap> data, @NonNull File file, @NonNull Options options) {
+      throw TO_THROW;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
new file mode 100644
index 000000000..1bf471a36
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
@@ -0,0 +1,121 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.DiskCache.Factory;
+import com.bumptech.glide.load.engine.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.File;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+// Tests #2465.
+@RunWith(AndroidJUnit4.class)
+public class ExternallyClearedDiskCacheTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private File cacheDir;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+    cacheDir = context.getCacheDir();
+  }
+
+  @After
+  public void tearDown() {
+    // Force us to wait until Glide's threads shut down.
+    Glide.tearDown();
+    deleteRecursively(cacheDir);
+  }
+
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+  }
+
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeletedAndCleared_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(
+                new Factory() {
+                  @Override
+                  public DiskCache build() {
+                    return cache;
+                  }
+                }));
+
+    Drawable drawable =
+        concurrency.get(Glide.with(context).load(ResourceIds.raw.canonical).submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeleted_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(
+                new Factory() {
+                  @Override
+                  public DiskCache build() {
+                    return cache;
+                  }
+                }));
+
+    Drawable drawable = concurrency.get(Glide.with(context).load(raw.canonical).submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  private static void deleteRecursively(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursively(f);
+        }
+      }
+    }
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
new file mode 100644
index 000000000..dbb5342a3
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
@@ -0,0 +1,125 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({24, 23, 21, 19, 18, 16})
+@RegressionTest
+public class FitCenterRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void fitCenter_withSquareSmallerThanImage_returnsImageFitWithinSquare()
+      throws ExecutionException, InterruptedException {
+
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context).asBitmap().load(canonical.getBitmap()).fitCenter().override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(37);
+  }
+
+  @Test
+  public void fitCenter_withSquareLargerThanImage_returnsUpscaledSquare()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    int multipliedHeight = (int) (canonical.getHeight() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(multipliedWidth);
+    assertThat(result.getHeight()).isEqualTo(multipliedHeight);
+  }
+
+  @Test
+  public void fitCenter_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
+  }
+
+  @Test
+  public void fitCenter_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+
+  @Test
+  public void fitCenter_withHugeRectangle_throwsOOM()
+      throws ExecutionException, InterruptedException {
+    float multiplier = Integer.MAX_VALUE / (canonical.getWidth() * canonical.getHeight() * 2);
+    final int overrideWidth = (int) multiplier * canonical.getWidth();
+    final int overrideHeight = (int) multiplier * canonical.getHeight();
+
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(overrideWidth, overrideHeight)
+                .submit()
+                .get();
+          }
+        });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
new file mode 100644
index 000000000..fc6d8ffba
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
@@ -0,0 +1,345 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyBitmap;
+import static com.bumptech.glide.test.Matchers.anyBitmapTarget;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.Drawable;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBitmapTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Bitmap> bitmapListener;
+  @Mock private RequestListener<Drawable> drawableListener;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private GlideBuilder glideBuilder;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
+
+    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob
+    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race
+    // by making our clear and EngineJob's clear run on the same thread.
+    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();
+    glideBuilder =
+        new GlideBuilder()
+            .setSourceExecutor(mainThreadExecutor)
+            .setDiskCacheExecutor(mainThreadExecutor)
+            .setAnimationExecutor(mainThreadExecutor);
+  }
+
+  @Test
+  public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).asDrawable().load(bitmap).submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context).asDrawable().load(bitmap).centerCrop().submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).load(bitmap).submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(GlideApp.with(context).load(bitmap).centerCrop().submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Bitmap> target =
+        concurrency.wait(GlideApp.with(context).asBitmap().load(bitmap).submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(GlideApp.with(context).asBitmap().load(bitmap).centerCrop().submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).load(bitmap).centerCrop().submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context).asDrawable().load(bitmap).centerCrop().submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context).asBitmap().load(bitmap).centerCrop().submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(anyBitmap(), any(), anyBitmapTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(anyBitmap(), any(), anyBitmapTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
new file mode 100644
index 000000000..680029e2c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
@@ -0,0 +1,493 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.GlideOptions.skipMemoryCacheOf;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.widget.AbsListView.LayoutParams;
+import android.widget.ImageView;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> requestListener;
+
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
+
+    imageView = new ImageView(context);
+    int[] dimensions = getCanonicalDimensions();
+    imageView.setLayoutParams(new LayoutParams(/*w=*/ dimensions[0], /*h=*/ dimensions[1]));
+
+    // Writes to the resource disk cache run in a non-blocking manner after the Target is notified.
+    // Unless we enforce a single threaded executor, the encode task races with our second decode
+    // task, causing the test to sometimes fail (when the second resource is started after the
+    // encode and loaded from the disk cache) and sometimes succeed (when the second resource is
+    // started before the encode and loads from source).
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    GlideExecutor glideExecutor = MockGlideExecutor.newTestExecutor(executor);
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setAnimationExecutor(glideExecutor)
+            .setDiskCacheExecutor(glideExecutor)
+            .setSourceExecutor(glideExecutor));
+  }
+
+  @Test
+  public void loadFromRequestManager_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(Glide.with(context).load(canonicalBytes), imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(Glide.with(context).load(modifiedBytes), imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameInstanceAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void loadFromRequestBuilder_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context).asDrawable().load(canonicalBytes), imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context).asDrawable().load(modifiedBytes), imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameInstanceAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void requestManager_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(canonicalBytes).apply(skipMemoryCacheOf(false)), imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void requestBuilder_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context).asDrawable().load(canonicalBytes).apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(data)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(data)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).load(data).skipMemoryCache(false).submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context).asDrawable().load(data).skipMemoryCache(false).submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(GlideApp.with(context).load(data).submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(GlideApp.with(context).load(data).listener(requestListener).submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).asDrawable().load(data).submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context).asDrawable().load(data).listener(requestListener).submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(GlideApp.with(context).load(data).submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(GlideApp.with(context).load(data).listener(requestListener).submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).asDrawable().load(data).submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context).asDrawable().load(data).listener(requestListener).submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDiskCacheStrategySetBeforeLoad_doesNotOverrideDiskCacheStrategy()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withSkipMemoryCacheSetBeforeLoad_doesNotOverrideSkipMemoryCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context).asDrawable().skipMemoryCache(false).load(data).submit());
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDataDiskCacheStrategy_returnsFromSource() throws IOException {
+    byte[] data = getCanonicalBytes();
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .load(data)
+            .submit());
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .skipMemoryCache(true)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  private Bitmap copyFromImageViewDrawable(ImageView imageView) {
+    if (imageView.getDrawable() == null) {
+      fail("Drawable unexpectedly null");
+    }
+
+    // Glide mutates Bitmaps, so it's possible that a Bitmap loaded into a View in one place may
+    // be re-used to load a different image later. Create a defensive copy just in case.
+    return Bitmap.createBitmap(((BitmapDrawable) imageView.getDrawable()).getBitmap());
+  }
+
+  private int[] getCanonicalDimensions() throws IOException {
+    byte[] canonicalBytes = getCanonicalBytes();
+    Bitmap bitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    return new int[] {bitmap.getWidth(), bitmap.getHeight()};
+  }
+
+  private byte[] getModifiedBytes() throws IOException {
+    int[] dimensions = getCanonicalDimensions();
+    Bitmap bitmap = Bitmap.createBitmap(dimensions[0], dimensions[1], Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
+    return os.toByteArray();
+  }
+
+  private byte[] getCanonicalBytes() throws IOException {
+    int resourceId = ResourceIds.raw.canonical;
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(resourceId);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
new file mode 100644
index 000000000..db9e9a8f2
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
@@ -0,0 +1,197 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> listener;
+
+  private Context context;
+  private GlideExecutor executor;
+  private GlideBuilder glideBuilder;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    executor = MockGlideExecutor.newMainThreadExecutor();
+
+    context = ApplicationProvider.getApplicationContext();
+    glideBuilder =
+        new GlideBuilder()
+            .setAnimationExecutor(executor)
+            .setSourceExecutor(executor)
+            .setDiskCacheExecutor(executor);
+  }
+
+  @Test
+  public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).load(drawable).submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    concurrency.wait(GlideApp.with(context).load(drawable).centerCrop().submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).load(drawable).centerCrop().submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context).load(drawable).centerCrop().listener(listener).submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context).asDrawable().load(drawable).centerCrop().submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context).load(drawable).centerCrop().listener(listener).submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
+
+    concurrency.wait(
+        GlideApp.with(context).load(drawable).centerCrop().listener(listener).submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
new file mode 100644
index 000000000..1da10d6cb
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
@@ -0,0 +1,304 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ColorSpace;
+import android.net.Uri;
+import android.os.Build;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Locale;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * On API 26, decoding a variety of different images can cause {@link BitmapFactory} with {@link
+ * BitmapFactory.Options#inJustDecodeBounds} set to {@code true} to set {@link
+ * BitmapFactory.Options#outConfig} to null instead of a valid value, even though the image can be
+ * decoded successfully. Glide can mask these failures by decoding some image sources (notably
+ * including resource ids) using other data types and decoders.
+ *
+ * <p>This test ensures that we've worked around the framework issue by loading a variety of images
+ * and image types without the normal fallback behavior.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadResourcesWithDownsamplerTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = ApplicationProvider.getApplicationContext();
+
+  @Test
+  public void loadJpegResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context)
+        .getRegistry()
+        .prepend(Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.canonical));
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadWideGamutJpegResource_withNoOtherLoaders_decodesWideGamutBitmap() {
+    assumeTrue(
+        "Wide gamut is only available on O+", Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+    Glide.get(context)
+        .getRegistry()
+        .prepend(
+            Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.webkit_logo_p3));
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+    assertThat(bitmap.getColorSpace())
+        .isEqualTo(ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB));
+  }
+
+  @Test
+  public void loadOpaquePngResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context)
+        .getRegistry()
+        .prepend(
+            Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.canonical_png));
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentPngResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context)
+        .getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical_transparent_png));
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentGifResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context)
+        .getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentGifResource_asHardware_withNoOtherLoaders_decodesResource() {
+    assumeTrue(
+        "Hardware Bitmaps are only supported on O+",
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+
+    Glide.get(context)
+        .getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .set(Downsampler.ALLOW_HARDWARE_CONFIG, true)
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.HARDWARE);
+  }
+
+  @Test
+  public void loadTransparentGifResource_withNoOtherLoaders_fromBytes_decodesResource() {
+    byte[] data = getBytes(ResourceIds.raw.transparent_gif);
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context)
+        .getRegistry()
+        .prepend(
+            Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_asBytes_decodesResource() {
+    byte[] data = getBytes(ResourceIds.raw.opaque_gif);
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_asHardware_withNoOtherLoaders_decodesResource() {
+    assumeTrue(
+        "Hardware Bitmaps are only supported on O+",
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+
+    Glide.get(context)
+        .getRegistry()
+        .prepend(
+            Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                // Allow HARDWARE Bitmaps.
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  private byte[] getBytes(int resourceId) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    InputStream is = null;
+    try {
+      is = context.getResources().openRawResource(resourceId);
+      byte[] buffer = new byte[1024 * 1024];
+      int read;
+      while ((read = is.read(buffer)) != -1) {
+        os.write(buffer, 0, read);
+      }
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored;
+        }
+      }
+    }
+
+    return os.toByteArray();
+  }
+
+  private class FakeModelLoader<T>
+      implements ModelLoader<T, InputStream>, ModelLoaderFactory<T, InputStream> {
+
+    private final int resourceId;
+
+    FakeModelLoader(int resourceId) {
+      this.resourceId = resourceId;
+    }
+
+    @androidx.annotation.Nullable
+    @Override
+    public LoadData<InputStream> buildLoadData(
+        @NonNull Object o, int width, int height, @NonNull Options options) {
+      return new LoadData<>(new ObjectKey(o), new Fetcher());
+    }
+
+    @Override
+    public boolean handles(@NonNull Object o) {
+      return true;
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<T, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
+      return this;
+    }
+
+    @Override
+    public void teardown() {}
+
+    private final class Fetcher implements DataFetcher<InputStream> {
+      private InputStream inputStream;
+
+      @Override
+      public void loadData(
+          @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
+        inputStream = getInputStreamForResource(context, resourceId);
+        callback.onDataReady(inputStream);
+      }
+
+      private InputStream getInputStreamForResource(Context context, @DrawableRes int resourceId) {
+        Resources resources = context.getResources();
+        try {
+          Uri parse =
+              Uri.parse(
+                  String.format(
+                      Locale.US,
+                      "%s://%s/%s/%s",
+                      ContentResolver.SCHEME_ANDROID_RESOURCE,
+                      resources.getResourcePackageName(resourceId),
+                      resources.getResourceTypeName(resourceId),
+                      resources.getResourceEntryName(resourceId)));
+          return context.getContentResolver().openInputStream(parse);
+        } catch (Resources.NotFoundException | FileNotFoundException e) {
+          throw new IllegalArgumentException("Resource ID " + resourceId + " not found", e);
+        }
+      }
+
+      @Override
+      public void cleanup() {
+        InputStream local = inputStream;
+        if (local != null) {
+          try {
+            local.close();
+          } catch (IOException e) {
+            // Ignored.
+          }
+        }
+      }
+
+      @Override
+      public void cancel() {
+        // Do nothing.
+      }
+
+      @NonNull
+      @Override
+      public Class<InputStream> getDataClass() {
+        return InputStream.class;
+      }
+
+      @NonNull
+      @Override
+      public DataSource getDataSource() {
+        return DataSource.LOCAL;
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
new file mode 100644
index 000000000..8935ed445
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
@@ -0,0 +1,284 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests that Glide is able to load videos stored in resources and loaded as {@link
+ * android.content.res.AssetFileDescriptor}s.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadVideoResourceTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_decodesFrame() {
+    Drawable frame = concurrency.get(Glide.with(context).load(ResourceIds.raw.video).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_decodesFrame() {
+    Drawable frame =
+        concurrency.get(Glide.with(context).load(new Integer(ResourceIds.raw.video)).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(Glide.with(context).asBitmap().load(ResourceIds.raw.video).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_withFrameTime_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Drawable frame = concurrency.get(GlideApp.with(context).load(uri).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame = concurrency.get(GlideApp.with(context).asBitmap().load(uri).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame = concurrency.get(GlideApp.with(context).asBitmap().load(uri.toString()).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Drawable frame = concurrency.get(GlideApp.with(context).load(uri).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame = concurrency.get(GlideApp.with(context).asBitmap().load(uri).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame = concurrency.get(GlideApp.with(context).asBitmap().load(uri.toString()).submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
index d7153958f..15cacbf85 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -3,6 +3,7 @@
 import static com.bumptech.glide.request.RequestOptions.bitmapTransform;
 import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
 
 import android.content.ContentResolver;
 import android.content.Context;
@@ -15,132 +16,124 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
 import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
+import org.junit.function.ThrowingRunnable;
+import org.junit.rules.TestName;
 import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
 
 @RunWith(AndroidJUnit4.class)
 public class NonBitmapDrawableResourcesTest {
-  private Context context;
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
 
-  @Rule
-  public ExpectedException expectedException = ExpectedException.none();
+  private Context context;
 
   @Before
   public void setUp() {
-    context = InstrumentationRegistry.getTargetContext();
-  }
-
-  @After
-  public void tearDown() {
-    Glide.get(context).clearDiskCache();
-    Glide.tearDown();
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
   }
 
   @Test
   public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(android.R.drawable.star_big_off)
-        .submit()
-        .get();
+    Drawable drawable = Glide.with(context).load(android.R.drawable.star_big_off).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withBitmapResourceId_asDrawable_withTransformation_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(android.R.drawable.star_big_off)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(android.R.drawable.star_big_off)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withBitmapResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(android.R.drawable.star_big_off)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context).asBitmap().load(android.R.drawable.star_big_off).submit().get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withBitmapAliasResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.bitmap_alias)
-        .submit()
-        .get();
+    Drawable drawable = Glide.with(context).load(ResourceIds.drawable.bitmap_alias).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withBitmapAliasResourceId_asDrawable_withTransformation_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.bitmap_alias)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.bitmap_alias)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withBitmapAliasResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.bitmap_alias)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context).asBitmap().load(ResourceIds.drawable.bitmap_alias).submit().get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withShapeDrawableResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.shape_drawable)
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context).load(ResourceIds.drawable.shape_drawable).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withShapeDrawableResourceId_asDrawable_withTransformation_sizeOriginal_fails()
       throws ExecutionException, InterruptedException {
-    expectedException.expect(ExecutionException.class);
-    Glide.with(context)
-        .load(ResourceIds.drawable.shape_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            Glide.with(context)
+                .load(ResourceIds.drawable.shape_drawable)
+                .apply(centerCropTransform())
+                .submit()
+                .get();
+          }
+        });
   }
 
   @Test
   public void load_withShapeDrawableResourceId_asDrawable_withTransformation_validSize_succeeds()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.shape_drawable)
-        .apply(bitmapTransform(new RoundedCorners(10)))
-        .submit(100, 200)
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.shape_drawable)
+            .apply(bitmapTransform(new RoundedCorners(10)))
+            .submit(100, 200)
+            .get();
     assertThat(drawable).isNotNull();
     assertThat(drawable.getIntrinsicWidth()).isEqualTo(100);
     assertThat(drawable.getIntrinsicHeight()).isEqualTo(200);
@@ -149,22 +142,25 @@ public void load_withShapeDrawableResourceId_asDrawable_withTransformation_valid
   @Test
   public void load_withShapeDrawableResourceId_asBitmap_withSizeOriginal_fails()
       throws ExecutionException, InterruptedException {
-    expectedException.expect(ExecutionException.class);
-    Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.shape_drawable)
-        .submit()
-        .get();
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            Glide.with(context).asBitmap().load(ResourceIds.drawable.shape_drawable).submit().get();
+          }
+        });
   }
 
   @Test
   public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.shape_drawable)
-        .submit(100, 200)
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.shape_drawable)
+            .submit(100, 200)
+            .get();
     assertThat(bitmap).isNotNull();
     assertThat(bitmap.getWidth()).isEqualTo(100);
     assertThat(bitmap.getHeight()).isEqualTo(200);
@@ -173,12 +169,13 @@ public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNu
   @Test
   public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_nonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.shape_drawable)
-        .apply(centerCropTransform())
-        .submit(100, 200)
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.shape_drawable)
+            .apply(centerCropTransform())
+            .submit(100, 200)
+            .get();
     assertThat(bitmap).isNotNull();
     assertThat(bitmap.getWidth()).isEqualTo(100);
     assertThat(bitmap.getHeight()).isEqualTo(200);
@@ -187,98 +184,94 @@ public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_
   @Test
   public void load_withStateListDrawableResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.state_list_drawable)
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context).load(ResourceIds.drawable.state_list_drawable).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withStateListDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.state_list_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.state_list_drawable)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withStateListDrawableResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.state_list_drawable)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.state_list_drawable)
+            .submit()
+            .get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withStateListDrawableResourceId_asBitmap_withTransformation_nonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.state_list_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.state_list_drawable)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withVectorDrawableResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.vector_drawable)
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context).load(ResourceIds.drawable.vector_drawable).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withVectorDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.vector_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.vector_drawable)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withVectorDrawableResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.vector_drawable)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context).asBitmap().load(ResourceIds.drawable.vector_drawable).submit().get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withVectorDrawableResourceId_asBitmap_withTransformation_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.vector_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.vector_drawable)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context).load(ResourceIds.drawable.googlelogo_color_120x44dp).submit().get();
 
     assertThat(drawable).isNotNull();
   }
@@ -286,11 +279,12 @@ public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
   @Test
   public void load_withNinePatchResourceId_asDrawable_withTransformation_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
 
     assertThat(drawable).isNotNull();
   }
@@ -298,11 +292,12 @@ public void load_withNinePatchResourceId_asDrawable_withTransformation_producesN
   @Test
   public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+            .submit()
+            .get();
 
     assertThat(bitmap).isNotNull();
   }
@@ -310,12 +305,13 @@ public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap()
   @Test
   public void load_withNinePatchResourceId_asBitmap_withTransformation_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
 
     assertThat(bitmap).isNotNull();
   }
@@ -326,16 +322,14 @@ public void load_withApplicationIconResourceIdUri_asDrawable_producesNonNullDraw
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .path(String.valueOf(iconResourceId))
+              .build();
 
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .submit()
-          .get();
+      Drawable drawable = Glide.with(context).load(uri).submit().get();
       assertThat(drawable).isNotNull();
     }
   }
@@ -346,17 +340,14 @@ public void load_withApplicationIconResourceIdUri_asDrawable_withTransformation_
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .apply(centerCropTransform())
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .path(String.valueOf(iconResourceId))
+              .build();
+
+      Drawable drawable = Glide.with(context).load(uri).apply(centerCropTransform()).submit().get();
       assertThat(drawable).isNotNull();
     }
   }
@@ -367,39 +358,33 @@ public void load_withApplicationIconResourceIdUri_asBitmap_producesNonNullBitmap
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Bitmap bitmap = Glide.with(context)
-          .asBitmap()
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .path(String.valueOf(iconResourceId))
+              .build();
+
+      Bitmap bitmap = Glide.with(context).asBitmap().load(uri).submit().get();
       assertThat(bitmap).isNotNull();
     }
   }
 
   @Test
   public void load_withApplicationIconResourceIdUri_asBitmap_withTransformation_nonNullBitmap()
-      throws NameNotFoundException, ExecutionException, InterruptedException {
+      throws ExecutionException, InterruptedException {
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Bitmap bitmap = Glide.with(context)
-          .asBitmap()
-          .apply(centerCropTransform())
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .path(String.valueOf(iconResourceId))
+              .build();
+
+      Bitmap bitmap =
+          Glide.with(context).asBitmap().apply(centerCropTransform()).load(uri).submit().get();
       assertThat(bitmap).isNotNull();
     }
   }
@@ -412,23 +397,19 @@ public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDr
 
       Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
       Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .appendPath(resources.getResourceTypeName(iconResourceId))
+              .appendPath(resources.getResourceEntryName(iconResourceId))
+              .build();
+
+      Drawable drawable = Glide.with(context).load(uri).submit().get();
       assertThat(drawable).isNotNull();
     }
   }
 
-
   @Test
   public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_nonNullDrawable()
       throws ExecutionException, InterruptedException, NameNotFoundException {
@@ -437,19 +418,15 @@ public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_non
 
       Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
       Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .apply(centerCropTransform())
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .appendPath(resources.getResourceTypeName(iconResourceId))
+              .appendPath(resources.getResourceEntryName(iconResourceId))
+              .build();
+
+      Drawable drawable = Glide.with(context).load(uri).apply(centerCropTransform()).submit().get();
       assertThat(drawable).isNotNull();
     }
   }
@@ -462,19 +439,15 @@ public void load_withApplicationIconResourceNameUri_asBitmap_producesNonNullBitm
 
       Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
       Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Bitmap bitmap = Glide.with(context)
-          .asBitmap()
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .appendPath(resources.getResourceTypeName(iconResourceId))
+              .appendPath(resources.getResourceEntryName(iconResourceId))
+              .build();
+
+      Bitmap bitmap = Glide.with(context).asBitmap().load(uri).submit().get();
       assertThat(bitmap).isNotNull();
     }
   }
@@ -487,20 +460,16 @@ public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNu
 
       Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
       Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Bitmap bitmap = Glide.with(context)
-          .asBitmap()
-          .apply(centerCropTransform())
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .appendPath(resources.getResourceTypeName(iconResourceId))
+              .appendPath(resources.getResourceEntryName(iconResourceId))
+              .build();
+
+      Bitmap bitmap =
+          Glide.with(context).asBitmap().apply(centerCropTransform()).load(uri).submit().get();
       assertThat(bitmap).isNotNull();
     }
   }
@@ -509,12 +478,13 @@ public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNu
     Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
     mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
     PackageManager packageManager = context.getPackageManager();
-    List<ResolveInfo> pkgAppsList =
-        packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
+    List<ResolveInfo> pkgAppsList = packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
     Set<String> result = new HashSet<>();
     for (ResolveInfo info : pkgAppsList) {
-      int iconResourceId = getResourceId(info.activityInfo.packageName);
-      if (iconResourceId != 0) {
+      String packageName = info.activityInfo.packageName;
+      int iconResourceId = getResourceId(packageName);
+      if (iconResourceId != 0
+          && doesApplicationPackageNameMatchResourcePackageName(packageName, iconResourceId)) {
         result.add(info.activityInfo.packageName);
       }
     }
@@ -530,4 +500,48 @@ private int getResourceId(String packageName) {
     }
     return packageInfo.applicationInfo.icon;
   }
+
+  /**
+   * Returns {@code true} iff the resource package name is exactly the same as the containing
+   * application package name for a given resource id.
+   *
+   * <p>The resource package name is the value returned by {@link
+   * Resources#getResourcePackageName(int)}. The application package name is package name of the
+   * enclosing application. If these two things are equal, then we can both construct a Context for
+   * that package and retrieve a resource id for that package from a "standard" resource Uri
+   * containing a name instead of an id. If they aren't equal, then we can do only one of the two
+   * required tasks, so our Uri load will always fail. To handle this properly, we'd need callers to
+   * include both package names in the Uri. I'm not aware of any standardized Uri format for doing
+   * so, so these requests will just be treated as unsupported for the time being.
+   *
+   * <p>Take Calendar (emulators API 24 and below) as an example:
+   *
+   * <ul>
+   *   <li>package name: com.google.android.calendar
+   *   <li>resource package name: com.android.calendar
+   * </ul>
+   *
+   * We can construct one of two possible Uris:
+   *
+   * <ul>
+   *   <li>android.resource://com.google.android.calendar/mipmap/ic_icon_calendar.
+   *   <li>android.resource://com.android.calendar/mipmap/ic_icon_calendar.<
+   * </ul>
+   *
+   * From the first Uri, we can obtain the correct Context/Resources for the calendar package, but
+   * our attempts to resolve the correct resource id will fail because we do not have the resource
+   * package name. From the second Uri we cannot obtain the Context/Resources for the calendar
+   * package because the resource package name doesn't match the application package name.
+   */
+  private boolean doesApplicationPackageNameMatchResourcePackageName(
+      String applicationPackageName, int iconResourceId) {
+    try {
+      Context current = context.createPackageContext(applicationPackageName, /*flags=*/ 0);
+      String resourcePackageName = current.getResources().getResourcePackageName(iconResourceId);
+      return applicationPackageName.equals(resourcePackageName);
+    } catch (NameNotFoundException e) {
+      // This should never happen
+      throw new RuntimeException(e);
+    }
+  }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
new file mode 100644
index 000000000..3706b5364
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.widget.ImageView;
+import androidx.test.core.app.ApplicationProvider;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.GlideRequests;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Rule;
+import org.junit.Test;
+
+/**
+ * Tests how {@link com.bumptech.glide.request.Request}s behave when the corresponding {@link
+ * RequestManager} is paused.
+ */
+public final class PausedRequestsTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = ApplicationProvider.getApplicationContext();
+
+  @SuppressWarnings("unchecked")
+  @Test
+  public void load_withPlaceHolderSet_requestsPaused_displaysPlaceholder() {
+    final ImageView imageView = new ImageView(context);
+
+    final GlideRequests requests = GlideApp.with(context);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            requests.pauseAllRequests();
+          }
+        });
+
+    final ColorDrawable expected = new ColorDrawable(Color.RED);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            requests.load(ResourceIds.drawable.bitmap_alias).placeholder(expected).into(imageView);
+          }
+        });
+
+    assertThat(imageView.getDrawable()).isEqualTo(expected);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
new file mode 100644
index 000000000..26b9e3be9
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.LifecycleListener;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class RequestManagerTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestManagerTreeNode treeNode;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private RequestManager requestManager;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
+    Glide glide = Glide.get(context);
+    requestManager =
+        new RequestManager(
+            glide,
+            new Lifecycle() {
+              @Override
+              public void addListener(@NonNull LifecycleListener listener) {
+                listener.onStart();
+              }
+
+              @Override
+              public void removeListener(@NonNull LifecycleListener listener) {
+                // Do nothing.
+              }
+            },
+            treeNode,
+            context);
+  }
+
+  /** Tests #2262. */
+  @Test
+  public void clear_withNonOwningRequestManager_afterOwningManagerIsDestroyed_doesNotThrow() {
+    // First destroy our Fragment/Activity RequestManager.
+    requestManager.onDestroy();
+
+    final ImageView imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+    // Then start a new load with our now destroyed RequestManager.
+    concurrency.loadOnMainThread(requestManager.load(ResourceIds.raw.canonical), imageView);
+
+    // Finally clear our new load with any RequestManager other than the one we used to start it.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.with(context).clear(imageView);
+          }
+        });
+  }
+
+  /** Tests b/69361054. */
+  @Test
+  public void clear_withNonOwningRequestManager_onBackgroundTHread_doesNotThrow() {
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            requestManager.onDestroy();
+          }
+        });
+
+    final Target<Drawable> target = concurrency.wait(requestManager.load(raw.canonical).submit());
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.with(context).clear(target);
+          }
+        });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
new file mode 100644
index 000000000..0406a1a30
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -0,0 +1,242 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/** Tests the behaviors of Requests of all types. */
+@RunWith(AndroidJUnit4.class)
+public class RequestTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = ApplicationProvider.getApplicationContext();
+    imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+
+    // Some emulators only have a single resize thread, so waiting on a latch will block them
+    // forever.
+    Glide.init(
+        context, new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
+  }
+
+  @Test
+  public void clear_withSingleRequest_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(GlideApp.with(context).load(ResourceIds.raw.canonical), imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void clear_withRequestWithThumbnail_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(GlideApp.with(context).load(ResourceIds.raw.canonical).override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequest_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(GlideApp.with(context).load(ResourceIds.raw.canonical), imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnail_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(GlideApp.with(context).load(ResourceIds.raw.canonical).override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequestInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).load(ResourceIds.raw.canonical).into(imageView);
+          }
+        });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnailBothInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(model)
+                .thumbnail(GlideApp.with(context).load(model).override(100, 100))
+                .into(imageView);
+          }
+        });
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  /** Tests #2555. */
+  @Test
+  public void onStop_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> mainModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(mainModel)
+            .listener(requestListener)
+            .thumbnail(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+    assertThat(imageView.getDrawable()).isNull();
+    mainModel.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithOnlyThumbnailInProgress_doesNotNullOutDrawableInView() {
+    final WaitModel<Integer> thumbModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .thumbnail(
+                GlideApp.with(context)
+                    .load(thumbModel)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+
+    // Only requests that are running are paused in onStop. The full request should take priority
+    // over the thumbnail request. Therefore, if the full request is finished in onStop, it should
+    // not be cleared, even if the thumbnail request is still running.
+    assertThat(imageView.getDrawable()).isNotNull();
+    thumbModel.countDown();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
new file mode 100644
index 000000000..2b26f4950
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
@@ -0,0 +1,98 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+
+/**
+ * Compares the output of RoundedCorners with canonical resource files for all SDKs Glide supports
+ * and fails on deltas.
+ */
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({26, 24, 23, 21, 19, 18, 16})
+@RegressionTest
+public class RoundedCornersRegressionTest {
+  @Rule public final TestRule tearDownGlide = new TearDownGlide();
+  @Rule public final TestName testName = new TestName();
+
+  private Context context;
+  private BitmapRegressionTester bitmapRegressionTester;
+  private CanonicalBitmap canonicalBitmap;
+
+  @Before
+  public void setUp() throws Exception {
+    context = ApplicationProvider.getApplicationContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonicalBitmap = new CanonicalBitmap();
+  }
+
+  @Test
+  public void testRoundedCorners() throws ExecutionException, InterruptedException {
+    bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .transform(new RoundedCorners(5)));
+  }
+
+  @Test
+  public void testRoundedCorners_usePool() throws ExecutionException, InterruptedException {
+    canonicalBitmap = canonicalBitmap.scale(0.1f);
+
+    Bitmap redRect =
+        createRect(
+            Color.RED,
+            canonicalBitmap.getWidth(),
+            canonicalBitmap.getHeight(),
+            Bitmap.Config.ARGB_8888);
+
+    Glide.get(context).getBitmapPool().put(redRect);
+
+    Bitmap roundedRect =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonicalBitmap.getBitmap())
+                .override(canonicalBitmap.getWidth(), canonicalBitmap.getHeight())
+                .transform(new RoundedCorners(5)));
+
+    assertThat(roundedRect).isEqualTo(redRect);
+  }
+
+  @Test
+  public void testRoundedCorners_overRounded() throws ExecutionException, InterruptedException {
+    bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .transform(new RoundedCorners(20)));
+  }
+
+  private Bitmap createRect(int color, int width, int height, Bitmap.Config config) {
+    final Bitmap result = Bitmap.createBitmap(width, height, config);
+    Canvas canvas = new Canvas(result);
+    canvas.drawColor(color);
+    return result;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
new file mode 100644
index 000000000..c0dcb6e94
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
@@ -0,0 +1,195 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.ColorSpace;
+import android.graphics.ColorSpace.Named;
+import android.os.Build;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class WideGamutTest {
+  @Rule public final TestRule tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = ApplicationProvider.getApplicationContext();
+
+  @Before
+  public void setUp() {
+    assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+  }
+
+  @Test
+  public void load_withWideGamutImage_returnsWideGamutBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context).asBitmap().load(ResourceIds.raw.webkit_logo_p3).submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+  }
+
+  @Test
+  public void load_withWideGamutImage_bitmapInPoolWithSizeAndConfig_usesBitmapFromPool() {
+    int bitmapDimension = 1000;
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setBitmapPool(new LruBitmapPool(bitmapDimension * bitmapDimension * 8 * 4)));
+    Bitmap expected = Bitmap.createBitmap(bitmapDimension, bitmapDimension, Bitmap.Config.RGBA_F16);
+
+    Glide.get(context).getBitmapPool().put(expected);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context).asBitmap().load(ResourceIds.raw.webkit_logo_p3).submit());
+    assertThat(bitmap).isSameInstanceAs(expected);
+  }
+
+  // TODO: Even with hardware allowed, we get a wide F16. Attempting to decode the resource with
+  // preferred config set to hardware fails with:
+  // "D/skia    (10312): --- Failed to allocate a hardware bitmap"
+  @Test
+  public void load_withWideGamutImage_hardwareAllowed_returnsDecodedBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .set(Downsampler.ALLOW_HARDWARE_CONFIG, true)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withEncodedPngWideGamutImage_decodesWideGamut() {
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asPng(toCompress);
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+  }
+
+  @Test
+  public void load_withEncodedJpegWideGamutImage_decodesArgb8888() {
+    // TODO(b/71430152): Figure out whether or not this is supposed to pass in API 26 and fail in
+    // API 27.
+    assumeTrue(Build.VERSION.SDK_INT != Build.VERSION_CODES.O_MR1);
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asJpeg(toCompress);
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void load_withEncodedWebpWideGamutImage_decodesArgb8888() {
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asWebp(toCompress);
+
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void load_withSmallerWideGamutInPool_decodesBitmap() {
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    Bitmap toPut = Bitmap.createBitmap(300, 298, Config.RGBA_F16);
+    bitmapPool.put(toPut);
+    // Add a second Bitmap to account for the InputStream decode.
+    bitmapPool.put(Bitmap.createBitmap(toPut));
+
+    Bitmap wideGamut = Bitmap.createBitmap(300, 300, Config.RGBA_F16);
+    byte[] data = asPng(wideGamut);
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void circleCrop_withWideGamutBitmap_producesWideGamutBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);
+    byte[] data = asPng(bitmap);
+
+    Bitmap result =
+        concurrency.get(GlideApp.with(context).asBitmap().load(data).circleCrop().submit());
+    assertThat(result).isNotNull();
+    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
+  }
+
+  @Test
+  public void roundedCorners_withWideGamutBitmap_producesWideGamutBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);
+    byte[] data = asPng(bitmap);
+
+    Bitmap result =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(data)
+                .transform(new RoundedCorners(/*roundingRadius=*/ 10))
+                .submit());
+    assertThat(result).isNotNull();
+    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
+  }
+
+  @Test
+  public void loadWideGamutImage_withArgb888OfSufficientSizeInPool_usesArgb8888Bitmap() {
+    Bitmap wideGamut = Bitmap.createBitmap(100, 50, Bitmap.Config.RGBA_F16);
+    byte[] data = asPng(wideGamut);
+
+    Bitmap argb8888 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setBitmapPool(new LruBitmapPool(wideGamut.getAllocationByteCount() * 5)));
+    Glide.get(context).getBitmapPool().put(argb8888);
+
+    Bitmap result = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
+
+    assertThat(result).isSameInstanceAs(argb8888);
+  }
+
+  private static byte[] asJpeg(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.JPEG);
+  }
+
+  private static byte[] asPng(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.PNG);
+  }
+
+  private static byte[] asWebp(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.WEBP);
+  }
+
+  private static byte[] toByteArray(Bitmap bitmap, CompressFormat format) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    assertThat(bitmap.compress(format, 100, os)).isTrue();
+    return os.toByteArray();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..ab35c4e64
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,110 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/** Creates mock {@link GlideExecutor}s. */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /** @deprecated Use {@link #newMainThreadExecutor} instead. */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder().detectNetwork().penaltyDeath().build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(
+          new Runnable() {
+            @Override
+            public void run() {
+              StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+              StrictMode.setThreadPolicy(THREAD_POLICY);
+              try {
+                command.run();
+              } finally {
+                StrictMode.setThreadPolicy(oldPolicy);
+              }
+            }
+          });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
index 1447ed9bd..463dd6a87 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
@@ -17,19 +17,28 @@
 import android.graphics.Bitmap.Config;
 import android.os.Build;
 import android.os.Build.VERSION_CODES;
-import android.support.annotation.Nullable;
-import android.support.test.runner.AndroidJUnit4;
 import android.util.DisplayMetrics;
+import androidx.annotation.Nullable;
+import androidx.exifinterface.media.ExifInterface;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.util.Preconditions;
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -39,7 +48,7 @@
 /**
  * Runs tests to make sure that DownsampleStrategy provides the output we expect.
  *
- * WEBP at and above N rounds. Webp below N floors. PNG always floors. JPEG always rounds.
+ * <p>WEBP at and above N rounds. Webp below N floors. PNG always floors. JPEG always rounds.
  */
 @RunWith(AndroidJUnit4.class)
 @SuppressWarnings("VisibleForTests")
@@ -48,82 +57,65 @@
   @Test
   public void calculateScaling_withAtMost() throws IOException {
     new Tester(DownsampleStrategy.AT_MOST)
+        // See #3673
+        .setTargetDimensions(1977, 2636)
+        .givenImageWithDimensionsOf(3024, 4032, onAllApisAndAllFormatsExpect(1512, 2016))
         .setTargetDimensions(100, 100)
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(75, 75))
-        .givenImageWithDimensionsOf(799, 100,
+        .givenImageWithDimensionsOf(
+            799,
+            100,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(100, 13),
-                    formats(PNG)
-                        .expect(99, 12)),
+                .with(formats(JPEG, WEBP).expect(100, 13), formats(PNG).expect(99, 12)),
             below(VERSION_CODES.N)
-                .with(
-                    formats(JPEG)
-                        .expect(100, 13),
-                    formats(PNG, WEBP)
-                        .expect(99, 12)))
-        .givenImageWithDimensionsOf(800, 100,
+                .with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(99, 12)))
+        .givenImageWithDimensionsOf(
+            800,
+            100,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(100, 13),
-                    formats(PNG)
-                        .expect(100, 12)),
+                .with(formats(JPEG, WEBP).expect(100, 13), formats(PNG).expect(100, 12)),
             below(VERSION_CODES.N)
-                .with(
-                    formats(JPEG)
-                        .expect(100, 13),
-                    formats(PNG, WEBP)
-                        .expect(100, 12)))
+                .with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(100, 12)))
         .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(50, 6))
-        .givenImageWithDimensionsOf(100, 800,
+        .givenImageWithDimensionsOf(
+            100,
+            800,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(13, 100),
-                    formats(PNG)
-                        .expect(12, 100)),
+                .with(formats(JPEG, WEBP).expect(13, 100), formats(PNG).expect(12, 100)),
             below(VERSION_CODES.N)
+                .with(formats(JPEG).expect(13, 100), formats(PNG, WEBP).expect(12, 100)))
+        .givenImageWithDimensionsOf(
+            801,
+            100,
+            below(KITKAT)
                 .with(
-                    formats(JPEG)
-                        .expect(13, 100),
-                    formats(PNG, WEBP)
-                        .expect(12, 100)))
+                    // JPEG is correct because CENTER_INSIDE wants to give a subsequent
+                    // transformation an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, CENTER_INSIDE can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a subsequent transformation will
+                    // be called.
+                    formats(JPEG).expect(50, 6), formats(PNG, WEBP).expect(50, 6)))
         .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
         // This set of examples demonstrate that webp uses round on N+ and floor < N.
         .setTargetDimensions(13, 13)
-        .givenSquareImageWithDimensionOf(99,
+        .givenSquareImageWithDimensionOf(
+            99,
             atAndAbove(KITKAT)
                 .with(
                     // 99 / 8.0 = 12.375. ceil(12.375) = 13. round(12.375) = 12. floor(12.375) = 12.
-                    formats(JPEG)
-                        .expect(13, 13),
-                    formats(PNG, WEBP)
-                        .expect(12, 12)),
-            below(KITKAT)
-                .with(
-                    formats(JPEG)
-                        .expect(13, 13),
-                    formats(PNG, WEBP)
-                        .expect(12, 12)))
-        .givenSquareImageWithDimensionOf(100,
+                    formats(JPEG).expect(13, 13), formats(PNG, WEBP).expect(12, 12)),
+            below(KITKAT).with(formats(JPEG).expect(13, 13), formats(PNG, WEBP).expect(12, 12)))
+        .givenSquareImageWithDimensionOf(
+            100,
             atAndAbove(VERSION_CODES.N)
                 .with(
                     // 100 / 8.0 = 12.5. ceil(12.5) = 13. round(12.5) = 13. floor(12.5) = 12.
-                    formats(JPEG, WEBP)
-                        .expect(13, 13),
-                    formats(PNG)
-                        .expect(12, 12)),
+                    formats(JPEG, WEBP).expect(13, 13), formats(PNG).expect(12, 12)),
             below(VERSION_CODES.N)
-                .with(
-                    formats(JPEG)
-                        .expect(13, 13),
-                    formats(PNG, WEBP)
-                        .expect(12, 12)))
+                .with(formats(JPEG).expect(13, 13), formats(PNG, WEBP).expect(12, 12)))
         // Upscaling
         .setTargetDimensions(500, 500)
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
@@ -135,6 +127,9 @@ public void calculateScaling_withAtMost() throws IOException {
   @Test
   public void calculateScaling_withAtLeast() throws IOException {
     new Tester(DownsampleStrategy.AT_LEAST)
+        // See #3673
+        .setTargetDimensions(1977, 2636)
+        .givenImageWithDimensionsOf(3024, 4032, onAllApisAndAllFormatsExpect(3024, 4032))
         .setTargetDimensions(100, 100)
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
@@ -155,36 +150,38 @@ public void calculateScaling_withAtLeast() throws IOException {
   @Test
   public void calculateScaling_withCenterInside() throws IOException {
     new Tester(DownsampleStrategy.CENTER_INSIDE)
+        // See #3673
+        .setTargetDimensions(1977, 2636)
+        .givenImageWithDimensionsOf(
+            3024,
+            4032,
+            atAndAbove(KITKAT).with(allFormats().expect(1977, 2636)),
+            below(KITKAT).with(allFormats().expect(3024, 4032)))
         .setTargetDimensions(100, 100)
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
-        .givenImageWithDimensionsOf(300, 300,
+        .givenImageWithDimensionsOf(
+            300,
+            300,
             atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
             below(KITKAT).with(allFormats().expect(150, 150)))
-        .givenImageWithDimensionsOf(799, 100,
+        .givenImageWithDimensionsOf(
+            799,
+            100,
             atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
-            below(KITKAT)
-                .with(
-                    formats(JPEG)
-                        .expect(200, 25),
-                    formats(PNG, WEBP)
-                        .expect(199, 25)))
-        .givenImageWithDimensionsOf(800, 100,
+            below(KITKAT).with(formats(JPEG).expect(200, 25), formats(PNG, WEBP).expect(199, 25)))
+        .givenImageWithDimensionsOf(
+            800,
+            100,
             atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
-            below(KITKAT).with(allFormats().expect(200, 25)))
-        .givenImageWithDimensionsOf(801, 100,
+            below(KITKAT).with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(100, 12)))
+        .givenImageWithDimensionsOf(
+            801,
+            100,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(100, 13),
-                    formats(PNG)
-                        .expect(100, 12)),
+                .with(formats(JPEG, WEBP).expect(100, 13), formats(PNG).expect(100, 12)),
             apis(KITKAT, VERSION_CODES.M)
-              .with(
-                  formats(JPEG)
-                      .expect(100, 13),
-                  formats(PNG, WEBP)
-                      .expect(100, 12)),
+                .with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(100, 12)),
             below(KITKAT)
                 .with(
                     // JPEG is correct because CENTER_INSIDE wants to give a subsequent
@@ -192,16 +189,17 @@ public void calculateScaling_withCenterInside() throws IOException {
                     // Api > VERSION_CODES.KITKAT, CENTER_INSIDE can do the transformation itself.
                     // On < VERSION_CODES.KITKAT, it has to assume a subsequent transformation will
                     // be called.
-                    formats(JPEG)
-                        .expect(101, 13),
-                    formats(PNG, WEBP)
-                        .expect(100, 12)))
-        .givenImageWithDimensionsOf(100, 800,
+                    formats(JPEG).expect(101, 13), formats(PNG, WEBP).expect(100, 12)))
+        .givenImageWithDimensionsOf(
+            100,
+            800,
             atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
-            below(KITKAT).with(allFormats().expect(25, 200)))
+            below(KITKAT).with(formats(JPEG).expect(13, 100), formats(PNG, WEBP).expect(12, 100)))
         .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
         .setTargetDimensions(897, 897)
-        .givenImageWithDimensionsOf(2208, 1520,
+        .givenImageWithDimensionsOf(
+            2208,
+            1520,
             atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
             below(KITKAT).with(allFormats().expect(1104, 760)))
         // Upscaling
@@ -215,29 +213,44 @@ public void calculateScaling_withCenterInside() throws IOException {
   @Test
   public void calculateScaling_withCenterOutside() throws IOException {
     new Tester(DownsampleStrategy.CENTER_OUTSIDE)
+        // See #3673
+        .setTargetDimensions(1977, 2636)
+        .givenImageWithDimensionsOf(
+            3024,
+            4032,
+            atAndAbove(KITKAT).with(allFormats().expect(1977, 2636)),
+            below(KITKAT).with(allFormats().expect(3024, 4032)))
         .setTargetDimensions(100, 100)
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
-        .givenImageWithDimensionsOf(300, 300,
+        .givenImageWithDimensionsOf(
+            300,
+            300,
             atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
             below(KITKAT).with(allFormats().expect(150, 150)))
         .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
         .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
         .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
         .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
-        .givenImageWithDimensionsOf(87, 78,
+        .givenImageWithDimensionsOf(
+            87,
+            78,
             atAndAbove(KITKAT).with(allFormats().expect(112, 100)),
             below(KITKAT).with(allFormats().expect(87, 78)))
         // Upscaling
         .setTargetDimensions(500, 500)
-        .givenSquareImageWithDimensionOf(200,
+        .givenSquareImageWithDimensionOf(
+            200,
             atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
             below(KITKAT).with(allFormats().expect(200, 200)))
-        .givenSquareImageWithDimensionOf(450,
+        .givenSquareImageWithDimensionOf(
+            450,
             atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
             below(KITKAT).with(allFormats().expect(450, 450)))
-        .givenImageWithDimensionsOf(200, 450,
+        .givenImageWithDimensionsOf(
+            200,
+            450,
             atAndAbove(KITKAT).with(allFormats().expect(500, 1125)),
             below(KITKAT).with(allFormats().expect(200, 450)))
         .run();
@@ -246,6 +259,9 @@ public void calculateScaling_withCenterOutside() throws IOException {
   @Test
   public void calculateScaling_withNone() throws IOException {
     new Tester(DownsampleStrategy.NONE)
+        // See #3673
+        .setTargetDimensions(1977, 2636)
+        .givenImageWithDimensionsOf(3024, 4032, onAllApisAndAllFormatsExpect(3024, 4032))
         .setTargetDimensions(100, 100)
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
@@ -266,37 +282,39 @@ public void calculateScaling_withNone() throws IOException {
   @Test
   public void calculateScaling_withFitCenter() throws IOException {
     new Tester(DownsampleStrategy.FIT_CENTER)
+        // See #3673
+        .setTargetDimensions(1977, 2636)
+        .givenImageWithDimensionsOf(
+            3024,
+            4032,
+            atAndAbove(KITKAT).with(allFormats().expect(1977, 2636)),
+            below(KITKAT).with(allFormats().expect(3024, 4032)))
         .setTargetDimensions(100, 100)
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
-        .givenImageWithDimensionsOf(300, 300,
+        .givenImageWithDimensionsOf(
+            300,
+            300,
             atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
             below(KITKAT).with(allFormats().expect(150, 150)))
-        .givenImageWithDimensionsOf(799, 100,
+        .givenImageWithDimensionsOf(
+            799,
+            100,
             atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
-            below(KITKAT)
-                .with(
-                    formats(JPEG)
-                        .expect(200, 25),
-                    formats(PNG, WEBP)
-                        .expect(199, 25)))
-        .givenImageWithDimensionsOf(800, 100,
+            below(KITKAT).with(formats(JPEG).expect(200, 25), formats(PNG, WEBP).expect(199, 25)))
+        .givenImageWithDimensionsOf(
+            800,
+            100,
             atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
-            below(KITKAT).with(allFormats().expect(200, 25)))
-        .givenImageWithDimensionsOf(801, 100,
+            below(KITKAT).with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(100, 12)))
+        .givenImageWithDimensionsOf(
+            801,
+            100,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(100, 13),
-                    formats(PNG)
-                        .expect(100, 12)),
+                .with(formats(JPEG, WEBP).expect(100, 13), formats(PNG).expect(100, 12)),
             apis(KITKAT, VERSION_CODES.M)
-                .with(
-                    formats(JPEG)
-                        .expect(100, 13),
-                    formats(PNG, WEBP)
-                        .expect(100, 12)),
+                .with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(100, 12)),
             below(KITKAT)
                 .with(
                     // JPEG is correct because FIT_CENTER wants to give a subsequent transformation
@@ -304,60 +322,68 @@ public void calculateScaling_withFitCenter() throws IOException {
                     // Api > VERSION_CODES.KITKAT, FIT_CENTER can do the transformation itself.
                     // On < VERSION_CODES.KITKAT, it has to assume a transformation will be run
                     // after it that will fix the rounding error.
-                    formats(JPEG)
-                        .expect(101, 13),
-                    formats(PNG, WEBP)
-                        .expect(100, 12)))
-        .givenImageWithDimensionsOf(100, 800,
+                    formats(JPEG).expect(101, 13), formats(PNG, WEBP).expect(100, 12)))
+        .givenImageWithDimensionsOf(
+            100,
+            800,
             atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
-            below(KITKAT).with(allFormats().expect(25, 200)))
-        .givenImageWithDimensionsOf(87, 78,
+            below(KITKAT).with(formats(JPEG).expect(13, 100), formats(PNG, WEBP).expect(12, 100)))
+        .givenImageWithDimensionsOf(
+            87,
+            78,
             atAndAbove(KITKAT).with(allFormats().expect(100, 90)),
             below(KITKAT).with(allFormats().expect(87, 78)))
         .setTargetDimensions(897, 897)
-        .givenImageWithDimensionsOf(2208, 1520,
+        .givenImageWithDimensionsOf(
+            2208,
+            1520,
             atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
             below(KITKAT).with(allFormats().expect(1104, 760)))
         .setTargetDimensions(270, 270)
         // This set of larger image examples exercises sample sizes > 8. Android' scaling logic
         // varies for jpegs.
-        .givenImageWithDimensionsOf(9014, 1638,
+        .givenImageWithDimensionsOf(
+            9014,
+            1638,
             // 15 and 16 will OOM so don't run them.
             atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
             apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
                 .with(allFormats().expect(281, 51)))
-        .givenImageWithDimensionsOf(1638, 9014,
+        .givenImageWithDimensionsOf(
+            1638,
+            9014,
             // 15 and 16 will OOM so don't run them.
             atAndAbove(KITKAT).with(allFormats().expect(49, 270)),
             apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
                 .with(allFormats().expect(51, 281)))
-        .givenImageWithDimensionsOf(1638, 1638,
+        .givenImageWithDimensionsOf(
+            1638,
+            1638,
             atAndAbove(KITKAT).with(allFormats().expect(270, 270)),
-            below(KITKAT)
-                .with(
-                    formats(JPEG)
-                        .expect(410, 410),
-                    formats(PNG, WEBP)
-                        .expect(409, 409)))
-        .givenImageWithDimensionsOf(4507, 819,
+            below(KITKAT).with(formats(JPEG).expect(410, 410), formats(PNG, WEBP).expect(409, 409)))
+        .givenImageWithDimensionsOf(
+            4507,
+            819,
             atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
-            below(KITKAT).with(
-                formats(JPEG)
-                    .expect(282, 51),
-                formats(PNG, WEBP)
-                    .expect(281, 51)))
-        .givenImageWithDimensionsOf(4503, 819,
+            below(KITKAT).with(formats(JPEG).expect(282, 51), formats(PNG, WEBP).expect(281, 51)))
+        .givenImageWithDimensionsOf(
+            4503,
+            819,
             atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
             below(KITKAT).with(allFormats().expect(281, 51)))
         // Upscaling
         .setTargetDimensions(500, 500)
-        .givenSquareImageWithDimensionOf(200,
+        .givenSquareImageWithDimensionOf(
+            200,
             atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
             below(KITKAT).with(allFormats().expect(200, 200)))
-        .givenSquareImageWithDimensionOf(450,
+        .givenSquareImageWithDimensionOf(
+            450,
             atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
             below(KITKAT).with(allFormats().expect(450, 450)))
-        .givenImageWithDimensionsOf(200, 450,
+        .givenImageWithDimensionsOf(
+            200,
+            450,
             atAndAbove(KITKAT).with(allFormats().expect(222, 500)),
             below(KITKAT).with(allFormats().expect(200, 450)))
         .run();
@@ -371,23 +397,59 @@ private static String runScaleTest(
       int initialHeight,
       int targetWidth,
       int targetHeight,
+      int exifOrientation,
       DownsampleStrategy strategy,
       int expectedWidth,
-      int expectedHeight) throws IOException {
+      int expectedHeight)
+      throws IOException {
     Downsampler downsampler = buildDownsampler();
 
-    InputStream is = openBitmapStream(format, initialWidth, initialHeight);
-    Options options = new Options()
-        .set(Downsampler.DOWNSAMPLE_STRATEGY, strategy);
-    Bitmap bitmap = downsampler.decode(is, targetWidth, targetHeight, options).get();
+    InputStream is = openBitmapStream(format, initialWidth, initialHeight, exifOrientation);
+    Options options = new Options().set(DownsampleStrategy.OPTION, strategy);
+    Bitmap bitmap;
+    try {
+      bitmap = downsampler.decode(is, targetWidth, targetHeight, options).get();
+    } catch (OutOfMemoryError e) {
+      return "API: "
+          + Build.VERSION.SDK_INT
+          + ", os: "
+          + Build.VERSION.RELEASE
+          + ", format: "
+          + format
+          + ", strategy: "
+          + strategy
+          + ", orientation: "
+          + exifOrientation
+          + " -"
+          + " Initial "
+          + readableDimens(initialWidth, initialHeight)
+          + " Target "
+          + readableDimens(targetWidth, targetHeight)
+          + " Expected "
+          + readableDimens(expectedWidth, expectedHeight)
+          + " but threw OutOfMemoryError";
+    }
     try {
       if (bitmap.getWidth() != expectedWidth || bitmap.getHeight() != expectedHeight) {
-        return "API: " + Build.VERSION.SDK_INT + ", os: " + Build.VERSION.RELEASE
-            + ", format: " + format + ", strategy: " + strategy + " -"
-            + " Initial " + readableDimens(initialWidth, initialHeight)
-            + " Target " + readableDimens(targetWidth, targetHeight)
-            + " Expected " + readableDimens(expectedWidth, expectedHeight)
-            + ", but Received " + readableDimens(bitmap.getWidth(), bitmap.getHeight());
+        return "API: "
+            + Build.VERSION.SDK_INT
+            + ", os: "
+            + Build.VERSION.RELEASE
+            + ", format: "
+            + format
+            + ", strategy: "
+            + strategy
+            + ", orientation: "
+            + exifOrientation
+            + " -"
+            + " Initial "
+            + readableDimens(initialWidth, initialHeight)
+            + " Target "
+            + readableDimens(targetWidth, targetHeight)
+            + " Expected "
+            + readableDimens(expectedWidth, expectedHeight)
+            + ", but Received "
+            + readableDimens(bitmap.getWidth(), bitmap.getHeight());
       }
     } finally {
       bitmap.recycle();
@@ -410,7 +472,67 @@ private static Downsampler buildDownsampler() {
     return new Downsampler(parsers, displayMetrics, bitmapPool, arrayPool);
   }
 
-  private static InputStream openBitmapStream(CompressFormat format, int width, int height) {
+  private static InputStream openBitmapStream(
+      CompressFormat format, int width, int height, int exifOrientation) {
+    Preconditions.checkArgument(
+        format == CompressFormat.JPEG || exifOrientation == ExifInterface.ORIENTATION_UNDEFINED,
+        "Can only orient JPEGs, but asked for orientation: "
+            + exifOrientation
+            + " with format: "
+            + format);
+
+    // TODO: support orientations for formats other than JPEG.
+    if (format == CompressFormat.JPEG) {
+      return openFileStream(width, height, exifOrientation);
+    } else {
+      return openInMemoryStream(format, width, height);
+    }
+  }
+
+  private static InputStream openFileStream(int width, int height, int exifOrientation) {
+    int rotationDegrees = TransformationUtils.getExifOrientationDegrees(exifOrientation);
+    if (rotationDegrees == 270 || rotationDegrees == 90) {
+      int temp = width;
+      width = height;
+      height = temp;
+    }
+
+    Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
+
+    OutputStream os = null;
+    try {
+      File tempFile =
+          File.createTempFile(
+              "ds-" + width + "-" + height + "-" + exifOrientation,
+              ".jpeg",
+              ApplicationProvider.getApplicationContext().getCacheDir());
+      os = new BufferedOutputStream(new FileOutputStream(tempFile));
+      bitmap.compress(CompressFormat.JPEG, /*quality=*/ 100, os);
+      bitmap.recycle();
+      os.close();
+
+      ExifInterface exifInterface = new ExifInterface(tempFile.getAbsolutePath());
+      exifInterface.setAttribute(ExifInterface.TAG_ORIENTATION, String.valueOf(exifOrientation));
+      exifInterface.saveAttributes();
+
+      InputStream result = new BufferedInputStream(new FileInputStream(tempFile));
+      if (!tempFile.delete()) {
+        throw new IllegalStateException("Failed to delete: " + tempFile);
+      }
+      return result;
+    } catch (IOException e) {
+      throw new IllegalStateException(e);
+    } finally {
+      if (os != null) {
+        try {
+          os.close();
+        } catch (IOException e) {
+        }
+      }
+    }
+  }
+
+  private static InputStream openInMemoryStream(CompressFormat format, int width, int height) {
     Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
     ByteArrayOutputStream os = new ByteArrayOutputStream();
     bitmap.compress(format, 100 /*quality*/, os);
@@ -436,12 +558,11 @@ Tester setTargetDimensions(int targetWidth, int targetHeight) {
       return this;
     }
 
-    Tester givenSquareImageWithDimensionOf(int dimension, Api... apis) throws IOException {
+    Tester givenSquareImageWithDimensionOf(int dimension, Api... apis) {
       return givenImageWithDimensionsOf(dimension, dimension, apis);
     }
 
-    Tester givenImageWithDimensionsOf(
-        int sourceWidth, int sourceHeight, Api... apis) throws IOException {
+    Tester givenImageWithDimensionsOf(int sourceWidth, int sourceHeight, Api... apis) {
       testCases.add(new TestCase(sourceWidth, sourceHeight, targetWidth, targetHeight, apis));
       return this;
     }
@@ -456,9 +577,9 @@ void run() throws IOException {
         return;
       }
 
-      String failure = "Failing Tests:\n";
+      StringBuilder failure = new StringBuilder("Failing Tests:\n");
       for (String result : results) {
-        failure += result + "\n";
+        failure.append(result).append("\n");
       }
       fail(failure.substring(0, failure.length() - 1));
     }
@@ -478,8 +599,7 @@ void run() throws IOException {
         this.apis = apis;
       }
 
-      List<String> test(DownsampleStrategy strategy)
-          throws IOException {
+      List<String> test(DownsampleStrategy strategy) throws IOException {
         List<String> results = new ArrayList<>();
         for (Api api : apis) {
           results.addAll(api.test(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
@@ -492,7 +612,7 @@ void run() throws IOException {
   static final class Api {
     private final int startVersion;
     private final int stopVersion;
-    private Formats[] formats;
+    private final Formats[] formats;
 
     static Builder apis(int min, int max) {
       return new Builder().min(min).max(max);
@@ -555,7 +675,6 @@ Api with(Formats... formats) {
       for (Formats format : formats) {
         results.addAll(
             format.runTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
-
       }
       return results;
     }
@@ -565,6 +684,20 @@ Api with(Formats... formats) {
     private final int expectedWidth;
     private final int expectedHeight;
     private final CompressFormat[] formats;
+    private static final int[] ALL_EXIF_ORIENTATIONS =
+        new int[] {
+          ExifInterface.ORIENTATION_UNDEFINED,
+          ExifInterface.ORIENTATION_NORMAL,
+          ExifInterface.ORIENTATION_FLIP_HORIZONTAL,
+          ExifInterface.ORIENTATION_ROTATE_180,
+          ExifInterface.ORIENTATION_FLIP_VERTICAL,
+          ExifInterface.ORIENTATION_TRANSPOSE,
+          ExifInterface.ORIENTATION_ROTATE_90,
+          ExifInterface.ORIENTATION_TRANSVERSE,
+          ExifInterface.ORIENTATION_ROTATE_270
+        };
+    private static final int[] UNDEFINED_EXIF_ORIENTATIONS =
+        new int[] {ExifInterface.ORIENTATION_UNDEFINED};
 
     static final class Builder {
       private final CompressFormat[] formats;
@@ -597,20 +730,27 @@ Formats expect(int width, int height) {
         int sourceHeight,
         int targetWidth,
         int targetHeight,
-        DownsampleStrategy strategy) throws IOException {
+        DownsampleStrategy strategy)
+        throws IOException {
       List<String> result = new ArrayList<>();
       for (CompressFormat format : formats) {
-        String testResult = runScaleTest(
-            format,
-            sourceWidth,
-            sourceHeight,
-            targetWidth,
-            targetHeight,
-            strategy,
-            expectedWidth,
-            expectedHeight);
-        if (testResult != null) {
-          result.add(testResult);
+        int[] exifOrientations =
+            format == CompressFormat.JPEG ? ALL_EXIF_ORIENTATIONS : UNDEFINED_EXIF_ORIENTATIONS;
+        for (int exifOrientation : exifOrientations) {
+          String testResult =
+              runScaleTest(
+                  format,
+                  sourceWidth,
+                  sourceHeight,
+                  targetWidth,
+                  targetHeight,
+                  exifOrientation,
+                  strategy,
+                  expectedWidth,
+                  expectedHeight);
+          if (testResult != null) {
+            result.add(testResult);
+          }
         }
       }
       return result;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
deleted file mode 100644
index 85a97967b..000000000
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-import android.graphics.BitmapFactory;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.test.ResourceIds;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/**
- * Emulator tests for Glide transformation utilities.
- */
-@RunWith(AndroidJUnit4.class)
-public class TransformationUtilsTest {
-  private BitmapPool bitmapPool;
-  private Context context;
-
-  @Before
-  public void setUp() throws Exception {
-    bitmapPool = new BitmapPoolAdapter();
-    context = InstrumentationRegistry.getTargetContext();
-    // TODO: Add Android API specific resources that work > API 16.
-    assumeTrue(Build.VERSION.SDK_INT <= VERSION_CODES.JELLY_BEAN);
-  }
-
-  @Test
-  public void testRoundedCorners() {
-    int width = 20;
-    int height = 30;
-    Bitmap blueRect = createRect(Color.BLUE, width, height, Bitmap.Config.ARGB_8888);
-    Bitmap roundedBlueRect =
-        TransformationUtils.roundedCorners(bitmapPool, blueRect, 5);
-    assertBitmapMatches(ResourceIds.raw.blue_rect_rounded, roundedBlueRect);
-  }
-
-  @Test
-  public void testRoundedCorners_usePool() {
-    int width = 20;
-    int height = 30;
-
-    Bitmap blueRect = createRect(Color.BLUE, width, height, Bitmap.Config.ARGB_8888);
-    Bitmap redRect = createRect(Color.RED, width, height, Bitmap.Config.ARGB_8888);
-    BitmapPool mockBitmapPool = mock(BitmapPool.class);
-    when(mockBitmapPool.get(width, height, Config.ARGB_8888)).thenReturn(redRect);
-
-    Bitmap roundedBlueRect =
-        TransformationUtils.roundedCorners(mockBitmapPool, blueRect, 5);
-    assertBitmapMatches(ResourceIds.raw.blue_rect_rounded, roundedBlueRect);
-    assertThat(roundedBlueRect).isEqualTo(redRect);
-  }
-
-  @Test
-  public void testRoundedCorners_overRounded() {
-    int width = 40;
-    int height = 20;
-    Bitmap blueRect = createRect(Color.BLUE, width, height, Bitmap.Config.RGB_565);
-    Bitmap roundedBlueRect =
-        TransformationUtils.roundedCorners(bitmapPool, blueRect, 20);
-    assertBitmapMatches(ResourceIds.raw.blue_rect_over_rounded, roundedBlueRect);
-  }
-
-  private Bitmap createRect(int color, int width, int height, Bitmap.Config config) {
-    final Bitmap result = Bitmap.createBitmap(width, height, config);
-    Canvas canvas = new Canvas(result);
-    canvas.drawColor(color);
-    return result;
-  }
-
-  private void assertBitmapMatches(int resId, Bitmap actual) {
-    Resources res = context.getResources();
-    // Avoid default density scaling when decoding the expected Bitmap.
-    BitmapFactory.Options options = new BitmapFactory.Options();
-    options.inScaled = false;
-    Bitmap expected = BitmapFactory.decodeResource(res, resId, options);
-    assertPixelDataMatches(expected, actual);
-  }
-
-  /**
-   * TODO(user): Pull this out into a helper library and add tests for it. Would also be good
-   * to get a tool for updating expected bitmaps on functionality changes and new tests.
-   */
-  private void assertPixelDataMatches(Bitmap expected, Bitmap actual) {
-    assertEquals(expected.getWidth(), actual.getWidth());
-    assertEquals(expected.getHeight(), actual.getHeight());
-
-    for (int y = 0; y < expected.getHeight(); y++) {
-      for (int x = 0; x < expected.getWidth(); x++) {
-        assertEquals(expected.getPixel(x, y), actual.getPixel(x, y));
-      }
-    }
-  }
-}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
new file mode 100644
index 000000000..2c4559809
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -0,0 +1,203 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.Manifest.permission;
+import android.content.Context;
+import android.os.Build;
+import android.view.View;
+import android.view.WindowManager;
+import android.view.WindowManager.LayoutParams;
+import android.widget.ImageView;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.rule.GrantPermissionRule;
+import com.bumptech.glide.load.resource.gif.GifDrawable.GifState;
+import com.bumptech.glide.load.resource.gif.GifFrameLoader.OnEveryFrameListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Preconditions;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class GifDrawableTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Rule public final GrantPermissionRule grantPermissionRule;
+  private final ConcurrencyHelper concurrencyHelper = new ConcurrencyHelper();
+
+  {
+    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
+      grantPermissionRule = GrantPermissionRule.grant(permission.SYSTEM_ALERT_WINDOW);
+    } else {
+      grantPermissionRule = GrantPermissionRule.grant();
+    }
+  }
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+  }
+
+  @Test
+  public void loadGif_withInterlacedTransparentGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.interlaced_transparent_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withInterlacedTransparentGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.interlaced_transparent_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withTransparentGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context).asGif().load(ResourceIds.raw.transparent_gif).submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withTransparentGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context).asGif().load(ResourceIds.raw.transparent_gif).submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context).asGif().load(ResourceIds.raw.opaque_gif).submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context).asGif().load(ResourceIds.raw.opaque_gif).submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueInterlacedGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context).asGif().load(ResourceIds.raw.opaque_interlaced_gif).submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueInterlacedGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_interlaced_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_intoImageView_afterStop_restartsGif()
+      throws ExecutionException, InterruptedException {
+    // Mimic the state the Drawable can get into if it was loaded into a View previously and stopped
+    // so that it ended up with a pending frame that finished after the stop call.
+    final GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.dl_world_anim)
+                .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL));
+
+    final CountDownLatch waitForGifFrame = new CountDownLatch(1);
+    // Starting/Stopping loads in GIFs must happen on the main thread.
+    concurrencyHelper.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            // Make sure a frame is loaded while the drawable is stopped.
+            GifState gifState =
+                (GifState) Preconditions.checkNotNull(gifDrawable.getConstantState());
+            gifState.frameLoader.setOnEveryFrameReadyListener(
+                new OnEveryFrameListener() {
+                  @Override
+                  public void onFrameReady() {
+                    waitForGifFrame.countDown();
+                  }
+                });
+            gifDrawable.start();
+            gifDrawable.stop();
+          }
+        });
+    ConcurrencyHelper.waitOnLatch(waitForGifFrame);
+
+    // Load the Drawable with the pending frame into a new View and make sure it ends up in the
+    // running state.
+    final ImageView imageView = new ImageView(context);
+    concurrencyHelper.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            addViewToWindow(imageView);
+          }
+        });
+
+    concurrencyHelper.loadOnMainThread(
+        GlideApp.with(context).load(gifDrawable).override(Target.SIZE_ORIGINAL), imageView);
+
+    GifDrawable drawableFromView = (GifDrawable) imageView.getDrawable();
+    assertThat(drawableFromView.isRunning()).isTrue();
+
+    drawableFromView.stop();
+    gifDrawable.stop();
+  }
+
+  @SuppressWarnings("deprecation")
+  private void addViewToWindow(View view) {
+    WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();
+    layoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
+    layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
+    layoutParams.type =
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
+            ? LayoutParams.TYPE_APPLICATION_OVERLAY
+            : Build.VERSION.SDK_INT == Build.VERSION_CODES.M
+                ? LayoutParams.TYPE_TOAST
+                : LayoutParams.TYPE_SYSTEM_ALERT;
+    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    Preconditions.checkNotNull(windowManager).addView(view, layoutParams);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
new file mode 100644
index 000000000..727984936
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
@@ -0,0 +1,191 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import android.os.Environment;
+import androidx.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.RequestBuilder;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.concurrent.ExecutionException;
+import org.junit.rules.TestName;
+
+/**
+ * Checks for regressions for a given Glide load by comparing the result of a load to a previously
+ * saved Bitmap.
+ *
+ * <p>Can be used to generate or re-generate expected {@link Bitmap}s by placing a file named
+ * "regenerate" in /sdcard/DCIM/test_files. The apks containing this tester will need to have {@link
+ * android.Manifest.permission#WRITE_EXTERNAL_STORAGE}. Resources can be split by apk by adding
+ * {@link SplitBySdk} to test methods or classes. If {@link SplitBySdk} is added to both a test
+ * class and a particular method, the values from the method will be used.
+ *
+ * <p>This class only handles exactly one Bitmap comparison per test method because the resource
+ * names it expects and generates are based on the method name.
+ */
+public final class BitmapRegressionTester {
+  private static final String RESOURCE_TYPE = "raw";
+  private static final String EXTENSION = ".png";
+  private static final String REGENERATE_SIGNAL_FILE_NAME = "regenerate";
+  private static final String GENERATED_FILES_DIR = "test_files";
+  private static final String SEPARATOR = "_";
+
+  private final Class<?> testClass;
+  private final TestName testName;
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  public BitmapRegressionTester(Class<?> testClass, TestName testName) {
+    this.testClass = testClass;
+    this.testName = testName;
+
+    if (testClass.getAnnotation(RegressionTest.class) == null) {
+      throw new IllegalArgumentException(
+          testClass + " must be annotated with " + RegressionTest.class);
+    }
+  }
+
+  public Bitmap test(RequestBuilder<Bitmap> request)
+      throws ExecutionException, InterruptedException {
+    Bitmap result = request.submit().get();
+    if (writeNewExpected()) {
+      writeBitmap(result);
+    }
+    Bitmap expected = decodeExpected();
+    BitmapSubject.assertThat(result).sameAs(expected);
+    return result;
+  }
+
+  private String getResourceName() {
+    return getClassNameString()
+        + SEPARATOR
+        + testName.getMethodName().toLowerCase()
+        + getSdkIntString()
+        + getCpuString();
+  }
+
+  private String getClassNameString() {
+    StringBuilder result = new StringBuilder();
+    for (char c : testClass.getSimpleName().toCharArray()) {
+      if (Character.isUpperCase(c)) {
+        result.append(Character.toLowerCase(c));
+      }
+    }
+    return result.toString();
+  }
+
+  @Nullable
+  private SplitBySdk getSplitBySdkValues() {
+    SplitBySdk result;
+    try {
+      Method method =
+          testClass.getMethod(testName.getMethodName(), /*parameterTypes=*/ (Class[]) null);
+      result = method.getAnnotation(SplitBySdk.class);
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException(e);
+    }
+
+    if (result == null) {
+      result = testClass.getAnnotation(SplitBySdk.class);
+    }
+    return result;
+  }
+
+  @SuppressWarnings("deprecation")
+  private String getCpuString() {
+    return splitByCpu() ? SEPARATOR + Build.CPU_ABI.replace("-", "_") : "";
+  }
+
+  private boolean splitByCpu() {
+    return testClass.getAnnotation(SplitByCpu.class) != null;
+  }
+
+  private String getSdkIntString() {
+    SplitBySdk splitBySdk = getSplitBySdkValues();
+    if (splitBySdk == null) {
+      return "";
+    }
+    int targetSdk = -1;
+    int[] values = splitBySdk.value();
+    Arrays.sort(values);
+    for (int value : values) {
+      if (value > Build.VERSION.SDK_INT) {
+        break;
+      }
+      targetSdk = value;
+    }
+
+    if (targetSdk == -1) {
+      return "";
+    }
+
+    return SEPARATOR + targetSdk;
+  }
+
+  private File getTestFilesDir() {
+    File dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);
+    return new File(dir, GENERATED_FILES_DIR);
+  }
+
+  private void writeBitmap(Bitmap bitmap) {
+    File testFilesDir = getTestFilesDir();
+    File subdirectory = new File(testFilesDir, RESOURCE_TYPE);
+    if (!subdirectory.exists() && !subdirectory.mkdirs()) {
+      throw new IllegalArgumentException("Failed to make directory: " + subdirectory);
+    }
+
+    File file = new File(subdirectory, getResourceName() + EXTENSION);
+    if (file.exists() && !file.delete()) {
+      throw new IllegalStateException("Failed to remove existing file: " + file);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(file));
+      bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
+      os.close();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (os != null) {
+        try {
+          os.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+
+  private boolean writeNewExpected() {
+    File testFiles = getTestFilesDir();
+    return new File(testFiles, REGENERATE_SIGNAL_FILE_NAME).exists();
+  }
+
+  private Bitmap decodeExpected() {
+    int resourceId =
+        context
+            .getResources()
+            .getIdentifier(getResourceName(), RESOURCE_TYPE, context.getPackageName());
+    if (resourceId == 0) {
+      throw new IllegalArgumentException(
+          "Failed to find resource for: "
+              + getResourceName()
+              + " with type: "
+              + RESOURCE_TYPE
+              + " and package: "
+              + context.getPackageName());
+    }
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    return BitmapFactory.decodeResource(context.getResources(), resourceId, options);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
new file mode 100644
index 000000000..4759634d1
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
@@ -0,0 +1,122 @@
+package com.bumptech.glide.test;
+
+import static com.google.common.truth.Fact.simpleFact;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.core.content.res.ResourcesCompat;
+import androidx.test.InstrumentationRegistry;
+import com.google.common.truth.FailureMetadata;
+import com.google.common.truth.Subject;
+import com.google.common.truth.Truth;
+
+/** Truth assertions for comparing {@link Bitmap}s. */
+// Test APIs.
+@SuppressWarnings({"WeakerAccess", "unused", "rawtypes", "unchecked"})
+public final class BitmapSubject extends Subject {
+
+  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =
+      new Subject.Factory<BitmapSubject, Bitmap>() {
+        @Override
+        public BitmapSubject createSubject(
+            @NonNull FailureMetadata metadata, @NonNull Bitmap actual) {
+          return new BitmapSubject(metadata, actual);
+        }
+      };
+
+  private final Bitmap actual;
+
+  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {
+    super(failureMetadata, subject);
+    this.actual = subject;
+  }
+
+  public static BitmapSubject assertThat(Drawable drawable) {
+    if (!(drawable instanceof BitmapDrawable)) {
+      throw new IllegalArgumentException("Not a BitmapDrawable: " + drawable);
+    }
+    return assertThat(((BitmapDrawable) drawable).getBitmap());
+  }
+
+  public static BitmapSubject assertThat(Bitmap bitmap) {
+    return Truth.assertAbout(FACTORY).that(bitmap);
+  }
+
+  @Override
+  protected String actualCustomStringRepresentation() {
+    return getDisplayString(actual);
+  }
+
+  private static String getDisplayString(Bitmap bitmap) {
+    return "<"
+        + "["
+        + bitmap.getWidth()
+        + "x"
+        + bitmap.getHeight()
+        + "]"
+        + " "
+        + bitmap.getConfig()
+        + ">";
+  }
+
+  public void sameAs(@DrawableRes int resourceId) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    Drawable drawable =
+        ResourcesCompat.getDrawable(context.getResources(), resourceId, context.getTheme());
+    sameAs(drawable);
+  }
+
+  public void hasDimensions(int expectedWidth, int expectedHeight) {
+    int actualWidth = actual.getWidth();
+    int actualHeight = actual.getHeight();
+    if (expectedWidth != actualWidth && expectedHeight != actualHeight) {
+      failWithActual("expected to have dimensions", expectedWidth + "x" + expectedHeight);
+    } else if (expectedWidth != actualWidth) {
+      failWithActual("expected to have width", expectedWidth);
+    } else if (expectedHeight != actualHeight) {
+      failWithActual("expected to have height", expectedHeight);
+    }
+  }
+
+  public void isMutable() {
+    if (!actual.isMutable()) {
+      failWithActual(simpleFact("expected to be mutable"));
+    }
+  }
+
+  public void isImmutable() {
+    if (actual.isMutable()) {
+      failWithActual(simpleFact("expected to be immutable"));
+    }
+  }
+
+  public void isNotRecycled() {
+    if (actual.isRecycled()) {
+      failWithActual(simpleFact("expected not to be recycled"));
+    }
+  }
+
+  @SuppressWarnings({"unchecked", "ConstantConditions"})
+  public void sameAs(Drawable other) {
+    if (!(other instanceof BitmapDrawable)) {
+      failWithoutActual(simpleFact("The given expected value was not a BitmapDrawable."));
+    }
+    sameAs(((BitmapDrawable) other).getBitmap());
+  }
+
+  public void sameAs(Bitmap other) {
+    if (!actual.sameAs(other)) {
+      failWithActual("expected to be the same as", getDisplayString(other));
+    }
+  }
+
+  public void isNotSameAs(Bitmap other) {
+    if (actual.sameAs(other)) {
+      failWithActual("expected not to be the same as", getDisplayString(other));
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
new file mode 100644
index 000000000..e203e5d77
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.util.Preconditions;
+
+public final class CanonicalBitmap {
+  @Nullable private Bitmap bitmap;
+  @Nullable private Float scaleFactor;
+
+  @NonNull
+  public synchronized Bitmap getBitmap() {
+    if (bitmap == null) {
+      bitmap = decodeBitmap();
+    }
+    return bitmap;
+  }
+
+  public CanonicalBitmap scale(float scaleFactor) {
+    Preconditions.checkArgument(bitmap == null, "Can't set scale factor after decoding image");
+    this.scaleFactor = scaleFactor;
+    return this;
+  }
+
+  public int getWidth() {
+    return getBitmap().getWidth();
+  }
+
+  public int getHeight() {
+    return getBitmap().getHeight();
+  }
+
+  private Bitmap decodeBitmap() {
+    Context context = InstrumentationRegistry.getTargetContext();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    int resourceId = ResourceIds.raw.canonical;
+    Bitmap result = BitmapFactory.decodeResource(context.getResources(), resourceId, options);
+    if (scaleFactor != null) {
+      result =
+          Bitmap.createScaledBitmap(
+              result,
+              (int) (result.getWidth() * scaleFactor),
+              (int) (result.getHeight() * scaleFactor),
+              /*filter=*/ false);
+    }
+    // Make sure the Bitmap is immutable.
+    return result;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
new file mode 100644
index 000000000..ed6b13cf8
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -0,0 +1,334 @@
+package com.bumptech.glide.test;
+
+import android.graphics.drawable.Drawable;
+import android.os.Debug;
+import android.os.Handler;
+import android.os.Looper;
+import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.target.DrawableImageViewTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+/** Helper for running sections of code on the main thread in emulator tests. */
+public class ConcurrencyHelper {
+  private final Handler handler = new Handler(Looper.getMainLooper());
+  private static final long TIMEOUT_SECONDS = 10;
+  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.SECONDS;
+
+  public <T> T get(final Future<T> future) {
+    final AtomicReference<T> reference = new AtomicReference<>();
+    wait(
+        new Waiter() {
+          @Override
+          public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+            try {
+              reference.set(future.get(timeout, timeUnit));
+              return true;
+            } catch (ExecutionException e) {
+              throw new RuntimeException(e.getCause());
+            } catch (TimeoutException e) {
+              return false;
+            }
+          }
+        });
+    return reference.get();
+  }
+
+  public <T> Target<T> wait(FutureTarget<T> future) {
+    get(future);
+    return future;
+  }
+
+  public void loadOnOtherThread(final Runnable runnable) {
+    final AtomicBoolean isDone = new AtomicBoolean();
+    final Thread thread =
+        new Thread(
+            new Runnable() {
+              @Override
+              public void run() {
+                runnable.run();
+                isDone.set(true);
+              }
+            });
+    thread.start();
+
+    wait(
+        new Waiter() {
+          @Override
+          public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+            thread.join(timeUnit.toMillis(timeout));
+            return isDone.get();
+          }
+        });
+  }
+
+  public void loadOnMainThread(final RequestBuilder<Drawable> builder, ImageView imageView) {
+    loadOnMainThread(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  public void clearOnMainThread(final ImageView imageView) {
+    runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.with(InstrumentationRegistry.getTargetContext()).clear(imageView);
+          }
+        });
+  }
+
+  public void loadUntilFirstFinish(final RequestBuilder<Drawable> builder, ImageView imageView) {
+    loadUntilFirstFinish(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  private <T> void loadUntilFirstFinish(final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    callOnMainThread(
+        new Callable<Target<T>>() {
+          @Override
+          public Target<T> call() {
+            builder.into(
+                new Target<T>() {
+                  @Override
+                  public void onStart() {
+                    target.onStart();
+                  }
+
+                  @Override
+                  public void onStop() {
+                    target.onStop();
+                  }
+
+                  @Override
+                  public void onDestroy() {
+                    target.onDestroy();
+                  }
+
+                  @Override
+                  public void onResourceReady(
+                      @NonNull T resource, @Nullable Transition<? super T> transition) {
+                    target.onResourceReady(resource, transition);
+                    latch.countDown();
+                  }
+
+                  @Override
+                  public void onLoadCleared(@Nullable Drawable placeholder) {
+                    target.onLoadCleared(placeholder);
+                  }
+
+                  @Override
+                  public void onLoadStarted(@Nullable Drawable placeholder) {
+                    target.onLoadStarted(placeholder);
+                  }
+
+                  @Override
+                  public void onLoadFailed(@Nullable Drawable errorDrawable) {
+                    target.onLoadFailed(errorDrawable);
+                    latch.countDown();
+                  }
+
+                  @Override
+                  public void getSize(@NonNull SizeReadyCallback cb) {
+                    target.getSize(cb);
+                  }
+
+                  @Override
+                  public void removeCallback(@NonNull SizeReadyCallback cb) {
+                    target.removeCallback(cb);
+                  }
+
+                  @Override
+                  public void setRequest(@Nullable Request request) {
+                    target.setRequest(request);
+                  }
+
+                  @Nullable
+                  @Override
+                  public Request getRequest() {
+                    return target.getRequest();
+                  }
+                });
+            return target;
+          }
+        });
+    waitOnLatch(latch);
+  }
+
+  private <T> void loadOnMainThread(final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    callOnMainThread(
+        new Callable<Target<T>>() {
+          @Override
+          public Target<T> call() {
+            builder.into(
+                new Target<T>() {
+                  @Override
+                  public void onStart() {
+                    target.onStart();
+                  }
+
+                  @Override
+                  public void onStop() {
+                    target.onStop();
+                  }
+
+                  @Override
+                  public void onDestroy() {
+                    target.onDestroy();
+                  }
+
+                  @Override
+                  public void onResourceReady(
+                      @NonNull T resource, @Nullable Transition<? super T> transition) {
+                    target.onResourceReady(resource, transition);
+                    if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+                      latch.countDown();
+                    }
+                  }
+
+                  @Override
+                  public void onLoadCleared(@Nullable Drawable placeholder) {
+                    target.onLoadCleared(placeholder);
+                  }
+
+                  @Override
+                  public void onLoadStarted(@Nullable Drawable placeholder) {
+                    target.onLoadStarted(placeholder);
+                  }
+
+                  @Override
+                  public void onLoadFailed(@Nullable Drawable errorDrawable) {
+                    target.onLoadFailed(errorDrawable);
+                    if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+                      latch.countDown();
+                    }
+                  }
+
+                  @Override
+                  public void getSize(@NonNull SizeReadyCallback cb) {
+                    target.getSize(cb);
+                  }
+
+                  @Override
+                  public void removeCallback(@NonNull SizeReadyCallback cb) {
+                    target.removeCallback(cb);
+                  }
+
+                  @Override
+                  public void setRequest(@Nullable Request request) {
+                    target.setRequest(request);
+                  }
+
+                  @Nullable
+                  @Override
+                  public Request getRequest() {
+                    return target.getRequest();
+                  }
+                });
+            return target;
+          }
+        });
+    waitOnLatch(latch);
+  }
+
+  public void pokeMainThread() {
+    runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            // Do nothing.
+          }
+        });
+  }
+
+  public void runOnMainThread(final Runnable runnable) {
+    callOnMainThread(
+        new Callable<Void>() {
+          @Override
+          public Void call() {
+            runnable.run();
+            return null;
+          }
+        });
+  }
+
+  private <T> void callOnMainThread(final Callable<T> callable) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    handler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            try {
+              callable.call();
+            } catch (Exception e) {
+              throw new RuntimeException(e);
+            }
+            latch.countDown();
+          }
+        });
+    waitOnLatch(latch);
+  }
+
+  public static void waitOnLatch(final CountDownLatch latch) {
+    wait(
+        new Waiter() {
+          @Override
+          public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+            return latch.await(timeout, timeUnit);
+          }
+        });
+  }
+
+  private interface Waiter {
+    boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException;
+  }
+
+  private static void wait(Waiter waiter) {
+    boolean isFinished = false;
+    do {
+      try {
+        try {
+          isFinished = waiter.await(TIMEOUT_SECONDS, TIMEOUT_UNIT);
+          if (!isFinished) {
+            throw new WaiterException("Timed out while waiting");
+          }
+        } catch (InterruptedException e) {
+          throw new WaiterException(e);
+        }
+      } catch (WaiterException e) {
+        if (Debug.isDebuggerConnected()) {
+          continue;
+        }
+        throw e;
+      }
+    } while (Debug.isDebuggerConnected() && !isFinished);
+  }
+
+  private static final class WaiterException extends RuntimeException {
+    private static final long serialVersionUID = -627297254223169728L;
+
+    WaiterException(String message) {
+      super(message);
+    }
+
+    WaiterException(Throwable cause) {
+      super(cause);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
new file mode 100644
index 000000000..fb2709699
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.test;
+
+import static org.mockito.ArgumentMatchers.any;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.request.target.Target;
+
+/** Mockito matchers for various common classes. */
+public final class Matchers {
+
+  private Matchers() {
+    // Utility class.
+  }
+
+  public static Target<Drawable> anyDrawableTarget() {
+    return anyTarget();
+  }
+
+  public static Target<Bitmap> anyBitmapTarget() {
+    return anyTarget();
+  }
+
+  @SuppressWarnings("unchecked")
+  public static <T> Target<T> anyTarget() {
+    return (Target<T>) any(Target.class);
+  }
+
+  public static Bitmap anyBitmap() {
+    return any();
+  }
+
+  public static Drawable anyDrawable() {
+    return any();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
new file mode 100644
index 000000000..054ed0a0e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import androidx.annotation.NonNull;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.signature.ObjectKey;
+
+public final class MockModelLoader<ModelT, DataT> implements ModelLoader<ModelT, DataT> {
+  private final ModelT model;
+  private final DataT data;
+
+  @SuppressWarnings("unchecked")
+  public static <ModelT, DataT> void mock(final ModelT model, final DataT data) {
+    Context context = InstrumentationRegistry.getTargetContext();
+
+    Glide.get(context)
+        .getRegistry()
+        .replace(
+            (Class<ModelT>) model.getClass(),
+            (Class<DataT>) data.getClass(),
+            new ModelLoaderFactory<ModelT, DataT>() {
+              @NonNull
+              @Override
+              public ModelLoader<ModelT, DataT> build(
+                  @NonNull MultiModelLoaderFactory multiFactory) {
+                return new MockModelLoader<>(model, data);
+              }
+
+              @Override
+              public void teardown() {
+                // Do nothing.
+              }
+            });
+  }
+
+  private MockModelLoader(ModelT model, DataT data) {
+    this.model = model;
+    this.data = data;
+  }
+
+  @Override
+  public LoadData<DataT> buildLoadData(
+      @NonNull ModelT modelT, int width, int height, @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(modelT), new MockDataFetcher<>(data));
+  }
+
+  @Override
+  public boolean handles(@NonNull ModelT model) {
+    return this.model.equals(model);
+  }
+
+  private static final class MockDataFetcher<DataT> implements DataFetcher<DataT> {
+
+    private final DataT data;
+
+    MockDataFetcher(DataT data) {
+      this.data = data;
+    }
+
+    @Override
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super DataT> callback) {
+      callback.onDataReady(data);
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @NonNull
+    @Override
+    @SuppressWarnings("unchecked")
+    public Class<DataT> getDataClass() {
+      return (Class<DataT>) data.getClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.REMOTE;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
new file mode 100644
index 000000000..5ca5db97c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that a test is a regression test that relies on comparing a newly transformed image to
+ * a previously generated copy of the same image to detect changes.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface RegressionTest {
+  // Intentionally empty.
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
index 50e9cff05..5f248df6a 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 import android.content.res.Resources;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.core.app.ApplicationProvider;
 
 /**
  * Internally in google we don't appear to be able to reference resource ids directly, this class is
@@ -14,20 +14,28 @@ private ResourceIds() {
   }
 
   public interface raw {
-    int blue_rect_over_rounded = getResourceId("raw", "blue_rect_over_rounded");
-    int blue_rect_rounded = getResourceId("raw", "blue_rect_rounded");
+    int dl_world_anim = getResourceId("raw", "dl_world_anim");
+    int canonical = getResourceId("raw", "canonical");
+    int canonical_png = getResourceId("raw", "canonical_png");
+    int canonical_transparent_png = getResourceId("raw", "canonical_transparent_png");
+    int interlaced_transparent_gif = getResourceId("raw", "interlaced_transparent_gif");
+    int transparent_gif = getResourceId("raw", "transparent_gif");
+    int opaque_gif = getResourceId("raw", "opaque_gif");
+    int opaque_interlaced_gif = getResourceId("raw", "opaque_interlaced_gif");
+    int webkit_logo_p3 = getResourceId("raw", "webkit_logo_p3");
+    int video = getResourceId("raw", "video");
   }
 
   public interface drawable {
     int bitmap_alias = getResourceId("drawable", "bitmap_alias");
-    int googlelogo_color_120x44dp= getResourceId("drawable", "googlelogo_color_120x44dp");
+    int googlelogo_color_120x44dp = getResourceId("drawable", "googlelogo_color_120x44dp");
     int shape_drawable = getResourceId("drawable", "shape_drawable");
     int state_list_drawable = getResourceId("drawable", "state_list_drawable");
     int vector_drawable = getResourceId("drawable", "vector_drawable");
   }
 
   private static int getResourceId(String type, String resourceName) {
-    Context context = InstrumentationRegistry.getTargetContext();
+    Context context = ApplicationProvider.getApplicationContext();
     Resources res = context.getResources();
     return res.getIdentifier(resourceName, type, context.getPackageName());
   }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
new file mode 100644
index 000000000..91c70d8cd
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the test relies on transformations or operations that may produce different
+ * outputs on different CPUs.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SplitByCpu {}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
new file mode 100644
index 000000000..fee994178
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used by {@link BitmapRegressionTester} to generate SDK specific resources to account for
+ * differences in Android's image decoding APIs across versions.
+ */
+@Target({ElementType.METHOD, ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SplitBySdk {
+  int[] value();
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
new file mode 100644
index 000000000..1af33d45a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import androidx.test.core.app.ApplicationProvider;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/** Clears out Glide's disk cache and the Glide singleton after every test method. */
+public final class TearDownGlide implements TestRule {
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          new ConcurrencyHelper()
+              .runOnMainThread(
+                  new Runnable() {
+                    @Override
+                    public void run() {
+                      // Casting to Context explicitly is required on Java8, or the context will
+                      // be interpreted as a FragmentActivity.
+                      RequestManager requestManager =
+                          Glide.with(ApplicationProvider.<Context>getApplicationContext());
+                      requestManager.onStop();
+                      requestManager.onDestroy();
+                    }
+                  });
+          Glide.tearDown();
+        }
+      }
+    };
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
new file mode 100644
index 000000000..07dd3efab
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
@@ -0,0 +1,136 @@
+package com.bumptech.glide.test;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.InputStream;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Allows callers to load an object but force the load to pause until {@link WaitModel#countDown()}
+ * is called.
+ */
+public final class WaitModelLoader<Model, Data> implements ModelLoader<WaitModel<Model>, Data> {
+
+  private final ModelLoader<Model, Data> wrapped;
+
+  private WaitModelLoader(ModelLoader<Model, Data> wrapped) {
+    this.wrapped = wrapped;
+  }
+
+  @Nullable
+  @Override
+  public LoadData<Data> buildLoadData(
+      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {
+    LoadData<Data> wrappedLoadData =
+        wrapped.buildLoadData(waitModel.wrapped, width, height, options);
+    if (wrappedLoadData == null) {
+      return null;
+    }
+    return new LoadData<>(
+        wrappedLoadData.sourceKey, new WaitFetcher<>(wrappedLoadData.fetcher, waitModel.latch));
+  }
+
+  @Override
+  public boolean handles(@NonNull WaitModel<Model> waitModel) {
+    return wrapped.handles(waitModel.wrapped);
+  }
+
+  public static final class WaitModel<T> {
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private final T wrapped;
+
+    WaitModel(T wrapped) {
+      this.wrapped = wrapped;
+    }
+
+    public void countDown() {
+      if (latch.getCount() != 1) {
+        throw new IllegalStateException();
+      }
+      latch.countDown();
+    }
+  }
+
+  public static final class Factory<Model, Data>
+      implements ModelLoaderFactory<WaitModel<Model>, Data> {
+
+    private final Class<Model> modelClass;
+    private final Class<Data> dataClass;
+
+    Factory(Class<Model> modelClass, Class<Data> dataClass) {
+      this.modelClass = modelClass;
+      this.dataClass = dataClass;
+    }
+
+    public static synchronized <T> WaitModel<T> waitOn(T model) {
+      @SuppressWarnings("unchecked")
+      ModelLoaderFactory<WaitModel<T>, InputStream> streamFactory =
+          new Factory<>((Class<T>) model.getClass(), InputStream.class);
+      Glide.get(InstrumentationRegistry.getTargetContext())
+          .getRegistry()
+          .replace(WaitModel.class, InputStream.class, streamFactory);
+
+      return new WaitModel<>(model);
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<WaitModel<Model>, Data> build(MultiModelLoaderFactory multiFactory) {
+      return new WaitModelLoader<>(multiFactory.build(modelClass, dataClass));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  private static final class WaitFetcher<Data> implements DataFetcher<Data> {
+
+    private final DataFetcher<Data> wrapped;
+    private final CountDownLatch toWaitOn;
+
+    WaitFetcher(DataFetcher<Data> wrapped, CountDownLatch toWaitOn) {
+      this.wrapped = wrapped;
+      this.toWaitOn = toWaitOn;
+    }
+
+    @Override
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
+      ConcurrencyHelper.waitOnLatch(toWaitOn);
+      wrapped.loadData(priority, callback);
+    }
+
+    @Override
+    public void cleanup() {
+      wrapped.cleanup();
+    }
+
+    @Override
+    public void cancel() {
+      wrapped.cancel();
+    }
+
+    @NonNull
+    @Override
+    public Class<Data> getDataClass() {
+      return wrapped.getDataClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return wrapped.getDataSource();
+    }
+  }
+}
diff --git a/instrumentation/src/main/AndroidManifest.xml b/instrumentation/src/main/AndroidManifest.xml
index 706827159..fa6e2915f 100644
--- a/instrumentation/src/main/AndroidManifest.xml
+++ b/instrumentation/src/main/AndroidManifest.xml
@@ -1,4 +1,6 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.bumptech.glide.instrumentation">
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
   <application />
 </manifest>
diff --git a/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java b/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java
new file mode 100644
index 000000000..056d6140a
--- /dev/null
+++ b/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public class InstrumentationAppGlideModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/instrumentation/src/main/res/raw/blue_rect_over_rounded.png b/instrumentation/src/main/res/raw/blue_rect_over_rounded.png
deleted file mode 100644
index c4cc26a1e..000000000
Binary files a/instrumentation/src/main/res/raw/blue_rect_over_rounded.png and /dev/null differ
diff --git a/instrumentation/src/main/res/raw/blue_rect_rounded.png b/instrumentation/src/main/res/raw/blue_rect_rounded.png
deleted file mode 100644
index 86229d517..000000000
Binary files a/instrumentation/src/main/res/raw/blue_rect_rounded.png and /dev/null differ
diff --git a/instrumentation/src/main/res/raw/canonical.jpg b/instrumentation/src/main/res/raw/canonical.jpg
new file mode 100644
index 000000000..889ba2762
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical.jpg differ
diff --git a/instrumentation/src/main/res/raw/canonical_png.png b/instrumentation/src/main/res/raw/canonical_png.png
new file mode 100644
index 000000000..475aa74c4
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical_png.png differ
diff --git a/instrumentation/src/main/res/raw/canonical_transparent_png.png b/instrumentation/src/main/res/raw/canonical_transparent_png.png
new file mode 100644
index 000000000..6e8e3eb97
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical_transparent_png.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..a001e38f1
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png
new file mode 100644
index 000000000..3a08a9026
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..a001e38f1
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png
new file mode 100644
index 000000000..515b8e4d3
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png
new file mode 100644
index 000000000..16efb6214
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..33ae114e4
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png
new file mode 100644
index 000000000..930e93090
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..33ae114e4
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png
new file mode 100644
index 000000000..cfd574f85
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png
new file mode 100644
index 000000000..f8bd1018a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..3c4f98d1b
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png
new file mode 100644
index 000000000..fdc961ec6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..3c4f98d1b
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png
new file mode 100644
index 000000000..1cd39b7e8
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png
new file mode 100644
index 000000000..25ca7a8d8
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..63613050c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png
new file mode 100644
index 000000000..a6f2ebb73
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..63613050c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png
new file mode 100644
index 000000000..fce9cc8e9
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png
new file mode 100644
index 000000000..889309568
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png
new file mode 100644
index 000000000..7d9667d0c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png
new file mode 100644
index 000000000..1515a3629
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png
new file mode 100644
index 000000000..b6cccc383
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png
new file mode 100644
index 000000000..040a0cb58
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png
new file mode 100644
index 000000000..b6cccc383
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png
new file mode 100644
index 000000000..3746332ad
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png
new file mode 100644
index 000000000..c0e1a463f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1515a3629
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..040a0cb58
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..3746332ad
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..c0e1a463f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..bba6152db
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..b667fbe14
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..3d86fa33a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..5829492f9
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..3d86fa33a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..7de62e0ea
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..fdc93c5f0
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..0f6e9e1df
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png
new file mode 100644
index 000000000..060028372
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..6d5494869
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png
new file mode 100644
index 000000000..80aa1e15a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png
new file mode 100644
index 000000000..1c0e76eb5
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png
new file mode 100644
index 000000000..95a70ed33
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..1c0e76eb5
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png
new file mode 100644
index 000000000..466ab5d9f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png
new file mode 100644
index 000000000..810cec1b2
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png
new file mode 100644
index 000000000..43b654ec6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png
new file mode 100644
index 000000000..ceca292da
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..cab94eaaa
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png
new file mode 100644
index 000000000..640c93085
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..9ead8030f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png
new file mode 100644
index 000000000..6f4a4e311
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..6ab29373f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png
new file mode 100644
index 000000000..54d467fb6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..288e5f0a3
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png
new file mode 100644
index 000000000..cab94eaaa
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png
new file mode 100644
index 000000000..14f685740
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png
new file mode 100644
index 000000000..640c93085
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..14f685740
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png
new file mode 100644
index 000000000..9ead8030f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png
new file mode 100644
index 000000000..6f4a4e311
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png
new file mode 100644
index 000000000..6ab29373f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png
new file mode 100644
index 000000000..54d467fb6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..396837460
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..fb6a40f75
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..9f7ad2686
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png
new file mode 100644
index 000000000..2e1cbbf18
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..9f7ad2686
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png
new file mode 100644
index 000000000..afe43f81a
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png
new file mode 100644
index 000000000..5c0019916
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..e7eb65010
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/dl_world_anim.gif b/instrumentation/src/main/res/raw/dl_world_anim.gif
new file mode 100644
index 000000000..1e3b8dea2
Binary files /dev/null and b/instrumentation/src/main/res/raw/dl_world_anim.gif differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..396837460
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..fb6a40f75
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png
new file mode 100644
index 000000000..cbf40ecec
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png
new file mode 100644
index 000000000..cbf40ecec
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png
new file mode 100644
index 000000000..a2a03bfe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..e7eb65010
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif b/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif
new file mode 100644
index 000000000..283e0fb16
Binary files /dev/null and b/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/opaque_gif.gif b/instrumentation/src/main/res/raw/opaque_gif.gif
new file mode 100644
index 000000000..3b50db910
Binary files /dev/null and b/instrumentation/src/main/res/raw/opaque_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif b/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif
new file mode 100644
index 000000000..4ebf12daf
Binary files /dev/null and b/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png
new file mode 100644
index 000000000..caa7c5963
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png
new file mode 100644
index 000000000..45956c505
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png
new file mode 100644
index 000000000..669269f2b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png
new file mode 100644
index 000000000..3e4aab0a0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png
new file mode 100644
index 000000000..669269f2b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png
new file mode 100644
index 000000000..3e4aab0a0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png
new file mode 100644
index 000000000..6c4dab5b5
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png
new file mode 100644
index 000000000..28cfaf4bf
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png
new file mode 100644
index 000000000..28cfaf4bf
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png
new file mode 100644
index 000000000..cd56aa644
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png
new file mode 100644
index 000000000..e68bc997c
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png
new file mode 100644
index 000000000..e1eda26d6
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png
new file mode 100644
index 000000000..6a53e1dd8
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png
new file mode 100644
index 000000000..683d55fe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png
new file mode 100644
index 000000000..c70fdea57
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png
new file mode 100644
index 000000000..683d55fe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png
new file mode 100644
index 000000000..c70fdea57
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png
new file mode 100644
index 000000000..ecbff14cb
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png
new file mode 100644
index 000000000..cbb3895b0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png
new file mode 100644
index 000000000..843b78f9b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png
new file mode 100644
index 000000000..fd26de305
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png
new file mode 100644
index 000000000..098a5da5e
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png
new file mode 100644
index 000000000..c8bc48aa4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png
new file mode 100644
index 000000000..e42fb5cf8
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png
new file mode 100644
index 000000000..a5cda420f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png
new file mode 100644
index 000000000..42229a13f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png
new file mode 100644
index 000000000..a5cda420f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png
new file mode 100644
index 000000000..42229a13f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png
new file mode 100644
index 000000000..b29b0da31
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png
new file mode 100644
index 000000000..0f4b78b5d
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png
new file mode 100644
index 000000000..0f4b78b5d
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png
new file mode 100644
index 000000000..2295f8881
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png
new file mode 100644
index 000000000..2295f8881
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/transparent_gif.gif b/instrumentation/src/main/res/raw/transparent_gif.gif
new file mode 100644
index 000000000..88c7097e7
Binary files /dev/null and b/instrumentation/src/main/res/raw/transparent_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/video.mp4 b/instrumentation/src/main/res/raw/video.mp4
new file mode 100644
index 000000000..3ffc91a98
Binary files /dev/null and b/instrumentation/src/main/res/raw/video.mp4 differ
diff --git a/instrumentation/src/main/res/raw/webkit_logo_p3.png b/instrumentation/src/main/res/raw/webkit_logo_p3.png
new file mode 100644
index 000000000..55bad7f81
Binary files /dev/null and b/instrumentation/src/main/res/raw/webkit_logo_p3.png differ
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index a5defa841..fb6589148 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -1,19 +1,18 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-
-    testCompile project(":testutil")
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+    implementation project(':library')
+
+    testImplementation project(":testutil")
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "androidx.legacy:legacy-support-v4:${ANDROID_X_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     sourceSets {
         main {
diff --git a/integration/gifencoder/src/main/AndroidManifest.xml b/integration/gifencoder/src/main/AndroidManifest.xml
index eeb7b37c5..c2b8a91b3 100644
--- a/integration/gifencoder/src/main/AndroidManifest.xml
+++ b/integration/gifencoder/src/main/AndroidManifest.xml
@@ -1,5 +1,5 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide.integration.gifencoder">
+<manifest
+  package="com.bumptech.glide.integration.gifencoder">
 
     <application>
     </application>
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index 9051d5f12..04f488b08 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -3,6 +3,8 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
@@ -30,44 +32,54 @@
 import java.security.MessageDigest;
 
 /**
- * An {@link com.bumptech.glide.load.ResourceEncoder} that can write
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} to cache.
+ * An {@link com.bumptech.glide.load.ResourceEncoder} that can write {@link
+ * com.bumptech.glide.load.resource.gif.GifDrawable} to cache.
  */
 public class ReEncodingGifResourceEncoder implements ResourceEncoder<GifDrawable> {
 
   private static final String KEY_ENCODE_TRANSFORMATION =
       "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";
-   /**
-   * A boolean option that, if set to <code>true</code>, causes the fully transformed
-   * GIF to be written to cache.
+  /**
+   * A boolean option that, if set to <code>true</code>, causes the fully transformed GIF to be
+   * written to cache.
    *
-   * <p> Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
-   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs. </p>
+   * <p>Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than the
+   * originals. Re-encoding may be worth it to decrease the size of very large GIFs.
    *
-   * <p> Defaults to <code>false</code>. </p>
+   * <p>Defaults to <code>false</code>.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final Option<Boolean> ENCODE_TRANSFORMATION =
-      Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {
-        @Override
-        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {
-          if (value) {
-            messageDigest.update(keyBytes);
-          }
-        }
-      });
+      Option.disk(
+          KEY_ENCODE_TRANSFORMATION,
+          false,
+          new Option.CacheKeyUpdater<Boolean>() {
+            @Override
+            public void update(
+                @NonNull byte[] keyBytes,
+                @NonNull Boolean value,
+                @NonNull MessageDigest messageDigest) {
+              if (value) {
+                messageDigest.update(keyBytes);
+              }
+            }
+          });
 
   private static final Factory FACTORY = new Factory();
   private static final String TAG = "GifEncoder";
   private final GifDecoder.BitmapProvider provider;
-  private Context context;
+  private final Context context;
   private final BitmapPool bitmapPool;
   private final Factory factory;
 
-  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
+  // Public API.
+  @SuppressWarnings("unused")
+  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {
     this(context, bitmapPool, FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {
     this.context = context;
     this.bitmapPool = bitmapPool;
@@ -75,15 +87,18 @@ public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
     this.factory = factory;
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     Boolean encodeTransformation = options.get(ENCODE_TRANSFORMATION);
     return encodeTransformation != null && encodeTransformation
-        ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;
+        ? EncodeStrategy.TRANSFORMED
+        : EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(Resource<GifDrawable> resource, File file, Options options) {
+  public boolean encode(
+      @NonNull Resource<GifDrawable> resource, @NonNull File file, @NonNull Options options) {
     GifDrawable drawable = resource.get();
     Transformation<Bitmap> transformation = drawable.getFrameTransformation();
     boolean isTransformed = !(transformation instanceof UnitTransformation);
@@ -114,12 +129,17 @@ private boolean encodeTransformedToFile(GifDrawable drawable, File file) {
           // Ignored.
         }
       }
-
     }
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and "
-          + drawable.getBuffer().limit() + " bytes in " + LogTime.getElapsedMillis(startTime)
-          + " ms");
+      Log.v(
+          TAG,
+          "Re-encoded GIF with "
+              + drawable.getFrameCount()
+              + " frames and "
+              + drawable.getBuffer().limit()
+              + " bytes in "
+              + LogTime.getElapsedMillis(startTime)
+              + " ms");
     }
 
     return success;
@@ -178,8 +198,8 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
     return decoder;
   }
 
-  private Resource<Bitmap> getTransformedFrame(Bitmap currentFrame,
-      Transformation<Bitmap> transformation, GifDrawable drawable) {
+  private Resource<Bitmap> getTransformedFrame(
+      Bitmap currentFrame, Transformation<Bitmap> transformation, GifDrawable drawable) {
     // TODO: what if current frame is null?
     Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
     Resource<Bitmap> transformedResource =
@@ -191,22 +211,23 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
     return transformedResource;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Factory {
 
-    public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
+    GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
       return new StandardGifDecoder(bitmapProvider);
     }
 
-    public GifHeaderParser buildParser() {
+    GifHeaderParser buildParser() {
       return new GifHeaderParser();
     }
 
-    public AnimatedGifEncoder buildEncoder() {
+    AnimatedGifEncoder buildEncoder() {
       return new AnimatedGifEncoder();
     }
 
-    public Resource<Bitmap> buildFrameResource(Bitmap bitmap, BitmapPool bitmapPool) {
+    @NonNull
+    Resource<Bitmap> buildFrameResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
       return new BitmapResource(bitmap, bitmapPool);
     }
   }
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index 9d449e805..cbe4f30db 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -3,7 +3,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assume.assumeTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
@@ -43,20 +42,18 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}.
- */
+/** Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}. */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ReEncodingGifResourceEncoderTest {
-  @Mock Resource<GifDrawable> resource;
-  @Mock GifDecoder decoder;
-  @Mock GifHeaderParser parser;
-  @Mock AnimatedGifEncoder gifEncoder;
-  @Mock Resource<Bitmap> frameResource;
-  @Mock GifDrawable gifDrawable;
-  @Mock Transformation<Bitmap> frameTransformation;
-  @Mock Resource<Bitmap> transformedResource;
+  @Mock private Resource<GifDrawable> resource;
+  @Mock private GifDecoder decoder;
+  @Mock private GifHeaderParser parser;
+  @Mock private AnimatedGifEncoder gifEncoder;
+  @Mock private Resource<Bitmap> frameResource;
+  @Mock private GifDrawable gifDrawable;
+  @Mock private Transformation<Bitmap> frameTransformation;
+  @Mock private Resource<Bitmap> transformedResource;
 
   private ReEncodingGifResourceEncoder encoder;
   private Options options;
@@ -74,7 +71,7 @@ public void setUp() {
     when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
     when(factory.buildParser()).thenReturn(parser);
     when(factory.buildEncoder()).thenReturn(gifEncoder);
-    when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class)))
+    when(factory.buildFrameResource(anyBitmapOrNull(), any(BitmapPool.class)))
         .thenReturn(frameResource);
 
     // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!)
@@ -95,6 +92,8 @@ public void setUp() {
 
   @After
   public void tearDown() {
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
     if (file.exists() && !file.delete()) {
       throw new RuntimeException("Failed to delete file");
     }
@@ -120,8 +119,6 @@ public void testEncodeStrategy_withEncodeTransformationFalse_returnsSource() {
   @Test
   public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
       throws IOException {
-    // Most likely an instance of http://stackoverflow.com/q/991489/253468
-    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     String expected = "testString";
     byte[] data = expected.getBytes("UTF-8");
@@ -134,7 +131,6 @@ public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
   @Test
   public void testEncode_WithEncodeTransformationFalse_whenOsThrows_returnsFalse()
       throws IOException {
-
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     byte[] data = "testString".getBytes("UTF-8");
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(data));
@@ -182,7 +178,7 @@ public void testAdvancesDecoderBeforeAttemptingToGetFirstFrame() {
   @Test
   public void testSetsDelayOnEncoderAfterAddingFrame() {
     when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-    when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(true);
+    when(gifEncoder.addFrame(anyBitmapOrNull())).thenReturn(true);
 
     when(decoder.getFrameCount()).thenReturn(1);
     when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
@@ -195,7 +191,7 @@ public void testSetsDelayOnEncoderAfterAddingFrame() {
 
     InOrder order = inOrder(gifEncoder, decoder);
     order.verify(decoder).advance();
-    order.verify(gifEncoder).addFrame(any(Bitmap.class));
+    order.verify(gifEncoder).addFrame(anyBitmapOrNull());
     order.verify(gifEncoder).setDelay(eq(expectedDelay));
     order.verify(decoder).advance();
   }
@@ -222,7 +218,7 @@ public void testReturnsFalseIfAddingFrameFails() {
     when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
 
     when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-    when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(false);
+    when(gifEncoder.addFrame(anyBitmapOrNull())).thenReturn(false);
 
     assertFalse(encoder.encode(resource, file, options));
   }
@@ -251,7 +247,7 @@ public void testWritesTransformedBitmaps() {
     Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
     when(transformedResource.get()).thenReturn(transformedFrame);
     when(frameTransformation.transform(
-        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
+            anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
         .thenReturn(transformedResource);
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
 
@@ -312,10 +308,7 @@ public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed
   }
 
   @Test
-  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
-      throws IOException {
-    // Most likely an instance of http://stackoverflow.com/q/991489/253468
-    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
+  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation() {
     when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
     String expected = "expected";
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
@@ -340,4 +333,8 @@ private String getEncodedData() {
   private static Context anyContext() {
     return any(Context.class);
   }
+
+  private static Bitmap anyBitmapOrNull() {
+    return any();
+  }
 }
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index b30b8fb59..c8c0420c3 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -1,16 +1,15 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.squareup.okhttp:okhttp:2.7.1"
-    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    api "com.squareup.okhttp:okhttp:2.7.5"
+    api "androidx.annotation:annotation:${ANDROID_X_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/okhttp/src/main/AndroidManifest.xml b/integration/okhttp/src/main/AndroidManifest.xml
index 738e5c900..62fac40a3 100644
--- a/integration/okhttp/src/main/AndroidManifest.xml
+++ b/integration/okhttp/src/main/AndroidManifest.xml
@@ -1,5 +1,5 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide.integration.okhttp">
+<manifest
+  package="com.bumptech.glide.integration.okhttp">
 
     <application />
 </manifest>
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 36a47491f..0ecc01004 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -8,20 +9,20 @@
 import java.io.InputStream;
 
 /**
- * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
- * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
- * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default {@link
+ * java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with an
+ * OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
  *
- * <p> If you're using gradle, you can include this module simply by depending on the aar, the
- * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ * <p>If you're using gradle, you can include this module simply by depending on the aar, the module
+ * will be merged in by manifest merger. For other build systems or for more more information, see
+ * {@link com.bumptech.glide.module.GlideModule}.
  *
  * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
  */
 @Deprecated
 public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
index bc81dabc0..9abe0ab02 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
@@ -12,9 +12,8 @@
 /**
  * Registers OkHttp related classes via Glide's annotation processor.
  *
- * <p>For Applications that depend on this library and include an
- * {@link AppGlideModule} and Glide's annotation processor, this class
- * will be automatically included.
+ * <p>For Applications that depend on this library and include an {@link AppGlideModule} and Glide's
+ * annotation processor, this class will be automatically included.
  *
  * @deprecated Prefer the okhttp3 version instead.
  */
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 936f95f81..2a9c946ea 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.integration.okhttp;
 
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.HttpException;
@@ -27,16 +27,25 @@
   private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
   private final GlideUrl url;
-  @Synthetic InputStream stream;
-  @Synthetic ResponseBody responseBody;
 
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  InputStream stream;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  ResponseBody responseBody;
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
     this.client = client;
     this.url = url;
   }
 
   @Override
-  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+  public void loadData(
+      @NonNull Priority priority, @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
@@ -44,27 +53,31 @@ public void loadData(Priority priority, final DataCallback<? super InputStream>
     }
     Request request = requestBuilder.build();
 
-    client.newCall(request).enqueue(new com.squareup.okhttp.Callback() {
-      @Override
-      public void onFailure(Request request, IOException e) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "OkHttp failed to obtain result", e);
-        }
-        callback.onLoadFailed(e);
-      }
+    client
+        .newCall(request)
+        .enqueue(
+            new com.squareup.okhttp.Callback() {
+              @Override
+              public void onFailure(Request request, IOException e) {
+                if (Log.isLoggable(TAG, Log.DEBUG)) {
+                  Log.d(TAG, "OkHttp failed to obtain result", e);
+                }
+                callback.onLoadFailed(e);
+              }
 
-      @Override
-      public void onResponse(Response response) throws IOException {
-        responseBody = response.body();
-        if (response.isSuccessful()) {
-          long contentLength = responseBody.contentLength();
-          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
-          callback.onDataReady(stream);
-        } else {
-          callback.onLoadFailed(new HttpException(response.message(), response.code()));
-        }
-      }
-    });
+              @Override
+              public void onResponse(Response response) throws IOException {
+                responseBody = response.body();
+                if (response.isSuccessful()) {
+                  long contentLength = responseBody.contentLength();
+                  stream =
+                      ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+                  callback.onDataReady(stream);
+                } else {
+                  callback.onLoadFailed(new HttpException(response.message(), response.code()));
+                }
+              }
+            });
   }
 
   @Override
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 48468bf63..15b8660e2 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.okhttp;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -18,27 +19,30 @@
 
   private final OkHttpClient client;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpUrlLoader(OkHttpClient client) {
     this.client = client;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
+  @SuppressWarnings("deprecation")
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull GlideUrl model, int width, int height, @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
-  /**
-   * The default factory for {@link OkHttpUrlLoader}s.
-   */
+  /** The default factory for {@link OkHttpUrlLoader}s. */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "deprecation"})
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile OkHttpClient internalClient;
-    private OkHttpClient client;
+    private final OkHttpClient client;
 
     private static OkHttpClient getInternalClient() {
       if (internalClient == null) {
@@ -51,20 +55,18 @@ private static OkHttpClient getInternalClient() {
       return internalClient;
     }
 
-    /**
-     * Constructor for a new Factory that runs requests using a static singleton client.
-     */
+    /** Constructor for a new Factory that runs requests using a static singleton client. */
     public Factory() {
       this(getInternalClient());
     }
 
-    /**
-     * Constructor for a new Factory that runs requests using given client.
-     */
+    /** Constructor for a new Factory that runs requests using given client. */
     public Factory(OkHttpClient client) {
       this.client = client;
     }
 
+    @NonNull
+    @SuppressWarnings("deprecation")
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
index 5290c6a42..74f32696e 100644
--- a/integration/okhttp3/build.gradle
+++ b/integration/okhttp3/build.gradle
@@ -1,16 +1,15 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
-    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    api "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    api "androidx.annotation:annotation:${ANDROID_X_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
index 60517251f..bb489f18b 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -8,21 +9,21 @@
 import java.io.InputStream;
 
 /**
- * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
- * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
- * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default {@link
+ * java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with an
+ * OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
  *
- * <p> If you're using gradle, you can include this module simply by depending on the aar, the
- * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ * <p>If you're using gradle, you can include this module simply by depending on the aar, the module
+ * will be merged in by manifest merger. For other build systems or for more more information, see
+ * {@link com.bumptech.glide.module.GlideModule}.
  *
  * @deprecated Replaced by {@link OkHttpLibraryGlideModule} for Applications that use Glide's
- * annotations.
+ *     annotations.
  */
 @Deprecated
 public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
index 74eace9eb..0d605ce9c 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -12,14 +13,14 @@
 /**
  * Registers OkHttp related classes via Glide's annotation processor.
  *
- * <p>For Applications that depend on this library and include an
- * {@link AppGlideModule} and Glide's annotation processor, this class
- * will be automatically included.
+ * <p>For Applications that depend on this library and include an {@link AppGlideModule} and Glide's
+ * annotation processor, this class will be automatically included.
  */
 @GlideModule
 public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
index a0b0faaef..ac9ca2bbd 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.integration.okhttp3;
 
-import android.os.Build;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.HttpException;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
-import com.bumptech.glide.util.Synthetic;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Map;
@@ -18,26 +17,28 @@
 import okhttp3.Response;
 import okhttp3.ResponseBody;
 
-/**
- * Fetches an {@link InputStream} using the okhttp library.
- */
-public class OkHttpStreamFetcher implements DataFetcher<InputStream>,
- okhttp3.Callback {
+/** Fetches an {@link InputStream} using the okhttp library. */
+public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {
   private static final String TAG = "OkHttpFetcher";
   private final Call.Factory client;
   private final GlideUrl url;
-  @Synthetic InputStream stream;
-  @Synthetic ResponseBody responseBody;
-  private volatile Call call;
+  private InputStream stream;
+  private ResponseBody responseBody;
   private DataCallback<? super InputStream> callback;
+  // call may be accessed on the main thread while the object is in use on other threads. All other
+  // accesses to variables may occur on different threads, but only one at a time.
+  private volatile Call call;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
     this.client = client;
     this.url = url;
   }
 
   @Override
-  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+  public void loadData(
+      @NonNull Priority priority, @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
@@ -47,25 +48,11 @@ public void loadData(Priority priority, final DataCallback<? super InputStream>
     this.callback = callback;
 
     call = client.newCall(request);
-    if (Build.VERSION.SDK_INT != Build.VERSION_CODES.O) {
-      call.enqueue(this);
-    } else {
-      try {
-        // Calling execute instead of enqueue is a workaround for #2355, where okhttp throws a
-        // ClassCastException on O.
-        onResponse(call, call.execute());
-      } catch (IOException e) {
-        onFailure(call, e);
-      } catch (ClassCastException e) {
-        // It's not clear that this catch is necessary, the error may only occur even on O if
-        // enqueue is used.
-        onFailure(call, new IOException("Workaround for framework bug on O", e));
-      }
-    }
+    call.enqueue(this);
   }
 
   @Override
-  public void onFailure(Call call, IOException e) {
+  public void onFailure(@NonNull Call call, @NonNull IOException e) {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
       Log.d(TAG, "OkHttp failed to obtain result", e);
     }
@@ -74,10 +61,10 @@ public void onFailure(Call call, IOException e) {
   }
 
   @Override
-  public void onResponse(Call call, Response response) throws IOException {
+  public void onResponse(@NonNull Call call, @NonNull Response response) {
     responseBody = response.body();
     if (response.isSuccessful()) {
-      long contentLength = responseBody.contentLength();
+      long contentLength = Preconditions.checkNotNull(responseBody).contentLength();
       stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
       callback.onDataReady(stream);
     } else {
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
index b63164a59..6eb982377 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.okhttp3;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -9,34 +10,34 @@
 import okhttp3.Call;
 import okhttp3.OkHttpClient;
 
-/**
- * A simple model loader for fetching media over http/https using OkHttp.
- */
+/** A simple model loader for fetching media over http/https using OkHttp. */
 public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
   private final Call.Factory client;
 
-  public OkHttpUrlLoader(Call.Factory client) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public OkHttpUrlLoader(@NonNull Call.Factory client) {
     this.client = client;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull GlideUrl model, int width, int height, @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
-  /**
-   * The default factory for {@link OkHttpUrlLoader}s.
-   */
+  /** The default factory for {@link OkHttpUrlLoader}s. */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile Call.Factory internalClient;
-    private Call.Factory client;
+    private final Call.Factory client;
 
     private static Call.Factory getInternalClient() {
       if (internalClient == null) {
@@ -49,9 +50,7 @@ public boolean handles(GlideUrl url) {
       return internalClient;
     }
 
-    /**
-     * Constructor for a new Factory that runs requests using a static singleton client.
-     */
+    /** Constructor for a new Factory that runs requests using a static singleton client. */
     public Factory() {
       this(getInternalClient());
     }
@@ -61,10 +60,11 @@ public Factory() {
      *
      * @param client this is typically an instance of {@code OkHttpClient}.
      */
-    public Factory(Call.Factory client) {
+    public Factory(@NonNull Call.Factory client) {
       this.client = client;
     }
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
index 24eb09e46..c02a36c0f 100644
--- a/integration/recyclerview/build.gradle
+++ b/integration/recyclerview/build.gradle
@@ -1,14 +1,13 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-    provided "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
-    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    implementation project(':library')
+    compileOnly "androidx.recyclerview:recyclerview:${ANDROID_X_VERSION}"
+    compileOnly "androidx.fragment:fragment:${ANDROID_X_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/recyclerview/lint.xml b/integration/recyclerview/lint.xml
index ff7e5955c..5e2b51e98 100644
--- a/integration/recyclerview/lint.xml
+++ b/integration/recyclerview/lint.xml
@@ -1,4 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
 </lint>
diff --git a/integration/recyclerview/src/main/AndroidManifest.xml b/integration/recyclerview/src/main/AndroidManifest.xml
index 0d880314c..ec07ec85f 100644
--- a/integration/recyclerview/src/main/AndroidManifest.xml
+++ b/integration/recyclerview/src/main/AndroidManifest.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide.integration.recyclerview">
+<manifest
+  package="com.bumptech.glide.integration.recyclerview">
     <application />
 </manifest>
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
index a3fd25880..c91ff05c2 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
@@ -1,16 +1,19 @@
 package com.bumptech.glide.integration.recyclerview;
 
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
 import android.widget.AbsListView;
 import android.widget.ListView;
+import androidx.annotation.NonNull;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
 
 /**
- * Converts {@link android.support.v7.widget.RecyclerView.OnScrollListener} events to
- * {@link AbsListView} scroll events.
+ * Converts {@link androidx.recyclerview.widget.RecyclerView.OnScrollListener} events to {@link
+ * AbsListView} scroll events.
  *
  * <p>Requires that the the recycler view be using a {@link LinearLayoutManager} subclass.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class RecyclerToListViewScrollListener extends RecyclerView.OnScrollListener {
   public static final int UNKNOWN_SCROLL_STATE = Integer.MIN_VALUE;
   private final AbsListView.OnScrollListener scrollListener;
@@ -18,7 +21,7 @@
   private int lastVisibleCount = -1;
   private int lastItemCount = -1;
 
-  public RecyclerToListViewScrollListener(AbsListView.OnScrollListener scrollListener) {
+  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {
     this.scrollListener = scrollListener;
   }
 
@@ -50,7 +53,8 @@ public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
     int visibleCount = Math.abs(firstVisible - layoutManager.findLastVisibleItemPosition());
     int itemCount = recyclerView.getAdapter().getItemCount();
 
-    if (firstVisible != lastFirstVisible || visibleCount != lastVisibleCount
+    if (firstVisible != lastFirstVisible
+        || visibleCount != lastVisibleCount
         || itemCount != lastItemCount) {
       scrollListener.onScroll(null, firstVisible, visibleCount, itemCount);
       lastFirstVisible = firstVisible;
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
index 47be184a7..d1e0056d4 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide.integration.recyclerview;
 
 import android.app.Activity;
-import android.app.Fragment;
-import android.support.v4.app.FragmentActivity;
-import android.support.v7.widget.RecyclerView;
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
+import androidx.recyclerview.widget.RecyclerView;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.ListPreloader.PreloadModelProvider;
@@ -16,13 +17,13 @@
  * the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and
  * cache size.
  *
- * <p> Must be added as a listener to the {@link RecyclerView} using
- * {@link RecyclerView#addOnScrollListener(RecyclerView.OnScrollListener)}, or have its
- * corresponding methods called from another
- * {@link android.support.v7.widget.RecyclerView.OnScrollListener} to function. </p>
+ * <p>Must be added as a listener to the {@link RecyclerView} using {@link
+ * RecyclerView#addOnScrollListener(RecyclerView.OnScrollListener)}, or have its corresponding
+ * methods called from another {@link androidx.recyclerview.widget.RecyclerView.OnScrollListener} to
+ * function.
  *
- * <p> This class only works with {@link android.support.v7.widget.LinearLayoutManager} and
- * subclasses of {@link android.support.v7.widget.LinearLayoutManager}. </p>
+ * <p>This class only works with {@link androidx.recyclerview.widget.LinearLayoutManager} and
+ * subclasses of {@link androidx.recyclerview.widget.LinearLayoutManager}.
  *
  * @param <T> The type of the model being displayed in the {@link RecyclerView}.
  */
@@ -31,55 +32,65 @@
 
   private final RecyclerToListViewScrollListener recyclerScrollListener;
 
-  /**
-   * Helper constructor that accepts an {@link Activity}.
-   */
-  public RecyclerViewPreloader(Activity activity,
-      PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  /** Helper constructor that accepts an {@link Activity}. */
+  public RecyclerViewPreloader(
+      @NonNull Activity activity,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
     this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
-  /**
-   * Helper constructor that accepts an {@link FragmentActivity}.
-   */
-  public RecyclerViewPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  /** Helper constructor that accepts an {@link FragmentActivity}. */
+  public RecyclerViewPreloader(
+      @NonNull FragmentActivity fragmentActivity,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
-  /**
-   * Helper constructor that accepts an {@link Fragment}.
-   */
-  public RecyclerViewPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  /** Helper constructor that accepts an {@link Fragment}. */
+  public RecyclerViewPreloader(
+      @NonNull Fragment fragment,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
   /**
-   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
+   * Helper constructor that accepts an {@link android.app.Fragment}.
+   *
+   * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,
+   * PreloadSizeProvider<T>)</code> instead.
    */
-  public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  @Deprecated
+  public RecyclerViewPreloader(
+      @NonNull android.app.Fragment fragment,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
+
   /**
    * Constructor that accepts interfaces for providing the dimensions of images to preload, the list
    * of models to preload for a given position, and the request to use to load images.
    *
-   * @param preloadModelProvider     Provides models to load and requests capable of loading them.
+   * @param preloadModelProvider Provides models to load and requests capable of loading them.
    * @param preloadDimensionProvider Provides the dimensions of images to load.
-   * @param maxPreload               Maximum number of items to preload.
+   * @param maxPreload Maximum number of items to preload.
    */
-  public RecyclerViewPreloader(RequestManager requestManager,
-      PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public RecyclerViewPreloader(
+      @NonNull RequestManager requestManager,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
 
-    ListPreloader<T> listPreloader = new ListPreloader<>(requestManager, preloadModelProvider,
-        preloadDimensionProvider, maxPreload);
+    ListPreloader<T> listPreloader =
+        new ListPreloader<>(
+            requestManager, preloadModelProvider, preloadDimensionProvider, maxPreload);
     recyclerScrollListener = new RecyclerToListViewScrollListener(listPreloader);
   }
 
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index b4c5a53ff..7f764f2ea 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,22 +1,21 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile project(':library')
-    compile "com.android.volley:volley:${VOLLEY_VERSION}"
-    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    implementation project(':library')
+    api "com.android.volley:volley:${VOLLEY_VERSION}"
+    api "androidx.annotation:annotation:${ANDROID_X_VERSION}"
     annotationProcessor project(':annotation:compiler')
 
-    testCompile project(":testutil")
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation project(":testutil")
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 52899e89a..cf00278db 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -8,13 +9,13 @@
 import java.io.InputStream;
 
 /**
- * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
- * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
- * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default {@link
+ * java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a Volley
+ * based {@link com.bumptech.glide.load.model.ModelLoader}.
  *
- * <p> If you're using gradle, you can include this module simply by depending on the aar, the
- * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}.
+ * <p>If you're using gradle, you can include this module simply by depending on the aar, the module
+ * will be merged in by manifest merger. For other build systems or for more more information, see
+ * {@link com.bumptech.glide.module.GlideModule}.
  *
  * @deprecated Replaced with {@link VolleyLibraryGlideModule}.
  */
@@ -22,7 +23,7 @@
 @SuppressWarnings("deprecation")
 public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
index 6fa56468c..60b86565b 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -10,18 +11,18 @@
 import java.io.InputStream;
 
 /**
- * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
- * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
- * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default {@link
+ * java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a Volley
+ * based {@link com.bumptech.glide.load.model.ModelLoader}.
  *
- * <p>For Applications that depend on this library and include an
- * {@link AppGlideModule} and Glide's annotation processor, this class
- * will be automatically included.
+ * <p>For Applications that depend on this library and include an {@link AppGlideModule} and Glide's
+ * annotation processor, this class will be automatically included.
  */
 @GlideModule
 public class VolleyLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
   }
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
index bbc313217..6ed285b1a 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
@@ -6,17 +6,16 @@
 import java.io.InputStream;
 import java.util.Map;
 
-/**
- * Used to construct a custom Volley request, such as for authentication header decoration.
- */
+/** Used to construct a custom Volley request, such as for authentication header decoration. */
 public interface VolleyRequestFactory {
 
   /**
-   * Returns a Volley request for the given image url. The given future should be put as a
-   * listener or called when the request completes.
+   * Returns a Volley request for the given image url. The given future should be put as a listener
+   * or called when the request completes.
    */
-
-  Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
-      Priority priority, Map<String, String> headers);
-
+  Request<byte[]> create(
+      String url,
+      DataCallback<? super InputStream> callback,
+      Priority priority,
+      Map<String, String> headers);
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index 3a4e17415..39c5de9d6 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
-import android.support.annotation.NonNull;
 import android.util.Log;
-import com.android.volley.AuthFailureError;
+import androidx.annotation.NonNull;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
@@ -18,18 +17,22 @@
 import java.util.Collections;
 import java.util.Map;
 
-/**
- * A DataFetcher backed by volley for fetching images via http.
- */
+/** A DataFetcher backed by volley for fetching images via http. */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class VolleyStreamFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "VolleyStreamFetcher";
-  public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
-    @Override
-    public Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
-        Request.Priority priority, Map<String, String> headers) {
-      return new GlideRequest(url, callback, priority, headers);
-    }
-  };
+  public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY =
+      new VolleyRequestFactory() {
+        @Override
+        public Request<byte[]> create(
+            String url,
+            DataCallback<? super InputStream> callback,
+            Request.Priority priority,
+            Map<String, String> headers) {
+          return new GlideRequest(url, callback, priority, headers);
+        }
+      };
 
   private final RequestQueue requestQueue;
   private final VolleyRequestFactory requestFactory;
@@ -41,17 +44,19 @@ public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
     this(requestQueue, url, DEFAULT_REQUEST_FACTORY);
   }
 
-  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
-      VolleyRequestFactory requestFactory) {
+  public VolleyStreamFetcher(
+      RequestQueue requestQueue, GlideUrl url, VolleyRequestFactory requestFactory) {
     this.requestQueue = requestQueue;
     this.url = url;
     this.requestFactory = requestFactory;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
-    request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),
-        url.getHeaders());
+  public void loadData(
+      @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
+    request =
+        requestFactory.create(
+            url.toStringUrl(), callback, glideToVolleyPriority(priority), url.getHeaders());
     requestQueue.add(request);
   }
 
@@ -80,7 +85,7 @@ public DataSource getDataSource() {
     return DataSource.REMOTE;
   }
 
-  private static Request.Priority glideToVolleyPriority(Priority priority) {
+  private static Request.Priority glideToVolleyPriority(@NonNull Priority priority) {
     switch (priority) {
       case LOW:
         return Request.Priority.LOW;
@@ -97,6 +102,8 @@ public DataSource getDataSource() {
    * Default {@link com.android.volley.Request} implementation for Glide that receives errors and
    * results on volley's background thread.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static class GlideRequest extends Request<byte[]> {
     private final DataCallback<? super InputStream> callback;
     private final Priority priority;
@@ -106,7 +113,10 @@ public GlideRequest(String url, DataCallback<? super InputStream> callback, Prio
       this(url, callback, priority, Collections.<String, String>emptyMap());
     }
 
-    public GlideRequest(String url, DataCallback<? super InputStream> callback, Priority priority,
+    public GlideRequest(
+        String url,
+        DataCallback<? super InputStream> callback,
+        Priority priority,
         Map<String, String> headers) {
       super(Method.GET, url, null);
       this.callback = callback;
@@ -115,7 +125,7 @@ public GlideRequest(String url, DataCallback<? super InputStream> callback, Prio
     }
 
     @Override
-    public Map<String, String> getHeaders() throws AuthFailureError {
+    public Map<String, String> getHeaders() {
       return headers;
     }
 
@@ -129,13 +139,17 @@ protected VolleyError parseNetworkError(VolleyError volleyError) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Volley failed to retrieve response", volleyError);
       }
-      callback.onLoadFailed(volleyError);
+      if (!isCanceled()) {
+        callback.onLoadFailed(volleyError);
+      }
       return super.parseNetworkError(volleyError);
     }
 
     @Override
     protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
-      callback.onDataReady(new ByteArrayInputStream(response.data));
+      if (!isCanceled()) {
+        callback.onDataReady(new ByteArrayInputStream(response.data));
+      }
       return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
     }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index 02c3c0921..7bdf11b00 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.load.Options;
@@ -10,53 +11,51 @@
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import java.io.InputStream;
 
-/**
- * A simple model loader for fetching media over http/https using Volley.
- */
+/** A simple model loader for fetching media over http/https using Volley. */
 public class VolleyUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
   private final RequestQueue requestQueue;
   private final VolleyRequestFactory requestFactory;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public VolleyUrlLoader(RequestQueue requestQueue) {
     this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public VolleyUrlLoader(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
     this.requestQueue = requestQueue;
     this.requestFactory = requestFactory;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull GlideUrl url, int width, int height, @NonNull Options options) {
     return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));
   }
 
-  /**
-   * The default factory for {@link VolleyUrlLoader}s.
-   */
+  /** The default factory for {@link VolleyUrlLoader}s. */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile RequestQueue internalQueue;
 
     private final VolleyRequestFactory requestFactory;
     private final RequestQueue requestQueue;
 
-    /**
-     * Constructor for a new Factory that runs requests using a static singleton request queue.
-     */
+    /** Constructor for a new Factory that runs requests using a static singleton request queue. */
     public Factory(Context context) {
       this(getInternalQueue(context));
     }
 
-    /**
-     * Constructor for a new Factory that runs requests using the given {@link RequestQueue}.
-     */
+    /** Constructor for a new Factory that runs requests using the given {@link RequestQueue}. */
     public Factory(RequestQueue requestQueue) {
       this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
     }
@@ -70,6 +69,7 @@ public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
       this.requestQueue = requestQueue;
     }
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {
       return new VolleyUrlLoader(requestQueue, requestFactory);
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index b1271b9a2..dc506f696 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -42,17 +42,17 @@
 import org.robolectric.shadows.ShadowSystemClock;
 
 /**
- * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server
- * responses.
+ * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server responses.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18,
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
     shadows = VolleyStreamFetcherServerTest.FakeSystemClock.class)
 public class VolleyStreamFetcherServerTest {
   private static final String DEFAULT_PATH = "/fakepath";
 
-  @Mock VolleyRequestFactory requestFactory;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private MockWebServer mockWebServer;
   private RequestQueue requestQueue;
@@ -93,8 +93,10 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   @Test
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
-    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(301)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -105,8 +107,10 @@ public void testHandlesRedirect301s() throws Exception {
   @Test
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
-    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(302)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -120,8 +124,10 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String expected = "redirectedData";
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
-      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
+      mockWebServer.enqueue(
+          new MockResponse()
+              .setResponseCode(301)
+              .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -158,8 +164,10 @@ public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {
   @Test
   public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 20; i++) {
-      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
+      mockWebServer.enqueue(
+          new MockResponse()
+              .setResponseCode(301)
+              .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
     waitForResponseLatch.await();
@@ -216,9 +224,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  /**
-   * A shadow clock that doesn't rely on running on an Android thread with a Looper.
-   */
+  /** A shadow clock that doesn't rely on running on an Android thread with a Looper. */
   @Implements(SystemClock.class)
   public static class FakeSystemClock extends ShadowSystemClock {
 
diff --git a/library/build.gradle b/library/build.gradle
index d69a6f3ef..87df5b6ff 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,38 +1,38 @@
 apply plugin: 'com.android.library'
-apply plugin: 'maven'
-apply plugin: 'findbugs'
-apply plugin: 'pmd'
-apply plugin: 'jacoco'
-apply plugin: 'com.github.kt3k.coveralls'
 
-dependencies {
-    compile project(':third_party:gif_decoder')
-    compile project(':third_party:disklrucache')
-    compile project(':annotation')
-    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
-    provided "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
-    testCompile project(':testutil')
-    testCompile 'com.google.guava:guava-testlib:18.0'
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
-    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+if (!hasProperty('DISABLE_ERROR_PRONE')) {
+    apply plugin: "net.ltgt.errorprone"
+}
+
+tasks.withType(JavaCompile) {
+    options.fork = true
 }
 
-android.testOptions.unitTests.all { Test testTask ->
-    // configure max heap size of the test JVM
-    testTask.maxHeapSize = TEST_JVM_MEMORY_SIZE as String
-    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
-        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
-        testTask.jvmArgs "-XX:MaxPermSize=${TEST_JVM_MEMORY_SIZE}"
+dependencies {
+    api project(':third_party:gif_decoder')
+    api project(':third_party:disklrucache')
+    api project(':annotation')
+    api "androidx.fragment:fragment:${ANDROID_X_VERSION}"
+    api "androidx.vectordrawable:vectordrawable-animated:${ANDROID_X_VERSION}"
+    compileOnly "androidx.appcompat:appcompat:${ANDROID_X_VERSION}"
+
+    if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
+        errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}"
     }
+
+    testImplementation "androidx.appcompat:appcompat:${ANDROID_X_VERSION}"
+    testImplementation project(':testutil')
+    testImplementation 'com.google.guava:guava-testlib:18.0'
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation "androidx.legacy:legacy-support-v4:${ANDROID_X_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
@@ -41,107 +41,24 @@ android {
         consumerProguardFiles 'proguard-rules.txt'
     }
 
-    buildTypes {
-        debug {
-            testCoverageEnabled = true
-        }
-    }
-
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_7
         targetCompatibility JavaVersion.VERSION_1_7
     }
 }
 
-afterEvaluate {
-    if (tasks.findByName("assembleDebug") == null) {
-        return
-    }
-
-    findbugs {
-        toolVersion FINDBUGS_VERSION
-    }
-
-    tasks.create('findbugs', FindBugs) {
-        dependsOn tasks.assembleDebug
-
-        description 'Run findbugs'
-        group 'verification'
-
-        classes = fileTree("${project.buildDir}/intermediates/classes/debug/")
-        source android.sourceSets.main.java.srcDirs
-        classpath = project.configurations.compile
-        classpath += files(android.bootClasspath)
-
-        effort = 'max'
-
-        excludeFilter = file("findbugs-exclude.xml")
-
-        reports {
-            xml.enabled = false
-            html.enabled = true
-        }
-    }
-
-    check.dependsOn('findbugs')
-
-    pmd {
-        toolVersion PMD_VERSION
-    }
-
-    tasks.create('pmd', Pmd) {
-        targetJdk = TargetJdk.VERSION_1_7
-
-        description 'Run pmd'
-        group 'verification'
-
-        // If ruleSets is not empty, it seems to contain some
-        // defaults which override rules in the ruleset file...
-        ruleSets = []
-        ruleSetFiles = files('pmd-ruleset.xml')
-        source android.sourceSets.main.java.srcDirs
-
-        reports {
-            xml.enabled = false
-            html.enabled = true
-        }
-    }
-
-    check.dependsOn('pmd')
-
-    jacoco {
-        toolVersion JACOCO_VERSION
-    }
-    coveralls {
-        jacocoReportPath = "${project.buildDir}/reports/jacoco/jacocoTestReport/jacocoTestReport.xml"
-    }
-
-    tasks.create("jacocoTestReport", JacocoReport) {
-        dependsOn tasks.testDebugUnitTest
-        def coverageSourceDirs = android.sourceSets.main.java.srcDirs
-        group = "Reporting"
-        description = "Generate Jacoco coverage reports"
-
-        classDirectories = fileTree(
-                dir: "${project.buildDir}/intermediates/classes/debug",
-                excludes: ['**/R.class',
-                           '**/R$*.class',
-                           '**/BuildConfig.*',
-                           '**/Manifest*.*',
-                           '**/BitmapRequestBuilder.class',
-                           '**/DrawableRequestBuilder.class',
-                           '**/GifRequestBuilder.class',]
-        )
-
-        additionalSourceDirs = files(coverageSourceDirs)
-        sourceDirectories = files(coverageSourceDirs)
-        executionData = files("${project.buildDir}/jacoco/testDebug.exec")
-
-        reports {
-            xml.enabled = true
-            html.enabled = true
-        }
-    }
+check.dependsOn(':library:findbugs:findbugs')
+check.dependsOn(':library:pmd:pmd')
+check.dependsOn(':library:test:check')
+
+// Used in pmd and findbugs subprojects.
+@SuppressWarnings("GroovyUnusedDeclaration")
+def classPathForQuality() {
+    return files(
+            android.bootClasspath,
+            project.configurations.compile,
+            project.android.libraryVariants.collect { it.javaCompile.classpath }
+    )
 }
 
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index e9defbbe7..919868ba9 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -38,8 +38,32 @@
 
     <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->
     <Match>
-      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />
+      <Class name="com.bumptech.glide.load.engine.executor.RuntimeCompat" />
       <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
     </Match>
 
+    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->
+    <Match>
+      <Class name="com.bumptech.glide.util.FixedPreloadSizeProvider" />
+      <Bug pattern="EI_EXPOSE_REP" />
+    </Match>
+
+    <!-- We just cache the value of hashcode, no need to also override equals. -->
+    <Match>
+      <Class name="com.bumptech.glide.util.CachedHashCodeArrayMap" />
+      <Bug pattern="EQ_DOESNT_OVERRIDE_EQUALS" />
+    </Match>
+
+    <!-- Inconsistent synchronization is due to synchronizing on Engine/listener to avoid deadlock only. -->
+    <Match>
+      <Class name="com.bumptech.glide.load.engine.EngineResource" />
+      <Bug pattern="IS2_INCONSISTENT_SYNC" />
+    </Match>
+
+     <!-- Inconsistent synchronization is due to synchronizing on Engine/listener to avoid deadlock only. -->
+    <Match>
+      <Class name="com.bumptech.glide.load.engine.EngineJob" />
+      <Bug pattern="IS2_INCONSISTENT_SYNC" />
+    </Match>
+
 </FindBugsFilter>
diff --git a/library/findbugs/build.gradle b/library/findbugs/build.gradle
new file mode 100644
index 000000000..a2e5b3f2a
--- /dev/null
+++ b/library/findbugs/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'findbugs'
+
+findbugs {
+    toolVersion FINDBUGS_VERSION
+}
+
+def library = project(':library')
+
+tasks.create('findbugs', FindBugs) {
+    dependsOn library.tasks.compileDebugJavaWithJavac
+
+    description 'Run findbugs'
+    group 'verification'
+
+    classes = fileTree(library.tasks.compileDebugJavaWithJavac.destinationDir)
+    source library.android.sourceSets.main.java.srcDirs
+    classpath = files()
+    doFirst {
+        classpath += library.classPathForQuality()
+    }
+    effort = 'max'
+    excludeFilter = file("${library.projectDir}/findbugs-exclude.xml")
+
+    // Failures are caught and printed by the violations plugin.
+    ignoreFailures = true
+
+    reports {
+        xml.enabled = true
+        html.enabled = false
+    }
+}
diff --git a/library/lint.xml b/library/lint.xml
index 869eb6598..d904731d9 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
-    <!-- TODO: Fix this after RequestManager#get(View) uses official APIs -->
-    <issue id="RestrictedApi" severity="ignore"/>
+    <issue id="ExifInterface" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore"/>
 </lint>
diff --git a/library/pmd-ruleset.xml b/library/pmd-ruleset.xml
index 76249e191..8297a5c09 100644
--- a/library/pmd-ruleset.xml
+++ b/library/pmd-ruleset.xml
@@ -3,56 +3,168 @@
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
 
-    <description>This ruleset was created from PMD.rul</description>
+    <description>Check for flaws in Glide's codebase.</description>
 
-    <rule ref="rulesets/java/basic.xml">
+    <rule ref="category/java/errorprone.xml">
         <exclude name="AvoidBranchingStatementAsLastInLoop"/>
+        <!-- Not using beans. -->
+        <exclude name="BeanMembersShouldSerialize" />
+        <!-- wat -->
+        <exclude name="AvoidFieldNameMatchingTypeName" />
+        <!-- This is identifying trivial cases that are clearly correct. -->
+        <exclude name="DataflowAnomalyAnalysis" />
+        <!-- Used regularly for object pooling. -->
+        <exclude name="NullAssignment" />
+        <!-- This can make the code easier to read and avoid duplicated logic in some cases. -->
+        <exclude name="AssignmentInOperand" />
+        <!-- I don't think this is confusing. -->
+        <exclude name="AvoidFieldNameMatchingMethodName" />
+        <!-- There are enough cases where this makes sense (typically related to logic around the number of items in a collection) that a blanket ban doesn't seem like a good idea. -->
+        <exclude name="AvoidLiteralsInIfCondition" />
+        <!-- It's clear that this is bad, but we have a number of cases where it makes sense and a blanket ban is irritating. -->
+        <exclude name="AvoidCatchingThrowable" />
     </rule>
-    <rule ref="rulesets/java/braces.xml"/>
-    <rule ref="rulesets/java/strings.xml">
-        <!-- TODO: This warns about annotations, apparently fixed in a later version. -->
-        <exclude name="AvoidDuplicateLiterals"/>
+    <rule ref="category/java/errorprone.xml/AvoidDuplicateLiterals">
+      <properties>
+        <property name="skipAnnotations" value="true" />
+      </properties>
+    </rule>
+    <rule ref="category/java/codestyle.xml">
+      <!-- Abstract classes don't need to have Abstract in the name -->
+      <exclude name="AbstractNaming" />
+      <!-- Who cares? -->
+      <exclude name="AtLeastOneConstructor" />
+      <!-- Don't need to annotate package private methods. -->
+      <exclude name="DefaultPackage" />
+      <exclude name="CommentDefaultAccessModifier" />
+      <!-- Optionally implemented default empty methods are fine. -->
+      <exclude name="EmptyMethodInAbstractClassShouldBeAbstract" />
+      <!-- Why make generics less clear by using shorter names? -->
+      <exclude name="GenericsNaming" />
+      <!-- No need to enforce final if it's not necessary. -->
+      <exclude name="MethodArgumentCouldBeFinal" />
+      <exclude name="LocalVariableCouldBeFinal" />
+      <!-- This isn't always the easiest way to read a method. -->
+      <exclude name="OnlyOneReturn" />
+      <!-- Obfuscated code is best code? -->
+      <exclude name="LongVariable" />
+      <!-- This is not always true. -->
+      <exclude name="ShortClassName" />
+      <!-- A good idea but we have tons of violations. FIXME. -->
+      <exclude name="ShortMethodName" />
+      <exclude name="ShortVariable" />
+      <!-- We don't use in and out to mean modified or not modified by the method, it's useful to match framework methods. -->
+      <exclude name="AvoidPrefixingMethodParameters" />
+      <!-- No idea what this is supposed to accomplish. -->
+      <exclude name="AvoidFinalLocalVariable" />
+      <!-- These are often useful for clarity and explicitly suggested by Google's code style. -->
+      <exclude name="UselessParentheses" />
+      <!-- Theoretically this might be reasonable but the number of imports probably varies from class to class and this doesn't seem worth the overhead to maintain. -->
+      <exclude name="TooManyStaticImports" />
+      <!-- Lots of existing violations, not clear that the overhead is worthwhile though there are some cases where we definitely need to call super. FIXME. -->
+      <exclude name="CallSuperInConstructor" />
+      <!-- This is a reasonable idea, but in practice often the != null case is the expected case and it makes sense for it to come first. -->
+      <exclude name="ConfusingTernary" />
+    </rule>
+    <rule ref="category/java/performance.xml" >
+      <!-- Android may not behave the same as java VMs, using short can be clearer when working with binary data. -->
+      <exclude name="AvoidUsingShortType" />
+      <!-- The suggsted alternatives are not available until Glide's minsdk level is 26+ -->
+      <exclude name="AvoidFileStream" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml" >
+      <!-- Catches any method, test or not, that has the name "tearDown". -->
+      <exclude name="JUnit4TestShouldUseAfterAnnotation" />
+      <!-- This is a good idea, but in practice it's often somewhat clearer than defining a temporary variable and we do it all over the place. -->
+      <exclude name="AvoidReassigningParameters" />
+      <!-- This ignores imports used by javadocs and is worse than the existing checkstyle check. -->
+      <exclude name="UnusedImports" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml/OneDeclarationPerLine">
+      <properties>
+        <property name="strictMode" value="true" />
+        <!-- Allow `for (int i = 0, size = list.size(); i < size; i++) {`
+             Somewhat clearer to set size along with the index. -->
+        <property name="violationSuppressXPath"
+                  value="self::LocalVariableDeclaration
+                           [parent::ForInit]
+                           [Type/PrimitiveType[@Image = 'int']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='i']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='size']
+                           ]
+                        " />
+      </properties>
+    </rule>
+    <rule ref="category/java/bestpractices.xml/AccessorMethodGeneration"
+      message="Avoid autogenerated methods to access private fields and methods of inner / outer classes.
+                       Use @Synthetic to flag members made more visible than necessary to prevent accessors.">
+      <properties>
+        <!-- Ignore references to `private static final * * = <literal>`
+             Suppress via XPath: current node (access that generates the accessor) is .
+             Check if there exists a FieldDeclaration (private static final)
+             which has a VariableInitializer with a Literal
+             and the name (@Image) of the declaration is the same as the accessed member.
+             TODO calculated constants are false positive https://github.com/pmd/pmd/issues/808
+        -->
+        <property name="violationSuppressXPath" value="
+                .[@Image =
+                    //FieldDeclaration[@Private = 'true' and @Static='true' and @Final='true']
+                    /VariableDeclarator[
+                        VariableInitializer/Expression/PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Literal
+                    ]/VariableDeclaratorId/@Image
+                 ]" />
+      </properties>
     </rule>
-    <rule ref="rulesets/java/unusedcode.xml"/>
 
-    <rule ref="rulesets/java/design.xml">
-        <exclude name="ConfusingTernary"/>
-        <exclude name="EmptyMethodInAbstractClassShouldBeAbstract"/>
-        <exclude name="AvoidSynchronizedAtMethodLevel"/>
+    <rule ref="category/java/design.xml">
+        <exclude name="GodClass" />
+        <!-- No idea how you reasonably define this. -->
+        <exclude name="ExcessiveImports" />
+        <exclude name="CouplingBetweenObjects" />
+        <exclude name="TooManyMethods" />
+        <exclude name="LawOfDemeter" />
+        <exclude name="NcssCount" />
+        <exclude name="ExcessiveParameterList" />
+        <exclude name="TooManyFields" />
+        <!-- We don't define any packages to use with this rule. -->
+        <exclude name="LoosePackageCoupling" />
+        <!-- Throwing other types of exceptions doesn't seem to add much to clarify. -->
+        <exclude name="AvoidThrowingRawExceptionTypes" />
+        <exclude name="AvoidThrowingNullPointerException" />
+        <!-- TODO: explore these further. -->
+        <exclude name="CyclomaticComplexity" />
+        <exclude name="NPathComplexity" />
+        <exclude name="ExcessiveMethodLength" />
+        <exclude name="ExcessiveClassLength" />
+        <exclude name="ExcessivePublicCount" />
+        <!-- This is redundant, also caught with AvoidCatchingNPEs. -->
+        <exclude name="AvoidCatchingGenericException" />
+    </rule>
 
+    <rule ref="category/java/multithreading.xml">
+        <exclude name="AvoidSynchronizedAtMethodLevel"/>
         <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
         <exclude name="NonThreadSafeSingleton"/>
-
-        <!-- TODO: Fix these -->
-        <exclude name="AvoidReassigningParameters"/>
-        <exclude name="GodClass"/>
+        <!-- Used frequently in the singleton pattern. -->
+        <exclude name="AvoidUsingVolatile" />
+        <!-- No reason to do this by default. -->
+        <exclude name="UseConcurrentHashMap" />
+        <exclude name="DoNotUseThreads" />
     </rule>
 
-    <rule ref="rulesets/java/empty.xml/EmptyCatchBlock" message="Commented blocks are ok">
+    <rule ref="category/java/errorprone.xml/EmptyCatchBlock" message="Commented blocks are ok">
         <properties>
             <property name="allowCommentedBlocks" value="true"/>
         </properties>
     </rule>
 
 
-    <!--Overrides default check to avoid violation when @Synthetic annotation is present-->
-    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor"
-          message="Document empty constructor">
-
-        <properties>
-            <property name="xpath">
-                <value>
-                    <![CDATA[
-//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and
-($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false'
- and not(../Annotation/MarkerAnnotation/Name[@Image='Synthetic'])]
- ]]>
-                </value>
-            </property>
-
-        </properties>
-
+  <!-- Configures check to avoid violation when @Synthetic annotation is present. -->
+    <rule ref="category/java/documentation.xml/UncommentedEmptyConstructor">
+      <properties>
+        <property name="violationSuppressXPath"
+          value="../Annotation/MarkerAnnotation/Name[@Image='Synthetic']" />
+      </properties>
     </rule>
 
-
 </ruleset>
diff --git a/library/pmd/build.gradle b/library/pmd/build.gradle
new file mode 100644
index 000000000..d02349082
--- /dev/null
+++ b/library/pmd/build.gradle
@@ -0,0 +1,39 @@
+apply plugin: 'pmd'
+
+def library = project(':library')
+
+pmd {
+    toolVersion PMD_VERSION
+}
+
+tasks.create('pmd', Pmd) {
+    dependsOn library.tasks.compileDebugJavaWithJavac
+    targetJdk = TargetJdk.VERSION_1_7
+
+    description 'Run pmd'
+    group 'verification'
+
+    // If ruleSets is not empty, it seems to contain some
+    // defaults which override rules in the ruleset file...
+    ruleSets = []
+    ruleSetFiles = files("${library.projectDir}/pmd-ruleset.xml")
+    source library.android.sourceSets.main.java.srcDirs
+    classpath = files()
+    classpath += files(library.tasks.compileDebugJavaWithJavac.destinationDir)
+    doFirst {
+        classpath += library.classPathForQuality()
+    }
+
+    //TODO enable this once new Gradle containing this flag is out
+    //see https://github.com/gradle/gradle/pull/3125#issuecomment-352442432
+    //incrementalAnalysis = true
+
+    // Failures are caught and printed by the violations plugin.
+    ignoreFailures = true
+
+    reports {
+        xml.enabled = true
+        html.enabled = false
+    }
+}
+
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
index 078afb542..bc714028d 100644
--- a/library/proguard-rules.txt
+++ b/library/proguard-rules.txt
@@ -1,6 +1,11 @@
 -keep public class * implements com.bumptech.glide.module.GlideModule
--keep public class * extends com.bumptech.glide.GeneratedAppGlideModule
--keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
-    **[] $VALUES;
-    public *;
-}
\ No newline at end of file
+-keep class * extends com.bumptech.glide.module.AppGlideModule {
+ <init>(...);
+}
+-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {
+  **[] $VALUES;
+  public *;
+}
+
+# Uncomment for DexGuard only
+#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 06f5c692a..cdae5bd7b 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide">
-
-    <application/>
+    package="com.bumptech.glide">
+  <application/>
 </manifest>
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
index 853990ec2..5f58e1b9d 100644
--- a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.module.AppGlideModule;
 import java.util.Set;
@@ -9,14 +9,11 @@
 /**
  * Allows {@link AppGlideModule}s to exclude {@link com.bumptech.glide.annotation.GlideModule}s to
  * ease the migration from {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation
- * processing system and optionally provides a
- * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} impl.
+ * processing system and optionally provides a {@link
+ * com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} impl.
  */
 abstract class GeneratedAppGlideModule extends AppGlideModule {
-  /**
-   * This method can be removed when manifest parsing is no longer supported.
-   */
-  @Deprecated
+  /** This method can be removed when manifest parsing is no longer supported. */
   @NonNull
   abstract Set<Class<?>> getExcludedModuleClasses();
 
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
index 1fe9588f5..ee9c68492 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.request.transition.ViewPropertyTransition;
 
@@ -9,14 +10,16 @@
  *
  * @param <TranscodeType> The type of the resource that will be displayed.
  */
-@SuppressWarnings("PMD.UseUtilityClass")
-public final class GenericTransitionOptions<TranscodeType> extends
-    TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
+// Public API.
+@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
+public final class GenericTransitionOptions<TranscodeType>
+    extends TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
   /**
    * Removes any existing animation put on the builder.
    *
    * @see GenericTransitionOptions#dontTransition()
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {
     return new GenericTransitionOptions<TranscodeType>().dontTransition();
   }
@@ -26,8 +29,8 @@
    *
    * @see GenericTransitionOptions#transition(int)
    */
-  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
-      int viewAnimationId) {
+  @NonNull
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(int viewAnimationId) {
     return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);
   }
 
@@ -36,8 +39,9 @@
    *
    * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator)
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
-      ViewPropertyTransition.Animator animator) {
+      @NonNull ViewPropertyTransition.Animator animator) {
     return new GenericTransitionOptions<TranscodeType>().transition(animator);
   }
 
@@ -46,8 +50,9 @@
    *
    * @see GenericTransitionOptions#transition(TransitionFactory)
    */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
-      TransitionFactory<? super TranscodeType> transitionFactory) {
+      @NonNull TransitionFactory<? super TranscodeType> transitionFactory) {
     return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index bf2e9fb9f..252edddaa 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ComponentCallbacks2;
+import android.content.ContentResolver;
 import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -11,15 +12,20 @@
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.Build;
+import android.os.MessageQueue.IdleHandler;
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
 import android.util.Log;
 import android.view.View;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -27,6 +33,7 @@
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.prefill.BitmapPreFiller;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
+import com.bumptech.glide.load.engine.prefill.PreFillType.Builder;
 import com.bumptech.glide.load.model.AssetUriLoader;
 import com.bumptech.glide.load.model.ByteArrayLoader;
 import com.bumptech.glide.load.model.ByteBufferEncoder;
@@ -50,13 +57,18 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableEncoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapImageDecoderResourceDecoder;
 import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.ExifInterfaceImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.InputStreamBitmapImageDecoderResourceDecoder;
 import com.bumptech.glide.load.resource.bitmap.ResourceBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.load.resource.bytes.ByteBufferRewinder;
 import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;
 import com.bumptech.glide.load.resource.file.FileDecoder;
 import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -65,10 +77,12 @@
 import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
 import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
+import com.bumptech.glide.load.resource.transcode.DrawableBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.module.ManifestParser;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.Target;
@@ -76,6 +90,7 @@
 import com.bumptech.glide.util.Util;
 import java.io.File;
 import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
@@ -86,11 +101,10 @@
 import java.util.Set;
 
 /**
- * A singleton to present a simple static interface for building requests with
- * {@link RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool},
- * {@link com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
+ * A singleton to present a simple static interface for building requests with {@link
+ * RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool}, {@link
+ * com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class Glide implements ComponentCallbacks2 {
   private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
   private static final String TAG = "Glide";
@@ -100,15 +114,19 @@
   private final Engine engine;
   private final BitmapPool bitmapPool;
   private final MemoryCache memoryCache;
-  private final BitmapPreFiller bitmapPreFiller;
   private final GlideContext glideContext;
   private final Registry registry;
   private final ArrayPool arrayPool;
   private final RequestManagerRetriever requestManagerRetriever;
   private final ConnectivityMonitorFactory connectivityMonitorFactory;
   private final List<RequestManager> managers = new ArrayList<>();
+  private final RequestOptionsFactory defaultRequestOptionsFactory;
   private MemoryCategory memoryCategory = MemoryCategory.NORMAL;
 
+  @GuardedBy("this")
+  @Nullable
+  private BitmapPreFiller bitmapPreFiller;
+
   /**
    * Returns a directory with a default name in the private cache directory of the application to
    * use to store retrieved media and thumbnails.
@@ -117,7 +135,7 @@
    * @see #getPhotoCacheDir(android.content.Context, String)
    */
   @Nullable
-  public static File getPhotoCacheDir(Context context) {
+  public static File getPhotoCacheDir(@NonNull Context context) {
     return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
   }
 
@@ -125,12 +143,12 @@ public static File getPhotoCacheDir(Context context) {
    * Returns a directory with the given name in the private cache directory of the application to
    * use to store retrieved media and thumbnails.
    *
-   * @param context   A context.
+   * @param context A context.
    * @param cacheName The name of the subdirectory in which to store the cache.
    * @see #getPhotoCacheDir(android.content.Context)
    */
   @Nullable
-  public static File getPhotoCacheDir(Context context, String cacheName) {
+  public static File getPhotoCacheDir(@NonNull Context context, @NonNull String cacheName) {
     File cacheDir = context.getCacheDir();
     if (cacheDir != null) {
       File result = new File(cacheDir, cacheName);
@@ -151,11 +169,14 @@ public static File getPhotoCacheDir(Context context, String cacheName) {
    *
    * @return the singleton
    */
-  public static Glide get(Context context) {
+  @NonNull
+  public static Glide get(@NonNull Context context) {
     if (glide == null) {
+      GeneratedAppGlideModule annotationGeneratedModule =
+          getAnnotationGeneratedGlideModules(context.getApplicationContext());
       synchronized (Glide.class) {
         if (glide == null) {
-          checkAndInitializeGlide(context);
+          checkAndInitializeGlide(context, annotationGeneratedModule);
         }
       }
     }
@@ -163,33 +184,68 @@ public static Glide get(Context context) {
     return glide;
   }
 
-  private static void checkAndInitializeGlide(Context context) {
+  @GuardedBy("Glide.class")
+  private static void checkAndInitializeGlide(
+      @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) {
     // In the thread running initGlide(), one or more classes may call Glide.get(context).
     // Without this check, those calls could trigger infinite recursion.
     if (isInitializing) {
-      throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),"
-          + " use the provided Glide instance instead");
+      throw new IllegalStateException(
+          "You cannot call Glide.get() in registerComponents(),"
+              + " use the provided Glide instance instead");
     }
     isInitializing = true;
-    initializeGlide(context);
+    initializeGlide(context, generatedAppGlideModule);
     isInitializing = false;
   }
 
+  /**
+   * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with Glide's
+   *     generated API.
+   *     <p>This method will be removed in a future version of Glide.
+   */
   @VisibleForTesting
+  @Deprecated
   public static synchronized void init(Glide glide) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
     Glide.glide = glide;
   }
 
+  @VisibleForTesting
+  public static void init(@NonNull Context context, @NonNull GlideBuilder builder) {
+    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules(context);
+    synchronized (Glide.class) {
+      if (Glide.glide != null) {
+        tearDown();
+      }
+      initializeGlide(context, builder, annotationGeneratedModule);
+    }
+  }
+
   @VisibleForTesting
   public static synchronized void tearDown() {
+    if (glide != null) {
+      glide.getContext().getApplicationContext().unregisterComponentCallbacks(glide);
+      glide.engine.shutdown();
+    }
     glide = null;
   }
 
+  @GuardedBy("Glide.class")
+  private static void initializeGlide(
+      @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) {
+    initializeGlide(context, new GlideBuilder(), generatedAppGlideModule);
+  }
+
+  @GuardedBy("Glide.class")
   @SuppressWarnings("deprecation")
-  private static void initializeGlide(Context context) {
+  private static void initializeGlide(
+      @NonNull Context context,
+      @NonNull GlideBuilder builder,
+      @Nullable GeneratedAppGlideModule annotationGeneratedModule) {
     Context applicationContext = context.getApplicationContext();
-
-    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
     List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
     if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
       manifestModules = new ManifestParser(applicationContext).parse();
@@ -197,8 +253,7 @@ private static void initializeGlide(Context context) {
 
     if (annotationGeneratedModule != null
         && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
-      Set<Class<?>> excludedModuleClasses =
-          annotationGeneratedModule.getExcludedModuleClasses();
+      Set<Class<?>> excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();
       Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
       while (iterator.hasNext()) {
         com.bumptech.glide.module.GlideModule current = iterator.next();
@@ -220,9 +275,9 @@ private static void initializeGlide(Context context) {
 
     RequestManagerRetriever.RequestManagerFactory factory =
         annotationGeneratedModule != null
-            ? annotationGeneratedModule.getRequestManagerFactory() : null;
-    GlideBuilder builder = new GlideBuilder()
-        .setRequestManagerFactory(factory);
+            ? annotationGeneratedModule.getRequestManagerFactory()
+            : null;
+    builder.setRequestManagerFactory(factory);
     for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       module.applyOptions(applicationContext, builder);
     }
@@ -231,112 +286,194 @@ private static void initializeGlide(Context context) {
     }
     Glide glide = builder.build(applicationContext);
     for (com.bumptech.glide.module.GlideModule module : manifestModules) {
-      module.registerComponents(applicationContext, glide, glide.registry);
+      try {
+        module.registerComponents(applicationContext, glide, glide.registry);
+      } catch (AbstractMethodError e) {
+        throw new IllegalStateException(
+            "Attempting to register a Glide v3 module. If you see this, you or one of your"
+                + " dependencies may be including Glide v3 even though you're using Glide v4."
+                + " You'll need to find and remove (or update) the offending dependency."
+                + " The v3 module name is: "
+                + module.getClass().getName(),
+            e);
+      }
     }
     if (annotationGeneratedModule != null) {
       annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
     }
-    context.getApplicationContext().registerComponentCallbacks(glide);
+    applicationContext.registerComponentCallbacks(glide);
     Glide.glide = glide;
   }
 
   @Nullable
-  @SuppressWarnings({"unchecked", "deprecation", "TryWithIdenticalCatches"})
-  private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
+  @SuppressWarnings({"unchecked", "TryWithIdenticalCatches", "PMD.UnusedFormalParameter"})
+  private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules(Context context) {
     GeneratedAppGlideModule result = null;
     try {
       Class<GeneratedAppGlideModule> clazz =
           (Class<GeneratedAppGlideModule>)
               Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
-      result = clazz.newInstance();
+      result =
+          clazz.getDeclaredConstructor(Context.class).newInstance(context.getApplicationContext());
     } catch (ClassNotFoundException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
-            + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
-            + " in your application and a @GlideModule annotated AppGlideModule implementation or"
-            + " LibraryGlideModules will be silently ignored");
+        Log.w(
+            TAG,
+            "Failed to find GeneratedAppGlideModule. You should include an"
+                + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
+                + " in your application and a @GlideModule annotated AppGlideModule implementation"
+                + " or LibraryGlideModules will be silently ignored");
       }
-    } catch (InstantiationException e) {
-      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
-          + " If you've manually implemented this class, remove your implementation. The Annotation"
-          + " processor will generate a correct implementation.", e);
       // These exceptions can't be squashed across all versions of Android.
+    } catch (InstantiationException e) {
+      throwIncorrectGlideModule(e);
     } catch (IllegalAccessException e) {
-      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
-          + " If you've manually implemented this class, remove your implementation. The Annotation"
-          + " processor will generate a correct implementation.", e);
+      throwIncorrectGlideModule(e);
+    } catch (NoSuchMethodException e) {
+      throwIncorrectGlideModule(e);
+    } catch (InvocationTargetException e) {
+      throwIncorrectGlideModule(e);
     }
     return result;
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+  private static void throwIncorrectGlideModule(Exception e) {
+    throw new IllegalStateException(
+        "GeneratedAppGlideModuleImpl is implemented incorrectly."
+            + " If you've manually implemented this class, remove your implementation. The"
+            + " Annotation processor will generate a correct implementation.",
+        e);
+  }
+
+  @SuppressWarnings("PMD.UnusedFormalParameter")
   Glide(
-      Context context,
-      Engine engine,
-      MemoryCache memoryCache,
-      BitmapPool bitmapPool,
-      ArrayPool arrayPool,
-      RequestManagerRetriever requestManagerRetriever,
-      ConnectivityMonitorFactory connectivityMonitorFactory,
+      @NonNull Context context,
+      @NonNull Engine engine,
+      @NonNull MemoryCache memoryCache,
+      @NonNull BitmapPool bitmapPool,
+      @NonNull ArrayPool arrayPool,
+      @NonNull RequestManagerRetriever requestManagerRetriever,
+      @NonNull ConnectivityMonitorFactory connectivityMonitorFactory,
       int logLevel,
-      RequestOptions defaultRequestOptions,
-      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
+      @NonNull RequestOptionsFactory defaultRequestOptionsFactory,
+      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
+      @NonNull List<RequestListener<Object>> defaultRequestListeners,
+      boolean isLoggingRequestOriginsEnabled,
+      boolean isImageDecoderEnabledForBitmaps,
+      int hardwareBitmapFdLimit) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
     this.memoryCache = memoryCache;
     this.requestManagerRetriever = requestManagerRetriever;
     this.connectivityMonitorFactory = connectivityMonitorFactory;
-
-    DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
-    bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
+    this.defaultRequestOptionsFactory = defaultRequestOptionsFactory;
 
     final Resources resources = context.getResources();
 
     registry = new Registry();
     registry.register(new DefaultImageHeaderParser());
+    // Right now we're only using this parser for HEIF images, which are only supported on OMR1+.
+    // If we need this for other file types, we should consider removing this restriction.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {
+      registry.register(new ExifInterfaceImageHeaderParser());
+    }
+
+    List<ImageHeaderParser> imageHeaderParsers = registry.getImageHeaderParsers();
 
-    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
-        resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
-        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+        new ByteBufferGifDecoder(context, imageHeaderParsers, bitmapPool, arrayPool);
+    ResourceDecoder<ParcelFileDescriptor, Bitmap> parcelFileDescriptorVideoDecoder =
+        VideoDecoder.parcel(bitmapPool);
+
+    ResourceDecoder<ByteBuffer, Bitmap> byteBufferBitmapDecoder;
+    ResourceDecoder<InputStream, Bitmap> streamBitmapDecoder;
+    if (isImageDecoderEnabledForBitmaps && Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
+      streamBitmapDecoder = new InputStreamBitmapImageDecoderResourceDecoder();
+      byteBufferBitmapDecoder = new ByteBufferBitmapImageDecoderResourceDecoder();
+    } else {
+      Downsampler downsampler =
+          new Downsampler(
+              registry.getImageHeaderParsers(),
+              resources.getDisplayMetrics(),
+              bitmapPool,
+              arrayPool);
+      byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
+      streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
+    }
+
+    ResourceDrawableDecoder resourceDrawableDecoder = new ResourceDrawableDecoder(context);
+    ResourceLoader.StreamFactory resourceLoaderStreamFactory =
+        new ResourceLoader.StreamFactory(resources);
+    ResourceLoader.UriFactory resourceLoaderUriFactory = new ResourceLoader.UriFactory(resources);
+    ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
+        new ResourceLoader.FileDescriptorFactory(resources);
+    ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
+        new ResourceLoader.AssetFileDescriptorFactory(resources);
+    BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);
+
+    BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();
+    GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();
+
+    ContentResolver contentResolver = context.getContentResolver();
 
     registry
         .append(ByteBuffer.class, new ByteBufferEncoder())
         .append(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
-        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class,
-            new ByteBufferBitmapDecoder(downsampler))
-        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class,
-            new StreamBitmapDecoder(downsampler, arrayPool))
-        .append(Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class,
-            new VideoBitmapDecoder(bitmapPool))
-        .append(Bitmap.class, new BitmapEncoder())
-        /* GlideBitmapDrawables */
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, ByteBuffer.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new ByteBufferBitmapDecoder(downsampler)))
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, InputStream.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new StreamBitmapDecoder(downsampler, arrayPool)))
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, ParcelFileDescriptor.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
-        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
+        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)
+        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)
+        .append(
+            Registry.BUCKET_BITMAP,
+            ParcelFileDescriptor.class,
+            Bitmap.class,
+            parcelFileDescriptorVideoDecoder)
+        .append(
+            Registry.BUCKET_BITMAP,
+            AssetFileDescriptor.class,
+            Bitmap.class,
+            VideoDecoder.asset(bitmapPool))
+        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
+        .append(Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
+        .append(Bitmap.class, bitmapEncoder)
+        /* BitmapDrawables */
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ByteBuffer.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, byteBufferBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            InputStream.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, streamBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ParcelFileDescriptor.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, parcelFileDescriptorVideoDecoder))
+        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
         /* GIFs */
-        .append(Registry.BUCKET_GIF, InputStream.class, GifDrawable.class,
-            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
+        .append(
+            Registry.BUCKET_GIF,
+            InputStream.class,
+            GifDrawable.class,
+            new StreamGifDecoder(imageHeaderParsers, byteBufferGifDecoder, arrayPool))
         .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
         .append(GifDrawable.class, new GifDrawableEncoder())
         /* GIF Frames */
         // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
-        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
-        .append(Registry.BUCKET_BITMAP, GifDecoder.class, Bitmap.class,
+        .append(
+            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP,
+            GifDecoder.class,
+            Bitmap.class,
             new GifFrameResourceDecoder(bitmapPool))
         /* Drawables */
-        .append(Uri.class, Drawable.class, new ResourceDrawableDecoder(context, bitmapPool))
-        .append(Uri.class, Bitmap.class,
-            new ResourceBitmapDecoder(
-                new ResourceDrawableDecoder(context, bitmapPool), bitmapPool))
+        .append(Uri.class, Drawable.class, resourceDrawableDecoder)
+        .append(
+            Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))
         /* Files */
         .register(new ByteBufferRewinder.Factory())
         .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
@@ -344,56 +481,72 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         .append(File.class, File.class, new FileDecoder())
         .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
         // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
-        .append(File.class, File.class, new UnitModelLoader.Factory<File>())
+        .append(File.class, File.class, UnitModelLoader.Factory.<File>getInstance())
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
-        .append(
-                int.class,
-                ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
-        .append(
-                Integer.class,
-                ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
-        .append(Integer.class, Uri.class, new ResourceLoader.UriFactory(resources))
-        .append(int.class, Uri.class, new ResourceLoader.UriFactory(resources))
-        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
+        .append(int.class, InputStream.class, resourceLoaderStreamFactory)
+        .append(int.class, ParcelFileDescriptor.class, resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
+        .append(Integer.class, ParcelFileDescriptor.class, resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, Uri.class, resourceLoaderUriFactory)
+        .append(int.class, AssetFileDescriptor.class, resourceLoaderAssetFileDescriptorFactory)
+        .append(Integer.class, AssetFileDescriptor.class, resourceLoaderAssetFileDescriptorFactory)
+        .append(int.class, Uri.class, resourceLoaderUriFactory)
+        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
+        .append(Uri.class, InputStream.class, new DataUrlLoader.StreamFactory<Uri>())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
+        .append(
+            String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
         .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
         .append(
-                Uri.class,
-                ParcelFileDescriptor.class,
-                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+            Uri.class,
+            ParcelFileDescriptor.class,
+            new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
         .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
         .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
+        .append(Uri.class, InputStream.class, new UriLoader.StreamFactory(contentResolver))
         .append(
             Uri.class,
-            InputStream.class,
-            new UriLoader.StreamFactory(context.getContentResolver()))
-        .append(Uri.class, ParcelFileDescriptor.class,
-             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
+            ParcelFileDescriptor.class,
+            new UriLoader.FileDescriptorFactory(contentResolver))
+        .append(
+            Uri.class,
+            AssetFileDescriptor.class,
+            new UriLoader.AssetFileDescriptorFactory(contentResolver))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
         .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
-        .append(Uri.class, Uri.class, new UnitModelLoader.Factory<Uri>())
+        .append(Uri.class, Uri.class, UnitModelLoader.Factory.<Uri>getInstance())
+        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance())
+        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())
         /* Transcoders */
-        .register(Bitmap.class, BitmapDrawable.class,
-            new BitmapDrawableTranscoder(resources, bitmapPool))
-        .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
-        .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
+        .register(Bitmap.class, BitmapDrawable.class, new BitmapDrawableTranscoder(resources))
+        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)
+        .register(
+            Drawable.class,
+            byte[].class,
+            new DrawableBytesTranscoder(
+                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))
+        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);
 
     ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
     glideContext =
         new GlideContext(
-            context, registry, imageViewTargetFactory, defaultRequestOptions,
-            defaultTransitionOptions, engine, logLevel);
+            context,
+            arrayPool,
+            registry,
+            imageViewTargetFactory,
+            defaultRequestOptionsFactory,
+            defaultTransitionOptions,
+            defaultRequestListeners,
+            engine,
+            isLoggingRequestOriginsEnabled,
+            logLevel);
   }
 
   /**
@@ -401,31 +554,31 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
    * temporarily store {@link android.graphics.Bitmap}s so they can be reused to avoid garbage
    * collections.
    *
-   * <p> Note - Using this pool directly can lead to undefined behavior and strange drawing errors.
+   * <p>Note - Using this pool directly can lead to undefined behavior and strange drawing errors.
    * Any {@link android.graphics.Bitmap} added to the pool must not be currently in use in any other
    * part of the application. Any {@link android.graphics.Bitmap} added to the pool must be removed
-   * from the pool before it is added a second time. </p>
+   * from the pool before it is added a second time.
    *
-   * <p> Note - To make effective use of the pool, any {@link android.graphics.Bitmap} removed from
+   * <p>Note - To make effective use of the pool, any {@link android.graphics.Bitmap} removed from
    * the pool must eventually be re-added. Otherwise the pool will eventually empty and will not
-   * serve any useful purpose. </p>
+   * serve any useful purpose.
    *
-   * <p> The primary reason this object is exposed is for use in custom
-   * {@link com.bumptech.glide.load.ResourceDecoder}s and
-   * {@link com.bumptech.glide.load.Transformation}s. Use outside of these classes is not generally
-   * recommended. </p>
+   * <p>The primary reason this object is exposed is for use in custom {@link
+   * com.bumptech.glide.load.ResourceDecoder}s and {@link com.bumptech.glide.load.Transformation}s.
+   * Use outside of these classes is not generally recommended.
    */
+  @NonNull
   public BitmapPool getBitmapPool() {
     return bitmapPool;
   }
 
+  @NonNull
   public ArrayPool getArrayPool() {
     return arrayPool;
   }
 
-  /**
-   * @return The context associated with this instance.
-   */
+  /** @return The context associated with this instance. */
+  @NonNull
   public Context getContext() {
     return glideContext.getBaseContext();
   }
@@ -434,36 +587,40 @@ ConnectivityMonitorFactory getConnectivityMonitorFactory() {
     return connectivityMonitorFactory;
   }
 
+  @NonNull
   GlideContext getGlideContext() {
     return glideContext;
   }
 
   /**
-   * Pre-fills the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} using the given
-   * sizes.
+   * Pre-fills the {@link BitmapPool} using the given sizes.
    *
-   * <p> Enough Bitmaps are added to completely fill the pool, so most or all of the Bitmaps
+   * <p>Enough Bitmaps are added to completely fill the pool, so most or all of the Bitmaps
    * currently in the pool will be evicted. Bitmaps are allocated according to the weights of the
    * given sizes, where each size gets (weight / prefillWeightSum) percent of the pool to fill.
-   * </p>
    *
-   * <p> Note - Pre-filling is done asynchronously using and
-   * {@link android.os.MessageQueue.IdleHandler}. Any currently running pre-fill will be cancelled
-   * and replaced by a call to this method. </p>
+   * <p>Note - Pre-filling is done asynchronously using and {@link IdleHandler}. Any currently
+   * running pre-fill will be cancelled and replaced by a call to this method.
    *
-   * <p> This method should be used with caution, overly aggressive pre-filling is substantially
+   * <p>This method should be used with caution, overly aggressive pre-filling is substantially
    * worse than not pre-filling at all. Pre-filling should only be started in onCreate to avoid
-   * constantly clearing and re-filling the
-   * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}. Rotation should be carefully
+   * constantly clearing and re-filling the {@link BitmapPool}. Rotation should be carefully
    * considered as well. It may be worth calling this method only when no saved instance state
    * exists so that pre-filling only happens when the Activity is first created, rather than on
-   * every rotation. </p>
+   * every rotation.
    *
-   * @param bitmapAttributeBuilders The list of
-   * {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
-   * individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
+   * @param bitmapAttributeBuilders The list of {@link Builder Builders} representing individual
+   *     sizes and configurations of {@link Bitmap}s to be pre-filled.
    */
-  public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
+  @SuppressWarnings("unused") // Public API
+  public synchronized void preFillBitmapPool(
+      @NonNull PreFillType.Builder... bitmapAttributeBuilders) {
+    if (bitmapPreFiller == null) {
+      DecodeFormat decodeFormat =
+          defaultRequestOptionsFactory.build().getOptions().get(Downsampler.DECODE_FORMAT);
+      bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
+    }
+
     bitmapPreFiller.preFill(bitmapAttributeBuilders);
   }
 
@@ -499,20 +656,17 @@ public void trimMemory(int level) {
   /**
    * Clears disk cache.
    *
-   * <p>
-   *     This method should always be called on a background thread, since it is a blocking call.
-   * </p>
+   * <p>This method should always be called on a background thread, since it is a blocking call.
    */
-  @SuppressWarnings("unused") // Public API
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public void clearDiskCache() {
     Util.assertBackgroundThread();
     engine.clearDiskCache();
   }
 
-
-  /**
-   * Internal method.
-   */
+  /** Internal method. */
+  @NonNull
   public RequestManagerRetriever getRequestManagerRetriever() {
     return requestManagerRetriever;
   }
@@ -520,16 +674,18 @@ public RequestManagerRetriever getRequestManagerRetriever() {
   /**
    * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
    *
-   * <p> The default {@link MemoryCategory} is {@link MemoryCategory#NORMAL}.
-   * {@link MemoryCategory#HIGH} increases Glide's maximum memory usage by up to 50% and
-   * {@link MemoryCategory#LOW} decreases Glide's maximum memory usage by 50%. This method should be
-   * used to temporarily increase or decrease memory usage for a single Activity or part of the app.
-   * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want
-   * to change the default. </p>
+   * <p>The default {@link MemoryCategory} is {@link MemoryCategory#NORMAL}. {@link
+   * MemoryCategory#HIGH} increases Glide's maximum memory usage by up to 50% and {@link
+   * MemoryCategory#LOW} decreases Glide's maximum memory usage by 50%. This method should be used
+   * to temporarily increase or decrease memory usage for a single Activity or part of the app. Use
+   * {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want to
+   * change the default.
    *
    * @return the previous MemoryCategory used by Glide.
    */
-  public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public MemoryCategory setMemoryCategory(@NonNull MemoryCategory memoryCategory) {
     // Engine asserts this anyway when removing resources, fail faster and consistently
     Util.assertMainThread();
     // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
@@ -540,12 +696,13 @@ public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
     return oldCategory;
   }
 
+  @NonNull
   private static RequestManagerRetriever getRetriever(@Nullable Context context) {
     // Context could be null for other reasons (ie the user passes in null), but in practice it will
     // only occur due to errors with the Fragment lifecycle.
     Preconditions.checkNotNull(
         context,
-        "You cannot start a load on a not yet attached View or a  Fragment where getActivity() "
+        "You cannot start a load on a not yet attached View or a Fragment where getActivity() "
             + "returns null (which usually occurs when getActivity() is called before the Fragment "
             + "is attached or after the Fragment is destroyed).");
     return Glide.get(context).getRequestManagerRetriever();
@@ -554,26 +711,27 @@ private static RequestManagerRetriever getRetriever(@Nullable Context context) {
   /**
    * Begin a load with Glide by passing in a context.
    *
-   * <p> Any requests started using a context will only have the application level options applied
+   * <p>Any requests started using a context will only have the application level options applied
    * and will not be started or stopped based on lifecycle events. In general, loads should be
    * started at the level the result will be used in. If the resource will be used in a view in a
    * child fragment, the load should be started with {@link #with(android.app.Fragment)}} using that
    * child fragment. Similarly, if the resource will be used in a view in the parent fragment, the
    * load should be started with {@link #with(android.app.Fragment)} using the parent fragment. In
    * the same vein, if the resource will be used in a view in an activity, the load should be
-   * started with {@link #with(android.app.Activity)}}. </p>
+   * started with {@link #with(android.app.Activity)}}.
    *
-   * <p> This method is appropriate for resources that will be used outside of the normal fragment
-   * or activity lifecycle (For example in services, or for notification thumbnails). </p>
+   * <p>This method is appropriate for resources that will be used outside of the normal fragment or
+   * activity lifecycle (For example in services, or for notification thumbnails).
    *
    * @param context Any context, will not be retained.
    * @return A RequestManager for the top level application that can be used to start a load.
    * @see #with(android.app.Activity)
    * @see #with(android.app.Fragment)
-   * @see #with(android.support.v4.app.Fragment)
-   * @see #with(android.support.v4.app.FragmentActivity)
+   * @see #with(androidx.fragment.app.Fragment)
+   * @see #with(androidx.fragment.app.FragmentActivity)
    */
-  public static RequestManager with(Context context) {
+  @NonNull
+  public static RequestManager with(@NonNull Context context) {
     return getRetriever(context).get(context);
   }
 
@@ -584,48 +742,56 @@ public static RequestManager with(Context context) {
    * @param activity The activity to use.
    * @return A RequestManager for the given activity that can be used to start a load.
    */
-  public static RequestManager with(Activity activity) {
+  @NonNull
+  public static RequestManager with(@NonNull Activity activity) {
     return getRetriever(activity).get(activity);
   }
 
   /**
-   * Begin a load with Glide that will tied to the give
-   * {@link android.support.v4.app.FragmentActivity}'s lifecycle and that uses the given
-   * {@link android.support.v4.app.FragmentActivity}'s default options.
+   * Begin a load with Glide that will tied to the give {@link
+   * androidx.fragment.app.FragmentActivity}'s lifecycle and that uses the given {@link
+   * androidx.fragment.app.FragmentActivity}'s default options.
    *
    * @param activity The activity to use.
    * @return A RequestManager for the given FragmentActivity that can be used to start a load.
    */
-  public static RequestManager with(FragmentActivity activity) {
+  @NonNull
+  public static RequestManager with(@NonNull FragmentActivity activity) {
     return getRetriever(activity).get(activity);
   }
 
   /**
-   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
-   * and that uses the given {@link android.app.Fragment}'s default options.
+   * Begin a load with Glide that will be tied to the given {@link androidx.fragment.app.Fragment}'s
+   * lifecycle and that uses the given {@link androidx.fragment.app.Fragment}'s default options.
    *
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
-  public static RequestManager with(android.app.Fragment fragment) {
-    return getRetriever(fragment.getActivity()).get(fragment);
+  @NonNull
+  public static RequestManager with(@NonNull Fragment fragment) {
+    return getRetriever(fragment.getContext()).get(fragment);
   }
 
   /**
-   * Begin a load with Glide that will be tied to the given
-   * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
-   * {@link android.support.v4.app.Fragment}'s default options.
+   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
+   * and that uses the given {@link android.app.Fragment}'s default options.
    *
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
+   * @deprecated Prefer support Fragments and {@link #with(Fragment)} instead, {@link
+   *     android.app.Fragment} will be deprecated. See
+   *     https://github.com/android/android-ktx/pull/161#issuecomment-363270555.
    */
-  public static RequestManager with(Fragment fragment) {
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
+  public static RequestManager with(@NonNull android.app.Fragment fragment) {
     return getRetriever(fragment.getActivity()).get(fragment);
   }
 
   /**
-   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},
-   * {@link android.app.Fragment}, or {@link Activity} that contains the View.
+   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment}, {@link
+   * android.app.Fragment}, or {@link Activity} that contains the View.
    *
    * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View
    * is a child of the View returned by the {@link Fragment#getView()}} method.
@@ -642,29 +808,32 @@ public static RequestManager with(Fragment fragment) {
    * avoiding entirely or using the {@link Fragment}s from the support library instead.
    *
    * <p>If the support {@link FragmentActivity} class is used, this method will only attempt to
-   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached
-   * to the {@link FragmentActivity} will be ignored.
+   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached to
+   * the {@link FragmentActivity} will be ignored.
    *
    * @param view The view to search for a containing Fragment or Activity from.
    * @return A RequestManager that can be used to start a load.
    */
-  public static RequestManager with(View view) {
+  @NonNull
+  public static RequestManager with(@NonNull View view) {
     return getRetriever(view.getContext()).get(view);
   }
 
+  @NonNull
   public Registry getRegistry() {
     return registry;
   }
 
-  void removeFromManagers(Target<?> target) {
+  boolean removeFromManagers(@NonNull Target<?> target) {
     synchronized (managers) {
       for (RequestManager requestManager : managers) {
         if (requestManager.untrack(target)) {
-          return;
+          return true;
         }
       }
     }
-    throw new IllegalStateException("Failed to remove target from managers");
+
+    return false;
   }
 
   void registerRequestManager(RequestManager requestManager) {
@@ -699,4 +868,12 @@ public void onConfigurationChanged(Configuration newConfig) {
   public void onLowMemory() {
     clearMemory();
   }
+
+  /** Creates a new instance of {@link RequestOptions}. */
+  public interface RequestOptionsFactory {
+
+    /** Returns a non-null {@link RequestOptions} object. */
+    @NonNull
+    RequestOptions build();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 1276daea8..1162e7a6e 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -1,12 +1,16 @@
 package com.bumptech.glide;
 
 import android.content.Context;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.v4.util.ArrayMap;
+import android.graphics.Bitmap;
 import android.util.Log;
-import com.bumptech.glide.load.DecodeFormat;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.collection.ArrayMap;
+import androidx.core.os.BuildCompat;
+import com.bumptech.glide.Glide.RequestOptionsFactory;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
@@ -18,16 +22,23 @@
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.resource.bitmap.HardwareConfigState;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 
-/**
- * A builder class for setting default structural classes for Glide to use.
- */
+/** A builder class for setting default structural classes for Glide to use. */
+@SuppressWarnings("PMD.ImmutableField")
 public final class GlideBuilder {
   private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions = new ArrayMap<>();
   private Engine engine;
@@ -40,9 +51,23 @@
   private MemorySizeCalculator memorySizeCalculator;
   private ConnectivityMonitorFactory connectivityMonitorFactory;
   private int logLevel = Log.INFO;
-  private RequestOptions defaultRequestOptions = new RequestOptions();
-  @Nullable
-  private RequestManagerFactory requestManagerFactory;
+  private RequestOptionsFactory defaultRequestOptionsFactory =
+      new RequestOptionsFactory() {
+        @NonNull
+        @Override
+        public RequestOptions build() {
+          return new RequestOptions();
+        }
+      };
+  @Nullable private RequestManagerFactory requestManagerFactory;
+  private GlideExecutor animationExecutor;
+  private boolean isActiveResourceRetentionAllowed;
+  @Nullable private List<RequestListener<Object>> defaultRequestListeners;
+  private boolean isLoggingRequestOriginsEnabled;
+
+  private boolean isImageDecoderEnabledForBitmaps;
+
+  private int hardwareBitmapFdLimit = HardwareConfigState.DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -51,19 +76,21 @@
    * @param bitmapPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
+  @NonNull
+  public GlideBuilder setBitmapPool(@Nullable BitmapPool bitmapPool) {
     this.bitmapPool = bitmapPool;
     return this;
   }
 
   /**
-   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored
-   * and retrieved as needed.
+   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored and
+   * retrieved as needed.
    *
    * @param arrayPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setArrayPool(ArrayPool arrayPool) {
+  @NonNull
+  public GlideBuilder setArrayPool(@Nullable ArrayPool arrayPool) {
     this.arrayPool = arrayPool;
     return this;
   }
@@ -75,31 +102,14 @@ public GlideBuilder setArrayPool(ArrayPool arrayPool) {
    * @param memoryCache The cache to use.
    * @return This builder.
    */
-  public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setMemoryCache(@Nullable MemoryCache memoryCache) {
     this.memoryCache = memoryCache;
     return this;
   }
 
-  /**
-   * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
-   * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
-   *
-   * @param diskCache The disk cache to use.
-   * @return This builder.
-   * @deprecated Creating a disk cache directory on the main thread causes strict mode violations,
-   * use {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead.
-   * Scheduled to be removed in Glide 4.0.
-   */
-  @Deprecated
-  public GlideBuilder setDiskCache(final DiskCache diskCache) {
-    return setDiskCache(new DiskCache.Factory() {
-      @Override
-      public DiskCache build() {
-        return diskCache;
-      }
-    });
-  }
-
   /**
    * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use
    * to construct the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store {@link
@@ -108,57 +118,139 @@ public DiskCache build() {
    * @param diskCacheFactory The disk cache factory to use.
    * @return This builder.
    */
-  public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setDiskCache(@Nullable DiskCache.Factory diskCacheFactory) {
     this.diskCacheFactory = diskCacheFactory;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   * Sets the {@link GlideExecutor} to use when retrieving {@link
+   * com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   *
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
+   *
+   * @param service The ExecutorService to use.
+   * @return This builder.
+   * @see #setDiskCacheExecutor(GlideExecutor)
+   * @see GlideExecutor
+   * @deprecated Use {@link #setSourceExecutor(GlideExecutor)}
+   */
+  @Deprecated
+  public GlideBuilder setResizeExecutor(@Nullable GlideExecutor service) {
+    return setSourceExecutor(service);
+  }
+
+  /**
+   * Sets the {@link GlideExecutor} to use when retrieving {@link
+   * com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   *
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
    *
    * @param service The ExecutorService to use.
    * @return This builder.
    * @see #setDiskCacheExecutor(GlideExecutor)
    * @see GlideExecutor
    */
-  public GlideBuilder setResizeExecutor(GlideExecutor service) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setSourceExecutor(@Nullable GlideExecutor service) {
     this.sourceExecutor = service;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
+   * Sets the {@link GlideExecutor} to use when retrieving {@link
+   * com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>Defaults to a single thread which is usually the best combination of memory usage, jank, and
+   * performance, even on high end devices.
    *
-   * @param service The ExecutorService to use.
+   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options for
+   * the disk cache executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
    * @return This builder.
-   * @see #setResizeExecutor(GlideExecutor)
+   * @see #setSourceExecutor(GlideExecutor)
    * @see GlideExecutor
    */
-  public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setDiskCacheExecutor(@Nullable GlideExecutor service) {
     this.diskCacheExecutor = service;
     return this;
   }
 
+  /**
+   * Sets the {@link GlideExecutor} to use when loading frames of animated images and particularly
+   * of {@link com.bumptech.glide.load.resource.gif.GifDrawable}s.
+   *
+   * <p>Defaults to one or two threads, depending on the number of cores available.
+   *
+   * <p>Use the {@link GlideExecutor#newAnimationExecutor()} methods if you'd like to specify
+   * options for the animation executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
+   * @return This builder.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setAnimationExecutor(@Nullable GlideExecutor service) {
+    this.animationExecutor = service;
+    return this;
+  }
+
   /**
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
-   * <p>Applying additional options with {@link
-   * RequestBuilder#apply(RequestOptions)} will override defaults
-   * set here.
+   * <p>Applying additional options with {@link RequestBuilder#apply(BaseRequestOptions)} will
+   * override defaults set here.
    *
+   * @see #setDefaultRequestOptions(RequestOptionsFactory)
    * @param requestOptions The options to use by default.
    * @return This builder.
    */
-  public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
-    this.defaultRequestOptions = requestOptions;
+  @NonNull
+  public GlideBuilder setDefaultRequestOptions(@Nullable final RequestOptions requestOptions) {
+    return setDefaultRequestOptions(
+        new RequestOptionsFactory() {
+          @NonNull
+          @Override
+          public RequestOptions build() {
+            return requestOptions != null ? requestOptions : new RequestOptions();
+          }
+        });
+  }
+
+  /**
+   * Sets a factory for the default {@link RequestOptions} to use for all loads across the app and
+   * returns this {@code GlideBuilder}.
+   *
+   * <p>This factory will <em>NOT</em> be called once per load. Instead it will be called a handful
+   * of times and memoized. It's not safe to assume that this factory will be called again for every
+   * new load.
+   *
+   * <p>Applying additional options with {@link RequestBuilder#apply(BaseRequestOptions)} will
+   * override defaults set here.
+   *
+   * @see #setDefaultRequestOptions(RequestOptionsFactory)
+   */
+  @NonNull
+  public GlideBuilder setDefaultRequestOptions(@NonNull RequestOptionsFactory factory) {
+    this.defaultRequestOptionsFactory = Preconditions.checkNotNull(factory);
     return this;
   }
 
@@ -168,16 +260,19 @@ public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
    *
    * <p>It's preferable but not required for the requested resource class to match the resource
    * class applied here as long as the resource class applied here is assignable from the requested
-   * resource class. For example you can set a default transition for
-   * {@link android.graphics.drawable.Drawable} and that default transition will be used if you
+   * resource class. For example you can set a default transition for {@link
+   * android.graphics.drawable.Drawable} and that default transition will be used if you
    * subsequently start requests for specific {@link android.graphics.drawable.Drawable} types like
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or
-   * {@link android.graphics.drawable.BitmapDrawable}. Specific types are always preferred so if you
-   * register a default transition for both {@link android.graphics.drawable.Drawable} and
-   * {@link android.graphics.drawable.BitmapDrawable} and then start a request for
-   * {@link android.graphics.drawable.BitmapDrawable}s, the transition you registered for
-   * {@link android.graphics.drawable.BitmapDrawable}s will be used.
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or {@link
+   * android.graphics.drawable.BitmapDrawable}. Specific types are always preferred so if you
+   * register a default transition for both {@link android.graphics.drawable.Drawable} and {@link
+   * android.graphics.drawable.BitmapDrawable} and then start a request for {@link
+   * android.graphics.drawable.BitmapDrawable}s, the transition you registered for {@link
+   * android.graphics.drawable.BitmapDrawable}s will be used.
    */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
   public <T> GlideBuilder setDefaultTransitionOptions(
       @NonNull Class<T> clazz, @Nullable TransitionOptions<?, T> options) {
     defaultTransitionOptions.put(clazz, options);
@@ -185,61 +280,50 @@ public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
   }
 
   /**
-   * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all
-   * the default decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link
-   * android.graphics.Bitmap}s they decode.
-   *
-   * <p> Decode format is always a suggestion, not a requirement. See {@link
-   * com.bumptech.glide.load.DecodeFormat} for more details. </p>
-   *
-   * @param decodeFormat The format to use.
-   * @return This builder.
-   *
-   * @deprecated Use {@link #setDefaultRequestOptions(RequestOptions)} instead.
-   */
-  @Deprecated
-  public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
-    defaultRequestOptions = defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));
-    return this;
-  }
-
-  /**
-   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default
-   * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
+   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default {@link
+   * MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
    *
    * @see #setMemorySizeCalculator(MemorySizeCalculator)
-   *
    * @param builder The builder to use (will not be modified).
    * @return This builder.
    */
-  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder) {
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setMemorySizeCalculator(@NonNull MemorySizeCalculator.Builder builder) {
     return setMemorySizeCalculator(builder.build());
   }
 
   /**
-   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default
-   * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
+   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default {@link
+   * MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
    *
-   * <p>The given {@link MemorySizeCalculator} will not affect custom pools or caches provided
-   * via {@link #setBitmapPool(BitmapPool)} or {@link #setMemoryCache(MemoryCache)}.
+   * <p>The given {@link MemorySizeCalculator} will not affect custom pools or caches provided via
+   * {@link #setBitmapPool(BitmapPool)} or {@link #setMemoryCache(MemoryCache)}.
    *
    * @param calculator The calculator to use.
    * @return This builder.
    */
-  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setMemorySizeCalculator(@Nullable MemorySizeCalculator calculator) {
     this.memorySizeCalculator = calculator;
     return this;
   }
 
   /**
-   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}
-   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events.
-   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used.
+   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory} to use to notify {@link
+   * com.bumptech.glide.RequestManager} of connectivity events. If not set {@link
+   * com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used.
    *
    * @param factory The factory to use
    * @return This builder.
    */
-  public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory factory) {
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setConnectivityMonitorFactory(@Nullable ConnectivityMonitorFactory factory) {
     this.connectivityMonitorFactory = factory;
     return this;
   }
@@ -247,16 +331,16 @@ public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory fac
   /**
    * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity.
    *
-   * <p>The level must be one of {@link Log#VERBOSE}, {@link Log#DEBUG}, {@link Log#INFO},
-   * {@link Log#WARN}, or {@link Log#ERROR}.
+   * <p>The level must be one of {@link Log#VERBOSE}, {@link Log#DEBUG}, {@link Log#INFO}, {@link
+   * Log#WARN}, or {@link Log#ERROR}.
    *
-   * <p>{@link Log#VERBOSE} means one or more lines will be logged per request, including
-   * timing logs and failures. {@link Log#DEBUG} means at most one line will be logged
-   * per successful request, including timing logs, although many lines may be logged for
-   * failures including multiple complete stack traces. {@link Log#INFO} means
-   * failed loads will be logged including multiple complete stack traces, but successful loads
-   * will not be logged at all. {@link Log#WARN} means only summaries of failed loads will be
-   * logged. {@link Log#ERROR} means only exceptional cases will be logged.
+   * <p>{@link Log#VERBOSE} means one or more lines will be logged per request, including timing
+   * logs and failures. {@link Log#DEBUG} means at most one line will be logged per successful
+   * request, including timing logs, although many lines may be logged for failures including
+   * multiple complete stack traces. {@link Log#INFO} means failed loads will be logged including
+   * multiple complete stack traces, but successful loads will not be logged at all. {@link
+   * Log#WARN} means only summaries of failed loads will be logged. {@link Log#ERROR} means only
+   * exceptional cases will be logged.
    *
    * <p>All logs will be logged using the 'Glide' tag.
    *
@@ -269,28 +353,155 @@ public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory fac
    * @param logLevel The log level to use from {@link Log}.
    * @return This builder.
    */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
   public GlideBuilder setLogLevel(int logLevel) {
     if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {
-      throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,"
-          + " Log.INFO, Log.WARN, or Log.ERROR");
+      throw new IllegalArgumentException(
+          "Log level must be one of Log.VERBOSE, Log.DEBUG," + " Log.INFO, Log.WARN, or Log.ERROR");
     }
     this.logLevel = logLevel;
     return this;
   }
 
-  GlideBuilder setRequestManagerFactory(
-      @Nullable RequestManagerRetriever.RequestManagerFactory factory) {
-    this.requestManagerFactory = factory;
+  /**
+   * If set to {@code true}, allows Glide to re-capture resources that are loaded into {@link
+   * com.bumptech.glide.request.target.Target}s which are subsequently de-referenced and garbage
+   * collected without being cleared.
+   *
+   * <p>Defaults to {@code false}.
+   *
+   * <p>Glide's resource re-use system is permissive, which means that's acceptable for callers to
+   * load resources into {@link com.bumptech.glide.request.target.Target}s and then never clear the
+   * {@link com.bumptech.glide.request.target.Target}. To do so, Glide uses {@link
+   * java.lang.ref.WeakReference}s to track resources that belong to {@link
+   * com.bumptech.glide.request.target.Target}s that haven't yet been cleared. Setting this method
+   * to {@code true} allows Glide to also maintain a hard reference to the underlying resource so
+   * that if the {@link com.bumptech.glide.request.target.Target} is garbage collected, Glide can
+   * return the underlying resource to it's memory cache so that subsequent requests will not
+   * unexpectedly re-load the resource from disk or source. As a side affect, it will take the
+   * system slightly longer to garbage collect the underlying resource because the weak reference
+   * has to be cleared and processed before the hard reference is removed. As a result, setting this
+   * method to {@code true} may transiently increase the memory usage of an application.
+   *
+   * <p>Leaving this method at the default {@code false} value will allow the platform to garbage
+   * collect resources more quickly, but will lead to unexpected memory cache misses if callers load
+   * resources into {@link com.bumptech.glide.request.target.Target}s but never clear them.
+   *
+   * <p>If you set this method to {@code true} you <em>must not</em> call {@link Bitmap#recycle()}
+   * or mutate any Bitmaps returned by Glide. If this method is set to {@code false}, recycling or
+   * mutating Bitmaps is inefficient but safe as long as you do not clear the corresponding {@link
+   * com.bumptech.glide.request.target.Target} used to load the {@link Bitmap}. However, if you set
+   * this method to {@code true} and recycle or mutate any returned {@link Bitmap}s or other mutable
+   * resources, Glide may recover those resources and attempt to use them later on, resulting in
+   * crashes, graphical corruption or undefined behavior.
+   *
+   * <p>Regardless of what value this method is set to, it's always good practice to clear {@link
+   * com.bumptech.glide.request.target.Target}s when you're done with the corresponding resource.
+   * Clearing {@link com.bumptech.glide.request.target.Target}s allows Glide to maximize resource
+   * re-use, minimize memory overhead and minimize unexpected behavior resulting from edge cases. If
+   * you use {@link RequestManager#clear(Target)}, calling {@link Bitmap#recycle()} or mutating
+   * {@link Bitmap}s is not only unsafe, it's also totally unnecessary and should be avoided. In all
+   * cases, prefer {@link RequestManager#clear(Target)} to {@link Bitmap#recycle()}.
+   *
+   * @return This builder.
+   */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setIsActiveResourceRetentionAllowed(
+      boolean isActiveResourceRetentionAllowed) {
+    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
+    return this;
+  }
+
+  /**
+   * Adds a global {@link RequestListener} that will be added to every request started with Glide.
+   *
+   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or to
+   * individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
+   * added. Even if an earlier {@link RequestListener} returns {@code true} from {@link
+   * RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or {@link
+   * RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will not
+   * prevent subsequent {@link RequestListener}s from being called.
+   *
+   * <p>Because Glide requests can be started for any number of individual resource types, any
+   * listener added here has to accept any generic resource type in {@link
+   * RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you must base
+   * the behavior of the listener on the resource type, you will need to use {@code instanceof} to
+   * do so. It's not safe to cast resource types without first checking with {@code instanceof}.
+   */
+  @NonNull
+  public GlideBuilder addGlobalRequestListener(@NonNull RequestListener<Object> listener) {
+    if (defaultRequestListeners == null) {
+      defaultRequestListeners = new ArrayList<>();
+    }
+    defaultRequestListeners.add(listener);
     return this;
   }
 
+  /**
+   * Set to {@code true} to make Glide populate {@link
+   * com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests.
+   *
+   * <p>The exception set by this method is not printed by {@link GlideException} and can only be
+   * viewed via a {@link RequestListener} that reads the field via {@link
+   * GlideException#getOrigin()}.
+   *
+   * <p>This is an experimental API that may be removed in the future.
+   */
+  public GlideBuilder setLogRequestOrigins(boolean isEnabled) {
+    isLoggingRequestOriginsEnabled = isEnabled;
+    return this;
+  }
+
+  /**
+   * Set to {@code true} to make Glide use {@link android.graphics.ImageDecoder} when decoding
+   * {@link Bitmap}s on Android P and higher.
+   *
+   * <p>Calls to this method on versions of Android less than Q are ignored. Although ImageDecoder
+   * was added in Android O a bug prevents it from scaling images with exif orientations until Q.
+   * See b/136096254.
+   *
+   * <p>Specifically {@link android.graphics.ImageDecoder} will be used in place of {@link
+   * com.bumptech.glide.load.resource.bitmap.Downsampler} and {@link android.graphics.BitmapFactory}
+   * to decode {@link Bitmap}s. GIFs, resources, and all other types of {@link
+   * android.graphics.drawable.Drawable}s are not affected by this flag.
+   *
+   * <p>This flag is experimental and may be removed without deprecation in a future version.
+   *
+   * <p>When this flag is enabled, Bitmap's will not be re-used when decoding images, though they
+   * may still be used as part of {@link com.bumptech.glide.load.Transformation}s because {@link
+   * android.graphics.ImageDecoder} does not support Bitmap re-use.
+   *
+   * <p>When this flag is enabled {@link
+   * com.bumptech.glide.load.resource.bitmap.Downsampler#FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS} is
+   * ignored. All other {@link com.bumptech.glide.load.resource.bitmap.Downsampler} flags are
+   * obeyed, although there may be subtle behavior differences because many options are subject to
+   * the whims of {@link android.graphics.BitmapFactory} and {@link android.graphics.ImageDecoder}
+   * which may not agree.
+   */
+  public GlideBuilder setImageDecoderEnabledForBitmaps(boolean isEnabled) {
+    if (!BuildCompat.isAtLeastQ()) {
+      return this;
+    }
+    isImageDecoderEnabledForBitmaps = isEnabled;
+    return this;
+  }
+
+  void setRequestManagerFactory(@Nullable RequestManagerFactory factory) {
+    this.requestManagerFactory = factory;
+  }
+
   // For testing.
   GlideBuilder setEngine(Engine engine) {
     this.engine = engine;
     return this;
   }
 
-  public Glide build(Context context) {
+  @NonNull
+  Glide build(@NonNull Context context) {
     if (sourceExecutor == null) {
       sourceExecutor = GlideExecutor.newSourceExecutor();
     }
@@ -299,6 +510,10 @@ public Glide build(Context context) {
       diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
 
+    if (animationExecutor == null) {
+      animationExecutor = GlideExecutor.newAnimationExecutor();
+    }
+
     if (memorySizeCalculator == null) {
       memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
@@ -336,11 +551,18 @@ public Glide build(Context context) {
               diskCacheExecutor,
               sourceExecutor,
               GlideExecutor.newUnlimitedSourceExecutor(),
-              GlideExecutor.newAnimationExecutor());
+              animationExecutor,
+              isActiveResourceRetentionAllowed);
+    }
+
+    if (defaultRequestListeners == null) {
+      defaultRequestListeners = Collections.emptyList();
+    } else {
+      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);
     }
 
-    RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(
-        requestManagerFactory);
+    RequestManagerRetriever requestManagerRetriever =
+        new RequestManagerRetriever(requestManagerFactory);
 
     return new Glide(
         context,
@@ -351,7 +573,11 @@ public Glide build(Context context) {
         requestManagerRetriever,
         connectivityMonitorFactory,
         logLevel,
-        defaultRequestOptions.lock(),
-        defaultTransitionOptions);
+        defaultRequestOptionsFactory,
+        defaultTransitionOptions,
+        defaultRequestListeners,
+        isLoggingRequestOriginsEnabled,
+        isImageDecoderEnabledForBitmaps,
+        hardwareBitmapFdLimit);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index 1e0aa58ab..82daabc07 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -1,18 +1,20 @@
 package com.bumptech.glide;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.ContextWrapper;
-import android.os.Build;
-import android.os.Handler;
-import android.os.Looper;
-import android.support.annotation.NonNull;
-import android.support.annotation.VisibleForTesting;
 import android.widget.ImageView;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.bumptech.glide.Glide.RequestOptionsFactory;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
-import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
@@ -20,41 +22,63 @@
  * Global context for all loads in Glide containing and exposing the various registries and classes
  * required to load resources.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class GlideContext extends ContextWrapper {
   @VisibleForTesting
   static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
-      new GenericTransitionOptions<Object>();
-  private final Handler mainHandler;
+      new GenericTransitionOptions<>();
+
+  private final ArrayPool arrayPool;
   private final Registry registry;
   private final ImageViewTargetFactory imageViewTargetFactory;
-  private final RequestOptions defaultRequestOptions;
+  private final RequestOptionsFactory defaultRequestOptionsFactory;
+  private final List<RequestListener<Object>> defaultRequestListeners;
   private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions;
   private final Engine engine;
+  private final boolean isLoggingRequestOriginsEnabled;
   private final int logLevel;
 
-  public GlideContext(Context context, Registry registry,
-      ImageViewTargetFactory imageViewTargetFactory, RequestOptions defaultRequestOptions,
-      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions, Engine engine,
+  @Nullable
+  @GuardedBy("this")
+  private RequestOptions defaultRequestOptions;
+
+  public GlideContext(
+      @NonNull Context context,
+      @NonNull ArrayPool arrayPool,
+      @NonNull Registry registry,
+      @NonNull ImageViewTargetFactory imageViewTargetFactory,
+      @NonNull RequestOptionsFactory defaultRequestOptionsFactory,
+      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
+      @NonNull List<RequestListener<Object>> defaultRequestListeners,
+      @NonNull Engine engine,
+      boolean isLoggingRequestOriginsEnabled,
       int logLevel) {
     super(context.getApplicationContext());
+    this.arrayPool = arrayPool;
     this.registry = registry;
     this.imageViewTargetFactory = imageViewTargetFactory;
-    this.defaultRequestOptions = defaultRequestOptions;
+    this.defaultRequestOptionsFactory = defaultRequestOptionsFactory;
+    this.defaultRequestListeners = defaultRequestListeners;
     this.defaultTransitionOptions = defaultTransitionOptions;
     this.engine = engine;
+    this.isLoggingRequestOriginsEnabled = isLoggingRequestOriginsEnabled;
     this.logLevel = logLevel;
+  }
 
-    mainHandler = new Handler(Looper.getMainLooper());
+  public List<RequestListener<Object>> getDefaultRequestListeners() {
+    return defaultRequestListeners;
   }
 
-  public RequestOptions getDefaultRequestOptions() {
+  public synchronized RequestOptions getDefaultRequestOptions() {
+    if (defaultRequestOptions == null) {
+      defaultRequestOptions = defaultRequestOptionsFactory.build().lock();
+    }
+
     return defaultRequestOptions;
   }
 
   @SuppressWarnings("unchecked")
   @NonNull
-  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
+  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(@NonNull Class<T> transcodeClass) {
     TransitionOptions<?, ?> result = defaultTransitionOptions.get(transcodeClass);
     if (result == null) {
       for (Entry<Class<?>, TransitionOptions<?, ?>> value : defaultTransitionOptions.entrySet()) {
@@ -69,18 +93,18 @@ public RequestOptions getDefaultRequestOptions() {
     return (TransitionOptions<?, T>) result;
   }
 
-  public <X> Target<X> buildImageViewTarget(ImageView imageView, Class<X> transcodeClass) {
+  @NonNull
+  public <X> ViewTarget<ImageView, X> buildImageViewTarget(
+      @NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
     return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
   }
 
-  public Handler getMainHandler() {
-    return mainHandler;
-  }
-
+  @NonNull
   public Engine getEngine() {
     return engine;
   }
 
+  @NonNull
   public Registry getRegistry() {
     return registry;
   }
@@ -88,4 +112,19 @@ public Registry getRegistry() {
   public int getLogLevel() {
     return logLevel;
   }
+
+  @NonNull
+  public ArrayPool getArrayPool() {
+    return arrayPool;
+  }
+
+  /**
+   * Returns {@code true} if Glide should populate {@link
+   * com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests.
+   *
+   * <p>This is an experimental API that may be removed in the future.
+   */
+  public boolean isLoggingRequestOriginsEnabled() {
+    return isLoggingRequestOriginsEnabled;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index 7aaa9d370..ba6e4f208 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,10 +1,12 @@
 package com.bumptech.glide;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import android.graphics.drawable.Drawable;
 import android.widget.AbsListView;
-import com.bumptech.glide.request.target.BaseTarget;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
@@ -17,10 +19,10 @@
  * the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and
  * cache size.
  *
- * <p> Must be put using
- * {@link AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)}, or have its
+ * <p>Must be put using {@link
+ * AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)}, or have its
  * corresponding methods called from another {@link android.widget.AbsListView.OnScrollListener} to
- * function. </p>
+ * function.
  *
  * @param <T> The type of the model being displayed in the list.
  */
@@ -33,7 +35,7 @@
 
   private int lastEnd;
   private int lastStart;
-  private int lastFirstVisible;
+  private int lastFirstVisible = -1;
   private int totalItemCount;
 
   private boolean isIncreasing = true;
@@ -66,15 +68,15 @@
     List<U> getPreloadItems(int position);
 
     /**
-     * Returns a {@link RequestBuilder} for a given item on which
-     * {@link RequestBuilder#load(Object)}} has been called or {@code null} if no valid load can be
+     * Returns a {@link RequestBuilder} for a given item on which {@link
+     * RequestBuilder#load(Object)}} has been called or {@code null} if no valid load can be
      * started.
      *
      * <p>For the preloader to be effective, the {@link RequestBuilder} returned here must use
      * exactly the same size and set of options as the {@link RequestBuilder} used when the ``View``
      * is bound. You may need to specify a size in both places to ensure that the width and height
-     * match exactly. If so, you can use
-     * {@link com.bumptech.glide.request.RequestOptions#override(int, int)} to do so.
+     * match exactly. If so, you can use {@link
+     * com.bumptech.glide.request.RequestOptions#override(int, int)} to do so.
      *
      * <p>The target and context will be provided by the preloader.
      *
@@ -85,7 +87,7 @@
      * @param item The model to load.
      */
     @Nullable
-    RequestBuilder getPreloadRequestBuilder(U item);
+    RequestBuilder<?> getPreloadRequestBuilder(@NonNull U item);
   }
 
   /**
@@ -107,7 +109,7 @@
      * @param item A model
      */
     @Nullable
-    int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
+    int[] getPreloadSize(@NonNull T item, int adapterPosition, int perItemPosition);
   }
 
   /**
@@ -115,12 +117,15 @@
    * the dimensions of images to preload, the list of models to preload for a given position, and
    * the request to use to load images.
    *
-   * @param preloadModelProvider     Provides models to load and requests capable of loading them.
+   * @param preloadModelProvider Provides models to load and requests capable of loading them.
    * @param preloadDimensionProvider Provides the dimensions of images to load.
-   * @param maxPreload               Maximum number of items to preload.
+   * @param maxPreload Maximum number of items to preload.
    */
-  public ListPreloader(RequestManager requestManager, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public ListPreloader(
+      @NonNull RequestManager requestManager,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
     this.requestManager = requestManager;
     this.preloadModelProvider = preloadModelProvider;
     this.preloadDimensionProvider = preloadDimensionProvider;
@@ -134,8 +139,8 @@ public void onScrollStateChanged(AbsListView absListView, int scrollState) {
   }
 
   @Override
-  public void onScroll(AbsListView absListView, int firstVisible, int visibleCount,
-      int totalCount) {
+  public void onScroll(
+      AbsListView absListView, int firstVisible, int visibleCount, int totalCount) {
     totalItemCount = totalCount;
     if (firstVisible > lastFirstVisible) {
       preload(firstVisible + visibleCount, true);
@@ -169,12 +174,12 @@ private void preload(int from, int to) {
     if (from < to) {
       // Increasing
       for (int i = start; i < end; i++) {
-        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, true);
+        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, true);
       }
     } else {
       // Decreasing
       for (int i = end - 1; i >= start; i--) {
-        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, false);
+        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, false);
       }
     }
 
@@ -200,13 +205,12 @@ private void preloadItem(@Nullable T item, int position, int perItemPosition) {
     if (item == null) {
       return;
     }
-    int[] dimensions =
-        preloadDimensionProvider.getPreloadSize(item, position, perItemPosition);
+    int[] dimensions = preloadDimensionProvider.getPreloadSize(item, position, perItemPosition);
     if (dimensions == null) {
       return;
     }
     RequestBuilder<Object> preloadRequestBuilder =
-        preloadModelProvider.getPreloadRequestBuilder(item);
+        (RequestBuilder<Object>) preloadModelProvider.getPreloadRequestBuilder(item);
     if (preloadRequestBuilder == null) {
       return;
     }
@@ -223,6 +227,8 @@ private void cancelAll() {
   private static final class PreloadTargetQueue {
     private final Queue<PreloadTarget> queue;
 
+    // The loop is short and the only point is to create the objects.
+    @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
     PreloadTargetQueue(int size) {
       queue = Util.createQueue(size);
 
@@ -240,26 +246,69 @@ public PreloadTarget next(int width, int height) {
     }
   }
 
-  private static final class PreloadTarget extends BaseTarget<Object> {
+  private static final class PreloadTarget implements Target<Object> {
     @Synthetic int photoHeight;
     @Synthetic int photoWidth;
+    @Nullable private Request request;
 
     @Synthetic
-    PreloadTarget() { }
+    PreloadTarget() {}
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onLoadStarted(@Nullable Drawable placeholder) {
       // Do nothing.
     }
 
     @Override
-    public void getSize(SizeReadyCallback cb) {
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      // Do nothing.
+    }
+
+    @Override
+    public void getSize(@NonNull SizeReadyCallback cb) {
       cb.onSizeReady(photoWidth, photoHeight);
     }
 
     @Override
-    public void removeCallback(SizeReadyCallback cb) {
+    public void removeCallback(@NonNull SizeReadyCallback cb) {
       // Do nothing because we don't retain references to SizeReadyCallbacks.
     }
+
+    @Override
+    public void setRequest(@Nullable Request request) {
+      this.request = request;
+    }
+
+    @Nullable
+    @Override
+    public Request getRequest() {
+      return request;
+    }
+
+    @Override
+    public void onStart() {
+      // Do nothing.
+    }
+
+    @Override
+    public void onStop() {
+      // Do nothing.
+    }
+
+    @Override
+    public void onDestroy() {
+      // Do nothing.
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/MemoryCategory.java b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
index a5781f62d..0e7107205 100644
--- a/library/src/main/java/com/bumptech/glide/MemoryCategory.java
+++ b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
@@ -1,16 +1,12 @@
 package com.bumptech.glide;
 
-/**
- * An enum for dynamically modifying the amount of memory Glide is able to use.
- */
+/** An enum for dynamically modifying the amount of memory Glide is able to use. */
 public enum MemoryCategory {
   /**
    * Tells Glide's memory cache and bitmap pool to use at most half of their initial maximum size.
    */
   LOW(0.5f),
-  /**
-   * Tells Glide's memory cache and bitmap pool to use at most their initial maximum size.
-   */
+  /** Tells Glide's memory cache and bitmap pool to use at most their initial maximum size. */
   NORMAL(1f),
   /**
    * Tells Glide's memory cache and bitmap pool to use at most one and a half times their initial
@@ -18,7 +14,7 @@
    */
   HIGH(1.5f);
 
-  private float multiplier;
+  private final float multiplier;
 
   MemoryCategory(float multiplier) {
     this.multiplier = multiplier;
diff --git a/library/src/main/java/com/bumptech/glide/ModelTypes.java b/library/src/main/java/com/bumptech/glide/ModelTypes.java
new file mode 100644
index 000000000..7f1937525
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/ModelTypes.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Ensures that the set of explicitly supported model types remains consistent across Glide's API
+ * surface.
+ */
+interface ModelTypes<T> {
+  @NonNull
+  @CheckResult
+  T load(@Nullable Bitmap bitmap);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable Drawable drawable);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable String string);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable Uri uri);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable File file);
+
+  @NonNull
+  @CheckResult
+  T load(@RawRes @DrawableRes @Nullable Integer resourceId);
+
+  @Deprecated
+  @CheckResult
+  T load(@Nullable URL url);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable byte[] model);
+
+  @NonNull
+  @CheckResult
+  @SuppressWarnings("unchecked")
+  T load(@Nullable Object model);
+}
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index 97ef93a87..40b6cde67 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide;
 
-import android.support.v4.util.Pools.Pool;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.util.Pools.Pool;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
@@ -32,6 +34,8 @@
  * Manages component registration to extend or replace Glide's default loading, decoding, and
  * encoding logic.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public class Registry {
   public static final String BUCKET_GIF = "Gif";
   public static final String BUCKET_BITMAP = "Bitmap";
@@ -50,10 +54,10 @@
   private final ModelToResourceClassCache modelToResourceClassCache =
       new ModelToResourceClassCache();
   private final LoadPathCache loadPathCache = new LoadPathCache();
-  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
+  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();
 
   public Registry() {
-    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);
+    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);
     this.encoderRegistry = new EncoderRegistry();
     this.decoderRegistry = new ResourceDecoderRegistry();
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
@@ -69,18 +73,19 @@ public Registry() {
    *
    * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
    * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
-   * {@link Encoder} being used for
-   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
-   * {@link java.io.FileInputStream} and any other subclass.
+   * {@link Encoder} being used for {@link
+   * android.content.res.AssetFileDescriptor.AutoCloseInputStream}, {@link java.io.FileInputStream}
+   * and any other subclass.
    *
-   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
-   * {@link Encoder} that is registered first will be used.
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the {@link
+   * Encoder} that is registered first will be used.
    *
    * @deprecated Use the equivalent {@link #append(Class, Class, ModelLoaderFactory)} method
-   * instead.
+   *     instead.
    */
+  @NonNull
   @Deprecated
-  public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
+  public <Data> Registry register(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
     return append(dataClass, encoder);
   }
 
@@ -90,60 +95,61 @@ public Registry() {
    *
    * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
    * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
-   * {@link Encoder} being used for
-   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
-   * {@link java.io.FileInputStream} and any other subclass.
+   * {@link Encoder} being used for {@link
+   * android.content.res.AssetFileDescriptor.AutoCloseInputStream}, {@link java.io.FileInputStream}
+   * and any other subclass.
    *
-   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
-   * {@link Encoder} that is registered first will be used.
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the {@link
+   * Encoder} that is registered first will be used.
    *
    * @see #prepend(Class, Encoder)
    */
-  public <Data> Registry append(Class<Data> dataClass, Encoder<Data> encoder) {
+  @NonNull
+  public <Data> Registry append(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
     encoderRegistry.append(dataClass, encoder);
     return this;
   }
 
   /**
-   * Prepends the given {@link Encoder} into the list of available {@link Encoder}s
-   * so that it is attempted before all later and default {@link Encoder}s for the given
-   * data class.
+   * Prepends the given {@link Encoder} into the list of available {@link Encoder}s so that it is
+   * attempted before all later and default {@link Encoder}s for the given data class.
    *
-   * <p>This method allows you to replace the default {@link Encoder} because it ensures
-   * the registered {@link Encoder} will run first. If multiple {@link Encoder}s are registered for
-   * the same type or super type, the {@link Encoder} that is registered first will be used.
+   * <p>This method allows you to replace the default {@link Encoder} because it ensures the
+   * registered {@link Encoder} will run first. If multiple {@link Encoder}s are registered for the
+   * same type or super type, the {@link Encoder} that is registered first will be used.
    *
    * @see #append(Class, Encoder)
    */
-  public <Data> Registry prepend(Class<Data> dataClass, Encoder<Data> encoder) {
+  @NonNull
+  public <Data> Registry prepend(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
     encoderRegistry.prepend(dataClass, encoder);
     return this;
   }
 
   /**
-   * Appends the given {@link ResourceDecoder} onto the list of all available
-   * {@link ResourceDecoder}s allowing it to be used if all earlier and default
-   * {@link ResourceDecoder}s for the given types fail (or there are none).
+   * Appends the given {@link ResourceDecoder} onto the list of all available {@link
+   * ResourceDecoder}s allowing it to be used if all earlier and default {@link ResourceDecoder}s
+   * for the given types fail (or there are none).
    *
    * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
-   * that your {@link ResourceDecoder} gets the chance to run before an existing
-   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
-   * best for new types of resources and data or as a way to add an additional fallback decoder
-   * for an existing type of data.
+   * that your {@link ResourceDecoder} gets the chance to run before an existing {@link
+   * ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is best for
+   * new types of resources and data or as a way to add an additional fallback decoder for an
+   * existing type of data.
    *
    * @see #append(String, Class, Class, ResourceDecoder)
    * @see #prepend(Class, Class, ResourceDecoder)
-   *
-   * @param dataClass The data that will be decoded from
-   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param dataClass The data that will be decoded from ({@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor} etc).
    * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   *     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
+  @NonNull
   public <Data, TResource> Registry append(
-      Class<Data> dataClass,
-      Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
     append(BUCKET_APPEND_ALL, dataClass, resourceClass, decoder);
     return this;
   }
@@ -154,84 +160,83 @@ public Registry() {
    * the given types in this bucket fail (or there are none).
    *
    * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
-   * that your {@link ResourceDecoder} gets the chance to run before an existing
-   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
-   * best for new types of resources and data or as a way to add an additional fallback decoder
-   * for an existing type of data.
+   * that your {@link ResourceDecoder} gets the chance to run before an existing {@link
+   * ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is best for
+   * new types of resources and data or as a way to add an additional fallback decoder for an
+   * existing type of data.
    *
    * @see #prepend(String, Class, Class, ResourceDecoder)
    * @see #setResourceDecoderBucketPriorityList(List)
-   *
    * @param bucket The bucket identifier to add this decoder to.
-   * @param dataClass The data that will be decoded from
-   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param dataClass The data that will be decoded from ({@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor} etc).
    * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   *     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
+  @NonNull
   public <Data, TResource> Registry append(
-      String bucket,
-      Class<Data> dataClass,
-      Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
+      @NonNull String bucket,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
     decoderRegistry.append(bucket, decoder, dataClass, resourceClass);
     return this;
   }
 
   /**
-   * Prepends the given {@link ResourceDecoder} into the list of all available
-   * {@link ResourceDecoder}s so that it is attempted before all later and default
-   * {@link ResourceDecoder}s for the given types.
+   * Prepends the given {@link ResourceDecoder} into the list of all available {@link
+   * ResourceDecoder}s so that it is attempted before all later and default {@link ResourceDecoder}s
+   * for the given types.
    *
-   * <p>This method allows you to replace the default {@link ResourceDecoder} because it ensures
-   * the registered {@link ResourceDecoder} will run first. You can use the
-   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
-   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
-   * types of data.
+   * <p>This method allows you to replace the default {@link ResourceDecoder} because it ensures the
+   * registered {@link ResourceDecoder} will run first. You can use the {@link
+   * ResourceDecoder#handles(Object, Options)} to fall back to the default {@link ResourceDecoder}s
+   * if you only want to change the default functionality for certain types of data.
    *
    * @see #prepend(String, Class, Class, ResourceDecoder)
    * @see #append(Class, Class, ResourceDecoder)
-   *
-   * @param dataClass The data that will be decoded from
-   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param dataClass The data that will be decoded from ({@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor} etc).
    * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   *     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
+  @NonNull
   public <Data, TResource> Registry prepend(
-      Class<Data> dataClass,
-      Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
     prepend(BUCKET_PREPEND_ALL, dataClass, resourceClass, decoder);
     return this;
   }
 
   /**
    * Prepends the given {@link ResourceDecoder} into the list of available {@link ResourceDecoder}s
-   * in the same bucket so that it is attempted before all later and default
-   * {@link ResourceDecoder}s for the given types in that bucket.
+   * in the same bucket so that it is attempted before all later and default {@link
+   * ResourceDecoder}s for the given types in that bucket.
    *
    * <p>This method allows you to replace the default {@link ResourceDecoder} for this bucket
    * because it ensures the registered {@link ResourceDecoder} will run first. You can use the
-   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
-   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
-   * types of data.
+   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default {@link
+   * ResourceDecoder}s if you only want to change the default functionality for certain types of
+   * data.
    *
    * @see #append(String, Class, Class, ResourceDecoder)
    * @see #setResourceDecoderBucketPriorityList(List)
-   *
    * @param bucket The bucket identifier to add this decoder to.
-   * @param dataClass The data that will be decoded from
-   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param dataClass The data that will be decoded from ({@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor} etc).
    * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   *     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
+  @NonNull
   public <Data, TResource> Registry prepend(
-      String bucket,
-      Class<Data> dataClass,
-      Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
+      @NonNull String bucket,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
     decoderRegistry.prepend(bucket, decoder, dataClass, resourceClass);
     return this;
   }
@@ -241,19 +246,22 @@ public Registry() {
    * which are identified as a unique string. Glide will attempt to decode using decoders in the
    * highest priority bucket before moving on to the next one.
    *
-   * <p>The default order is [{@link #BUCKET_GIF}, {@link #BUCKET_BITMAP},
-   * {@link #BUCKET_BITMAP_DRAWABLE}].
+   * <p>The default order is [{@link #BUCKET_GIF}, {@link #BUCKET_BITMAP}, {@link
+   * #BUCKET_BITMAP_DRAWABLE}].
    *
    * <p>When registering decoders, you can use these buckets to specify the ordering relative only
    * to other decoders in that bucket.
+   *
    * @see #append(String, Class, Class, ResourceDecoder)
    * @see #prepend(String, Class, Class, ResourceDecoder)
-   *
    * @param buckets The list of bucket identifiers in order from highest priority to least priority.
    */
   // Final to avoid a PMD error.
-  public final Registry setResourceDecoderBucketPriorityList(List<String> buckets) {
-    List<String> modifiedBuckets = new ArrayList<>(buckets);
+  @NonNull
+  public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String> buckets) {
+    // See #3296 and https://bugs.openjdk.java.net/browse/JDK-6260652.
+    List<String> modifiedBuckets = new ArrayList<>(buckets.size());
+    modifiedBuckets.addAll(buckets);
     modifiedBuckets.add(0, BUCKET_PREPEND_ALL);
     modifiedBuckets.add(BUCKET_APPEND_ALL);
     decoderRegistry.setBucketPriorityList(modifiedBuckets);
@@ -266,19 +274,20 @@ public final Registry setResourceDecoderBucketPriorityList(List<String> buckets)
    * data type.
    *
    * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
-   * For example, registering an {@link ResourceEncoder} for
-   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
-   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   * For example, registering an {@link ResourceEncoder} for {@link
+   * android.graphics.drawable.Drawable} (not recommended) will result in the {@link
+   * ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
    *
    * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
    * {@link ResourceEncoder} that is registered first will be used.
    *
    * @deprecated Use the equivalent {@link #append(Class, ResourceEncoder)} method instead.
    */
+  @NonNull
   @Deprecated
   public <TResource> Registry register(
-      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
     return append(resourceClass, encoder);
   }
 
@@ -288,18 +297,19 @@ public final Registry setResourceDecoderBucketPriorityList(List<String> buckets)
    * data type.
    *
    * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
-   * For example, registering an {@link ResourceEncoder} for
-   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
-   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   * For example, registering an {@link ResourceEncoder} for {@link
+   * android.graphics.drawable.Drawable} (not recommended) will result in the {@link
+   * ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
    *
    * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
    * {@link ResourceEncoder} that is registered first will be used.
    *
    * @see #prepend(Class, ResourceEncoder)
    */
+  @NonNull
   public <TResource> Registry append(
-      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
     resourceEncoderRegistry.append(resourceClass, encoder);
     return this;
   }
@@ -309,15 +319,16 @@ public final Registry setResourceDecoderBucketPriorityList(List<String> buckets)
    * so that it is attempted before all later and default {@link ResourceEncoder}s for the given
    * data type.
    *
-   * <p>This method allows you to replace the default {@link ResourceEncoder} because it ensures
-   * the registered {@link ResourceEncoder} will run first. If multiple {@link ResourceEncoder}s are
+   * <p>This method allows you to replace the default {@link ResourceEncoder} because it ensures the
+   * registered {@link ResourceEncoder} will run first. If multiple {@link ResourceEncoder}s are
    * registered for the same type or super type, the {@link ResourceEncoder} that is registered
    * first will be used.
    *
    * @see #append(Class, ResourceEncoder)
    */
+  @NonNull
   public <TResource> Registry prepend(
-      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
     resourceEncoderRegistry.prepend(resourceClass, encoder);
     return this;
   }
@@ -326,7 +337,8 @@ public final Registry setResourceDecoderBucketPriorityList(List<String> buckets)
    * Registers a new {@link com.bumptech.glide.load.data.DataRewinder.Factory} to handle a
    * non-default data type that can be rewind to allow for efficient reads of file headers.
    */
-  public Registry register(DataRewinder.Factory factory) {
+  @NonNull
+  public Registry register(@NonNull DataRewinder.Factory<?> factory) {
     dataRewinderRegistry.register(factory);
     return this;
   }
@@ -335,14 +347,17 @@ public Registry register(DataRewinder.Factory factory) {
    * Registers the given {@link ResourceTranscoder} to convert from the given resource {@link Class}
    * to the given transcode {@link Class}.
    *
-   * @param resourceClass The class that will be transcoded from (e.g.
-   * {@link android.graphics.Bitmap}).
-   * @param transcodeClass The class that will be transcoded to (e.g.
-   * {@link android.graphics.drawable.BitmapDrawable}).
+   * @param resourceClass The class that will be transcoded from (e.g. {@link
+   *     android.graphics.Bitmap}).
+   * @param transcodeClass The class that will be transcoded to (e.g. {@link
+   *     android.graphics.drawable.BitmapDrawable}).
    * @param transcoder The {@link ResourceTranscoder} to register.
    */
-  public <TResource, Transcode> Registry register(Class<TResource> resourceClass,
-      Class<Transcode> transcodeClass, ResourceTranscoder<TResource, Transcode> transcoder) {
+  @NonNull
+  public <TResource, Transcode> Registry register(
+      @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass,
+      @NonNull ResourceTranscoder<TResource, Transcode> transcoder) {
     transcoderRegistry.register(resourceClass, transcodeClass, transcoder);
     return this;
   }
@@ -351,7 +366,8 @@ public Registry register(DataRewinder.Factory factory) {
    * Registers a new {@link ImageHeaderParser} that can obtain some basic metadata from an image
    * header (orientation, type etc).
    */
-  public Registry register(ImageHeaderParser parser) {
+  @NonNull
+  public Registry register(@NonNull ImageHeaderParser parser) {
     imageHeaderParserRegistry.add(parser);
     return this;
   }
@@ -361,25 +377,26 @@ public Registry register(ImageHeaderParser parser) {
    * constructed {@link ModelLoader} will be tried after all default and previously registered
    * {@link ModelLoader}s for the given model and data classes.
    *
-   * <p>If you're attempting to replace an existing {@link ModelLoader}, use
-   * {@link #prepend(Class, Class, ModelLoaderFactory)}. This method is best for new types of models
-   * and/or data or as a way to add an additional fallback loader for an existing type of
-   * model/data.
+   * <p>If you're attempting to replace an existing {@link ModelLoader}, use {@link #prepend(Class,
+   * Class, ModelLoaderFactory)}. This method is best for new types of models and/or data or as a
+   * way to add an additional fallback loader for an existing type of model/data.
    *
    * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
-   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
-   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
-   * entire request fail.
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the {@link
+   * ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the entire
+   * request fail.
    *
    * @see #prepend(Class, Class, ModelLoaderFactory)
    * @see #replace(Class, Class, ModelLoaderFactory)
-   *
    * @param modelClass The model class (e.g. URL, file path).
-   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
-   * {@link java.io.FileDescriptor}).
+   * @param dataClass the data class (e.g. {@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor}).
    */
-  public <Model, Data> Registry append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  @NonNull
+  public <Model, Data> Registry append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.append(modelClass, dataClass, factory);
     return this;
   }
@@ -390,25 +407,27 @@ public Registry register(ImageHeaderParser parser) {
    * {@link ModelLoader}s for the given model and data classes.
    *
    * <p>If you're attempting to add additional functionality or add a backup that should run only
-   * after the default {@link ModelLoader}s run, use
-   * {@link #append(Class, Class, ModelLoaderFactory)}. This method is best for adding an additional
-   * case to Glide's existing functionality that should run first. This method will still run
-   * Glide's default {@link ModelLoader}s if the prepended {@link ModelLoader}s fail.
+   * after the default {@link ModelLoader}s run, use {@link #append(Class, Class,
+   * ModelLoaderFactory)}. This method is best for adding an additional case to Glide's existing
+   * functionality that should run first. This method will still run Glide's default {@link
+   * ModelLoader}s if the prepended {@link ModelLoader}s fail.
    *
    * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
-   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
-   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
-   * entire request fail.
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the {@link
+   * ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the entire
+   * request fail.
    *
    * @see #append(Class, Class, ModelLoaderFactory)
    * @see #replace(Class, Class, ModelLoaderFactory)
-   *
    * @param modelClass The model class (e.g. URL, file path).
-   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
-   * {@link java.io.FileDescriptor}).
+   * @param dataClass the data class (e.g. {@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor}).
    */
-  public <Model, Data> Registry prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  @NonNull
+  public <Model, Data> Registry prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.prepend(modelClass, dataClass, factory);
     return this;
   }
@@ -418,35 +437,41 @@ public Registry register(ImageHeaderParser parser) {
    * and model class and replaces all of them with the single {@link ModelLoader} provided.
    *
    * <p>If you're attempting to add additional functionality or add a backup that should run only
-   * after the default {@link ModelLoader}s run, use
-   * {@link #append(Class, Class, ModelLoaderFactory)}. This method should be used only when you
-   * want to ensure that Glide's default {@link ModelLoader}s do not run.
+   * after the default {@link ModelLoader}s run, use {@link #append(Class, Class,
+   * ModelLoaderFactory)}. This method should be used only when you want to ensure that Glide's
+   * default {@link ModelLoader}s do not run.
    *
    * <p>One good use case for this method is when you want to replace Glide's default networking
-   * library with your OkHttp, Volley, or your own implementation. Using
-   * {@link #prepend(Class, Class, ModelLoaderFactory)} or
-   * {@link #append(Class, Class, ModelLoaderFactory)} may still allow Glide's default networking
-   * library to run in some cases. Using this method will ensure that only your networking library
-   * will run and that the request will fail otherwise.
+   * library with your OkHttp, Volley, or your own implementation. Using {@link #prepend(Class,
+   * Class, ModelLoaderFactory)} or {@link #append(Class, Class, ModelLoaderFactory)} may still
+   * allow Glide's default networking library to run in some cases. Using this method will ensure
+   * that only your networking library will run and that the request will fail otherwise.
    *
    * @see #prepend(Class, Class, ModelLoaderFactory)
    * @see #append(Class, Class, ModelLoaderFactory)
-   *
    * @param modelClass The model class (e.g. URL, file path).
-   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
-   * {@link java.io.FileDescriptor}).
+   * @param dataClass the data class (e.g. {@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor}).
    */
-  public <Model, Data> Registry replace(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  @NonNull
+  public <Model, Data> Registry replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     modelLoaderRegistry.replace(modelClass, dataClass, factory);
     return this;
   }
 
+  @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> getLoadPath(
-      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     LoadPath<Data, TResource, Transcode> result =
         loadPathCache.get(dataClass, resourceClass, transcodeClass);
-    if (result == null && !loadPathCache.contains(dataClass, resourceClass, transcodeClass)) {
+    if (loadPathCache.isEmptyLoadPath(result)) {
+      return null;
+    } else if (result == null) {
       List<DecodePath<Data, TResource, Transcode>> decodePaths =
           getDecodePaths(dataClass, resourceClass, transcodeClass);
       // It's possible there is no way to decode or transcode to the desired types from a given
@@ -454,17 +479,20 @@ public Registry register(ImageHeaderParser parser) {
       if (decodePaths.isEmpty()) {
         result = null;
       } else {
-        result = new LoadPath<>(dataClass, resourceClass, transcodeClass, decodePaths,
-            exceptionListPool);
+        result =
+            new LoadPath<>(
+                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);
       }
       loadPathCache.put(dataClass, resourceClass, transcodeClass, result);
     }
     return result;
   }
 
+  @NonNull
   private <Data, TResource, Transcode> List<DecodePath<Data, TResource, Transcode>> getDecodePaths(
-      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
-
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     List<DecodePath<Data, TResource, Transcode>> decodePaths = new ArrayList<>();
     List<Class<TResource>> registeredResourceClasses =
         decoderRegistry.getResourceClasses(dataClass, resourceClass);
@@ -479,16 +507,28 @@ public Registry register(ImageHeaderParser parser) {
             decoderRegistry.getDecoders(dataClass, registeredResourceClass);
         ResourceTranscoder<TResource, Transcode> transcoder =
             transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);
-        decodePaths.add(new DecodePath<>(dataClass, registeredResourceClass,
-            registeredTranscodeClass, decoders, transcoder, exceptionListPool));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        DecodePath<Data, TResource, Transcode> path =
+            new DecodePath<>(
+                dataClass,
+                registeredResourceClass,
+                registeredTranscodeClass,
+                decoders,
+                transcoder,
+                throwableListPool);
+        decodePaths.add(path);
       }
     }
     return decodePaths;
   }
 
+  @NonNull
   public <Model, TResource, Transcode> List<Class<?>> getRegisteredResourceClasses(
-      Class<Model> modelClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
-    List<Class<?>> result = modelToResourceClassCache.get(modelClass, resourceClass);
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
+    List<Class<?>> result =
+        modelToResourceClassCache.get(modelClass, resourceClass, transcodeClass);
 
     if (result == null) {
       result = new ArrayList<>();
@@ -497,25 +537,26 @@ public Registry register(ImageHeaderParser parser) {
         List<? extends Class<?>> registeredResourceClasses =
             decoderRegistry.getResourceClasses(dataClass, resourceClass);
         for (Class<?> registeredResourceClass : registeredResourceClasses) {
-          List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry
-              .getTranscodeClasses(registeredResourceClass, transcodeClass);
+          List<Class<Transcode>> registeredTranscodeClasses =
+              transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);
           if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {
-              result.add(registeredResourceClass);
+            result.add(registeredResourceClass);
           }
         }
       }
-      modelToResourceClassCache.put(modelClass, resourceClass,
-          Collections.unmodifiableList(result));
+      modelToResourceClassCache.put(
+          modelClass, resourceClass, transcodeClass, Collections.unmodifiableList(result));
     }
 
     return result;
   }
 
-  public boolean isResourceEncoderAvailable(Resource<?> resource) {
+  public boolean isResourceEncoderAvailable(@NonNull Resource<?> resource) {
     return resourceEncoderRegistry.get(resource.getResourceClass()) != null;
   }
 
-  public <X> ResourceEncoder<X> getResultEncoder(Resource<X> resource)
+  @NonNull
+  public <X> ResourceEncoder<X> getResultEncoder(@NonNull Resource<X> resource)
       throws NoResultEncoderAvailableException {
     ResourceEncoder<X> resourceEncoder = resourceEncoderRegistry.get(resource.getResourceClass());
     if (resourceEncoder != null) {
@@ -524,8 +565,9 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     throw new NoResultEncoderAvailableException(resource.getResourceClass());
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public <X> Encoder<X> getSourceEncoder(X data) throws NoSourceEncoderAvailableException {
+  public <X> Encoder<X> getSourceEncoder(@NonNull X data) throws NoSourceEncoderAvailableException {
     Encoder<X> encoder = encoderRegistry.getEncoder((Class<X>) data.getClass());
     if (encoder != null) {
       return encoder;
@@ -533,11 +575,13 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     throw new NoSourceEncoderAvailableException(data.getClass());
   }
 
-  public <X> DataRewinder<X> getRewinder(X data) {
+  @NonNull
+  public <X> DataRewinder<X> getRewinder(@NonNull X data) {
     return dataRewinderRegistry.build(data);
   }
 
-  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(Model model) {
+  @NonNull
+  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(@NonNull Model model) {
     List<ModelLoader<Model, ?>> result = modelLoaderRegistry.getModelLoaders(model);
     if (result.isEmpty()) {
       throw new NoModelLoaderAvailableException(model);
@@ -545,6 +589,7 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     return result;
   }
 
+  @NonNull
   public List<ImageHeaderParser> getImageHeaderParsers() {
     List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();
     if (result.isEmpty()) {
@@ -557,46 +602,54 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
    * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
    * model class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoModelLoaderAvailableException extends MissingComponentException {
-    public NoModelLoaderAvailableException(Object model) {
+    public NoModelLoaderAvailableException(@NonNull Object model) {
       super("Failed to find any ModelLoaders for model: " + model);
     }
 
-    public NoModelLoaderAvailableException(Class<?> modelClass, Class<?> dataClass) {
+    public NoModelLoaderAvailableException(
+        @NonNull Class<?> modelClass, @NonNull Class<?> dataClass) {
       super("Failed to find any ModelLoaders for model: " + modelClass + " and data: " + dataClass);
     }
   }
 
-  /**
-   * Thrown when no {@link ResourceEncoder} is registered for a given resource class.
-   */
+  /** Thrown when no {@link ResourceEncoder} is registered for a given resource class. */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoResultEncoderAvailableException extends MissingComponentException {
-    public NoResultEncoderAvailableException(Class<?> resourceClass) {
-      super("Failed to find result encoder for resource class: " + resourceClass);
+    public NoResultEncoderAvailableException(@NonNull Class<?> resourceClass) {
+      super(
+          "Failed to find result encoder for resource class: "
+              + resourceClass
+              + ", you may need to consider registering a new Encoder for the requested type or"
+              + " DiskCacheStrategy.DATA/DiskCacheStrategy.NONE if caching your transformed"
+              + " resource is unnecessary.");
     }
   }
 
-  /**
-   * Thrown when no {@link Encoder} is registered for a given data class.
-   */
+  /** Thrown when no {@link Encoder} is registered for a given data class. */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoSourceEncoderAvailableException extends MissingComponentException {
-    public NoSourceEncoderAvailableException(Class<?> dataClass) {
+    public NoSourceEncoderAvailableException(@NonNull Class<?> dataClass) {
       super("Failed to find source encoder for data class: " + dataClass);
     }
   }
 
-  /**
-   * Thrown when some necessary component is missing for a load.
-   */
+  /** Thrown when some necessary component is missing for a load. */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class MissingComponentException extends RuntimeException {
-    public MissingComponentException(String message) {
+    public MissingComponentException(@NonNull String message) {
       super(message);
     }
   }
 
-  /**
-   * Thrown when no {@link ImageHeaderParser} is registered.
-   */
+  /** Thrown when no {@link ImageHeaderParser} is registered. */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static final class NoImageHeaderParserException extends MissingComponentException {
     public NoImageHeaderParserException() {
       super("Failed to find image header parser.");
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 38d9ce454..8bf798ea4 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -1,16 +1,23 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.support.annotation.CheckResult;
-import android.support.annotation.DrawableRes;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.annotation.RawRes;
 import android.widget.ImageView;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.ErrorRequestCoordinator;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.Request;
@@ -22,35 +29,41 @@
 import com.bumptech.glide.request.ThumbnailRequestCoordinator;
 import com.bumptech.glide.request.target.PreloadTarget;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.util.Executors;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.io.File;
 import java.net.URL;
-import java.util.UUID;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Executor;
 
 /**
  * A generic class that can handle setting options and staring loads for generic resource types.
  *
- * @param <TranscodeType> The type of resource that will be delivered to the
- * {@link com.bumptech.glide.request.target.Target}.
+ * @param <TranscodeType> The type of resource that will be delivered to the {@link
+ *     com.bumptech.glide.request.target.Target}.
  */
-public class RequestBuilder<TranscodeType> implements Cloneable {
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public class RequestBuilder<TranscodeType> extends BaseRequestOptions<RequestBuilder<TranscodeType>>
+    implements Cloneable, ModelTypes<RequestBuilder<TranscodeType>> {
   // Used in generated subclasses
   protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
+      new RequestOptions()
+          .diskCacheStrategy(DiskCacheStrategy.DATA)
+          .priority(Priority.LOW)
           .skipMemoryCache(true);
 
   private final Context context;
   private final RequestManager requestManager;
   private final Class<TranscodeType> transcodeClass;
-  private final RequestOptions defaultRequestOptions;
   private final Glide glide;
   private final GlideContext glideContext;
 
-  @NonNull protected RequestOptions requestOptions;
-
   @NonNull
   @SuppressWarnings("unchecked")
   private TransitionOptions<?, ? super TranscodeType> transitionOptions;
@@ -58,7 +71,7 @@
   @Nullable private Object model;
   // model may occasionally be null, so to enforce that load() was called, put a boolean rather
   // than relying on model not to be null.
-  @Nullable private RequestListener<TranscodeType> requestListener;
+  @Nullable private List<RequestListener<TranscodeType>> requestListeners;
   @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
   @Nullable private RequestBuilder<TranscodeType> errorBuilder;
   @Nullable private Float thumbSizeMultiplier;
@@ -66,42 +79,63 @@
   private boolean isModelSet;
   private boolean isThumbnailBuilt;
 
-  protected RequestBuilder(Glide glide, RequestManager requestManager,
-      Class<TranscodeType> transcodeClass, Context context) {
+  // We only override the method to change the return type, not the functionality.
+  @SuppressLint("CheckResult")
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+  protected RequestBuilder(
+      @NonNull Glide glide,
+      RequestManager requestManager,
+      Class<TranscodeType> transcodeClass,
+      Context context) {
     this.glide = glide;
     this.requestManager = requestManager;
     this.transcodeClass = transcodeClass;
-    this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
     this.context = context;
     this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
-    this.requestOptions = defaultRequestOptions;
     this.glideContext = glide.getGlideContext();
+
+    initRequestListeners(requestManager.getDefaultRequestListeners());
+    apply(requestManager.getDefaultRequestOptions());
   }
 
+  @SuppressLint("CheckResult")
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
   protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
     this(other.glide, other.requestManager, transcodeClass, other.context);
     model = other.model;
     isModelSet = other.isModelSet;
-    requestOptions = other.requestOptions;
+
+    // This is safe because it will always mutate, no one else has access to the object.
+    apply(other);
+  }
+
+  // Casting from Object to a specific type is always safe.
+  @SuppressWarnings("unchecked")
+  // addListener always returns the same instance.
+  @SuppressLint("CheckResult")
+  private void initRequestListeners(List<RequestListener<Object>> requestListeners) {
+    for (RequestListener<Object> listener : requestListeners) {
+      addListener((RequestListener<TranscodeType>) listener);
+    }
   }
 
   /**
-   * Applies the given options to the request, options set or unset in the given options will
-   * replace those previously set in options in this class.
+   * Applies the given options to the request.
    *
-   * @see RequestOptions#apply(RequestOptions)
+   * <p>As with {@link RequestOptions#apply(BaseRequestOptions)}, {@code #apply} only replaces those
+   * values that are explicitly set in the given {@link RequestOptions} object. If you need to
+   * completely reset all previously set options, create a new {@code RequestBuilder} instead of
+   * using this method.
+   *
+   * @see RequestOptions#apply(BaseRequestOptions)
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
-  public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
+  @Override
+  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
     Preconditions.checkNotNull(requestOptions);
-    this.requestOptions = getMutableOptions().apply(requestOptions);
-    return this;
-  }
-
-  protected RequestOptions getMutableOptions() {
-    return defaultRequestOptions == this.requestOptions
-        ? this.requestOptions.clone() : this.requestOptions;
+    return super.apply(requestOptions);
   }
 
   /**
@@ -113,6 +147,7 @@ protected RequestOptions getMutableOptions() {
    *
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   public RequestBuilder<TranscodeType> transition(
       @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
@@ -126,41 +161,64 @@ protected RequestOptions getMutableOptions() {
    * instance of an exception handler per type of request (usually activity/fragment) rather than
    * pass one in per request to avoid some redundant object allocation.
    *
+   * <p>Subsequent calls to this method will replace previously set listeners. To set multiple
+   * listeners, use {@link #addListener} instead.
+   *
    * @param requestListener The request listener to use.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> listener(
       @Nullable RequestListener<TranscodeType> requestListener) {
-    this.requestListener = requestListener;
+    this.requestListeners = null;
+    return addListener(requestListener);
+  }
 
+  /**
+   * Adds a {@link RequestListener}. If called multiple times, all passed {@link RequestListener
+   * listeners} will be called in order.
+   *
+   * @param requestListener The request listener to use. If {@code null}, this method is a noop.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestBuilder<TranscodeType> addListener(
+      @Nullable RequestListener<TranscodeType> requestListener) {
+    if (requestListener != null) {
+      if (this.requestListeners == null) {
+        this.requestListeners = new ArrayList<>();
+      }
+      this.requestListeners.add(requestListener);
+    }
     return this;
   }
 
   /**
-   * Sets a {@link RequestBuilder} that is built and run iff the load started by this
-   * {@link RequestBuilder} fails.
+   * Sets a {@link RequestBuilder} that is built and run if the load started by this {@link
+   * RequestBuilder} fails.
    *
-   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
-   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
+   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error {@link
+   * RequestBuilder} will be started anyway if the non-thumbnail request fails.
    *
-   * <p>Recursive calls to {@link #error(RequestBuilder)} as well as calls to
-   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder)} are supported for the given
-   * error {@link RequestBuilder}.
+   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and {@link
+   * #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
    *
    * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
    * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
    * Options like priority, override widths and heights and transitions must be applied
    * independently to the error builder.
    *
-   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
-   * if it's set on this {@link RequestBuilder} via
-   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
-   * {@link RequestOptions#fallback(int)}.
+   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable if
+   * it's set on this {@link RequestBuilder} via {@link
+   * RequestOptions#fallback(android.graphics.drawable.Drawable)} or {@link
+   * RequestOptions#fallback(int)}.
    *
    * @return This {@link RequestBuilder}.
    */
+  @NonNull
   public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
     this.errorBuilder = errorBuilder;
     return this;
@@ -175,15 +233,15 @@ protected RequestOptions getMutableOptions() {
    *
    * <p>Recursive calls to thumbnail are supported.
    *
-   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
-   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder[])}.
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and {@link
+   * #thumbnail(RequestBuilder[])}.
    *
    * @see #thumbnail(float)
    * @see #thumbnail(RequestBuilder[])
-   *
    * @param thumbnailRequest The request to use to load the thumbnail.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> thumbnail(
@@ -197,35 +255,33 @@ protected RequestOptions getMutableOptions() {
    * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
    * loaded as thumbnails in the given priority order.
    *
-   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
-   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
-   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
-   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the {@link
+   * RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied as using its
+   * thumbnail method, the {@link RequestBuilder} at position 1 has the {@link RequestBuilder} at
+   * position 2 applied using its thumbnail method and so on.
    *
-   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
-   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
-   * {@link #thumbnail(RequestBuilder)} with {@code null}.
+   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or an
+   * empty array of {@link RequestBuilder} thumbnails is equivalent to calling {@link
+   * #thumbnail(RequestBuilder)} with {@code null}.
    *
-   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
-   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
-   * chain.
+   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be {@code
+   * null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive chain.
    *
-   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
-   * calls to their {@link #thumbnail(RequestBuilder[])} or {@link #thumbnail(RequestBuilder)}
-   * methods overridden.
+   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous calls
+   * to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
    *
-   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
-   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder[])}.
+   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)}, {@link
+   * #thumbnail(float)} and this method.
    *
    * @see #thumbnail(float)
    * @see #thumbnail(RequestBuilder)
-   *
    * @return This request builder.
    */
   @SuppressWarnings({"CheckResult", "unchecked"})
+  @NonNull
   @CheckResult
   public RequestBuilder<TranscodeType> thumbnail(
-      @Nullable RequestBuilder<TranscodeType> /*@Nullable*/ ... thumbnails) {
+      @Nullable RequestBuilder<TranscodeType>... thumbnails) {
     if (thumbnails == null || thumbnails.length == 0) {
       return thumbnail((RequestBuilder<TranscodeType>) null);
     }
@@ -261,29 +317,28 @@ protected RequestOptions getMutableOptions() {
    * load, the thumbnail will not be shown.
    *
    * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
-   * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}.
+   * {@link ImageView}) must be able to scale the thumbnail appropriately. See {@link
+   * android.widget.ImageView.ScaleType}.
    *
    * <p>Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
-   * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
-   * {@link #listener(RequestListener)} will only be used on the full size load and will not be
-   * copied for the thumbnail load.
+   * and {@link com.bumptech.glide.load.Transformation}s. However, {@link
+   * com.bumptech.glide.request.RequestOptions#placeholder(int)} and {@link
+   * com.bumptech.glide.request.RequestOptions#error(int)}, and {@link #listener(RequestListener)}
+   * will only be used on the full size load and will not be copied for the thumbnail load.
    *
    * <p>Recursive calls to thumbnail are supported.
    *
-   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder[])},
-   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder)}.
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])}, and
+   * {@link #thumbnail(RequestBuilder)}.
    *
    * @see #thumbnail(RequestBuilder)
    * @see #thumbnail(RequestBuilder[])
-   *
    * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
-   *                       the thumbnail.
+   *     the thumbnail.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
@@ -298,43 +353,92 @@ protected RequestOptions getMutableOptions() {
   /**
    * Sets the specific model to load data for.
    *
-   * <p> This method must be called at least once before
-   * {@link #into(com.bumptech.glide.request.target.Target)} is called. </p>
-   *
    * @param model The model to load data for, or null.
    * @return This request builder.
    */
+  @NonNull
   @CheckResult
   @SuppressWarnings("unchecked")
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Object model) {
     return loadGeneric(model);
   }
 
+  @NonNull
   private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
     this.model = model;
     isModelSet = true;
     return this;
   }
+  /**
+   * Returns an object to load the given {@link Bitmap}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than pass {@link Bitmap}s
+   * into Glide. If you have a custom way to obtain {@link Bitmap}s that is not supported by Glide
+   * by default, consider registering a custom {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than {@link
+   * DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return loadGeneric(bitmap).apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
 
   /**
-   * Returns a request builder to load the given {@link java.lang.String}. signature.
+   * Returns a request builder to load the given {@link Drawable}.
    *
-   * <p> Note - this method caches data using only the given String as the cache key. If the data is
-   * a Uri outside of your control, or you otherwise expect the data represented by the given String
-   * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create that identifies the data currently at the given String that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   * </p>
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass {@link
+   * Bitmap}s into Glide using this method . If you have a custom way to obtain {@link Bitmap}s that
+   * is not supported by Glide by default, consider registering a custom {@link
+   * com.bumptech.glide.load.model.ModelLoader} or {@link com.bumptech.glide.load.ResourceDecoder}
+   * instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than {@link
+   * DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
+   * compared.
    *
    * @see #load(Object)
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
+    return loadGeneric(drawable).apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
+
+  /**
+   * Returns a request builder to load the given {@link java.lang.String}.
    *
-   * @param string A file path, or a uri or url handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
+   * <p>Note - this method caches data using only the given String as the cache key. If the data is
+   * a Uri outside of your control, or you otherwise expect the data represented by the given String
+   * to change without the String identifier changing, Consider using {@link
+   * com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to mixin a
+   * signature you create that identifies the data currently at the given String that will
+   * invalidate the cache if that data changes. Alternatively, using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or {@link
+   * com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be appropriate.
+   *
+   * @see #load(Object)
+   * @param string A file path, or a uri or url handled by {@link
+   *     com.bumptech.glide.load.model.UriLoader}.
    */
+  @NonNull
+  @Override
   @CheckResult
   public RequestBuilder<TranscodeType> load(@Nullable String string) {
     return loadGeneric(string);
@@ -343,22 +447,22 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request builder to load the given {@link Uri}.
    *
-   * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
+   * <p>Note - this method caches data at Uris using only the Uri itself as the cache key. The data
    * represented by Uris from some content providers may change without the Uri changing, which
-   * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create based on the data at the given Uri that will invalidate the cache
-   * if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate. </p>
+   * means using this method can lead to displaying stale data. Consider using {@link
+   * com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to mixin a
+   * signature you create based on the data at the given Uri that will invalidate the cache if that
+   * data changes. Alternatively, using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or {@link
+   * com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be appropriate.
    *
    * @see #load(Object)
-   *
-   * @param uri The Uri representing the image. Must be of a type handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
+   * @param uri The Uri representing the image. Must be of a type handled by {@link
+   *     com.bumptech.glide.load.model.UriLoader}.
    */
+  @NonNull
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
     return loadGeneric(uri);
   }
@@ -366,52 +470,60 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request builder to load the given {@link File}.
    *
-   * <p> Note - this method caches data for Files using only the file path itself as the cache key.
+   * <p>Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
-   * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
-   * to mixin a signature you create that identifies the data currently in the File that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   * </p>
+   * expect the data in the File to change, Consider using {@link
+   * com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to mixin a
+   * signature you create that identifies the data currently in the File that will invalidate the
+   * cache if that data changes. Alternatively, using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or {@link
+   * com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be appropriate.
    *
    * @see #load(Object)
-   *
    * @param file The File containing the image
    */
+  @NonNull
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable File file) {
     return loadGeneric(file);
   }
 
   /**
-   * Returns a request builder that uses the
-   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
-   * {@link Integer} to load the image represented by the given {@link Integer} resource id.
-   * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
+   * Returns a request builder that uses the {@link
+   * com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or {@link Integer} to
+   * load the image represented by the given {@link Integer} resource id. Defaults to {@link
+   * com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
    *
    * <p>By default this method adds a version code based signature to the cache key used to cache
    * this resource in Glide. This signature is sufficient to guarantee that end users will see the
    * most up to date versions of your Drawables, but during development if you do not increment your
    * version code before each install and you replace a Drawable with different data without
    * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
-   * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via {@link
+   * RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)} during
+   * development, and re-enabling the default {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+   *
+   * <p>This method will load non-{@link android.graphics.Bitmap} resources like {@link
+   * android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply {@link
+   * com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting the
+   * underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide is
+   * still not able to transform all types of resources. Animated {@link Drawable}s cannot be
+   * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
+   * load failures if a {@link Drawable} can't be transformed, use the optional transformation
+   * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
    *
-   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
-   * {@link android.graphics.drawable.VectorDrawable}s, but most common options including
-   * default {@link com.bumptech.glide.load.Transformation}s will not <em>NOT</em> work on
-   * non-{@link android.graphics.Bitmap} resources. As a result, functionality for
-   * non-{@link android.graphics.Bitmap} resources may be limited.
+   * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
+   * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
+   * caution for non-{@link Bitmap} {@link Drawable}s.
    *
    * @see #load(Integer)
    * @see com.bumptech.glide.signature.ApplicationVersionSignature
    */
+  @NonNull
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
     return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
   }
@@ -422,11 +534,12 @@ protected RequestOptions getMutableOptions() {
    * @param url The URL representing the image.
    * @see #load(Object)
    * @deprecated The {@link java.net.URL} class has <a href="http://goo.gl/c4hHNu">a number of
-   * performance problems</a> and should generally be avoided when possible. Prefer
-   * {@link #load(android.net.Uri)} or {@link #load(String)}.
+   *     performance problems</a> and should generally be avoided when possible. Prefer {@link
+   *     #load(android.net.Uri)} or {@link #load(String)}.
    */
   @Deprecated
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable URL url) {
     return loadGeneric(url);
   }
@@ -434,38 +547,44 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request to load the given byte array.
    *
-   * <p> Note - by default loads for bytes are not cached in either the memory or the disk cache.
-   * </p>
+   * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
    *
    * @param model the data to load.
    * @see #load(Object)
    */
+  @NonNull
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString()))
-        .diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true /*skipMemoryCache*/));
+    RequestBuilder<TranscodeType> result = loadGeneric(model);
+    if (!result.isDiskCacheStrategySet()) {
+      result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+    if (!result.isSkipMemoryCacheSet()) {
+      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+    }
+    return result;
   }
 
   /**
    * Returns a copy of this request builder with all of the options put so far on this builder.
    *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * <p>This method returns a "deep" copy in that all non-immutable arguments are copied such that
    * changes to one builder will not affect the other builder. However, in addition to immutable
    * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
+   * builders.
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+    "unchecked",
+    // we don't want to throw to be user friendly
+    "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @CheckResult
   @Override
   public RequestBuilder<TranscodeType> clone() {
-    try {
-      RequestBuilder<TranscodeType> result = (RequestBuilder<TranscodeType>) super.clone();
-      result.requestOptions = result.requestOptions.clone();
-      result.transitionOptions = result.transitionOptions.clone();
-      return result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
+    RequestBuilder<TranscodeType> result = super.clone();
+    result.transitionOptions = result.transitionOptions.clone();
+    return result;
   }
 
   /**
@@ -475,31 +594,35 @@ protected RequestOptions getMutableOptions() {
    * @return The given target.
    * @see RequestManager#clear(Target)
    */
+  @NonNull
   public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
-    return into(target, /*targetListener=*/ null);
+    return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor());
   }
 
-  private <Y extends Target<TranscodeType>> Y into(
+  @NonNull
+  @Synthetic
+  <Y extends Target<TranscodeType>> Y into(
       @NonNull Y target,
-      @Nullable RequestListener<TranscodeType> targetListener) {
-    return into(target, targetListener, getMutableOptions());
+      @Nullable RequestListener<TranscodeType> targetListener,
+      Executor callbackExecutor) {
+    return into(target, targetListener, /*options=*/ this, callbackExecutor);
   }
 
   private <Y extends Target<TranscodeType>> Y into(
       @NonNull Y target,
       @Nullable RequestListener<TranscodeType> targetListener,
-      RequestOptions options) {
-    Util.assertMainThread();
+      BaseRequestOptions<?> options,
+      Executor callbackExecutor) {
     Preconditions.checkNotNull(target);
     if (!isModelSet) {
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
 
-    options = options.autoClone();
-    Request request = buildRequest(target, targetListener, options);
+    Request request = buildRequest(target, targetListener, options, callbackExecutor);
 
     Request previous = target.getRequest();
-    if (request.isEquivalentTo(previous)) {
+    if (request.isEquivalentTo(previous)
+        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
       request.recycle();
       // If the request is completed, beginning again will ensure the result is re-delivered,
       // triggering RequestListeners and Targets. If the request is failed, beginning again will
@@ -507,8 +630,8 @@ protected RequestOptions getMutableOptions() {
       // running, we can let it continue running without interruption.
       if (!Preconditions.checkNotNull(previous).isRunning()) {
         // Use the previous request rather than the new one to allow for optimizations like skipping
-        // setting placeholders, tracking and untracking Targets, and obtaining View dimensions that
-        // are done in the individual Request.
+        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
+        // that are done in the individual Request.
         previous.begin();
       }
       return target;
@@ -521,6 +644,15 @@ protected RequestOptions getMutableOptions() {
     return target;
   }
 
+  // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
+  // the previous request will complete from memory because it will just use the resource that had
+  // already been loaded. If the previous request isn't complete, we can wait for it to finish
+  // because the previous request must also be using skipMemoryCache for the requests to be
+  // equivalent. See #2663 for additional context.
+  private boolean isSkipMemoryCacheWithCompletePreviousRequest(
+      BaseRequestOptions<?> options, Request previous) {
+    return !options.isMemoryCacheable() && previous.isComplete();
+  }
 
   /**
    * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
@@ -528,16 +660,16 @@ protected RequestOptions getMutableOptions() {
    * reused.
    *
    * @see RequestManager#clear(Target)
-   *
    * @param view The view to cancel previous loads for and load the new resource into.
-   * @return The
-   * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
+   * @return The {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link
+   *     ImageView}.
    */
-  public Target<TranscodeType> into(ImageView view) {
+  @NonNull
+  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
     Util.assertMainThread();
     Preconditions.checkNotNull(view);
 
-    RequestOptions requestOptions = this.requestOptions;
+    BaseRequestOptions<?> requestOptions = this;
     if (!requestOptions.isTransformationSet()
         && requestOptions.isTransformationAllowed()
         && view.getScaleType() != null) {
@@ -569,22 +701,20 @@ protected RequestOptions getMutableOptions() {
     return into(
         glideContext.buildImageViewTarget(view, transcodeClass),
         /*targetListener=*/ null,
-        requestOptions);
+        requestOptions,
+        Executors.mainThreadExecutor());
   }
 
   /**
    * Returns a future that can be used to do a blocking get on a background thread.
    *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
+   * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+   *     previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+   *     previously called).
    * @see RequestManager#clear(Target)
-   *
    * @deprecated Use {@link #submit(int, int)} instead.
    */
   @Deprecated
@@ -604,6 +734,7 @@ protected RequestOptions getMutableOptions() {
    * @see #submit(int, int)
    * @see #into(Target)
    */
+  @NonNull
   public FutureTarget<TranscodeType> submit() {
     return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
@@ -611,53 +742,36 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a future that can be used to do a blocking get on a background thread.
    *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
+   * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+   *     previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+   *     previously called).
    */
+  @NonNull
   public FutureTarget<TranscodeType> submit(int width, int height) {
-    final RequestFutureTarget<TranscodeType> target =
-        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
-
-    if (Util.isOnBackgroundThread()) {
-      glideContext.getMainHandler().post(new Runnable() {
-        @Override
-        public void run() {
-          if (!target.isCancelled()) {
-            into(target, target);
-          }
-        }
-      });
-    } else {
-      into(target, target);
-    }
-
-    return target;
+    final RequestFutureTarget<TranscodeType> target = new RequestFutureTarget<>(width, height);
+    return into(target, target, Executors.directExecutor());
   }
 
   /**
    * Preloads the resource into the cache using the given width and height.
    *
-   * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
-   * future are available quickly. </p>
+   * <p>Pre-loading is useful for making sure that resources you are going to to want in the near
+   * future are available quickly.
    *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
+   * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+   *     previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}.
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+   *     previously called).
+   * @return A {@link Target} that can be used to cancel the load via {@link
+   *     RequestManager#clear(Target)}.
    * @see com.bumptech.glide.ListPreloader
    */
+  @NonNull
   public Target<TranscodeType> preload(int width, int height) {
     final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
     return into(target);
@@ -668,10 +782,11 @@ public void run() {
    * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
    * the width and height.
    *
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}
+   * @return A {@link Target} that can be used to cancel the load via {@link
+   *     RequestManager#clear(Target)}
    * @see #preload(int, int)
    */
+  @NonNull
   public Target<TranscodeType> preload() {
     return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
@@ -681,28 +796,25 @@ public void run() {
    * File.
    *
    * @param target The Target that will receive the cache File when the load completes
-   * @param <Y>    The type of Target.
+   * @param <Y> The type of Target.
    * @return The given Target.
-   *
    * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
    */
   @Deprecated
   @CheckResult
-  public <Y extends Target<File>> Y downloadOnly(Y target) {
+  public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
     return getDownloadOnlyRequest().into(target);
   }
 
   /**
-   * Loads the original unmodified data into the cache and returns a
-   * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
-   * data.
+   * Loads the original unmodified data into the cache and returns a {@link
+   * java.util.concurrent.Future} that can be used to retrieve the cache File containing the data.
    *
-   * @param width  The width in pixels to use to fetch the data.
+   * @param width The width in pixels to use to fetch the data.
    * @param height The height in pixels to use to fetch the data.
    * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
-   * containing the data.
-   *
-   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}.
+   *     containing the data.
+   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #submit(int, int)}.
    */
   @Deprecated
   @CheckResult
@@ -710,12 +822,14 @@ public void run() {
     return getDownloadOnlyRequest().submit(width, height);
   }
 
+  @NonNull
   @CheckResult
   protected RequestBuilder<File> getDownloadOnlyRequest() {
     return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
   }
 
-  private Priority getThumbnailPriority(Priority current) {
+  @NonNull
+  private Priority getThumbnailPriority(@NonNull Priority current) {
     switch (current) {
       case LOW:
         return Priority.NORMAL;
@@ -725,23 +839,25 @@ private Priority getThumbnailPriority(Priority current) {
       case IMMEDIATE:
         return Priority.IMMEDIATE;
       default:
-        throw new IllegalArgumentException("unknown priority: " + requestOptions.getPriority());
+        throw new IllegalArgumentException("unknown priority: " + getPriority());
     }
   }
 
   private Request buildRequest(
       Target<TranscodeType> target,
       @Nullable RequestListener<TranscodeType> targetListener,
-      RequestOptions requestOptions) {
+      BaseRequestOptions<?> requestOptions,
+      Executor callbackExecutor) {
     return buildRequestRecursive(
         target,
         targetListener,
-        /*requestCoordinator=*/ null,
+        /*parentCoordinator=*/ null,
         transitionOptions,
         requestOptions.getPriority(),
         requestOptions.getOverrideWidth(),
         requestOptions.getOverrideHeight(),
-        requestOptions);
+        requestOptions,
+        callbackExecutor);
   }
 
   private Request buildRequestRecursive(
@@ -752,7 +868,8 @@ private Request buildRequestRecursive(
       Priority priority,
       int overrideWidth,
       int overrideHeight,
-      RequestOptions requestOptions) {
+      BaseRequestOptions<?> requestOptions,
+      Executor callbackExecutor) {
 
     // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
     ErrorRequestCoordinator errorRequestCoordinator = null;
@@ -770,29 +887,31 @@ private Request buildRequestRecursive(
             priority,
             overrideWidth,
             overrideHeight,
-            requestOptions);
+            requestOptions,
+            callbackExecutor);
 
     if (errorRequestCoordinator == null) {
       return mainRequest;
     }
 
-    int errorOverrideWidth = errorBuilder.requestOptions.getOverrideWidth();
-    int errorOverrideHeight = errorBuilder.requestOptions.getOverrideHeight();
-    if (Util.isValidDimensions(overrideWidth, overrideHeight)
-        && !errorBuilder.requestOptions.isValidOverride()) {
+    int errorOverrideWidth = errorBuilder.getOverrideWidth();
+    int errorOverrideHeight = errorBuilder.getOverrideHeight();
+    if (Util.isValidDimensions(overrideWidth, overrideHeight) && !errorBuilder.isValidOverride()) {
       errorOverrideWidth = requestOptions.getOverrideWidth();
       errorOverrideHeight = requestOptions.getOverrideHeight();
     }
 
-    Request errorRequest = errorBuilder.buildRequestRecursive(
-        target,
-        targetListener,
-        errorRequestCoordinator,
-        errorBuilder.transitionOptions,
-        errorBuilder.requestOptions.getPriority(),
-        errorOverrideWidth,
-        errorOverrideHeight,
-        errorBuilder.requestOptions);
+    Request errorRequest =
+        errorBuilder.buildRequestRecursive(
+            target,
+            targetListener,
+            errorRequestCoordinator,
+            errorBuilder.transitionOptions,
+            errorBuilder.getPriority(),
+            errorOverrideWidth,
+            errorOverrideHeight,
+            errorBuilder,
+            callbackExecutor);
     errorRequestCoordinator.setRequests(mainRequest, errorRequest);
     return errorRequestCoordinator;
   }
@@ -805,12 +924,14 @@ private Request buildThumbnailRequestRecursive(
       Priority priority,
       int overrideWidth,
       int overrideHeight,
-      RequestOptions requestOptions) {
+      BaseRequestOptions<?> requestOptions,
+      Executor callbackExecutor) {
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
-        throw new IllegalStateException("You cannot use a request as both the main request and a "
-            + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
+        throw new IllegalStateException(
+            "You cannot use a request as both the main request and a "
+                + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
       }
 
       TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
@@ -822,13 +943,15 @@ private Request buildThumbnailRequestRecursive(
         thumbTransitionOptions = transitionOptions;
       }
 
-      Priority thumbPriority = thumbnailBuilder.requestOptions.isPrioritySet()
-          ? thumbnailBuilder.requestOptions.getPriority() : getThumbnailPriority(priority);
+      Priority thumbPriority =
+          thumbnailBuilder.isPrioritySet()
+              ? thumbnailBuilder.getPriority()
+              : getThumbnailPriority(priority);
 
-      int thumbOverrideWidth = thumbnailBuilder.requestOptions.getOverrideWidth();
-      int thumbOverrideHeight = thumbnailBuilder.requestOptions.getOverrideHeight();
+      int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
+      int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
       if (Util.isValidDimensions(overrideWidth, overrideHeight)
-          && !thumbnailBuilder.requestOptions.isValidOverride()) {
+          && !thumbnailBuilder.isValidOverride()) {
         thumbOverrideWidth = requestOptions.getOverrideWidth();
         thumbOverrideHeight = requestOptions.getOverrideHeight();
       }
@@ -843,7 +966,8 @@ private Request buildThumbnailRequestRecursive(
               transitionOptions,
               priority,
               overrideWidth,
-              overrideHeight);
+              overrideHeight,
+              callbackExecutor);
       isThumbnailBuilt = true;
       // Recursively generate thumbnail requests.
       Request thumbRequest =
@@ -855,7 +979,8 @@ private Request buildThumbnailRequestRecursive(
               thumbPriority,
               thumbOverrideWidth,
               thumbOverrideHeight,
-              thumbnailBuilder.requestOptions);
+              thumbnailBuilder,
+              callbackExecutor);
       isThumbnailBuilt = false;
       coordinator.setRequests(fullRequest, thumbRequest);
       return coordinator;
@@ -871,9 +996,10 @@ private Request buildThumbnailRequestRecursive(
               transitionOptions,
               priority,
               overrideWidth,
-              overrideHeight);
-      RequestOptions thumbnailOptions = requestOptions.clone()
-          .sizeMultiplier(thumbSizeMultiplier);
+              overrideHeight,
+              callbackExecutor);
+      BaseRequestOptions<?> thumbnailOptions =
+          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);
 
       Request thumbnailRequest =
           obtainRequest(
@@ -884,7 +1010,8 @@ private Request buildThumbnailRequestRecursive(
               transitionOptions,
               getThumbnailPriority(priority),
               overrideWidth,
-              overrideHeight);
+              overrideHeight,
+              callbackExecutor);
 
       coordinator.setRequests(fullRequest, thumbnailRequest);
       return coordinator;
@@ -898,19 +1025,21 @@ private Request buildThumbnailRequestRecursive(
           transitionOptions,
           priority,
           overrideWidth,
-          overrideHeight);
+          overrideHeight,
+          callbackExecutor);
     }
   }
 
   private Request obtainRequest(
       Target<TranscodeType> target,
       RequestListener<TranscodeType> targetListener,
-      RequestOptions requestOptions,
+      BaseRequestOptions<?> requestOptions,
       RequestCoordinator requestCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions,
       Priority priority,
       int overrideWidth,
-      int overrideHeight) {
+      int overrideHeight,
+      Executor callbackExecutor) {
     return SingleRequest.obtain(
         context,
         glideContext,
@@ -922,9 +1051,10 @@ private Request obtainRequest(
         priority,
         target,
         targetListener,
-        requestListener,
+        requestListeners,
         requestCoordinator,
         glideContext.getEngine(),
-        transitionOptions.getTransitionFactory());
+        transitionOptions.getTransitionFactory(),
+        callbackExecutor);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index ecd2e5821..0a205d266 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -7,13 +7,19 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
-import android.support.annotation.CheckResult;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.view.View;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
@@ -22,14 +28,19 @@
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.manager.TargetTracker;
+import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.CustomViewTarget;
 import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.io.File;
+import java.net.URL;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity
@@ -38,38 +49,55 @@
  * handling, use the static Glide.load methods with your Fragment or Activity.
  *
  * @see Glide#with(android.app.Activity)
- * @see Glide#with(android.support.v4.app.FragmentActivity)
+ * @see Glide#with(androidx.fragment.app.FragmentActivity)
  * @see Glide#with(android.app.Fragment)
- * @see Glide#with(android.support.v4.app.Fragment)
+ * @see Glide#with(androidx.fragment.app.Fragment)
  * @see Glide#with(Context)
  */
-public class RequestManager implements LifecycleListener {
+public class RequestManager implements LifecycleListener, ModelTypes<RequestBuilder<Drawable>> {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
   private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
-          .skipMemoryCache(true);
+      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW).skipMemoryCache(true);
 
   protected final Glide glide;
   protected final Context context;
-  @Synthetic final Lifecycle lifecycle;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final Lifecycle lifecycle;
+
+  @GuardedBy("this")
   private final RequestTracker requestTracker;
+
+  @GuardedBy("this")
   private final RequestManagerTreeNode treeNode;
+
+  @GuardedBy("this")
   private final TargetTracker targetTracker = new TargetTracker();
-  private final Runnable addSelfToLifecycle = new Runnable() {
-    @Override
-    public void run() {
-      lifecycle.addListener(RequestManager.this);
-    }
-  };
+
+  private final Runnable addSelfToLifecycle =
+      new Runnable() {
+        @Override
+        public void run() {
+          lifecycle.addListener(RequestManager.this);
+        }
+      };
   private final Handler mainHandler = new Handler(Looper.getMainLooper());
   private final ConnectivityMonitor connectivityMonitor;
+  // Adding default listeners should be much less common than starting new requests. We want
+  // some way of making sure that requests don't mutate our listeners without creating a new copy of
+  // the list each time a request is started.
+  private final CopyOnWriteArrayList<RequestListener<Object>> defaultRequestListeners;
 
-  @NonNull
+  @GuardedBy("this")
   private RequestOptions requestOptions;
 
   public RequestManager(
-      Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode, Context context) {
+      @NonNull Glide glide,
+      @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode,
+      @NonNull Context context) {
     this(
         glide,
         lifecycle,
@@ -110,38 +138,41 @@ public RequestManager(
     }
     lifecycle.addListener(connectivityMonitor);
 
+    defaultRequestListeners =
+        new CopyOnWriteArrayList<>(glide.getGlideContext().getDefaultRequestListeners());
     setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
 
     glide.registerRequestManager(this);
   }
 
-  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+  protected synchronized void setRequestOptions(@NonNull RequestOptions toSet) {
     requestOptions = toSet.clone().autoClone();
   }
 
-  private void updateRequestOptions(RequestOptions toUpdate) {
+  private synchronized void updateRequestOptions(@NonNull RequestOptions toUpdate) {
     requestOptions = requestOptions.apply(toUpdate);
   }
 
   /**
-   * Updates the default {@link RequestOptions} for all loads started with this request manager
-   * with the given {@link RequestOptions}.
+   * Updates the default {@link RequestOptions} for all loads started with this request manager with
+   * the given {@link RequestOptions}.
    *
    * <p>The {@link RequestOptions} provided here are applied on top of those provided via {@link
    * GlideBuilder#setDefaultRequestOptions(RequestOptions)}. If there are conflicts, the options
-   * applied here will win. Note that this method does not mutate options provided to
-   * {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   * applied here will win. Note that this method does not mutate options provided to {@link
+   * GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
    *
    * <p>Multiple sets of options can be applied. If there are conflicts the last {@link
    * RequestOptions} applied will win.
    *
    * <p>The modified options will only be applied to loads started after this method is called.
    *
-   * @see RequestBuilder#apply(RequestOptions)
-   *
+   * @see RequestBuilder#apply(BaseRequestOptions)
    * @return This request manager.
    */
-  public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public synchronized RequestManager applyDefaultRequestOptions(
+      @NonNull RequestOptions requestOptions) {
     updateRequestOptions(requestOptions);
     return this;
   }
@@ -151,43 +182,43 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    * with the given {@link RequestOptions}.
    *
    * <p>The {@link RequestOptions} provided here replace those that have been previously provided
-   * via {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, {@link
-   * #setDefaultRequestOptions(RequestOptions)} and {@link
+   * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and {@link
    * #applyDefaultRequestOptions(RequestOptions)}.
    *
-   * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
-   * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
-   * options and mutate the clone.
+   * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate the
+   * {@link RequestOptions} provided here. Instead the manager will create a clone of these options
+   * and mutate the clone.
    *
    * @see #applyDefaultRequestOptions(RequestOptions)
-   *
    * @return This request manager.
    */
-  public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public synchronized RequestManager setDefaultRequestOptions(
+      @NonNull RequestOptions requestOptions) {
     setRequestOptions(requestOptions);
     return this;
   }
 
   /**
-   * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+   * Adds a default {@link RequestListener} that will be added to every request started with this
+   * {@link RequestManager}.
    *
-   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
-   * externally.
-   */
-  @Deprecated
-  public void onTrimMemory(int level) {
-    glide.onTrimMemory(level);
-  }
-
-  /**
-   * @see android.content.ComponentCallbacks2#onLowMemory()
+   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or to
+   * individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
+   * added. Even if an earlier {@link RequestListener} returns {@code true} from {@link
+   * RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or {@link
+   * RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will not
+   * prevent subsequent {@link RequestListener}s from being called.
    *
-   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
-   * externally.
+   * <p>Because Glide requests can be started for any number of individual resource types, any
+   * listener added here has to accept any generic resource type in {@link
+   * RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you must base
+   * the behavior of the listener on the resource type, you will need to use {@code instanceof} to
+   * do so. It's not safe to cast resource types without first checking with {@code instanceof}.
    */
-  @Deprecated
-  public void onLowMemory() {
-    glide.onLowMemory();
+  public RequestManager addDefaultRequestListener(RequestListener<Object> requestListener) {
+    defaultRequestListeners.add(requestListener);
+    return this;
   }
 
   /**
@@ -196,38 +227,61 @@ public void onLowMemory() {
    * @see #pauseRequests()
    * @see #resumeRequests()
    */
-  public boolean isPaused() {
-    Util.assertMainThread();
+  public synchronized boolean isPaused() {
     return requestTracker.isPaused();
   }
 
   /**
    * Cancels any in progress loads, but does not clear resources of completed loads.
    *
+   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+   * manager is paused to complete. RequestManagers attached to Fragments and Activities
+   * automatically resume onStart().
+   *
    * @see #isPaused()
    * @see #resumeRequests()
    */
-  public void pauseRequests() {
-    Util.assertMainThread();
+  public synchronized void pauseRequests() {
     requestTracker.pauseRequests();
   }
 
   /**
-   * Performs {@link #pauseRequests()} recursively for all managers that are contextually
-   * descendant to this manager based on the Activity/Fragment hierarchy:
+   * Cancels any in progress loads and clears resources of completed loads.
+   *
+   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+   * manager is paused to complete. RequestManagers attached to Fragments and Activities
+   * automatically resume onStart().
+   *
+   * <p>This will release the memory used by completed bitmaps but leaves them in any configured
+   * caches. When an #{@link android.app.Activity} receives #{@link
+   * android.app.Activity#onTrimMemory(int)} at a level of #{@link
+   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep
+   * your process alive longer.
+   *
+   * @see #isPaused()
+   * @see #resumeRequests()
+   */
+  public synchronized void pauseAllRequests() {
+    requestTracker.pauseAllRequests();
+  }
+
+  /**
+   * Performs {@link #pauseRequests()} recursively for all managers that are contextually descendant
+   * to this manager based on the Activity/Fragment hierarchy:
    *
    * <ul>
    *   <li>When pausing on an Activity all attached fragments will also get paused.
    *   <li>When pausing on an attached Fragment all descendant fragments will also get paused.
    *   <li>When pausing on a detached Fragment or the application context only the current
-   *   RequestManager is paused.
+   *       RequestManager is paused.
    * </ul>
    *
    * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
    * pause, in this case either call pause on the Activity or use a support Fragment.
    */
-  public void pauseRequestsRecursive() {
-    Util.assertMainThread();
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
+  public synchronized void pauseRequestsRecursive() {
     pauseRequests();
     for (RequestManager requestManager : treeNode.getDescendants()) {
       requestManager.pauseRequests();
@@ -240,8 +294,7 @@ public void pauseRequestsRecursive() {
    * @see #isPaused()
    * @see #pauseRequests()
    */
-  public void resumeRequests() {
-    Util.assertMainThread();
+  public synchronized void resumeRequests() {
     requestTracker.resumeRequests();
   }
 
@@ -250,7 +303,9 @@ public void resumeRequests() {
    * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
    * are identical as for {@link #pauseRequestsRecursive()}.
    */
-  public void resumeRequestsRecursive() {
+  // Public API.
+  @SuppressWarnings("unused")
+  public synchronized void resumeRequestsRecursive() {
     Util.assertMainThread();
     resumeRequests();
     for (RequestManager requestManager : treeNode.getDescendants()) {
@@ -264,7 +319,7 @@ public void resumeRequestsRecursive() {
    * requests.
    */
   @Override
-  public void onStart() {
+  public synchronized void onStart() {
     resumeRequests();
     targetTracker.onStart();
   }
@@ -274,7 +329,7 @@ public void onStart() {
    * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.
    */
   @Override
-  public void onStop() {
+  public synchronized void onStop() {
     pauseRequests();
     targetTracker.onStop();
   }
@@ -284,7 +339,7 @@ public void onStop() {
    * all completed requests.
    */
   @Override
-  public void onDestroy() {
+  public synchronized void onDestroy() {
     targetTracker.onDestroy();
     for (Target<?> target : targetTracker.getAll()) {
       clear(target);
@@ -303,24 +358,26 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link android.graphics.Bitmap}
    */
+  @NonNull
   @CheckResult
   public RequestBuilder<Bitmap> asBitmap() {
     return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
   }
 
   /**
-   * Attempts to always load the resource as a
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+   * Attempts to always load the resource as a {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}.
    *
-   * <p> If the underlying data is not a GIF, this will fail. As a result, this should only be used
+   * <p>If the underlying data is not a GIF, this will fail. As a result, this should only be used
    * if the model represents an animated GIF and the caller wants to interact with the GifDrawable
    * directly. Normally using just {@link #asDrawable()} is sufficient because it will determine
    * whether or not the given data represents an animated GIF and return the appropriate {@link
-   * Drawable}, animated or not, automatically. </p>
+   * Drawable}, animated or not, automatically.
    *
-   * @return A new request builder for loading a
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+   * @return A new request builder for loading a {@link
+   *     com.bumptech.glide.load.resource.gif.GifDrawable}.
    */
+  @NonNull
   @CheckResult
   public RequestBuilder<GifDrawable> asGif() {
     return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
@@ -330,24 +387,125 @@ public void onDestroy() {
    * Attempts to always load the resource using any registered {@link
    * com.bumptech.glide.load.ResourceDecoder}s that can decode any subclass of {@link Drawable}.
    *
-   * <p> By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
+   * <p>By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
    * GifDrawable}, but if additional decoders are registered for other {@link Drawable} subclasses,
-   * any of those subclasses may also be returned. </p>
+   * any of those subclasses may also be returned.
    *
    * @return A new request builder for loading a {@link Drawable}.
    */
+  @NonNull
   @CheckResult
   public RequestBuilder<Drawable> asDrawable() {
     return as(Drawable.class);
   }
 
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
+    return asDrawable().load(bitmap);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
+    return asDrawable().load(drawable);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable String string) {
+    return asDrawable().load(string);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Uri uri) {
+    return asDrawable().load(uri);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable File file) {
+    return asDrawable().load(file);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
+    return asDrawable().load(resourceId);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @CheckResult
+  @Override
+  @Deprecated
+  public RequestBuilder<Drawable> load(@Nullable URL url) {
+    return asDrawable().load(url);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable byte[] model) {
+    return asDrawable().load(model);
+  }
+
   /**
    * A helper method equivalent to calling {@link #asDrawable()} and then {@link
    * RequestBuilder#load(Object)} with the given model.
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
+  @NonNull
   @CheckResult
+  @Override
   public RequestBuilder<Drawable> load(@Nullable Object model) {
     return asDrawable().load(model);
   }
@@ -357,12 +515,12 @@ public void onDestroy() {
    * cached source data.
    *
    * <p>This method is designed to work for remote data that is or will be cached using {@link
-   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not
-   * recommended.
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not recommended.
    *
    * @return A new request builder for downloading content to cache and returning the cache File.
    */
+  @NonNull
   @CheckResult
   public RequestBuilder<File> downloadOnly() {
     return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
@@ -374,6 +532,7 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
+  @NonNull
   @CheckResult
   public RequestBuilder<File> download(@Nullable Object model) {
     return downloadOnly().load(model);
@@ -381,28 +540,31 @@ public void onDestroy() {
 
   /**
    * Attempts to always load a {@link File} containing the resource, either using a file path
-   * obtained from the media store (for local images/videos), or using Glide's disk cache
-   * (for remote images/videos).
+   * obtained from the media store (for local images/videos), or using Glide's disk cache (for
+   * remote images/videos).
    *
    * <p>For remote content, prefer {@link #downloadOnly()}.
    *
    * @return A new request builder for obtaining File paths to content.
    */
+  @NonNull
   @CheckResult
   public RequestBuilder<File> asFile() {
     return as(File.class).apply(skipMemoryCacheOf(true));
   }
 
   /**
-   * Attempts to load the resource using any registered
-   * {@link com.bumptech.glide.load.ResourceDecoder}s
-   * that can decode the given resource class or any subclass of the given resource class.
+   * Attempts to load the resource using any registered {@link
+   * com.bumptech.glide.load.ResourceDecoder}s that can decode the given resource class or any
+   * subclass of the given resource class.
    *
    * @param resourceClass The resource to decode.
    * @return A new request builder for loading the given resource class.
    */
+  @NonNull
   @CheckResult
-  public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
+  public <ResourceType> RequestBuilder<ResourceType> as(
+      @NonNull Class<ResourceType> resourceClass) {
     return new RequestBuilder<>(glide, this, resourceClass, context);
   }
 
@@ -410,49 +572,59 @@ public void onDestroy() {
    * Cancel any pending loads Glide may have for the view and free any resources that may have been
    * loaded for the view.
    *
-   * <p> Note that this will only work if {@link View#setTag(Object)} is not called on this view
-   * outside of Glide. </p>
+   * <p>Note that this will only work if {@link View#setTag(Object)} is not called on this view
+   * outside of Glide.
    *
    * @param view The view to cancel loads and free resources for.
    * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
-   *                                  tag.
+   *     tag.
    * @see #clear(Target)
    */
-  public void clear(View view) {
+  public void clear(@NonNull View view) {
     clear(new ClearTarget(view));
   }
 
   /**
-   * Cancel any pending loads Glide may have for the target and free any resources (such as
-   * {@link Bitmap}s) that may have been loaded for the target so they may be reused.
+   * Cancel any pending loads Glide may have for the target and free any resources (such as {@link
+   * Bitmap}s) that may have been loaded for the target so they may be reused.
    *
    * @param target The Target to cancel loads for.
    */
-  public void clear(@Nullable final Target<?> target) {
+  public synchronized void clear(@Nullable final Target<?> target) {
     if (target == null) {
       return;
     }
 
-    if (Util.isOnMainThread()) {
-      untrackOrDelegate(target);
-    } else {
-      mainHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          clear(target);
-        }
-      });
-    }
+    untrackOrDelegate(target);
   }
 
-  private void untrackOrDelegate(Target<?> target) {
+  private void untrackOrDelegate(@NonNull Target<?> target) {
     boolean isOwnedByUs = untrack(target);
-    if (!isOwnedByUs) {
-      glide.removeFromManagers(target);
+    // We'll end up here if the Target was cleared after the RequestManager that started the request
+    // is destroyed. That can happen for at least two reasons:
+    // 1. We call clear() on a background thread using something other than Application Context
+    // RequestManager.
+    // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
+    // Fragment is destroyed, starts a load with it, and then clears that load with a different
+    // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
+    //
+    // #1 is always an error. At best the caller is leaking memory briefly in something like an
+    // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
+    // time if they do something like reference the Activity RequestManager in a long lived
+    // background thread or task.
+    //
+    // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
+    // the corresponding Activity or Fragment is destroyed because retaining any reference to the
+    // RequestManager leaks memory. It's possible that there's some brief period of time during or
+    // immediately after onDestroy where this is reasonable, but I can't think of why.
+    if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
+      Request request = target.getRequest();
+      target.setRequest(null);
+      request.clear();
     }
   }
 
-  boolean untrack(Target<?> target) {
+  synchronized boolean untrack(@NonNull Target<?> target) {
     Request request = target.getRequest();
     // If the Target doesn't have a request, it's already been cleared.
     if (request == null) {
@@ -468,12 +640,16 @@ boolean untrack(Target<?> target) {
     }
   }
 
-  void track(Target<?> target, Request request) {
+  synchronized void track(@NonNull Target<?> target, @NonNull Request request) {
     targetTracker.track(target);
     requestTracker.runRequest(request);
   }
 
-  RequestOptions getDefaultRequestOptions() {
+  List<RequestListener<Object>> getDefaultRequestListeners() {
+    return defaultRequestListeners;
+  }
+
+  synchronized RequestOptions getDefaultRequestOptions() {
     return requestOptions;
   }
 
@@ -483,34 +659,48 @@ RequestOptions getDefaultRequestOptions() {
   }
 
   @Override
-  public String toString() {
+  public synchronized String toString() {
     return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
   }
 
-  private static class RequestManagerConnectivityListener implements ConnectivityMonitor
-      .ConnectivityListener {
+  private class RequestManagerConnectivityListener
+      implements ConnectivityMonitor.ConnectivityListener {
+    @GuardedBy("RequestManager.this")
     private final RequestTracker requestTracker;
 
-    public RequestManagerConnectivityListener(RequestTracker requestTracker) {
+    RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
       this.requestTracker = requestTracker;
     }
 
     @Override
     public void onConnectivityChanged(boolean isConnected) {
       if (isConnected) {
-        requestTracker.restartRequests();
+        synchronized (RequestManager.this) {
+          requestTracker.restartRequests();
+        }
       }
     }
   }
 
-  private static class ClearTarget extends ViewTarget<View, Object> {
+  private static class ClearTarget extends CustomViewTarget<View, Object> {
 
-    public ClearTarget(View view) {
+    ClearTarget(@NonNull View view) {
       super(view);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    protected void onResourceCleared(@Nullable Drawable placeholder) {
+      // Do nothing, we don't retain a reference to our resource.
+    }
+
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
       // Do nothing.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
index 7768f6fcc..0132cd699 100644
--- a/library/src/main/java/com/bumptech/glide/TransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.request.transition.NoTransition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.request.transition.ViewAnimationFactory;
@@ -10,11 +11,12 @@
 /**
  * A base class for setting a transition to use on a resource when a load completes.
  *
- * @param <CHILD>         The implementation of this class to return to chain methods.
+ * @param <CHILD> The implementation of this class to return to chain methods.
  * @param <TranscodeType> The type of resource that will be animated.
  */
-public abstract class TransitionOptions<CHILD extends TransitionOptions<CHILD, TranscodeType>,
-    TranscodeType> implements Cloneable {
+public abstract class TransitionOptions<
+        CHILD extends TransitionOptions<CHILD, TranscodeType>, TranscodeType>
+    implements Cloneable {
   private TransitionFactory<? super TranscodeType> transitionFactory = NoTransition.getFactory();
 
   /**
@@ -23,44 +25,63 @@
    *
    * @return This request builder.
    */
+  @NonNull
   public final CHILD dontTransition() {
     return transition(NoTransition.getFactory());
   }
 
   /**
    * Sets an {@link android.view.animation.Animation} to run on the wrapped target when an resource
-   * load finishes.
-   * Will only be run if the resource was loaded asynchronously (i.e. was not in the memory cache).
+   * load finishes. Will only be run if the resource was loaded asynchronously (i.e. was not in the
+   * memory cache).
    *
    * @param viewAnimationId The resource id of the {@link android.view.animation} to use as the
-   *                        transition.
+   *     transition.
    * @return This request builder.
    */
+  @NonNull
   public final CHILD transition(int viewAnimationId) {
-    return transition(new ViewAnimationFactory<TranscodeType>(viewAnimationId));
+    return transition(new ViewAnimationFactory<>(viewAnimationId));
   }
 
   /**
    * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target
-   * may be wrapping when a resource load finishes.
-   * Will only be run if the load was loaded asynchronously (i.e. was not in the memory cache).
+   * may be wrapping when a resource load finishes. Will only be run if the load was loaded
+   * asynchronously (i.e. was not in the memory cache).
    *
    * @param animator The {@link com.bumptech.glide.request.transition.ViewPropertyTransition
-   *                 .Animator} to run.
+   *     .Animator} to run.
    * @return This request builder.
    */
-  public final CHILD transition(ViewPropertyTransition.Animator animator) {
-    return transition(new ViewPropertyAnimationFactory<TranscodeType>(animator));
+  @NonNull
+  public final CHILD transition(@NonNull ViewPropertyTransition.Animator animator) {
+    return transition(new ViewPropertyAnimationFactory<>(animator));
   }
 
-  public final CHILD transition(TransitionFactory<? super TranscodeType> transitionFactory) {
+  /**
+   * Uses the given {@link TransitionFactory} to build a {@link
+   * com.bumptech.glide.request.transition.Transition} for each request started with these {@code
+   * TransitionOptions}.
+   *
+   * @return This request builder.
+   */
+  @NonNull
+  public final CHILD transition(
+      @NonNull TransitionFactory<? super TranscodeType> transitionFactory) {
     this.transitionFactory = Preconditions.checkNotNull(transitionFactory);
     return self();
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+    // cast to CHILD is safe given the generic argument represents the object's runtime class
+    "unchecked",
+    // CHILD is the correct class name.
+    "PMD.CloneMethodReturnTypeMustMatchClassName",
+    // we don't want to throw to be user friendly
+    "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @Override
-  protected final CHILD clone() {
+  public final CHILD clone() {
     try {
       return (CHILD) super.clone();
     } catch (CloneNotSupportedException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/DataSource.java b/library/src/main/java/com/bumptech/glide/load/DataSource.java
index 699a13bfe..d266c7f0a 100644
--- a/library/src/main/java/com/bumptech/glide/load/DataSource.java
+++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java
@@ -1,28 +1,18 @@
 package com.bumptech.glide.load;
 
-/**
- * Indicates the origin of some retrieved data.
- */
+/** Indicates the origin of some retrieved data. */
 public enum DataSource {
   /**
    * Indicates data was probably retrieved locally from the device, although it may have been
    * obtained through a content provider that may have obtained the data from a remote source.
    */
   LOCAL,
-  /**
-   * Indicates data was retrieved from a remote source other than the device.
-   */
+  /** Indicates data was retrieved from a remote source other than the device. */
   REMOTE,
-  /**
-   * Indicates data was retrieved unmodified from the on device cache.
-   */
+  /** Indicates data was retrieved unmodified from the on device cache. */
   DATA_DISK_CACHE,
-  /**
-   * Indicates data was retrieved from modified content in the on device cache.
-   */
+  /** Indicates data was retrieved from modified content in the on device cache. */
   RESOURCE_DISK_CACHE,
-  /**
-   * Indicates data was retrieved from the in memory cache.
-   */
+  /** Indicates data was retrieved from the in memory cache. */
   MEMORY_CACHE,
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index 4837ec515..ad9cb2efc 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -1,55 +1,44 @@
 package com.bumptech.glide.load;
 
 /**
- * Options for setting the value of {@link android.graphics.Bitmap#getConfig()} for
- * {@link android.graphics.Bitmap}s returned by {@link com.bumptech.glide.load.ResourceDecoder}s.
+ * Options for setting the value of {@link android.graphics.Bitmap#getConfig()} for {@link
+ * android.graphics.Bitmap}s returned by {@link com.bumptech.glide.load.ResourceDecoder}s.
  *
- * <p> Note - In some cases it may not be possible to obey the requested setting, not all
- * {@link com.bumptech.glide.load.resource.bitmap.Downsampler}s support setting formats and certain
- * images may not be able to be loaded as certain configurations. Therefore this class represents a
- * preference rather than a requirement. </p>
+ * <p>Note - In some cases it may not be possible to obey the requested setting, not all {@link
+ * com.bumptech.glide.load.resource.bitmap.Downsampler}s support setting formats and certain images
+ * may not be able to be loaded as certain configurations. Therefore this class represents a
+ * preference rather than a requirement.
  */
 public enum DecodeFormat {
   /**
-   * Bitmaps returned by the {@link com.bumptech.glide.load.ResourceDecoder}.
-   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
-   * {@link android.graphics.Bitmap#getConfig()} when possible.
+   * Bitmaps returned by the {@link com.bumptech.glide.load.ResourceDecoder}. should return {@link
+   * android.graphics.Bitmap.Config#ARGB_8888} for {@link android.graphics.Bitmap#getConfig()} when
+   * possible.
    *
-   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
-   * {@link android.graphics.Bitmap.Config#HARDWARE}.
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use {@link
+   * android.graphics.Bitmap.Config#HARDWARE}. More information is available about hardware Bitmaps
+   * here: https://goo.gl/tn2A6k. If you need to disable hardware Bitmaps for a particular request,
+   * use {@link com.bumptech.glide.request.RequestOptions#disallowHardwareConfig()}.
    *
-   * <p> GIF images decoded by {@link android.graphics.BitmapFactory} currently use an internal
+   * <p>GIF images decoded by {@link android.graphics.BitmapFactory} currently use an internal
    * hidden format that is returned as null from {@link android.graphics.Bitmap#getConfig()}. Since
    * we cannot force {@link android.graphics.BitmapFactory} to always return our desired config,
    * this setting is a preference, not a promise.
    */
   PREFER_ARGB_8888,
 
-  /**
-   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link
-   * android.graphics.Bitmap.Config#HARDWARE} on Android O+.
-   *
-   * @deprecated If you must disable hardware bitmaps, set
-   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false
-   * instead.
-   */
-  @Deprecated
-  PREFER_ARGB_8888_DISALLOW_HARDWARE,
-
   /**
    * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)
-   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
-   * {@link android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or
-   * use alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for
-   * {@link android.graphics.Bitmap#getConfig()}.
+   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for {@link
+   * android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or use
+   * alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for {@link
+   * android.graphics.Bitmap#getConfig()}.
    *
-   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
-   * {@link android.graphics.Bitmap.Config#HARDWARE}.
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use {@link
+   * android.graphics.Bitmap.Config#HARDWARE}.
    */
   PREFER_RGB_565;
 
-  /**
-   * The default value for DecodeFormat.
-   */
-  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;
+  /** The default value for DecodeFormat. */
+  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java b/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java
index 33eed74dc..950ca398b 100644
--- a/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java
@@ -10,13 +10,9 @@
    */
   SOURCE,
 
-  /**
-   * Writes the decoded, downsampled and transformed data for the resource to disk.
-   */
+  /** Writes the decoded, downsampled and transformed data for the resource to disk. */
   TRANSFORMED,
 
-  /**
-   * Will write no data.
-   */
+  /** Will write no data. */
   NONE,
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Encoder.java b/library/src/main/java/com/bumptech/glide/load/Encoder.java
index db652b1ad..920433e93 100644
--- a/library/src/main/java/com/bumptech/glide/load/Encoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import androidx.annotation.NonNull;
 import java.io.File;
 
 /**
@@ -8,7 +9,6 @@
  * @param <T> The type of the data that will be written.
  */
 public interface Encoder<T> {
-
   /**
    * Writes the given data to the given output stream and returns True if the write completed
    * successfully and should be committed.
@@ -17,5 +17,5 @@
    * @param file The File to write the data to.
    * @param options The put of options to apply when encoding.
    */
-  boolean encode(T data, File file, Options options);
+  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/HttpException.java b/library/src/main/java/com/bumptech/glide/load/HttpException.java
index 6b4430c98..ce265c6c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/HttpException.java
+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java
@@ -1,16 +1,20 @@
 package com.bumptech.glide.load;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import java.io.IOException;
 
 /**
  * Thrown when an http request fails.
  *
- * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so
- * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of
- * the underlying http library.
+ * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so users may
+ * attempt to retry or otherwise uniformly handle certain types of errors regardless of the
+ * underlying http library.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public final class HttpException extends IOException {
+  private static final long serialVersionUID = 1L;
+
   public static final int UNKNOWN = -1;
   private final int statusCode;
 
@@ -32,8 +36,8 @@ public HttpException(String message, int statusCode, @Nullable Throwable cause)
   }
 
   /**
-   * Returns the http status code, or {@link #UNKNOWN} if the request failed without providing
-   * a status code.
+   * Returns the http status code, or {@link #UNKNOWN} if the request failed without providing a
+   * status code.
    */
   public int getStatusCode() {
     return statusCode;
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
index 6cecef3ac..ce3606626 100644
--- a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -1,24 +1,22 @@
 package com.bumptech.glide.load;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 
-/**
- * Interface for the ImageHeaderParser.
- */
+/** Interface for the ImageHeaderParser. */
 public interface ImageHeaderParser {
   /**
-   * A constant indicating we were unable to parse the orientation from the image either because
-   * no exif segment containing orientation data existed, or because of an I/O error attempting to
-   * read the exif segment.
+   * A constant indicating we were unable to parse the orientation from the image either because no
+   * exif segment containing orientation data existed, or because of an I/O error attempting to read
+   * the exif segment.
    */
   int UNKNOWN_ORIENTATION = -1;
 
   /**
-   * The format of the image data including whether or not the image may include transparent
-   * pixels.
+   * The format of the image data including whether or not the image may include transparent pixels.
    */
   enum ImageType {
     GIF(true),
@@ -32,10 +30,9 @@
     WEBP_A(true),
     /** WebP type without alpha. */
     WEBP(false),
-    /**
-     * Unrecognized type.
-     */
+    /** Unrecognized type. */
     UNKNOWN(false);
+
     private final boolean hasAlpha;
 
     ImageType(boolean hasAlpha) {
@@ -47,17 +44,21 @@ public boolean hasAlpha() {
     }
   }
 
-  ImageType getType(InputStream is) throws IOException;
-  ImageType getType(ByteBuffer byteBuffer) throws IOException;
+  @NonNull
+  ImageType getType(@NonNull InputStream is) throws IOException;
+
+  @NonNull
+  ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException;
 
   /**
    * Parse the orientation from the image header. If it doesn't handle this image type (or this is
    * not an image) it will return a default value rather than throwing an exception.
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
-   * contain an orientation
-   * @throws IOException
+   *     contain an orientation
    */
-  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;
-  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;
+  int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException;
+
+  int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
index b092e15f2..030e3ea7d 100644
--- a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
@@ -9,19 +10,21 @@
 import java.nio.ByteBuffer;
 import java.util.List;
 
-/**
- * Utilities for the ImageHeaderParser.
- */
+/** Utilities for the ImageHeaderParser. */
 public final class ImageHeaderParserUtils {
   // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but
   // will resize up to this amount if necessary.
   private static final int MARK_POSITION = 5 * 1024 * 1024;
 
-  private ImageHeaderParserUtils() { }
+  private ImageHeaderParserUtils() {}
 
   /** Returns the ImageType for the given InputStream. */
-  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable InputStream is,
-      ArrayPool byteArrayPool) throws IOException {
+  @NonNull
+  public static ImageType getType(
+      @NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is,
+      @NonNull ArrayPool byteArrayPool)
+      throws IOException {
     if (is == null) {
       return ImageType.UNKNOWN;
     }
@@ -31,7 +34,9 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable Input
     }
 
     is.mark(MARK_POSITION);
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       try {
         ImageType type = parser.getType(is);
         if (type != ImageType.UNKNOWN) {
@@ -46,13 +51,16 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable Input
   }
 
   /** Returns the ImageType for the given ByteBuffer. */
-  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer)
-      throws IOException {
+  @NonNull
+  public static ImageType getType(
+      @NonNull List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer) throws IOException {
     if (buffer == null) {
       return ImageType.UNKNOWN;
     }
 
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       ImageType type = parser.getType(buffer);
       if (type != ImageType.UNKNOWN) {
         return type;
@@ -63,8 +71,11 @@ public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteB
   }
 
   /** Returns the orientation for the given InputStream. */
-  public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable InputStream is,
-      ArrayPool byteArrayPool) throws IOException {
+  public static int getOrientation(
+      @NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is,
+      @NonNull ArrayPool byteArrayPool)
+      throws IOException {
     if (is == null) {
       return ImageHeaderParser.UNKNOWN_ORIENTATION;
     }
@@ -74,7 +85,9 @@ public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable Inpu
     }
 
     is.mark(MARK_POSITION);
-    for (ImageHeaderParser parser : parsers) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
       try {
         int orientation = parser.getOrientation(is, byteArrayPool);
         if (orientation != ImageHeaderParser.UNKNOWN_ORIENTATION) {
diff --git a/library/src/main/java/com/bumptech/glide/load/Key.java b/library/src/main/java/com/bumptech/glide/load/Key.java
index 47bb2e01a..d5d4f128f 100644
--- a/library/src/main/java/com/bumptech/glide/load/Key.java
+++ b/library/src/main/java/com/bumptech/glide/load/Key.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import androidx.annotation.NonNull;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
 
@@ -18,14 +19,22 @@
   /**
    * Adds all uniquely identifying information to the given digest.
    *
-   * <p> Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result
-   * in undefined behavior. </p>
+   * <p>Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result
+   * in undefined behavior.
    */
-  void updateDiskCacheKey(MessageDigest messageDigest);
+  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);
 
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and {@link
+   * #hashCode()}.
+   */
   @Override
   boolean equals(Object o);
 
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and {@link
+   * #equals(Object)}.
+   */
   @Override
   int hashCode();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index c4c5d712b..149f047f6 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import java.security.MessageDigest;
 import java.util.Arrays;
@@ -15,15 +16,16 @@
   private final Collection<? extends Transformation<T>> transformations;
 
   @SafeVarargs
-  public MultiTransformation(Transformation<T>... transformations) {
-    if (transformations.length < 1) {
+  @SuppressWarnings("varargs")
+  public MultiTransformation(@NonNull Transformation<T>... transformations) {
+    if (transformations.length == 0) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
     this.transformations = Arrays.asList(transformations);
   }
 
-  public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
+  public MultiTransformation(@NonNull Collection<? extends Transformation<T>> transformationList) {
     if (transformationList.isEmpty()) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
@@ -31,9 +33,10 @@ public MultiTransformation(Collection<? extends Transformation<T>> transformatio
     this.transformations = transformationList;
   }
 
+  @NonNull
   @Override
   public Resource<T> transform(
-      Context context, Resource<T> resource, int outWidth, int outHeight) {
+      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {
     Resource<T> previous = resource;
 
     for (Transformation<T> transformation : transformations) {
@@ -61,7 +64,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     for (Transformation<T> transformation : transformations) {
       transformation.updateDiskCacheKey(messageDigest);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index a63bdc44b..888cb6bc9 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.util.Preconditions;
 import java.security.MessageDigest;
 
@@ -9,27 +10,25 @@
  * default values and the ability to affect the resource disk cache key used by {@link
  * com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE}.
  *
- * <p>
- *   Implementations must either be unique (usually declared as static final variables), or
- *   implement {@link #equals(Object)} and {@link #hashCode()}.
- * </p>
+ * <p>Implementations must either be unique (usually declared as static final variables), or
+ * implement {@link #equals(Object)} and {@link #hashCode()}.
  *
- * <p>
- *   Implementations can implement {@link #update(Object, MessageDigest)} to make sure that
- *   the disk cache key includes the specific option set.
- * </p>
+ * <p>Implementations can implement {@link #update(Object, MessageDigest)} to make sure that the
+ * disk cache key includes the specific option set.
  *
  * @param <T> The type of the option ({@link Integer}, {@link
- * android.graphics.Bitmap.CompressFormat} etc.), must implement {@link #equals(Object)} and
- * {@link #hashCode()}.
+ *     android.graphics.Bitmap.CompressFormat} etc.), must implement {@link #equals(Object)} and
+ *     {@link #hashCode()}.
  */
 public final class Option<T> {
-  private static final CacheKeyUpdater<Object> EMPTY_UPDATER = new CacheKeyUpdater<Object>() {
-    @Override
-    public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
-      // Do nothing.
-    }
-  };
+  private static final CacheKeyUpdater<Object> EMPTY_UPDATER =
+      new CacheKeyUpdater<Object>() {
+        @Override
+        public void update(
+            @NonNull byte[] keyBytes, @NonNull Object value, @NonNull MessageDigest messageDigest) {
+          // Do nothing.
+        }
+      };
 
   private final T defaultValue;
   private final CacheKeyUpdater<T> cacheKeyUpdater;
@@ -40,21 +39,23 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * Returns a new {@link Option} that does not affect disk cache keys with a {@code null} default
    * value.
    *
-   * @param key A unique package prefixed {@link String} that identifies this option (must be
-   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   * @param key A unique package prefixed {@link String} that identifies this option (must be stable
+   *     across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> memory(String key) {
-    return new Option<>(key, null /*defaultValue*/, Option.<T>emptyUpdater());
+  @NonNull
+  public static <T> Option<T> memory(@NonNull String key) {
+    return new Option<>(key, null, Option.<T>emptyUpdater());
   }
 
   /**
    * Returns a new {@link Option} that does not affect disk cache keys with the given value as the
    * default value.
    *
-   * @param key A unique package prefixed {@link String} that identifies this option (must be
-   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   * @param key A unique package prefixed {@link String} that identifies this option (must be stable
+   *     across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> memory(String key, T defaultValue) {
+  @NonNull
+  public static <T> Option<T> memory(@NonNull String key, @NonNull T defaultValue) {
     return new Option<>(key, defaultValue, Option.<T>emptyUpdater());
   }
 
@@ -62,48 +63,54 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * Returns a new {@link Option} that uses the given {@link
    * com.bumptech.glide.load.Option.CacheKeyUpdater} to update disk cache keys.
    *
-   * @param key A unique package prefixed {@link String} that identifies this option (must be
-   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   * @param key A unique package prefixed {@link String} that identifies this option (must be stable
+   *     across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> disk(String key, CacheKeyUpdater<T> cacheKeyUpdater) {
-    return new Option<>(key, null /*defaultValue*/, cacheKeyUpdater);
+  @NonNull
+  public static <T> Option<T> disk(
+      @NonNull String key, @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
+    return new Option<>(key, null, cacheKeyUpdater);
   }
 
   /**
    * Returns a new {@link Option} that uses the given {@link
-   * com.bumptech.glide.load.Option.CacheKeyUpdater} to update disk cache keys and provides
-   * the given value as the default value.
+   * com.bumptech.glide.load.Option.CacheKeyUpdater} to update disk cache keys and provides the
+   * given value as the default value.
    *
-   * @param key A unique package prefixed {@link String} that identifies this option (must be
-   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   * @param key A unique package prefixed {@link String} that identifies this option (must be stable
+   *     across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> disk(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+  @NonNull
+  public static <T> Option<T> disk(
+      @NonNull String key, @Nullable T defaultValue, @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     return new Option<>(key, defaultValue, cacheKeyUpdater);
   }
 
-  Option(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+  private Option(
+      @NonNull String key, @Nullable T defaultValue, @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     this.key = Preconditions.checkNotEmpty(key);
     this.defaultValue = defaultValue;
     this.cacheKeyUpdater = Preconditions.checkNotNull(cacheKeyUpdater);
   }
 
-  /**
-   * Returns a reasonable default to use if no other value is set, or {@code null}.
-   */
+  /** Returns a reasonable default to use if no other value is set, or {@code null}. */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   @Nullable
   public T getDefaultValue() {
     return defaultValue;
   }
 
   /**
-   * Updates the given {@link MessageDigest} used to construct a cache key with the given
-   * value using the {@link com.bumptech.glide.load.Option.CacheKeyUpdater} optionally provided in
-   * the constructor.
+   * Updates the given {@link MessageDigest} used to construct a cache key with the given value
+   * using the {@link com.bumptech.glide.load.Option.CacheKeyUpdater} optionally provided in the
+   * constructor.
    */
-  public void update(T value, MessageDigest messageDigest) {
+  public void update(@NonNull T value, @NonNull MessageDigest messageDigest) {
     cacheKeyUpdater.update(getKeyBytes(), value, messageDigest);
   }
 
+  @NonNull
   private byte[] getKeyBytes() {
     if (keyBytes == null) {
       keyBytes = key.getBytes(Key.CHARSET);
@@ -125,6 +132,7 @@ public int hashCode() {
     return key.hashCode();
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <T> CacheKeyUpdater<T> emptyUpdater() {
     return (CacheKeyUpdater<T>) EMPTY_UPDATER;
@@ -132,9 +140,7 @@ public int hashCode() {
 
   @Override
   public String toString() {
-    return "Option{"
-        + "key='" + key + '\''
-        + '}';
+    return "Option{" + "key='" + key + '\'' + '}';
   }
 
   /**
@@ -147,7 +153,18 @@ public String toString() {
     /**
      * Updates the given {@link MessageDigest} with the bytes of the given key (to avoid incidental
      * value collisions when values are not particularly unique) and value.
+     *
+     * <p>If your {@link Option} shouldn't affect the disk cache key, you should not implement this
+     * class and use {@link Option#memory(String)} or {@link Option#memory(String, Object)} instead.
+     *
+     * @param keyBytes The bytes of the {@link String} used as the key for this particular {@link
+     *     Option}. Should be added to the {@code messageDigest} using {@link
+     *     MessageDigest#update(byte[])} by all implementations if the digest is updated with the
+     *     given {@code value} parameter.
+     * @param value The value of of this particular option. Typically you should convert the value
+     *     to a byte array using some stable mechanism and then call {@link
+     *     MessageDigest#update(byte[])} to update the given digest.
      */
-    void update(byte[] keyBytes, T value, MessageDigest messageDigest);
+    void update(@NonNull byte[] keyBytes, @NonNull T value, @NonNull MessageDigest messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Options.java b/library/src/main/java/com/bumptech/glide/load/Options.java
index 32aa7c227..281470acd 100644
--- a/library/src/main/java/com/bumptech/glide/load/Options.java
+++ b/library/src/main/java/com/bumptech/glide/load/Options.java
@@ -1,27 +1,29 @@
 package com.bumptech.glide.load;
 
-import android.support.v4.util.ArrayMap;
-import android.support.v4.util.SimpleArrayMap;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.collection.ArrayMap;
+import androidx.collection.SimpleArrayMap;
+import com.bumptech.glide.util.CachedHashCodeArrayMap;
 import java.security.MessageDigest;
-import java.util.Map;
 
-/**
- * A set of {@link Option Options} to apply to in memory and disk cache keys.
- */
+/** A set of {@link Option Options} to apply to in memory and disk cache keys. */
 public final class Options implements Key {
-  private final ArrayMap<Option<?>, Object> values = new ArrayMap<>();
+  private final ArrayMap<Option<?>, Object> values = new CachedHashCodeArrayMap<>();
 
-  public void putAll(Options other) {
+  public void putAll(@NonNull Options other) {
     values.putAll((SimpleArrayMap<Option<?>, Object>) other.values);
   }
 
-  public <T> Options set(Option<T> option, T value) {
+  @NonNull
+  public <T> Options set(@NonNull Option<T> option, @NonNull T value) {
     values.put(option, value);
     return this;
   }
 
+  @Nullable
   @SuppressWarnings("unchecked")
-  public <T> T get(Option<T> option) {
+  public <T> T get(@NonNull Option<T> option) {
     return values.containsKey(option) ? (T) values.get(option) : option.getDefaultValue();
   }
 
@@ -40,21 +42,22 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    for (Map.Entry<Option<?>, Object> entry : values.entrySet()) {
-      updateDiskCacheKey(entry.getKey(), entry.getValue(), messageDigest);
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    for (int i = 0; i < values.size(); i++) {
+      Option<?> key = values.keyAt(i);
+      Object value = values.valueAt(i);
+      updateDiskCacheKey(key, value, messageDigest);
     }
   }
 
   @Override
   public String toString() {
-    return "Options{"
-        + "values=" + values
-        + '}';
+    return "Options{" + "values=" + values + '}';
   }
 
   @SuppressWarnings("unchecked")
-  private static <T> void updateDiskCacheKey(Option<T> option, Object value, MessageDigest md) {
+  private static <T> void updateDiskCacheKey(
+      @NonNull Option<T> option, @NonNull Object value, @NonNull MessageDigest md) {
     option.update((T) value, md);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index f8e67f7e0..5d455debb 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.engine.Resource;
 import java.io.IOException;
 
@@ -16,44 +17,40 @@
    * Returns {@code true} if this decoder is capable of decoding the given source with the given
    * options, and {@code false} otherwise.
    *
-   * <p> Decoders should make a best effort attempt to quickly determine if they are likely to be
+   * <p>Decoders should make a best effort attempt to quickly determine if they are likely to be
    * able to decode data, but should not attempt to completely read the given data. A typical
    * implementation would check the file headers verify they match content the decoder expects to
-   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block. </p>
+   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block.
    *
-   * <p> Decoders that return {@code true} from {@link #handles(Object, Options)} may still
-   * return {@code null} from {@link #decode(Object, int, int, Options)} if the data is
-   * partial or formatted incorrectly. </p>
-   *
-   * @throws IOException
+   * <p>Decoders that return {@code true} from {@code handles} may still return {@code null} from
+   * {@link #decode(Object, int, int, Options)} if the data is partial or formatted incorrectly.
    */
-  boolean handles(T source, Options options) throws IOException;
+  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;
 
   /**
    * Returns a decoded resource from the given data or null if no resource could be decoded.
    *
-   * <p> The {@code source} is managed by the caller, there's no need to close it. The returned
-   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit. </p>
+   * <p>The {@code source} is managed by the caller, there's no need to close it. The returned
+   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit.
    *
-   * <p> Note - The {@code width} and {@code height} arguments are hints only, there is no
+   * <p>Note - The {@code width} and {@code height} arguments are hints only, there is no
    * requirement that the decoded resource exactly match the given dimensions. A typical use case
    * would be to use the target dimensions to determine how much to downsample Bitmaps by to avoid
-   * overly large allocations. </p>
+   * overly large allocations.
    *
-   * @param source  The data the resource should be decoded from.
-   * @param width   The ideal width in pixels of the decoded resource, or {@link
-   *                com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original
-   *                resource width.
-   * @param height  The ideal height in pixels of the decoded resource, or {@link
-   *                com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original
-   *                resource height.
+   * @param source The data the resource should be decoded from.
+   * @param width The ideal width in pixels of the decoded resource, or {@link
+   *     com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+   *     width.
+   * @param height The ideal height in pixels of the decoded resource, or {@link
+   *     com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+   *     height.
    * @param options A map of string keys to objects that may or may not contain options available to
-   *                this particular implementation. Implementations should not assume that any or
-   *                all of their option keys are present. However, implementations may assume that
-   *                if one of their option keys is present, it's value is non-null and is of the
-   *                expected type.
-   * @throws IOException
+   *     this particular implementation. Implementations should not assume that any or all of their
+   *     option keys are present. However, implementations may assume that if one of their option
+   *     keys is present, it's value is non-null and is of the expected type.
    */
   @Nullable
-  Resource<Z> decode(T source, int width, int height, Options options) throws IOException;
+  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options)
+      throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
index 941d3845d..dc1e0f4a5 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -10,5 +11,6 @@
  */
 public interface ResourceEncoder<T> extends Encoder<Resource<T>> {
   // specializing the generic arguments
-  EncodeStrategy getEncodeStrategy(Options options);
+  @NonNull
+  EncodeStrategy getEncodeStrategy(@NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index 3d5c96e0f..ad758815d 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -1,19 +1,28 @@
 package com.bumptech.glide.load;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
 
 /**
- * A class for performing an arbitrary transformation on a resource that implements
- * {@link #equals(Object)} and {@link #hashCode()}} to identify the transformation in the memory
- * cache and {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the
- * transformation in disk caches.
+ * A class for performing an arbitrary transformation on a resource that implements {@link
+ * #equals(Object)} and {@link #hashCode()}} to identify the transformation in the memory cache and
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the transformation in disk
+ * caches.
  *
- * <p>Using the fully qualified class name (not {@link Class#getName()} to avoid proguard
- * obfuscation) is an easy way to implement
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly.
+ * <p>Using the fully qualified class name as a static final {@link String} (not {@link
+ * Class#getName()} to avoid proguard obfuscation) is an easy way to implement {@link
+ * #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * required they can be passed in to the constructor of the {@code Transformation} and then used to
+ * update the {@link java.security.MessageDigest} passed in to {@link
+ * #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically easily
+ * be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized with
+ * {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
  *
- * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()}.
+ * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()} for
+ * memory caching to work correctly.
  *
  * @param <T> The type of the resource being transformed.
  */
@@ -22,20 +31,19 @@
   /**
    * Transforms the given resource and returns the transformed resource.
    *
-   * <p>If the original resource object is not returned, the original resource will be
-   * recycled and it's internal resources may be reused. This means it is not safe to rely on the
-   * original resource or any internal state of the original resource in any new resource that is
-   * created. Usually this shouldn't occur, but if absolutely necessary either the original resource
-   * object can be returned with modified internal state, or the data in the original resource can
-   * be copied into the transformed resource.
+   * <p>If the original resource object is not returned, the original resource will be recycled and
+   * it's internal resources may be reused. This means it is not safe to rely on the original
+   * resource or any internal state of the original resource in any new resource that is created.
+   * Usually this shouldn't occur, but if absolutely necessary either the original resource object
+   * can be returned with modified internal state, or the data in the original resource can be
+   * copied into the transformed resource.
    *
-   * <p>If a Transformation is updated, {@link #equals(Object)}, {@link #hashCode()}, and
-   * {@link #updateDiskCacheKey(java.security.MessageDigest)} should all change. If you're using a
-   * simple String key an easy way to do this is to append a version number to your key. Failing to
-   * do so will mean users may see images loaded from cache that had the old version of the
-   * Transformation applied. Changing the return values of those methods will ensure that the cache
-   * key has changed and therefore that any cached resources will be re-generated using the updated
-   * Transformation.
+   * <p>If a Transformation is updated, {@link #equals(Object)}, {@link #hashCode()}, and {@link
+   * #updateDiskCacheKey(java.security.MessageDigest)} should all change. If you're using a simple
+   * String key an easy way to do this is to append a version number to your key. Failing to do so
+   * will mean users may see images loaded from cache that had the old version of the Transformation
+   * applied. Changing the return values of those methods will ensure that the cache key has changed
+   * and therefore that any cached resources will be re-generated using the updated Transformation.
    *
    * <p>During development you may need to either using {@link
    * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} or make sure {@link
@@ -44,28 +52,16 @@
    * Transformation may not be called.
    *
    * @param context The Application context
-   * @param resource  The resource to transform.
-   * @param outWidth  The width of the view or target the resource will be displayed in, or {@link
-   *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
-   *                  original resource width.
+   * @param resource The resource to transform.
+   * @param outWidth The width of the view or target the resource will be displayed in, or {@link
+   *     com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+   *     width.
    * @param outHeight The height of the view or target the resource will be displayed in, or {@link
-   *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
-   *                  original resource height.
+   *     com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+   *     height.
    * @return The transformed resource.
    */
-  Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight);
-
-  /**
-   * For caching to work correctly, implementations <em>must</em> implement this method and
-   * {@link #hashCode()}.
-   */
-  @Override
-  boolean equals(Object o);
-
-  /**
-   * For caching to work correctly, implementations <em>must</em> implement this method and
-   * {@link #equals(Object)}.
-   */
-  @Override
-  int hashCode();
+  @NonNull
+  Resource<T> transform(
+      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
new file mode 100644
index 000000000..1667249ce
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
@@ -0,0 +1,37 @@
+package com.bumptech.glide.load.data;
+
+import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
+import android.net.Uri;
+import androidx.annotation.NonNull;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+/** Fetches an {@link AssetFileDescriptor} for a local {@link android.net.Uri}. */
+public final class AssetFileDescriptorLocalUriFetcher extends LocalUriFetcher<AssetFileDescriptor> {
+
+  public AssetFileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
+  }
+
+  @Override
+  protected AssetFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    AssetFileDescriptor result = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (result == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return result;
+  }
+
+  @Override
+  protected void close(AssetFileDescriptor data) throws IOException {
+    data.close();
+  }
+
+  @NonNull
+  @Override
+  public Class<AssetFileDescriptor> getDataClass() {
+    return AssetFileDescriptor.class;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 366a9ad3d..cd67ad3da 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.data;
 
 import android.content.res.AssetManager;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import java.io.IOException;
@@ -19,13 +19,15 @@
   private final AssetManager assetManager;
   private T data;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public AssetPathFetcher(AssetManager assetManager, String assetPath) {
     this.assetManager = assetManager;
     this.assetPath = assetPath;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super T> callback) {
+  public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(assetManager, assetPath);
     } catch (IOException e) {
@@ -66,7 +68,7 @@ public DataSource getDataSource() {
    * the concrete data type returned by the AssetManager.
    *
    * @param assetManager An AssetManager to use to open the given path.
-   * @param path         A string path pointing to a resource in assets to open.
+   * @param path A string path pointing to a resource in assets to open.
    */
   protected abstract T loadResource(AssetManager assetManager, String path) throws IOException;
 
@@ -74,7 +76,6 @@ public DataSource getDataSource() {
    * Closes the concrete data type if necessary.
    *
    * @param data The data to close.
-   * @throws IOException
    */
   protected abstract void close(T data) throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
new file mode 100644
index 000000000..191e365ac
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.load.data;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * An {@link OutputStream} implementation that recycles and re-uses {@code byte[]}s using the
+ * provided {@link ArrayPool}.
+ */
+public final class BufferedOutputStream extends OutputStream {
+  @NonNull private final OutputStream out;
+  private byte[] buffer;
+  private ArrayPool arrayPool;
+  private int index;
+
+  public BufferedOutputStream(@NonNull OutputStream out, @NonNull ArrayPool arrayPool) {
+    this(out, arrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  }
+
+  @VisibleForTesting
+  BufferedOutputStream(@NonNull OutputStream out, ArrayPool arrayPool, int bufferSize) {
+    this.out = out;
+    this.arrayPool = arrayPool;
+    buffer = arrayPool.get(bufferSize, byte[].class);
+  }
+
+  @Override
+  public void write(int b) throws IOException {
+    buffer[index++] = (byte) b;
+    maybeFlushBuffer();
+  }
+
+  @Override
+  public void write(@NonNull byte[] b) throws IOException {
+    write(b, 0, b.length);
+  }
+
+  @Override
+  public void write(@NonNull byte[] b, int initialOffset, int length) throws IOException {
+    int writtenSoFar = 0;
+    do {
+      int remainingToWrite = length - writtenSoFar;
+      int currentOffset = initialOffset + writtenSoFar;
+      // If we still need to write at least the buffer size worth of bytes, we might as well do so
+      // directly and avoid the overhead of copying to the buffer first.
+      if (index == 0 && remainingToWrite >= buffer.length) {
+        out.write(b, currentOffset, remainingToWrite);
+        return;
+      }
+
+      int remainingSpaceInBuffer = buffer.length - index;
+      int totalBytesToWriteToBuffer = Math.min(remainingToWrite, remainingSpaceInBuffer);
+
+      System.arraycopy(b, currentOffset, buffer, index, totalBytesToWriteToBuffer);
+
+      index += totalBytesToWriteToBuffer;
+      writtenSoFar += totalBytesToWriteToBuffer;
+
+      maybeFlushBuffer();
+    } while (writtenSoFar < length);
+  }
+
+  @Override
+  public void flush() throws IOException {
+    flushBuffer();
+    out.flush();
+  }
+
+  private void flushBuffer() throws IOException {
+    if (index > 0) {
+      out.write(buffer, 0, index);
+      index = 0;
+    }
+  }
+
+  private void maybeFlushBuffer() throws IOException {
+    if (index == buffer.length) {
+      flushBuffer();
+    }
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      flush();
+    } finally {
+      out.close();
+    }
+    release();
+  }
+
+  private void release() {
+    if (buffer != null) {
+      arrayPool.put(buffer);
+      buffer = null;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index 9889eaf06..b6b6dc077 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -1,21 +1,20 @@
 package com.bumptech.glide.load.data;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 
 /**
  * Lazily retrieves data that can be used to load a resource.
  *
- * <p> A new instance is
- * created per resource load by {@link com.bumptech.glide.load.model.ModelLoader}. {@link
- * #loadData(com.bumptech.glide.Priority, com.bumptech.glide.load.data.DataFetcher.DataCallback)}
- * may or may not be called for any given load depending on whether or not the corresponding
- * resource is cached. Cancel also may or may not be called. If
- * {@link #loadData(com.bumptech.glide.Priority,
+ * <p>A new instance is created per resource load by {@link
+ * com.bumptech.glide.load.model.ModelLoader}. {@link #loadData(com.bumptech.glide.Priority,
+ * com.bumptech.glide.load.data.DataFetcher.DataCallback)} may or may not be called for any given
+ * load depending on whether or not the corresponding resource is cached. Cancel also may or may not
+ * be called. If {@link #loadData(com.bumptech.glide.Priority,
  * com.bumptech.glide.load.data.DataFetcher.DataCallback)}} is called, then so {@link #cleanup()}
- * will be called. </p>
+ * will be called.
  *
  * @param <T> The type of data to be loaded (InputStream, byte[], File etc).
  */
@@ -39,39 +38,37 @@
      *
      * @param e a non-null {@link Exception} indicating why the load failed.
      */
-    void onLoadFailed(Exception e);
+    void onLoadFailed(@NonNull Exception e);
   }
 
   /**
    * Fetch data from which a resource can be decoded.
    *
-   * <p> This will always be called on background thread so it is safe to perform long running tasks
+   * <p>This will always be called on background thread so it is safe to perform long running tasks
    * here. Any third party libraries called must be thread safe (or move the work to another thread)
-   * since this method will be called from a thread in a
-   * {@link java.util.concurrent.ExecutorService}
-   * that may have more than one background thread. </p>
+   * since this method will be called from a thread in a {@link
+   * java.util.concurrent.ExecutorService} that may have more than one background thread. You
+   * <b>MUST</b> use the {@link DataCallback} once the request is complete.
    *
-   * You <b>MUST</b> use the {@link DataCallback} once the request is complete.
+   * <p>You are free to move the fetch work to another thread and call the callback from there.
    *
-   * You are free to move the fetch work to another thread and call the callback from there.
+   * <p>This method will only be called when the corresponding resource is not in the cache.
    *
-   * <p> This method will only be called when the corresponding resource is not in the cache. </p>
-   *
-   * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
+   * <p>Note - this method will be run on a background thread so blocking I/O is safe.
    *
    * @param priority The priority with which the request should be completed.
    * @param callback The callback to use when the request is complete
    * @see #cleanup() where the data retuned will be cleaned up
    */
-  void loadData(Priority priority, DataCallback<? super T> callback);
+  void loadData(@NonNull Priority priority, @NonNull DataCallback<? super T> callback);
 
   /**
    * Cleanup or recycle any resources used by this data fetcher. This method will be called in a
    * finally block after the data provided by {@link #loadData(com.bumptech.glide.Priority,
-   * com.bumptech.glide.load.data.DataFetcher.DataCallback)} has been decoded by the
-   * {@link com.bumptech.glide.load.ResourceDecoder}.
+   * com.bumptech.glide.load.data.DataFetcher.DataCallback)} has been decoded by the {@link
+   * com.bumptech.glide.load.ResourceDecoder}.
    *
-   * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
+   * <p>Note - this method will be run on a background thread so blocking I/O is safe.
    */
   void cleanup();
 
@@ -80,24 +77,20 @@
    * method does not need to guarantee that any in process loads do not finish. It also may be
    * called before a load starts or after it finishes.
    *
-   * <p> The best way to use this method is to cancel any loads that have not yet started, but allow
+   * <p>The best way to use this method is to cancel any loads that have not yet started, but allow
    * those that are in process to finish since its we typically will want to display the same
-   * resource in a different view in the near future. </p>
+   * resource in a different view in the near future.
    *
-   * <p> Note - this method will be run on the main thread so it should not perform blocking
-   * operations and should finish quickly. </p>
+   * <p>Note - this method will be run on the main thread so it should not perform blocking
+   * operations and should finish quickly.
    */
   void cancel();
 
-  /**
-   * Returns the class of the data this fetcher will attempt to obtain.
-   */
+  /** Returns the class of the data this fetcher will attempt to obtain. */
   @NonNull
   Class<T> getDataClass();
 
-  /**
-   * Returns the {@link com.bumptech.glide.load.DataSource} this fetcher will return data from.
-   */
+  /** Returns the {@link com.bumptech.glide.load.DataSource} this fetcher will return data from. */
   @NonNull
   DataSource getDataSource();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
index 73dd6411e..295bf201d 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import androidx.annotation.NonNull;
 import java.io.IOException;
 
 /**
@@ -10,22 +11,22 @@
 public interface DataRewinder<T> {
 
   /**
-   * A factory interface for producing individual
-   * {@link com.bumptech.glide.load.data.DataRewinder}s.
+   * A factory interface for producing individual {@link
+   * com.bumptech.glide.load.data.DataRewinder}s.
    *
    * @param <T> The type of data that the {@link com.bumptech.glide.load.data.DataRewinder} will
-   *            wrap.
+   *     wrap.
    */
   interface Factory<T> {
-    /**
-     * Returns a new {@link com.bumptech.glide.load.data.DataRewinder} wrapping the given data.
-     */
-    DataRewinder<T> build(T data);
+    /** Returns a new {@link com.bumptech.glide.load.data.DataRewinder} wrapping the given data. */
+    @NonNull
+    DataRewinder<T> build(@NonNull T data);
 
     /**
-     * Returns the class of data this factory can produce
-     * {@link com.bumptech.glide.load.data.DataRewinder}s for.
+     * Returns the class of data this factory can produce {@link
+     * com.bumptech.glide.load.data.DataRewinder}s for.
      */
+    @NonNull
     Class<T> getDataClass();
   }
 
@@ -34,14 +35,14 @@
    * returns the re-wound data (or a wrapper for the re-wound data).
    *
    * @return An object pointing to the wrapped data.
-   * @throws IOException
    */
+  @NonNull
   T rewindAndGet() throws IOException;
 
   /**
    * Called when this rewinder is no longer needed and can be cleaned up.
    *
-   * <p> The underlying data may still be in use and should not be closed or invalidated. </p>
+   * <p>The underlying data may still be in use and should not be closed or invalidated.
    */
   void cleanup();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
index 1d7ce3c2e..981c6b83d 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.util.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
@@ -12,23 +13,26 @@
   private final Map<Class<?>, DataRewinder.Factory<?>> rewinders = new HashMap<>();
   private static final DataRewinder.Factory<?> DEFAULT_FACTORY =
       new DataRewinder.Factory<Object>() {
+        @NonNull
         @Override
-        public DataRewinder<Object> build(Object data) {
+        public DataRewinder<Object> build(@NonNull Object data) {
           return new DefaultRewinder(data);
         }
 
+        @NonNull
         @Override
         public Class<Object> getDataClass() {
           throw new UnsupportedOperationException("Not implemented");
         }
       };
 
-  public synchronized void register(DataRewinder.Factory<?> factory) {
+  public synchronized void register(@NonNull DataRewinder.Factory<?> factory) {
     rewinders.put(factory.getDataClass(), factory);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T> DataRewinder<T> build(T data) {
+  public synchronized <T> DataRewinder<T> build(@NonNull T data) {
     Preconditions.checkNotNull(data);
     DataRewinder.Factory<T> result = (DataRewinder.Factory<T>) rewinders.get(data.getClass());
     if (result == null) {
@@ -46,13 +50,14 @@ public synchronized void register(DataRewinder.Factory<?> factory) {
     return result.build(data);
   }
 
-  private static class DefaultRewinder implements DataRewinder<Object> {
+  private static final class DefaultRewinder implements DataRewinder<Object> {
     private final Object data;
 
-    public DefaultRewinder(Object data) {
+    DefaultRewinder(@NonNull Object data) {
       this.data = data;
     }
 
+    @NonNull
     @Override
     public Object rewindAndGet() {
       return data;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
index de4436d93..fea6e01d1 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import androidx.annotation.NonNull;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -8,55 +9,57 @@
  * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
  * image data.
  *
- * <p>This class assumes that the wrapped stream contains an image format that can contain
- * exif information and performs no verification. </p>
+ * <p>This class assumes that the wrapped stream contains an image format that can contain exif
+ * information and performs no verification.
  */
 public final class ExifOrientationStream extends FilterInputStream {
   /** Allow two bytes for the file format. */
   private static final int SEGMENT_START_POSITION = 2;
-  private static final byte[] EXIF_SEGMENT = new byte[] {
-      /** segment start id. */
-      (byte) 0xFF,
-      /** segment type. */
-      (byte) 0xE1,
-      /** segmentLength. */
-      0x00,
-      (byte) 0x1C,
-      /** exif identifier. */
-      0x45,
-      0x78,
-      0x69,
-      0x66,
-      0x00,
-      0x00,
-      /** motorola byte order (big endian). */
-      (byte) 0x4D,
-      (byte) 0x4D,
-      /** filler? */
-      0x00,
-      0x00,
-      /** first id offset. */
-      0x00,
-      0x00,
-      0x00,
-      0x08,
-      /** tagCount. */
-      0x00,
-      0x01,
-      /** exif tag type. */
-      0x01,
-      0x12,
-      /** 2 byte format. */
-      0x00,
-      0x02,
-      /** component count. */
-      0x00,
-      0x00,
-      0x00,
-      0x01,
-      /** 2 byte orientation value, the first byte of which is always 0. */
-      0x00,
-  };
+
+  private static final byte[] EXIF_SEGMENT =
+      new byte[] {
+        /* segment start id. */
+        (byte) 0xFF,
+        /* segment type. */
+        (byte) 0xE1,
+        /* segmentLength. */
+        0x00,
+        (byte) 0x1C,
+        /* exif identifier. */
+        0x45,
+        0x78,
+        0x69,
+        0x66,
+        0x00,
+        0x00,
+        /* motorola byte order (big endian). */
+        (byte) 0x4D,
+        (byte) 0x4D,
+        /* filler? */
+        0x00,
+        0x00,
+        /* first id offset. */
+        0x00,
+        0x00,
+        0x00,
+        0x08,
+        /* tagCount. */
+        0x00,
+        0x01,
+        /* exif tag type. */
+        0x01,
+        0x12,
+        /* 2 byte format. */
+        0x00,
+        0x02,
+        /* component count. */
+        0x00,
+        0x00,
+        0x00,
+        0x01,
+        /* 2 byte orientation value, the first byte of which is always 0. */
+        0x00,
+      };
   private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
   private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
   private final byte orientation;
@@ -75,8 +78,10 @@ public boolean markSupported() {
     return false;
   }
 
+  // No need for synchronized since all we do is throw.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
-  public void mark(int readlimit) {
+  public void mark(int readLimit) {
     throw new UnsupportedOperationException();
   }
 
@@ -97,7 +102,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
     int read;
     if (position > ORIENTATION_POSITION) {
       read = super.read(buffer, byteOffset, byteCount);
@@ -120,11 +125,14 @@ public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException
   public long skip(long byteCount) throws IOException {
     long skipped = super.skip(byteCount);
     if (skipped > 0) {
-      position += skipped;
+      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      position = (int) (position + skipped);
     }
     return skipped;
   }
 
+  // No need for synchronized since all we do is throw.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
   public void reset() throws IOException {
     throw new UnsupportedOperationException();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
index 176f206d9..50adeba32 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
@@ -2,12 +2,10 @@
 
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import java.io.IOException;
 
-/**
- * Fetches an {@link android.os.ParcelFileDescriptor} for an asset path.
- */
+/** Fetches an {@link android.os.ParcelFileDescriptor} for an asset path. */
 public class FileDescriptorAssetPathFetcher extends AssetPathFetcher<ParcelFileDescriptor> {
   public FileDescriptorAssetPathFetcher(AssetManager assetManager, String assetPath) {
     super(assetManager, assetPath);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 2a159b92b..1f484b3a7 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -4,13 +4,11 @@
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-/**
- * Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}.
- */
+/** Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}. */
 public class FileDescriptorLocalUriFetcher extends LocalUriFetcher<ParcelFileDescriptor> {
   public FileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
     super(contentResolver, uri);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index 6989129cc..922a9c6b7 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.load.data;
 
-import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.HttpException;
@@ -17,15 +18,16 @@
 import java.net.URL;
 import java.util.Map;
 
-/**
- * A DataFetcher that retrieves an {@link java.io.InputStream} for a Url.
- */
+/** A DataFetcher that retrieves an {@link java.io.InputStream} for a Url. */
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "HttpUrlFetcher";
   private static final int MAXIMUM_REDIRECTS = 5;
-  // Visible for testing.
+
+  @VisibleForTesting
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
+  /** Returned when a connection error prevented us from receiving an http error. */
+  private static final int INVALID_STATUS_CODE = -1;
 
   private final GlideUrl glideUrl;
   private final int timeout;
@@ -39,7 +41,7 @@ public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
     this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
     this.glideUrl = glideUrl;
     this.timeout = timeout;
@@ -47,29 +49,26 @@ public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(
+      @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
     long startTime = LogTime.getLogTime();
-    final InputStream result;
     try {
-      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
-          glideUrl.getHeaders());
+      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
+      callback.onDataReady(result);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to load data for url", e);
       }
       callback.onLoadFailed(e);
-      return;
-    }
-
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime)
-          + " ms and loaded " + result);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-    callback.onDataReady(result);
   }
 
-  private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
-      Map<String, String> headers) throws IOException {
+  private InputStream loadDataWithRedirects(
+      URL url, int redirects, URL lastUrl, Map<String, String> headers) throws IOException {
     if (redirects >= MAXIMUM_REDIRECTS) {
       throw new HttpException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
     } else {
@@ -78,7 +77,6 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       try {
         if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
           throw new HttpException("In re-direct loop");
-
         }
       } catch (URISyntaxException e) {
         // Do nothing, this is best effort.
@@ -106,9 +104,9 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       return null;
     }
     final int statusCode = urlConnection.getResponseCode();
-    if (statusCode / 100 == 2) {
+    if (isHttpOk(statusCode)) {
       return getStreamForSuccessfulRequest(urlConnection);
-    } else if (statusCode / 100 == 3) {
+    } else if (isHttpRedirect(statusCode)) {
       String redirectUrlString = urlConnection.getHeaderField("Location");
       if (TextUtils.isEmpty(redirectUrlString)) {
         throw new HttpException("Received empty or null redirect url");
@@ -118,13 +116,23 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       // to disconnecting the url connection below. See #2352.
       cleanup();
       return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
-    } else if (statusCode == -1) {
+    } else if (statusCode == INVALID_STATUS_CODE) {
       throw new HttpException(statusCode);
     } else {
       throw new HttpException(urlConnection.getResponseMessage(), statusCode);
     }
   }
 
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpOk(int statusCode) {
+    return statusCode / 100 == 2;
+  }
+
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpRedirect(int statusCode) {
+    return statusCode / 100 == 3;
+  }
+
   private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
       throws IOException {
     if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
@@ -180,7 +188,7 @@ public DataSource getDataSource() {
   private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
 
     @Synthetic
-    DefaultHttpUrlConnectionFactory() { }
+    DefaultHttpUrlConnectionFactory() {}
 
     @Override
     public HttpURLConnection build(URL url) throws IOException {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
index 08fce42d8..380be1311 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.data;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+import com.bumptech.glide.util.Synthetic;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -15,11 +17,13 @@
 
   private final RecyclableBufferedInputStream bufferedStream;
 
+  @Synthetic
   InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {
     bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool);
     bufferedStream.mark(MARK_LIMIT);
   }
 
+  @NonNull
   @Override
   public InputStream rewindAndGet() throws IOException {
     bufferedStream.reset();
@@ -42,11 +46,13 @@ public Factory(ArrayPool byteArrayPool) {
       this.byteArrayPool = byteArrayPool;
     }
 
+    @NonNull
     @Override
     public DataRewinder<InputStream> build(InputStream data) {
       return new InputStreamRewinder(data, byteArrayPool);
     }
 
+    @NonNull
     @Override
     public Class<InputStream> getDataClass() {
       return InputStream.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index 81d12b054..2ce74bafe 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -2,8 +2,8 @@
 
 import android.content.ContentResolver;
 import android.net.Uri;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import java.io.FileNotFoundException;
@@ -14,7 +14,7 @@
  * android.net.Uri} pointing to a local resource.
  *
  * @param <T> The type of data that will obtained for the given uri (For example, {@link
- *            java.io.InputStream} or {@link android.os.ParcelFileDescriptor}.
+ *     java.io.InputStream} or {@link android.os.ParcelFileDescriptor}.
  */
 public abstract class LocalUriFetcher<T> implements DataFetcher<T> {
   private static final String TAG = "LocalUriFetcher";
@@ -26,17 +26,20 @@
    * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
    *
    * @param contentResolver Any {@link android.content.ContentResolver}.
-   * @param uri     A Uri pointing to a local asset. This load will fail if the uri isn't openable
-   *                by {@link ContentResolver#openInputStream(android.net.Uri)}
+   * @param uri A Uri pointing to a local asset. This load will fail if the uri isn't openable by
+   *     {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
     this.contentResolver = contentResolver;
     this.uri = uri;
   }
 
   @Override
-  public final void loadData(Priority priority, DataCallback<? super T> callback) {
+  public final void loadData(
+      @NonNull Priority priority, @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
@@ -81,11 +84,10 @@ protected abstract T loadResource(Uri uri, ContentResolver contentResolver)
   /**
    * Closes the concrete data type if necessary.
    *
-   * <p> Note - We can't rely on the closeable interface because it was added after our min API
-   * level. See issue #157. </p>
+   * <p>Note - We can't rely on the closeable interface because it was added after our min API
+   * level. See issue #157.
    *
    * @param data The data to close.
    */
   protected abstract void close(T data) throws IOException;
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
index aaad13214..211fbd55f 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.data;
 
 import android.content.res.AssetManager;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * Fetches an {@link java.io.InputStream} for an asset path.
- */
+/** Fetches an {@link java.io.InputStream} for an asset path. */
 public class StreamAssetPathFetcher extends AssetPathFetcher<InputStream> {
   public StreamAssetPathFetcher(AssetManager assetManager, String assetPath) {
     super(assetManager, assetPath);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index cb4cb966b..6477fb3bb 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -1,45 +1,33 @@
 package com.bumptech.glide.load.data;
 
-import android.annotation.TargetApi;
 import android.content.ContentResolver;
 import android.content.UriMatcher;
 import android.net.Uri;
-import android.os.Build;
 import android.provider.ContactsContract;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}.
- */
+/** Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}. */
 public class StreamLocalUriFetcher extends LocalUriFetcher<InputStream> {
-  /**
-   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537)
-   */
+  /** A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537) */
   private static final int ID_CONTACTS_LOOKUP = 1;
-  /**
-   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo)
-   */
+  /** A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo) */
   private static final int ID_CONTACTS_THUMBNAIL = 2;
-  /**
-   * A contact uri (e.g. content://com.android.contacts/contacts/38)
-   */
+  /** A contact uri (e.g. content://com.android.contacts/contacts/38) */
   private static final int ID_CONTACTS_CONTACT = 3;
   /**
-   * A contact display photo (high resolution) uri
-   * (e.g. content://com.android.contacts/5/display_photo)
+   * A contact display photo (high resolution) uri (e.g.
+   * content://com.android.contacts/5/display_photo)
    */
   private static final int ID_CONTACTS_PHOTO = 4;
   /**
-   * Uri for optimized search of phones by number
-   * (e.g. content://com.android.contacts/phone_lookup/232323232
+   * Uri for optimized search of phones by number (e.g.
+   * content://com.android.contacts/phone_lookup/232323232
    */
   private static final int ID_LOOKUP_BY_PHONE = 5;
-  /**
-   * Match the incoming Uri for special cases which we can handle nicely.
-   */
+  /** Match the incoming Uri for special cases which we can handle nicely. */
   private static final UriMatcher URI_MATCHER;
 
   static {
@@ -66,7 +54,6 @@ protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
     return inputStream;
   }
 
-
   private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
     switch (URI_MATCHER.match(uri)) {
@@ -88,10 +75,9 @@ private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
-    return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
-        true /*preferHighres*/);
+    return ContactsContract.Contacts.openContactPhotoInputStream(
+        contentResolver, contactUri, true /*preferHighres*/);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
index d7f7e44af..bd00853e1 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
@@ -5,9 +5,7 @@
 import android.provider.MediaStore;
 import com.bumptech.glide.request.target.Target;
 
-/**
- * Utility classes for interacting with the media store.
- */
+/** Utility classes for interacting with the media store. */
 public final class MediaStoreUtil {
   private static final int MINI_THUMB_WIDTH = 512;
   private static final int MINI_THUMB_HEIGHT = 384;
@@ -17,7 +15,8 @@ private MediaStoreUtil() {
   }
 
   public static boolean isMediaStoreUri(Uri uri) {
-    return uri != null && ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())
+    return uri != null
+        && ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())
         && MediaStore.AUTHORITY.equals(uri.getAuthority());
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 64fcec28f..ad5cb0b0e 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -5,8 +5,9 @@
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -28,8 +29,6 @@
   private final ThumbnailStreamOpener opener;
   private InputStream inputStream;
 
-  // TODO(nnaze): These build methods do not need the full Glide or Context objects.
-
   public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
     return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));
   }
@@ -40,20 +39,24 @@ public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
     ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
-    ThumbnailStreamOpener opener = new ThumbnailStreamOpener(
-        Glide.get(context).getRegistry().getImageHeaderParsers(), query, byteArrayPool,
-        context.getContentResolver());
+    ThumbnailStreamOpener opener =
+        new ThumbnailStreamOpener(
+            Glide.get(context).getRegistry().getImageHeaderParsers(),
+            query,
+            byteArrayPool,
+            context.getContentResolver());
     return new ThumbFetcher(uri, opener);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
     this.mediaStoreImageUri = mediaStoreImageUri;
     this.opener = opener;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(
+      @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
     try {
       inputStream = openThumbInputStream();
     } catch (FileNotFoundException e) {
@@ -117,12 +120,14 @@ public DataSource getDataSource() {
       this.contentResolver = contentResolver;
     }
 
-    private static final String[] PATH_PROJECTION = {
-      MediaStore.Video.Thumbnails.DATA
-    };
+    private static final String[] PATH_PROJECTION = {MediaStore.Video.Thumbnails.DATA};
     private static final String PATH_SELECTION =
-        MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
-        + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
+        MediaStore.Video.Thumbnails.KIND
+            + " = "
+            + MediaStore.Video.Thumbnails.MINI_KIND
+            + " AND "
+            + MediaStore.Video.Thumbnails.VIDEO_ID
+            + " = ?";
 
     @Override
     public Cursor query(Uri uri) {
@@ -136,7 +141,6 @@ public Cursor query(Uri uri) {
     }
   }
 
-
   static class ImageThumbnailQuery implements ThumbnailQuery {
 
     private final ContentResolver contentResolver;
@@ -149,8 +153,12 @@ public Cursor query(Uri uri) {
       MediaStore.Images.Thumbnails.DATA,
     };
     private static final String PATH_SELECTION =
-        MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
-        + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
+        MediaStore.Images.Thumbnails.KIND
+            + " = "
+            + MediaStore.Images.Thumbnails.MINI_KIND
+            + " AND "
+            + MediaStore.Images.Thumbnails.IMAGE_ID
+            + " = ?";
 
     @Override
     public Cursor query(Uri uri) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 323f02e17..84621f868 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -5,6 +5,8 @@
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -24,13 +26,15 @@
   private final ContentResolver contentResolver;
   private final List<ImageHeaderParser> parsers;
 
-  public ThumbnailStreamOpener(
-      List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
+  ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers,
+      ThumbnailQuery query,
+      ArrayPool byteArrayPool,
       ContentResolver contentResolver) {
     this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(
+  ThumbnailStreamOpener(
       List<ImageHeaderParser> parsers,
       FileService service,
       ThumbnailQuery query,
@@ -43,13 +47,13 @@ public ThumbnailStreamOpener(
     this.parsers = parsers;
   }
 
-  public int getOrientation(Uri uri) {
+  int getOrientation(Uri uri) {
     InputStream is = null;
     try {
       is = contentResolver.openInputStream(uri);
       return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
-      // openInputStream can throw NPEs.
-    } catch (IOException | NullPointerException e) {
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") IOException | NullPointerException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to open uri: " + uri, e);
       }
@@ -66,37 +70,51 @@ public int getOrientation(Uri uri) {
   }
 
   public InputStream open(Uri uri) throws FileNotFoundException {
-    Uri thumbnailUri = null;
-    InputStream inputStream = null;
+    String path = getPath(uri);
+    if (TextUtils.isEmpty(path)) {
+      return null;
+    }
 
-    final Cursor cursor = query.query(uri);
+    File file = service.get(path);
+    if (!isValid(file)) {
+      return null;
+    }
+
+    Uri thumbnailUri = Uri.fromFile(file);
     try {
-      if (cursor == null || !cursor.moveToFirst()) {
-        return null;
-      }
-      String path = cursor.getString(0);
-      if (TextUtils.isEmpty(path)) {
+      return contentResolver.openInputStream(thumbnailUri);
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (
+        @SuppressWarnings("PMD.AvoidCatchingNPE")
+        NullPointerException e) {
+      throw (FileNotFoundException)
+          new FileNotFoundException("NPE opening uri: " + uri + " -> " + thumbnailUri).initCause(e);
+    }
+  }
+
+  @Nullable
+  private String getPath(@NonNull Uri uri) {
+    Cursor cursor = null;
+    try {
+      cursor = query.query(uri);
+      if (cursor != null && cursor.moveToFirst()) {
+        return cursor.getString(0);
+      } else {
         return null;
       }
-
-      File file = service.get(path);
-      if (service.exists(file) && service.length(file) > 0) {
-        thumbnailUri = Uri.fromFile(file);
+    } catch (SecurityException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to query for thumbnail for Uri: " + uri, e);
       }
+      return null;
     } finally {
       if (cursor != null) {
         cursor.close();
       }
     }
-    if (thumbnailUri != null) {
-      try {
-        inputStream = contentResolver.openInputStream(thumbnailUri);
-        // openInputStream can throw NPEs.
-      } catch (NullPointerException e) {
-        throw (FileNotFoundException)
-          new FileNotFoundException("NPE opening uri: " + thumbnailUri).initCause(e);
-      }
-    }
-    return inputStream;
+  }
+
+  private boolean isValid(File file) {
+    return service.exists(file) && 0 < service.length(file);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
new file mode 100644
index 000000000..bdfc03615
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -0,0 +1,205 @@
+package com.bumptech.glide.load.engine;
+
+import android.os.Process;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.util.Executors;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadFactory;
+
+final class ActiveResources {
+  private final boolean isActiveResourceRetentionAllowed;
+  private final Executor monitorClearedResourcesExecutor;
+  @VisibleForTesting final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+  private final ReferenceQueue<EngineResource<?>> resourceReferenceQueue = new ReferenceQueue<>();
+
+  private ResourceListener listener;
+
+  private volatile boolean isShutdown;
+  @Nullable private volatile DequeuedResourceCallback cb;
+
+  ActiveResources(boolean isActiveResourceRetentionAllowed) {
+    this(
+        isActiveResourceRetentionAllowed,
+        java.util.concurrent.Executors.newSingleThreadExecutor(
+            new ThreadFactory() {
+              @Override
+              public Thread newThread(@NonNull final Runnable r) {
+                return new Thread(
+                    new Runnable() {
+                      @Override
+                      public void run() {
+                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+                        r.run();
+                      }
+                    },
+                    "glide-active-resources");
+              }
+            }));
+  }
+
+  @VisibleForTesting
+  ActiveResources(
+      boolean isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) {
+    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
+    this.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;
+
+    monitorClearedResourcesExecutor.execute(
+        new Runnable() {
+          @Override
+          public void run() {
+            cleanReferenceQueue();
+          }
+        });
+  }
+
+  void setListener(ResourceListener listener) {
+    synchronized (listener) {
+      synchronized (this) {
+        this.listener = listener;
+      }
+    }
+  }
+
+  synchronized void activate(Key key, EngineResource<?> resource) {
+    ResourceWeakReference toPut =
+        new ResourceWeakReference(
+            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);
+
+    ResourceWeakReference removed = activeEngineResources.put(key, toPut);
+    if (removed != null) {
+      removed.reset();
+    }
+  }
+
+  synchronized void deactivate(Key key) {
+    ResourceWeakReference removed = activeEngineResources.remove(key);
+    if (removed != null) {
+      removed.reset();
+    }
+  }
+
+  @Nullable
+  synchronized EngineResource<?> get(Key key) {
+    ResourceWeakReference activeRef = activeEngineResources.get(key);
+    if (activeRef == null) {
+      return null;
+    }
+
+    EngineResource<?> active = activeRef.get();
+    if (active == null) {
+      cleanupActiveReference(activeRef);
+    }
+    return active;
+  }
+
+  @SuppressWarnings({"WeakerAccess", "SynchronizeOnNonFinalField"})
+  @Synthetic
+  void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
+    // Fixes a deadlock where we normally acquire the Engine lock and then the ActiveResources lock
+    // but reverse that order in this one particular test. This is definitely a bit of a hack...
+    synchronized (listener) {
+      synchronized (this) {
+        activeEngineResources.remove(ref.key);
+
+        if (!ref.isCacheable || ref.resource == null) {
+          return;
+        }
+        EngineResource<?> newResource =
+            new EngineResource<>(
+                ref.resource,
+                /*isMemoryCacheable=*/ true,
+                /*isRecyclable=*/ false,
+                ref.key,
+                listener);
+        listener.onResourceReleased(ref.key, newResource);
+      }
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  void cleanReferenceQueue() {
+    while (!isShutdown) {
+      try {
+        ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();
+        cleanupActiveReference(ref);
+
+        // This section for testing only.
+        DequeuedResourceCallback current = cb;
+        if (current != null) {
+          current.onResourceDequeued();
+        }
+        // End for testing only.
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
+  @VisibleForTesting
+  void setDequeuedResourceCallback(DequeuedResourceCallback cb) {
+    this.cb = cb;
+  }
+
+  @VisibleForTesting
+  interface DequeuedResourceCallback {
+    void onResourceDequeued();
+  }
+
+  @VisibleForTesting
+  void shutdown() {
+    isShutdown = true;
+    if (monitorClearedResourcesExecutor instanceof ExecutorService) {
+      ExecutorService service = (ExecutorService) monitorClearedResourcesExecutor;
+      Executors.shutdownAndAwaitTermination(service);
+    }
+  }
+
+  @VisibleForTesting
+  static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {
+    @SuppressWarnings("WeakerAccess")
+    @Synthetic
+    final Key key;
+
+    @SuppressWarnings("WeakerAccess")
+    @Synthetic
+    final boolean isCacheable;
+
+    @Nullable
+    @SuppressWarnings("WeakerAccess")
+    @Synthetic
+    Resource<?> resource;
+
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    ResourceWeakReference(
+        @NonNull Key key,
+        @NonNull EngineResource<?> referent,
+        @NonNull ReferenceQueue<? super EngineResource<?>> queue,
+        boolean isActiveResourceRetentionAllowed) {
+      super(referent, queue);
+      this.key = Preconditions.checkNotNull(key);
+      this.resource =
+          referent.isMemoryCacheable() && isActiveResourceRetentionAllowed
+              ? Preconditions.checkNotNull(referent.getResource())
+              : null;
+      isCacheable = referent.isMemoryCacheable();
+    }
+
+    void reset() {
+      resource = null;
+      clear();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java b/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java
new file mode 100644
index 000000000..9692fa765
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.load.engine;
+
+/**
+ * An exception indicating that code outside of Glide threw an unexpected exception.
+ *
+ * <p>This is useful to allow us to distinguish developer errors on the part of users of Glide from
+ * developer errors on the part of developers of Glide itself.
+ */
+final class CallbackException extends RuntimeException {
+  private static final long serialVersionUID = -7530898992688511851L;
+
+  CallbackException(Throwable cause) {
+    super("Unexpected exception thrown by non-Glide code", cause);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
index a97652e7d..bcec45088 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -12,10 +13,9 @@
  * Generates {@link com.bumptech.glide.load.data.DataFetcher DataFetchers} from cache files
  * containing original unmodified source data.
  */
-class DataCacheGenerator implements DataFetcherGenerator,
-    DataFetcher.DataCallback<Object> {
+class DataCacheGenerator implements DataFetcherGenerator, DataFetcher.DataCallback<Object> {
 
-  private List<Key> cacheKeys;
+  private final List<Key> cacheKeys;
   private final DecodeHelper<?> helper;
   private final FetcherReadyCallback cb;
 
@@ -50,6 +50,9 @@ public boolean startNext() {
       }
 
       Key sourceId = cacheKeys.get(sourceIdIndex);
+      // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times
+      // and the actions it performs are much more expensive than a single allocation.
+      @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
       Key originalKey = new DataCacheKey(sourceId, helper.getSignature());
       cacheFile = helper.getDiskCache().get(originalKey);
       if (cacheFile != null) {
@@ -64,8 +67,8 @@ public boolean startNext() {
     while (!started && hasNextModelLoader()) {
       ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
       loadData =
-          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
-              helper.getOptions());
+          modelLoader.buildLoadData(
+              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());
       if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
@@ -92,7 +95,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(sourceKey, e, loadData.fetcher, DataSource.DATA_DISK_CACHE);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
index e70792c74..aa024003d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
@@ -1,22 +1,21 @@
 package com.bumptech.glide.load.engine;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 
-/**
- * A cache key for original source data + any requested signature.
- */
+/** A cache key for original source data + any requested signature. */
 final class DataCacheKey implements Key {
 
   private final Key sourceKey;
   private final Key signature;
 
-  public DataCacheKey(Key sourceKey, Key signature) {
+  DataCacheKey(Key sourceKey, Key signature) {
     this.sourceKey = sourceKey;
     this.signature = signature;
   }
 
-  public Key getSourceKey() {
+  Key getSourceKey() {
     return sourceKey;
   }
 
@@ -38,14 +37,11 @@ public int hashCode() {
 
   @Override
   public String toString() {
-    return "DataCacheKey{"
-        + "sourceKey=" + sourceKey
-        + ", signature=" + signature
-        + '}';
+    return "DataCacheKey{" + "sourceKey=" + sourceKey + ", signature=" + signature + '}';
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     sourceKey.updateDiskCacheKey(messageDigest);
     signature.updateDiskCacheKey(messageDigest);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
index eb7d4a4bd..87884048b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -1,18 +1,18 @@
 package com.bumptech.glide.load.engine;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import java.io.File;
 
 /**
- * Writes original source data or downsampled/transformed resource data to cache using the
- * provided {@link com.bumptech.glide.load.Encoder} or
- * {@link com.bumptech.glide.load.ResourceEncoder} and the given data or
- * {@link com.bumptech.glide.load.engine.Resource}.
+ * Writes original source data or downsampled/transformed resource data to cache using the provided
+ * {@link com.bumptech.glide.load.Encoder} or {@link com.bumptech.glide.load.ResourceEncoder} and
+ * the given data or {@link com.bumptech.glide.load.engine.Resource}.
  *
  * @param <DataType> The type of data that will be encoded (InputStream, ByteBuffer,
- *                  Resource<Bitmap> etc).
+ *     Resource<Bitmap> etc).
  */
 class DataCacheWriter<DataType> implements DiskCache.Writer {
   private final Encoder<DataType> encoder;
@@ -26,7 +26,7 @@
   }
 
   @Override
-  public boolean write(File file) {
+  public boolean write(@NonNull File file) {
     return encoder.encode(data, file, options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
index ae7cddb8d..70576d84a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.engine;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -11,14 +11,12 @@
  */
 interface DataFetcherGenerator {
   /**
-   * Called when the generator has finished loading data from a
-   * {@link com.bumptech.glide.load.data.DataFetcher}.
+   * Called when the generator has finished loading data from a {@link
+   * com.bumptech.glide.load.data.DataFetcher}.
    */
   interface FetcherReadyCallback {
 
-    /**
-     * Requests that we call startNext() again on a Glide owned thread.
-     */
+    /** Requests that we call startNext() again on a Glide owned thread. */
     void reschedule();
 
     /**
@@ -30,8 +28,12 @@
      * @param dataSource The data source we were loading from.
      * @param attemptedKey The key we were loading data from (may be an alternate).
      */
-    void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,
-        DataSource dataSource, Key attemptedKey);
+    void onDataFetcherReady(
+        Key sourceKey,
+        @Nullable Object data,
+        DataFetcher<?> fetcher,
+        DataSource dataSource,
+        Key attemptedKey);
 
     /**
      * Notifies the callback when the load fails.
@@ -41,20 +43,20 @@ void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fet
      * @param fetcher The fetcher we were loading from.
      * @param dataSource The data source we were loading from.
      */
-    void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
-        DataSource dataSource);
+    void onDataFetcherFailed(
+        Key attemptedKey, Exception e, DataFetcher<?> fetcher, DataSource dataSource);
   }
 
   /**
-   * Attempts to a single new {@link com.bumptech.glide.load.data.DataFetcher} and returns true if
-   * a {@link com.bumptech.glide.load.data.DataFetcher} was started, and false otherwise.
+   * Attempts to a single new {@link com.bumptech.glide.load.data.DataFetcher} and returns true if a
+   * {@link com.bumptech.glide.load.data.DataFetcher} was started, and false otherwise.
    */
   boolean startNext();
 
   /**
    * Attempts to cancel the currently running fetcher.
    *
-   * <p> This will be called on the main thread and should complete quickly. </p>
+   * <p>This will be called on the main thread and should complete quickly.
    */
   void cancel();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 597100ac6..b7dbebcc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -8,6 +8,8 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DecodeJob.DiskCacheProvider;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
@@ -41,7 +43,7 @@
   private boolean isScaleOnlyOrNoTransform;
 
   @SuppressWarnings("unchecked")
-  <R> DecodeHelper<R> init(
+  <R> void init(
       GlideContext glideContext,
       Object model,
       Key signature,
@@ -55,7 +57,7 @@
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
       boolean isScaleOnlyOrNoTransform,
-      DecodeJob.DiskCacheProvider diskCacheProvider) {
+      DiskCacheProvider diskCacheProvider) {
     this.glideContext = glideContext;
     this.model = model;
     this.signature = signature;
@@ -70,12 +72,6 @@
     this.transformations = transformations;
     this.isTransformationRequired = isTransformationRequired;
     this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;
-
-    return (DecodeHelper<R>) this;
-  }
-
-  Object getModel() {
-    return model;
   }
 
   void clear() {
@@ -123,8 +119,21 @@ int getHeight() {
     return height;
   }
 
+  ArrayPool getArrayPool() {
+    return glideContext.getArrayPool();
+  }
+
+  Class<?> getTranscodeClass() {
+    return transcodeClass;
+  }
+
+  Class<?> getModelClass() {
+    return model.getClass();
+  }
+
   List<Class<?>> getRegisteredResourceClasses() {
-    return glideContext.getRegistry()
+    return glideContext
+        .getRegistry()
         .getRegisteredResourceClasses(model.getClass(), resourceClass, transcodeClass);
   }
 
@@ -155,7 +164,9 @@ boolean isScaleOnlyOrNoTransform() {
     if (result == null) {
       if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
-            "Missing transformation for " + resourceClass + ". If you wish to"
+            "Missing transformation for "
+                + resourceClass
+                + ". If you wish to"
                 + " ignore unknown resource types, use the optional transformation methods.");
       } else {
         return UnitTransformation.get();
@@ -179,8 +190,8 @@ boolean isResourceEncoderAvailable(Resource<?> resource) {
 
   boolean isSourceKey(Key key) {
     List<LoadData<?>> loadData = getLoadData();
-    int size = loadData.size();
-    for (int i = 0; i < size; i++) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = loadData.size(); i < size; i++) {
       LoadData<?> current = loadData.get(i);
       if (current.sourceKey.equals(key)) {
         return true;
@@ -194,11 +205,10 @@ boolean isSourceKey(Key key) {
       isLoadDataSet = true;
       loadData.clear();
       List<ModelLoader<Object, ?>> modelLoaders = glideContext.getRegistry().getModelLoaders(model);
-      int size = modelLoaders.size();
-      for (int i = 0; i < size; i++) {
+      //noinspection ForLoopReplaceableByForEach to improve perf
+      for (int i = 0, size = modelLoaders.size(); i < size; i++) {
         ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);
-        LoadData<?> current =
-            modelLoader.buildLoadData(model, width, height, options);
+        LoadData<?> current = modelLoader.buildLoadData(model, width, height, options);
         if (current != null) {
           loadData.add(current);
         }
@@ -212,8 +222,8 @@ boolean isSourceKey(Key key) {
       isCacheKeysSet = true;
       cacheKeys.clear();
       List<LoadData<?>> loadData = getLoadData();
-      int size = loadData.size();
-      for (int i = 0; i < size; i++) {
+      //noinspection ForLoopReplaceableByForEach to improve perf
+      for (int i = 0, size = loadData.size(); i < size; i++) {
         LoadData<?> data = loadData.get(i);
         if (!cacheKeys.contains(data.sourceKey)) {
           cacheKeys.add(data.sourceKey);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 9bc35e27b..3a7a831db 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -1,9 +1,9 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Build;
-import android.support.v4.os.TraceCompat;
-import android.support.v4.util.Pools;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.core.util.Pools;
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.Registry;
@@ -20,6 +20,7 @@
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
+import com.bumptech.glide.util.pool.GlideTrace;
 import com.bumptech.glide.util.pool.StateVerifier;
 import java.util.ArrayList;
 import java.util.List;
@@ -32,39 +33,41 @@
  * <p>Note: this class has a natural ordering that is inconsistent with equals.
  *
  * @param <R> The type of resource that will be transcoded from the decoded and transformed
- *            resource.
+ *     resource.
  */
-class DecodeJob<R> implements DataFetcherGenerator.FetcherReadyCallback,
-    Runnable,
-    Comparable<DecodeJob<?>>,
-    Poolable {
+class DecodeJob<R>
+    implements DataFetcherGenerator.FetcherReadyCallback,
+        Runnable,
+        Comparable<DecodeJob<?>>,
+        Poolable {
   private static final String TAG = "DecodeJob";
 
-  @Synthetic final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
-  private final List<Exception> exceptions = new ArrayList<>();
+  private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
+  private final List<Throwable> throwables = new ArrayList<>();
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private final DiskCacheProvider diskCacheProvider;
   private final Pools.Pool<DecodeJob<?>> pool;
-  @Synthetic final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
+  private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
   private final ReleaseManager releaseManager = new ReleaseManager();
 
   private GlideContext glideContext;
-  @Synthetic Key signature;
+  private Key signature;
   private Priority priority;
   private EngineKey loadKey;
-  @Synthetic int width;
-  @Synthetic int height;
-  @Synthetic DiskCacheStrategy diskCacheStrategy;
-  @Synthetic Options options;
+  private int width;
+  private int height;
+  private DiskCacheStrategy diskCacheStrategy;
+  private Options options;
   private Callback<R> callback;
   private int order;
   private Stage stage;
   private RunReason runReason;
   private long startFetchTime;
   private boolean onlyRetrieveFromCache;
+  private Object model;
 
   private Thread currentThread;
-  @Synthetic Key currentSourceKey;
+  private Key currentSourceKey;
   private Key currentAttemptingKey;
   private Object currentData;
   private DataSource currentDataSource;
@@ -124,6 +127,7 @@
     this.callback = callback;
     this.order = order;
     this.runReason = RunReason.INITIALIZE;
+    this.model = model;
     return this;
   }
 
@@ -139,8 +143,8 @@ boolean willDecodeFromCache() {
   /**
    * Called when this object is no longer in use externally.
    *
-   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run}
-   *                           is neither in progress nor will ever be called again.
+   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run} is
+   *     neither in progress nor will ever be called again.
    */
   void release(boolean isRemovedFromQueue) {
     if (releaseManager.release(isRemovedFromQueue)) {
@@ -158,9 +162,7 @@ private void onEncodeComplete() {
     }
   }
 
-  /**
-   * Called when the load has failed due to a an error or a series of errors.
-   */
+  /** Called when the load has failed due to a an error or a series of errors. */
   private void onLoadFailed() {
     if (releaseManager.onFailed()) {
       releaseInternal();
@@ -187,12 +189,13 @@ private void releaseInternal() {
     currentFetcher = null;
     startFetchTime = 0L;
     isCancelled = false;
-    exceptions.clear();
+    model = null;
+    throwables.clear();
     pool.release(this);
   }
 
   @Override
-  public int compareTo(DecodeJob<?> other) {
+  public int compareTo(@NonNull DecodeJob<?> other) {
     int result = getPriority() - other.getPriority();
     if (result == 0) {
       result = order - other.order;
@@ -212,12 +215,14 @@ public void cancel() {
     }
   }
 
+  // We need to rethrow only CallbackException, but not other types of Throwables.
+  @SuppressWarnings("PMD.AvoidRethrowingException")
   @Override
   public void run() {
     // This should be much more fine grained, but since Java's thread pool implementation silently
     // swallows all otherwise fatal exceptions, this will at least make it obvious to developers
     // that something is failing.
-    TraceCompat.beginSection("DecodeJob#run");
+    GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);
     // Methods in the try statement can invalidate currentFetcher, so set a local variable here to
     // ensure that the fetcher is cleaned up either way.
     DataFetcher<?> localFetcher = currentFetcher;
@@ -227,32 +232,44 @@ public void run() {
         return;
       }
       runWrapped();
-    } catch (RuntimeException e) {
+    } catch (CallbackException e) {
+      // If a callback not controlled by Glide throws an exception, we should avoid the Glide
+      // specific debug logic below.
+      throw e;
+    } catch (Throwable t) {
+      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our
+      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We
+      // are however ensuring that our callbacks are always notified when a load fails. Without this
+      // notification, uncaught throwables never notify the corresponding callbacks, which can cause
+      // loads to silently hang forever, a case that's especially bad for users using Futures on
+      // background threads.
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "DecodeJob threw unexpectedly"
-            + ", isCancelled: " + isCancelled
-            + ", stage: " + stage, e);
+        Log.d(
+            TAG,
+            "DecodeJob threw unexpectedly" + ", isCancelled: " + isCancelled + ", stage: " + stage,
+            t);
       }
       // When we're encoding we've already notified our callback and it isn't safe to do so again.
       if (stage != Stage.ENCODE) {
-        exceptions.add(e);
+        throwables.add(t);
         notifyFailed();
       }
       if (!isCancelled) {
-        throw e;
+        throw t;
       }
+      throw t;
     } finally {
       // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
       // close in all cases anyway.
       if (localFetcher != null) {
         localFetcher.cleanup();
       }
-      TraceCompat.endSection();
+      GlideTrace.endSection();
     }
   }
 
   private void runWrapped() {
-     switch (runReason) {
+    switch (runReason) {
       case INITIALIZE:
         stage = getNextStage(Stage.INITIALIZE);
         currentGenerator = getNextGenerator();
@@ -288,7 +305,8 @@ private void runGenerators() {
     currentThread = Thread.currentThread();
     startFetchTime = LogTime.getLogTime();
     boolean isStarted = false;
-    while (!isCancelled && currentGenerator != null
+    while (!isCancelled
+        && currentGenerator != null
         && !(isStarted = currentGenerator.startNext())) {
       stage = getNextStage(stage);
       currentGenerator = getNextGenerator();
@@ -309,7 +327,7 @@ private void runGenerators() {
 
   private void notifyFailed() {
     setNotifiedOrThrow();
-    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(exceptions));
+    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));
     callback.onLoadFailed(e);
     onLoadFailed();
   }
@@ -322,7 +340,8 @@ private void notifyComplete(Resource<R> resource, DataSource dataSource) {
   private void setNotifiedOrThrow() {
     stateVerifier.throwIfRecycled();
     if (isCallbackNotified) {
-      throw new IllegalStateException("Already notified");
+      Throwable lastThrown = throwables.isEmpty() ? null : throwables.get(throwables.size() - 1);
+      throw new IllegalStateException("Already notified", lastThrown);
     }
     isCallbackNotified = true;
   }
@@ -331,10 +350,12 @@ private Stage getNextStage(Stage current) {
     switch (current) {
       case INITIALIZE:
         return diskCacheStrategy.decodeCachedResource()
-            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
+            ? Stage.RESOURCE_CACHE
+            : getNextStage(Stage.RESOURCE_CACHE);
       case RESOURCE_CACHE:
         return diskCacheStrategy.decodeCachedData()
-            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
+            ? Stage.DATA_CACHE
+            : getNextStage(Stage.DATA_CACHE);
       case DATA_CACHE:
         // Skip loading from source if the user opted to only retrieve the resource from cache.
         return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
@@ -353,8 +374,8 @@ public void reschedule() {
   }
 
   @Override
-  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
-      DataSource dataSource, Key attemptedKey) {
+  public void onDataFetcherReady(
+      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {
     this.currentSourceKey = sourceKey;
     this.currentData = data;
     this.currentFetcher = fetcher;
@@ -364,22 +385,22 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
       runReason = RunReason.DECODE_DATA;
       callback.reschedule(this);
     } else {
-      TraceCompat.beginSection("DecodeJob.decodeFromRetrievedData");
+      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");
       try {
         decodeFromRetrievedData();
       } finally {
-        TraceCompat.endSection();
+        GlideTrace.endSection();
       }
     }
   }
 
   @Override
-  public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
-      DataSource dataSource) {
+  public void onDataFetcherFailed(
+      Key attemptedKey, Exception e, DataFetcher<?> fetcher, DataSource dataSource) {
     fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
-    exceptions.add(exception);
+    throwables.add(exception);
     if (Thread.currentThread() != currentThread) {
       runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
       callback.reschedule(this);
@@ -390,17 +411,22 @@ public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fe
 
   private void decodeFromRetrievedData() {
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      logWithTimeAndKey("Retrieved data", startFetchTime,
-          "data: " + currentData
-          + ", cache key: " + currentSourceKey
-          + ", fetcher: " + currentFetcher);
+      logWithTimeAndKey(
+          "Retrieved data",
+          startFetchTime,
+          "data: "
+              + currentData
+              + ", cache key: "
+              + currentSourceKey
+              + ", fetcher: "
+              + currentFetcher);
     }
     Resource<R> resource = null;
     try {
       resource = decodeFromData(currentFetcher, currentData, currentDataSource);
     } catch (GlideException e) {
       e.setLoggingDetails(currentAttemptingKey, currentDataSource);
-      exceptions.add(e);
+      throwables.add(e);
     }
     if (resource != null) {
       notifyEncodeAndRelease(resource, currentDataSource);
@@ -432,12 +458,14 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
       if (lockedResource != null) {
         lockedResource.unlock();
       }
-      onEncodeComplete();
     }
+    // Call onEncodeComplete outside the finally block so that it's not called if the encode process
+    // throws.
+    onEncodeComplete();
   }
 
-  private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
-      DataSource dataSource) throws GlideException {
+  private <Data> Resource<R> decodeFromData(
+      DataFetcher<?> fetcher, Data data, DataSource dataSource) throws GlideException {
     try {
       if (data == null) {
         return null;
@@ -460,27 +488,35 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
     return runLoadPath(data, dataSource, path);
   }
 
+  @NonNull
   private Options getOptionsWithHardwareConfig(DataSource dataSource) {
     Options options = this.options;
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
       return options;
     }
 
-    if (options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null) {
+    boolean isHardwareConfigSafe =
+        dataSource == DataSource.RESOURCE_DISK_CACHE || decodeHelper.isScaleOnlyOrNoTransform();
+    Boolean isHardwareConfigAllowed = options.get(Downsampler.ALLOW_HARDWARE_CONFIG);
+
+    // If allow hardware config is defined, we can use it if it's set to false or if it's safe to
+    // use the hardware config for the request.
+    if (isHardwareConfigAllowed != null && (!isHardwareConfigAllowed || isHardwareConfigSafe)) {
       return options;
     }
 
-    if (dataSource == DataSource.RESOURCE_DISK_CACHE
-        || decodeHelper.isScaleOnlyOrNoTransform()) {
-      options = new Options();
-      options.putAll(this.options);
-      options.set(Downsampler.ALLOW_HARDWARE_CONFIG, true);
-    }
+    // If allow hardware config is undefined or is set to true but it's unsafe for us to use the
+    // hardware config for this request, we need to override the config.
+    options = new Options();
+    options.putAll(this.options);
+    options.set(Downsampler.ALLOW_HARDWARE_CONFIG, isHardwareConfigSafe);
+
     return options;
   }
 
-  private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
-      LoadPath<Data, ResourceType, R> path) throws GlideException {
+  private <Data, ResourceType> Resource<R> runLoadPath(
+      Data data, DataSource dataSource, LoadPath<Data, ResourceType, R> path)
+      throws GlideException {
     Options options = getOptionsWithHardwareConfig(dataSource);
     DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
     try {
@@ -497,16 +533,85 @@ private void logWithTimeAndKey(String message, long startTime) {
   }
 
   private void logWithTimeAndKey(String message, long startTime, String extraArgs) {
-    Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + ", load key: " + loadKey
-        + (extraArgs != null ? ", " + extraArgs : "") + ", thread: "
-        + Thread.currentThread().getName());
-  }
-
+    Log.v(
+        TAG,
+        message
+            + " in "
+            + LogTime.getElapsedMillis(startTime)
+            + ", load key: "
+            + loadKey
+            + (extraArgs != null ? ", " + extraArgs : "")
+            + ", thread: "
+            + Thread.currentThread().getName());
+  }
+
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
+  @Synthetic
+  @NonNull
+  <Z> Resource<Z> onResourceDecoded(DataSource dataSource, @NonNull Resource<Z> decoded) {
+    @SuppressWarnings("unchecked")
+    Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
+    Transformation<Z> appliedTransformation = null;
+    Resource<Z> transformed = decoded;
+    if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
+      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
+      transformed = appliedTransformation.transform(glideContext, decoded, width, height);
+    }
+    // TODO: Make this the responsibility of the Transformation.
+    if (!decoded.equals(transformed)) {
+      decoded.recycle();
+    }
+
+    final EncodeStrategy encodeStrategy;
+    final ResourceEncoder<Z> encoder;
+    if (decodeHelper.isResourceEncoderAvailable(transformed)) {
+      encoder = decodeHelper.getResultEncoder(transformed);
+      encodeStrategy = encoder.getEncodeStrategy(options);
+    } else {
+      encoder = null;
+      encodeStrategy = EncodeStrategy.NONE;
+    }
+
+    Resource<Z> result = transformed;
+    boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
+    if (diskCacheStrategy.isResourceCacheable(
+        isFromAlternateCacheKey, dataSource, encodeStrategy)) {
+      if (encoder == null) {
+        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
+      }
+      final Key key;
+      switch (encodeStrategy) {
+        case SOURCE:
+          key = new DataCacheKey(currentSourceKey, signature);
+          break;
+        case TRANSFORMED:
+          key =
+              new ResourceCacheKey(
+                  decodeHelper.getArrayPool(),
+                  currentSourceKey,
+                  signature,
+                  width,
+                  height,
+                  appliedTransformation,
+                  resourceSubClass,
+                  options);
+          break;
+        default:
+          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
+      }
+
+      LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
+      deferredEncodeManager.init(key, encoder, lockedResult);
+      result = lockedResult;
+    }
+    return result;
+  }
+
   private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
     private final DataSource dataSource;
@@ -516,57 +621,10 @@ public StateVerifier getVerifier() {
       this.dataSource = dataSource;
     }
 
+    @NonNull
     @Override
-    public Resource<Z> onResourceDecoded(Resource<Z> decoded) {
-      Class<Z> resourceSubClass = getResourceClass(decoded);
-      Transformation<Z> appliedTransformation = null;
-      Resource<Z> transformed = decoded;
-      if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
-        appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
-        transformed = appliedTransformation.transform(glideContext, decoded, width, height);
-      }
-      // TODO: Make this the responsibility of the Transformation.
-      if (!decoded.equals(transformed)) {
-        decoded.recycle();
-      }
-
-      final EncodeStrategy encodeStrategy;
-      final ResourceEncoder<Z> encoder;
-      if (decodeHelper.isResourceEncoderAvailable(transformed)) {
-        encoder = decodeHelper.getResultEncoder(transformed);
-        encodeStrategy = encoder.getEncodeStrategy(options);
-      } else {
-        encoder = null;
-        encodeStrategy = EncodeStrategy.NONE;
-      }
-
-      Resource<Z> result = transformed;
-      boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
-      if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
-          encodeStrategy)) {
-        if (encoder == null) {
-          throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
-        }
-        final Key key;
-        if (encodeStrategy == EncodeStrategy.SOURCE) {
-          key = new DataCacheKey(currentSourceKey, signature);
-        } else if (encodeStrategy == EncodeStrategy.TRANSFORMED) {
-          key = new ResourceCacheKey(currentSourceKey, signature, width, height,
-              appliedTransformation, resourceSubClass, options);
-        } else {
-          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
-        }
-
-        LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
-        deferredEncodeManager.init(key, encoder, lockedResult);
-        result = lockedResult;
-      }
-      return result;
-    }
-
-    @SuppressWarnings("unchecked")
-    private Class<Z> getResourceClass(Resource<Z> resource) {
-      return (Class<Z>) resource.get().getClass();
+    public Resource<Z> onResourceDecoded(@NonNull Resource<Z> decoded) {
+      return DecodeJob.this.onResourceDecoded(dataSource, decoded);
     }
   }
 
@@ -579,7 +637,7 @@ public StateVerifier getVerifier() {
     private boolean isFailed;
 
     @Synthetic
-    ReleaseManager() { }
+    ReleaseManager() {}
 
     synchronized boolean release(boolean isRemovedFromQueue) {
       isReleased = true;
@@ -608,8 +666,8 @@ private boolean isComplete(boolean isRemovedFromQueue) {
   }
 
   /**
-   * Allows transformed resources to be encoded after the transcoded result is already delivered
-   * to requestors.
+   * Allows transformed resources to be encoded after the transcoded result is already delivered to
+   * requestors.
    */
   private static class DeferredEncodeManager<Z> {
     private Key key;
@@ -617,7 +675,7 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     private LockedResource<Z> toEncode;
 
     @Synthetic
-    DeferredEncodeManager() { }
+    DeferredEncodeManager() {}
 
     // We just need the encoder and resource type to match, which this will enforce.
     @SuppressWarnings("unchecked")
@@ -628,13 +686,14 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     }
 
     void encode(DiskCacheProvider diskCacheProvider, Options options) {
-      TraceCompat.beginSection("DecodeJob.encode");
+      GlideTrace.beginSection("DecodeJob.encode");
       try {
-        diskCacheProvider.getDiskCache().put(key,
-            new DataCacheWriter<>(encoder, toEncode, options));
+        diskCacheProvider
+            .getDiskCache()
+            .put(key, new DataCacheWriter<>(encoder, toEncode, options));
       } finally {
         toEncode.unlock();
-        TraceCompat.endSection();
+        GlideTrace.endSection();
       }
     }
 
@@ -662,15 +721,11 @@ void clear() {
     DiskCache getDiskCache();
   }
 
-  /**
-   * Why we're being executed again.
-   */
+  /** Why we're being executed again. */
   private enum RunReason {
     /** The first time we've been submitted. */
     INITIALIZE,
-    /**
-     * We want to switch from the disk cache service to the source executor.
-     */
+    /** We want to switch from the disk cache service to the source executor. */
     SWITCH_TO_SOURCE_SERVICE,
     /**
      * We retrieved some data on a thread we don't own and want to switch back to our thread to
@@ -679,9 +734,7 @@ void clear() {
     DECODE_DATA,
   }
 
-  /**
-   * Where we're trying to decode data from.
-   */
+  /** Where we're trying to decode data from. */
   private enum Stage {
     /** The initial stage. */
     INITIALIZE,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
index e74320bf0..8fe172fde 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -1,53 +1,71 @@
 package com.bumptech.glide.load.engine;
 
-import android.support.v4.util.Pools.Pool;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.core.util.Pools.Pool;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Attempts to decode and transcode  resource type from a given data type.
+ * Attempts to decode and transcode resource type from a given data type.
  *
- * @param <DataType>     The type of data ResourceType that will be decoded from.
+ * @param <DataType> The type of data ResourceType that will be decoded from.
  * @param <ResourceType> The type of intermediate resource that will be decoded.
- * @param <Transcode>    The final type of resource that will be transcoded from ResourceType and
- *                       returned to the caller.
+ * @param <Transcode> The final type of resource that will be transcoded from ResourceType and
+ *     returned to the caller.
  */
 public class DecodePath<DataType, ResourceType, Transcode> {
   private static final String TAG = "DecodePath";
   private final Class<DataType> dataClass;
   private final List<? extends ResourceDecoder<DataType, ResourceType>> decoders;
   private final ResourceTranscoder<ResourceType, Transcode> transcoder;
-  private final Pool<List<Exception>> listPool;
+  private final Pool<List<Throwable>> listPool;
   private final String failureMessage;
 
-  public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
+  public DecodePath(
+      Class<DataType> dataClass,
+      Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
       List<? extends ResourceDecoder<DataType, ResourceType>> decoders,
-      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Exception>> listPool) {
+      ResourceTranscoder<ResourceType, Transcode> transcoder,
+      Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.decoders = decoders;
     this.transcoder = transcoder;
     this.listPool = listPool;
-    failureMessage = "Failed DecodePath{" + dataClass.getSimpleName() + "->"
-        + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
+    failureMessage =
+        "Failed DecodePath{"
+            + dataClass.getSimpleName()
+            + "->"
+            + resourceClass.getSimpleName()
+            + "->"
+            + transcodeClass.getSimpleName()
+            + "}";
   }
 
-  public Resource<Transcode> decode(DataRewinder<DataType> rewinder, int width, int height,
-      Options options, DecodeCallback<ResourceType> callback) throws GlideException {
+  public Resource<Transcode> decode(
+      DataRewinder<DataType> rewinder,
+      int width,
+      int height,
+      @NonNull Options options,
+      DecodeCallback<ResourceType> callback)
+      throws GlideException {
     Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
     Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
     return transcoder.transcode(transformed, options);
   }
 
-  private Resource<ResourceType> decodeResource(DataRewinder<DataType> rewinder, int width,
-      int height, Options options) throws GlideException {
-    List<Exception> exceptions = listPool.acquire();
+  @NonNull
+  private Resource<ResourceType> decodeResource(
+      DataRewinder<DataType> rewinder, int width, int height, @NonNull Options options)
+      throws GlideException {
+    List<Throwable> exceptions = Preconditions.checkNotNull(listPool.acquire());
     try {
       return decodeResourceWithList(rewinder, width, height, options, exceptions);
     } finally {
@@ -55,9 +73,16 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
     }
   }
 
-  private Resource<ResourceType> decodeResourceWithList(DataRewinder<DataType> rewinder, int width,
-      int height, Options options, List<Exception> exceptions) throws GlideException {
+  @NonNull
+  private Resource<ResourceType> decodeResourceWithList(
+      DataRewinder<DataType> rewinder,
+      int width,
+      int height,
+      @NonNull Options options,
+      List<Throwable> exceptions)
+      throws GlideException {
     Resource<ResourceType> result = null;
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0, size = decoders.size(); i < size; i++) {
       ResourceDecoder<DataType, ResourceType> decoder = decoders.get(i);
       try {
@@ -68,7 +93,7 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
         }
         // Some decoders throw unexpectedly. If they do, we shouldn't fail the entire load path, but
         // instead log and continue. See #2406 for an example.
-      } catch (IOException | RuntimeException e) {
+      } catch (IOException | RuntimeException | OutOfMemoryError e) {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
           Log.v(TAG, "Failed to decode data for " + decoder, e);
         }
@@ -88,11 +113,18 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
 
   @Override
   public String toString() {
-    return "DecodePath{" + " dataClass=" + dataClass + ", decoders=" + decoders + ", transcoder="
-        + transcoder + '}';
+    return "DecodePath{"
+        + " dataClass="
+        + dataClass
+        + ", decoders="
+        + decoders
+        + ", transcoder="
+        + transcoder
+        + '}';
   }
 
   interface DecodeCallback<ResourceType> {
-    Resource<ResourceType> onResourceDecoded(Resource<ResourceType> resource);
+    @NonNull
+    Resource<ResourceType> onResourceDecoded(@NonNull Resource<ResourceType> resource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
index b110e3121..b5b1379ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
@@ -3,147 +3,145 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.EncodeStrategy;
 
-/**
- * Set of available caching strategies for media.
- */
+/** Set of available caching strategies for media. */
 public abstract class DiskCacheStrategy {
 
   /**
-   * Caches remote data with both {@link #DATA} and {@link #RESOURCE}, and local data with
-   * {@link #RESOURCE} only.
+   * Caches remote data with both {@link #DATA} and {@link #RESOURCE}, and local data with {@link
+   * #RESOURCE} only.
    */
-  public static final DiskCacheStrategy ALL = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return dataSource == DataSource.REMOTE;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return dataSource != DataSource.RESOURCE_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return true;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return true;
-    }
-  };
+  public static final DiskCacheStrategy ALL =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return dataSource == DataSource.REMOTE;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return dataSource != DataSource.RESOURCE_DISK_CACHE
+              && dataSource != DataSource.MEMORY_CACHE;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return true;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return true;
+        }
+      };
+
+  /** Saves no data to cache. */
+  public static final DiskCacheStrategy NONE =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return false;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return false;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return false;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return false;
+        }
+      };
+
+  /** Writes retrieved data directly to the disk cache before it's decoded. */
+  public static final DiskCacheStrategy DATA =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return dataSource != DataSource.DATA_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return false;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return false;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return true;
+        }
+      };
+
+  /** Writes resources to disk after they've been decoded. */
+  public static final DiskCacheStrategy RESOURCE =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return false;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return dataSource != DataSource.RESOURCE_DISK_CACHE
+              && dataSource != DataSource.MEMORY_CACHE;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return true;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return false;
+        }
+      };
 
   /**
-   * Saves no data to cache.
+   * Tries to intelligently choose a strategy based on the data source of the {@link
+   * com.bumptech.glide.load.data.DataFetcher} and the {@link
+   * com.bumptech.glide.load.EncodeStrategy} of the {@link com.bumptech.glide.load.ResourceEncoder}
+   * (if an {@link com.bumptech.glide.load.ResourceEncoder} is available).
    */
-  public static final DiskCacheStrategy NONE = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return false;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return false;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return false;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return false;
-    }
-  };
-
-  /**
-   * Writes retrieved data directly to the disk cache before it's decoded.
-   */
-  public static final DiskCacheStrategy DATA = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return dataSource != DataSource.DATA_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return false;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return false;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return true;
-    }
-  };
-
-  /**
-   * Writes resources to disk after they've been decoded.
-   */
-  public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return false;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return dataSource != DataSource.RESOURCE_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return true;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return false;
-    }
-  };
-
-  /**
-   * Tries to intelligently choose a strategy based on the data source of the
-   * {@link com.bumptech.glide.load.data.DataFetcher} and the
-   * {@link com.bumptech.glide.load.EncodeStrategy} of the
-   * {@link com.bumptech.glide.load.ResourceEncoder} (if an
-   * {@link com.bumptech.glide.load.ResourceEncoder} is available).
-   */
-  public static final DiskCacheStrategy AUTOMATIC = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return dataSource == DataSource.REMOTE;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return ((isFromAlternateCacheKey && dataSource == DataSource.DATA_DISK_CACHE)
-          || dataSource == DataSource.LOCAL)
-          && encodeStrategy == EncodeStrategy.TRANSFORMED;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return true;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return true;
-    }
-  };
+  public static final DiskCacheStrategy AUTOMATIC =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return dataSource == DataSource.REMOTE;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return ((isFromAlternateCacheKey && dataSource == DataSource.DATA_DISK_CACHE)
+                  || dataSource == DataSource.LOCAL)
+              && encodeStrategy == EncodeStrategy.TRANSFORMED;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return true;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return true;
+        }
+      };
 
   /**
    * Returns true if this request should cache the original unmodified data.
@@ -156,22 +154,18 @@ public boolean decodeCachedData() {
    * Returns true if this request should cache the final transformed resource.
    *
    * @param isFromAlternateCacheKey {@code true} if the resource we've decoded was loaded using an
-   *                                alternative, rather than the primary, cache key.
+   *     alternative, rather than the primary, cache key.
    * @param dataSource Indicates where the data used to decode the resource was originally
-   *                   retrieved.
+   *     retrieved.
    * @param encodeStrategy The {@link EncodeStrategy} the {@link
-   * com.bumptech.glide.load.ResourceEncoder} will use to encode the resource.
+   *     com.bumptech.glide.load.ResourceEncoder} will use to encode the resource.
    */
-  public abstract boolean isResourceCacheable(boolean isFromAlternateCacheKey,
-      DataSource dataSource, EncodeStrategy encodeStrategy);
+  public abstract boolean isResourceCacheable(
+      boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy);
 
-  /**
-   * Returns true if this request should attempt to decode cached resource data.
-   */
+  /** Returns true if this request should attempt to decode cached resource data. */
   public abstract boolean decodeCachedResource();
 
-  /**
-   * Returns true if this request should attempt to decode cached source data.
-   */
+  /** Returns true if this request should attempt to decode cached source data. */
   public abstract boolean decodeCachedData();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index db2052254..5872340cc 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -1,73 +1,55 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Looper;
-import android.os.MessageQueue;
-import android.support.v4.util.Pools;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.core.util.Pools;
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.DiskCacheAdapter;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Executors;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
-import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.Executor;
 
-/**
- * Responsible for starting loads and managing active and cached resources.
- */
-public class Engine implements EngineJobListener,
-    MemoryCache.ResourceRemovedListener,
-    EngineResource.ResourceListener {
+/** Responsible for starting loads and managing active and cached resources. */
+public class Engine
+    implements EngineJobListener,
+        MemoryCache.ResourceRemovedListener,
+        EngineResource.ResourceListener {
   private static final String TAG = "Engine";
   private static final int JOB_POOL_SIZE = 150;
-  private final Map<Key, EngineJob<?>> jobs;
+  private static final boolean VERBOSE_IS_LOGGABLE = Log.isLoggable(TAG, Log.VERBOSE);
+  private final Jobs jobs;
   private final EngineKeyFactory keyFactory;
   private final MemoryCache cache;
   private final EngineJobFactory engineJobFactory;
-  private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
   private final ResourceRecycler resourceRecycler;
   private final LazyDiskCacheProvider diskCacheProvider;
   private final DecodeJobFactory decodeJobFactory;
+  private final ActiveResources activeResources;
 
-  // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
-  // #295.
-  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
-
-  /**
-   * Allows a request to indicate it no longer is interested in a given load.
-   */
-  public static class LoadStatus {
-    private final EngineJob<?> engineJob;
-    private final ResourceCallback cb;
-
-    public LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
-      this.cb = cb;
-      this.engineJob = engineJob;
-    }
-
-    public void cancel() {
-      engineJob.removeCallback(cb);
-    }
-  }
-
-  public Engine(MemoryCache memoryCache,
+  public Engine(
+      MemoryCache memoryCache,
       DiskCache.Factory diskCacheFactory,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      GlideExecutor animationExecutor) {
+      GlideExecutor animationExecutor,
+      boolean isActiveResourceRetentionAllowed) {
     this(
         memoryCache,
         diskCacheFactory,
@@ -80,29 +62,33 @@ public Engine(MemoryCache memoryCache,
         /*activeResources=*/ null,
         /*engineJobFactory=*/ null,
         /*decodeJobFactory=*/ null,
-        /*resourceRecycler=*/ null);
+        /*resourceRecycler=*/ null,
+        isActiveResourceRetentionAllowed);
   }
 
-  // Visible for testing.
-  Engine(MemoryCache cache,
+  @VisibleForTesting
+  Engine(
+      MemoryCache cache,
       DiskCache.Factory diskCacheFactory,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
       GlideExecutor animationExecutor,
-      Map<Key, EngineJob<?>> jobs,
+      Jobs jobs,
       EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources,
+      ActiveResources activeResources,
       EngineJobFactory engineJobFactory,
       DecodeJobFactory decodeJobFactory,
-      ResourceRecycler resourceRecycler) {
+      ResourceRecycler resourceRecycler,
+      boolean isActiveResourceRetentionAllowed) {
     this.cache = cache;
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
     if (activeResources == null) {
-      activeResources = new HashMap<>();
+      activeResources = new ActiveResources(isActiveResourceRetentionAllowed);
     }
     this.activeResources = activeResources;
+    activeResources.setListener(this);
 
     if (keyFactory == null) {
       keyFactory = new EngineKeyFactory();
@@ -110,14 +96,19 @@ public Engine(MemoryCache memoryCache,
     this.keyFactory = keyFactory;
 
     if (jobs == null) {
-      jobs = new HashMap<>();
+      jobs = new Jobs();
     }
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
       engineJobFactory =
           new EngineJobFactory(
-              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);
+              diskCacheExecutor,
+              sourceExecutor,
+              sourceUnlimitedExecutor,
+              animationExecutor,
+              /*engineJobListener=*/ this,
+              /*resourceListener=*/ this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -135,23 +126,31 @@ public Engine(MemoryCache memoryCache,
   }
 
   /**
-   * Starts a load for the given arguments. Must be called on the main thread.
+   * Starts a load for the given arguments.
+   *
+   * <p>Must be called on the main thread.
    *
-   * <p> The flow for any request is as follows: <ul> <li>Check the memory cache and provide the
-   * cached resource if present</li> <li>Check the current put of actively used resources and return
-   * the active resource if present</li> <li>Check the current put of in progress loads and add the
-   * cb to the in progress load if present</li> <li>Start a new load</li> </ul> </p>
+   * <p>The flow for any request is as follows:
    *
-   * <p> Active resources are those that have been provided to at least one request and have not yet
+   * <ul>
+   *   <li>Check the current set of actively used resources, return the active resource if present,
+   *       and move any newly inactive resources into the memory cache.
+   *   <li>Check the memory cache and provide the cached resource if present.
+   *   <li>Check the current set of in progress loads and add the cb to the in progress load if one
+   *       is present.
+   *   <li>Start a new load.
+   * </ul>
+   *
+   * <p>Active resources are those that have been provided to at least one request and have not yet
    * been released. Once all consumers of a resource have released that resource, the resource then
    * goes to cache. If the resource is ever returned to a new consumer from cache, it is re-added to
    * the active resources. If the resource is evicted from the cache, its resources are recycled and
    * re-used if possible and the resource is discarded. There is no strict requirement that
-   * consumers release their resources so active resources are held weakly. </p>
+   * consumers release their resources so active resources are held weakly.
    *
-   * @param width  The target width in pixels of the desired resource.
+   * @param width The target width in pixels of the desired resource.
    * @param height The target height in pixels of the desired resource.
-   * @param cb     The callback that will be called when the load completes.
+   * @param cb The callback that will be called when the load completes.
    */
   public <R> LoadStatus load(
       GlideContext glideContext,
@@ -171,106 +170,176 @@ public Engine(MemoryCache memoryCache,
       boolean useUnlimitedSourceExecutorPool,
       boolean useAnimationPool,
       boolean onlyRetrieveFromCache,
-      ResourceCallback cb) {
-    Util.assertMainThread();
-    long startTime = LogTime.getLogTime();
-
-    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
-        resourceClass, transcodeClass, options);
-
-    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
-    if (cached != null) {
-      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from cache", startTime, key);
+      ResourceCallback cb,
+      Executor callbackExecutor) {
+    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;
+
+    EngineKey key =
+        keyFactory.buildKey(
+            model,
+            signature,
+            width,
+            height,
+            transformations,
+            resourceClass,
+            transcodeClass,
+            options);
+
+    EngineResource<?> memoryResource;
+    synchronized (this) {
+      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);
+
+      if (memoryResource == null) {
+        return waitForExistingOrStartNewJob(
+            glideContext,
+            model,
+            signature,
+            width,
+            height,
+            resourceClass,
+            transcodeClass,
+            priority,
+            diskCacheStrategy,
+            transformations,
+            isTransformationRequired,
+            isScaleOnlyOrNoTransform,
+            options,
+            isMemoryCacheable,
+            useUnlimitedSourceExecutorPool,
+            useAnimationPool,
+            onlyRetrieveFromCache,
+            cb,
+            callbackExecutor,
+            key,
+            startTime);
       }
-      return null;
     }
 
-    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
-    if (active != null) {
-      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
-      }
-      return null;
-    }
+    // Avoid calling back while holding the engine lock, doing so makes it easier for callers to
+    // deadlock.
+    cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);
+    return null;
+  }
 
-    EngineJob<?> current = jobs.get(key);
+  private <R> LoadStatus waitForExistingOrStartNewJob(
+      GlideContext glideContext,
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Class<?> resourceClass,
+      Class<R> transcodeClass,
+      Priority priority,
+      DiskCacheStrategy diskCacheStrategy,
+      Map<Class<?>, Transformation<?>> transformations,
+      boolean isTransformationRequired,
+      boolean isScaleOnlyOrNoTransform,
+      Options options,
+      boolean isMemoryCacheable,
+      boolean useUnlimitedSourceExecutorPool,
+      boolean useAnimationPool,
+      boolean onlyRetrieveFromCache,
+      ResourceCallback cb,
+      Executor callbackExecutor,
+      EngineKey key,
+      long startTime) {
+
+    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
     if (current != null) {
-      current.addCallback(cb);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      current.addCallback(cb, callbackExecutor);
+      if (VERBOSE_IS_LOGGABLE) {
         logWithTimeAndKey("Added to existing load", startTime, key);
       }
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
-        useUnlimitedSourceExecutorPool, useAnimationPool);
-    DecodeJob<R> decodeJob = decodeJobFactory.build(
-        glideContext,
-        model,
-        key,
-        signature,
-        width,
-        height,
-        resourceClass,
-        transcodeClass,
-        priority,
-        diskCacheStrategy,
-        transformations,
-        isTransformationRequired,
-        isScaleOnlyOrNoTransform,
-        onlyRetrieveFromCache,
-        options,
-        engineJob);
+    EngineJob<R> engineJob =
+        engineJobFactory.build(
+            key,
+            isMemoryCacheable,
+            useUnlimitedSourceExecutorPool,
+            useAnimationPool,
+            onlyRetrieveFromCache);
+
+    DecodeJob<R> decodeJob =
+        decodeJobFactory.build(
+            glideContext,
+            model,
+            key,
+            signature,
+            width,
+            height,
+            resourceClass,
+            transcodeClass,
+            priority,
+            diskCacheStrategy,
+            transformations,
+            isTransformationRequired,
+            isScaleOnlyOrNoTransform,
+            onlyRetrieveFromCache,
+            options,
+            engineJob);
+
     jobs.put(key, engineJob);
-    engineJob.addCallback(cb);
+
+    engineJob.addCallback(cb, callbackExecutor);
     engineJob.start(decodeJob);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (VERBOSE_IS_LOGGABLE) {
       logWithTimeAndKey("Started new load", startTime, key);
     }
     return new LoadStatus(cb, engineJob);
   }
 
-  private static void logWithTimeAndKey(String log, long startTime, Key key) {
-    Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
-  }
-
-  private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
+  @Nullable
+  private EngineResource<?> loadFromMemory(
+      EngineKey key, boolean isMemoryCacheable, long startTime) {
     if (!isMemoryCacheable) {
       return null;
     }
 
-    EngineResource<?> active = null;
-    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
-    if (activeRef != null) {
-      active = activeRef.get();
-      if (active != null) {
-        active.acquire();
-      } else {
-        activeResources.remove(key);
+    EngineResource<?> active = loadFromActiveResources(key);
+    if (active != null) {
+      if (VERBOSE_IS_LOGGABLE) {
+        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
       }
+      return active;
     }
 
-    return active;
+    EngineResource<?> cached = loadFromCache(key);
+    if (cached != null) {
+      if (VERBOSE_IS_LOGGABLE) {
+        logWithTimeAndKey("Loaded resource from cache", startTime, key);
+      }
+      return cached;
+    }
+
+    return null;
   }
 
-  private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
-    if (!isMemoryCacheable) {
-      return null;
+  private static void logWithTimeAndKey(String log, long startTime, Key key) {
+    Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
+  }
+
+  @Nullable
+  private EngineResource<?> loadFromActiveResources(Key key) {
+    EngineResource<?> active = activeResources.get(key);
+    if (active != null) {
+      active.acquire();
     }
 
+    return active;
+  }
+
+  private EngineResource<?> loadFromCache(Key key) {
     EngineResource<?> cached = getEngineResourceFromCache(key);
     if (cached != null) {
       cached.acquire();
-      activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));
+      activeResources.activate(key, cached);
     }
     return cached;
   }
 
-  @SuppressWarnings("unchecked")
   private EngineResource<?> getEngineResourceFromCache(Key key) {
     Resource<?> cached = cache.remove(key);
 
@@ -281,13 +350,14 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
       result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource<>(cached, true /*isMemoryCacheable*/);
+      result =
+          new EngineResource<>(
+              cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);
     }
     return result;
   }
 
   public void release(Resource<?> resource) {
-    Util.assertMainThread();
     if (resource instanceof EngineResource) {
       ((EngineResource<?>) resource).release();
     } else {
@@ -297,40 +367,30 @@ public void release(Resource<?> resource) {
 
   @SuppressWarnings("unchecked")
   @Override
-  public void onEngineJobComplete(Key key, EngineResource<?> resource) {
-    Util.assertMainThread();
+  public synchronized void onEngineJobComplete(
+      EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
     // A null resource indicates that the load failed, usually due to an exception.
-    if (resource != null) {
-      resource.setResourceListener(key, this);
-
-      if (resource.isCacheable()) {
-        activeResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
-      }
+    if (resource != null && resource.isMemoryCacheable()) {
+      activeResources.activate(key, resource);
     }
-    // TODO: should this check that the engine job is still current?
-    jobs.remove(key);
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onEngineJobCancelled(EngineJob engineJob, Key key) {
-    Util.assertMainThread();
-    EngineJob<?> current = jobs.get(key);
-    if (engineJob.equals(current)) {
-      jobs.remove(key);
-    }
+  public synchronized void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onResourceRemoved(final Resource<?> resource) {
-    Util.assertMainThread();
+  public void onResourceRemoved(@NonNull final Resource<?> resource) {
     resourceRecycler.recycle(resource);
   }
 
   @Override
-  public void onResourceReleased(Key cacheKey, EngineResource resource) {
-    Util.assertMainThread();
-    activeResources.remove(cacheKey);
-    if (resource.isCacheable()) {
+  public synchronized void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
+    activeResources.deactivate(cacheKey);
+    if (resource.isMemoryCacheable()) {
       cache.put(cacheKey, resource);
     } else {
       resourceRecycler.recycle(resource);
@@ -341,13 +401,36 @@ public void clearDiskCache() {
     diskCacheProvider.getDiskCache().clear();
   }
 
-  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
-    if (resourceReferenceQueue == null) {
-      resourceReferenceQueue = new ReferenceQueue<>();
-      MessageQueue queue = Looper.myQueue();
-      queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
+  @VisibleForTesting
+  public void shutdown() {
+    engineJobFactory.shutdown();
+    diskCacheProvider.clearDiskCacheIfCreated();
+    activeResources.shutdown();
+  }
+
+  /**
+   * Allows a request to indicate it no longer is interested in a given load.
+   *
+   * <p>Non-final for mocking.
+   */
+  public class LoadStatus {
+    private final EngineJob<?> engineJob;
+    private final ResourceCallback cb;
+
+    LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
+      this.cb = cb;
+      this.engineJob = engineJob;
+    }
+
+    public void cancel() {
+      // Acquire the Engine lock so that a new request can't get access to a particular EngineJob
+      // just after the EngineJob has been cancelled. Without this lock, we'd allow new requests
+      // to find the cancelling EngineJob in our Jobs data structure. With this lock, the EngineJob
+      // is both cancelled and removed from Jobs atomically.
+      synchronized (Engine.this) {
+        engineJob.removeCallback(cb);
+      }
     }
-    return resourceReferenceQueue;
   }
 
   private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
@@ -355,10 +438,18 @@ public void clearDiskCache() {
     private final DiskCache.Factory factory;
     private volatile DiskCache diskCache;
 
-    public LazyDiskCacheProvider(DiskCache.Factory factory) {
+    LazyDiskCacheProvider(DiskCache.Factory factory) {
       this.factory = factory;
     }
 
+    @VisibleForTesting
+    synchronized void clearDiskCacheIfCreated() {
+      if (diskCache == null) {
+        return;
+      }
+      diskCache.clear();
+    }
+
     @Override
     public DiskCache getDiskCache() {
       if (diskCache == null) {
@@ -375,49 +466,21 @@ public DiskCache getDiskCache() {
     }
   }
 
-  private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-    @Synthetic final Key key;
-
-    public ResourceWeakReference(Key key, EngineResource<?> r,
-        ReferenceQueue<? super EngineResource<?>> q) {
-      super(r, q);
-      this.key = key;
-    }
-  }
-
-  // Responsible for cleaning up the active resource map by remove weak references that have been
-  // cleared.
-  private static class RefQueueIdleHandler implements MessageQueue.IdleHandler {
-    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
-    private final ReferenceQueue<EngineResource<?>> queue;
-
-    public RefQueueIdleHandler(Map<Key, WeakReference<EngineResource<?>>> activeResources,
-        ReferenceQueue<EngineResource<?>> queue) {
-      this.activeResources = activeResources;
-      this.queue = queue;
-    }
-
-    @Override
-    public boolean queueIdle() {
-      ResourceWeakReference ref = (ResourceWeakReference) queue.poll();
-      if (ref != null) {
-        activeResources.remove(ref.key);
-      }
-
-      return true;
-    }
-  }
-
-  // Visible for testing.
+  @VisibleForTesting
   static class DecodeJobFactory {
     @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
-    @Synthetic final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<DecodeJob<?>>() {
-          @Override
-          public DecodeJob<?> create() {
-            return new DecodeJob<Object>(diskCacheProvider, pool);
-          }
-        });
+
+    @Synthetic
+    final Pools.Pool<DecodeJob<?>> pool =
+        FactoryPools.threadSafe(
+            JOB_POOL_SIZE,
+            new FactoryPools.Factory<DecodeJob<?>>() {
+              @Override
+              public DecodeJob<?> create() {
+                return new DecodeJob<>(diskCacheProvider, pool);
+              }
+            });
+
     private int creationOrder;
 
     DecodeJobFactory(DecodeJob.DiskCacheProvider diskCacheProvider) {
@@ -425,7 +488,8 @@ public boolean queueIdle() {
     }
 
     @SuppressWarnings("unchecked")
-    <R> DecodeJob<R> build(GlideContext glideContext,
+    <R> DecodeJob<R> build(
+        GlideContext glideContext,
         Object model,
         EngineKey loadKey,
         Key signature,
@@ -441,7 +505,7 @@ public boolean queueIdle() {
         boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
-      DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
+      DecodeJob<R> result = Preconditions.checkNotNull((DecodeJob<R>) pool.acquire());
       return result.init(
           glideContext,
           model,
@@ -463,45 +527,70 @@ public boolean queueIdle() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class EngineJobFactory {
     @Synthetic final GlideExecutor diskCacheExecutor;
     @Synthetic final GlideExecutor sourceExecutor;
     @Synthetic final GlideExecutor sourceUnlimitedExecutor;
     @Synthetic final GlideExecutor animationExecutor;
-    @Synthetic final EngineJobListener listener;
-    @Synthetic final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<EngineJob<?>>() {
-          @Override
-          public EngineJob<?> create() {
-            return new EngineJob<Object>(
-                diskCacheExecutor,
-                sourceExecutor,
-                sourceUnlimitedExecutor,
-                animationExecutor,
-                listener,
-                pool);
-          }
-        });
+    @Synthetic final EngineJobListener engineJobListener;
+    @Synthetic final ResourceListener resourceListener;
+
+    @Synthetic
+    final Pools.Pool<EngineJob<?>> pool =
+        FactoryPools.threadSafe(
+            JOB_POOL_SIZE,
+            new FactoryPools.Factory<EngineJob<?>>() {
+              @Override
+              public EngineJob<?> create() {
+                return new EngineJob<>(
+                    diskCacheExecutor,
+                    sourceExecutor,
+                    sourceUnlimitedExecutor,
+                    animationExecutor,
+                    engineJobListener,
+                    resourceListener,
+                    pool);
+              }
+            });
 
     EngineJobFactory(
         GlideExecutor diskCacheExecutor,
         GlideExecutor sourceExecutor,
         GlideExecutor sourceUnlimitedExecutor,
         GlideExecutor animationExecutor,
-        EngineJobListener listener) {
+        EngineJobListener engineJobListener,
+        ResourceListener resourceListener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
       this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
       this.animationExecutor = animationExecutor;
-      this.listener = listener;
+      this.engineJobListener = engineJobListener;
+      this.resourceListener = resourceListener;
+    }
+
+    @VisibleForTesting
+    void shutdown() {
+      Executors.shutdownAndAwaitTermination(diskCacheExecutor);
+      Executors.shutdownAndAwaitTermination(sourceExecutor);
+      Executors.shutdownAndAwaitTermination(sourceUnlimitedExecutor);
+      Executors.shutdownAndAwaitTermination(animationExecutor);
     }
 
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
-        boolean useUnlimitedSourceGeneratorPool, boolean useAnimationPool) {
-      EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool, useAnimationPool);
+    <R> EngineJob<R> build(
+        Key key,
+        boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool,
+        boolean useAnimationPool,
+        boolean onlyRetrieveFromCache) {
+      EngineJob<R> result = Preconditions.checkNotNull((EngineJob<R>) pool.acquire());
+      return result.init(
+          key,
+          isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 87c714a6a..bd34729c8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -1,59 +1,70 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.support.v4.util.Pools;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import androidx.core.util.Pools;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Executors;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
-import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * A class that manages a load by adding and removing callbacks for for the load and notifying
  * callbacks when the load completes.
  */
-class EngineJob<R> implements DecodeJob.Callback<R>,
-    Poolable {
+class EngineJob<R> implements DecodeJob.Callback<R>, Poolable {
   private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();
-  private static final Handler MAIN_THREAD_HANDLER =
-      new Handler(Looper.getMainLooper(), new MainThreadCallback());
 
-  private static final int MSG_COMPLETE = 1;
-  private static final int MSG_EXCEPTION = 2;
-  // Used when we realize we're cancelled on a background thread in reschedule and can recycle
-  // immediately rather than waiting for a result or an error.
-  private static final int MSG_CANCELLED = 3;
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final ResourceCallbacksAndExecutors cbs = new ResourceCallbacksAndExecutors();
 
-  private final List<ResourceCallback> cbs = new ArrayList<>(2);
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
+  private final ResourceListener resourceListener;
   private final Pools.Pool<EngineJob<?>> pool;
   private final EngineResourceFactory engineResourceFactory;
-  private final EngineJobListener listener;
+  private final EngineJobListener engineJobListener;
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
   private final GlideExecutor sourceUnlimitedExecutor;
   private final GlideExecutor animationExecutor;
+  private final AtomicInteger pendingCallbacks = new AtomicInteger();
 
   private Key key;
   private boolean isCacheable;
   private boolean useUnlimitedSourceGeneratorPool;
   private boolean useAnimationPool;
+  private boolean onlyRetrieveFromCache;
   private Resource<?> resource;
-  private DataSource dataSource;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  DataSource dataSource;
+
   private boolean hasResource;
-  private GlideException exception;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  GlideException exception;
+
   private boolean hasLoadFailed;
-  // A put of callbacks that are removed while we're notifying other callbacks of a change in
-  // status.
-  private List<ResourceCallback> ignoredCallbacks;
-  private EngineResource<?> engineResource;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  EngineResource<?> engineResource;
+
   private DecodeJob<R> decodeJob;
 
   // Checked primarily on the main thread, but also on other threads in reschedule.
@@ -64,178 +75,231 @@
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
       GlideExecutor animationExecutor,
-      EngineJobListener listener,
+      EngineJobListener engineJobListener,
+      ResourceListener resourceListener,
       Pools.Pool<EngineJob<?>> pool) {
     this(
         diskCacheExecutor,
         sourceExecutor,
         sourceUnlimitedExecutor,
         animationExecutor,
-        listener,
+        engineJobListener,
+        resourceListener,
         pool,
         DEFAULT_FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   EngineJob(
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
       GlideExecutor animationExecutor,
-      EngineJobListener listener,
+      EngineJobListener engineJobListener,
+      ResourceListener resourceListener,
       Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
     this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
     this.animationExecutor = animationExecutor;
-    this.listener = listener;
+    this.engineJobListener = engineJobListener;
+    this.resourceListener = resourceListener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
-  // Visible for testing.
-  EngineJob<R> init(
+  @VisibleForTesting
+  synchronized EngineJob<R> init(
       Key key,
       boolean isCacheable,
       boolean useUnlimitedSourceGeneratorPool,
-      boolean useAnimationPool) {
+      boolean useAnimationPool,
+      boolean onlyRetrieveFromCache) {
     this.key = key;
     this.isCacheable = isCacheable;
     this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
     this.useAnimationPool = useAnimationPool;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     return this;
   }
 
-  public void start(DecodeJob<R> decodeJob) {
+  public synchronized void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
-    GlideExecutor executor = decodeJob.willDecodeFromCache()
-        ? diskCacheExecutor
-        : getActiveSourceExecutor();
+    GlideExecutor executor =
+        decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();
     executor.execute(decodeJob);
   }
 
-  public void addCallback(ResourceCallback cb) {
-    Util.assertMainThread();
+  synchronized void addCallback(final ResourceCallback cb, Executor callbackExecutor) {
     stateVerifier.throwIfRecycled();
+    cbs.add(cb, callbackExecutor);
     if (hasResource) {
-      cb.onResourceReady(engineResource, dataSource);
+      // Acquire early so that the resource isn't recycled while the Runnable below is still sitting
+      // in the executors queue.
+      incrementPendingCallbacks(1);
+      callbackExecutor.execute(new CallResourceReady(cb));
     } else if (hasLoadFailed) {
-      cb.onLoadFailed(exception);
+      incrementPendingCallbacks(1);
+      callbackExecutor.execute(new CallLoadFailed(cb));
     } else {
-      cbs.add(cb);
+      Preconditions.checkArgument(!isCancelled, "Cannot add callbacks to a cancelled EngineJob");
     }
   }
 
-  public void removeCallback(ResourceCallback cb) {
-    Util.assertMainThread();
-    stateVerifier.throwIfRecycled();
-    if (hasResource || hasLoadFailed) {
-      addIgnoredCallback(cb);
-    } else {
-      cbs.remove(cb);
-      if (cbs.isEmpty()) {
-        cancel();
-      }
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  @GuardedBy("this")
+  void callCallbackOnResourceReady(ResourceCallback cb) {
+    try {
+      // This is overly broad, some Glide code is actually called here, but it's much
+      // simpler to encapsulate here than to do so at the actual call point in the
+      // Request implementation.
+      cb.onResourceReady(engineResource, dataSource);
+    } catch (Throwable t) {
+      throw new CallbackException(t);
     }
   }
 
-  private GlideExecutor getActiveSourceExecutor() {
-    return useUnlimitedSourceGeneratorPool
-        ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  @GuardedBy("this")
+  void callCallbackOnLoadFailed(ResourceCallback cb) {
+    // This is overly broad, some Glide code is actually called here, but it's much
+    // simpler to encapsulate here than to do so at the actual call point in the Request
+    // implementation.
+    try {
+      cb.onLoadFailed(exception);
+    } catch (Throwable t) {
+      throw new CallbackException(t);
+    }
   }
 
-  // We cannot remove callbacks while notifying our list of callbacks directly because doing so
-  // would cause a ConcurrentModificationException. However, we need to obey the cancellation
-  // request such that if notifying a callback early in the callbacks list cancels a callback later
-  // in the request list, the cancellation for the later request is still obeyed. Using a put of
-  // ignored callbacks allows us to avoid the exception while still meeting the requirement.
-  private void addIgnoredCallback(ResourceCallback cb) {
-    if (ignoredCallbacks == null) {
-      ignoredCallbacks = new ArrayList<>(2);
-    }
-    if (!ignoredCallbacks.contains(cb)) {
-      ignoredCallbacks.add(cb);
+  synchronized void removeCallback(ResourceCallback cb) {
+    stateVerifier.throwIfRecycled();
+    cbs.remove(cb);
+    if (cbs.isEmpty()) {
+      cancel();
+      boolean isFinishedRunning = hasResource || hasLoadFailed;
+      if (isFinishedRunning && pendingCallbacks.get() == 0) {
+        release();
+      }
     }
   }
 
-  private boolean isInIgnoredCallbacks(ResourceCallback cb) {
-    return ignoredCallbacks != null && ignoredCallbacks.contains(cb);
+  boolean onlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
+
+  private GlideExecutor getActiveSourceExecutor() {
+    return useUnlimitedSourceGeneratorPool
+        ? sourceUnlimitedExecutor
+        : (useAnimationPool ? animationExecutor : sourceExecutor);
   }
 
   // Exposed for testing.
   void cancel() {
-    if (hasLoadFailed || hasResource || isCancelled) {
+    if (isDone()) {
       return;
     }
 
     isCancelled = true;
     decodeJob.cancel();
-    // TODO: Consider trying to remove jobs that have never been run before from executor queues.
-    // Removing jobs that have run before can break things. See #1996.
-    listener.onEngineJobCancelled(this, key);
+    engineJobListener.onEngineJobCancelled(this, key);
   }
 
   // Exposed for testing.
-  boolean isCancelled() {
+  synchronized boolean isCancelled() {
     return isCancelled;
   }
 
+  private boolean isDone() {
+    return hasLoadFailed || hasResource || isCancelled;
+  }
+
+  // We have to post Runnables in a loop. Typically there will be very few callbacks. AccessorMethod
+  // seems to be a false positive
+  @SuppressWarnings({
+    "WeakerAccess",
+    "PMD.AvoidInstantiatingObjectsInLoops",
+    "PMD.AccessorMethodGeneration"
+  })
   @Synthetic
-  void handleResultOnMainThread() {
-    stateVerifier.throwIfRecycled();
-    if (isCancelled) {
-      resource.recycle();
-      release(false /*isRemovedFromQueue*/);
-      return;
-    } else if (cbs.isEmpty()) {
-      throw new IllegalStateException("Received a resource without any callbacks to notify");
-    } else if (hasResource) {
-      throw new IllegalStateException("Already have resource");
-    }
-    engineResource = engineResourceFactory.build(resource, isCacheable);
-    hasResource = true;
-
-    // Hold on to resource for duration of request so we don't recycle it in the middle of
-    // notifying if it synchronously released by one of the callbacks.
-    engineResource.acquire();
-    listener.onEngineJobComplete(key, engineResource);
-
-    for (ResourceCallback cb : cbs) {
-      if (!isInIgnoredCallbacks(cb)) {
-        engineResource.acquire();
-        cb.onResourceReady(engineResource, dataSource);
+  void notifyCallbacksOfResult() {
+    ResourceCallbacksAndExecutors copy;
+    Key localKey;
+    EngineResource<?> localResource;
+    synchronized (this) {
+      stateVerifier.throwIfRecycled();
+      if (isCancelled) {
+        // TODO: Seems like we might as well put this in the memory cache instead of just recycling
+        // it since we've gotten this far...
+        resource.recycle();
+        release();
+        return;
+      } else if (cbs.isEmpty()) {
+        throw new IllegalStateException("Received a resource without any callbacks to notify");
+      } else if (hasResource) {
+        throw new IllegalStateException("Already have resource");
       }
+      engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);
+      // Hold on to resource for duration of our callbacks below so we don't recycle it in the
+      // middle of notifying if it synchronously released by one of the callbacks. Acquire it under
+      // a lock here so that any newly added callback that executes before the next locked section
+      // below can't recycle the resource before we call the callbacks.
+      hasResource = true;
+      copy = cbs.copy();
+      incrementPendingCallbacks(copy.size() + 1);
+
+      localKey = key;
+      localResource = engineResource;
     }
-    // Our request is complete, so we can release the resource.
-    engineResource.release();
 
-    release(false /*isRemovedFromQueue*/);
+    engineJobListener.onEngineJobComplete(this, localKey, localResource);
+
+    for (final ResourceCallbackAndExecutor entry : copy) {
+      entry.executor.execute(new CallResourceReady(entry.cb));
+    }
+    decrementPendingCallbacks();
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  synchronized void incrementPendingCallbacks(int count) {
+    Preconditions.checkArgument(isDone(), "Not yet complete!");
+    if (pendingCallbacks.getAndAdd(count) == 0 && engineResource != null) {
+      engineResource.acquire();
+    }
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
-  void handleCancelledOnMainThread() {
+  synchronized void decrementPendingCallbacks() {
     stateVerifier.throwIfRecycled();
-    if (!isCancelled) {
-      throw new IllegalStateException("Not cancelled");
+    Preconditions.checkArgument(isDone(), "Not yet complete!");
+    int decremented = pendingCallbacks.decrementAndGet();
+    Preconditions.checkArgument(decremented >= 0, "Can't decrement below 0");
+    if (decremented == 0) {
+      if (engineResource != null) {
+        engineResource.release();
+      }
+
+      release();
     }
-    listener.onEngineJobCancelled(this, key);
-    release(false /*isRemovedFromQueue*/);
   }
 
-  private void release(boolean isRemovedFromQueue) {
-    Util.assertMainThread();
+  private synchronized void release() {
+    if (key == null) {
+      throw new IllegalArgumentException();
+    }
     cbs.clear();
     key = null;
     engineResource = null;
     resource = null;
-    if (ignoredCallbacks != null) {
-      ignoredCallbacks.clear();
-    }
     hasLoadFailed = false;
     isCancelled = false;
     hasResource = false;
-    decodeJob.release(isRemovedFromQueue);
+    decodeJob.release(/*isRemovedFromQueue=*/ false);
     decodeJob = null;
     exception = null;
     dataSource = null;
@@ -244,15 +308,19 @@ private void release(boolean isRemovedFromQueue) {
 
   @Override
   public void onResourceReady(Resource<R> resource, DataSource dataSource) {
-    this.resource = resource;
-    this.dataSource = dataSource;
-    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();
+    synchronized (this) {
+      this.resource = resource;
+      this.dataSource = dataSource;
+    }
+    notifyCallbacksOfResult();
   }
 
   @Override
   public void onLoadFailed(GlideException e) {
-    this.exception = e;
-    MAIN_THREAD_HANDLER.obtainMessage(MSG_EXCEPTION, this).sendToTarget();
+    synchronized (this) {
+      this.exception = e;
+    }
+    notifyCallbacksOfException();
   }
 
   @Override
@@ -262,64 +330,182 @@ public void reschedule(DecodeJob<?> job) {
     getActiveSourceExecutor().execute(job);
   }
 
+  // We have to post Runnables in a loop. Typically there will be very few callbacks. Acessor method
+  // warning seems to be false positive.
+  @SuppressWarnings({
+    "WeakerAccess",
+    "PMD.AvoidInstantiatingObjectsInLoops",
+    "PMD.AccessorMethodGeneration"
+  })
   @Synthetic
-  void handleExceptionOnMainThread() {
-    stateVerifier.throwIfRecycled();
-    if (isCancelled) {
-      release(false /*isRemovedFromQueue*/);
-      return;
-    } else if (cbs.isEmpty()) {
-      throw new IllegalStateException("Received an exception without any callbacks to notify");
-    } else if (hasLoadFailed) {
-      throw new IllegalStateException("Already failed once");
-    }
-    hasLoadFailed = true;
+  void notifyCallbacksOfException() {
+    ResourceCallbacksAndExecutors copy;
+    Key localKey;
+    synchronized (this) {
+      stateVerifier.throwIfRecycled();
+      if (isCancelled) {
+        release();
+        return;
+      } else if (cbs.isEmpty()) {
+        throw new IllegalStateException("Received an exception without any callbacks to notify");
+      } else if (hasLoadFailed) {
+        throw new IllegalStateException("Already failed once");
+      }
+      hasLoadFailed = true;
 
-    listener.onEngineJobComplete(key, null);
+      localKey = key;
 
-    for (ResourceCallback cb : cbs) {
-      if (!isInIgnoredCallbacks(cb)) {
-        cb.onLoadFailed(exception);
-      }
+      copy = cbs.copy();
+      // One for each callback below, plus one for ourselves so that we finish if a callback runs on
+      // another thread before we finish scheduling all of them.
+      incrementPendingCallbacks(copy.size() + 1);
     }
 
-    release(false /*isRemovedFromQueue*/);
+    engineJobListener.onEngineJobComplete(this, localKey, /*resource=*/ null);
+
+    for (ResourceCallbackAndExecutor entry : copy) {
+      entry.executor.execute(new CallLoadFailed(entry.cb));
+    }
+    decrementPendingCallbacks();
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  // Visible for testing.
-  static class EngineResourceFactory {
-    public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
-      return new EngineResource<>(resource, isMemoryCacheable);
+  private class CallLoadFailed implements Runnable {
+
+    private final ResourceCallback cb;
+
+    CallLoadFailed(ResourceCallback cb) {
+      this.cb = cb;
+    }
+
+    @Override
+    public void run() {
+      // Make sure we always acquire the request lock, then the EngineJob lock to avoid deadlock
+      // (b/136032534).
+      synchronized (cb) {
+        synchronized (EngineJob.this) {
+          if (cbs.contains(cb)) {
+            callCallbackOnLoadFailed(cb);
+          }
+
+          decrementPendingCallbacks();
+        }
+      }
     }
   }
 
-  private static class MainThreadCallback implements Handler.Callback {
+  private class CallResourceReady implements Runnable {
+
+    private final ResourceCallback cb;
 
-    @Synthetic
-    MainThreadCallback() { }
+    CallResourceReady(ResourceCallback cb) {
+      this.cb = cb;
+    }
 
     @Override
-    public boolean handleMessage(Message message) {
-      EngineJob<?> job = (EngineJob<?>) message.obj;
-      switch (message.what) {
-        case MSG_COMPLETE:
-          job.handleResultOnMainThread();
-          break;
-        case MSG_EXCEPTION:
-          job.handleExceptionOnMainThread();
-          break;
-        case MSG_CANCELLED:
-          job.handleCancelledOnMainThread();
-          break;
-        default:
-          throw new IllegalStateException("Unrecognized message: " + message.what);
+    public void run() {
+      // Make sure we always acquire the request lock, then the EngineJob lock to avoid deadlock
+      // (b/136032534).
+      synchronized (cb) {
+        synchronized (EngineJob.this) {
+          if (cbs.contains(cb)) {
+            // Acquire for this particular callback.
+            engineResource.acquire();
+            callCallbackOnResourceReady(cb);
+            removeCallback(cb);
+          }
+          decrementPendingCallbacks();
+        }
       }
-      return true;
+    }
+  }
+
+  static final class ResourceCallbacksAndExecutors
+      implements Iterable<ResourceCallbackAndExecutor> {
+    private final List<ResourceCallbackAndExecutor> callbacksAndExecutors;
+
+    ResourceCallbacksAndExecutors() {
+      this(new ArrayList<ResourceCallbackAndExecutor>(2));
+    }
+
+    ResourceCallbacksAndExecutors(List<ResourceCallbackAndExecutor> callbacksAndExecutors) {
+      this.callbacksAndExecutors = callbacksAndExecutors;
+    }
+
+    void add(ResourceCallback cb, Executor executor) {
+      callbacksAndExecutors.add(new ResourceCallbackAndExecutor(cb, executor));
+    }
+
+    void remove(ResourceCallback cb) {
+      callbacksAndExecutors.remove(defaultCallbackAndExecutor(cb));
+    }
+
+    boolean contains(ResourceCallback cb) {
+      return callbacksAndExecutors.contains(defaultCallbackAndExecutor(cb));
+    }
+
+    boolean isEmpty() {
+      return callbacksAndExecutors.isEmpty();
+    }
+
+    int size() {
+      return callbacksAndExecutors.size();
+    }
+
+    void clear() {
+      callbacksAndExecutors.clear();
+    }
+
+    ResourceCallbacksAndExecutors copy() {
+      return new ResourceCallbacksAndExecutors(new ArrayList<>(callbacksAndExecutors));
+    }
+
+    private static ResourceCallbackAndExecutor defaultCallbackAndExecutor(ResourceCallback cb) {
+      return new ResourceCallbackAndExecutor(cb, Executors.directExecutor());
+    }
+
+    @NonNull
+    @Override
+    public Iterator<ResourceCallbackAndExecutor> iterator() {
+      return callbacksAndExecutors.iterator();
+    }
+  }
+
+  static final class ResourceCallbackAndExecutor {
+    final ResourceCallback cb;
+    final Executor executor;
+
+    ResourceCallbackAndExecutor(ResourceCallback cb, Executor executor) {
+      this.cb = cb;
+      this.executor = executor;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof ResourceCallbackAndExecutor) {
+        ResourceCallbackAndExecutor other = (ResourceCallbackAndExecutor) o;
+        return cb.equals(other.cb);
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return cb.hashCode();
+    }
+  }
+
+  @VisibleForTesting
+  static class EngineResourceFactory {
+    public <R> EngineResource<R> build(
+        Resource<R> resource, boolean isMemoryCacheable, Key key, ResourceListener listener) {
+      return new EngineResource<>(
+          resource, isMemoryCacheable, /*isRecyclable=*/ true, key, listener);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
index 0d3c2e410..4b068286f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
@@ -4,7 +4,7 @@
 
 interface EngineJobListener {
 
-  void onEngineJobComplete(Key key, EngineResource<?> resource);
+  void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource);
 
-  void onEngineJobCancelled(EngineJob engineJob, Key key);
+  void onEngineJobCancelled(EngineJob<?> engineJob, Key key);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index a95e820a8..b6269f7d7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
@@ -7,9 +8,7 @@
 import java.security.MessageDigest;
 import java.util.Map;
 
-/**
- * An in memory only cache key used to multiplex loads.
- */
+/** An in memory only cache key used to multiplex loads. */
 class EngineKey implements Key {
   private final Object model;
   private final int width;
@@ -21,9 +20,15 @@
   private final Options options;
   private int hashCode;
 
-  public EngineKey(Object model, Key signature, int width, int height,
-      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
-      Class<?> transcodeClass, Options options) {
+  EngineKey(
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Map<Class<?>, Transformation<?>> transformations,
+      Class<?> resourceClass,
+      Class<?> transcodeClass,
+      Options options) {
     this.model = Preconditions.checkNotNull(model);
     this.signature = Preconditions.checkNotNull(signature, "Signature must not be null");
     this.width = width;
@@ -70,20 +75,29 @@ public int hashCode() {
   @Override
   public String toString() {
     return "EngineKey{"
-        + "model=" + model
-        + ", width=" + width
-        + ", height=" + height
-        + ", resourceClass=" + resourceClass
-        + ", transcodeClass=" + transcodeClass
-        + ", signature=" + signature
-        + ", hashCode=" + hashCode
-        + ", transformations=" + transformations
-        + ", options=" + options
+        + "model="
+        + model
+        + ", width="
+        + width
+        + ", height="
+        + height
+        + ", resourceClass="
+        + resourceClass
+        + ", transcodeClass="
+        + transcodeClass
+        + ", signature="
+        + signature
+        + ", hashCode="
+        + hashCode
+        + ", transformations="
+        + transformations
+        + ", options="
+        + options
         + '}';
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     throw new UnsupportedOperationException();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
index ec00d0a06..e1f4993b4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
@@ -8,10 +8,16 @@
 class EngineKeyFactory {
 
   @SuppressWarnings("rawtypes")
-  public EngineKey buildKey(Object model, Key signature, int width, int height,
-      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
-      Class<?> transcodeClass, Options options) {
-    return new EngineKey(model, signature, width, height, transformations, resourceClass,
-        transcodeClass, options);
+  EngineKey buildKey(
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Map<Class<?>, Transformation<?>> transformations,
+      Class<?> resourceClass,
+      Class<?> transcodeClass,
+      Options options) {
+    return new EngineKey(
+        model, signature, width, height, transformations, resourceClass, transcodeClass, options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index c03168f69..0b097e995 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Looper;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 
@@ -11,36 +11,47 @@
  * @param <Z> The type of data returned by the wrapped {@link Resource}.
  */
 class EngineResource<Z> implements Resource<Z> {
-  private final boolean isCacheable;
-  private ResourceListener listener;
-  private Key key;
+  private final boolean isMemoryCacheable;
+  private final boolean isRecyclable;
+  private final Resource<Z> resource;
+  private final ResourceListener listener;
+  private final Key key;
+
   private int acquired;
   private boolean isRecycled;
-  private final Resource<Z> resource;
 
   interface ResourceListener {
     void onResourceReleased(Key key, EngineResource<?> resource);
   }
 
-  EngineResource(Resource<Z> toWrap, boolean isCacheable) {
+  EngineResource(
+      Resource<Z> toWrap,
+      boolean isMemoryCacheable,
+      boolean isRecyclable,
+      Key key,
+      ResourceListener listener) {
     resource = Preconditions.checkNotNull(toWrap);
-    this.isCacheable = isCacheable;
+    this.isMemoryCacheable = isMemoryCacheable;
+    this.isRecyclable = isRecyclable;
+    this.key = key;
+    this.listener = Preconditions.checkNotNull(listener);
   }
 
-  void setResourceListener(Key key, ResourceListener listener) {
-    this.key = key;
-    this.listener = listener;
+  Resource<Z> getResource() {
+    return resource;
   }
 
-  boolean isCacheable() {
-    return isCacheable;
+  boolean isMemoryCacheable() {
+    return isMemoryCacheable;
   }
 
+  @NonNull
   @Override
   public Class<Z> getResourceClass() {
     return resource.getResourceClass();
   }
 
+  @NonNull
   @Override
   public Z get() {
     return resource.get();
@@ -52,7 +63,7 @@ public int getSize() {
   }
 
   @Override
-  public void recycle() {
+  public synchronized void recycle() {
     if (acquired > 0) {
       throw new IllegalStateException("Cannot recycle a resource while it is still acquired");
     }
@@ -60,25 +71,24 @@ public void recycle() {
       throw new IllegalStateException("Cannot recycle a resource that has already been recycled");
     }
     isRecycled = true;
-    resource.recycle();
+    if (isRecyclable) {
+      resource.recycle();
+    }
   }
 
   /**
    * Increments the number of consumers using the wrapped resource. Must be called on the main
    * thread.
    *
-   * <p> This must be called with a number corresponding to the number of new consumers each time
-   * new consumers begin using the wrapped resource. It is always safer to call acquire more often
-   * than necessary. Generally external users should never call this method, the framework will take
-   * care of this for you. </p>
+   * <p>This must be called with a number corresponding to the number of new consumers each time new
+   * consumers begin using the wrapped resource. It is always safer to call acquire more often than
+   * necessary. Generally external users should never call this method, the framework will take care
+   * of this for you.
    */
-  void acquire() {
+  synchronized void acquire() {
     if (isRecycled) {
       throw new IllegalStateException("Cannot acquire a recycled resource");
     }
-    if (!Looper.getMainLooper().equals(Looper.myLooper())) {
-      throw new IllegalThreadStateException("Must call acquire on the main thread");
-    }
     ++acquired;
   }
 
@@ -86,31 +96,43 @@ void acquire() {
    * Decrements the number of consumers using the wrapped resource. Must be called on the main
    * thread.
    *
-   * <p> This must only be called when a consumer that called the {@link #acquire()} method is now
-   * done with the resource. Generally external users should never callthis method, the framework
-   * will take care of this for you. </p>
+   * <p>This must only be called when a consumer that called the {@link #acquire()} method is now
+   * done with the resource. Generally external users should never call this method, the framework
+   * will take care of this for you.
    */
+  // listener is effectively final.
+  @SuppressWarnings("SynchronizeOnNonFinalField")
   void release() {
-    if (acquired <= 0) {
-      throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
-    }
-    if (!Looper.getMainLooper().equals(Looper.myLooper())) {
-      throw new IllegalThreadStateException("Must call release on the main thread");
-    }
-    if (--acquired == 0) {
-      listener.onResourceReleased(key, this);
+    // To avoid deadlock, always acquire the listener lock before our lock so that the locking
+    // scheme is consistent (Engine -> EngineResource). Violating this order leads to deadlock
+    // (b/123646037).
+    synchronized (listener) {
+      synchronized (this) {
+        if (acquired <= 0) {
+          throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
+        }
+        if (--acquired == 0) {
+          listener.onResourceReleased(key, this);
+        }
+      }
     }
   }
 
   @Override
-  public String toString() {
+  public synchronized String toString() {
     return "EngineResource{"
-        + "isCacheable=" + isCacheable
-        + ", listener=" + listener
-        + ", key=" + key
-        + ", acquired=" + acquired
-        + ", isRecycled=" + isRecycled
-        + ", resource=" + resource
+        + "isMemoryCacheable="
+        + isMemoryCacheable
+        + ", listener="
+        + listener
+        + ", key="
+        + key
+        + ", acquired="
+        + acquired
+        + ", isRecycled="
+        + isRecycled
+        + ", resource="
+        + resource
         + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index f932aac27..0197eac46 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.engine;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import java.io.IOException;
@@ -12,27 +12,31 @@
 import java.util.Collections;
 import java.util.List;
 
-/**
- * An exception with zero or more causes indicating why a load in Glide failed.
- */
+/** An exception with zero or more causes indicating why a load in Glide failed. */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class GlideException extends Exception {
+  private static final long serialVersionUID = 1L;
+
   private static final StackTraceElement[] EMPTY_ELEMENTS = new StackTraceElement[0];
 
-  private final List<Exception> causes;
+  private final List<Throwable> causes;
   private Key key;
   private DataSource dataSource;
   private Class<?> dataClass;
+  private String detailMessage;
+  @Nullable private Exception exception;
 
   public GlideException(String message) {
-    this(message, Collections.<Exception>emptyList());
+    this(message, Collections.<Throwable>emptyList());
   }
 
-  public GlideException(String detailMessage, Exception cause) {
+  public GlideException(String detailMessage, Throwable cause) {
     this(detailMessage, Collections.singletonList(cause));
   }
 
-  public GlideException(String detailMessage, List<Exception> causes) {
-    super(detailMessage);
+  public GlideException(String detailMessage, List<Throwable> causes) {
+    this.detailMessage = detailMessage;
     setStackTrace(EMPTY_ELEMENTS);
     this.causes = causes;
   }
@@ -47,6 +51,28 @@ void setLoggingDetails(Key key, DataSource dataSource, Class<?> dataClass) {
     this.dataClass = dataClass;
   }
 
+  /**
+   * Sets a stack trace that includes where the request originated.
+   *
+   * <p>This is an experimental API that may be removed in the future.
+   */
+  public void setOrigin(@Nullable Exception exception) {
+    this.exception = exception;
+  }
+
+  /**
+   * Returns an {@link Exception} with a stack trace that includes where the request originated (if
+   * previously set via {@link #setOrigin(Exception)})
+   *
+   * <p>This is an experimental API that may be removed in the future.
+   */
+  @Nullable
+  public Exception getOrigin() {
+    return exception;
+  }
+
+  // No need to synchronize when doing nothing whatsoever.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
   public Throwable fillInStackTrace() {
     // Avoid an expensive allocation by doing nothing here. Causes should contain all relevant
@@ -58,11 +84,11 @@ public Throwable fillInStackTrace() {
    * Returns a list of causes that are immediate children of this exception.
    *
    * <p>Causes may or may not be {@link GlideException GlideExceptions}. Causes may also not be root
-   * causes, and in turn my have been caused by other failures.</p>
+   * causes, and in turn my have been caused by other failures.
    *
    * @see #getRootCauses()
    */
-  public List<Exception> getCauses() {
+  public List<Throwable> getCauses() {
     return causes;
   }
 
@@ -74,8 +100,8 @@ public Throwable fillInStackTrace() {
    * a given model using multiple different pathways, there may be multiple related or unrelated
    * reasons for a load to fail.
    */
-  public List<Exception> getRootCauses() {
-    List<Exception> rootCauses = new ArrayList<>();
+  public List<Throwable> getRootCauses() {
+    List<Throwable> rootCauses = new ArrayList<>();
     addRootCauses(this, rootCauses);
     return rootCauses;
   }
@@ -88,20 +114,20 @@ public Throwable fillInStackTrace() {
    * complete stack traces.
    */
   public void logRootCauses(String tag) {
-    List<Exception> causes = getRootCauses();
+    List<Throwable> causes = getRootCauses();
     for (int i = 0, size = causes.size(); i < size; i++) {
       Log.i(tag, "Root cause (" + (i + 1) + " of " + size + ")", causes.get(i));
     }
   }
 
-  private void addRootCauses(Exception exception, List<Exception> rootCauses) {
-    if (exception instanceof GlideException) {
-      GlideException glideException = (GlideException) exception;
-      for (Exception e : glideException.getCauses()) {
-        addRootCauses(e, rootCauses);
+  private void addRootCauses(Throwable throwable, List<Throwable> rootCauses) {
+    if (throwable instanceof GlideException) {
+      GlideException glideException = (GlideException) throwable;
+      for (Throwable t : glideException.getCauses()) {
+        addRootCauses(t, rootCauses);
       }
     } else {
-      rootCauses.add(exception);
+      rootCauses.add(throwable);
     }
   }
 
@@ -125,29 +151,52 @@ private void printStackTrace(Appendable appendable) {
     appendCauses(getCauses(), new IndentedAppendable(appendable));
   }
 
+  // PMD doesn't seem to notice that we're allocating the builder with the suggested size.
+  @SuppressWarnings("PMD.InsufficientStringBufferDeclaration")
   @Override
   public String getMessage() {
-    return super.getMessage()
-        + (dataClass != null ? ", " + dataClass : "")
-        + (dataSource != null ? ", " + dataSource : "")
-        + (key != null ? ", " + key : "");
+    StringBuilder result =
+        new StringBuilder(71)
+            .append(detailMessage)
+            .append(dataClass != null ? ", " + dataClass : "")
+            .append(dataSource != null ? ", " + dataSource : "")
+            .append(key != null ? ", " + key : "");
+
+    List<Throwable> rootCauses = getRootCauses();
+    if (rootCauses.isEmpty()) {
+      return result.toString();
+    } else if (rootCauses.size() == 1) {
+      result.append("\nThere was 1 cause:");
+    } else {
+      result.append("\nThere were ").append(rootCauses.size()).append(" causes:");
+    }
+    for (Throwable cause : rootCauses) {
+      result
+          .append('\n')
+          .append(cause.getClass().getName())
+          .append('(')
+          .append(cause.getMessage())
+          .append(')');
+    }
+    result.append("\n call GlideException#logRootCauses(String) for more detail");
+    return result.toString();
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
   // never happen.
   @SuppressWarnings("PMD.PreserveStackTrace")
-  private static void appendExceptionMessage(Exception e, Appendable appendable) {
+  private static void appendExceptionMessage(Throwable t, Appendable appendable) {
     try {
-      appendable.append(e.getClass().toString()).append(": ").append(e.getMessage()).append('\n');
+      appendable.append(t.getClass().toString()).append(": ").append(t.getMessage()).append('\n');
     } catch (IOException e1) {
-      throw new RuntimeException(e);
+      throw new RuntimeException(t);
     }
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
   // never happen.
   @SuppressWarnings("PMD.PreserveStackTrace")
-  private static void appendCauses(List<Exception> causes, Appendable appendable) {
+  private static void appendCauses(List<Throwable> causes, Appendable appendable) {
     try {
       appendCausesWrapped(causes, appendable);
     } catch (IOException e) {
@@ -156,17 +205,18 @@ private static void appendCauses(List<Exception> causes, Appendable appendable)
   }
 
   @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
-  private static void appendCausesWrapped(List<Exception> causes, Appendable appendable)
+  private static void appendCausesWrapped(List<Throwable> causes, Appendable appendable)
       throws IOException {
     int size = causes.size();
     for (int i = 0; i < size; i++) {
-      appendable.append("Cause (")
+      appendable
+          .append("Cause (")
           .append(String.valueOf(i + 1))
           .append(" of ")
           .append(String.valueOf(size))
           .append("): ");
 
-      Exception cause = causes.get(i);
+      Throwable cause = causes.get(i);
       if (cause instanceof GlideException) {
         GlideException glideCause = (GlideException) cause;
         glideCause.printStackTrace(appendable);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
index 9b34820b1..15091bf2a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
@@ -6,9 +6,6 @@
  */
 public interface Initializable {
 
-  /**
-   * Called on a background thread so the {@link Resource} can do some eager initialization.
-   */
+  /** Called on a background thread so the {@link Resource} can do some eager initialization. */
   void initialize();
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
new file mode 100644
index 000000000..3c840082a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine;
+
+import androidx.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+final class Jobs {
+  private final Map<Key, EngineJob<?>> jobs = new HashMap<>();
+  private final Map<Key, EngineJob<?>> onlyCacheJobs = new HashMap<>();
+
+  @VisibleForTesting
+  Map<Key, EngineJob<?>> getAll() {
+    return Collections.unmodifiableMap(jobs);
+  }
+
+  EngineJob<?> get(Key key, boolean onlyRetrieveFromCache) {
+    return getJobMap(onlyRetrieveFromCache).get(key);
+  }
+
+  void put(Key key, EngineJob<?> job) {
+    getJobMap(job.onlyRetrieveFromCache()).put(key, job);
+  }
+
+  void removeIfCurrent(Key key, EngineJob<?> expected) {
+    Map<Key, EngineJob<?>> jobMap = getJobMap(expected.onlyRetrieveFromCache());
+    if (expected.equals(jobMap.get(key))) {
+      jobMap.remove(key);
+    }
+  }
+
+  private Map<Key, EngineJob<?>> getJobMap(boolean onlyRetrieveFromCache) {
+    return onlyRetrieveFromCache ? onlyCacheJobs : jobs;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
index d182da6ea..d3003642d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
-import android.support.v4.util.Pools.Pool;
+import androidx.annotation.NonNull;
+import androidx.core.util.Pools.Pool;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.util.Preconditions;
@@ -10,47 +11,66 @@
 
 /**
  * For a given {@link com.bumptech.glide.load.data.DataFetcher} for a given data class, attempts to
- * fetch the data and then run it through one or more
- * {@link com.bumptech.glide.load.engine.DecodePath}s.
+ * fetch the data and then run it through one or more {@link
+ * com.bumptech.glide.load.engine.DecodePath}s.
  *
- * @param <Data>         The type of data that will be fetched.
+ * @param <Data> The type of data that will be fetched.
  * @param <ResourceType> The type of intermediate resource that will be decoded within one of the
- *                       {@link com.bumptech.glide.load.engine.DecodePath}s.
- * @param <Transcode>    The type of resource that will be returned as the result if the load and
- *                       one of the decode paths succeeds.
+ *     {@link com.bumptech.glide.load.engine.DecodePath}s.
+ * @param <Transcode> The type of resource that will be returned as the result if the load and one
+ *     of the decode paths succeeds.
  */
 public class LoadPath<Data, ResourceType, Transcode> {
   private final Class<Data> dataClass;
-  private final Pool<List<Exception>> listPool;
+  private final Pool<List<Throwable>> listPool;
   private final List<? extends DecodePath<Data, ResourceType, Transcode>> decodePaths;
   private final String failureMessage;
 
-  public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
+  public LoadPath(
+      Class<Data> dataClass,
+      Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
-      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Exception>> listPool) {
+      List<DecodePath<Data, ResourceType, Transcode>> decodePaths,
+      Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.listPool = listPool;
     this.decodePaths = Preconditions.checkNotEmpty(decodePaths);
-    failureMessage = "Failed LoadPath{" + dataClass.getSimpleName() + "->"
-        + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
+    failureMessage =
+        "Failed LoadPath{"
+            + dataClass.getSimpleName()
+            + "->"
+            + resourceClass.getSimpleName()
+            + "->"
+            + transcodeClass.getSimpleName()
+            + "}";
   }
 
-  public Resource<Transcode> load(DataRewinder<Data> rewinder, Options options, int width,
-      int height, DecodePath.DecodeCallback<ResourceType> decodeCallback) throws GlideException {
-    List<Exception> exceptions = listPool.acquire();
+  public Resource<Transcode> load(
+      DataRewinder<Data> rewinder,
+      @NonNull Options options,
+      int width,
+      int height,
+      DecodePath.DecodeCallback<ResourceType> decodeCallback)
+      throws GlideException {
+    List<Throwable> throwables = Preconditions.checkNotNull(listPool.acquire());
     try {
-      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, exceptions);
+      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
     } finally {
-      listPool.release(exceptions);
+      listPool.release(throwables);
     }
   }
 
-  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder, Options options,
-      int width, int height, DecodePath.DecodeCallback<ResourceType> decodeCallback,
-      List<Exception> exceptions) throws GlideException {
-    int size = decodePaths.size();
+  private Resource<Transcode> loadWithExceptionList(
+      DataRewinder<Data> rewinder,
+      @NonNull Options options,
+      int width,
+      int height,
+      DecodePath.DecodeCallback<ResourceType> decodeCallback,
+      List<Throwable> exceptions)
+      throws GlideException {
     Resource<Transcode> result = null;
-    for (int i = 0; i < size; i++) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = decodePaths.size(); i < size; i++) {
       DecodePath<Data, ResourceType, Transcode> path = decodePaths.get(i);
       try {
         result = path.decode(rewinder, width, height, options, decodeCallback);
@@ -75,7 +95,6 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
 
   @Override
   public String toString() {
-    return "LoadPath{" + "decodePaths="
-        + Arrays.toString(decodePaths.toArray(new DecodePath[decodePaths.size()])) + '}';
+    return "LoadPath{" + "decodePaths=" + Arrays.toString(decodePaths.toArray()) + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
index 5ee05aca7..6a8ae72ae 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.engine;
 
-import android.support.v4.util.Pools;
+import androidx.annotation.NonNull;
+import androidx.core.util.Pools;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
@@ -12,29 +14,32 @@
  * <p>If the resource was recycled prior to {@link #unlock()}, then {@link #unlock()} will also
  * recycle the resource.
  */
-final class LockedResource<Z> implements Resource<Z>,
-    FactoryPools.Poolable {
-  private static final Pools.Pool<LockedResource<?>> POOL = FactoryPools.threadSafe(20,
-      new FactoryPools.Factory<LockedResource<?>>() {
-        @Override
-        public LockedResource<?> create() {
-          return new LockedResource<Object>();
-        }
-      });
+final class LockedResource<Z> implements Resource<Z>, FactoryPools.Poolable {
+  private static final Pools.Pool<LockedResource<?>> POOL =
+      FactoryPools.threadSafe(
+          20,
+          new FactoryPools.Factory<LockedResource<?>>() {
+            @Override
+            public LockedResource<?> create() {
+              return new LockedResource<Object>();
+            }
+          });
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private Resource<Z> toWrap;
   private boolean isLocked;
   private boolean isRecycled;
 
   @SuppressWarnings("unchecked")
+  @NonNull
   static <Z> LockedResource<Z> obtain(Resource<Z> resource) {
-    LockedResource<Z> result = (LockedResource<Z>) POOL.acquire();
+    LockedResource<Z> result = Preconditions.checkNotNull((LockedResource<Z>) POOL.acquire());
     result.init(resource);
     return result;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
-  LockedResource() { }
+  LockedResource() {}
 
   private void init(Resource<Z> toWrap) {
     isRecycled = false;
@@ -47,7 +52,7 @@ private void release() {
     POOL.release(this);
   }
 
-  public synchronized void unlock() {
+  synchronized void unlock() {
     stateVerifier.throwIfRecycled();
 
     if (!isLocked) {
@@ -59,11 +64,13 @@ public synchronized void unlock() {
     }
   }
 
+  @NonNull
   @Override
   public Class<Z> getResourceClass() {
     return toWrap.getResourceClass();
   }
 
+  @NonNull
   @Override
   public Z get() {
     return toWrap.get();
@@ -85,6 +92,7 @@ public synchronized void recycle() {
     }
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
index 3717a889d..35b99fedd 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import androidx.annotation.NonNull;
 
 /**
  * A resource interface that wraps a particular type so that it can be pooled and reused.
@@ -8,21 +9,21 @@
  */
 public interface Resource<Z> {
 
-  /**
-   * Returns the {@link Class} of the wrapped resource.
-   */
+  /** Returns the {@link Class} of the wrapped resource. */
+  @NonNull
   Class<Z> getResourceClass();
 
   /**
    * Returns an instance of the wrapped resource.
    *
-   * <p> Note - This does not have to be the same instance of the wrapped resource class and in fact
-   * it is often appropriate to return a new instance for each call. For example,
-   * {@link android.graphics.drawable.Drawable Drawable}s should only be used by a single
-   * {@link android.view.View View} at a time so each call to this method for Resources that wrap
-   * {@link android.graphics.drawable.Drawable Drawable}s should always return a new
-   * {@link android.graphics.drawable.Drawable Drawable}. </p>
+   * <p>Note - This does not have to be the same instance of the wrapped resource class and in fact
+   * it is often appropriate to return a new instance for each call. For example, {@link
+   * android.graphics.drawable.Drawable Drawable}s should only be used by a single {@link
+   * android.view.View View} at a time so each call to this method for Resources that wrap {@link
+   * android.graphics.drawable.Drawable Drawable}s should always return a new {@link
+   * android.graphics.drawable.Drawable Drawable}.
    */
+  @NonNull
   Z get();
 
   /**
@@ -34,18 +35,18 @@
   /**
    * Cleans up and recycles internal resources.
    *
-   * <p> It is only safe to call this method if there are no current resource consumers and if this
+   * <p>It is only safe to call this method if there are no current resource consumers and if this
    * method has not yet been called. Typically this occurs at one of two times:
+   *
    * <ul>
    *   <li>During a resource load when the resource is transformed or transcoded before any consumer
-   *   have ever had access to this resource</li>
+   *       have ever had access to this resource
    *   <li>After all consumers have released this resource and it has been evicted from the cache
-   *   </li>
    * </ul>
    *
    * For most users of this class, the only time this method should ever be called is during
    * transformations or transcoders, the framework will call this method when all consumers have
-   * released this resource and it has been evicted from the cache. </p>
+   * released this resource and it has been evicted from the cache.
    */
   void recycle();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index b0d444ed9..c3bf6630b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
@@ -13,13 +14,12 @@
  * Generates {@link com.bumptech.glide.load.data.DataFetcher DataFetchers} from cache files
  * containing downsampled/transformed resource data.
  */
-class ResourceCacheGenerator implements DataFetcherGenerator,
-    DataFetcher.DataCallback<Object> {
+class ResourceCacheGenerator implements DataFetcherGenerator, DataFetcher.DataCallback<Object> {
 
   private final FetcherReadyCallback cb;
   private final DecodeHelper<?> helper;
 
-  private int sourceIdIndex = 0;
+  private int sourceIdIndex;
   private int resourceClassIndex = -1;
   private Key sourceKey;
   private List<ModelLoader<File, ?>> modelLoaders;
@@ -29,13 +29,16 @@
   // multiple calls to startNext.
   @SuppressWarnings("PMD.SingularField")
   private File cacheFile;
+
   private ResourceCacheKey currentKey;
 
-  public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+  ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
     this.helper = helper;
     this.cb = cb;
   }
 
+  // See TODO below.
+  @SuppressWarnings("PMD.CollapsibleIfStatements")
   @Override
   public boolean startNext() {
     List<Key> sourceIds = helper.getCacheKeys();
@@ -43,6 +46,16 @@ public boolean startNext() {
       return false;
     }
     List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
+    if (resourceClasses.isEmpty()) {
+      if (File.class.equals(helper.getTranscodeClass())) {
+        return false;
+      }
+      throw new IllegalStateException(
+          "Failed to find any load path from "
+              + helper.getModelClass()
+              + " to "
+              + helper.getTranscodeClass());
+    }
     while (modelLoaders == null || !hasNextModelLoader()) {
       resourceClassIndex++;
       if (resourceClassIndex >= resourceClasses.size()) {
@@ -56,12 +69,22 @@ public boolean startNext() {
       Key sourceId = sourceIds.get(sourceIdIndex);
       Class<?> resourceClass = resourceClasses.get(resourceClassIndex);
       Transformation<?> transformation = helper.getTransformation(resourceClass);
-
-      currentKey = new ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),
-          helper.getHeight(), transformation, resourceClass, helper.getOptions());
+      // PMD.AvoidInstantiatingObjectsInLoops Each iteration is comparatively expensive anyway,
+      // we only run until the first one succeeds, the loop runs for only a limited
+      // number of iterations on the order of 10-20 in the worst case.
+      currentKey =
+          new ResourceCacheKey( // NOPMD AvoidInstantiatingObjectsInLoops
+              helper.getArrayPool(),
+              sourceId,
+              helper.getSignature(),
+              helper.getWidth(),
+              helper.getHeight(),
+              transformation,
+              resourceClass,
+              helper.getOptions());
       cacheFile = helper.getDiskCache().get(currentKey);
       if (cacheFile != null) {
-        this.sourceKey = sourceId;
+        sourceKey = sourceId;
         modelLoaders = helper.getModelLoaders(cacheFile);
         modelLoaderIndex = 0;
       }
@@ -72,8 +95,8 @@ public boolean startNext() {
     while (!started && hasNextModelLoader()) {
       ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
       loadData =
-          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
-              helper.getOptions());
+          modelLoader.buildLoadData(
+              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());
       if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
@@ -97,12 +120,12 @@ public void cancel() {
 
   @Override
   public void onDataReady(Object data) {
-    cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE,
-        currentKey);
+    cb.onDataFetcherReady(
+        sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE, currentKey);
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(currentKey, e, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index 2fbd7051e..98825103b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -1,18 +1,19 @@
 package com.bumptech.glide.load.engine;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
-/**
- * A cache key for downsampled and transformed resource data + any requested signature.
- */
+/** A cache key for downsampled and transformed resource data + any requested signature. */
 final class ResourceCacheKey implements Key {
   private static final LruCache<Class<?>, byte[]> RESOURCE_CLASS_BYTES = new LruCache<>(50);
+  private final ArrayPool arrayPool;
   private final Key sourceKey;
   private final Key signature;
   private final int width;
@@ -21,8 +22,16 @@
   private final Options options;
   private final Transformation<?> transformation;
 
-  public ResourceCacheKey(Key sourceKey, Key signature, int width, int height,
-      Transformation<?> appliedTransformation, Class<?> decodedResourceClass, Options options) {
+  ResourceCacheKey(
+      ArrayPool arrayPool,
+      Key sourceKey,
+      Key signature,
+      int width,
+      int height,
+      Transformation<?> appliedTransformation,
+      Class<?> decodedResourceClass,
+      Options options) {
+    this.arrayPool = arrayPool;
     this.sourceKey = sourceKey;
     this.signature = signature;
     this.width = width;
@@ -36,7 +45,8 @@ public ResourceCacheKey(Key sourceKey, Key signature, int width, int height,
   public boolean equals(Object o) {
     if (o instanceof ResourceCacheKey) {
       ResourceCacheKey other = (ResourceCacheKey) o;
-      return height == other.height && width == other.width
+      return height == other.height
+          && width == other.width
           && Util.bothNullOrEqual(transformation, other.transformation)
           && decodedResourceClass.equals(other.decodedResourceClass)
           && sourceKey.equals(other.sourceKey)
@@ -62,8 +72,9 @@ public int hashCode() {
 
   // TODO: Include relevant options?
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    byte[] dimensions = ByteBuffer.allocate(8).putInt(width).putInt(height).array();
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    byte[] dimensions = arrayPool.getExact(8, byte[].class);
+    ByteBuffer.wrap(dimensions).putInt(width).putInt(height).array();
     signature.updateDiskCacheKey(messageDigest);
     sourceKey.updateDiskCacheKey(messageDigest);
     messageDigest.update(dimensions);
@@ -72,6 +83,7 @@ public void updateDiskCacheKey(MessageDigest messageDigest) {
     }
     options.updateDiskCacheKey(messageDigest);
     messageDigest.update(getResourceClassBytes());
+    arrayPool.put(dimensions);
   }
 
   private byte[] getResourceClassBytes() {
@@ -86,13 +98,21 @@ public void updateDiskCacheKey(MessageDigest messageDigest) {
   @Override
   public String toString() {
     return "ResourceCacheKey{"
-        + "sourceKey=" + sourceKey
-        + ", signature=" + signature
-        + ", width=" + width
-        + ", height=" + height
-        + ", decodedResourceClass=" + decodedResourceClass
-        + ", transformation='" + transformation + '\''
-        + ", options=" + options
+        + "sourceKey="
+        + sourceKey
+        + ", signature="
+        + signature
+        + ", width="
+        + width
+        + ", height="
+        + height
+        + ", decodedResourceClass="
+        + decodedResourceClass
+        + ", transformation='"
+        + transformation
+        + '\''
+        + ", options="
+        + options
         + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index 6d8d365b8..ac8ade21f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -4,24 +4,18 @@
 import android.os.Looper;
 import android.os.Message;
 import com.bumptech.glide.util.Synthetic;
-import com.bumptech.glide.util.Util;
 
-/**
- * A class that can safely recycle recursive resources.
- */
+/** A class that can safely recycle recursive resources. */
 class ResourceRecycler {
   private boolean isRecycling;
   private final Handler handler =
       new Handler(Looper.getMainLooper(), new ResourceRecyclerCallback());
 
-  public void recycle(Resource<?> resource) {
-    Util.assertMainThread();
-
+  synchronized void recycle(Resource<?> resource) {
     if (isRecycling) {
       // If a resource has sub-resources, releasing a sub resource can cause it's parent to be
-      // synchronously
-      // evicted which leads to a recycle loop when the parent releases it's children. Posting
-      // breaks this loop.
+      // synchronously evicted which leads to a recycle loop when the parent releases it's children.
+      // Posting breaks this loop.
       handler.obtainMessage(ResourceRecyclerCallback.RECYCLE_RESOURCE, resource).sendToTarget();
     } else {
       isRecycling = true;
@@ -30,11 +24,11 @@ public void recycle(Resource<?> resource) {
     }
   }
 
-  private static class ResourceRecyclerCallback implements Handler.Callback {
-    public static final int RECYCLE_RESOURCE = 1;
+  private static final class ResourceRecyclerCallback implements Handler.Callback {
+    static final int RECYCLE_RESOURCE = 1;
 
     @Synthetic
-    ResourceRecyclerCallback() { }
+    ResourceRecyclerCallback() {}
 
     @Override
     public boolean handleMessage(Message message) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
index c3f3420dc..d0aa0cff7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -15,12 +16,13 @@
  * using registered {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders} and the model
  * provided for the load.
  *
- * <p> Depending on the disk cache strategy, source data may first be written to disk and then
- * loaded from the cache file rather than returned directly. </p>
+ * <p>Depending on the disk cache strategy, source data may first be written to disk and then loaded
+ * from the cache file rather than returned directly.
  */
-class SourceGenerator implements DataFetcherGenerator,
-    DataFetcher.DataCallback<Object>,
-    DataFetcherGenerator.FetcherReadyCallback {
+class SourceGenerator
+    implements DataFetcherGenerator,
+        DataFetcher.DataCallback<Object>,
+        DataFetcherGenerator.FetcherReadyCallback {
   private static final String TAG = "SourceGenerator";
 
   private final DecodeHelper<?> helper;
@@ -32,7 +34,7 @@
   private volatile ModelLoader.LoadData<?> loadData;
   private DataCacheKey originalKey;
 
-  public SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+  SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
     this.helper = helper;
     this.cb = cb;
   }
@@ -56,7 +58,7 @@ public boolean startNext() {
       loadData = helper.getLoadData().get(loadDataListIndex++);
       if (loadData != null
           && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
-          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
+              || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
       }
@@ -77,11 +79,17 @@ private void cacheData(Object dataToCache) {
       originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());
       helper.getDiskCache().put(originalKey, writer);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Finished encoding source to cache"
-            + ", key: " + originalKey
-            + ", data: " + dataToCache
-            + ", encoder: " + encoder
-            + ", duration: " + LogTime.getElapsedMillis(startTime));
+        Log.v(
+            TAG,
+            "Finished encoding source to cache"
+                + ", key: "
+                + originalKey
+                + ", data: "
+                + dataToCache
+                + ", encoder: "
+                + encoder
+                + ", duration: "
+                + LogTime.getElapsedMillis(startTime));
       }
     } finally {
       loadData.fetcher.cleanup();
@@ -108,13 +116,17 @@ public void onDataReady(Object data) {
       // reschedule to get back onto Glide's thread.
       cb.reschedule();
     } else {
-      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,
-          loadData.fetcher.getDataSource(), originalKey);
+      cb.onDataFetcherReady(
+          loadData.sourceKey,
+          data,
+          loadData.fetcher,
+          loadData.fetcher.getDataSource(),
+          originalKey);
     }
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());
   }
 
@@ -127,16 +139,16 @@ public void reschedule() {
 
   // Called from source cache generator.
   @Override
-  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
-      DataSource dataSource, Key attemptedKey) {
+  public void onDataFetcherReady(
+      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {
     // This data fetcher will be loading from a File and provide the wrong data source, so override
     // with the data source of the original fetcher
     cb.onDataFetcherReady(sourceKey, data, fetcher, loadData.fetcher.getDataSource(), sourceKey);
   }
 
   @Override
-  public void onDataFetcherFailed(Key sourceKey, Exception e, DataFetcher<?> fetcher,
-      DataSource dataSource) {
+  public void onDataFetcherFailed(
+      Key sourceKey, Exception e, DataFetcher<?> fetcher, DataSource dataSource) {
     cb.onDataFetcherFailed(sourceKey, e, fetcher, loadData.fetcher.getDataSource());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
index 18427396a..655a980f6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -1,27 +1,20 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 /**
  * Interface for handling operations on a primitive array type.
+ *
  * @param <T> Array type (e.g. byte[], int[])
  */
-public interface ArrayAdapterInterface<T> {
+interface ArrayAdapterInterface<T> {
 
-  /**
-   * TAG for logging.
-   */
+  /** TAG for logging. */
   String getTag();
 
-  /**
-   * Return the length of the given array.
-   */
+  /** Return the length of the given array. */
   int getArrayLength(T array);
 
-  /**
-   * Allocate and return an array of the specified size.
-   */
+  /** Allocate and return an array of the specified size. */
   T newArray(int length);
 
-  /**
-   * Return the size of an element in the array in bytes (e.g. for int return 4).
-   */
+  /** Return the size of an element in the array in bytes (e.g. for int return 4). */
   int getElementSizeInBytes();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index bfdb18621..b9a6b8dc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -1,34 +1,53 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-/**
- * Interface for an array pool that pools arrays of different types.
- */
+/** Interface for an array pool that pools arrays of different types. */
 public interface ArrayPool {
   /**
-   * A standard size to use to increase hit rates when the required size isn't defined.
-   * Currently 64KB.
+   * A standard size to use to increase hit rates when the required size isn't defined. Currently
+   * 64KB.
    */
   int STANDARD_BUFFER_SIZE_BYTES = 64 * 1024;
 
   /**
    * Optionally adds the given array of the given type to the pool.
    *
-   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
-   * pool.
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the pool.
+   *
+   * @deprecated Use {@link #put(Object)}
    */
+  @Deprecated
   <T> void put(T array, Class<T> arrayClass);
 
+  /**
+   * Optionally adds the given array of the given type to the pool.
+   *
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the pool.
+   */
+  <T> void put(T array);
+
   /**
    * Returns a non-null array of the given type with a length >= to the given size.
    *
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
    *
    * <p>This class makes no guarantees about the contents of the returned array.
+   *
+   * @see #getExact(int, Class)
    */
   <T> T get(int size, Class<T> arrayClass);
+
   /**
-   * Clears all arrays from the pool.
+   * Returns a non-null array of the given type with a length exactly equal to the given size.
+   *
+   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
+   *
+   * @see #get(int, Class)
    */
+  <T> T getExact(int size, Class<T> arrayClass);
+
+  /** Clears all arrays from the pool. */
   void clearMemory();
 
   /**
@@ -37,5 +56,4 @@
    * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
    */
   void trimMemory(int level);
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index f9448856b..896b13f83 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
@@ -12,6 +13,7 @@
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
 
+  @Override
   public void put(Bitmap bitmap) {
     final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
 
@@ -54,14 +56,15 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   static String getBitmapString(int width, int height, Bitmap.Config config) {
     return "[" + width + "x" + height + "], " + config;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
-    public Key get(int width, int height, Bitmap.Config config) {
+    Key get(int width, int height, Bitmap.Config config) {
       Key result = get();
       result.init(width, height, config);
       return result;
@@ -73,7 +76,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Key implements Poolable {
     private final KeyPool pool;
     private int width;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
index ffdba43d3..ccb085511 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
@@ -7,7 +7,7 @@
   private static final int MAX_SIZE = 20;
   private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);
 
-  protected T get() {
+  T get() {
     T result = keyPool.poll();
     if (result == null) {
       result = create();
@@ -21,5 +21,5 @@ public void offer(T key) {
     }
   }
 
-  protected abstract T create();
+  abstract T create();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
index 3fecc0360..83c449525 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
@@ -1,35 +1,30 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 
-/**
- * An interface for a pool that allows users to reuse {@link android.graphics.Bitmap} objects.
- */
+/** An interface for a pool that allows users to reuse {@link android.graphics.Bitmap} objects. */
 public interface BitmapPool {
 
-  /**
-   * Returns the current maximum size of the pool in bytes.
-   */
-  int getMaxSize();
+  /** Returns the current maximum size of the pool in bytes. */
+  long getMaxSize();
 
   /**
    * Multiplies the initial size of the pool by the given multiplier to dynamically and
    * synchronously allow users to adjust the size of the pool.
    *
-   * <p> If the current total size of the pool is larger than the max size after the given
-   * multiplier is applied, {@link Bitmap}s should be evicted until the pool is smaller than the new
-   * max size. </p>
+   * <p>If the current total size of the pool is larger than the max size after the given multiplier
+   * is applied, {@link Bitmap}s should be evicted until the pool is smaller than the new max size.
    *
    * @param sizeMultiplier The size multiplier to apply between 0 and 1.
    */
   void setSizeMultiplier(float sizeMultiplier);
 
   /**
-   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool
-   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it.
+   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool can
+   * fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it.
    *
-   * <p> Callers must <em>not</em> continue to use the Bitmap after calling this method. </p>
+   * <p>Callers must <em>not</em> continue to use the Bitmap after calling this method.
    *
    * @param bitmap The {@link android.graphics.Bitmap} to attempt to add.
    * @see android.graphics.Bitmap#isMutable()
@@ -41,15 +36,15 @@
    * Returns a {@link android.graphics.Bitmap} of exactly the given width, height, and
    * configuration, and containing only transparent pixels.
    *
-   * <p> If no Bitmap with the requested attributes is present in the pool, a new one will be
-   * allocated. </p>
+   * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be
+   * allocated.
    *
-   * <p> Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower
+   * <p>Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower
    * than {@link #getDirty(int, int, android.graphics.Bitmap.Config)}. If the {@link
    * android.graphics.Bitmap} is being obtained to be used in {@link android.graphics.BitmapFactory}
    * or in any other case where every pixel in the {@link android.graphics.Bitmap} will always be
    * overwritten or cleared, {@link #getDirty(int, int, android.graphics.Bitmap.Config)} will be
-   * faster. When in doubt, use this method to ensure correctness. </p>
+   * faster. When in doubt, use this method to ensure correctness.
    *
    * <pre>
    *     Implementations can should clear out every returned Bitmap using the following:
@@ -59,10 +54,10 @@
    * }
    * </pre>
    *
-   * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
+   * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
    * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
    * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
-   *               android.graphics.Bitmap}.
+   *     android.graphics.Bitmap}.
    * @see #getDirty(int, int, android.graphics.Bitmap.Config)
    */
   @NonNull
@@ -73,35 +68,32 @@
    * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data.
    *
    * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be
-   * allocated. </p>
+   * allocated.
    *
-   * <p> Although this method is slightly more efficient than {@link #get(int, int,
+   * <p>Although this method is slightly more efficient than {@link #get(int, int,
    * android.graphics.Bitmap.Config)} it should be used with caution and only when the caller is
    * sure that they are going to erase the {@link android.graphics.Bitmap} entirely before writing
-   * new data to it. </p>
+   * new data to it.
    *
-   * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
+   * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
    * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
    * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
-   *               android.graphics.Bitmap}.
+   *     android.graphics.Bitmap}.
    * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config
-   * potentially containing random image data or null if no such {@link android.graphics.Bitmap}
-   * could be obtained from the pool.
+   *     potentially containing random image data.
    * @see #get(int, int, android.graphics.Bitmap.Config)
    */
   @NonNull
   Bitmap getDirty(int width, int height, Bitmap.Config config);
 
-  /**
-   * Removes all {@link android.graphics.Bitmap}s from the pool.
-   */
+  /** Removes all {@link android.graphics.Bitmap}s from the pool. */
   void clearMemory();
 
   /**
    * Reduces the size of the cache by evicting items based on the given level.
    *
    * @param level The level from {@link android.content.ComponentCallbacks2} to use to determine how
-   *              many {@link android.graphics.Bitmap}s to evict.
+   *     many {@link android.graphics.Bitmap}s to evict.
    * @see android.content.ComponentCallbacks2
    */
   void trimMemory(int level);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
index af72c1b82..b0dfc41ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 
 /**
  * An {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool BitmapPool} implementation
@@ -10,7 +10,7 @@
  */
 public class BitmapPoolAdapter implements BitmapPool {
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return 0;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
index 95f5ff708..d9a4d0f44 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-/**
- * Adapter for handling primitive byte arrays.
- */
+/** Adapter for handling primitive byte arrays. */
 @SuppressWarnings("PMD.UseVarargs")
 public final class ByteArrayAdapter implements ArrayAdapterInterface<byte[]> {
   private static final String TAG = "ByteArrayPool";
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index d190a475f..e07a793d7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -13,8 +13,8 @@
  * bitmap size, rather than the LRU bitmap object. We can then remove bitmaps from the least
  * recently used size of bitmap when we need to reduce our cache size.
  *
- * For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even if
- * no bitmaps of that size are present. We do not count addition or removal of bitmaps as an
+ * <p>For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even
+ * if no bitmaps of that size are present. We do not count addition or removal of bitmaps as an
  * access.
  */
 class GroupedLinkedMap<K extends Poolable, V> {
@@ -127,11 +127,11 @@ private void makeTail(LinkedEntry<K, V> entry) {
 
     // Used only for the first item in the list which we will treat specially and which will not
     // contain a value.
-    public LinkedEntry() {
+    LinkedEntry() {
       this(null);
     }
 
-    public LinkedEntry(K key) {
+    LinkedEntry(K key) {
       next = prev = this;
       this.key = key;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
index 4fb179c38..f596ce3ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-/**
- * Adapter for handling primitive int arrays.
- */
+/** Adapter for handling primitive int arrays. */
 @SuppressWarnings("PMD.UseVarargs")
 public final class IntegerArrayAdapter implements ArrayAdapterInterface<int[]> {
   private static final String TAG = "IntegerArrayPool";
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
index 6da2cb0e0..874f3b02b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import java.util.HashMap;
@@ -11,18 +11,18 @@
 import java.util.TreeMap;
 
 /**
- * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under
- * the maximum byte size.
+ * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under the
+ * maximum byte size.
  */
 public final class LruArrayPool implements ArrayPool {
   // 4MB.
-  static final int DEFAULT_SIZE = 4 * 1024 * 1024;
+  private static final int DEFAULT_SIZE = 4 * 1024 * 1024;
 
   /**
    * The maximum number of times larger an int array may be to be than a requested size to eligible
    * to be returned from the pool.
    */
-  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  @VisibleForTesting static final int MAX_OVER_SIZE_MULTIPLE = 8;
   /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
   private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
 
@@ -47,8 +47,17 @@ public LruArrayPool(int maxSize) {
     this.maxSize = maxSize;
   }
 
+  @Deprecated
   @Override
-  public synchronized <T> void put(T array, Class<T> arrayClass) {
+  public <T> void put(T array, Class<T> arrayClass) {
+    put(array);
+  }
+
+  @Override
+  public synchronized <T> void put(T array) {
+    @SuppressWarnings("unchecked")
+    Class<T> arrayClass = (Class<T>) array.getClass();
+
     ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
     int size = arrayAdapter.getArrayLength(array);
     int arrayBytes = size * arrayAdapter.getElementSizeInBytes();
@@ -66,35 +75,42 @@ public LruArrayPool(int maxSize) {
   }
 
   @Override
-  public <T> T get(int size, Class<T> arrayClass) {
-    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
-    T result;
-    synchronized (this) {
-      Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
-      final Key key;
-      if (mayFillRequest(size, possibleSize)) {
-        key = keyPool.get(possibleSize, arrayClass);
-      } else {
-        key = keyPool.get(size, arrayClass);
-      }
+  public synchronized <T> T getExact(int size, Class<T> arrayClass) {
+    Key key = keyPool.get(size, arrayClass);
+    return getForKey(key, arrayClass);
+  }
 
-      result = getArrayForKey(key);
-      if (result != null) {
-        currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
-        decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
-      }
+  @Override
+  public synchronized <T> T get(int size, Class<T> arrayClass) {
+    Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
+    final Key key;
+    if (mayFillRequest(size, possibleSize)) {
+      key = keyPool.get(possibleSize, arrayClass);
+    } else {
+      key = keyPool.get(size, arrayClass);
+    }
+    return getForKey(key, arrayClass);
+  }
+
+  private <T> T getForKey(Key key, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    T result = getArrayForKey(key);
+    if (result != null) {
+      currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
     }
 
     if (result == null) {
       if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
-        Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
+        Log.v(arrayAdapter.getTag(), "Allocated " + key.size + " bytes");
       }
-      result = arrayAdapter.newArray(size);
+      result = arrayAdapter.newArray(key.size);
     }
     return result;
   }
 
-  @SuppressWarnings("unchecked")
+  // Our cast is safe because the Key is based on the type.
+  @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
   @Nullable
   private <T> T getArrayForKey(Key key) {
     return (T) groupedMap.get(key);
@@ -122,7 +138,8 @@ public synchronized void clearMemory() {
   public synchronized void trimMemory(int level) {
     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
+        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
       evictToSize(maxSize / 2);
     }
   }
@@ -181,8 +198,8 @@ private void decrementArrayOfSize(int size, Class<?> arrayClass) {
       } else if (arrayPoolClass.equals(byte[].class)) {
         adapter = new ByteArrayAdapter();
       } else {
-          throw new IllegalArgumentException("No array pool found for: "
-              + arrayPoolClass.getSimpleName());
+        throw new IllegalArgumentException(
+            "No array pool found for: " + arrayPoolClass.getSimpleName());
       }
       adapters.put(arrayPoolClass, adapter);
     }
@@ -204,7 +221,7 @@ int getCurrentSize() {
   private static final class KeyPool extends BaseKeyPool<Key> {
 
     @Synthetic
-    KeyPool() { }
+    KeyPool() {}
 
     Key get(int size, Class<?> arrayClass) {
       Key result = get();
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 88150031d..c59959f2f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -5,9 +5,9 @@
 import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.os.Build;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.util.Synthetic;
 import java.util.Arrays;
 import java.util.Collections;
@@ -26,18 +26,18 @@
 
   private final LruPoolStrategy strategy;
   private final Set<Bitmap.Config> allowedConfigs;
-  private final int initialMaxSize;
+  private final long initialMaxSize;
   private final BitmapTracker tracker;
 
-  private int maxSize;
-  private int currentSize;
+  private long maxSize;
+  private long currentSize;
   private int hits;
   private int misses;
   private int puts;
   private int evictions;
 
   // Exposed for testing only.
-  LruBitmapPool(int maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
+  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
     this.initialMaxSize = maxSize;
     this.maxSize = maxSize;
     this.strategy = strategy;
@@ -50,24 +50,25 @@
    *
    * @param maxSize The initial maximum size of the pool in bytes.
    */
-  public LruBitmapPool(int maxSize) {
+  public LruBitmapPool(long maxSize) {
     this(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());
   }
 
   /**
    * Constructor for LruBitmapPool.
    *
-   * @param maxSize        The initial maximum size of the pool in bytes.
+   * @param maxSize The initial maximum size of the pool in bytes.
    * @param allowedConfigs A white listed put of {@link android.graphics.Bitmap.Config} that are
-   *                       allowed to be put into the pool. Configs not in the allowed put will be
-   *                       rejected.
+   *     allowed to be put into the pool. Configs not in the allowed put will be rejected.
    */
-  public LruBitmapPool(int maxSize, Set<Bitmap.Config> allowedConfigs) {
+  // Public API.
+  @SuppressWarnings("unused")
+  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {
     this(maxSize, getDefaultStrategy(), allowedConfigs);
   }
 
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return maxSize;
   }
 
@@ -85,13 +86,19 @@ public synchronized void put(Bitmap bitmap) {
     if (bitmap.isRecycled()) {
       throw new IllegalStateException("Cannot pool recycled bitmap");
     }
-    if (!bitmap.isMutable() || strategy.getSize(bitmap) > maxSize
+    if (!bitmap.isMutable()
+        || strategy.getSize(bitmap) > maxSize
         || !allowedConfigs.contains(bitmap.getConfig())) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Reject bitmap from pool"
-                + ", bitmap: " + strategy.logBitmap(bitmap)
-                + ", is mutable: " + bitmap.isMutable()
-                + ", is allowed config: " + allowedConfigs.contains(bitmap.getConfig()));
+        Log.v(
+            TAG,
+            "Reject bitmap from pool"
+                + ", bitmap: "
+                + strategy.logBitmap(bitmap)
+                + ", is mutable: "
+                + bitmap.isMutable()
+                + ", is allowed config: "
+                + allowedConfigs.contains(bitmap.getConfig()));
       }
       bitmap.recycle();
       return;
@@ -126,7 +133,7 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
       // contents individually, so we do so here. See issue #131.
       result.eraseColor(Color.TRANSPARENT);
     } else {
-      result = Bitmap.createBitmap(width, height, config);
+      result = createBitmap(width, height, config);
     }
 
     return result;
@@ -137,11 +144,16 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
   public Bitmap getDirty(int width, int height, Bitmap.Config config) {
     Bitmap result = getDirtyOrNull(width, height, config);
     if (result == null) {
-      result = Bitmap.createBitmap(width, height, config);
+      result = createBitmap(width, height, config);
     }
     return result;
   }
 
+  @NonNull
+  private static Bitmap createBitmap(int width, int height, @Nullable Bitmap.Config config) {
+    return Bitmap.createBitmap(width, height, config != null ? config : DEFAULT_CONFIG);
+  }
+
   @TargetApi(Build.VERSION_CODES.O)
   private static void assertNotHardwareConfig(Bitmap.Config config) {
     // Avoid short circuiting on sdk int since it breaks on some versions of Android.
@@ -150,14 +162,17 @@ private static void assertNotHardwareConfig(Bitmap.Config config) {
     }
 
     if (config == Bitmap.Config.HARDWARE) {
-      throw new IllegalArgumentException("Cannot create a mutable Bitmap with config: " + config
-          + ". Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your RequestOptions"
-          + " and/or in GlideBuilder.setDefaultRequestOptions");
+      throw new IllegalArgumentException(
+          "Cannot create a mutable Bitmap with config: "
+              + config
+              + ". Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your"
+              + " RequestOptions and/or in GlideBuilder.setDefaultRequestOptions");
     }
   }
 
   @Nullable
-  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {
+  private synchronized Bitmap getDirtyOrNull(
+      int width, int height, @Nullable Bitmap.Config config) {
     assertNotHardwareConfig(config);
     // Config will be null for non public config types, which can lead to transformations naively
     // passing in null as the requested config here. See issue #194.
@@ -211,12 +226,13 @@ public void trimMemory(int level) {
     }
     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
-      trimToSize(maxSize / 2);
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
+        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
+      trimToSize(getMaxSize() / 2);
     }
   }
 
-  private synchronized void trimToSize(int size) {
+  private synchronized void trimToSize(long size) {
     while (currentSize > size) {
       final Bitmap removed = strategy.removeLast();
       // TODO: This shouldn't ever happen, see #331.
@@ -246,8 +262,22 @@ private void dump() {
   }
 
   private void dumpUnchecked() {
-    Log.v(TAG, "Hits=" + hits + ", misses=" + misses + ", puts=" + puts + ", evictions=" + evictions
-        + ", currentSize=" + currentSize + ", maxSize=" + maxSize + "\nStrategy=" + strategy);
+    Log.v(
+        TAG,
+        "Hits="
+            + hits
+            + ", misses="
+            + misses
+            + ", puts="
+            + puts
+            + ", evictions="
+            + evictions
+            + ", currentSize="
+            + currentSize
+            + ", maxSize="
+            + maxSize
+            + "\nStrategy="
+            + strategy);
   }
 
   private static LruPoolStrategy getDefaultStrategy() {
@@ -262,8 +292,7 @@ private static LruPoolStrategy getDefaultStrategy() {
 
   @TargetApi(Build.VERSION_CODES.O)
   private static Set<Bitmap.Config> getDefaultAllowedConfigs() {
-    Set<Bitmap.Config> configs = new HashSet<>();
-    configs.addAll(Arrays.asList(Bitmap.Config.values()));
+    Set<Bitmap.Config> configs = new HashSet<>(Arrays.asList(Bitmap.Config.values()));
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java
       // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured
@@ -291,8 +320,13 @@ private static LruPoolStrategy getDefaultStrategy() {
     public void add(Bitmap bitmap) {
       if (bitmaps.contains(bitmap)) {
         throw new IllegalStateException(
-            "Can't add already added bitmap: " + bitmap + " [" + bitmap.getWidth() + "x" + bitmap
-                .getHeight() + "]");
+            "Can't add already added bitmap: "
+                + bitmap
+                + " ["
+                + bitmap.getWidth()
+                + "x"
+                + bitmap.getHeight()
+                + "]");
       }
       bitmaps.add(bitmap);
     }
@@ -306,10 +340,10 @@ public void remove(Bitmap bitmap) {
     }
   }
 
-  private static class NullBitmapTracker implements BitmapTracker {
+  private static final class NullBitmapTracker implements BitmapTracker {
 
     @Synthetic
-    NullBitmapTracker() { }
+    NullBitmapTracker() {}
 
     @Override
     public void add(Bitmap bitmap) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
index 376dd9665..375f8d359 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 interface LruPoolStrategy {
   void put(Bitmap bitmap);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
index 5d4176f3c..220d3beff 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
@@ -2,6 +2,8 @@
 
 import java.util.TreeMap;
 
+// Never serialized.
+@SuppressWarnings("serial")
 class PrettyPrintTreeMap<K, V> extends TreeMap<K, V> {
   @Override
   public String toString() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index 05964ba05..992d41ddf 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -1,44 +1,59 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.os.Build;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.TreeMap;
 
 /**
- * Keys {@link android.graphics.Bitmap Bitmaps} using both
- * {@link android.graphics.Bitmap#getAllocationByteCount()} and the
- * {@link android.graphics.Bitmap.Config} returned from
- * {@link android.graphics.Bitmap#getConfig()}.
+ * Keys {@link android.graphics.Bitmap Bitmaps} using both {@link
+ * android.graphics.Bitmap#getAllocationByteCount()} and the {@link android.graphics.Bitmap.Config}
+ * returned from {@link android.graphics.Bitmap#getConfig()}.
  *
- * <p> Using both the config and the byte size allows us to safely re-use a greater variety of
- * {@link android.graphics.Bitmap Bitmaps}, which increases the hit rate of the pool and therefore
- * the performance of applications. This class works around #301 by only allowing re-use of
- * {@link android.graphics.Bitmap Bitmaps} with a matching number of bytes per pixel. </p>
+ * <p>Using both the config and the byte size allows us to safely re-use a greater variety of {@link
+ * android.graphics.Bitmap Bitmaps}, which increases the hit rate of the pool and therefore the
+ * performance of applications. This class works around #301 by only allowing re-use of {@link
+ * android.graphics.Bitmap Bitmaps} with a matching number of bytes per pixel.
  */
-@TargetApi(Build.VERSION_CODES.KITKAT)
+@RequiresApi(Build.VERSION_CODES.KITKAT)
 public class SizeConfigStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
-  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS =
-      new Bitmap.Config[] {
+
+  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS;
+
+  static {
+    Bitmap.Config[] result =
+        new Bitmap.Config[] {
           Bitmap.Config.ARGB_8888,
           // The value returned by Bitmaps with the hidden Bitmap config.
           null,
-      };
+        };
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      result = Arrays.copyOf(result, result.length + 1);
+      result[result.length - 1] = Config.RGBA_F16;
+    }
+    ARGB_8888_IN_CONFIGS = result;
+  }
+
+  private static final Bitmap.Config[] RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS;
+
   // We probably could allow ARGB_4444 and RGB_565 to decode into each other, but ARGB_4444 is
   // deprecated and we'd rather be safe.
   private static final Bitmap.Config[] RGB_565_IN_CONFIGS =
-      new Bitmap.Config[] { Bitmap.Config.RGB_565 };
+      new Bitmap.Config[] {Bitmap.Config.RGB_565};
   private static final Bitmap.Config[] ARGB_4444_IN_CONFIGS =
-      new Bitmap.Config[] { Bitmap.Config.ARGB_4444 };
+      new Bitmap.Config[] {Bitmap.Config.ARGB_4444};
   private static final Bitmap.Config[] ALPHA_8_IN_CONFIGS =
-      new Bitmap.Config[] { Bitmap.Config.ALPHA_8 };
+      new Bitmap.Config[] {Bitmap.Config.ALPHA_8};
 
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
@@ -66,8 +81,7 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
     if (result != null) {
       // Decrement must be called before reconfigure.
       decrementBitmapOfSize(bestKey.size, result);
-      result.reconfigure(width, height,
-          result.getConfig() != null ? result.getConfig() : Bitmap.Config.ARGB_8888);
+      result.reconfigure(width, height, config);
     }
     return result;
   }
@@ -105,10 +119,14 @@ private void decrementBitmapOfSize(Integer size, Bitmap removed) {
     NavigableMap<Integer, Integer> sizes = getSizesForConfig(config);
     Integer current = sizes.get(size);
     if (current == null) {
-      throw new NullPointerException("Tried to decrement empty size"
-          + ", size: " + size
-          + ", removed: " + logBitmap(removed)
-          + ", this: " + this);
+      throw new NullPointerException(
+          "Tried to decrement empty size"
+              + ", size: "
+              + size
+              + ", removed: "
+              + logBitmap(removed)
+              + ", this: "
+              + this);
     }
 
     if (current == 1) {
@@ -160,7 +178,7 @@ public String toString() {
     return sb.append(")}").toString();
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
     public Key get(int size, Bitmap.Config config) {
@@ -175,7 +193,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
 
@@ -186,7 +204,7 @@ public Key(KeyPool pool) {
       this.pool = pool;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Key(KeyPool pool, int size, Bitmap.Config config) {
       this(pool);
       init(size, config);
@@ -211,8 +229,7 @@ public String toString() {
     public boolean equals(Object o) {
       if (o instanceof Key) {
         Key other = (Key) o;
-        return size == other.size
-            && Util.bothNullOrEqual(config, other.config);
+        return size == other.size && Util.bothNullOrEqual(config, other.config);
       }
       return false;
     }
@@ -231,6 +248,12 @@ static String getBitmapString(int size, Bitmap.Config config) {
   }
 
   private static Bitmap.Config[] getInConfigs(Bitmap.Config requested) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      if (Bitmap.Config.RGBA_F16.equals(requested)) { // NOPMD - Avoid short circuiting sdk checks.
+        return RGBA_F16_IN_CONFIGS;
+      }
+    }
+
     switch (requested) {
       case ARGB_8888:
         return ARGB_8888_IN_CONFIGS;
@@ -241,7 +264,7 @@ static String getBitmapString(int size, Bitmap.Config config) {
       case ALPHA_8:
         return ALPHA_8_IN_CONFIGS;
       default:
-        return new Bitmap.Config[] { requested };
+        return new Bitmap.Config[] {requested};
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index 205ec7e4f..7987f507d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -1,25 +1,26 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-import java.util.TreeMap;
+import java.util.NavigableMap;
 
 /**
- * A strategy for reusing bitmaps that relies on
- * {@link Bitmap#reconfigure(int, int, Bitmap.Config)}.
+ * A strategy for reusing bitmaps that relies on {@link Bitmap#reconfigure(int, int,
+ * Bitmap.Config)}.
  *
- * <p> Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher. </p>
+ * <p>Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher.
  */
-@TargetApi(Build.VERSION_CODES.KITKAT)
-class SizeStrategy implements LruPoolStrategy {
+@RequiresApi(Build.VERSION_CODES.KITKAT)
+final class SizeStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
-  private final TreeMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
+  private final NavigableMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
 
   @Override
   public void put(Bitmap bitmap) {
@@ -106,11 +107,12 @@ static String getBitmapString(int size) {
     return "[" + size + "]";
   }
 
-  // Visible for testing.
+  // Non-final for mocking.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
     public Key get(int size) {
-      Key result = get();
+      Key result = super.get();
       result.init(size);
       return result;
     }
@@ -121,7 +123,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
     @Synthetic int size;
@@ -148,6 +150,8 @@ public int hashCode() {
       return size;
     }
 
+    // PMD.AccessorMethodGeneration: https://github.com/pmd/pmd/issues/807
+    @SuppressWarnings("PMD.AccessorMethodGeneration")
     @Override
     public String toString() {
       return getBitmapString(size);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index 31cdcf025..5358374b6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -1,33 +1,26 @@
 package com.bumptech.glide.load.engine.cache;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import java.io.File;
 
-/**
- * An interface for writing to and reading from a disk cache.
- */
+/** An interface for writing to and reading from a disk cache. */
 public interface DiskCache {
 
-  /**
-   * An interface for lazily creating a disk cache.
-   */
+  /** An interface for lazily creating a disk cache. */
   interface Factory {
+    /** 250 MB of cache. */
+    int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
 
-      /** 250 MB of cache. */
-      int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
-      String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
+    String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
 
-      /**
-       * Returns a new disk cache, or {@code null} if no disk cache could be created.
-       */
-      @Nullable
-      DiskCache build();
+    /** Returns a new disk cache, or {@code null} if no disk cache could be created. */
+    @Nullable
+    DiskCache build();
   }
 
-  /**
-   * An interface to actually write data to a key in the disk cache.
-   */
+  /** An interface to actually write data to a key in the disk cache. */
   interface Writer {
     /**
      * Writes data to the file and returns true if the write was successful and should be committed,
@@ -35,14 +28,14 @@
      *
      * @param file The File the Writer should write to.
      */
-    boolean write(File file);
+    boolean write(@NonNull File file);
   }
 
   /**
    * Get the cache for the value at the given key.
    *
-   * <p> Note - This is potentially dangerous, someone may write a new value to the file at any
-   * point in time and we won't know about it. </p>
+   * <p>Note - This is potentially dangerous, someone may write a new value to the file at any point
+   * in time and we won't know about it.
    *
    * @param key The key in the cache.
    * @return An InputStream representing the data at key at the time get is called.
@@ -54,7 +47,7 @@
    * Write to a key in the cache. {@link Writer} is used so that the cache implementation can
    * perform actions after the write finishes, like commit (via atomic file rename).
    *
-   * @param key    The key to write to.
+   * @param key The key to write to.
    * @param writer An interface that will write data given an OutputStream for the key.
    */
   void put(Key key, Writer writer);
@@ -64,10 +57,10 @@
    *
    * @param key The key to remove.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   void delete(Key key);
 
-  /**
-   * Clear the cache.
-   */
+  /** Clear the cache. */
   void clear();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
index d551af16a..573544217 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.load.Key;
 import java.io.File;
 
-/**
- * A simple class that returns null for all gets and ignores all writes.
- */
+/** A simple class that returns null for all gets and ignores all writes. */
 public class DiskCacheAdapter implements DiskCache {
   @Override
   public File get(Key key) {
@@ -25,6 +23,14 @@ public void delete(Key key) {
 
   @Override
   public void clear() {
-      // no op, default for overriders
+    // no op, default for overriders
+  }
+
+  /** Default factory for {@link DiskCacheAdapter}. */
+  public static final class Factory implements DiskCache.Factory {
+    @Override
+    public DiskCache build() {
+      return new DiskCacheAdapter();
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
index d11f0f02a..960252b2f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -13,9 +13,9 @@
  * Keeps a map of keys to locks that allows locks to be removed from the map when no longer in use
  * so the size of the collection is bounded.
  *
- * <p> This class will be accessed by multiple threads in a thread pool and ensures that the
- *  number of threads interested in each lock is updated atomically so that when the count reaches
- *  0, the lock can safely be removed from the map. </p>
+ * <p>This class will be accessed by multiple threads in a thread pool and ensures that the number
+ * of threads interested in each lock is updated atomically so that when the count reaches 0, the
+ * lock can safely be removed from the map.
  */
 final class DiskCacheWriteLocker {
   private final Map<String, WriteLock> locks = new HashMap<>();
@@ -40,19 +40,26 @@ void release(String safeKey) {
     synchronized (this) {
       writeLock = Preconditions.checkNotNull(locks.get(safeKey));
       if (writeLock.interestedThreads < 1) {
-        throw new IllegalStateException("Cannot release a lock that is not held"
-            + ", safeKey: " + safeKey
-            + ", interestedThreads: " + writeLock.interestedThreads);
+        throw new IllegalStateException(
+            "Cannot release a lock that is not held"
+                + ", safeKey: "
+                + safeKey
+                + ", interestedThreads: "
+                + writeLock.interestedThreads);
       }
 
       writeLock.interestedThreads--;
       if (writeLock.interestedThreads == 0) {
         WriteLock removed = locks.remove(safeKey);
         if (!removed.equals(writeLock)) {
-          throw new IllegalStateException("Removed the wrong lock"
-              + ", expected to remove: " + writeLock
-              + ", but actually removed: " + removed
-              + ", safeKey: " + safeKey);
+          throw new IllegalStateException(
+              "Removed the wrong lock"
+                  + ", expected to remove: "
+                  + writeLock
+                  + ", but actually removed: "
+                  + removed
+                  + ", safeKey: "
+                  + safeKey);
         }
         writeLockPool.offer(removed);
       }
@@ -61,12 +68,12 @@ void release(String safeKey) {
     writeLock.lock.unlock();
   }
 
-  private static class WriteLock  {
+  private static class WriteLock {
     final Lock lock = new ReentrantLock();
     int interestedThreads;
 
     @Synthetic
-    WriteLock() { }
+    WriteLock() {}
   }
 
   private static class WriteLockPool {
@@ -74,7 +81,7 @@ void release(String safeKey) {
     private final Queue<WriteLock> pool = new ArrayDeque<>();
 
     @Synthetic
-    WriteLockPool() { }
+    WriteLockPool() {}
 
     WriteLock obtain() {
       WriteLock result;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
index f24fa6dd2..03a783481 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
@@ -7,36 +7,40 @@
  * disk cache directory.
  *
  * <p>If you need to make I/O access before returning the cache directory use the {@link
- * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, int)} constructor variant.
+ * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)} constructor variant.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class DiskLruCacheFactory implements DiskCache.Factory {
-  private final int diskCacheSize;
+  private final long diskCacheSize;
   private final CacheDirectoryGetter cacheDirectoryGetter;
 
-  /**
-   * Interface called out of UI thread to get the cache folder.
-   */
+  /** Interface called out of UI thread to get the cache folder. */
   public interface CacheDirectoryGetter {
     File getCacheDirectory();
   }
 
-  public DiskLruCacheFactory(final String diskCacheFolder, int diskCacheSize) {
-    this(new CacheDirectoryGetter() {
-      @Override
-      public File getCacheDirectory() {
-        return new File(diskCacheFolder);
-      }
-    }, diskCacheSize);
+  public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {
+    this(
+        new CacheDirectoryGetter() {
+          @Override
+          public File getCacheDirectory() {
+            return new File(diskCacheFolder);
+          }
+        },
+        diskCacheSize);
   }
 
-  public DiskLruCacheFactory(final String diskCacheFolder, final String diskCacheName,
-      int diskCacheSize) {
-    this(new CacheDirectoryGetter() {
-      @Override
-      public File getCacheDirectory() {
-        return new File(diskCacheFolder, diskCacheName);
-      }
-    }, diskCacheSize);
+  public DiskLruCacheFactory(
+      final String diskCacheFolder, final String diskCacheName, long diskCacheSize) {
+    this(
+        new CacheDirectoryGetter() {
+          @Override
+          public File getCacheDirectory() {
+            return new File(diskCacheFolder, diskCacheName);
+          }
+        },
+        diskCacheSize);
   }
 
   /**
@@ -44,9 +48,11 @@ public File getCacheDirectory() {
    * of UI thread, allowing to do I/O access without performance impacts.
    *
    * @param cacheDirectoryGetter Interface called out of UI thread to get the cache folder.
-   * @param diskCacheSize        Desired max bytes size for the LRU disk cache.
+   * @param diskCacheSize Desired max bytes size for the LRU disk cache.
    */
-  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, int diskCacheSize) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, long diskCacheSize) {
     this.diskCacheSize = diskCacheSize;
     this.cacheDirectoryGetter = cacheDirectoryGetter;
   }
@@ -63,6 +69,6 @@ public DiskCache build() {
       return null;
     }
 
-    return DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
+    return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 8cd104d02..516bee1f0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -15,18 +15,18 @@
  * The default DiskCache implementation. There must be no more than one active instance for a given
  * directory at a time.
  *
- * @see #get(java.io.File, int)
+ * @see #get(java.io.File, long)
  */
 public class DiskLruCacheWrapper implements DiskCache {
   private static final String TAG = "DiskLruCacheWrapper";
 
   private static final int APP_VERSION = 1;
   private static final int VALUE_COUNT = 1;
-  private static DiskLruCacheWrapper wrapper = null;
+  private static DiskLruCacheWrapper wrapper;
 
   private final SafeKeyGenerator safeKeyGenerator;
   private final File directory;
-  private final int maxSize;
+  private final long maxSize;
   private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
   private DiskLruCache diskLruCache;
 
@@ -36,10 +36,13 @@
    * ignored.
    *
    * @param directory The directory for the disk cache
-   * @param maxSize   The max size for the disk cache
+   * @param maxSize The max size for the disk cache
    * @return The new disk cache with the given arguments, or the current cache if one already exists
+   * @deprecated Use {@link #create(File, long)} to create a new cache with the specified arguments.
    */
-  public static synchronized DiskCache get(File directory, int maxSize) {
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public static synchronized DiskCache get(File directory, long maxSize) {
     // TODO calling twice with different arguments makes it return the cache for the same
     // directory, it's public!
     if (wrapper == null) {
@@ -48,7 +51,23 @@ public static synchronized DiskCache get(File directory, int maxSize) {
     return wrapper;
   }
 
-  protected DiskLruCacheWrapper(File directory, int maxSize) {
+  /**
+   * Create a new DiskCache in the given directory with a specified max size.
+   *
+   * @param directory The directory for the disk cache
+   * @param maxSize The max size for the disk cache
+   * @return The new disk cache with the given arguments
+   */
+  @SuppressWarnings("deprecation")
+  public static DiskCache create(File directory, long maxSize) {
+    return new DiskLruCacheWrapper(directory, maxSize);
+  }
+
+  /** @deprecated Do not extend this class. */
+  @Deprecated
+  // Deprecated public API.
+  @SuppressWarnings({"WeakerAccess", "DeprecatedIsStillUsed"})
+  protected DiskLruCacheWrapper(File directory, long maxSize) {
     this.directory = directory;
     this.maxSize = maxSize;
     this.safeKeyGenerator = new SafeKeyGenerator();
@@ -141,11 +160,15 @@ public void delete(Key key) {
   public synchronized void clear() {
     try {
       getDiskCache().delete();
-      resetDiskCache();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Unable to clear disk cache", e);
+        Log.w(TAG, "Unable to clear disk cache or disk cache cleared externally", e);
       }
+    } finally {
+      // Delete can close the cache but still throw. If we don't null out the disk cache here, every
+      // subsequent request will try to act on a closed disk cache and fail. By nulling out the disk
+      // cache we at least allow for attempts to open the cache in the future. See #2465.
+      resetDiskCache();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
index 9780364bf..606b14857 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
@@ -11,11 +11,15 @@
  *
  * @deprecated use {@link ExternalPreferredCacheDiskCacheFactory} instead.
  */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
 @Deprecated
 public final class ExternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public ExternalCacheDiskCacheFactory(Context context) {
-    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+    this(
+        context,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
@@ -23,20 +27,22 @@ public ExternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
-  public ExternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
-      int diskCacheSize) {
-    super(new CacheDirectoryGetter() {
-      @Override
-      public File getCacheDirectory() {
-        File cacheDirectory = context.getExternalCacheDir();
-        if (cacheDirectory == null) {
-          return null;
-        }
-        if (diskCacheName != null) {
-          return new File(cacheDirectory, diskCacheName);
-        }
-        return cacheDirectory;
-      }
-    }, diskCacheSize);
+  public ExternalCacheDiskCacheFactory(
+      final Context context, final String diskCacheName, int diskCacheSize) {
+    super(
+        new CacheDirectoryGetter() {
+          @Override
+          public File getCacheDirectory() {
+            File cacheDirectory = context.getExternalCacheDir();
+            if (cacheDirectory == null) {
+              return null;
+            }
+            if (diskCacheName != null) {
+              return new File(cacheDirectory, diskCacheName);
+            }
+            return cacheDirectory;
+          }
+        },
+        diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
index 1b0e17747..1ac0a8220 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.content.Context;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import java.io.File;
 
 /**
@@ -11,53 +11,59 @@
  *
  * <p><b>Images can be read by everyone when using external disk cache.</b>
  */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
 public final class ExternalPreferredCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public ExternalPreferredCacheDiskCacheFactory(Context context) {
-    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+    this(
+        context,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
-  public ExternalPreferredCacheDiskCacheFactory(Context context, int diskCacheSize) {
+  public ExternalPreferredCacheDiskCacheFactory(Context context, long diskCacheSize) {
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
-  public ExternalPreferredCacheDiskCacheFactory(final Context context, final String diskCacheName,
-                                                final int diskCacheSize) {
-    super(new CacheDirectoryGetter() {
-      @Nullable
-      private File getInternalCacheDirectory() {
-        File cacheDirectory = context.getCacheDir();
-        if (cacheDirectory == null) {
-          return null;
-        }
-        if (diskCacheName != null) {
-          return new File(cacheDirectory, diskCacheName);
-        }
-        return cacheDirectory;
-      }
-
-      @Override
-      public File getCacheDirectory() {
-        File internalCacheDirectory = getInternalCacheDirectory();
-
-        // Already used internal cache, so keep using that one,
-        // thus avoiding using both external and internal with transient errors.
-        if ((null != internalCacheDirectory) && internalCacheDirectory.exists()) {
-          return internalCacheDirectory;
-        }
-
-        File cacheDirectory = context.getExternalCacheDir();
-
-        // Shared storage is not available.
-        if (cacheDirectory == null) {
-          return internalCacheDirectory;
-        }
-        if (diskCacheName != null) {
-          return new File(cacheDirectory, diskCacheName);
-        }
-        return cacheDirectory;
-      }
-    }, diskCacheSize);
+  public ExternalPreferredCacheDiskCacheFactory(
+      final Context context, final String diskCacheName, final long diskCacheSize) {
+    super(
+        new CacheDirectoryGetter() {
+          @Nullable
+          private File getInternalCacheDirectory() {
+            File cacheDirectory = context.getCacheDir();
+            if (cacheDirectory == null) {
+              return null;
+            }
+            if (diskCacheName != null) {
+              return new File(cacheDirectory, diskCacheName);
+            }
+            return cacheDirectory;
+          }
+
+          @Override
+          public File getCacheDirectory() {
+            File internalCacheDirectory = getInternalCacheDirectory();
+
+            // Already used internal cache, so keep using that one,
+            // thus avoiding using both external and internal with transient errors.
+            if ((null != internalCacheDirectory) && internalCacheDirectory.exists()) {
+              return internalCacheDirectory;
+            }
+
+            File cacheDirectory = context.getExternalCacheDir();
+
+            // Shared storage is not available.
+            if ((cacheDirectory == null) || (!cacheDirectory.canWrite())) {
+              return internalCacheDirectory;
+            }
+            if (diskCacheName != null) {
+              return new File(cacheDirectory, diskCacheName);
+            }
+            return cacheDirectory;
+          }
+        },
+        diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
index 225743b89..3fec19c99 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -7,31 +7,37 @@
  * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the internal
  * disk cache directory.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public InternalCacheDiskCacheFactory(Context context) {
-    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+    this(
+        context,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
-  public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
+  public InternalCacheDiskCacheFactory(Context context, long diskCacheSize) {
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
-  public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
-      int diskCacheSize) {
-    super(new CacheDirectoryGetter() {
-      @Override
-      public File getCacheDirectory() {
-        File cacheDirectory = context.getCacheDir();
-        if (cacheDirectory == null) {
-          return null;
-        }
-        if (diskCacheName != null) {
-          return new File(cacheDirectory, diskCacheName);
-        }
-        return cacheDirectory;
-      }
-    }, diskCacheSize);
+  public InternalCacheDiskCacheFactory(
+      final Context context, final String diskCacheName, long diskCacheSize) {
+    super(
+        new CacheDirectoryGetter() {
+          @Override
+          public File getCacheDirectory() {
+            File cacheDirectory = context.getCacheDir();
+            if (cacheDirectory == null) {
+              return null;
+            }
+            if (diskCacheName != null) {
+              return new File(cacheDirectory, diskCacheName);
+            }
+            return cacheDirectory;
+          }
+        },
+        diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 44071a869..8d052c4ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.annotation.SuppressLint;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
 
-/**
- * An LRU in memory cache for {@link com.bumptech.glide.load.engine.Resource}s.
- */
+/** An LRU in memory cache for {@link com.bumptech.glide.load.engine.Resource}s. */
 public class LruResourceCache extends LruCache<Key, Resource<?>> implements MemoryCache {
   private ResourceRemovedListener listener;
 
@@ -16,38 +16,44 @@
    *
    * @param size The maximum size in bytes the in memory cache can use.
    */
-  public LruResourceCache(int size) {
+  public LruResourceCache(long size) {
     super(size);
   }
 
   @Override
-  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
     this.listener = listener;
   }
 
   @Override
-  protected void onItemEvicted(Key key, Resource<?> item) {
-    if (listener != null) {
+  protected void onItemEvicted(@NonNull Key key, @Nullable Resource<?> item) {
+    if (listener != null && item != null) {
       listener.onResourceRemoved(item);
     }
   }
 
   @Override
-  protected int getSize(Resource<?> item) {
-    return item.getSize();
+  protected int getSize(@Nullable Resource<?> item) {
+    if (item == null) {
+      return super.getSize(null);
+    } else {
+      return item.getSize();
+    }
   }
 
   @SuppressLint("InlinedApi")
   @Override
   public void trimMemory(int level) {
     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
-      // Nearing middle of list of cached background apps
+      // Entering list of cached background apps
       // Evict our entire bitmap cache
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
-      // Entering list of cached background apps
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
+        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
+      // The app's UI is no longer visible, or app is in the foreground but system is running
+      // critically low on memory
       // Evict oldest half of our bitmap cache
-      trimToSize(getCurrentSize() / 2);
+      trimToSize(getMaxSize() / 2);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index 3cf56d4c5..f48f4c4f2 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -1,36 +1,29 @@
 package com.bumptech.glide.load.engine.cache;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
-/**
- * An interface for adding and removing resources from an in memory cache.
- */
+/** An interface for adding and removing resources from an in memory cache. */
 public interface MemoryCache {
-  /**
-   * An interface that will be called whenever a bitmap is removed from the cache.
-   */
+  /** An interface that will be called whenever a bitmap is removed from the cache. */
   interface ResourceRemovedListener {
-    void onResourceRemoved(Resource<?> removed);
+    void onResourceRemoved(@NonNull Resource<?> removed);
   }
 
-  /**
-   * Returns the sum of the sizes of all the contents of the cache in bytes.
-   */
-  int getCurrentSize();
+  /** Returns the sum of the sizes of all the contents of the cache in bytes. */
+  long getCurrentSize();
 
-  /**
-   * Returns the current maximum size in bytes of the cache.
-   */
-  int getMaxSize();
+  /** Returns the current maximum size in bytes of the cache. */
+  long getMaxSize();
 
   /**
    * Adjust the maximum size of the cache by multiplying the original size of the cache by the given
    * multiplier.
    *
-   * <p> If the size multiplier causes the size of the cache to be decreased, items will be evicted
-   * until the cache is smaller than the new size. </p>
+   * <p>If the size multiplier causes the size of the cache to be decreased, items will be evicted
+   * until the cache is smaller than the new size.
    *
    * @param multiplier A size multiplier >= 0.
    */
@@ -42,35 +35,33 @@
    * @param key The key.
    */
   @Nullable
-  Resource<?> remove(Key key);
+  Resource<?> remove(@NonNull Key key);
 
   /**
    * Add bitmap to the cache with the given key.
    *
-   * @param key      The key to retrieve the bitmap.
+   * @param key The key to retrieve the bitmap.
    * @param resource The {@link com.bumptech.glide.load.engine.EngineResource} to store.
    * @return The old value of key (null if key is not in map).
    */
   @Nullable
-  Resource<?> put(Key key, Resource<?> resource);
+  Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource);
 
   /**
    * Set the listener to be called when a bitmap is removed from the cache.
    *
    * @param listener The listener.
    */
-  void setResourceRemovedListener(ResourceRemovedListener listener);
+  void setResourceRemovedListener(@NonNull ResourceRemovedListener listener);
 
-  /**
-   * Evict all items from the memory cache.
-   */
+  /** Evict all items from the memory cache. */
   void clearMemory();
 
   /**
    * Trim the memory cache to the appropriate level. Typically called on the callback onTrimMemory.
    *
    * @param level This integer represents a trim level as specified in {@link
-   *              android.content.ComponentCallbacks2}.
+   *     android.content.ComponentCallbacks2}.
    */
   void trimMemory(int level);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
index e2f92de07..d19c73ed1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
@@ -1,22 +1,22 @@
 package com.bumptech.glide.load.engine.cache;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
-/**
- * A simple class that ignores all puts and returns null for all gets.
- */
+/** A simple class that ignores all puts and returns null for all gets. */
 public class MemoryCacheAdapter implements MemoryCache {
 
   private ResourceRemovedListener listener;
 
   @Override
-  public int getCurrentSize() {
+  public long getCurrentSize() {
     return 0;
   }
 
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return 0;
   }
 
@@ -25,19 +25,23 @@ public void setSizeMultiplier(float multiplier) {
     // Do nothing.
   }
 
+  @Nullable
   @Override
-  public Resource<?> remove(Key key) {
+  public Resource<?> remove(@NonNull Key key) {
     return null;
   }
 
+  @Nullable
   @Override
-  public Resource<?> put(Key key, Resource<?> resource) {
-    listener.onResourceRemoved(resource);
+  public Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource) {
+    if (resource != null) {
+      listener.onResourceRemoved(resource);
+    }
     return null;
   }
 
   @Override
-  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
     this.listener = listener;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 4489744e2..278376578 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -1,12 +1,15 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
 import android.text.format.Formatter;
 import android.util.DisplayMetrics;
 import android.util.Log;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A calculator that tries to intelligently determine cache sizes for a given device based on some
@@ -14,9 +17,8 @@
  */
 public final class MemorySizeCalculator {
   private static final String TAG = "MemorySizeCalculator";
-  // Visible for testing.
-  static final int BYTES_PER_ARGB_8888_PIXEL = 4;
-  static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
+  @VisibleForTesting static final int BYTES_PER_ARGB_8888_PIXEL = 4;
+  private static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
 
   private final int bitmapPoolSize;
   private final int memoryCacheSize;
@@ -25,6 +27,7 @@
 
   interface ScreenDimensions {
     int getWidthPixels();
+
     int getHeightPixels();
   }
 
@@ -79,46 +82,43 @@
     }
   }
 
-  /**
-   * Returns the recommended memory cache size for the device it is run on in bytes.
-   */
+  /** Returns the recommended memory cache size for the device it is run on in bytes. */
   public int getMemoryCacheSize() {
     return memoryCacheSize;
   }
 
-  /**
-   * Returns the recommended bitmap pool size for the device it is run on in bytes.
-   */
+  /** Returns the recommended bitmap pool size for the device it is run on in bytes. */
   public int getBitmapPoolSize() {
     return bitmapPoolSize;
   }
 
-  /**
-   * Returns the recommended array pool size for the device it is run on in bytes.
-   */
+  /** Returns the recommended array pool size for the device it is run on in bytes. */
   public int getArrayPoolSizeInBytes() {
     return arrayPoolSize;
   }
 
-  private static int getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,
-      float lowMemoryMaxSizeMultiplier) {
+  private static int getMaxSize(
+      ActivityManager activityManager, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
     final int memoryClassBytes = activityManager.getMemoryClass() * 1024 * 1024;
     final boolean isLowMemoryDevice = isLowMemoryDevice(activityManager);
-    return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier
-        : maxSizeMultiplier));
+    return Math.round(
+        memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier : maxSizeMultiplier));
   }
 
   private String toMb(int bytes) {
     return Formatter.formatFileSize(context, bytes);
   }
 
-  private static boolean isLowMemoryDevice(ActivityManager activityManager) {
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  @Synthetic
+  static boolean isLowMemoryDevice(ActivityManager activityManager) {
     // Explicitly check with an if statement, on some devices both parts of boolean expressions
     // can be evaluated even if we'd normally expect a short circuit.
+    //noinspection SimplifiableIfStatement
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return activityManager.isLowRamDevice();
     } else {
-      return false;
+      return true;
     }
   }
 
@@ -126,9 +126,10 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
    * Constructs an {@link MemorySizeCalculator} with reasonable defaults that can be optionally
    * overridden.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
   public static final class Builder {
-    // Visible for testing.
-    static final int MEMORY_CACHE_TARGET_SCREENS = 2;
+    @VisibleForTesting static final int MEMORY_CACHE_TARGET_SCREENS = 2;
 
     /**
      * On Android O+, we use {@link android.graphics.Bitmap.Config#HARDWARE} for all reasonably
@@ -143,22 +144,21 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
     // 4MB.
     static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
-    private final Context context;
+    @Synthetic final Context context;
 
-    // Modifiable for testing.
-    private ActivityManager activityManager;
-    private ScreenDimensions screenDimensions;
+    // Modifiable (non-final) for testing.
+    @Synthetic ActivityManager activityManager;
+    @Synthetic ScreenDimensions screenDimensions;
 
-    private float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
-    private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
-    private float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
-    private float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
-    private int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
+    @Synthetic float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
+    @Synthetic float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
+    @Synthetic float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
+    @Synthetic float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
+    @Synthetic int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
 
     public Builder(Context context) {
       this.context = context;
-      activityManager =
-          (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+      activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
       screenDimensions =
           new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics());
 
@@ -172,37 +172,38 @@ public Builder(Context context) {
     }
 
     /**
-     * Sets the number of device screens worth of pixels the
-     * {@link com.bumptech.glide.load.engine.cache.MemoryCache} should be able to hold and
-     * returns this Builder.
+     * Sets the number of device screens worth of pixels the {@link
+     * com.bumptech.glide.load.engine.cache.MemoryCache} should be able to hold and returns this
+     * Builder.
      */
     public Builder setMemoryCacheScreens(float memoryCacheScreens) {
-      Preconditions.checkArgument(bitmapPoolScreens >= 0,
-          "Memory cache screens must be greater than or equal to 0");
+      Preconditions.checkArgument(
+          memoryCacheScreens >= 0, "Memory cache screens must be greater than or equal to 0");
       this.memoryCacheScreens = memoryCacheScreens;
       return this;
     }
 
     /**
-     * Sets the number of device screens worth of pixels the
-     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} should be able to hold and
-     * returns this Builder.
+     * Sets the number of device screens worth of pixels the {@link
+     * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} should be able to hold and returns
+     * this Builder.
      */
     public Builder setBitmapPoolScreens(float bitmapPoolScreens) {
-      Preconditions.checkArgument(bitmapPoolScreens >= 0,
-          "Bitmap pool screens must be greater than or equal to 0");
+      Preconditions.checkArgument(
+          bitmapPoolScreens >= 0, "Bitmap pool screens must be greater than or equal to 0");
       this.bitmapPoolScreens = bitmapPoolScreens;
       return this;
     }
 
     /**
      * Sets the maximum percentage of the device's memory class for standard devices that can be
-     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and
-     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns
-     * this builder.
+     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and {@link
+     * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns this
+     * builder.
      */
     public Builder setMaxSizeMultiplier(float maxSizeMultiplier) {
-      Preconditions.checkArgument(maxSizeMultiplier >= 0 && maxSizeMultiplier <= 1,
+      Preconditions.checkArgument(
+          maxSizeMultiplier >= 0 && maxSizeMultiplier <= 1,
           "Size multiplier must be between 0 and 1");
       this.maxSizeMultiplier = maxSizeMultiplier;
       return this;
@@ -210,40 +211,39 @@ public Builder setMaxSizeMultiplier(float maxSizeMultiplier) {
 
     /**
      * Sets the maximum percentage of the device's memory class for low ram devices that can be
-     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and
-     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns
-     * this builder.
+     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and {@link
+     * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns this
+     * builder.
      *
      * @see ActivityManager#isLowRamDevice()
      */
     public Builder setLowMemoryMaxSizeMultiplier(float lowMemoryMaxSizeMultiplier) {
       Preconditions.checkArgument(
           lowMemoryMaxSizeMultiplier >= 0 && lowMemoryMaxSizeMultiplier <= 1,
-              "Low memory max size multiplier must be between 0 and 1");
+          "Low memory max size multiplier must be between 0 and 1");
       this.lowMemoryMaxSizeMultiplier = lowMemoryMaxSizeMultiplier;
       return this;
     }
 
     /**
-     * Sets the size in bytes of the {@link
-     * com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool} to use to store temporary
-     * arrays while decoding data and returns this builder.
+     * Sets the size in bytes of the {@link com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool}
+     * to use to store temporary arrays while decoding data and returns this builder.
      *
-     * <p>This number will be halved on low memory devices that return {@code true} from
-     * {@link ActivityManager#isLowRamDevice()}.
+     * <p>This number will be halved on low memory devices that return {@code true} from {@link
+     * ActivityManager#isLowRamDevice()}.
      */
     public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
       this.arrayPoolSizeBytes = arrayPoolSizeBytes;
       return this;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Builder setActivityManager(ActivityManager activityManager) {
       this.activityManager = activityManager;
       return this;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Builder setScreenDimensions(ScreenDimensions screenDimensions) {
       this.screenDimensions = screenDimensions;
       return this;
@@ -257,7 +257,7 @@ public MemorySizeCalculator build() {
   private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
     private final DisplayMetrics displayMetrics;
 
-    public DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
+    DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
       this.displayMetrics = displayMetrics;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index 2a81c4d9a..a496ae6ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.load.engine.cache;
 
-import android.support.v4.util.Pools;
+import androidx.annotation.NonNull;
+import androidx.core.util.Pools;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.LruCache;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
@@ -14,19 +16,23 @@
  * A class that generates and caches safe and unique string file names from {@link
  * com.bumptech.glide.load.Key}s.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class SafeKeyGenerator {
   private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
-  private final Pools.Pool<PoolableDigestContainer> digestPool = FactoryPools.threadSafe(10,
-      new FactoryPools.Factory<PoolableDigestContainer>() {
-        @Override
-        public PoolableDigestContainer create() {
-          try {
-            return new PoolableDigestContainer(MessageDigest.getInstance("SHA-256"));
-          } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e);
-          }
-        }
-      });
+  private final Pools.Pool<PoolableDigestContainer> digestPool =
+      FactoryPools.threadSafe(
+          10,
+          new FactoryPools.Factory<PoolableDigestContainer>() {
+            @Override
+            public PoolableDigestContainer create() {
+              try {
+                return new PoolableDigestContainer(MessageDigest.getInstance("SHA-256"));
+              } catch (NoSuchAlgorithmException e) {
+                throw new RuntimeException(e);
+              }
+            }
+          });
 
   public String getSafeKey(Key key) {
     String safeKey;
@@ -43,7 +49,7 @@ public String getSafeKey(Key key) {
   }
 
   private String calculateHexStringDigest(Key key) {
-    PoolableDigestContainer container = digestPool.acquire();
+    PoolableDigestContainer container = Preconditions.checkNotNull(digestPool.acquire());
     try {
       key.updateDiskCacheKey(container.messageDigest);
       // calling digest() will automatically reset()
@@ -62,6 +68,7 @@ private String calculateHexStringDigest(Key key) {
       this.messageDigest = messageDigest;
     }
 
+    @NonNull
     @Override
     public StateVerifier getVerifier() {
       return stateVerifier;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index b66014a04..a1b835a0a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -2,191 +2,222 @@
 
 import android.os.StrictMode;
 import android.os.StrictMode.ThreadPolicy;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
-import java.io.File;
-import java.io.FilenameFilter;
-import java.util.concurrent.BlockingQueue;
+import java.util.Collection;
+import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.regex.Pattern;
-
-/**
- * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
- */
-public final class GlideExecutor extends ThreadPoolExecutor {
+import java.util.concurrent.TimeoutException;
 
+/** A prioritized {@link ThreadPoolExecutor} for running jobs in Glide. */
+public final class GlideExecutor implements ExecutorService {
   /**
    * The default thread name prefix for executors used to load/decode/transform data not found in
    * cache.
    */
-  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+  private static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+
   /**
    * The default thread name prefix for executors used to load/decode/transform data found in
    * Glide's cache.
    */
-  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+  private static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+
   /**
    * The default thread count for executors used to load/decode/transform data found in Glide's
    * cache.
    */
-  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
+  private static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
 
   private static final String TAG = "GlideExecutor";
-  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
-  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
-  // Don't use more than four threads when automatically determining thread count..
-  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
-  // May be accessed on other threads, but this is an optimization only so it's ok if we set its
-  // value more than once.
-  private static volatile int bestThreadCount;
-  private final boolean executeSynchronously;
 
   /**
    * The default thread name prefix for executors from unlimited thread pool used to
    * load/decode/transform data not found in cache.
    */
   private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
-  /**
-   * The default keep alive time for threads in our cached thread pools in milliseconds.
-   */
-  private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
 
   private static final String ANIMATION_EXECUTOR_NAME = "animation";
 
+  /** The default keep alive time for threads in our cached thread pools in milliseconds. */
+  private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
+
+  // Don't use more than four threads when automatically determining thread count..
+  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+
+  // May be accessed on other threads, but this is an optimization only so it's ok if we set its
+  // value more than once.
+  private static volatile int bestThreadCount;
+
+  private final ExecutorService delegate;
+
   /**
-   * Returns a new fixed thread pool with the default thread count returned from
-   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
-   * prefix, and the
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name prefix,
+   * and the {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy.
    *
    * <p>Disk cache executors do not allow network operations on their threads.
    */
   public static GlideExecutor newDiskCacheExecutor() {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from
-   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
-   * prefix, and a custom
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
-   * uncaught throwable strategy.
+   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name prefix,
+   * and a custom {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} uncaught
+   * throwable strategy.
    *
    * <p>Disk cache executors do not allow network operations on their threads.
+   *
    * @param uncaughtThrowableStrategy The {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *                                  handle uncaught exceptions.
+   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *     handle uncaught exceptions.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static GlideExecutor newDiskCacheExecutor(
-          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-                                DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
   }
 
   /**
-   * Returns a new fixed thread pool with the given thread count, thread name prefix,
-   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix, and {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
    *
    * <p>Disk cache executors do not allow network operations on their threads.
    *
    * @param threadCount The number of threads.
    * @param name The prefix for each thread name.
    * @param uncaughtThrowableStrategy The {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *                                  handle uncaught exceptions.
+   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *     handle uncaught exceptions.
    */
-  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
-        true /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newDiskCacheExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, true)));
   }
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from
-   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
-   * prefix, and the
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name prefix, and
+   * the {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy.
    *
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newSourceExecutor() {
-    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
         UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from
-   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
-   * prefix, and a custom
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
-   * uncaught throwable strategy.
+   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name prefix, and
+   * a custom {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} uncaught
+   * throwable strategy.
    *
    * <p>Source executors allow network operations on their threads.
    *
    * @param uncaughtThrowableStrategy The {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *                                  handle uncaught exceptions.
+   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *     handle uncaught exceptions.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static GlideExecutor newSourceExecutor(
-          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-                                DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newSourceExecutor(
+        calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME, uncaughtThrowableStrategy);
   }
 
   /**
-   * Returns a new fixed thread pool with the given thread count, thread name prefix,
-   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix, and {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
    *
    * <p>Source executors allow network operations on their threads.
    *
    * @param threadCount The number of threads.
    * @param name The prefix for each thread name.
    * @param uncaughtThrowableStrategy The {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *                                  handle uncaught exceptions.
+   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *     handle uncaught exceptions.
    */
-  public static GlideExecutor newSourceExecutor(int threadCount, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
-        false /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newSourceExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, false)));
   }
 
   /**
    * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
-   * created by default, {@link #KEEP_ALIVE_TIME_MS} keep alive
-   * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * created by default, {@link #KEEP_ALIVE_TIME_MS} keep alive time, the {@link
+   * #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
    * blocking queue, for example, {@link PriorityBlockingQueue} effectively won't create more than
-   * {@code corePoolSize} threads.
-   * See <a href=
+   * {@code corePoolSize} threads. See <a href=
    * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">
    * ThreadPoolExecutor documentation</a>.
    *
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newUnlimitedSourceExecutor() {
-    return new GlideExecutor(0 /* corePoolSize */,
-        Integer.MAX_VALUE /* maximumPoolSize */,
-        KEEP_ALIVE_TIME_MS,
-        SOURCE_UNLIMITED_EXECUTOR_NAME,
-        UncaughtThrowableStrategy.DEFAULT,
-        false /*preventNetworkOperations*/,
-        false /*executeSynchronously*/,
-        new SynchronousQueue<Runnable>());
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            0,
+            Integer.MAX_VALUE,
+            KEEP_ALIVE_TIME_MS,
+            TimeUnit.MILLISECONDS,
+            new SynchronousQueue<Runnable>(),
+            new DefaultThreadFactory(
+                SOURCE_UNLIMITED_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT, false)));
   }
 
+  /**
+   * Returns a new cached thread pool that defaults to either one or two threads depending on the
+   * number of available cores to use when loading frames of animations.
+   */
   public static GlideExecutor newAnimationExecutor() {
     int bestThreadCount = calculateBestThreadCount();
     // We don't want to add a ton of threads running animations in parallel with our source and
@@ -195,141 +226,123 @@ public static GlideExecutor newAnimationExecutor() {
     // with more cores, two threads can provide better performance if lots of GIFs are showing at
     // once.
     int maximumPoolSize = bestThreadCount >= 4 ? 2 : 1;
+
+    return newAnimationExecutor(maximumPoolSize, UncaughtThrowableStrategy.DEFAULT);
+  }
+
+  /**
+   * Returns a new cached thread pool with the given thread count and {@link
+   * UncaughtThrowableStrategy} to use when loading frames of animations.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newAnimationExecutor(
+      int threadCount, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
     return new GlideExecutor(
-        /*corePoolSize=*/ 0,
-        maximumPoolSize,
-        KEEP_ALIVE_TIME_MS,
-        ANIMATION_EXECUTOR_NAME,
-        UncaughtThrowableStrategy.DEFAULT,
-        /*preventNetworkOperations=*/ true,
-        /*executeSynchronously=*/ false,
-        new PriorityBlockingQueue<Runnable>());
+        new ThreadPoolExecutor(
+            0 /* corePoolSize */,
+            threadCount,
+            KEEP_ALIVE_TIME_MS,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(ANIMATION_EXECUTOR_NAME, uncaughtThrowableStrategy, true)));
+  }
+
+  @VisibleForTesting
+  GlideExecutor(ExecutorService delegate) {
+    this.delegate = delegate;
   }
 
-  // Visible for testing.
-  GlideExecutor(int poolSize, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously) {
-    this(
-        poolSize /* corePoolSize */,
-        poolSize /* maximumPoolSize */,
-        0 /* keepAliveTimeInMs */,
-        name,
-        uncaughtThrowableStrategy,
-        preventNetworkOperations,
-        executeSynchronously);
+  @Override
+  public void execute(@NonNull Runnable command) {
+    delegate.execute(command);
   }
 
-  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously) {
-    this(
-        corePoolSize,
-        maximumPoolSize,
-        keepAliveTimeInMs,
-        name,
-        uncaughtThrowableStrategy,
-        preventNetworkOperations,
-        executeSynchronously,
-        new PriorityBlockingQueue<Runnable>());
+  @NonNull
+  @Override
+  public Future<?> submit(@NonNull Runnable task) {
+    return delegate.submit(task);
   }
 
-  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously, BlockingQueue<Runnable> queue) {
-    super(
-        corePoolSize,
-        maximumPoolSize,
-        keepAliveTimeInMs,
-        TimeUnit.MILLISECONDS,
-        queue,
-        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
-    this.executeSynchronously = executeSynchronously;
+  @NonNull
+  @Override
+  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks);
   }
 
+  @NonNull
   @Override
-  public void execute(Runnable command) {
-    if (executeSynchronously) {
-      command.run();
-    } else {
-      super.execute(command);
-    }
+  public <T> List<Future<T>> invokeAll(
+      @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks, timeout, unit);
   }
 
   @NonNull
   @Override
-  public Future<?> submit(Runnable task) {
-    return maybeWait(super.submit(task));
+  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException, ExecutionException {
+    return delegate.invokeAny(tasks);
   }
 
-  private <T> Future<T> maybeWait(Future<T> future) {
-    if (executeSynchronously) {
-      boolean interrupted = false;
-      try {
-        while (!future.isDone()) {
-          try {
-            future.get();
-          } catch (ExecutionException e) {
-            throw new RuntimeException(e);
-          } catch (InterruptedException e) {
-            interrupted = true;
-          }
-        }
-      } finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    }
-    return future;
+  @Override
+  public <T> T invokeAny(
+      @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException, ExecutionException, TimeoutException {
+    return delegate.invokeAny(tasks, timeout, unit);
   }
 
   @NonNull
   @Override
-  public <T> Future<T> submit(Runnable task, T result) {
-    return maybeWait(super.submit(task, result));
+  public <T> Future<T> submit(@NonNull Runnable task, T result) {
+    return delegate.submit(task, result);
   }
 
   @Override
-  public <T> Future<T> submit(Callable<T> task) {
-    return maybeWait(super.submit(task));
+  public <T> Future<T> submit(@NonNull Callable<T> task) {
+    return delegate.submit(task);
   }
 
-  /**
-   * Determines the number of cores available on the device.
-   *
-   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not
-   * be the number of available cores depending on the device's current state. See
-   * http://goo.gl/8H670N.
-   */
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
+  }
+
+  @NonNull
+  @Override
+  public List<Runnable> shutdownNow() {
+    return delegate.shutdownNow();
+  }
+
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
+
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
+  }
+
+  @Override
+  public boolean awaitTermination(long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException {
+    return delegate.awaitTermination(timeout, unit);
+  }
+
+  @Override
+  public String toString() {
+    return delegate.toString();
+  }
+
+  /** Determines the number of cores available on the device. */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static int calculateBestThreadCount() {
     if (bestThreadCount == 0) {
-      // We override the current ThreadPolicy to allow disk reads.
-      // This shouldn't actually do disk-IO and accesses a device file.
-      // See: https://github.com/bumptech/glide/issues/1170
-      ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
-      File[] cpus = null;
-      try {
-        File cpuInfo = new File(CPU_LOCATION);
-        final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
-        cpus = cpuInfo.listFiles(new FilenameFilter() {
-          @Override
-          public boolean accept(File file, String s) {
-            return cpuNamePattern.matcher(s).matches();
-          }
-        });
-      } catch (Throwable t) {
-        if (Log.isLoggable(TAG, Log.ERROR)) {
-          Log.e(TAG, "Failed to calculate accurate cpu count", t);
-        }
-      } finally {
-        StrictMode.setThreadPolicy(originalPolicy);
-      }
-
-      int cpuCount = cpus != null ? cpus.length : 0;
-      int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
       bestThreadCount =
-          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
+          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());
     }
     return bestThreadCount;
   }
@@ -339,37 +352,38 @@ public boolean accept(File file, String s) {
    * pool.
    */
   public interface UncaughtThrowableStrategy {
-    /**
-     * Silently catches and ignores the uncaught {@link Throwable}s.
-     */
-    UncaughtThrowableStrategy IGNORE = new UncaughtThrowableStrategy() {
-      @Override
-      public void handle(Throwable t) {
-        //ignore
-      }
-    };
-    /**
-     * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}.
-     */
-    UncaughtThrowableStrategy LOG = new UncaughtThrowableStrategy() {
-      @Override
-      public void handle(Throwable t) {
-        if (t != null && Log.isLoggable(TAG, Log.ERROR)) {
-          Log.e(TAG, "Request threw uncaught throwable", t);
-        }
-      }
-    };
-    /**
-     * Rethrows the uncaught {@link Throwable}s to crash the app.
-     */
-    UncaughtThrowableStrategy THROW = new UncaughtThrowableStrategy() {
-      @Override
-      public void handle(Throwable t) {
-        if (t != null) {
-          throw new RuntimeException("Request threw uncaught throwable", t);
-        }
-      }
-    };
+    /** Silently catches and ignores the uncaught {@link Throwable}s. */
+    // Public API.
+    @SuppressWarnings("unused")
+    UncaughtThrowableStrategy IGNORE =
+        new UncaughtThrowableStrategy() {
+          @Override
+          public void handle(Throwable t) {
+            // ignore
+          }
+        };
+    /** Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}. */
+    UncaughtThrowableStrategy LOG =
+        new UncaughtThrowableStrategy() {
+          @Override
+          public void handle(Throwable t) {
+            if (t != null && Log.isLoggable(TAG, Log.ERROR)) {
+              Log.e(TAG, "Request threw uncaught throwable", t);
+            }
+          }
+        };
+    /** Rethrows the uncaught {@link Throwable}s to crash the app. */
+    // Public API.
+    @SuppressWarnings("unused")
+    UncaughtThrowableStrategy THROW =
+        new UncaughtThrowableStrategy() {
+          @Override
+          public void handle(Throwable t) {
+            if (t != null) {
+              throw new RuntimeException("Request threw uncaught throwable", t);
+            }
+          }
+        };
 
     /** The default strategy, currently {@link #LOG}. */
     UncaughtThrowableStrategy DEFAULT = LOG;
@@ -382,12 +396,18 @@ public void handle(Throwable t) {
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
+    private static final int DEFAULT_PRIORITY =
+        android.os.Process.THREAD_PRIORITY_BACKGROUND
+            + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE;
+
     private final String name;
     @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
     @Synthetic final boolean preventNetworkOperations;
     private int threadNum;
 
-    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy,
+    DefaultThreadFactory(
+        String name,
+        UncaughtThrowableStrategy uncaughtThrowableStrategy,
         boolean preventNetworkOperations) {
       this.name = name;
       this.uncaughtThrowableStrategy = uncaughtThrowableStrategy;
@@ -396,26 +416,24 @@ public void handle(Throwable t) {
 
     @Override
     public synchronized Thread newThread(@NonNull Runnable runnable) {
-      final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
-        @Override
-        public void run() {
-          android.os.Process.setThreadPriority(
-              android.os.Process.THREAD_PRIORITY_BACKGROUND
-              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
-          if (preventNetworkOperations) {
-            StrictMode.setThreadPolicy(
-                new ThreadPolicy.Builder()
-                    .detectNetwork()
-                    .penaltyDeath()
-                    .build());
-          }
-          try {
-            super.run();
-          } catch (Throwable t) {
-            uncaughtThrowableStrategy.handle(t);
-          }
-        }
-      };
+      final Thread result =
+          new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
+            @Override
+            public void run() {
+              // why PMD suppression is needed: https://github.com/pmd/pmd/issues/808
+              android.os.Process.setThreadPriority(
+                  DEFAULT_PRIORITY); // NOPMD AccessorMethodGeneration
+              if (preventNetworkOperations) {
+                StrictMode.setThreadPolicy(
+                    new ThreadPolicy.Builder().detectNetwork().penaltyDeath().build());
+              }
+              try {
+                super.run();
+              } catch (Throwable t) {
+                uncaughtThrowableStrategy.handle(t);
+              }
+            }
+          };
       threadNum++;
       return result;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
new file mode 100644
index 000000000..6261f7dd0
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
@@ -0,0 +1,66 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.Build;
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.util.Log;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.regex.Pattern;
+
+/** Compatibility methods for {@link java.lang.Runtime}. */
+final class RuntimeCompat {
+  private static final String TAG = "GlideRuntimeCompat";
+  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
+  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
+
+  private RuntimeCompat() {
+    // Utility class.
+  }
+
+  /** Determines the number of cores available on the device. */
+  static int availableProcessors() {
+    int cpus = Runtime.getRuntime().availableProcessors();
+    if (Build.VERSION.SDK_INT < 17) {
+      cpus = Math.max(getCoreCountPre17(), cpus);
+    }
+    return cpus;
+  }
+
+  /**
+   * Determines the number of cores available on the device (pre-v17).
+   *
+   * <p>Before Jellybean, {@link Runtime#availableProcessors()} returned the number of awake cores,
+   * which may not be the number of available cores depending on the device's current state. See
+   * https://stackoverflow.com/a/30150409.
+   *
+   * @return the maximum number of processors available to the VM; never smaller than one
+   */
+  @SuppressWarnings("PMD")
+  private static int getCoreCountPre17() {
+    // We override the current ThreadPolicy to allow disk reads.
+    // This shouldn't actually do disk-IO and accesses a device file.
+    // See: https://github.com/bumptech/glide/issues/1170
+    File[] cpus = null;
+    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
+    try {
+      File cpuInfo = new File(CPU_LOCATION);
+      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+      cpus =
+          cpuInfo.listFiles(
+              new FilenameFilter() {
+                @Override
+                public boolean accept(File file, String s) {
+                  return cpuNamePattern.matcher(s).matches();
+                }
+              });
+    } catch (Throwable t) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      }
+    } finally {
+      StrictMode.setThreadPolicy(originalPolicy);
+    }
+    return Math.max(1, cpus != null ? cpus.length : 0);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index a2f92a9db..662f06fab 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -5,6 +5,8 @@
 import android.os.Looper;
 import android.os.SystemClock;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
@@ -28,7 +30,7 @@
  * limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
  */
 final class BitmapPreFillRunner implements Runnable {
-  private static final String TAG = "PreFillRunner";
+  @VisibleForTesting static final String TAG = "PreFillRunner";
   private static final Clock DEFAULT_CLOCK = new Clock();
 
   /**
@@ -42,14 +44,10 @@
    */
   static final long INITIAL_BACKOFF_MS = 40;
 
-  /**
-   * The amount by which the current backoff time is multiplied each time we detect a GC.
-   */
+  /** The amount by which the current backoff time is multiplied each time we detect a GC. */
   static final int BACKOFF_RATIO = 4;
 
-  /**
-   * The maximum amount of time in ms we wait before continuing to allocate.
-   */
+  /** The maximum amount of time in ms we wait before continuing to allocate. */
   static final long MAX_BACKOFF_MS = TimeUnit.SECONDS.toMillis(1);
 
   private final BitmapPool bitmapPool;
@@ -62,15 +60,25 @@
   private long currentDelay = INITIAL_BACKOFF_MS;
   private boolean isCancelled;
 
-  public BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache,
-      PreFillQueue allocationOrder) {
-    this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK,
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapPreFillRunner(
+      BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {
+    this(
+        bitmapPool,
+        memoryCache,
+        allocationOrder,
+        DEFAULT_CLOCK,
         new Handler(Looper.getMainLooper()));
   }
 
-  // Visible for testing.
-  BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder,
-      Clock clock, Handler handler) {
+  @VisibleForTesting
+  BitmapPreFillRunner(
+      BitmapPool bitmapPool,
+      MemoryCache memoryCache,
+      PreFillQueue allocationOrder,
+      Clock clock,
+      Handler handler) {
     this.bitmapPool = bitmapPool;
     this.memoryCache = memoryCache;
     this.toPrefill = allocationOrder;
@@ -86,33 +94,51 @@ public void cancel() {
    * Attempts to allocate {@link android.graphics.Bitmap}s and returns {@code true} if there are
    * more {@link android.graphics.Bitmap}s to allocate and {@code false} otherwise.
    */
-  private boolean allocate() {
+  @VisibleForTesting
+  boolean allocate() {
     long start = clock.now();
     while (!toPrefill.isEmpty() && !isGcDetected(start)) {
       PreFillType toAllocate = toPrefill.remove();
       final Bitmap bitmap;
       if (!seenTypes.contains(toAllocate)) {
         seenTypes.add(toAllocate);
-        bitmap = bitmapPool.getDirty(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            bitmapPool.getDirty(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       } else {
-        bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            Bitmap.createBitmap(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       }
 
+      // Order matters here! If the Bitmap is too large or the BitmapPool is too full, it may be
+      // recycled after the call to bitmapPool#put below.
+      int bitmapSize = Util.getBitmapByteSize(bitmap);
+
       // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's
-      // not empty so
-      // we use all available space.
-      if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
-        memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
+      // not empty so that we use all available space.
+      if (getFreeMemoryCacheBytes() >= bitmapSize) {
+        // We could probably make UniqueKey just always return false from equals,
+        // but the allocation of the Key is not nearly as expensive as the allocation of the Bitmap,
+        // so it's probably not worth it.
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        Key uniqueKey = new UniqueKey();
+        memoryCache.put(uniqueKey, BitmapResource.obtain(bitmap, bitmapPool));
       } else {
         bitmapPool.put(bitmap);
       }
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG,
-            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] " + toAllocate
-                .getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
+        Log.d(
+            TAG,
+            "allocated ["
+                + toAllocate.getWidth()
+                + "x"
+                + toAllocate.getHeight()
+                + "] "
+                + toAllocate.getConfig()
+                + " size: "
+                + bitmapSize);
       }
     }
 
@@ -123,7 +149,7 @@ private boolean isGcDetected(long startTimeMs) {
     return clock.now() - startTimeMs >= MAX_DURATION_MS;
   }
 
-  private int getFreeMemoryCacheBytes() {
+  private long getFreeMemoryCacheBytes() {
     return memoryCache.getMaxSize() - memoryCache.getCurrentSize();
   }
 
@@ -140,20 +166,21 @@ private long getNextDelay() {
     return result;
   }
 
-  private static class UniqueKey implements Key {
+  private static final class UniqueKey implements Key {
 
     @Synthetic
-    UniqueKey() { }
+    @SuppressWarnings("WeakerAccess")
+    UniqueKey() {}
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
       throw new UnsupportedOperationException();
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Clock {
-    public long now() {
+    long now() {
       return SystemClock.currentThreadTimeMillis();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index c5caa3cc7..cc65c2139 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
@@ -11,8 +12,8 @@
 import java.util.Map;
 
 /**
- * A class for pre-filling {@link android.graphics.Bitmap Bitmaps} in a
- * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
+ * A class for pre-filling {@link android.graphics.Bitmap Bitmaps} in a {@link
+ * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
  */
 public final class BitmapPreFiller {
 
@@ -23,8 +24,8 @@
 
   private BitmapPreFillRunner current;
 
-  public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool,
-      DecodeFormat defaultFormat) {
+  public BitmapPreFiller(
+      MemoryCache memoryCache, BitmapPool bitmapPool, DecodeFormat defaultFormat) {
     this.memoryCache = memoryCache;
     this.bitmapPool = bitmapPool;
     this.defaultFormat = defaultFormat;
@@ -42,8 +43,8 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
       if (builder.getConfig() == null) {
         builder.setConfig(
             defaultFormat == DecodeFormat.PREFER_ARGB_8888
-                || defaultFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
-            ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
+                ? Bitmap.Config.ARGB_8888
+                : Bitmap.Config.RGB_565);
       }
       bitmapAttributes[i] = builder.build();
     }
@@ -53,9 +54,9 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     handler.post(current);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   PreFillQueue generateAllocationOrder(PreFillType... preFillSizes) {
-    final int maxSize =
+    final long maxSize =
         memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
     int totalWeight = 0;
@@ -80,4 +81,3 @@ private static int getSizeInBytes(PreFillType size) {
     return Util.getBitmapByteSize(size.getWidth(), size.getHeight(), size.getConfig());
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
index 9c07fb07c..ac711c34c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -1,17 +1,17 @@
 package com.bumptech.glide.load.engine.prefill;
 
 import android.graphics.Bitmap;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * A container for a put of options used to pre-fill a
- * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} with {@link Bitmap Bitmaps} of a
- * single size and configuration.
+ * A container for a put of options used to pre-fill a {@link
+ * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} with {@link Bitmap Bitmaps} of a single
+ * size and configuration.
  */
 public final class PreFillType {
-  // Visible for testing.
-  static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
+  @VisibleForTesting static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
   private final int width;
   private final int height;
   private final Bitmap.Config config;
@@ -20,13 +20,13 @@
   /**
    * Constructor for a single type of {@link android.graphics.Bitmap}.
    *
-   * @param width  The width in pixels of the {@link android.graphics.Bitmap Bitmaps} to pre-fill.
+   * @param width The width in pixels of the {@link android.graphics.Bitmap Bitmaps} to pre-fill.
    * @param height The height in pixels of the {@link android.graphics.Bitmap Bitmaps} to pre-fill.
-   * @param config The {@link android.graphics.Bitmap.Config} of the
-   *               {@link android.graphics.Bitmap Bitmaps} to pre-fill.
+   * @param config The {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap
+   *     Bitmaps} to pre-fill.
    * @param weight An integer indicating how to balance pre-filling this size and configuration of
-   *               {@link android.graphics.Bitmap} against any other sizes/configurations that may
-   *               be being pre-filled.
+   *     {@link android.graphics.Bitmap} against any other sizes/configurations that may be being
+   *     pre-filled.
    */
   PreFillType(int width, int height, Bitmap.Config config, int weight) {
     this.config = Preconditions.checkNotNull(config, "Config must not be null");
@@ -35,31 +35,25 @@
     this.weight = weight;
   }
 
-  /**
-   * Returns the width in pixels of the {@link android.graphics.Bitmap Bitmaps}.
-   */
+  /** Returns the width in pixels of the {@link android.graphics.Bitmap Bitmaps}. */
   int getWidth() {
     return width;
   }
 
-  /**
-   * Returns the height in pixels of the {@link android.graphics.Bitmap Bitmaps}.
-   */
+  /** Returns the height in pixels of the {@link android.graphics.Bitmap Bitmaps}. */
   int getHeight() {
     return height;
   }
 
   /**
-   * Returns the {@link android.graphics.Bitmap.Config} of the
-   * {@link android.graphics.Bitmap Bitmaps}.
+   * Returns the {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap
+   * Bitmaps}.
    */
   Bitmap.Config getConfig() {
     return config;
   }
 
-  /**
-   * Returns the weight of the {@link android.graphics.Bitmap Bitmaps} of this type.
-   */
+  /** Returns the weight of the {@link android.graphics.Bitmap Bitmaps} of this type. */
   int getWeight() {
     return weight;
   }
@@ -68,7 +62,9 @@ int getWeight() {
   public boolean equals(Object o) {
     if (o instanceof PreFillType) {
       PreFillType other = (PreFillType) o;
-      return height == other.height && width == other.width && weight == other.weight
+      return height == other.height
+          && width == other.width
+          && weight == other.weight
           && config == other.config;
     }
     return false;
@@ -85,13 +81,19 @@ public int hashCode() {
 
   @Override
   public String toString() {
-    return "PreFillSize{" + "width=" + width + ", height=" + height + ", config=" + config
-        + ", weight=" + weight + '}';
+    return "PreFillSize{"
+        + "width="
+        + width
+        + ", height="
+        + height
+        + ", config="
+        + config
+        + ", weight="
+        + weight
+        + '}';
   }
 
-  /**
-   * Builder for {@link PreFillType}.
-   */
+  /** Builder for {@link PreFillType}. */
   public static class Builder {
     private final int width;
     private final int height;
@@ -113,7 +115,7 @@ public Builder(int size) {
      * Constructor for a builder that uses the given dimensions as the dimensions of the Bitmaps to
      * prefill.
      *
-     * @param width  The width in pixels of the Bitmaps to prefill.
+     * @param width The width in pixels of the Bitmaps to prefill.
      * @param height The height in pixels of the Bitmaps to prefill.
      */
     public Builder(int width, int height) {
@@ -138,9 +140,7 @@ public Builder setConfig(@Nullable Bitmap.Config config) {
       return this;
     }
 
-    /**
-     * Returns the current {@link android.graphics.Bitmap.Config}.
-     */
+    /** Returns the current {@link android.graphics.Bitmap.Config}. */
     Bitmap.Config getConfig() {
       return config;
     }
@@ -150,8 +150,8 @@ public Builder setConfig(@Nullable Bitmap.Config config) {
      * other requested types.
      *
      * @param weight An integer indicating how to balance pre-filling this size and configuration of
-     *               {@link android.graphics.Bitmap} against any other sizes/configurations that may
-     *               be being pre-filled.
+     *     {@link android.graphics.Bitmap} against any other sizes/configurations that may be being
+     *     pre-filled.
      * @return This builder.
      */
     public Builder setWeight(int weight) {
@@ -162,9 +162,7 @@ public Builder setWeight(int weight) {
       return this;
     }
 
-    /**
-     * Returns a new {@link PreFillType}.
-     */
+    /** Returns a new {@link PreFillType}. */
     PreFillType build() {
       return new PreFillType(width, height, config, weight);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index 7083de7bc..3da79ce85 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -4,6 +4,7 @@
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
@@ -25,22 +26,25 @@
   private final AssetManager assetManager;
   private final AssetFetcherFactory<Data> factory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public AssetUriLoader(AssetManager assetManager, AssetFetcherFactory<Data> factory) {
     this.assetManager = assetManager;
     this.factory = factory;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     String assetPath = model.toString().substring(ASSET_PREFIX_LENGTH);
     return new LoadData<>(new ObjectKey(model), factory.buildFetcher(assetManager, assetPath));
   }
 
   @Override
-  public boolean handles(Uri model) {
-    return ContentResolver.SCHEME_FILE.equals(model.getScheme()) && !model.getPathSegments()
-        .isEmpty() && ASSET_PATH_SEGMENT.equals(model.getPathSegments().get(0));
+  public boolean handles(@NonNull Uri model) {
+    return ContentResolver.SCHEME_FILE.equals(model.getScheme())
+        && !model.getPathSegments().isEmpty()
+        && ASSET_PATH_SEGMENT.equals(model.getPathSegments().get(0));
   }
 
   /**
@@ -52,11 +56,9 @@ public boolean handles(Uri model) {
     DataFetcher<Data> buildFetcher(AssetManager assetManager, String assetPath);
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from asset manager Uris.
-   */
-  public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
-      AssetFetcherFactory<InputStream> {
+  /** Factory for loading {@link InputStream}s from asset manager Uris. */
+  public static class StreamFactory
+      implements ModelLoaderFactory<Uri, InputStream>, AssetFetcherFactory<InputStream> {
 
     private final AssetManager assetManager;
 
@@ -64,6 +66,7 @@ public StreamFactory(AssetManager assetManager) {
       this.assetManager = assetManager;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new AssetUriLoader<>(assetManager, this);
@@ -80,12 +83,10 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for loading {@link ParcelFileDescriptor}s from asset manager Uris.
-   */
-  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
-      ParcelFileDescriptor>,
-      AssetFetcherFactory<ParcelFileDescriptor> {
+  /** Factory for loading {@link ParcelFileDescriptor}s from asset manager Uris. */
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<Uri, ParcelFileDescriptor>,
+          AssetFetcherFactory<ParcelFileDescriptor> {
 
     private final AssetManager assetManager;
 
@@ -93,6 +94,7 @@ public FileDescriptorFactory(AssetManager assetManager) {
       this.assetManager = assetManager;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new AssetUriLoader<>(assetManager, this);
@@ -104,8 +106,8 @@ public void teardown() {
     }
 
     @Override
-    public DataFetcher<ParcelFileDescriptor> buildFetcher(AssetManager assetManager,
-        String assetPath) {
+    public DataFetcher<ParcelFileDescriptor> buildFetcher(
+        AssetManager assetManager, String assetPath) {
       return new FileDescriptorAssetPathFetcher(assetManager, assetPath);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 60c4a9452..5bf7dd835 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.signature.ObjectKey;
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -20,28 +20,30 @@
 public class ByteArrayLoader<Data> implements ModelLoader<byte[], Data> {
   private final Converter<Data> converter;
 
+  @SuppressWarnings("WeakerAccess") // Public API
   public ByteArrayLoader(Converter<Data> converter) {
     this.converter = converter;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(byte[] model, int width, int height,
-      Options options) {
-    // TODO: compare the actual bytes?
-    return new LoadData<>(EmptySignature.obtain(), new Fetcher<>(model, converter));
+  public LoadData<Data> buildLoadData(
+      @NonNull byte[] model, int width, int height, @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(model), new Fetcher<>(model, converter));
   }
 
   @Override
-  public boolean handles(byte[] model) {
+  public boolean handles(@NonNull byte[] model) {
     return true;
   }
 
   /**
    * Converts between a byte array a desired model class.
+   *
    * @param <Data> The type of data to convert to.
    */
   public interface Converter<Data> {
     Data convert(byte[] model);
+
     Class<Data> getDataClass();
   }
 
@@ -49,13 +51,19 @@ public boolean handles(byte[] model) {
     private final byte[] model;
     private final Converter<Data> converter;
 
-    public Fetcher(byte[] model, Converter<Data> converter) {
+    /**
+     * @param model We really ought to copy the model, but doing so can be hugely expensive and/or
+     *     lead to OOMs. In practice it's unlikely that users would pass an array into Glide and
+     *     then mutate it.
+     */
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
+    Fetcher(byte[] model, Converter<Data> converter) {
       this.model = model;
       this.converter = converter;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       Data result = converter.convert(model);
       callback.onDataReady(result);
     }
@@ -84,24 +92,26 @@ public DataSource getDataSource() {
   }
 
   /**
-   * Factory for {@link com.bumptech.glide.load.model.ByteArrayLoader} and
-   * {@link java.nio.ByteBuffer}.
+   * Factory for {@link com.bumptech.glide.load.model.ByteArrayLoader} and {@link
+   * java.nio.ByteBuffer}.
    */
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
+    @NonNull
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
-      return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
-        @Override
-        public ByteBuffer convert(byte[] model) {
-          return ByteBuffer.wrap(model);
-        }
-
-        @Override
-        public Class<ByteBuffer> getDataClass() {
-          return ByteBuffer.class;
-        }
-      });
+    public ModelLoader<byte[], ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
+      return new ByteArrayLoader<>(
+          new Converter<ByteBuffer>() {
+            @Override
+            public ByteBuffer convert(byte[] model) {
+              return ByteBuffer.wrap(model);
+            }
+
+            @Override
+            public Class<ByteBuffer> getDataClass() {
+              return ByteBuffer.class;
+            }
+          });
     }
 
     @Override
@@ -110,24 +120,24 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for {@link ByteArrayLoader} and {@link java.io.InputStream}.
-   */
+  /** Factory for {@link ByteArrayLoader} and {@link java.io.InputStream}. */
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<byte[], InputStream> build(MultiModelLoaderFactory multiFactory) {
-      return new ByteArrayLoader<>(new Converter<InputStream>() {
-        @Override
-        public InputStream convert(byte[] model) {
-          return new ByteArrayInputStream(model);
-        }
-
-        @Override
-        public Class<InputStream> getDataClass() {
-          return InputStream.class;
-        }
-      });
+    public ModelLoader<byte[], InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
+      return new ByteArrayLoader<>(
+          new Converter<InputStream>() {
+            @Override
+            public InputStream convert(byte[] model) {
+              return new ByteArrayInputStream(model);
+            }
+
+            @Override
+            public Class<InputStream> getDataClass() {
+              return InputStream.class;
+            }
+          });
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
index 278d16f2f..72b86ba0d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.util.ByteBufferUtil;
@@ -8,14 +9,12 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-/**
- * Writes {@link ByteBuffer ByteBuffers} to {@link File Files}.
- */
+/** Writes {@link ByteBuffer ByteBuffers} to {@link File Files}. */
 public class ByteBufferEncoder implements Encoder<ByteBuffer> {
   private static final String TAG = "ByteBufferEncoder";
 
   @Override
-  public boolean encode(ByteBuffer data, File file, Options options) {
+  public boolean encode(@NonNull ByteBuffer data, @NonNull File file, @NonNull Options options) {
     boolean success = false;
     try {
       ByteBufferUtil.toFile(data, file);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index 82a787898..5b44924ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -1,41 +1,39 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.ByteBufferUtil;
+import com.bumptech.glide.util.Synthetic;
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-/**
- * Loads {@link java.nio.ByteBuffer}s using NIO for {@link java.io.File}.
- */
+/** Loads {@link java.nio.ByteBuffer}s using NIO for {@link java.io.File}. */
 public class ByteBufferFileLoader implements ModelLoader<File, ByteBuffer> {
   private static final String TAG = "ByteBufferFileLoader";
 
   @Override
-  public LoadData<ByteBuffer> buildLoadData(File file, int width, int height,
-      Options options) {
+  public LoadData<ByteBuffer> buildLoadData(
+      @NonNull File file, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(file), new ByteBufferFetcher(file));
   }
 
   @Override
-  public boolean handles(File file) {
+  public boolean handles(@NonNull File file) {
     return true;
   }
 
-  /**
-   * Factory for {@link com.bumptech.glide.load.model.ByteBufferFileLoader}.
-   */
+  /** Factory for {@link com.bumptech.glide.load.model.ByteBufferFileLoader}. */
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
+    @NonNull
     @Override
-    public ModelLoader<File, ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
@@ -45,17 +43,20 @@ public void teardown() {
     }
   }
 
-  private static class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
+  private static final class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
 
     private final File file;
 
-    public ByteBufferFetcher(File file) {
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    ByteBufferFetcher(File file) {
       this.file = file;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super ByteBuffer> callback) {
-      ByteBuffer result = null;
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super ByteBuffer> callback) {
+      ByteBuffer result;
       try {
         result = ByteBufferUtil.fromFile(file);
       } catch (IOException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
index 4f522f4ac..ee34c8756 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.NonNull;
 import android.util.Base64;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -14,32 +14,41 @@
 /**
  * A simple model loader for loading data from a Data URL String.
  *
- * Data URIs use the "data" scheme.
+ * <p>Data URIs use the "data" scheme.
  *
- * <p>See http://www.ietf.org/rfc/rfc2397.txt  for a complete description of the 'data' URL scheme.
+ * <p>See http://www.ietf.org/rfc/rfc2397.txt for a complete description of the 'data' URL scheme.
  *
- * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],some_data</pre>
+ * <p>Briefly, a 'data' URL has the form:
  *
- * @param <Data> The type of data that can be opened.
+ * <pre>data:[mediatype][;base64],some_data</pre>
+ *
+ * @param <Model> The type of Model that we can retrieve data for, e.g. {@link String}.
+ * @param <Data> The type of data that can be opened, e.g. {@link InputStream}.
  */
-public final class DataUrlLoader<Data> implements ModelLoader<String, Data> {
+public final class DataUrlLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private static final String DATA_SCHEME_IMAGE = "data:image";
   private static final String BASE64_TAG = ";base64";
   private final DataDecoder<Data> dataDecoder;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public DataUrlLoader(DataDecoder<Data> dataDecoder) {
     this.dataDecoder = dataDecoder;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(String model, int width, int height, Options options) {
-    return new LoadData<>(new ObjectKey(model), new DataUriFetcher<Data>(model, dataDecoder));
+  public LoadData<Data> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options) {
+    return new LoadData<>(
+        new ObjectKey(model), new DataUriFetcher<>(model.toString(), dataDecoder));
   }
 
   @Override
-  public boolean handles(String url) {
-    return url.startsWith(DATA_SCHEME_IMAGE);
+  public boolean handles(@NonNull Model model) {
+    // We expect Model to be a Uri or a String, both of which implement toString() efficiently. We
+    // should reconsider this implementation before adding any new Model types.
+    return model.toString().startsWith(DATA_SCHEME_IMAGE);
   }
 
   /**
@@ -62,13 +71,13 @@ public boolean handles(String url) {
     private final DataDecoder<Data> reader;
     private Data data;
 
-    public DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
+    DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
       this.dataUri = dataUri;
       this.reader = reader;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       try {
         data = reader.decode(dataUri);
         callback.onDataReady(data);
@@ -105,55 +114,59 @@ public DataSource getDataSource() {
   }
 
   /**
-   * Factory for loading {@link InputStream} from Data URL string.
+   * Factory for loading {@link InputStream}s from data uris.
+   *
+   * @param <Model> The type of Model we can obtain data for, e.g. String.
    */
-  public static final class StreamFactory implements ModelLoaderFactory<String, InputStream> {
+  public static final class StreamFactory<Model> implements ModelLoaderFactory<Model, InputStream> {
 
     private final DataDecoder<InputStream> opener;
 
     public StreamFactory() {
-      opener = new DataDecoder<InputStream>() {
-        @Override
-        public InputStream decode(String url) {
-          if (!url.startsWith(DATA_SCHEME_IMAGE)) {
-            throw new IllegalArgumentException("Not a valid image data URL.");
-          }
-
-          int commaIndex = url.indexOf(',');
-          if (commaIndex == -1) {
-            throw new IllegalArgumentException("Missing comma in data URL.");
-          }
-
-          String beforeComma = url.substring(0, commaIndex);
-          if (!beforeComma.endsWith(BASE64_TAG)) {
-            throw new IllegalArgumentException("Not a base64 image data URL.");
-          }
-
-          String afterComma = url.substring(commaIndex + 1);
-          byte[] bytes = Base64.decode(afterComma, Base64.DEFAULT);
-
-          return new ByteArrayInputStream(bytes);
-        }
-
-        @Override
-        public void close(InputStream inputStream) throws IOException {
-          inputStream.close();
-        }
-
-        @Override
-        public Class<InputStream> getDataClass() {
-          return InputStream.class;
-        }
-      };
+      opener =
+          new DataDecoder<InputStream>() {
+            @Override
+            public InputStream decode(String url) {
+              if (!url.startsWith(DATA_SCHEME_IMAGE)) {
+                throw new IllegalArgumentException("Not a valid image data URL.");
+              }
+
+              int commaIndex = url.indexOf(',');
+              if (commaIndex == -1) {
+                throw new IllegalArgumentException("Missing comma in data URL.");
+              }
+
+              String beforeComma = url.substring(0, commaIndex);
+              if (!beforeComma.endsWith(BASE64_TAG)) {
+                throw new IllegalArgumentException("Not a base64 image data URL.");
+              }
+
+              String afterComma = url.substring(commaIndex + 1);
+              byte[] bytes = Base64.decode(afterComma, Base64.DEFAULT);
+
+              return new ByteArrayInputStream(bytes);
+            }
+
+            @Override
+            public void close(InputStream inputStream) throws IOException {
+              inputStream.close();
+            }
+
+            @Override
+            public Class<InputStream> getDataClass() {
+              return InputStream.class;
+            }
+          };
     }
 
+    @NonNull
     @Override
-    public final ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Model, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new DataUrlLoader<>(opener);
     }
 
     @Override
-    public final void teardown() {
+    public void teardown() {
       // Do nothing.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index 3d6fb70c3..9936eaf1e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.model;
 
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -18,50 +18,55 @@
  * A simple model loader for loading data from {@link File}s.
  *
  * @param <Data> The type of data loaded from the given {@link java.io.File} ({@link
- *               java.io.InputStream} or {@link java.io.FileDescriptor} etc).
+ *     java.io.InputStream} or {@link java.io.FileDescriptor} etc).
  */
 public class FileLoader<Data> implements ModelLoader<File, Data> {
   private static final String TAG = "FileLoader";
 
   private final FileOpener<Data> fileOpener;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public FileLoader(FileOpener<Data> fileOpener) {
     this.fileOpener = fileOpener;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(File model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull File model, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new FileFetcher<>(model, fileOpener));
   }
 
   @Override
-  public boolean handles(File model) {
+  public boolean handles(@NonNull File model) {
     return true;
   }
 
   /**
    * Allows opening a specific type of data from a {@link java.io.File}.
+   *
    * @param <Data> The type of data that can be opened.
    */
   public interface FileOpener<Data> {
     Data open(File file) throws FileNotFoundException;
+
     void close(Data data) throws IOException;
+
     Class<Data> getDataClass();
   }
 
-  private static class FileFetcher<Data> implements DataFetcher<Data> {
+  private static final class FileFetcher<Data> implements DataFetcher<Data> {
     private final File file;
     private final FileOpener<Data> opener;
     private Data data;
 
-    public FileFetcher(File file, FileOpener<Data> opener) {
+    FileFetcher(File file, FileOpener<Data> opener) {
       this.file = file;
       this.opener = opener;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       try {
         data = opener.open(file);
       } catch (FileNotFoundException e) {
@@ -105,6 +110,7 @@ public DataSource getDataSource() {
 
   /**
    * Base factory for loading data from {@link java.io.File files}.
+   *
    * @param <Data> The type of data that will be loaded for a given {@link java.io.File}.
    */
   public static class Factory<Data> implements ModelLoaderFactory<File, Data> {
@@ -114,8 +120,9 @@ public Factory(FileOpener<Data> opener) {
       this.opener = opener;
     }
 
+    @NonNull
     @Override
-    public final ModelLoader<File, Data> build(MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
@@ -125,52 +132,50 @@ public final void teardown() {
     }
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from {@link File}s.
-   */
+  /** Factory for loading {@link InputStream}s from {@link File}s. */
   public static class StreamFactory extends Factory<InputStream> {
     public StreamFactory() {
-      super(new FileOpener<InputStream>() {
-        @Override
-        public InputStream open(File file) throws FileNotFoundException {
-          return new FileInputStream(file);
-        }
-
-        @Override
-        public void close(InputStream inputStream) throws IOException {
-          inputStream.close();
-        }
-
-        @Override
-        public Class<InputStream> getDataClass() {
-          return InputStream.class;
-        }
-      });
+      super(
+          new FileOpener<InputStream>() {
+            @Override
+            public InputStream open(File file) throws FileNotFoundException {
+              return new FileInputStream(file);
+            }
+
+            @Override
+            public void close(InputStream inputStream) throws IOException {
+              inputStream.close();
+            }
+
+            @Override
+            public Class<InputStream> getDataClass() {
+              return InputStream.class;
+            }
+          });
     }
   }
 
-  /**
-   * Factory for loading {@link ParcelFileDescriptor}s from {@link File}s.
-   */
+  /** Factory for loading {@link ParcelFileDescriptor}s from {@link File}s. */
   public static class FileDescriptorFactory extends Factory<ParcelFileDescriptor> {
 
     public FileDescriptorFactory() {
-      super(new FileOpener<ParcelFileDescriptor>() {
-        @Override
-        public ParcelFileDescriptor open(File file) throws FileNotFoundException {
-          return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
-        }
-
-        @Override
-        public void close(ParcelFileDescriptor parcelFileDescriptor) throws IOException {
-          parcelFileDescriptor.close();
-        }
-
-        @Override
-        public Class<ParcelFileDescriptor> getDataClass() {
-          return ParcelFileDescriptor.class;
-        }
-      });
+      super(
+          new FileOpener<ParcelFileDescriptor>() {
+            @Override
+            public ParcelFileDescriptor open(File file) throws FileNotFoundException {
+              return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+            }
+
+            @Override
+            public void close(ParcelFileDescriptor parcelFileDescriptor) throws IOException {
+              parcelFileDescriptor.close();
+            }
+
+            @Override
+            public Class<ParcelFileDescriptor> getDataClass() {
+              return ParcelFileDescriptor.class;
+            }
+          });
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 02a26aa26..9d4a621ef 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 import java.net.MalformedURLException;
@@ -15,18 +16,17 @@
  * escaped and avoiding unnecessary URL instantiations for loaders that require only string urls
  * rather than URL objects.
  *
- * <p>  Users wishing to replace the class for handling URLs must register a factory using
- * GlideUrl. </p>
+ * <p>Users wishing to replace the class for handling URLs must register a factory using GlideUrl.
  *
- * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string
+ * <p>To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string
  * URL, call {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache
- * key, call {@link #getCacheKey()}. </p>
+ * key, call {@link #getCacheKey()}.
  *
- * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for
- * convenience. </p>
+ * <p>This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for
+ * convenience.
  */
 public class GlideUrl implements Key {
-  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
+  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%;$";
   private final Headers headers;
   @Nullable private final URL url;
   @Nullable private final String stringUrl;
@@ -86,16 +86,14 @@ private String getSafeStringUrl() {
     if (TextUtils.isEmpty(safeStringUrl)) {
       String unsafeStringUrl = stringUrl;
       if (TextUtils.isEmpty(unsafeStringUrl)) {
-        unsafeStringUrl = url.toString();
+        unsafeStringUrl = Preconditions.checkNotNull(url).toString();
       }
       safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
     }
     return safeStringUrl;
   }
 
-  /**
-   * Returns a non-null {@link Map} containing headers.
-   */
+  /** Returns a non-null {@link Map} containing headers. */
   public Map<String, String> getHeaders() {
     return headers.getHeaders();
   }
@@ -103,13 +101,14 @@ private String getSafeStringUrl() {
   /**
    * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
    *
-   * <p> This method does not include headers. </p>
+   * <p>This method does not include headers.
    *
-   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
-   * input. </p>
+   * <p>Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public String getCacheKey() {
-    return stringUrl != null ? stringUrl : url.toString();
+    return stringUrl != null ? stringUrl : Preconditions.checkNotNull(url).toString();
   }
 
   @Override
@@ -118,7 +117,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(getCacheKeyBytes());
   }
 
@@ -133,8 +132,7 @@ public void updateDiskCacheKey(MessageDigest messageDigest) {
   public boolean equals(Object o) {
     if (o instanceof GlideUrl) {
       GlideUrl other = (GlideUrl) o;
-      return getCacheKey().equals(other.getCacheKey())
-          && headers.equals(other.headers);
+      return getCacheKey().equals(other.getCacheKey()) && headers.equals(other.headers);
     }
     return false;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Headers.java b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
index f55d16f4e..b6258ad30 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/Headers.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
@@ -6,7 +6,7 @@
 /**
  * An interface for a wrapper for a set of headers to be included in a Glide request.
  *
- * <p> Implementations must implement equals() and hashcode(). </p>
+ * <p>Implementations must implement equals() and hashcode().
  */
 public interface Headers {
 
@@ -16,21 +16,20 @@
    * @deprecated Use {@link #DEFAULT} instead.
    */
   @Deprecated
-  Headers NONE = new Headers() {
-      @Override
-      public Map<String, String> getHeaders() {
+  Headers NONE =
+      new Headers() {
+        @Override
+        public Map<String, String> getHeaders() {
           return Collections.emptyMap();
-      }
-  };
+        }
+      };
 
   /**
-   * A Headers object containing reasonable defaults that should be used when users don't want
-   * to provide their own headers.
+   * A Headers object containing reasonable defaults that should be used when users don't want to
+   * provide their own headers.
    */
   Headers DEFAULT = new LazyHeaders.Builder().build();
 
-  /**
-   * Returns a non-null map containing a set of headers to apply to an http request.
-   */
+  /** Returns a non-null map containing a set of headers to apply to an http request. */
   Map<String, String> getHeaders();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
index 66a76cd11..8e823b28c 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -1,24 +1,22 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 
 /**
  * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
  * example) to be generated in the background during the first fetch.
  *
- * <p> Implementations should implement equals() and hashcode() </p> .
+ * <p>Implementations should implement equals() and hashcode() .
  */
 public interface LazyHeaderFactory {
-
-    /**
-     * Returns an http header, or {@code null} if no header could be built.
-     *
-     * <p>Returning {@code null} or an empty String from this method will result in this particular
-     * key/value being excluded from the headers provided in the request. If there are multiple
-     * factories or values for a particular key, any non-null values will still be included for that
-     * key.
-     */
-    @Nullable
-    String buildHeader();
-
+  /**
+   * Returns an http header, or {@code null} if no header could be built.
+   *
+   * <p>Returning {@code null} or an empty String from this method will result in this particular
+   * key/value being excluded from the headers provided in the request. If there are multiple
+   * factories or values for a particular key, any non-null values will still be included for that
+   * key.
+   */
+  @Nullable
+  String buildHeader();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 5f4b4c85d..ad04e724d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -12,10 +14,10 @@
  * A wrapper class for a set of headers to be included in a Glide request, allowing headers to be
  * constructed lazily.
  *
- * <p> Ideally headers are constructed once and then re-used for multiple loads, rather then being
- * constructed individually for each load. </p>
+ * <p>Ideally headers are constructed once and then re-used for multiple loads, rather then being
+ * constructed individually for each load.
  *
- * <p> This class is thread safe. </p>
+ * <p>This class is thread safe.
  */
 public final class LazyHeaders implements Headers {
   private final Map<String, List<LazyHeaderFactory>> headers;
@@ -42,33 +44,35 @@
     Map<String, String> combinedHeaders = new HashMap<>();
 
     for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-      StringBuilder sb = new StringBuilder();
-      List<LazyHeaderFactory> factories = entry.getValue();
-      int size = factories.size();
-      for (int i = 0; i < size; i++) {
-        LazyHeaderFactory factory = factories.get(i);
-        String header = factory.buildHeader();
-        if (!TextUtils.isEmpty(header)) {
-          sb.append(header);
-          if (i != factories.size() - 1) {
-            sb.append(',');
-          }
-        }
-      }
-      String values = sb.toString();
+      String values = buildHeaderValue(entry.getValue());
       if (!TextUtils.isEmpty(values)) {
-        combinedHeaders.put(entry.getKey(), sb.toString());
+        combinedHeaders.put(entry.getKey(), values);
       }
     }
 
     return combinedHeaders;
   }
 
+  @NonNull
+  private String buildHeaderValue(@NonNull List<LazyHeaderFactory> factories) {
+    StringBuilder sb = new StringBuilder();
+    int size = factories.size();
+    for (int i = 0; i < size; i++) {
+      LazyHeaderFactory factory = factories.get(i);
+      String header = factory.buildHeader();
+      if (!TextUtils.isEmpty(header)) {
+        sb.append(header);
+        if (i != factories.size() - 1) {
+          sb.append(',');
+        }
+      }
+    }
+    return sb.toString();
+  }
+
   @Override
   public String toString() {
-    return "LazyHeaders{"
-        + "headers=" + headers
-        + '}';
+    return "LazyHeaders{" + "headers=" + headers + '}';
   }
 
   @Override
@@ -86,18 +90,16 @@ public int hashCode() {
   }
 
   /**
-   * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
-   * key* lazily on a background thread.
+   * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given key*
+   * lazily on a background thread.
    *
-   * <p> This class is not thread safe. </p>
+   * <p>This class is not thread safe.
    *
-   * <p> This class may include default values for User-Agent and Accept-Encoding headers. These
-   * will be replaced by calls to either {@link #setHeader(String, LazyHeaderFactory)} or
-   * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}
-   * would usually append an additional value. </p>
+   * <p>This class may include default values for User-Agent and Accept-Encoding headers. These will
+   * be replaced by calls to either {@link #setHeader(String, LazyHeaderFactory)} or {@link
+   * #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)} would
+   * usually append an additional value.
    */
-   // PMD doesn't like the necessary static block to initialize DEFAULT_HEADERS.
-  @SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
   public static final class Builder {
     private static final String USER_AGENT_HEADER = "User-Agent";
     private static final String DEFAULT_USER_AGENT = getSanitizedUserAgent();
@@ -107,10 +109,10 @@ public int hashCode() {
     // images and also makes it more difficult for us to detect and prevent partial content
     // rendering. See #440.
     static {
-      Map<String, List<LazyHeaderFactory>> temp
-          = new HashMap<>(2);
+      Map<String, List<LazyHeaderFactory>> temp = new HashMap<>(2);
       if (!TextUtils.isEmpty(DEFAULT_USER_AGENT)) {
-        temp.put(USER_AGENT_HEADER,
+        temp.put(
+            USER_AGENT_HEADER,
             Collections.<LazyHeaderFactory>singletonList(
                 new StringHeaderFactory(DEFAULT_USER_AGENT)));
       }
@@ -124,27 +126,25 @@ public int hashCode() {
     /**
      * Adds a value for the given header and returns this builder.
      *
-     * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
-     * (i.e. an OAuth token). </p>
+     * <p>Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+     * (i.e. an OAuth token).
      *
      * @see #addHeader(String, LazyHeaderFactory)
-
      */
-    public Builder addHeader(String key, String value) {
+    public Builder addHeader(@NonNull String key, @NonNull String value) {
       return addHeader(key, new StringHeaderFactory(value));
     }
 
     /**
-     * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
-     * key lazily on a background thread.
+     * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given key
+     * lazily on a background thread.
      *
-     * <p> Headers may have multiple values whose order is defined by the order in which
-     * this method is called. </p>
+     * <p>Headers may have multiple values whose order is defined by the order in which this method
+     * is called.
      *
-     * <p> This class does not prevent you from adding the same value to a given key multiple
-     * times </p>
+     * <p>This class does not prevent you from adding the same value to a given key multiple times
      */
-    public Builder addHeader(String key, LazyHeaderFactory factory) {
+    public Builder addHeader(@NonNull String key, @NonNull LazyHeaderFactory factory) {
       if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
         return setHeader(key, factory);
       }
@@ -155,25 +155,26 @@ public Builder addHeader(String key, LazyHeaderFactory factory) {
     }
 
     /**
-     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key
-     * with the given {@link LazyHeaderFactory}.
+     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key with the
+     * given {@link LazyHeaderFactory}.
      *
-     * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
+     * <p>If the given value is {@code null}, the header at the given key will be removed.
      *
-     * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
-     * (i.e. an OAuth token). </p>
+     * <p>Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+     * (i.e. an OAuth token).
      */
-    public Builder setHeader(String key, String value) {
+    @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}) // Public API
+    public Builder setHeader(@NonNull String key, @Nullable String value) {
       return setHeader(key, value == null ? null : new StringHeaderFactory(value));
     }
 
     /**
-     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key
-     * with the given {@link LazyHeaderFactory}.
+     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key with the
+     * given {@link LazyHeaderFactory}.
      *
-     * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
+     * <p>If the given value is {@code null}, the header at the given key will be removed.
      */
-    public Builder setHeader(String key, LazyHeaderFactory factory) {
+    public Builder setHeader(@NonNull String key, @Nullable LazyHeaderFactory factory) {
       copyIfNecessary();
       if (factory == null) {
         headers.remove(key);
@@ -206,19 +207,18 @@ private void copyIfNecessary() {
       }
     }
 
-    /**
-     * Returns a new immutable {@link LazyHeaders} object.
-     */
+    /** Returns a new immutable {@link LazyHeaders} object. */
     public LazyHeaders build() {
       copyOnModify = true;
       return new LazyHeaders(headers);
     }
 
     private Map<String, List<LazyHeaderFactory>> copyHeaders() {
-      Map<String, List<LazyHeaderFactory>> result =
-          new HashMap<>(headers.size());
+      Map<String, List<LazyHeaderFactory>> result = new HashMap<>(headers.size());
       for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-        result.put(entry.getKey(), new ArrayList<>(entry.getValue()));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        List<LazyHeaderFactory> valueCopy = new ArrayList<>(entry.getValue());
+        result.put(entry.getKey(), valueCopy);
       }
       return result;
     }
@@ -226,7 +226,7 @@ public LazyHeaders build() {
     /**
      * Ensures that the default header will pass OkHttp3's checks for header values.
      *
-     * <p>See #2331.
+     * @see <a href="https://github.com/bumptech/glide/issues/2331">#2331</a>
      */
     @VisibleForTesting
     static String getSanitizedUserAgent() {
@@ -251,9 +251,9 @@ static String getSanitizedUserAgent() {
 
   static final class StringHeaderFactory implements LazyHeaderFactory {
 
-    private final String value;
+    @NonNull private final String value;
 
-    StringHeaderFactory(String value) {
+    StringHeaderFactory(@NonNull String value) {
       this.value = value;
     }
 
@@ -264,9 +264,7 @@ public String buildHeader() {
 
     @Override
     public String toString() {
-      return "StringHeaderFactory{"
-          + "value='" + value + '\''
-          + '}';
+      return "StringHeaderFactory{" + "value='" + value + '\'' + '}';
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index 7d389f197..b4c4dc50b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -4,8 +4,8 @@
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
-import android.support.annotation.NonNull;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -15,31 +15,33 @@
 import java.io.File;
 import java.io.FileNotFoundException;
 
-/**
- * Loads the file path for {@link MediaStore} owned {@link Uri uris}.
- */
-public final class MediaStoreFileLoader implements ModelLoader<Uri, File>  {
+/** Loads the file path for {@link MediaStore} owned {@link Uri uris}. */
+public final class MediaStoreFileLoader implements ModelLoader<Uri, File> {
 
   private final Context context;
 
-  MediaStoreFileLoader(Context context) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public MediaStoreFileLoader(Context context) {
     this.context = context;
   }
 
   @Override
-  public LoadData<File> buildLoadData(Uri uri, int width, int height, Options options) {
+  public LoadData<File> buildLoadData(
+      @NonNull Uri uri, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(uri), new FilePathFetcher(context, uri));
   }
 
   @Override
-  public boolean handles(Uri uri) {
+  public boolean handles(@NonNull Uri uri) {
     return MediaStoreUtil.isMediaStoreUri(uri);
   }
 
   private static class FilePathFetcher implements DataFetcher<File> {
-    private static final String[] PROJECTION = new String[] {
-        MediaStore.MediaColumns.DATA,
-    };
+    private static final String[] PROJECTION =
+        new String[] {
+          MediaStore.MediaColumns.DATA,
+        };
 
     private final Context context;
     private final Uri uri;
@@ -50,9 +52,12 @@ public boolean handles(Uri uri) {
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super File> callback) {
-      Cursor cursor = context.getContentResolver().query(uri, PROJECTION, null /*selection*/,
-          null /*selectionArgs*/, null /*sortOrder*/);
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super File> callback) {
+      Cursor cursor =
+          context
+              .getContentResolver()
+              .query(
+                  uri, PROJECTION, null /*selection*/, null /*selectionArgs*/, null /*sortOrder*/);
 
       String filePath = null;
       if (cursor != null) {
@@ -95,9 +100,7 @@ public DataSource getDataSource() {
     }
   }
 
-  /**
-   * {@link ModelLoaderFactory} for {@link MediaStoreFileLoader}s.
-   */
+  /** {@link ModelLoaderFactory} for {@link MediaStoreFileLoader}s. */
   public static final class Factory implements ModelLoaderFactory<Uri, File> {
 
     private final Context context;
@@ -106,6 +109,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, File> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreFileLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Model.java b/library/src/main/java/com/bumptech/glide/load/model/Model.java
index 99dd48744..66dc66f55 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/Model.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java
@@ -1,28 +1,26 @@
 package com.bumptech.glide.load.model;
 
-/**
- * An optional interface that models can implement to enhance control over Glide behaviors.
- */
+import androidx.annotation.Nullable;
+
+/** An optional interface that models can implement to enhance control over Glide behaviors. */
 public interface Model {
 
-    /**
-     * Returns {@code true} if this model produces the same image using the same mechanism
-     * (server, authentication, source etc) as the given model.
-     * <p>
-     * Models must also override {@link Object#equals(Object other)} and {@link Object#hashCode()}
-     * to ensure that caching functions correctly.
-     * If this object returns {@code true} from this method for a given Model,
-     * it must also be equal to and have the same hash code as the given model.
-     * <p>
-     * However, this model may be equal to and have the same hash code as a given model
-     * but still return {@code false} from this method.
-     * This method optionally allows you to differentiate between Models that load the same image
-     * via multiple different means.
-     * For example one Model might load the image from server A and another model might load
-     * the same image from server B.
-     * The models must be equal to each other with the same hash code because they load
-     * the same image. However two requests made with the different models are not exactly the
-     * same because the way the image is loaded will differ.
-     */
-    boolean isEquivalentTo(Object other);
+  /**
+   * Returns {@code true} if this model produces the same image using the same mechanism (server,
+   * authentication, source etc) as the given model.
+   *
+   * <p>Models must also override {@link Object#equals(Object other)} and {@link Object#hashCode()}
+   * to ensure that caching functions correctly. If this object returns {@code true} from this
+   * method for a given Model, it must also be equal to and have the same hash code as the given
+   * model.
+   *
+   * <p>However, this model may be equal to and have the same hash code as a given model but still
+   * return {@code false} from this method. This method optionally allows you to differentiate
+   * between Models that load the same image via multiple different means. For example one Model
+   * might load the image from server A and another model might load the same image from server B.
+   * The models must be equal to each other with the same hash code because they load the same
+   * image. However two requests made with the different models are not exactly the same because the
+   * way the image is loaded will differ.
+   */
+  boolean isEquivalentTo(@Nullable Object other);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index a4f10978a..69a5f560f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
 import java.util.Queue;
@@ -8,8 +10,7 @@
 /**
  * A simple cache that can be used by {@link ModelLoader} and {@link ModelLoaderFactory} to cache
  * some data for a given model, width and height. For a loader that takes a model and returns a url,
- * the cache could be used to safely memoize url creation based on the width and height of the
- * view.
+ * the cache could be used to safely memoize url creation based on the width and height of the view.
  *
  * @param <A> Some Model type that implements {@link #equals} and {@link #hashCode}.
  * @param <B> Some useful type that may be expensive to create (URL, file path, etc).
@@ -19,24 +20,27 @@
 
   private final LruCache<ModelKey<A>, B> cache;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ModelCache() {
     this(DEFAULT_SIZE);
   }
 
-  public ModelCache(int size) {
-    cache = new LruCache<ModelKey<A>, B>(size) {
-      @Override
-      protected void onItemEvicted(ModelKey<A> key, B item) {
-        key.release();
-      }
-    };
+  public ModelCache(long size) {
+    cache =
+        new LruCache<ModelKey<A>, B>(size) {
+          @Override
+          protected void onItemEvicted(@NonNull ModelKey<A> key, @Nullable B item) {
+            key.release();
+          }
+        };
   }
 
   /**
    * Get a value.
    *
-   * @param model  The model.
-   * @param width  The width in pixels of the view the image is being loaded into.
+   * @param model The model.
+   * @param width The width in pixels of the view the image is being loaded into.
    * @param height The height in pixels of the view the image is being loaded into.
    * @return The cached result, or null.
    */
@@ -51,24 +55,22 @@ public B get(A model, int width, int height) {
   /**
    * Add a value.
    *
-   * @param model  The model.
-   * @param width  The width in pixels of the view the image is being loaded into.
+   * @param model The model.
+   * @param width The width in pixels of the view the image is being loaded into.
    * @param height The height in pixels of the view the image is being loaded into.
-   * @param value  The value to store.
+   * @param value The value to store.
    */
   public void put(A model, int width, int height, B value) {
     ModelKey<A> key = ModelKey.get(model, width, height);
     cache.put(key, value);
   }
 
-  /**
-   * Removes all entries from the cache.
-   */
+  /** Removes all entries from the cache. */
   public void clear() {
     cache.clearMemory();
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class ModelKey<A> {
     private static final Queue<ModelKey<?>> KEY_QUEUE = Util.createQueue(0);
 
@@ -90,8 +92,7 @@ public void clear() {
       return modelKey;
     }
 
-    private ModelKey() {
-    }
+    private ModelKey() {}
 
     private void init(A model, int width, int height) {
       this.model = model;
@@ -108,7 +109,8 @@ public void release() {
     @Override
     public boolean equals(Object o) {
       if (o instanceof ModelKey) {
-        @SuppressWarnings("unchecked") ModelKey<A> other = (ModelKey<A>) o;
+        @SuppressWarnings("unchecked")
+        ModelKey<A> other = (ModelKey<A>) o;
         return width == other.width && height == other.height && model.equals(other.model);
       }
       return false;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index 230551c5d..324d7929c 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -13,31 +14,30 @@
  * that can be used by an {@link DataFetcher} to obtain the data for a resource represented by the
  * model.
  *
- * <p> This interface has two objectives: 1. To translate a specific model into a data type that can
+ * <p>This interface has two objectives: 1. To translate a specific model into a data type that can
  * be decoded into a resource.
  *
- * 2. To allow a model to be combined with the dimensions of the view to fetch a resource of a
+ * <p>2. To allow a model to be combined with the dimensions of the view to fetch a resource of a
  * specific size.
  *
- * This not only avoids having to duplicate dimensions in xml and in your code in order to determine
- * the size of a view on devices with different densities, but also allows you to use layout weights
- * or otherwise programmatically put the dimensions of the view without forcing you to fetch a
- * generic resource size.
+ * <p>This not only avoids having to duplicate dimensions in xml and in your code in order to
+ * determine the size of a view on devices with different densities, but also allows you to use
+ * layout weights or otherwise programmatically put the dimensions of the view without forcing you
+ * to fetch a generic resource size.
  *
- * The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower
- * your memory footprint per resource. </p>
+ * <p>The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower
+ * your memory footprint per resource.
  *
  * @param <Model> The type of the model.
- * @param <Data>  The type of the data that can be used by a
- * {@link com.bumptech.glide.load.ResourceDecoder} to decode a resource.
+ * @param <Data> The type of the data that can be used by a {@link
+ *     com.bumptech.glide.load.ResourceDecoder} to decode a resource.
  */
 public interface ModelLoader<Model, Data> {
 
   /**
    * Contains a set of {@link com.bumptech.glide.load.Key Keys} identifying the source of the load,
-   * alternate cache keys pointing to equivalent data, and a
-   * {@link com.bumptech.glide.load.data.DataFetcher} that can be used to fetch data not found in
-   * cache.
+   * alternate cache keys pointing to equivalent data, and a {@link
+   * com.bumptech.glide.load.data.DataFetcher} that can be used to fetch data not found in cache.
    *
    * @param <Data> The type of data that well be loaded.
    */
@@ -46,11 +46,14 @@
     public final List<Key> alternateKeys;
     public final DataFetcher<Data> fetcher;
 
-    public LoadData(Key sourceKey, DataFetcher<Data> fetcher) {
+    public LoadData(@NonNull Key sourceKey, @NonNull DataFetcher<Data> fetcher) {
       this(sourceKey, Collections.<Key>emptyList(), fetcher);
     }
 
-    public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetcher) {
+    public LoadData(
+        @NonNull Key sourceKey,
+        @NonNull List<Key> alternateKeys,
+        @NonNull DataFetcher<Data> fetcher) {
       this.sourceKey = Preconditions.checkNotNull(sourceKey);
       this.alternateKeys = Preconditions.checkNotNull(alternateKeys);
       this.fetcher = Preconditions.checkNotNull(fetcher);
@@ -58,36 +61,37 @@ public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetche
   }
 
   /**
-   * Returns a {@link com.bumptech.glide.load.model.ModelLoader.LoadData} containing a
-   * {@link com.bumptech.glide.load.data.DataFetcher} required to decode the resource
-   * represented by this model, as well as a set of {@link com.bumptech.glide.load.Key Keys} that
-   * identify the data loaded by the {@link com.bumptech.glide.load.data.DataFetcher} as well as an
-   * optional list of alternate keys from which equivalent data can be loaded. The
-   * {@link DataFetcher} will not be used if the resource is already cached.
+   * Returns a {@link com.bumptech.glide.load.model.ModelLoader.LoadData} containing a {@link
+   * com.bumptech.glide.load.data.DataFetcher} required to decode the resource represented by this
+   * model, as well as a set of {@link com.bumptech.glide.load.Key Keys} that identify the data
+   * loaded by the {@link com.bumptech.glide.load.data.DataFetcher} as well as an optional list of
+   * alternate keys from which equivalent data can be loaded. The {@link DataFetcher} will not be
+   * used if the resource is already cached.
    *
-   * <p> Note - If no valid data fetcher can be returned (for example if a model has a null URL),
-   * then it is acceptable to return a null data fetcher from this method. </p>
+   * <p>Note - If no valid data fetcher can be returned (for example if a model has a null URL),
+   * then it is acceptable to return a null data fetcher from this method.
    *
-   * @param model  The model representing the resource.
-   * @param width  The width in pixels of the view or target the resource will be loaded into, or
-   *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that
-   *               the resource should be loaded at its original width.
+   * @param model The model representing the resource.
+   * @param width The width in pixels of the view or target the resource will be loaded into, or
+   *     {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that the
+   *     resource should be loaded at its original width.
    * @param height The height in pixels of the view or target the resource will be loaded into, or
-   *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that
-   *               the resource should be loaded at its original height.
+   *     {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that the
+   *     resource should be loaded at its original height.
    */
   @Nullable
-  LoadData<Data> buildLoadData(Model model, int width, int height, Options options);
+  LoadData<Data> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options);
 
   /**
    * Returns true if the given model is a of a recognized type that this loader can probably load.
    *
-   * <p> For example, you may want multiple Uri -> InputStream loaders. One might handle media
-   * store Uris, another might handle asset Uris, and a third might handle file Uris etc. </p>
+   * <p>For example, you may want multiple Uri -> InputStream loaders. One might handle media store
+   * Uris, another might handle asset Uris, and a third might handle file Uris etc.
    *
-   * <p> This method is generally expected to do no I/O and complete quickly, so best effort
-   * results are acceptable. {@link ModelLoader ModelLoaders} that return true from this method may
-   * return {@code null} from {@link #buildLoadData(Object, int, int, Options)} </p>
+   * <p>This method is generally expected to do no I/O and complete quickly, so best effort results
+   * are acceptable. {@link ModelLoader ModelLoaders} that return true from this method may return
+   * {@code null} from {@link #buildLoadData(Object, int, int, Options)}
    */
-  boolean handles(Model model);
+  boolean handles(@NonNull Model model);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index 19e126019..6235ee806 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -1,17 +1,23 @@
 package com.bumptech.glide.load.model;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Registry;
 
 /**
- * An interface for creating a {@link ModelLoader} for a given model type. Will be retained
- * statically so should not retain {@link Context} or any other objects that cannot be retained for
- * the life of the application. ModelLoaders will not be retained statically so it is safe for any
- * ModelLoader built by this factory to retain a reference to a {@link Context}.
+ * An interface for creating a {@link ModelLoader} for a given model type.
+ *
+ * <p>The application {@link android.content.Context} can be passed in to the constructor of the
+ * factory when necessary. It's unsafe to retain {@link android.app.Activity} {@link
+ * android.content.Context}s in factories. The {@link android.content.Context} can be obtained from
+ * {@link com.bumptech.glide.module.LibraryGlideModule#registerComponents(Context, Glide, Registry)}
+ * in most cases.
  *
  * @param <T> The type of the model the {@link com.bumptech.glide.load.model.ModelLoader}s built by
- *            this factory can handle
+ *     this factory can handle
  * @param <Y> The type of data the {@link com.bumptech.glide.load.model.ModelLoader}s built by this
- *            factory can load.
+ *     factory can load.
  */
 public interface ModelLoaderFactory<T, Y> {
 
@@ -19,13 +25,12 @@
    * Build a concrete ModelLoader for this model type.
    *
    * @param multiFactory A map of classes to factories that can be used to construct additional
-   *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
+   *     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
-  ModelLoader<T, Y> build(MultiModelLoaderFactory multiFactory);
+  @NonNull
+  ModelLoader<T, Y> build(@NonNull MultiModelLoaderFactory multiFactory);
 
-  /**
-   * A lifecycle method that will be called when this factory is about to replaced.
-   */
+  /** A lifecycle method that will be called when this factory is about to replaced. */
   void teardown();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index 77923f2c4..be288cab7 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.model;
 
-import android.support.v4.util.Pools.Pool;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.util.Pools.Pool;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -12,72 +14,94 @@
  * Maintains an ordered put of {@link ModelLoader}s and the model and data types they handle in
  * order from highest priority to lowest.
  */
+// Hides Model throughout.
+@SuppressWarnings("TypeParameterHidesVisibleType")
 public class ModelLoaderRegistry {
 
   private final MultiModelLoaderFactory multiModelLoaderFactory;
   private final ModelLoaderCache cache = new ModelLoaderCache();
 
-  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
-    this(new MultiModelLoaderFactory(exceptionListPool));
+  public ModelLoaderRegistry(@NonNull Pool<List<Throwable>> throwableListPool) {
+    this(new MultiModelLoaderFactory(throwableListPool));
   }
 
-  // Visible for testing.
-  ModelLoaderRegistry(MultiModelLoaderFactory multiModelLoaderFactory) {
+  private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFactory) {
     this.multiModelLoaderFactory = multiModelLoaderFactory;
   }
 
-  public synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     multiModelLoaderFactory.append(modelClass, dataClass, factory);
     cache.clear();
   }
 
-  public synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     multiModelLoaderFactory.prepend(modelClass, dataClass, factory);
     cache.clear();
   }
 
-  public synchronized <Model, Data> void remove(Class<Model> modelClass, Class<Data> dataClass) {
+  public synchronized <Model, Data> void remove(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass) {
     tearDown(multiModelLoaderFactory.remove(modelClass, dataClass));
     cache.clear();
   }
 
-  public synchronized <Model, Data> void replace(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     tearDown(multiModelLoaderFactory.replace(modelClass, dataClass, factory));
     cache.clear();
   }
 
-  private <Model, Data> void tearDown(List<ModelLoaderFactory<Model, Data>> factories) {
-    for (ModelLoaderFactory<?, ?> factory : factories) {
+  private <Model, Data> void tearDown(
+      @NonNull List<ModelLoaderFactory<? extends Model, ? extends Data>> factories) {
+    for (ModelLoaderFactory<? extends Model, ? extends Data> factory : factories) {
       factory.teardown();
     }
   }
 
-  public synchronized <A> List<ModelLoader<A, ?>> getModelLoaders(A model) {
+  // We're allocating in a loop to avoid allocating empty lists that will never have anything added
+  // to them.
+  @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+  @NonNull
+  public <A> List<ModelLoader<A, ?>> getModelLoaders(@NonNull A model) {
     List<ModelLoader<A, ?>> modelLoaders = getModelLoadersForClass(getClass(model));
     int size = modelLoaders.size();
-    List<ModelLoader<A, ?>> filteredLoaders = new ArrayList<>(size);
+    boolean isEmpty = true;
+    List<ModelLoader<A, ?>> filteredLoaders = Collections.emptyList();
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<A, ?> loader = modelLoaders.get(i);
       if (loader.handles(model)) {
+        if (isEmpty) {
+          filteredLoaders = new ArrayList<>(size - i);
+          isEmpty = false;
+        }
         filteredLoaders.add(loader);
       }
     }
     return filteredLoaders;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
-      Class<Data> dataClass) {
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass) {
     return multiModelLoaderFactory.build(modelClass, dataClass);
   }
 
-  public synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+  @NonNull
+  public synchronized List<Class<?>> getDataClasses(@NonNull Class<?> modelClass) {
     return multiModelLoaderFactory.getDataClasses(modelClass);
   }
 
-  private <A> List<ModelLoader<A, ?>> getModelLoadersForClass(Class<A> modelClass) {
+  @NonNull
+  private synchronized <A> List<ModelLoader<A, ?>> getModelLoadersForClass(
+      @NonNull Class<A> modelClass) {
     List<ModelLoader<A, ?>> loaders = cache.get(modelClass);
     if (loaders == null) {
       loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));
@@ -86,8 +110,9 @@ public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
     return loaders;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private static <A> Class<A> getClass(A model) {
+  private static <A> Class<A> getClass(@NonNull A model) {
     return (Class<A>) model.getClass();
   }
 
@@ -95,7 +120,7 @@ public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
     private final Map<Class<?>, Entry<?>> cachedModelLoaders = new HashMap<>();
 
     @Synthetic
-    ModelLoaderCache() { }
+    ModelLoaderCache() {}
 
     public void clear() {
       cachedModelLoaders.clear();
@@ -108,6 +133,7 @@ public void clear() {
       }
     }
 
+    @Nullable
     @SuppressWarnings("unchecked")
     public <Model> List<ModelLoader<Model, ?>> get(Class<Model> modelClass) {
       Entry<Model> entry = (Entry<Model>) cachedModelLoaders.get(modelClass);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index d18d12e46..46eaa2c94 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.v4.util.Pools.Pool;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.util.Pools.Pool;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
@@ -18,29 +18,31 @@
 /**
  * Allows attempting multiple ModelLoaders registered for a given model and data class.
  *
- * <p> TODO: we should try to find a way to remove this class. It exists to allow individual
+ * <p>TODO: we should try to find a way to remove this class. It exists to allow individual
  * ModelLoaders to delegate to multiple ModelLoaders without having to duplicate this logic
  * everywhere. We have very similar logic in the {@link
  * com.bumptech.glide.load.engine.DataFetcherGenerator} implementations and should try to avoid this
- * duplication. </p>
+ * duplication.
  */
 class MultiModelLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private final List<ModelLoader<Model, Data>> modelLoaders;
-  private final Pool<List<Exception>> exceptionListPool;
+  private final Pool<List<Throwable>> exceptionListPool;
 
-  MultiModelLoader(List<ModelLoader<Model, Data>> modelLoaders,
-      Pool<List<Exception>> exceptionListPool) {
+  MultiModelLoader(
+      @NonNull List<ModelLoader<Model, Data>> modelLoaders,
+      @NonNull Pool<List<Throwable>> exceptionListPool) {
     this.modelLoaders = modelLoaders;
     this.exceptionListPool = exceptionListPool;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Model model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options) {
     Key sourceKey = null;
     int size = modelLoaders.size();
     List<DataFetcher<Data>> fetchers = new ArrayList<>(size);
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<Model, Data> modelLoader = modelLoaders.get(i);
       if (modelLoader.handles(model)) {
@@ -51,12 +53,13 @@
         }
       }
     }
-    return !fetchers.isEmpty()
-        ? new LoadData<>(sourceKey, new MultiFetcher<>(fetchers, exceptionListPool)) : null;
+    return !fetchers.isEmpty() && sourceKey != null
+        ? new LoadData<>(sourceKey, new MultiFetcher<>(fetchers, exceptionListPool))
+        : null;
   }
 
   @Override
-  public boolean handles(Model model) {
+  public boolean handles(@NonNull Model model) {
     for (ModelLoader<Model, Data> modelLoader : modelLoaders) {
       if (modelLoader.handles(model)) {
         return true;
@@ -67,39 +70,48 @@ public boolean handles(Model model) {
 
   @Override
   public String toString() {
-    return "MultiModelLoader{" + "modelLoaders=" + Arrays
-        .toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + '}';
+    return "MultiModelLoader{" + "modelLoaders=" + Arrays.toString(modelLoaders.toArray()) + '}';
   }
 
   static class MultiFetcher<Data> implements DataFetcher<Data>, DataCallback<Data> {
 
     private final List<DataFetcher<Data>> fetchers;
-    private final Pool<List<Exception>> exceptionListPool;
+    private final Pool<List<Throwable>> throwableListPool;
     private int currentIndex;
     private Priority priority;
     private DataCallback<? super Data> callback;
-    @Nullable
-    private List<Exception> exceptions;
+    @Nullable private List<Throwable> exceptions;
+    private boolean isCancelled;
 
-    MultiFetcher(List<DataFetcher<Data>> fetchers, Pool<List<Exception>> exceptionListPool) {
-      this.exceptionListPool = exceptionListPool;
+    MultiFetcher(
+        @NonNull List<DataFetcher<Data>> fetchers,
+        @NonNull Pool<List<Throwable>> throwableListPool) {
+      this.throwableListPool = throwableListPool;
       Preconditions.checkNotEmpty(fetchers);
       this.fetchers = fetchers;
       currentIndex = 0;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       this.priority = priority;
       this.callback = callback;
-      exceptions = exceptionListPool.acquire();
+      exceptions = throwableListPool.acquire();
       fetchers.get(currentIndex).loadData(priority, this);
+
+      // If a race occurred where we cancelled the fetcher in cancel() and then called loadData here
+      // immediately after, make sure that we cancel the newly started fetcher. We don't bother
+      // checking cancelled before loadData because it's not required for correctness and would
+      // require an unlikely race to be useful.
+      if (isCancelled) {
+        cancel();
+      }
     }
 
     @Override
     public void cleanup() {
       if (exceptions != null) {
-        exceptionListPool.release(exceptions);
+        throwableListPool.release(exceptions);
       }
       exceptions = null;
       for (DataFetcher<Data> fetcher : fetchers) {
@@ -109,6 +121,7 @@ public void cleanup() {
 
     @Override
     public void cancel() {
+      isCancelled = true;
       for (DataFetcher<Data> fetcher : fetchers) {
         fetcher.cancel();
       }
@@ -127,7 +140,7 @@ public DataSource getDataSource() {
     }
 
     @Override
-    public void onDataReady(Data data) {
+    public void onDataReady(@Nullable Data data) {
       if (data != null) {
         callback.onDataReady(data);
       } else {
@@ -136,16 +149,21 @@ public void onDataReady(Data data) {
     }
 
     @Override
-    public void onLoadFailed(Exception e) {
-      exceptions.add(e);
+    public void onLoadFailed(@NonNull Exception e) {
+      Preconditions.checkNotNull(exceptions).add(e);
       startNextOrFail();
     }
 
     private void startNextOrFail() {
+      if (isCancelled) {
+        return;
+      }
+
       if (currentIndex < fetchers.size() - 1) {
         currentIndex++;
         loadData(priority, callback);
       } else {
+        Preconditions.checkNotNull(exceptions);
         callback.onLoadFailed(new GlideException("Fetch failed", new ArrayList<>(exceptions)));
       }
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index 4c63136a5..4df5ac65c 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.Nullable;
-import android.support.v4.util.Pools.Pool;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.core.util.Pools.Pool;
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.util.Preconditions;
@@ -16,51 +18,65 @@
  * Capable of building an {@link ModelLoader} that wraps one or more other {@link ModelLoader}s for
  * a given model and data class.
  */
+// Hides Model throughout.
+@SuppressWarnings("TypeParameterHidesVisibleType")
 public class MultiModelLoaderFactory {
   private static final Factory DEFAULT_FACTORY = new Factory();
   private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
   private final List<Entry<?, ?>> entries = new ArrayList<>();
   private final Factory factory;
   private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
-  private final Pool<List<Exception>> exceptionListPool;
+  private final Pool<List<Throwable>> throwableListPool;
 
-  public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
-    this(exceptionListPool, DEFAULT_FACTORY);
+  public MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool) {
+    this(throwableListPool, DEFAULT_FACTORY);
   }
 
-  // Visible for testing.
-  MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool,
-      Factory factory) {
-    this.exceptionListPool = exceptionListPool;
+  @VisibleForTesting
+  MultiModelLoaderFactory(
+      @NonNull Pool<List<Throwable>> throwableListPool, @NonNull Factory factory) {
+    this.throwableListPool = throwableListPool;
     this.factory = factory;
   }
 
-  synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
-    add(modelClass, dataClass, factory, true /*append*/);
+  synchronized <Model, Data> void append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    add(modelClass, dataClass, factory, /*append=*/ true);
   }
 
-  synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
-    add(modelClass, dataClass, factory, false /*append*/);
+  synchronized <Model, Data> void prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    add(modelClass, dataClass, factory, /*append=*/ false);
   }
 
-  private <Model, Data> void add(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory, boolean append) {
+  private <Model, Data> void add(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory,
+      boolean append) {
     Entry<Model, Data> entry = new Entry<>(modelClass, dataClass, factory);
     entries.add(append ? entries.size() : 0, entry);
   }
 
-  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> replace(Class<Model> modelClass,
-      Class<Data> dataClass, ModelLoaderFactory<Model, Data> factory) {
-    List<ModelLoaderFactory<Model, Data>> removed = remove(modelClass, dataClass);
+  @NonNull
+  synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    List<ModelLoaderFactory<? extends Model, ? extends Data>> removed =
+        remove(modelClass, dataClass);
     append(modelClass, dataClass, factory);
     return removed;
   }
 
-  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> remove(Class<Model> modelClass,
-      Class<Data> dataClass) {
-    List<ModelLoaderFactory<Model, Data>> factories = new ArrayList<>();
+  @NonNull
+  synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> remove(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass) {
+    List<ModelLoaderFactory<? extends Model, ? extends Data>> factories = new ArrayList<>();
     for (Iterator<Entry<?, ?>> iterator = entries.iterator(); iterator.hasNext(); ) {
       Entry<?, ?> entry = iterator.next();
       if (entry.handles(modelClass, dataClass)) {
@@ -71,7 +87,8 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     return factories;
   }
 
-  synchronized <Model> List<ModelLoader<Model, ?>> build(Class<Model> modelClass) {
+  @NonNull
+  synchronized <Model> List<ModelLoader<Model, ?>> build(@NonNull Class<Model> modelClass) {
     try {
       List<ModelLoader<Model, ?>> loaders = new ArrayList<>();
       for (Entry<?, ?> entry : entries) {
@@ -96,7 +113,8 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     }
   }
 
-  synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+  @NonNull
+  synchronized List<Class<?>> getDataClasses(@NonNull Class<?> modelClass) {
     List<Class<?>> result = new ArrayList<>();
     for (Entry<?, ?> entry : entries) {
       if (!result.contains(entry.dataClass) && entry.handles(modelClass)) {
@@ -106,8 +124,9 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     return result;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
-      Class<Data> dataClass) {
+  @NonNull
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass) {
     try {
       List<ModelLoader<Model, Data>> loaders = new ArrayList<>();
       boolean ignoredAnyEntries = false;
@@ -128,7 +147,7 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
         }
       }
       if (loaders.size() > 1) {
-        return factory.build(loaders, exceptionListPool);
+        return factory.build(loaders, throwableListPool);
       } else if (loaders.size() == 1) {
         return loaders.get(0);
       } else {
@@ -147,16 +166,19 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
     }
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(Entry<?, ?> entry) {
+  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(@NonNull Entry<?, ?> entry) {
     return (ModelLoaderFactory<Model, Data>) entry.factory;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
+  private <Model, Data> ModelLoader<Model, Data> build(@NonNull Entry<?, ?> entry) {
     return (ModelLoader<Model, Data>) Preconditions.checkNotNull(entry.factory.build(this));
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <Model, Data> ModelLoader<Model, Data> emptyModelLoader() {
     return (ModelLoader<Model, Data>) EMPTY_MODEL_LOADER;
@@ -165,44 +187,48 @@ public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
   private static class Entry<Model, Data> {
     private final Class<Model> modelClass;
     @Synthetic final Class<Data> dataClass;
-    @Synthetic final ModelLoaderFactory<Model, Data> factory;
+    @Synthetic final ModelLoaderFactory<? extends Model, ? extends Data> factory;
 
-    public Entry(Class<Model> modelClass, Class<Data> dataClass,
-        ModelLoaderFactory<Model, Data> factory) {
+    public Entry(
+        @NonNull Class<Model> modelClass,
+        @NonNull Class<Data> dataClass,
+        @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
       this.modelClass = modelClass;
       this.dataClass = dataClass;
       this.factory = factory;
     }
 
-    public boolean handles(Class<?> modelClass, Class<?> dataClass) {
+    public boolean handles(@NonNull Class<?> modelClass, @NonNull Class<?> dataClass) {
       return handles(modelClass) && this.dataClass.isAssignableFrom(dataClass);
     }
 
-    public boolean handles(Class<?> modelClass) {
+    public boolean handles(@NonNull Class<?> modelClass) {
       return this.modelClass.isAssignableFrom(modelClass);
     }
   }
 
   static class Factory {
+    @NonNull
     public <Model, Data> MultiModelLoader<Model, Data> build(
-        List<ModelLoader<Model, Data>> modelLoaders, Pool<List<Exception>> exceptionListPool) {
-      return new MultiModelLoader<>(modelLoaders, exceptionListPool);
+        @NonNull List<ModelLoader<Model, Data>> modelLoaders,
+        @NonNull Pool<List<Throwable>> throwableListPool) {
+      return new MultiModelLoader<>(modelLoaders, throwableListPool);
     }
   }
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
-
     @Synthetic
-    EmptyModelLoader() { }
+    EmptyModelLoader() {}
 
     @Nullable
     @Override
-    public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
+    public LoadData<Object> buildLoadData(
+        @NonNull Object o, int width, int height, @NonNull Options options) {
       return null;
     }
 
     @Override
-    public boolean handles(Object o) {
+    public boolean handles(@NonNull Object o) {
       return false;
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 602fac513..2c9087c27 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import java.io.InputStream;
 
@@ -20,13 +22,16 @@
   private final ModelLoader<Uri, Data> uriLoader;
   private final Resources resources;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     this.resources = resources;
     this.uriLoader = uriLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Integer model, int width, int height, Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Integer model, int width, int height, @NonNull Options options) {
     Uri uri = getResourceUri(model);
     return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
@@ -34,10 +39,14 @@ public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
   @Nullable
   private Uri getResourceUri(Integer model) {
     try {
-      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://"
-          + resources.getResourcePackageName(model) + '/'
-          + resources.getResourceTypeName(model) + '/'
-          + resources.getResourceEntryName(model));
+      return Uri.parse(
+          ContentResolver.SCHEME_ANDROID_RESOURCE
+              + "://"
+              + resources.getResourcePackageName(model)
+              + '/'
+              + resources.getResourceTypeName(model)
+              + '/'
+              + resources.getResourceEntryName(model));
     } catch (Resources.NotFoundException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
         Log.w(TAG, "Received invalid resource id: " + model, e);
@@ -47,14 +56,12 @@ private Uri getResourceUri(Integer model) {
   }
 
   @Override
-  public boolean handles(Integer model) {
+  public boolean handles(@NonNull Integer model) {
     // TODO: check that this is in fact a resource id.
     return true;
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from Android resource ids.
-   */
+  /** Factory for loading {@link InputStream}s from Android resource ids. */
   public static class StreamFactory implements ModelLoaderFactory<Integer, InputStream> {
 
     private final Resources resources;
@@ -63,6 +70,7 @@ public StreamFactory(Resources resources) {
       this.resources = resources;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Integer, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new ResourceLoader<>(resources, multiFactory.build(Uri.class, InputStream.class));
@@ -74,9 +82,7 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for loading {@link ParcelFileDescriptor}s from Android resource ids.
-   */
+  /** Factory for loading {@link ParcelFileDescriptor}s from Android resource ids. */
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
 
@@ -86,6 +92,7 @@ public FileDescriptorFactory(Resources resources) {
       this.resources = resources;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Integer, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new ResourceLoader<>(
@@ -98,9 +105,29 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for loading resource {@link Uri}s from Android resource ids.
-   */
+  /** Loads {@link AssetFileDescriptor}s from resource ids. */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Integer, AssetFileDescriptor> {
+
+    private final Resources resources;
+
+    public AssetFileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @Override
+    public ModelLoader<Integer, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /** Factory for loading resource {@link Uri}s from Android resource ids. */
   public static class UriFactory implements ModelLoaderFactory<Integer, Uri> {
 
     private final Resources resources;
@@ -109,9 +136,10 @@ public UriFactory(Resources resources) {
       this.resources = resources;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Integer, Uri> build(MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(resources, new UnitModelLoader<Uri>());
+      return new ResourceLoader<>(resources, UnitModelLoader.<Uri>getInstance());
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 28a06ca9e..1a6bc462e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -11,8 +12,7 @@
 import java.io.OutputStream;
 
 /**
- * An {@link com.bumptech.glide.load.Encoder} that can write an {@link java.io.InputStream} to
- * disk.
+ * An {@link com.bumptech.glide.load.Encoder} that can write an {@link java.io.InputStream} to disk.
  */
 public class StreamEncoder implements Encoder<InputStream> {
   private static final String TAG = "StreamEncoder";
@@ -23,7 +23,7 @@ public StreamEncoder(ArrayPool byteArrayPool) {
   }
 
   @Override
-  public boolean encode(InputStream data, File file, Options options) {
+  public boolean encode(@NonNull InputStream data, @NonNull File file, @NonNull Options options) {
     byte[] buffer = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     boolean success = false;
     OutputStream os = null;
@@ -47,7 +47,7 @@ public boolean encode(InputStream data, File file, Options options) {
           // Do nothing.
         }
       }
-      byteArrayPool.put(buffer, byte[].class);
+      byteArrayPool.put(buffer);
     }
     return success;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 62061cf16..9c86c1ac3 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,9 +1,11 @@
 package com.bumptech.glide.load.model;
 
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import java.io.File;
 import java.io.InputStream;
@@ -17,19 +19,26 @@
 public class StringLoader<Data> implements ModelLoader<String, Data> {
   private final ModelLoader<Uri, Data> uriLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public StringLoader(ModelLoader<Uri, Data> uriLoader) {
     this.uriLoader = uriLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(String model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull String model, int width, int height, @NonNull Options options) {
     Uri uri = parseUri(model);
-    return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
+    if (uri == null || !uriLoader.handles(uri)) {
+      return null;
+    }
+    return uriLoader.buildLoadData(uri, width, height, options);
   }
 
   @Override
-  public boolean handles(String model) {
+  public boolean handles(@NonNull String model) {
+    // Avoid parsing the Uri twice and simply return null from buildLoadData if we don't handle this
+    // particular Uri type.
     return true;
   }
 
@@ -38,7 +47,8 @@ private static Uri parseUri(String model) {
     Uri uri;
     if (TextUtils.isEmpty(model)) {
       return null;
-    } else if (model.startsWith("/")) {
+      // See https://pmd.github.io/pmd-6.0.0/pmd_rules_java_performance.html#simplifystartswith
+    } else if (model.charAt(0) == '/') {
       uri = toFileUri(model);
     } else {
       uri = Uri.parse(model);
@@ -54,13 +64,12 @@ private static Uri toFileUri(String path) {
     return Uri.fromFile(new File(path));
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from Strings.
-   */
+  /** Factory for loading {@link InputStream}s from Strings. */
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
@@ -70,14 +79,14 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for loading {@link ParcelFileDescriptor}s from Strings.
-   */
+  /** Factory for loading {@link ParcelFileDescriptor}s from Strings. */
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
+    @NonNull
     @Override
-    public ModelLoader<String, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, ParcelFileDescriptor> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
@@ -86,4 +95,20 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /** Loads {@link AssetFileDescriptor}s from Strings. */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<String, AssetFileDescriptor> {
+
+    @Override
+    public ModelLoader<String, AssetFileDescriptor> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
+      return new StringLoader<>(multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index 8a3eca114..043241d06 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.model;
 
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -14,15 +14,30 @@
  * @param <Model> The type of model that will also be returned as decodable data.
  */
 public class UnitModelLoader<Model> implements ModelLoader<Model, Model> {
+  @SuppressWarnings("deprecation")
+  private static final UnitModelLoader<?> INSTANCE = new UnitModelLoader<>();
+
+  @SuppressWarnings("unchecked")
+  public static <T> UnitModelLoader<T> getInstance() {
+    return (UnitModelLoader<T>) INSTANCE;
+  }
+
+  /** @deprecated Use {@link #getInstance()} instead. */
+  // Need constructor to document deprecation, will be removed, when constructor is privatized.
+  @SuppressWarnings({"PMD.UnnecessaryConstructor", "DeprecatedIsStillUsed"})
+  @Deprecated
+  public UnitModelLoader() {
+    // Intentionally empty.
+  }
 
   @Override
-  public LoadData<Model> buildLoadData(Model model, int width, int height,
-      Options options) {
+  public LoadData<Model> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new UnitFetcher<>(model));
   }
 
   @Override
-  public boolean handles(Model model) {
+  public boolean handles(@NonNull Model model) {
     return true;
   }
 
@@ -30,12 +45,13 @@ public boolean handles(Model model) {
 
     private final Model resource;
 
-    public UnitFetcher(Model resource) {
+    UnitFetcher(Model resource) {
       this.resource = resource;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Model> callback) {
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super Model> callback) {
       callback.onDataReady(resource);
     }
 
@@ -68,11 +84,29 @@ public DataSource getDataSource() {
    *
    * @param <Model> The type of model that will also be returned as decodable data.
    */
+  // PMD.SingleMethodSingleton false positive: https://github.com/pmd/pmd/issues/816
+  @SuppressWarnings("PMD.SingleMethodSingleton")
   public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
+    @SuppressWarnings("deprecation")
+    private static final Factory<?> FACTORY = new Factory<>();
+
+    @SuppressWarnings("unchecked")
+    public static <T> Factory<T> getInstance() {
+      return (Factory<T>) FACTORY;
+    }
 
+    /** @deprecated Use {@link #getInstance()} instead. */
+    // Need constructor to document deprecation, will be removed, when constructor is privatized.
+    @SuppressWarnings("PMD.UnnecessaryConstructor")
+    @Deprecated
+    public Factory() {
+      // Intentionally empty.
+    }
+
+    @NonNull
     @Override
     public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
-      return new UnitModelLoader<>();
+      return UnitModelLoader.getInstance();
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index 26cc3be5f..543ee9dbc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,9 +1,12 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.AssetFileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
@@ -15,38 +18,38 @@
 import java.util.Set;
 
 /**
- * A ModelLoader for {@link android.net.Uri}s that handles local {@link android.net.Uri}s
- * directly and routes remote {@link android.net.Uri}s to a wrapped
- * {@link com.bumptech.glide.load.model.ModelLoader} that handles
- * {@link com.bumptech.glide.load.model.GlideUrl}s.
+ * A ModelLoader for {@link android.net.Uri}s that handles local {@link android.net.Uri}s directly
+ * and routes remote {@link android.net.Uri}s to a wrapped {@link
+ * com.bumptech.glide.load.model.ModelLoader} that handles {@link
+ * com.bumptech.glide.load.model.GlideUrl}s.
  *
  * @param <Data> The type of data that will be retrieved for {@link android.net.Uri}s.
  */
 public class UriLoader<Data> implements ModelLoader<Uri, Data> {
-  private static final Set<String> SCHEMES = Collections.unmodifiableSet(
-      new HashSet<>(
-          Arrays.asList(
-              ContentResolver.SCHEME_FILE,
-              ContentResolver.SCHEME_ANDROID_RESOURCE,
-              ContentResolver.SCHEME_CONTENT
-          )
-      )
-  );
+  private static final Set<String> SCHEMES =
+      Collections.unmodifiableSet(
+          new HashSet<>(
+              Arrays.asList(
+                  ContentResolver.SCHEME_FILE,
+                  ContentResolver.SCHEME_ANDROID_RESOURCE,
+                  ContentResolver.SCHEME_CONTENT)));
 
   private final LocalUriFetcherFactory<Data> factory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UriLoader(LocalUriFetcherFactory<Data> factory) {
     this.factory = factory;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
@@ -59,11 +62,9 @@ public boolean handles(Uri model) {
     DataFetcher<Data> build(Uri uri);
   }
 
-  /**
-   * Loads {@link InputStream}s from {@link Uri}s.
-   */
-  public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
-      LocalUriFetcherFactory<InputStream> {
+  /** Loads {@link InputStream}s from {@link Uri}s. */
+  public static class StreamFactory
+      implements ModelLoaderFactory<Uri, InputStream>, LocalUriFetcherFactory<InputStream> {
 
     private final ContentResolver contentResolver;
 
@@ -76,6 +77,7 @@ public StreamFactory(ContentResolver contentResolver) {
       return new StreamLocalUriFetcher(contentResolver, uri);
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UriLoader<>(this);
@@ -87,12 +89,10 @@ public void teardown() {
     }
   }
 
-  /**
-   * Loads {@link ParcelFileDescriptor}s from {@link Uri}s.
-   */
-  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
-      ParcelFileDescriptor>,
-      LocalUriFetcherFactory<ParcelFileDescriptor> {
+  /** Loads {@link ParcelFileDescriptor}s from {@link Uri}s. */
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<Uri, ParcelFileDescriptor>,
+          LocalUriFetcherFactory<ParcelFileDescriptor> {
 
     private final ContentResolver contentResolver;
 
@@ -105,6 +105,7 @@ public FileDescriptorFactory(ContentResolver contentResolver) {
       return new FileDescriptorLocalUriFetcher(contentResolver, uri);
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new UriLoader<>(this);
@@ -115,4 +116,31 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /** Loads {@link AssetFileDescriptor}s from {@link Uri}s. */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Uri, AssetFileDescriptor>,
+          LocalUriFetcherFactory<AssetFileDescriptor> {
+
+    private final ContentResolver contentResolver;
+
+    public AssetFileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
+    @Override
+    public ModelLoader<Uri, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+
+    @Override
+    public DataFetcher<AssetFileDescriptor> build(Uri uri) {
+      return new AssetFileDescriptorLocalUriFetcher(contentResolver, uri);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index af2f2459a..5bd95f0b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import java.io.InputStream;
 import java.util.Arrays;
@@ -15,37 +16,35 @@
  * @param <Data> The type of data this Loader will obtain for a {@link Uri}.
  */
 public class UrlUriLoader<Data> implements ModelLoader<Uri, Data> {
-  private static final Set<String> SCHEMES = Collections.unmodifiableSet(
-      new HashSet<>(
-          Arrays.asList(
-              "http",
-              "https"
-          )
-      )
-  );
+  private static final Set<String> SCHEMES =
+      Collections.unmodifiableSet(new HashSet<>(Arrays.asList("http", "https")));
   private final ModelLoader<GlideUrl, Data> urlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UrlUriLoader(ModelLoader<GlideUrl, Data> urlLoader) {
     this.urlLoader = urlLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri uri, int width, int height, Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Uri uri, int width, int height, @NonNull Options options) {
     GlideUrl glideUrl = new GlideUrl(uri.toString());
     return urlLoader.buildLoadData(glideUrl, width, height, options);
   }
 
   @Override
-  public boolean handles(Uri uri) {
+  public boolean handles(@NonNull Uri uri) {
     return SCHEMES.contains(uri.getScheme());
   }
 
   /**
-   * Loads {@link java.io.InputStream InputStreams} from {@link android.net.Uri Uris} with http
-   * or https schemes.
+   * Loads {@link java.io.InputStream InputStreams} from {@link android.net.Uri Uris} with http or
+   * https schemes.
    */
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index d2944e47e..ca65b5147 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -10,6 +11,7 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -27,7 +29,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader)
     this(concreteLoader, null);
   }
 
-  protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+  protected BaseGlideUrlLoader(
+      ModelLoader<GlideUrl, InputStream> concreteLoader,
       @Nullable ModelCache<Model, GlideUrl> modelCache) {
     this.concreteLoader = concreteLoader;
     this.modelCache = modelCache;
@@ -35,7 +38,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(Model model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options) {
     GlideUrl result = null;
     if (modelCache != null) {
       result = modelCache.get(model, width, height);
@@ -57,17 +61,21 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     // TODO: this is expensive and slow to calculate every time, we should either cache these, or
     // try to come up with a way to avoid finding them when not necessary.
     List<String> alternateUrls = getAlternateUrls(model, width, height, options);
-    LoadData<InputStream> concreteLoaderData = concreteLoader.buildLoadData(result, width, height,
-        options);
-    if (alternateUrls.isEmpty()) {
+    LoadData<InputStream> concreteLoaderData =
+        concreteLoader.buildLoadData(result, width, height, options);
+    if (concreteLoaderData == null || alternateUrls.isEmpty()) {
       return concreteLoaderData;
     } else {
-      return new LoadData<>(concreteLoaderData.sourceKey, getAlternateKeys(alternateUrls),
+      return new LoadData<>(
+          concreteLoaderData.sourceKey,
+          getAlternateKeys(alternateUrls),
           concreteLoaderData.fetcher);
     }
   }
 
-  private static List<Key> getAlternateKeys(List<String> alternateUrls) {
+  // Creating a limited number of objects as the sole purpose of the loop.
+  @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+  private static List<Key> getAlternateKeys(Collection<String> alternateUrls) {
     List<Key> result = new ArrayList<>(alternateUrls.size());
     for (String alternate : alternateUrls) {
       result.add(new GlideUrl(alternate));
@@ -78,8 +86,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
   /**
    * Returns a valid url http:// or https:// for the given model and dimensions as a string.
    *
-   * @param model  The model.
-   * @param width  The width in pixels of the view/target the image will be loaded into.
+   * @param model The model.
+   * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
   protected abstract String getUrl(Model model, int width, int height, Options options);
@@ -89,14 +97,13 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
    * data can be obtained (usually the same image with the same aspect ratio, but in a larger size)
    * as the primary url.
    *
-   * <p> Implementing this method allows Glide to fulfill requests for bucketed images in smaller
-   * bucket sizes using already cached data for larger bucket sizes. </p>
+   * <p>Implementing this method allows Glide to fulfill requests for bucketed images in smaller
+   * bucket sizes using already cached data for larger bucket sizes.
    *
-   * @param width  The width in pixels of the view/target the image will be loaded into.
+   * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
-  protected List<String> getAlternateUrls(Model model, int width, int height,
-      Options options) {
+  protected List<String> getAlternateUrls(Model model, int width, int height, Options options) {
     return Collections.emptyList();
   }
 
@@ -108,6 +115,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
    * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   @Nullable
   protected Headers getHeaders(Model model, int width, int height, Options options) {
     return Headers.DEFAULT;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index d29625946..27776cba8 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
@@ -15,6 +16,8 @@
  * An {@link com.bumptech.glide.load.model.ModelLoader} for translating {@link
  * com.bumptech.glide.load.model.GlideUrl} (http/https URLS) into {@link java.io.InputStream} data.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class HttpGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
   /**
    * An integer option that is used to determine the maximum connect and read timeout durations (in
@@ -22,8 +25,8 @@
    *
    * <p>Defaults to 2500ms.
    */
-  public static final Option<Integer> TIMEOUT = Option.memory(
-      "com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout", 2500);
+  public static final Option<Integer> TIMEOUT =
+      Option.memory("com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout", 2500);
 
   @Nullable private final ModelCache<GlideUrl, GlideUrl> modelCache;
 
@@ -31,13 +34,13 @@ public HttpGlideUrlLoader() {
     this(null);
   }
 
-  public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
+  public HttpGlideUrlLoader(@Nullable ModelCache<GlideUrl, GlideUrl> modelCache) {
     this.modelCache = modelCache;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull GlideUrl model, int width, int height, @NonNull Options options) {
     // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time
     // spent parsing urls.
     GlideUrl url = model;
@@ -53,16 +56,15 @@ public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
   }
 
   @Override
-  public boolean handles(GlideUrl model) {
+  public boolean handles(@NonNull GlideUrl model) {
     return true;
   }
 
-  /**
-   * The default factory for {@link HttpGlideUrlLoader}s.
-   */
+  /** The default factory for {@link HttpGlideUrlLoader}s. */
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
+    @NonNull
     @Override
     public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpGlideUrlLoader(modelCache);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index 37b1e12fa..5f9cc96b9 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model.stream;
 
 import android.net.Uri;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -12,34 +13,34 @@
 import java.util.HashSet;
 import java.util.Set;
 
-/**
- * Loads {@link InputStream}s from http or https {@link Uri}s.
- */
+/** Loads {@link InputStream}s from http or https {@link Uri}s. */
 public class HttpUriLoader implements ModelLoader<Uri, InputStream> {
   private static final Set<String> SCHEMES =
       Collections.unmodifiableSet(new HashSet<>(Arrays.asList("http", "https")));
 
   private final ModelLoader<GlideUrl, InputStream> urlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public HttpUriLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
     this.urlLoader = urlLoader;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     return urlLoader.buildLoadData(new GlideUrl(model.toString()), width, height, options);
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from http/https {@link Uri}s.
-   */
+  /** Factory for loading {@link InputStream}s from http/https {@link Uri}s. */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index c10cfc90a..8f1b08da0 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
@@ -16,14 +17,17 @@
  * thumbnails for those {@link Uri}s in the media store.
  */
 public class MediaStoreImageThumbLoader implements ModelLoader<Uri, InputStream> {
-  public final Context context;
+  private final Context context;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public MediaStoreImageThumbLoader(Context context) {
     this.context = context.getApplicationContext();
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height)) {
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildImageFetcher(context, model));
     } else {
@@ -32,13 +36,11 @@ public MediaStoreImageThumbLoader(Context context) {
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreImageUri(model);
   }
 
-  /**
-   * Factory that loads {@link InputStream}s from media store image {@link Uri}s.
-   */
+  /** Factory that loads {@link InputStream}s from media store image {@link Uri}s. */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
     private final Context context;
@@ -47,6 +49,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreImageThumbLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 2263f1cc5..b54ed7e58 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -2,14 +2,15 @@
 
 import android.content.Context;
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.signature.ObjectKey;
 import java.io.InputStream;
 
@@ -17,23 +18,25 @@
  * Loads {@link InputStream}s from media store video {@link Uri}s that point to pre-generated
  * thumbnails for those {@link Uri}s in the media store.
  *
- * <p>If {@link VideoBitmapDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
- * {@link VideoBitmapDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
- * store does not use a defined frame to generate the thumbnail, so we cannot accurately fulfill
- * requests for specific frames.
+ * <p>If {@link VideoDecoder#TARGET_FRAME} is set with a non-null value that is not equal to {@link
+ * VideoDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media store does
+ * not use a defined frame to generate the thumbnail, so we cannot accurately fulfill requests for
+ * specific frames.
  */
 public class MediaStoreVideoThumbLoader implements ModelLoader<Uri, InputStream> {
   private final Context context;
 
-  MediaStoreVideoThumbLoader(Context context) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public MediaStoreVideoThumbLoader(Context context) {
     this.context = context.getApplicationContext();
   }
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
-      // TODO(nnaze): Tighten down this call to just the dependencies neede by buildVideoFetcher
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
       return null;
@@ -41,12 +44,12 @@
   }
 
   private boolean isRequestingDefaultFrame(Options options) {
-    Long specifiedFrame = options.get(VideoBitmapDecoder.TARGET_FRAME);
-    return specifiedFrame != null && specifiedFrame == VideoBitmapDecoder.DEFAULT_FRAME;
+    Long specifiedFrame = options.get(VideoDecoder.TARGET_FRAME);
+    return specifiedFrame != null && specifiedFrame == VideoDecoder.DEFAULT_FRAME;
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreVideoUri(model);
   }
 
@@ -62,6 +65,7 @@ public Factory(Context context) {
       this.context = context;
     }
 
+    @NonNull
     @Override
     public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreVideoThumbLoader(context);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index 1dc7951d4..d0bdda0e1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model.stream;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -17,25 +18,27 @@
 public class UrlLoader implements ModelLoader<URL, InputStream> {
   private final ModelLoader<GlideUrl, InputStream> glideUrlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UrlLoader(ModelLoader<GlideUrl, InputStream> glideUrlLoader) {
     this.glideUrlLoader = glideUrlLoader;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(URL model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull URL model, int width, int height, @NonNull Options options) {
     return glideUrlLoader.buildLoadData(new GlideUrl(model), width, height, options);
   }
 
   @Override
-  public boolean handles(URL model) {
+  public boolean handles(@NonNull URL model) {
     return true;
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from {@link URL}s.
-   */
+  /** Factory for loading {@link InputStream}s from {@link URL}s. */
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
+    @NonNull
     @Override
     public ModelLoader<URL, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/ImageDecoderResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/ImageDecoderResourceDecoder.java
new file mode 100644
index 000000000..11c8da20f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/ImageDecoderResourceDecoder.java
@@ -0,0 +1,135 @@
+package com.bumptech.glide.load.resource;
+
+import android.annotation.SuppressLint;
+import android.graphics.ImageDecoder;
+import android.graphics.ImageDecoder.DecodeException;
+import android.graphics.ImageDecoder.ImageInfo;
+import android.graphics.ImageDecoder.OnHeaderDecodedListener;
+import android.graphics.ImageDecoder.OnPartialImageListener;
+import android.graphics.ImageDecoder.Source;
+import android.util.Log;
+import android.util.Size;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.HardwareConfigState;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Synthetic;
+import java.io.IOException;
+
+/**
+ * Downsamples, decodes, and rotates images according to their exif orientation using {@link
+ * ImageDecoder}.
+ *
+ * <p>Obeys all options in {@link Downsampler} except for {@link
+ * Downsampler#FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS}.
+ *
+ * @param <T> The type of resource to be decoded (Bitmap, Drawable etc).
+ */
+@RequiresApi(api = 28)
+public abstract class ImageDecoderResourceDecoder<T> implements ResourceDecoder<Source, T> {
+  private static final String TAG = "ImageDecoder";
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();
+
+  @Override
+  public final boolean handles(@NonNull Source source, @NonNull Options options) {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public final Resource<T> decode(
+      @NonNull Source source,
+      final int requestedWidth,
+      final int requestedHeight,
+      @NonNull Options options)
+      throws IOException {
+    final DecodeFormat decodeFormat = options.get(Downsampler.DECODE_FORMAT);
+    final DownsampleStrategy strategy = options.get(DownsampleStrategy.OPTION);
+    final boolean isHardwareConfigAllowed =
+        options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null
+            && options.get(Downsampler.ALLOW_HARDWARE_CONFIG);
+
+    return decode(
+        source,
+        requestedWidth,
+        requestedHeight,
+        new OnHeaderDecodedListener() {
+          @SuppressLint("Override")
+          @Override
+          public void onHeaderDecoded(ImageDecoder decoder, ImageInfo info, Source source) {
+            if (hardwareConfigState.isHardwareConfigAllowed(
+                requestedWidth,
+                requestedHeight,
+                isHardwareConfigAllowed,
+                /*isExifOrientationRequired=*/ false)) {
+              decoder.setAllocator(ImageDecoder.ALLOCATOR_HARDWARE);
+            } else {
+              decoder.setAllocator(ImageDecoder.ALLOCATOR_SOFTWARE);
+            }
+
+            if (decodeFormat == DecodeFormat.PREFER_RGB_565) {
+              decoder.setMemorySizePolicy(ImageDecoder.MEMORY_POLICY_LOW_RAM);
+            }
+
+            decoder.setOnPartialImageListener(
+                new OnPartialImageListener() {
+                  @Override
+                  public boolean onPartialImage(@NonNull DecodeException e) {
+                    // Never return partial images.
+                    return false;
+                  }
+                });
+
+            Size size = info.getSize();
+            int targetWidth = requestedWidth;
+            if (requestedWidth == Target.SIZE_ORIGINAL) {
+              targetWidth = size.getWidth();
+            }
+            int targetHeight = requestedHeight;
+            if (requestedHeight == Target.SIZE_ORIGINAL) {
+              targetHeight = size.getHeight();
+            }
+
+            float scaleFactor =
+                strategy.getScaleFactor(
+                    size.getWidth(), size.getHeight(), targetWidth, targetHeight);
+
+            int resizeWidth = Math.round(scaleFactor * size.getWidth());
+            int resizeHeight = Math.round(scaleFactor * size.getHeight());
+            if (Log.isLoggable(TAG, Log.VERBOSE)) {
+              Log.v(
+                  TAG,
+                  "Resizing"
+                      + " from ["
+                      + size.getWidth()
+                      + "x"
+                      + size.getHeight()
+                      + "]"
+                      + " to ["
+                      + resizeWidth
+                      + "x"
+                      + resizeHeight
+                      + "]"
+                      + " scaleFactor: "
+                      + scaleFactor);
+            }
+
+            decoder.setTargetSize(resizeWidth, resizeHeight);
+          }
+        });
+  }
+
+  protected abstract Resource<T> decode(
+      Source source, int requestedWidth, int requestedHeight, OnHeaderDecodedListener listener)
+      throws IOException;
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
index 5291061e0..5ea377991 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
@@ -14,16 +15,18 @@
 public class SimpleResource<T> implements Resource<T> {
   protected final T data;
 
-  public SimpleResource(T data) {
+  public SimpleResource(@NonNull T data) {
     this.data = Preconditions.checkNotNull(data);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   @Override
   public Class<T> getResourceClass() {
     return (Class<T>) data.getClass();
   }
 
+  @NonNull
   @Override
   public final T get() {
     return data;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index 023e2d978..563a3181a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -1,17 +1,18 @@
 package com.bumptech.glide.load.resource;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import java.security.MessageDigest;
 
 /**
- * A noop Transformation that simply returns the given resource.
+ * A no-op Transformation that simply returns the given resource.
  *
  * @param <T> The type of the resource that will always be returned unmodified.
  */
 public final class UnitTransformation<T> implements Transformation<T> {
-  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();
+  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<>();
 
   /**
    * Returns a UnitTransformation for the given type.
@@ -19,6 +20,7 @@
    * @param <T> The type of the resource to be transformed.
    */
   @SuppressWarnings("unchecked")
+  @NonNull
   public static <T> UnitTransformation<T> get() {
     return (UnitTransformation<T>) TRANSFORMATION;
   }
@@ -27,13 +29,15 @@ private UnitTransformation() {
     // Only accessible as a singleton.
   }
 
+  @NonNull
   @Override
-  public Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(
+      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {
     return resource;
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
index 5a0f9064d..1213b1040 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -4,7 +4,7 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -21,32 +21,41 @@
 
   private final ResourceDecoder<DataType, Bitmap> decoder;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public BitmapDrawableDecoder(Context context, ResourceDecoder<DataType, Bitmap> decoder) {
-    this(context.getResources(), Glide.get(context).getBitmapPool(), decoder);
+    this(context.getResources(), decoder);
   }
 
-  public BitmapDrawableDecoder(Resources resources, BitmapPool bitmapPool,
+  /**
+   * @deprecated Use {@link #BitmapDrawableDecoder(Context, ResourceDecoder)}, {@code bitmapPool} is
+   *     ignored.
+   */
+  @Deprecated
+  public BitmapDrawableDecoder(
+      Resources resources,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       ResourceDecoder<DataType, Bitmap> decoder) {
+    this(resources, decoder);
+  }
+
+  public BitmapDrawableDecoder(
+      @NonNull Resources resources, @NonNull ResourceDecoder<DataType, Bitmap> decoder) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.decoder = Preconditions.checkNotNull(decoder);
   }
 
   @Override
-  public boolean handles(DataType source, Options options) throws IOException {
+  public boolean handles(@NonNull DataType source, @NonNull Options options) throws IOException {
     return decoder.handles(source, options);
   }
 
   @Override
-  public Resource<BitmapDrawable> decode(DataType source, int width, int height, Options options)
+  public Resource<BitmapDrawable> decode(
+      @NonNull DataType source, int width, int height, @NonNull Options options)
       throws IOException {
     Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);
-    if (bitmapResource == null) {
-      return null;
-    }
-
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, bitmapResource.get());
+    return LazyBitmapDrawableResource.obtain(resources, bitmapResource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
index a414e6dd0..cb9b835e7 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
@@ -9,9 +10,7 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import java.io.File;
 
-/**
- * Encodes {@link android.graphics.drawable.BitmapDrawable}s.
- */
+/** Encodes {@link android.graphics.drawable.BitmapDrawable}s. */
 public class BitmapDrawableEncoder implements ResourceEncoder<BitmapDrawable> {
 
   private final BitmapPool bitmapPool;
@@ -23,12 +22,14 @@ public BitmapDrawableEncoder(BitmapPool bitmapPool, ResourceEncoder<Bitmap> enco
   }
 
   @Override
-  public boolean encode(Resource<BitmapDrawable> data, File file, Options options) {
+  public boolean encode(
+      @NonNull Resource<BitmapDrawable> data, @NonNull File file, @NonNull Options options) {
     return encoder.encode(new BitmapResource(data.get().getBitmap(), bitmapPool), file, options);
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return encoder.getEncodeStrategy(options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index 989664e20..5718a75c5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,30 +1,33 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 import com.bumptech.glide.util.Util;
 
 /**
- * A {@link com.bumptech.glide.load.engine.Resource} that wraps an
- * {@link android.graphics.drawable.BitmapDrawable}
+ * A {@link com.bumptech.glide.load.engine.Resource} that wraps an {@link
+ * android.graphics.drawable.BitmapDrawable}
  *
- * <p> This class ensures that every call to {@link #get()}} always returns a new
- * {@link android.graphics.drawable.BitmapDrawable} to avoid rendering issues if used in multiple
- * views and is also responsible for returning the underlying {@link android.graphics.Bitmap} to the
- * given {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is
- * recycled. </p>
+ * <p>This class ensures that every call to {@link #get()}} always returns a new {@link
+ * android.graphics.drawable.BitmapDrawable} to avoid rendering issues if used in multiple views and
+ * is also responsible for returning the underlying {@link android.graphics.Bitmap} to the given
+ * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is recycled.
  */
 public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>
     implements Initializable {
   private final BitmapPool bitmapPool;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
     super(drawable);
     this.bitmapPool = bitmapPool;
   }
 
+  @NonNull
   @Override
   public Class<BitmapDrawable> getResourceClass() {
     return BitmapDrawable.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index 41ea33a35..8e1ce63c3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -4,9 +4,9 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import java.security.MessageDigest;
 
@@ -20,35 +20,20 @@
 
   private final Transformation<Drawable> wrapped;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
-    this.wrapped = Preconditions.checkNotNull(new DrawableTransformation(wrapped));
-  }
-
-  /**
-   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
-   */
-  @Deprecated
-  public BitmapDrawableTransformation(
-      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
-    this(wrapped);
-  }
-
-  /**
-   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
-   */
-  @Deprecated
-  public BitmapDrawableTransformation(
-      @SuppressWarnings("unused") Context context,
-      @SuppressWarnings("unused") BitmapPool bitmapPool,
-      Transformation<Bitmap> wrapped) {
-    this(wrapped);
+    this.wrapped =
+        Preconditions.checkNotNull(new DrawableTransformation(wrapped, /*isRequired=*/ false));
   }
 
+  @NonNull
   @Override
   public Resource<BitmapDrawable> transform(
-      Context context, Resource<BitmapDrawable> drawableResourceToTransform, int outWidth,
+      @NonNull Context context,
+      @NonNull Resource<BitmapDrawable> drawableResourceToTransform,
+      int outWidth,
       int outHeight) {
-
     Resource<Drawable> toTransform = convertToDrawableResource(drawableResourceToTransform);
     Resource<Drawable> transformed = wrapped.transform(context, toTransform, outWidth, outHeight);
     return convertToBitmapDrawableResource(transformed);
@@ -66,11 +51,11 @@ public BitmapDrawableTransformation(
   }
 
   @SuppressWarnings("unchecked")
-  private static Resource<Drawable> convertToDrawableResource(
-      Resource<BitmapDrawable> toConvert) {
+  private static Resource<Drawable> convertToDrawableResource(Resource<BitmapDrawable> toConvert) {
     return (Resource<Drawable>) (Resource<? extends Drawable>) toConvert;
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   public boolean equals(Object o) {
     if (o instanceof BitmapDrawableTransformation) {
@@ -86,7 +71,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index 8a2fdf327..4f948c28f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -1,15 +1,19 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-import android.support.v4.os.TraceCompat;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.data.BufferedOutputStream;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
+import com.bumptech.glide.util.pool.GlideTrace;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -19,42 +23,52 @@
  * An {@link com.bumptech.glide.load.ResourceEncoder} that writes {@link android.graphics.Bitmap}s
  * to {@link java.io.OutputStream}s.
  *
- * <p> {@link android.graphics.Bitmap}s that return true from
- * {@link android.graphics.Bitmap#hasAlpha ()}} are written using
- * {@link android.graphics.Bitmap.CompressFormat#PNG}
- * to preserve alpha and all other bitmaps are written using
- * {@link android.graphics.Bitmap.CompressFormat#JPEG}. </p>
+ * <p>{@link android.graphics.Bitmap}s that return true from {@link android.graphics.Bitmap#hasAlpha
+ * ()}} are written using {@link android.graphics.Bitmap.CompressFormat#PNG} to preserve alpha and
+ * all other bitmaps are written using {@link android.graphics.Bitmap.CompressFormat#JPEG}.
  *
  * @see android.graphics.Bitmap#compress(android.graphics.Bitmap.CompressFormat, int,
- * java.io.OutputStream)
+ *     java.io.OutputStream)
  */
 public class BitmapEncoder implements ResourceEncoder<Bitmap> {
   /**
    * An integer option between 0 and 100 that is used as the compression quality.
    *
-   * <p> Defaults to 90. </p>
+   * <p>Defaults to 90.
    */
-  public static final Option<Integer> COMPRESSION_QUALITY = Option.memory(
-      "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionQuality", 90);
+  public static final Option<Integer> COMPRESSION_QUALITY =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionQuality", 90);
 
   /**
-   * An {@link android.graphics.Bitmap.CompressFormat} option used as the format to encode
-   * the {@link android.graphics.Bitmap}.
+   * An {@link android.graphics.Bitmap.CompressFormat} option used as the format to encode the
+   * {@link android.graphics.Bitmap}.
    *
-   * <p> Defaults to {@link android.graphics.Bitmap.CompressFormat#JPEG} for images without alpha
-   * and {@link android.graphics.Bitmap.CompressFormat#PNG} for images with alpha. </p>
+   * <p>Defaults to {@link android.graphics.Bitmap.CompressFormat#JPEG} for images without alpha and
+   * {@link android.graphics.Bitmap.CompressFormat#PNG} for images with alpha.
    */
-  public static final Option<Bitmap.CompressFormat> COMPRESSION_FORMAT = Option.memory(
-      "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionFormat");
+  public static final Option<Bitmap.CompressFormat> COMPRESSION_FORMAT =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionFormat");
 
   private static final String TAG = "BitmapEncoder";
+  @Nullable private final ArrayPool arrayPool;
+
+  public BitmapEncoder(@NonNull ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
+  }
+
+  /** @deprecated Use {@link #BitmapEncoder(ArrayPool)} instead. */
+  @Deprecated
+  public BitmapEncoder() {
+    arrayPool = null;
+  }
 
   @Override
-  public boolean encode(Resource<Bitmap> resource, File file, Options options) {
+  public boolean encode(
+      @NonNull Resource<Bitmap> resource, @NonNull File file, @NonNull Options options) {
     final Bitmap bitmap = resource.get();
     Bitmap.CompressFormat format = getFormat(bitmap, options);
-    TraceCompat.beginSection(
-        "encode: [" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + format);
+    GlideTrace.beginSectionFormat(
+        "encode: [%dx%d] %s", bitmap.getWidth(), bitmap.getHeight(), format);
     try {
       long start = LogTime.getLogTime();
       int quality = options.get(COMPRESSION_QUALITY);
@@ -63,6 +77,9 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
       OutputStream os = null;
       try {
         os = new FileOutputStream(file);
+        if (arrayPool != null) {
+          os = new BufferedOutputStream(os, arrayPool);
+        }
         bitmap.compress(format, quality, os);
         os.close();
         success = true;
@@ -81,14 +98,22 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
       }
 
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Compressed with type: " + format + " of size " + Util.getBitmapByteSize(bitmap)
-            + " in " + LogTime.getElapsedMillis(start)
-            + ", options format: " + options.get(COMPRESSION_FORMAT)
-            + ", hasAlpha: " + bitmap.hasAlpha());
+        Log.v(
+            TAG,
+            "Compressed with type: "
+                + format
+                + " of size "
+                + Util.getBitmapByteSize(bitmap)
+                + " in "
+                + LogTime.getElapsedMillis(start)
+                + ", options format: "
+                + options.get(COMPRESSION_FORMAT)
+                + ", hasAlpha: "
+                + bitmap.hasAlpha());
       }
       return success;
     } finally {
-      TraceCompat.endSection();
+      GlideTrace.endSection();
     }
   }
 
@@ -103,8 +128,9 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
     }
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return EncodeStrategy.TRANSFORMED;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapImageDecoderResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapImageDecoderResourceDecoder.java
new file mode 100644
index 000000000..284dd769c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapImageDecoderResourceDecoder.java
@@ -0,0 +1,46 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.ImageDecoder;
+import android.graphics.ImageDecoder.OnHeaderDecodedListener;
+import android.graphics.ImageDecoder.Source;
+import android.util.Log;
+import androidx.annotation.RequiresApi;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.resource.ImageDecoderResourceDecoder;
+import java.io.IOException;
+
+/** {@link Bitmap} specific implementation of {@link ImageDecoderResourceDecoder}. */
+@RequiresApi(api = 28)
+public final class BitmapImageDecoderResourceDecoder extends ImageDecoderResourceDecoder<Bitmap> {
+  private static final String TAG = "BitmapImageDecoder";
+  private final BitmapPool bitmapPool = new BitmapPoolAdapter();
+
+  @Override
+  protected Resource<Bitmap> decode(
+      Source source,
+      int requestedResourceWidth,
+      int requestedResourceHeight,
+      OnHeaderDecodedListener listener)
+      throws IOException {
+    Bitmap result = ImageDecoder.decodeBitmap(source, listener);
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(
+          TAG,
+          "Decoded"
+              + " ["
+              + result.getWidth()
+              + "x"
+              + result.getHeight()
+              + "]"
+              + " for ["
+              + requestedResourceWidth
+              + "x"
+              + requestedResourceHeight
+              + "]");
+    }
+    return new BitmapResource(result, bitmapPool);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 102c688c0..80d926583 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -1,18 +1,16 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 
-/**
- * A resource wrapping a {@link android.graphics.Bitmap} object.
- */
-public class BitmapResource implements Resource<Bitmap>,
-    Initializable {
+/** A resource wrapping a {@link android.graphics.Bitmap} object. */
+public class BitmapResource implements Resource<Bitmap>, Initializable {
   private final Bitmap bitmap;
   private final BitmapPool bitmapPool;
 
@@ -20,11 +18,11 @@
    * Returns a new {@link BitmapResource} wrapping the given {@link Bitmap} if the Bitmap is
    * non-null or null if the given Bitmap is null.
    *
-   * @param bitmap     A Bitmap.
+   * @param bitmap A Bitmap.
    * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
    */
   @Nullable
-  public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPool) {
+  public static BitmapResource obtain(@Nullable Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
     if (bitmap == null) {
       return null;
     } else {
@@ -32,16 +30,18 @@ public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPo
     }
   }
 
-  public BitmapResource(Bitmap bitmap, BitmapPool bitmapPool) {
+  public BitmapResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
     this.bitmap = Preconditions.checkNotNull(bitmap, "Bitmap must not be null");
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool, "BitmapPool must not be null");
   }
 
+  @NonNull
   @Override
   public Class<Bitmap> getResourceClass() {
     return Bitmap.class;
   }
 
+  @NonNull
   @Override
   public Bitmap get() {
     return bitmap;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index f204cc54e..e5b0a90da 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -2,25 +2,28 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
 
 /**
- * A simple {@link com.bumptech.glide.load.Transformation} for transforming
- * {@link android.graphics.Bitmap}s that abstracts away dealing with
- * {@link com.bumptech.glide.load.engine.Resource} objects for subclasses.
+ * A simple {@link com.bumptech.glide.load.Transformation} for transforming {@link
+ * android.graphics.Bitmap}s that abstracts away dealing with {@link
+ * com.bumptech.glide.load.engine.Resource} objects for subclasses.
+ *
+ * <p>Use cases will look something like this:
  *
- * Use cases will look something like this:
  * <pre>
  * <code>
- * public class FillSpace extends BaseBitmapTransformation {
+ * public class FillSpace extends BitmapTransformation {
  *     private static final String ID = "com.bumptech.glide.transformations.FillSpace";
- *     private static final String ID_BYTES = ID.getBytes(STRING_CHARSET_NAME);
+ *     private static final byte[] ID_BYTES = ID.getBytes(Charset.forName("UTF-8"));
  *
  *     {@literal @Override}
  *     public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
@@ -32,7 +35,7 @@
  *     }
  *
  *     {@literal @Override}
- *     public void equals(Object o) {
+ *     public boolean equals(Object o) {
  *       return o instanceof FillSpace;
  *     }
  *
@@ -42,36 +45,37 @@
  *     }
  *
  *     {@literal @Override}
- *     public void updateDiskCacheKey(MessageDigest messageDigest)
- *         throws UnsupportedEncodingException {
+ *     public void updateDiskCacheKey(MessageDigest messageDigest) {
  *       messageDigest.update(ID_BYTES);
  *     }
  * }
  * </code>
  * </pre>
+ *
+ * <p>Using the fully qualified class name as a static final {@link String} (not {@link
+ * Class#getName()} to avoid proguard obfuscation) is an easy way to implement {@link
+ * #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * required they can be passed in to the constructor of the {@code Transformation} and then used to
+ * update the {@link java.security.MessageDigest} passed in to {@link
+ * #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically easily
+ * be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized with
+ * {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
+ *
+ * <p>As with all {@link Transformation}s, all subclasses <em>must</em> implement {@link
+ * #equals(Object)} and {@link #hashCode()} for memory caching to work correctly.
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
-  public BitmapTransformation() {
-    // Intentionally empty.
-  }
-
-  @Deprecated
-  public BitmapTransformation(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  @Deprecated
-  public BitmapTransformation(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
+  @NonNull
   @Override
   public final Resource<Bitmap> transform(
-      Context context, Resource<Bitmap> resource, int outWidth, int outHeight) {
+      @NonNull Context context, @NonNull Resource<Bitmap> resource, int outWidth, int outHeight) {
     if (!Util.isValidDimensions(outWidth, outHeight)) {
       throw new IllegalArgumentException(
-          "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
+          "Cannot apply transformation on width: "
+              + outWidth
+              + " or height: "
+              + outHeight
               + " less than or equal to zero and not Target.SIZE_ORIGINAL");
     }
     BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
@@ -101,21 +105,19 @@ public BitmapTransformation(@SuppressWarnings("unused") BitmapPool bitmapPool) {
    * example. If the implementation obtains and discards intermediate Bitmaps, they may safely be
    * returned to the BitmapPool and/or recycled.
    *
-   * <p>outWidth and outHeight will never be
-   * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL},
-   * this class converts them to be the size of the Bitmap we're going to transform before calling
-   * this method.
+   * <p>outWidth and outHeight will never be {@link
+   * com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}, this class converts them to be the
+   * size of the Bitmap we're going to transform before calling this method.
    *
-   * @param pool        A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can
-   *                    be used to obtain and return intermediate {@link Bitmap}s used in this
-   *                    transformation. For every {@link android.graphics.Bitmap} obtained from the
-   *                    pool during this transformation, a {@link android.graphics.Bitmap} must also
-   *                    be returned.
+   * @param pool A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can be used
+   *     to obtain and return intermediate {@link Bitmap}s used in this transformation. For every
+   *     {@link android.graphics.Bitmap} obtained from the pool during this transformation, a {@link
+   *     android.graphics.Bitmap} must also be returned.
    * @param toTransform The {@link android.graphics.Bitmap} to transform.
-   * @param outWidth    The ideal width of the transformed bitmap (the transformed width does not
-   *                    need to match exactly).
-   * @param outHeight   The ideal height of the transformed bitmap (the transformed height does not
-   *                    need to match exactly).
+   * @param outWidth The ideal width of the transformed bitmap (the transformed width does not need
+   *     to match exactly).
+   * @param outHeight The ideal height of the transformed bitmap (the transformed height does not
+   *     need to match exactly).
    */
   protected abstract Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
index 61900b789..1a2a3a7b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -2,22 +2,24 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.BitmapTransitionFactory;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
 import com.bumptech.glide.request.transition.TransitionFactory;
 
-/**
- * Contains {@link Bitmap} specific animation options.
- */
-public final class BitmapTransitionOptions extends
-    TransitionOptions<BitmapTransitionOptions, Bitmap> {
+/** Contains {@link Bitmap} specific animation options. */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public final class BitmapTransitionOptions
+    extends TransitionOptions<BitmapTransitionOptions, Bitmap> {
 
   /**
    * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
    *
    * @see #crossFade()
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade() {
     return new BitmapTransitionOptions().crossFade();
   }
@@ -27,6 +29,7 @@ public static BitmapTransitionOptions withCrossFade() {
    *
    * @see #crossFade(int)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(int duration) {
     return new BitmapTransitionOptions().crossFade(duration);
   }
@@ -36,8 +39,9 @@ public static BitmapTransitionOptions withCrossFade(int duration) {
    *
    * @see #crossFade(DrawableCrossFadeFactory)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return new BitmapTransitionOptions().crossFade(drawableCrossFadeFactory);
   }
 
@@ -46,19 +50,21 @@ public static BitmapTransitionOptions withCrossFade(
    *
    * @see #crossFade(DrawableCrossFadeFactory.Builder)
    */
+  @NonNull
   public static BitmapTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory.Builder builder) {
+      @NonNull DrawableCrossFadeFactory.Builder builder) {
     return new BitmapTransitionOptions().crossFade(builder);
   }
 
   /**
-   * Returns a {@link BitmapTransitionOptions} object that enables a any animation
-   * that is possible on drawables.
+   * Returns a {@link BitmapTransitionOptions} object that enables a any animation that is possible
+   * on drawables.
    *
    * @see #transitionUsing(TransitionFactory)
    */
+  @NonNull
   public static BitmapTransitionOptions withWrapped(
-      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+      @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
     return new BitmapTransitionOptions().transitionUsing(drawableCrossFadeFactory);
   }
 
@@ -67,8 +73,8 @@ public static BitmapTransitionOptions withWrapped(
    *
    * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
    */
-  public static BitmapTransitionOptions with(
-      TransitionFactory<Bitmap> transitionFactory) {
+  @NonNull
+  public static BitmapTransitionOptions with(@NonNull TransitionFactory<Bitmap> transitionFactory) {
     return new BitmapTransitionOptions().transition(transitionFactory);
   }
 
@@ -76,6 +82,7 @@ public static BitmapTransitionOptions with(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
+  @NonNull
   public BitmapTransitionOptions crossFade() {
     return crossFade(new DrawableCrossFadeFactory.Builder());
   }
@@ -84,10 +91,11 @@ public BitmapTransitionOptions crossFade() {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    *
-   * @param duration The duration of the animation, see
-   *     {@code DrawableCrossFadeFactory.Builder(int)}.
+   * @param duration The duration of the animation, see {@code
+   *     DrawableCrossFadeFactory.Builder(int)}.
    * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
    */
+  @NonNull
   public BitmapTransitionOptions crossFade(int duration) {
     return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
@@ -96,15 +104,16 @@ public BitmapTransitionOptions crossFade(int duration) {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+  @NonNull
+  public BitmapTransitionOptions crossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return transitionUsing(drawableCrossFadeFactory);
   }
 
-  /**
-   * Enables a any Drawable based animation to run on Bitmaps as well.
-   */
+  /** Enables a any Drawable based animation to run on Bitmaps as well. */
+  @NonNull
   public BitmapTransitionOptions transitionUsing(
-      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+      @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
     return transition(new BitmapTransitionFactory(drawableCrossFadeFactory));
   }
 
@@ -112,8 +121,8 @@ public BitmapTransitionOptions transitionUsing(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+  @NonNull
+  public BitmapTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Builder builder) {
     return transitionUsing(builder.build());
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
index 6a6c9ec8f..96214be07 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -9,9 +10,7 @@
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 
-/**
- * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link java.nio.ByteBuffer ByteBuffers}.
- */
+/** Decodes {@link android.graphics.Bitmap Bitmaps} from {@link java.nio.ByteBuffer ByteBuffers}. */
 public class ByteBufferBitmapDecoder implements ResourceDecoder<ByteBuffer, Bitmap> {
   private final Downsampler downsampler;
 
@@ -20,12 +19,13 @@ public ByteBufferBitmapDecoder(Downsampler downsampler) {
   }
 
   @Override
-  public boolean handles(ByteBuffer source, Options options) throws IOException {
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) {
     return downsampler.handles(source);
   }
 
   @Override
-  public Resource<Bitmap> decode(ByteBuffer source, int width, int height, Options options)
+  public Resource<Bitmap> decode(
+      @NonNull ByteBuffer source, int width, int height, @NonNull Options options)
       throws IOException {
     InputStream is = ByteBufferUtil.toStream(source);
     return downsampler.decode(is, width, height, options);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapImageDecoderResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapImageDecoderResourceDecoder.java
new file mode 100644
index 000000000..c9a18528f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapImageDecoderResourceDecoder.java
@@ -0,0 +1,37 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.ImageDecoder;
+import android.graphics.ImageDecoder.Source;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * {@link ByteBuffer} specific implementation of {@link
+ * ByteBufferBitmapImageDecoderResourceDecoder}.
+ */
+@RequiresApi(api = 28)
+public final class ByteBufferBitmapImageDecoderResourceDecoder
+    implements ResourceDecoder<ByteBuffer, Bitmap> {
+  private final BitmapImageDecoderResourceDecoder wrapped = new BitmapImageDecoderResourceDecoder();
+
+  @Override
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) throws IOException {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public Resource<Bitmap> decode(
+      @NonNull ByteBuffer buffer, int width, int height, @NonNull Options options)
+      throws IOException {
+    Source source = ImageDecoder.createSource(buffer);
+    return wrapped.decode(source, width, height, options);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index bdc38562a..b84add358 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import java.security.MessageDigest;
 
@@ -11,28 +10,12 @@
  * the image is greater than the given height or vice versa, and then crop the larger dimension to
  * match the given dimension.
  *
- * Does not maintain the image's aspect ratio
+ * <p>Does not maintain the image's aspect ratio
  */
 public class CenterCrop extends BitmapTransformation {
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterCrop() {
-    // Intentionally empty.
-  }
-
-  @Deprecated
-  public CenterCrop(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  @Deprecated
-  public CenterCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
-  // Bitmap doesn't implement equals, so == and .equals are equivalent here.
-  @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
@@ -50,7 +33,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
index 6efdbad47..07b1d9ab8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -1,42 +1,21 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import java.security.MessageDigest;
 
 /**
- * Returns the image with its original size if its dimensions match or are smaller
- * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}
- * in order to center it in Target. If not, then it is scaled so that one of the dimensions of
- * the image will be equal to the given dimension and the other will be less than the given
- * dimension (maintaining the image's aspect ratio).
+ * Returns the image with its original size if its dimensions match or are smaller than the
+ * target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE} in order to center
+ * it in Target. If not, then it is scaled so that one of the dimensions of the image will be equal
+ * to the given dimension and the other will be less than the given dimension (maintaining the
+ * image's aspect ratio).
  */
 public class CenterInside extends BitmapTransformation {
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterInside() {
-    // Intentionally empty.
-  }
-
-  /**
-   * Use {@link #CenterInside()}.
-   */
-  @Deprecated
-  public CenterInside(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * Use {@link #CenterInside()}.
-   */
-  @Deprecated
-  public CenterInside(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
@@ -54,9 +33,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
-
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
index 655487175..e56703603 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -1,16 +1,15 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import java.security.MessageDigest;
 
 /**
- * A Glide {@link BitmapTransformation} to circle crop an image.  Behaves similar to a
- * {@link FitCenter} transform, but the resulting image is masked to a circle.
+ * A Glide {@link BitmapTransformation} to circle crop an image. Behaves similar to a {@link
+ * FitCenter} transform, but the resulting image is masked to a circle.
  *
- * <p> Uses a PorterDuff blend mode, see http://ssp.impulsetrain.com/porterduff.html. </p>
+ * <p>Uses a PorterDuff blend mode, see http://ssp.impulsetrain.com/porterduff.html.
  */
 public class CircleCrop extends BitmapTransformation {
   // The version of this transformation, incremented to correct an error in a previous version.
@@ -19,26 +18,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CircleCrop() {
-    // Intentionally empty.
-  }
-
-  /**
-   * @deprecated Use {@link #CircleCrop()}.
-   */
-  @Deprecated
-  public CircleCrop(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * @deprecated Use {@link #CircleCrop()}
-   */
-  @Deprecated
-  public CircleCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
@@ -58,7 +37,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 5bfe67f8c..f81f548ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -7,6 +7,7 @@
 import static com.bumptech.glide.load.ImageHeaderParser.ImageType.UNKNOWN;
 
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.Preconditions;
@@ -16,9 +17,7 @@
 import java.nio.ByteOrder;
 import java.nio.charset.Charset;
 
-/**
- * A class for parsing the exif orientation and other data from an image header.
- */
+/** A class for parsing the exif orientation and other data from an image header. */
 public final class DefaultImageHeaderParser implements ImageHeaderParser {
   // Due to https://code.google.com/p/android/issues/detail?id=97751.
   // TAG needs to be under 23 chars, so "Default" > "Dflt".
@@ -31,7 +30,7 @@
   private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
   // "II".
   private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
-  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
+  private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
   static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
       JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
   private static final int SEGMENT_SOS = 0xDA;
@@ -39,7 +38,7 @@
   static final int SEGMENT_START_ID = 0xFF;
   static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
-  private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
+  private static final int[] BYTES_PER_FORMAT = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};
   // WebP-related
   // "RIFF"
   private static final int RIFF_HEADER = 0x52494646;
@@ -56,37 +55,44 @@
   private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
   private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
 
+  @NonNull
   @Override
-  public ImageType getType(InputStream is) throws IOException {
+  public ImageType getType(@NonNull InputStream is) throws IOException {
     return getType(new StreamReader(Preconditions.checkNotNull(is)));
   }
 
+  @NonNull
   @Override
-  public ImageType getType(ByteBuffer byteBuffer) throws IOException {
+  public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {
     return getType(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)));
   }
 
   @Override
-  public int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException {
-    return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
+  public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
+    return getOrientation(
+        new StreamReader(Preconditions.checkNotNull(is)),
         Preconditions.checkNotNull(byteArrayPool));
   }
 
   @Override
-  public int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException {
-    return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
+  public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
+    return getOrientation(
+        new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
         Preconditions.checkNotNull(byteArrayPool));
   }
 
+  @NonNull
   private ImageType getType(Reader reader) throws IOException {
-    int firstTwoBytes = reader.getUInt16();
+    final int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
     if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
       return JPEG;
     }
 
-    final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int firstFourBytes = (firstTwoBytes << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     // PNG.
     if (firstFourBytes == PNG_HEADER) {
       // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha
@@ -109,11 +115,13 @@ private ImageType getType(Reader reader) throws IOException {
     }
     // Bytes 4 - 7 contain length information. Skip these.
     reader.skip(4);
-    final int thirdFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int thirdFourBytes =
+        (reader.getUInt16() << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     if (thirdFourBytes != WEBP_HEADER) {
       return UNKNOWN;
     }
-    final int fourthFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int fourthFourBytes =
+        (reader.getUInt16() << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     if ((fourthFourBytes & VP8_HEADER_MASK) != VP8_HEADER) {
       return UNKNOWN;
     }
@@ -136,8 +144,7 @@ private ImageType getType(Reader reader) throws IOException {
    * not an image) it will return a default value rather than throwing an exception.
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
-   * contain an orientation
-   * @throws IOException
+   *     contain an orientation
    */
   private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
@@ -160,7 +167,7 @@ private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOExce
       try {
         return parseExifSegment(reader, exifData, exifSegmentLength);
       } finally {
-        byteArrayPool.put(exifData, byte[].class);
+        byteArrayPool.put(exifData);
       }
     }
   }
@@ -170,9 +177,13 @@ private int parseExifSegment(Reader reader, byte[] tempArray, int exifSegmentLen
     int read = reader.read(tempArray, exifSegmentLength);
     if (read != exifSegmentLength) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to read exif segment data"
-            + ", length: " + exifSegmentLength
-            + ", actually read: " + read);
+        Log.d(
+            TAG,
+            "Unable to read exif segment data"
+                + ", length: "
+                + exifSegmentLength
+                + ", actually read: "
+                + read);
       }
       return UNKNOWN_ORIENTATION;
     }
@@ -207,10 +218,8 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * {@code -1} if no exif segment is found.
    */
   private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
-    short segmentId, segmentType;
-    int segmentLength;
     while (true) {
-      segmentId = reader.getUInt8();
+      short segmentId = reader.getUInt8();
       if (segmentId != SEGMENT_START_ID) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Unknown segmentId=" + segmentId);
@@ -218,8 +227,7 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
         return -1;
       }
 
-      segmentType = reader.getUInt8();
-
+      short segmentType = reader.getUInt8();
       if (segmentType == SEGMENT_SOS) {
         return -1;
       } else if (segmentType == MARKER_EOI) {
@@ -230,18 +238,22 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
       }
 
       // Segment length includes bytes for segment length.
-      segmentLength = reader.getUInt16() - 2;
-
+      int segmentLength = reader.getUInt16() - 2;
       if (segmentType != EXIF_SEGMENT_TYPE) {
         long skipped = reader.skip(segmentLength);
         if (skipped != segmentLength) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Unable to skip enough data"
-                    + ", type: " + segmentType
-                    + ", wanted to skip: " + segmentLength
-                    + ", but actually skipped: " + skipped);
-            }
-            return -1;
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(
+                TAG,
+                "Unable to skip enough data"
+                    + ", type: "
+                    + segmentType
+                    + ", wanted to skip: "
+                    + segmentLength
+                    + ", but actually skipped: "
+                    + skipped);
+          }
+          return -1;
         }
       } else {
         return segmentLength;
@@ -254,34 +266,35 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
 
     short byteOrderIdentifier = segmentData.getInt16(headerOffsetSize);
     final ByteOrder byteOrder;
-    if (byteOrderIdentifier == MOTOROLA_TIFF_MAGIC_NUMBER) {
-      byteOrder = ByteOrder.BIG_ENDIAN;
-    } else if (byteOrderIdentifier == INTEL_TIFF_MAGIC_NUMBER) {
-      byteOrder = ByteOrder.LITTLE_ENDIAN;
-    } else {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
-      }
-      byteOrder = ByteOrder.BIG_ENDIAN;
+    switch (byteOrderIdentifier) {
+      case MOTOROLA_TIFF_MAGIC_NUMBER:
+        byteOrder = ByteOrder.BIG_ENDIAN;
+        break;
+      case INTEL_TIFF_MAGIC_NUMBER:
+        byteOrder = ByteOrder.LITTLE_ENDIAN;
+        break;
+      default:
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
+        }
+        byteOrder = ByteOrder.BIG_ENDIAN;
+        break;
     }
 
     segmentData.order(byteOrder);
 
     int firstIfdOffset = segmentData.getInt32(headerOffsetSize + 4) + headerOffsetSize;
     int tagCount = segmentData.getInt16(firstIfdOffset);
-
-    int tagOffset, tagType, formatCode, componentCount;
     for (int i = 0; i < tagCount; i++) {
-      tagOffset = calcTagOffset(firstIfdOffset, i);
-      tagType = segmentData.getInt16(tagOffset);
+      final int tagOffset = calcTagOffset(firstIfdOffset, i);
 
+      final int tagType = segmentData.getInt16(tagOffset);
       // We only want orientation.
       if (tagType != ORIENTATION_TAG_TYPE) {
         continue;
       }
 
-      formatCode = segmentData.getInt16(tagOffset + 2);
-
+      final int formatCode = segmentData.getInt16(tagOffset + 2);
       // 12 is max format code.
       if (formatCode < 1 || formatCode > 12) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -290,8 +303,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
         continue;
       }
 
-      componentCount = segmentData.getInt32(tagOffset + 4);
-
+      final int componentCount = segmentData.getInt32(tagOffset + 4);
       if (componentCount < 0) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Negative tiff component count");
@@ -300,12 +312,19 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode=" + formatCode
-            + " componentCount=" + componentCount);
+        Log.d(
+            TAG,
+            "Got tagIndex="
+                + i
+                + " tagType="
+                + tagType
+                + " formatCode="
+                + formatCode
+                + " componentCount="
+                + componentCount);
       }
 
       final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];
-
       if (byteCount > 4) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Got byte count > 4, not orientation, continuing, formatCode=" + formatCode);
@@ -314,7 +333,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int tagValueOffset = tagOffset + 8;
-
       if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
@@ -329,7 +347,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
         continue;
       }
 
-      //assume componentCount == 1 && fmtCode == 3
+      // assume componentCount == 1 && fmtCode == 3
       return segmentData.getInt16(tagValueOffset);
     }
 
@@ -350,9 +368,7 @@ private static boolean handles(int imageMagicNumber) {
     private final ByteBuffer data;
 
     RandomAccessReader(byte[] data, int length) {
-      this.data = (ByteBuffer) ByteBuffer.wrap(data)
-          .order(ByteOrder.BIG_ENDIAN)
-          .limit(length);
+      this.data = (ByteBuffer) ByteBuffer.wrap(data).order(ByteOrder.BIG_ENDIAN).limit(length);
     }
 
     void order(ByteOrder byteOrder) {
@@ -378,9 +394,13 @@ private boolean isAvailable(int offset, int byteSize) {
 
   private interface Reader {
     int getUInt16() throws IOException;
+
     short getUInt8() throws IOException;
+
     long skip(long total) throws IOException;
+
     int read(byte[] buffer, int byteCount) throws IOException;
+
     int getByte() throws IOException;
   }
 
@@ -394,24 +414,24 @@ private boolean isAvailable(int offset, int byteSize) {
     }
 
     @Override
-    public int getUInt16() throws IOException {
+    public int getUInt16() {
       return (getByte() << 8 & 0xFF00) | (getByte() & 0xFF);
     }
 
     @Override
-    public short getUInt8() throws IOException {
+    public short getUInt8() {
       return (short) (getByte() & 0xFF);
     }
 
     @Override
-    public long skip(long total) throws IOException {
+    public long skip(long total) {
       int toSkip = (int) Math.min(byteBuffer.remaining(), total);
       byteBuffer.position(byteBuffer.position() + toSkip);
       return toSkip;
     }
 
     @Override
-    public int read(byte[] buffer, int byteCount) throws IOException {
+    public int read(byte[] buffer, int byteCount) {
       int toRead = Math.min(byteCount, byteBuffer.remaining());
       if (toRead == 0) {
         return -1;
@@ -421,7 +441,7 @@ public int read(byte[] buffer, int byteCount) throws IOException {
     }
 
     @Override
-    public int getByte() throws IOException {
+    public int getByte() {
       if (byteBuffer.remaining() < 1) {
         return -1;
       }
@@ -431,6 +451,7 @@ public int getByte() throws IOException {
 
   private static final class StreamReader implements Reader {
     private final InputStream is;
+
     // Motorola / big endian byte order.
     StreamReader(InputStream is) {
       this.is = is;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index 71548c5e9..b6bcf90d8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -1,140 +1,191 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import android.os.Build;
+import com.bumptech.glide.load.Option;
 import com.bumptech.glide.util.Synthetic;
 
 /**
  * Indicates the algorithm to use when downsampling images.
+ *
+ * <p>{@code DownsampleStrategy} does not provide any guarantees about output sizes. Behavior will
+ * differ depending on the {@link com.bumptech.glide.load.ResourceDecoder} using the strategy and
+ * the version of Android the code runs on. Use {@code DownsampleStrategy} as an optimization to
+ * improve memory efficiency only. If you need a particular size or shape output, use an {@link
+ * com.bumptech.glide.load.Transformation} either instead or in addition to a {@code
+ * DownsampleStrategy}.
+ *
+ * <p>Some differences between versions of Android and {@link
+ * com.bumptech.glide.load.ResourceDecoder}s are listed below, but the list is not comprehensive
+ * because {@link DownsampleStrategy} only controls its output scale value, not how that output
+ * value is used.
+ *
+ * <p>On some versions of Android, precise scaling is not possible. In those cases, the strategies
+ * can only pick between downsampling to between 1x the requested size and 2x the requested size and
+ * between 0.5x the requested size and 1x the requested size because only power of two downsampling
+ * is supported. To preserve the potential for a {@link com.bumptech.glide.load.Transformation} to
+ * scale precisely without a loss in quality, all but {@link #AT_MOST} will prefer to downsample to
+ * between 1x and 2x the requested size.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class DownsampleStrategy {
 
-  /**
-   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
-   * exactly equal to the requested size and the other dimension is less than or equal to the
-   * requested size.
-   *
-   * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or
-   * {@link #CENTER_INSIDE}.
-   *
-   * <p>On pre-KitKat devices, this is equivalent to {@link #AT_MOST} because only power of
-   * two downsampling can be used.
-   */
-  public static final DownsampleStrategy FIT_CENTER = new FitCenter();
-
-  /**
-   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
-   * exactly equal to the requested size and the other dimension is greater than or equal to
-   * the requested size.
-   *
-   * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},
-   * or {@link #CENTER_INSIDE}.
-   *
-   * <p>On pre-KitKat devices, this is equivalent to {@link #AT_LEAST} because only power of
-   * two downsampling can be used.
-   */
-  public static final DownsampleStrategy CENTER_OUTSIDE = new CenterOutside();
-
   /**
    * Downsamples so the image's smallest dimension is between the given dimensions and 2x the given
    * dimensions, with no size restrictions on the image's largest dimension.
+   *
+   * <p>Does not upscale if the requested dimensions are larger than the original dimensions.
    */
   public static final DownsampleStrategy AT_LEAST = new AtLeast();
 
   /**
    * Downsamples so the image's largest dimension is between 1/2 the given dimensions and the given
    * dimensions, with no restrictions on the image's smallest dimension.
+   *
+   * <p>Does not upscale if the requested dimensions are larger than the original dimensions.
    */
   public static final DownsampleStrategy AT_MOST = new AtMost();
 
   /**
-   * Returns the original image if it is smaller than the target, otherwise it will be downscaled
-   * maintaining its original aspect ratio, so that one of the image's dimensions is exactly equal
-   * to the requested size and the other is less or equal than the requested size.
+   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is exactly
+   * equal to the requested size and the other dimension is less than or equal to the requested
+   * size.
    *
-   * <p>This method will not upscale.</p>
+   * <p>This method will upscale if the requested width and height are greater than the source width
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or {@link
+   * #CENTER_INSIDE}.
+   *
+   * <p>On pre-KitKat devices, {@code FIT_CENTER} will downsample by a power of two only so that one
+   * of the image's dimensions is greater than or equal to the requested size. No guarantees are
+   * made about the second dimensions. This is <em>NOT</em> the same as {@link #AT_LEAST} because
+   * only one dimension, not both, are greater than or equal to the requested dimensions, the other
+   * may be smaller.
    */
+  public static final DownsampleStrategy FIT_CENTER = new FitCenter();
+
+  /** Identical to {@link #FIT_CENTER}, but never upscales. */
   public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
 
   /**
-   * Performs no downsampling or scaling.
+   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is exactly
+   * equal to the requested size and the other dimension is greater than or equal to the requested
+   * size.
+   *
+   * <p>This method will upscale if the requested width and height are greater than the source width
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST}, or {@link
+   * #CENTER_INSIDE}.
+   *
+   * <p>On pre-KitKat devices, {@link Downsampler} treats this as equivalent to {@link #AT_LEAST}
+   * because only power of two downsampling can be used.
    */
+  public static final DownsampleStrategy CENTER_OUTSIDE = new CenterOutside();
+
+  /** Performs no downsampling or scaling. */
   public static final DownsampleStrategy NONE = new None();
 
+  /** Default strategy, currently {@link #CENTER_OUTSIDE}. */
+  public static final DownsampleStrategy DEFAULT = CENTER_OUTSIDE;
+
   /**
-   * Default strategy, currently {@link #CENTER_OUTSIDE}.
+   * Indicates the {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option that
+   * will be used to calculate the sample size to use to downsample an image given the original and
+   * target dimensions of the image.
    */
-  public static final DownsampleStrategy DEFAULT = CENTER_OUTSIDE;
+  // The exact String value here is retained to avoid breaking cache keys for images that were
+  // loaded with older versions of Glide.
+  public static final Option<DownsampleStrategy> OPTION =
+      Option.memory(
+          "com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy", DEFAULT);
+
+  @Synthetic
+  static final boolean IS_BITMAP_FACTORY_SCALING_SUPPORTED =
+      Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
 
   /**
-   * Returns a float (0, +infinity) indicating a scale factor to apply to the source
-   * width and height when displayed in the requested width and height.
+   * Returns a float (0, +infinity) indicating a scale factor to apply to the source width and
+   * height when displayed in the requested width and height.
    *
-   * <p>The returned scale factor will be split into a power of two sample size applied via
-   * {@link android.graphics.BitmapFactory.Options#inSampleSize} and a float scale factor applied
-   * after downsampling via {@link android.graphics.BitmapFactory.Options#inTargetDensity} and
-   * {@link android.graphics.BitmapFactory.Options#inDensity}. Because of rounding errors the scale
-   * factor may not be applied precisely.
+   * <p>The returned scale factor will be split into a power of two sample size applied via {@link
+   * android.graphics.BitmapFactory.Options#inSampleSize} and a float scale factor applied after
+   * downsampling via {@link android.graphics.BitmapFactory.Options#inTargetDensity} and {@link
+   * android.graphics.BitmapFactory.Options#inDensity}. Because of rounding errors the scale factor
+   * may not be applied precisely.
    *
-   * <p>The float scaling factor will only be applied on KitKat+. Prior to KitKat, only the power
-   * of two downsampling will be applied.
+   * <p>The float scaling factor will only be applied on KitKat+. Prior to KitKat, only the power of
+   * two downsampling will be applied.
    *
-   * @param sourceWidth   The width in pixels of the image to be downsampled.
-   * @param sourceHeight  The height in pixels of the image to be downsampled.
-   * @param requestedWidth  The width in pixels of the view/target the image will be displayed in.
+   * @param sourceWidth The width in pixels of the image to be downsampled.
+   * @param sourceHeight The height in pixels of the image to be downsampled.
+   * @param requestedWidth The width in pixels of the view/target the image will be displayed in.
    * @param requestedHeight The height in pixels of the view/target the image will be displayed in.
    */
-  public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-      int requestedHeight);
+  public abstract float getScaleFactor(
+      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight);
 
   /**
    * Returns a non-null {@link SampleSizeRounding} to use to resolve rounding errors and conflicts
    * between scaling for the width and the height of the image.
    *
-   * @param sourceWidth   The width in pixels of the image to be downsampled.
-   * @param sourceHeight  The height in pixels of the image to be downsampled.
-   * @param requestedWidth  The width in pixels of the view/target the image will be displayed in.
+   * @param sourceWidth The width in pixels of the image to be downsampled.
+   * @param sourceHeight The height in pixels of the image to be downsampled.
+   * @param requestedWidth The width in pixels of the view/target the image will be displayed in.
    * @param requestedHeight The height in pixels of the view/target the image will be displayed in.
    */
-  public abstract SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-      int requestedWidth, int requestedHeight);
+  public abstract SampleSizeRounding getSampleSizeRounding(
+      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight);
 
   private static class FitCenter extends DownsampleStrategy {
 
     @Synthetic
-    FitCenter() { }
+    FitCenter() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
-      float widthPercentage = requestedWidth / (float) sourceWidth;
-      float heightPercentage = requestedHeight / (float) sourceHeight;
-      return Math.min(widthPercentage, heightPercentage);
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
+      if (IS_BITMAP_FACTORY_SCALING_SUPPORTED) {
+        float widthPercentage = requestedWidth / (float) sourceWidth;
+        float heightPercentage = requestedHeight / (float) sourceHeight;
+
+        return Math.min(widthPercentage, heightPercentage);
+      } else {
+        // Similar to AT_LEAST, but only require one dimension or the other to be >= requested
+        // rather than both.
+        int maxIntegerFactor =
+            Math.max(sourceHeight / requestedHeight, sourceWidth / requestedWidth);
+        return maxIntegerFactor == 0 ? 1f : 1f / Integer.highestOneBit(maxIntegerFactor);
+      }
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
-      return SampleSizeRounding.QUALITY;
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
+      if (IS_BITMAP_FACTORY_SCALING_SUPPORTED) {
+        return SampleSizeRounding.QUALITY;
+      } else {
+        // TODO: This doesn't seem right, but otherwise we can skip a sample size because QUALITY
+        // prefers the smaller of the width and height scale factor. MEMORY is a hack that
+        // lets us prefer the larger of the two.
+        return SampleSizeRounding.MEMORY;
+      }
     }
   }
 
   private static class CenterOutside extends DownsampleStrategy {
 
     @Synthetic
-    CenterOutside() { }
+    CenterOutside() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       float widthPercentage = requestedWidth / (float) sourceWidth;
       float heightPercentage = requestedHeight / (float) sourceHeight;
       return Math.max(widthPercentage, heightPercentage);
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.QUALITY;
     }
   }
@@ -142,18 +193,18 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class AtLeast extends DownsampleStrategy {
 
     @Synthetic
-    AtLeast() { }
+    AtLeast() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       int minIntegerFactor = Math.min(sourceHeight / requestedHeight, sourceWidth / requestedWidth);
       return minIntegerFactor == 0 ? 1f : 1f / Integer.highestOneBit(minIntegerFactor);
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.QUALITY;
     }
   }
@@ -161,13 +212,17 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class AtMost extends DownsampleStrategy {
 
     @Synthetic
-    AtMost() { }
+    AtMost() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
-      int maxIntegerFactor = (int) Math.ceil(Math.max(sourceHeight / (float) requestedHeight,
-              sourceWidth / (float) requestedWidth));
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
+      int maxIntegerFactor =
+          (int)
+              Math.ceil(
+                  Math.max(
+                      sourceHeight / (float) requestedHeight,
+                      sourceWidth / (float) requestedWidth));
       int lesserOrEqualSampleSize = Math.max(1, Integer.highestOneBit(maxIntegerFactor));
       int greaterOrEqualSampleSize =
           lesserOrEqualSampleSize << (lesserOrEqualSampleSize < maxIntegerFactor ? 1 : 0);
@@ -175,8 +230,8 @@ public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidt
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.MEMORY;
     }
   }
@@ -184,17 +239,17 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class None extends DownsampleStrategy {
 
     @Synthetic
-    None() { }
+    None() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return 1f;
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.QUALITY;
     }
   }
@@ -202,26 +257,30 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class CenterInside extends DownsampleStrategy {
 
     @Synthetic
-    CenterInside() { }
+    CenterInside() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
 
-      return Math.min(1.f,
+      return Math.min(
+          1.f,
           FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
-      return SampleSizeRounding.QUALITY;
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
+      return getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight) == 1.f
+          ? SampleSizeRounding.QUALITY
+          : FIT_CENTER.getSampleSizeRounding(
+              sourceWidth, sourceHeight, requestedWidth, requestedHeight);
     }
   }
 
   /**
-   * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage
-   * or higher quality.
+   * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage or
+   * higher quality.
    */
   public enum SampleSizeRounding {
     /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 57eebd0b8..109322257 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -5,9 +5,9 @@
 import android.graphics.Bitmap.Config;
 import android.graphics.BitmapFactory;
 import android.os.Build;
-import android.support.annotation.Nullable;
 import android.util.DisplayMetrics;
 import android.util.Log;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
@@ -35,7 +35,8 @@
 import java.util.Set;
 
 /**
- * Downsamples, decodes, and rotates images according to their exif orientation.
+ * Downsamples, decodes, and rotates images according to their exif orientation using {@link
+ * BitmapFactory}.
  */
 public final class Downsampler {
   static final String TAG = "Downsampler";
@@ -44,80 +45,76 @@
    * with the image format to determine the {@link android.graphics.Bitmap.Config} to provide to
    * {@link android.graphics.BitmapFactory.Options#inPreferredConfig} when decoding the image.
    */
-  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(
-      "com.bumptech.glide.load.resource.bitmap.Downsampler.DecodeFormat", DecodeFormat.DEFAULT);
+  public static final Option<DecodeFormat> DECODE_FORMAT =
+      Option.memory(
+          "com.bumptech.glide.load.resource.bitmap.Downsampler.DecodeFormat", DecodeFormat.DEFAULT);
   /**
    * Indicates the {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option that
-   * will be used to calculate the sample size to use to downsample an image given the original
-   * and target dimensions of the image.
+   * will be used to calculate the sample size to use to downsample an image given the original and
+   * target dimensions of the image.
+   *
+   * @deprecated Use {@link DownsampleStrategy#OPTION} directly instead.
    */
-  public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY =
-      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
-          DownsampleStrategy.DEFAULT);
+  @Deprecated
+  public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY = DownsampleStrategy.OPTION;
   /**
-   * Ensure that the size of the bitmap is fixed to the requested width and height of the
-   * resource from the caller.  The final resource dimensions may differ from the requested
-   * width and height, and thus setting this to true may result in the bitmap size differing
-   * from the resource dimensions.
+   * Ensure that the size of the bitmap is fixed to the requested width and height of the resource
+   * from the caller. The final resource dimensions may differ from the requested width and height,
+   * and thus setting this to true may result in the bitmap size differing from the resource
+   * dimensions.
    *
-   * This can be used as a performance optimization for KitKat and above by fixing the size of the
-   * bitmap for a collection of requested resources so that the bitmap pool will not need to
+   * <p>This can be used as a performance optimization for KitKat and above by fixing the size of
+   * the bitmap for a collection of requested resources so that the bitmap pool will not need to
    * allocate new bitmaps for images of different sizes.
    */
+  // Public API
+  @SuppressWarnings("WeakerAccess")
   public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
 
   /**
-   * Indicates that it's safe or unsafe to decode {@link Bitmap}s with
-   * {@link Bitmap.Config#HARDWARE}.
+   * Indicates that it's safe or unsafe to decode {@link Bitmap}s with {@link
+   * Bitmap.Config#HARDWARE}.
    *
    * <p>Callers should almost never set this value to {@code true} manually. Glide will already do
    * so when Glide believes it's safe to do (when no transformations are applied). Instead, callers
-   * can set this value to {@code false} to prevent Glide from decoding hardware bitmaps if Glide
-   * is unable to detect that hardware bitmaps are unsafe. For example, you should set this to
-   * {@code false} if you plan to draw it to a software {@link android.graphics.Canvas} or if you
-   * plan to inspect the {@link Bitmap}s pixels with {@link Bitmap#getPixel(int, int)} or
-   * {@link Bitmap#getPixels(int[], int, int, int, int, int, int)}.
+   * can set this value to {@code false} to prevent Glide from decoding hardware bitmaps if Glide is
+   * unable to detect that hardware bitmaps are unsafe. For example, you should set this to {@code
+   * false} if you plan to draw it to a software {@link android.graphics.Canvas} or if you plan to
+   * inspect the {@link Bitmap}s pixels with {@link Bitmap#getPixel(int, int)} or {@link
+   * Bitmap#getPixels(int[], int, int, int, int, int, int)}.
    *
-   * <p>Callers can disable hardware {@link Bitmap}s for all loads using
-   * {@link com.bumptech.glide.GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   * <p>Callers can disable hardware {@link Bitmap}s for all loads using {@link
+   * com.bumptech.glide.GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
    *
    * <p>This option is ignored unless we're on Android O+.
    */
   public static final Option<Boolean> ALLOW_HARDWARE_CONFIG =
       Option.memory(
-          "com.bumtpech.glide.load.resource.bitmap.Downsampler.AllowHardwareDecode", null);
+          "com.bumptech.glide.load.resource.bitmap.Downsampler.AllowHardwareDecode", false);
 
   private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
   private static final String ICO_MIME_TYPE = "image/x-ico";
   private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
-      Collections.unmodifiableSet(
-          new HashSet<>(
-              Arrays.asList(
-                  WBMP_MIME_TYPE,
-                  ICO_MIME_TYPE
-              )
-          )
-      );
-  private static final DecodeCallbacks EMPTY_CALLBACKS = new DecodeCallbacks() {
-    @Override
-    public void onObtainBounds() {
-      // Do nothing.
-    }
+      Collections.unmodifiableSet(new HashSet<>(Arrays.asList(WBMP_MIME_TYPE, ICO_MIME_TYPE)));
+  private static final DecodeCallbacks EMPTY_CALLBACKS =
+      new DecodeCallbacks() {
+        @Override
+        public void onObtainBounds() {
+          // Do nothing.
+        }
 
-    @Override
-    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException {
-      // Do nothing.
-    }
-  };
+        @Override
+        public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {
+          // Do nothing.
+        }
+      };
   private static final Set<ImageHeaderParser.ImageType> TYPES_THAT_USE_POOL_PRE_KITKAT =
       Collections.unmodifiableSet(
           EnumSet.of(
               ImageHeaderParser.ImageType.JPEG,
               ImageHeaderParser.ImageType.PNG_A,
-              ImageHeaderParser.ImageType.PNG
-          )
-      );
+              ImageHeaderParser.ImageType.PNG));
   private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);
   // 10MB. This is the max image header size we can handle, we preallocate a much smaller buffer
   // but will resize up to this amount if necessary.
@@ -129,20 +126,23 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
   private final List<ImageHeaderParser> parsers;
   private final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();
 
-  public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
-      BitmapPool bitmapPool, ArrayPool byteArrayPool) {
+  public Downsampler(
+      List<ImageHeaderParser> parsers,
+      DisplayMetrics displayMetrics,
+      BitmapPool bitmapPool,
+      ArrayPool byteArrayPool) {
     this.parsers = parsers;
     this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
   }
 
-  public boolean handles(InputStream is) {
+  public boolean handles(@SuppressWarnings("unused") InputStream is) {
     // We expect Downsampler to handle any available type Android supports.
     return true;
   }
 
-  public boolean handles(ByteBuffer byteBuffer) {
+  public boolean handles(@SuppressWarnings("unused") ByteBuffer byteBuffer) {
     // We expect downsampler to handle any available type Android supports.
     return true;
   }
@@ -150,74 +150,90 @@ public boolean handles(ByteBuffer byteBuffer) {
   /**
    * Returns a Bitmap decoded from the given {@link InputStream} that is rotated to match any EXIF
    * data present in the stream and that is downsampled according to the given dimensions and any
-   * provided  {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
+   * provided {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
    *
    * @see #decode(InputStream, int, int, Options, DecodeCallbacks)
    */
-  public Resource<Bitmap> decode(InputStream is, int outWidth, int outHeight,
-      Options options) throws IOException {
+  public Resource<Bitmap> decode(InputStream is, int outWidth, int outHeight, Options options)
+      throws IOException {
     return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);
   }
 
   /**
    * Returns a Bitmap decoded from the given {@link InputStream} that is rotated to match any EXIF
    * data present in the stream and that is downsampled according to the given dimensions and any
-   * provided  {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
+   * provided {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
    *
-   * <p> If a Bitmap is present in the
-   * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} whose dimensions exactly match
-   * those of the image for the given InputStream is available, the operation is much less expensive
-   * in terms of memory. </p>
+   * <p>If a Bitmap is present in the {@link
+   * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} whose dimensions exactly match those
+   * of the image for the given InputStream is available, the operation is much less expensive in
+   * terms of memory.
    *
-   * <p> The provided {@link java.io.InputStream} must return <code>true</code> from
-   * {@link java.io.InputStream#markSupported()} and is expected to support a reasonably large
-   * mark limit to accommodate reading large image headers (~5MB). </p>
+   * <p>The provided {@link java.io.InputStream} must return <code>true</code> from {@link
+   * java.io.InputStream#markSupported()} and is expected to support a reasonably large mark limit
+   * to accommodate reading large image headers (~5MB).
    *
-   * @param is        An {@link InputStream} to the data for the image.
-   * @param requestedWidth  The width the final image should be close to.
+   * @param is An {@link InputStream} to the data for the image.
+   * @param requestedWidth The width the final image should be close to.
    * @param requestedHeight The height the final image should be close to.
-   * @param options   A set of options that may contain one or more supported options that influence
-   *                  how a Bitmap will be decoded from the given stream.
+   * @param options A set of options that may contain one or more supported options that influence
+   *     how a Bitmap will be decoded from the given stream.
    * @param callbacks A set of callbacks allowing callers to optionally respond to various
-   *                  significant events during the decode process.
+   *     significant events during the decode process.
    * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is
-   * not null.
+   *     not null.
    */
   @SuppressWarnings({"resource", "deprecation"})
-  public Resource<Bitmap> decode(InputStream is, int requestedWidth, int requestedHeight,
-      Options options, DecodeCallbacks callbacks) throws IOException {
-    Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports"
-        + " mark()");
+  public Resource<Bitmap> decode(
+      InputStream is,
+      int requestedWidth,
+      int requestedHeight,
+      Options options,
+      DecodeCallbacks callbacks)
+      throws IOException {
+    Preconditions.checkArgument(
+        is.markSupported(), "You must provide an InputStream that supports" + " mark()");
 
     byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();
     bitmapFactoryOptions.inTempStorage = bytesForOptions;
 
     DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
-    DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
+    DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);
     boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
     boolean isHardwareConfigAllowed =
-      options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);
-    if (decodeFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE) {
-      isHardwareConfigAllowed = false;
-    }
+        options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);
 
     try {
-      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,
-          requestedHeight, fixBitmapToRequestedDimensions, callbacks);
+      Bitmap result =
+          decodeFromWrappedStreams(
+              is,
+              bitmapFactoryOptions,
+              downsampleStrategy,
+              decodeFormat,
+              isHardwareConfigAllowed,
+              requestedWidth,
+              requestedHeight,
+              fixBitmapToRequestedDimensions,
+              callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
-      byteArrayPool.put(bytesForOptions, byte[].class);
+      byteArrayPool.put(bytesForOptions);
     }
   }
 
-  private Bitmap decodeFromWrappedStreams(InputStream is,
-      BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
-      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,
-      int requestedHeight, boolean fixBitmapToRequestedDimensions,
-      DecodeCallbacks callbacks) throws IOException {
+  private Bitmap decodeFromWrappedStreams(
+      InputStream is,
+      BitmapFactory.Options options,
+      DownsampleStrategy downsampleStrategy,
+      DecodeFormat decodeFormat,
+      boolean isHardwareConfigAllowed,
+      int requestedWidth,
+      int requestedHeight,
+      boolean fixBitmapToRequestedDimensions,
+      DecodeCallbacks callbacks)
+      throws IOException {
     long startTime = LogTime.getLogTime();
 
     int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);
@@ -268,13 +284,15 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {
       int expectedWidth;
       int expectedHeight;
-      if (sourceWidth >= 0 && sourceHeight >= 0
-          && fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+      if (sourceWidth >= 0
+          && sourceHeight >= 0
+          && fixBitmapToRequestedDimensions
+          && isKitKatOrGreater) {
         expectedWidth = targetWidth;
         expectedHeight = targetHeight;
       } else {
-        float densityMultiplier = isScaling(options)
-            ? (float) options.inTargetDensity / options.inDensity : 1f;
+        float densityMultiplier =
+            isScaling(options) ? (float) options.inTargetDensity / options.inDensity : 1f;
         int sampleSize = options.inSampleSize;
         int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
         int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
@@ -282,12 +300,26 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
         expectedHeight = Math.round(downsampledHeight * densityMultiplier);
 
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
-          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
-              + " [" + sourceWidth + "x" + sourceHeight + "]"
-              + ", sampleSize: " + sampleSize
-              + ", targetDensity: " + options.inTargetDensity
-              + ", density: " + options.inDensity
-              + ", density multiplier: " + densityMultiplier);
+          Log.v(
+              TAG,
+              "Calculated target ["
+                  + expectedWidth
+                  + "x"
+                  + expectedHeight
+                  + "] for source"
+                  + " ["
+                  + sourceWidth
+                  + "x"
+                  + sourceHeight
+                  + "]"
+                  + ", sampleSize: "
+                  + sampleSize
+                  + ", targetDensity: "
+                  + options.inTargetDensity
+                  + ", density: "
+                  + options.inDensity
+                  + ", density multiplier: "
+                  + densityMultiplier);
         }
       }
       // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
@@ -300,8 +332,15 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     callbacks.onDecodeComplete(bitmapPool, downsampled);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      logDecode(sourceWidth, sourceHeight, sourceMimeType, options, downsampled,
-          requestedWidth, requestedHeight, startTime);
+      logDecode(
+          sourceWidth,
+          sourceHeight,
+          sourceMimeType,
+          options,
+          downsampled,
+          requestedWidth,
+          requestedHeight,
+          startTime);
     }
 
     Bitmap rotated = null;
@@ -319,8 +358,7 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     return rotated;
   }
 
-  // Visible for testing.
-  static void calculateScaling(
+  private static void calculateScaling(
       ImageType imageType,
       InputStream is,
       DecodeCallbacks decodeCallbacks,
@@ -331,50 +369,77 @@ static void calculateScaling(
       int sourceHeight,
       int targetWidth,
       int targetHeight,
-      BitmapFactory.Options options) throws IOException {
+      BitmapFactory.Options options)
+      throws IOException {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to determine dimensions for: " + imageType
-            + " with target [" + targetWidth + "x" + targetHeight + "]");
+        Log.d(
+            TAG,
+            "Unable to determine dimensions for: "
+                + imageType
+                + " with target ["
+                + targetWidth
+                + "x"
+                + targetHeight
+                + "]");
       }
       return;
     }
 
-    final float exactScaleFactor;
+    int orientedSourceWidth = sourceWidth;
+    int orientedSourceHeight = sourceHeight;
+    // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
+    // width is decreased to near our target's height and the image height is decreased to near
+    // our target width.
+    //noinspection SuspiciousNameCombination
     if (degreesToRotate == 90 || degreesToRotate == 270) {
-      // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
-      // width is decreased to near our target's height and the image height is decreased to near
-      // our target width.
-      //noinspection SuspiciousNameCombination
-      exactScaleFactor = downsampleStrategy.getScaleFactor(sourceHeight, sourceWidth,
-          targetWidth, targetHeight);
-    } else {
-      exactScaleFactor =
-          downsampleStrategy.getScaleFactor(sourceWidth, sourceHeight, targetWidth, targetHeight);
+      orientedSourceWidth = sourceHeight;
+      orientedSourceHeight = sourceWidth;
     }
 
+    final float exactScaleFactor =
+        downsampleStrategy.getScaleFactor(
+            orientedSourceWidth, orientedSourceHeight, targetWidth, targetHeight);
+
     if (exactScaleFactor <= 0f) {
-      throw new IllegalArgumentException("Cannot scale with factor: " + exactScaleFactor
-          + " from: " + downsampleStrategy
-          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
-          + ", target: [" + targetWidth + "x" + targetHeight + "]");
+      throw new IllegalArgumentException(
+          "Cannot scale with factor: "
+              + exactScaleFactor
+              + " from: "
+              + downsampleStrategy
+              + ", source: ["
+              + sourceWidth
+              + "x"
+              + sourceHeight
+              + "]"
+              + ", target: ["
+              + targetWidth
+              + "x"
+              + targetHeight
+              + "]");
     }
-    SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth,
-        sourceHeight, targetWidth, targetHeight);
+
+    SampleSizeRounding rounding =
+        downsampleStrategy.getSampleSizeRounding(
+            orientedSourceWidth, orientedSourceHeight, targetWidth, targetHeight);
     if (rounding == null) {
       throw new IllegalArgumentException("Cannot round with null rounding");
     }
 
-    int outWidth = round(exactScaleFactor * sourceWidth);
-    int outHeight = round(exactScaleFactor * sourceHeight);
+    int outWidth = round(exactScaleFactor * orientedSourceWidth);
+    int outHeight = round(exactScaleFactor * orientedSourceHeight);
 
-    int widthScaleFactor = sourceWidth / outWidth;
-    int heightScaleFactor = sourceHeight / outHeight;
+    int widthScaleFactor = orientedSourceWidth / outWidth;
+    int heightScaleFactor = orientedSourceHeight / outHeight;
 
-    int scaleFactor = rounding == SampleSizeRounding.MEMORY
-        ? Math.max(widthScaleFactor, heightScaleFactor)
-        : Math.min(widthScaleFactor, heightScaleFactor);
+    // TODO: This isn't really right for both CenterOutside and CenterInside. Consider allowing
+    // DownsampleStrategy to pick, or trying to do something more sophisticated like picking the
+    // scale factor that leads to an exact match.
+    int scaleFactor =
+        rounding == SampleSizeRounding.MEMORY
+            ? Math.max(widthScaleFactor, heightScaleFactor)
+            : Math.min(widthScaleFactor, heightScaleFactor);
 
     int powerOfTwoSampleSize;
     // BitmapFactory does not support downsampling wbmp files on platforms <= M. See b/27305903.
@@ -402,26 +467,26 @@ static void calculateScaling(
       // After libjpegturbo's native rounding, skia does a secondary scale using floor
       // (integer division). Here we replicate that logic.
       int nativeScaling = Math.min(powerOfTwoSampleSize, 8);
-      powerOfTwoWidth = (int) Math.ceil(sourceWidth / (float) nativeScaling);
-      powerOfTwoHeight = (int) Math.ceil(sourceHeight / (float) nativeScaling);
+      powerOfTwoWidth = (int) Math.ceil(orientedSourceWidth / (float) nativeScaling);
+      powerOfTwoHeight = (int) Math.ceil(orientedSourceHeight / (float) nativeScaling);
       int secondaryScaling = powerOfTwoSampleSize / 8;
       if (secondaryScaling > 0) {
         powerOfTwoWidth = powerOfTwoWidth / secondaryScaling;
         powerOfTwoHeight = powerOfTwoHeight / secondaryScaling;
       }
     } else if (imageType == ImageType.PNG || imageType == ImageType.PNG_A) {
-      powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
-      powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+      powerOfTwoWidth = (int) Math.floor(orientedSourceWidth / (float) powerOfTwoSampleSize);
+      powerOfTwoHeight = (int) Math.floor(orientedSourceHeight / (float) powerOfTwoSampleSize);
     } else if (imageType == ImageType.WEBP || imageType == ImageType.WEBP_A) {
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
-        powerOfTwoWidth = Math.round(sourceWidth / (float) powerOfTwoSampleSize);
-        powerOfTwoHeight = Math.round(sourceHeight / (float) powerOfTwoSampleSize);
+        powerOfTwoWidth = Math.round(orientedSourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = Math.round(orientedSourceHeight / (float) powerOfTwoSampleSize);
       } else {
-        powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
-        powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+        powerOfTwoWidth = (int) Math.floor(orientedSourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = (int) Math.floor(orientedSourceHeight / (float) powerOfTwoSampleSize);
       }
-    } else if (
-        sourceWidth % powerOfTwoSampleSize != 0 || sourceHeight % powerOfTwoSampleSize != 0) {
+    } else if (orientedSourceWidth % powerOfTwoSampleSize != 0
+        || orientedSourceHeight % powerOfTwoSampleSize != 0) {
       // If we're not confident the image is in one of our types, fall back to checking the
       // dimensions again. inJustDecodeBounds decodes do obey inSampleSize.
       int[] dimensions = getDimensions(is, options, decodeCallbacks, bitmapPool);
@@ -432,12 +497,13 @@ static void calculateScaling(
       powerOfTwoWidth = dimensions[0];
       powerOfTwoHeight = dimensions[1];
     } else {
-      powerOfTwoWidth = sourceWidth / powerOfTwoSampleSize;
-      powerOfTwoHeight = sourceHeight / powerOfTwoSampleSize;
+      powerOfTwoWidth = orientedSourceWidth / powerOfTwoSampleSize;
+      powerOfTwoHeight = orientedSourceHeight / powerOfTwoSampleSize;
     }
 
-    double adjustedScaleFactor = downsampleStrategy.getScaleFactor(
-        powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);
+    double adjustedScaleFactor =
+        downsampleStrategy.getScaleFactor(
+            powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);
 
     // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
     // densities here so we calculate the final Bitmap size correctly.
@@ -452,15 +518,36 @@ static void calculateScaling(
     }
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Calculate scaling"
-          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
-          + ", target: [" + targetWidth + "x" + targetHeight + "]"
-          + ", power of two scaled: [" + powerOfTwoWidth + "x" + powerOfTwoHeight + "]"
-          + ", exact scale factor: " + exactScaleFactor
-          + ", power of 2 sample size: " + powerOfTwoSampleSize
-          + ", adjusted scale factor: " + adjustedScaleFactor
-          + ", target density: " + options.inTargetDensity
-          + ", density: " + options.inDensity);
+      Log.v(
+          TAG,
+          "Calculate scaling"
+              + ", source: ["
+              + sourceWidth
+              + "x"
+              + sourceHeight
+              + "]"
+              + ", degreesToRotate: "
+              + degreesToRotate
+              + ", target: ["
+              + targetWidth
+              + "x"
+              + targetHeight
+              + "]"
+              + ", power of two scaled: ["
+              + powerOfTwoWidth
+              + "x"
+              + powerOfTwoHeight
+              + "]"
+              + ", exact scale factor: "
+              + exactScaleFactor
+              + ", power of 2 sample size: "
+              + powerOfTwoSampleSize
+              + ", adjusted scale factor: "
+              + adjustedScaleFactor
+              + ", target density: "
+              + options.inTargetDensity
+              + ", density: "
+              + options.inDensity);
     }
   }
 
@@ -478,9 +565,10 @@ private static int adjustTargetDensityForError(double adjustedScaleFactor) {
   }
 
   private static int getDensityMultiplier(double adjustedScaleFactor) {
-    return (int) Math.round(
-        Integer.MAX_VALUE
-            * (adjustedScaleFactor <= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor));
+    return (int)
+        Math.round(
+            Integer.MAX_VALUE
+                * (adjustedScaleFactor <= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor));
   }
 
   // This is weird, but it matches the logic in a bunch of Android views/framework classes for
@@ -489,7 +577,7 @@ private static int round(double value) {
     return (int) (value + 0.5d);
   }
 
-  private boolean shouldUsePool(ImageType imageType) throws IOException {
+  private boolean shouldUsePool(ImageType imageType) {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
@@ -509,14 +597,12 @@ private void calculateConfig(
       boolean isExifOrientationRequired,
       BitmapFactory.Options optionsWithScaling,
       int targetWidth,
-      int targetHeight)
-      throws IOException {
+      int targetHeight) {
 
     if (hardwareConfigState.setHardwareConfigIfAllowed(
         targetWidth,
         targetHeight,
         optionsWithScaling,
-        format,
         isHardwareConfigAllowed,
         isExifOrientationRequired)) {
       return;
@@ -524,7 +610,6 @@ private void calculateConfig(
 
     // Changing configs can cause skewing on 4.1, see issue #128.
     if (format == DecodeFormat.PREFER_ARGB_8888
-        || format == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
         || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
       optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888;
       return;
@@ -535,16 +620,18 @@ private void calculateConfig(
       hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine whether the image has alpha or not from header"
-            + ", format " + format, e);
+        Log.d(
+            TAG,
+            "Cannot determine whether the image has alpha or not from header"
+                + ", format "
+                + format,
+            e);
       }
     }
 
     optionsWithScaling.inPreferredConfig =
         hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
-    if (optionsWithScaling.inPreferredConfig == Config.RGB_565
-        || optionsWithScaling.inPreferredConfig == Config.ARGB_4444
-        || optionsWithScaling.inPreferredConfig == Config.ALPHA_8) {
+    if (optionsWithScaling.inPreferredConfig == Config.RGB_565) {
       optionsWithScaling.inDither = true;
     }
   }
@@ -552,21 +639,29 @@ private void calculateConfig(
   /**
    * A method for getting the dimensions of an image from the given InputStream.
    *
-   * @param is      The InputStream representing the image.
+   * @param is The InputStream representing the image.
    * @param options The options to pass to {@link BitmapFactory#decodeStream(java.io.InputStream,
-   *                android.graphics.Rect, android.graphics.BitmapFactory.Options)}.
+   *     android.graphics.Rect, android.graphics.BitmapFactory.Options)}.
    * @return an array containing the dimensions of the image in the form {width, height}.
    */
-  private static int[] getDimensions(InputStream is, BitmapFactory.Options options,
-      DecodeCallbacks decodeCallbacks, BitmapPool bitmapPool) throws IOException {
+  private static int[] getDimensions(
+      InputStream is,
+      BitmapFactory.Options options,
+      DecodeCallbacks decodeCallbacks,
+      BitmapPool bitmapPool)
+      throws IOException {
     options.inJustDecodeBounds = true;
     decodeStream(is, options, decodeCallbacks, bitmapPool);
     options.inJustDecodeBounds = false;
-    return new int[] { options.outWidth, options.outHeight };
+    return new int[] {options.outWidth, options.outHeight};
   }
 
-  private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options,
-      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException {
+  private static Bitmap decodeStream(
+      InputStream is,
+      BitmapFactory.Options options,
+      DecodeCallbacks callbacks,
+      BitmapPool bitmapPool)
+      throws IOException {
     if (options.inJustDecodeBounds) {
       is.mark(MARK_POSITION);
     } else {
@@ -574,7 +669,7 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
       // size. To avoid unnecessary allocations reading image data, we fix the mark limit so that it
       // is no larger than our current buffer size here. We need to do so immediately before
       // decoding the full image to avoid having our mark limit overridden by other calls to
-      // markand reset. See issue #225.
+      // mark and reset. See issue #225.
       callbacks.onObtainBounds();
     }
     // BitmapFactory.Options out* variables are reset by most calls to decodeStream, successful or
@@ -590,7 +685,9 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
       IOException bitmapAssertionException =
           newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Failed to decode with inBitmap, trying again without Bitmap re-use",
+        Log.d(
+            TAG,
+            "Failed to decode with inBitmap, trying again without Bitmap re-use",
             bitmapAssertionException);
       }
       if (options.inBitmap != null) {
@@ -610,28 +707,52 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
 
     if (options.inJustDecodeBounds) {
       is.reset();
-
     }
     return result;
   }
 
   private static boolean isScaling(BitmapFactory.Options options) {
-    return options.inTargetDensity > 0 && options.inDensity > 0
+    return options.inTargetDensity > 0
+        && options.inDensity > 0
         && options.inTargetDensity != options.inDensity;
   }
 
-  private static void logDecode(int sourceWidth, int sourceHeight, String outMimeType,
-      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight,
+  private static void logDecode(
+      int sourceWidth,
+      int sourceHeight,
+      String outMimeType,
+      BitmapFactory.Options options,
+      Bitmap result,
+      int requestedWidth,
+      int requestedHeight,
       long startTime) {
-    Log.v(TAG, "Decoded " + getBitmapString(result)
-        + " from [" + sourceWidth + "x" + sourceHeight + "] " + outMimeType
-        + " with inBitmap " + getInBitmapString(options)
-        + " for [" + requestedWidth + "x" + requestedHeight + "]"
-        + ", sample size: " + options.inSampleSize
-        + ", density: " + options.inDensity
-        + ", target density: " + options.inTargetDensity
-        + ", thread: " + Thread.currentThread().getName()
-        + ", duration: " + LogTime.getElapsedMillis(startTime));
+    Log.v(
+        TAG,
+        "Decoded "
+            + getBitmapString(result)
+            + " from ["
+            + sourceWidth
+            + "x"
+            + sourceHeight
+            + "] "
+            + outMimeType
+            + " with inBitmap "
+            + getInBitmapString(options)
+            + " for ["
+            + requestedWidth
+            + "x"
+            + requestedHeight
+            + "]"
+            + ", sample size: "
+            + options.inSampleSize
+            + ", density: "
+            + options.inDensity
+            + ", target density: "
+            + options.inTargetDensity
+            + ", thread: "
+            + Thread.currentThread().getName()
+            + ", duration: "
+            + LogTime.getElapsedMillis(startTime));
   }
 
   private static String getInBitmapString(BitmapFactory.Options options) {
@@ -645,9 +766,16 @@ private static String getBitmapString(Bitmap bitmap) {
       return null;
     }
 
-    String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
-        ? " (" + bitmap.getAllocationByteCount() + ")" : "";
-    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
+    String sizeString =
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
+            ? " (" + bitmap.getAllocationByteCount() + ")"
+            : "";
+    return "["
+        + bitmap.getWidth()
+        + "x"
+        + bitmap.getHeight()
+        + "] "
+        + bitmap.getConfig()
         + sizeString;
   }
 
@@ -655,27 +783,50 @@ private static String getBitmapString(Bitmap bitmap) {
   // file when inBitmap is non-null, including those caused by partial or corrupt data. We still log
   // the error because the IllegalArgumentException is supposed to catch errors reusing Bitmaps, so
   // want some useful log output. In most cases this can be safely treated as a normal IOException.
-  private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentException e,
-      int outWidth, int outHeight, String outMimeType, BitmapFactory.Options options) {
-    return new IOException("Exception decoding bitmap"
-          + ", outWidth: " + outWidth
-          + ", outHeight: " + outHeight
-          + ", outMimeType: " + outMimeType
-          + ", inBitmap: " + getInBitmapString(options), e);
+  private static IOException newIoExceptionForInBitmapAssertion(
+      IllegalArgumentException e,
+      int outWidth,
+      int outHeight,
+      String outMimeType,
+      BitmapFactory.Options options) {
+    return new IOException(
+        "Exception decoding bitmap"
+            + ", outWidth: "
+            + outWidth
+            + ", outHeight: "
+            + outHeight
+            + ", outMimeType: "
+            + outMimeType
+            + ", inBitmap: "
+            + getInBitmapString(options),
+        e);
   }
 
   @SuppressWarnings("PMD.CollapsibleIfStatements")
   @TargetApi(Build.VERSION_CODES.O)
-  private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
-      int height) {
+  private static void setInBitmap(
+      BitmapFactory.Options options, BitmapPool bitmapPool, int width, int height) {
+    @Nullable Bitmap.Config expectedConfig = null;
     // Avoid short circuiting, it appears to break on some devices.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
       if (options.inPreferredConfig == Config.HARDWARE) {
         return;
       }
+      // On API 26 outConfig may be null for some images even if the image is valid, can be decoded
+      // and outWidth/outHeight/outColorSpace are populated (see b/71513049).
+      expectedConfig = options.outConfig;
+    }
+
+    if (expectedConfig == null) {
+      // We're going to guess that BitmapFactory will return us the config we're requesting. This
+      // isn't always the case, even though our guesses tend to be conservative and prefer configs
+      // of larger sizes so that the Bitmap will fit our image anyway. If we're wrong here and the
+      // config we choose is too small, our initial decode will fail, but we will retry with no
+      // inBitmap which will succeed so if we're wrong here, we're less efficient but still correct.
+      expectedConfig = options.inPreferredConfig;
     }
     // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-    options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
+    options.inBitmap = bitmapPool.getDirty(width, height, expectedConfig);
   }
 
   private static synchronized BitmapFactory.Options getDefaultOptions() {
@@ -708,6 +859,9 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inJustDecodeBounds = false;
     decodeBitmapOptions.inDensity = 0;
     decodeBitmapOptions.inTargetDensity = 0;
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      decodeBitmapOptions.outConfig = null;
+    }
     decodeBitmapOptions.outWidth = 0;
     decodeBitmapOptions.outHeight = 0;
     decodeBitmapOptions.outMimeType = null;
@@ -715,11 +869,10 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inMutable = true;
   }
 
-  /**
-   * Callbacks for key points during decodes.
-   */
+  /** Callbacks for key points during decodes. */
   public interface DecodeCallbacks {
     void onObtainBounds();
+
     void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
index 39370ce32..01aee28f4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
@@ -5,47 +5,70 @@
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
+import android.util.Log;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.request.target.Target;
 import java.util.concurrent.locks.Lock;
 
 final class DrawableToBitmapConverter {
+  private static final String TAG = "DrawableToBitmap";
+  private static final BitmapPool NO_RECYCLE_BITMAP_POOL =
+      new BitmapPoolAdapter() {
+        @Override
+        public void put(Bitmap bitmap) {
+          // Avoid calling super to avoid recycling the given Bitmap.
+        }
+      };
+
   private DrawableToBitmapConverter() {
     // Utility class.
   }
 
-  static boolean willDraw(Drawable drawable) {
-    return !(drawable.getCurrent() instanceof BitmapDrawable);
-  }
-
   @Nullable
-  static Bitmap convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+  static Resource<Bitmap> convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {
     // Handle DrawableContainer or StateListDrawables that may contain one or more BitmapDrawables.
     drawable = drawable.getCurrent();
     Bitmap result = null;
+    boolean isRecycleable = false;
     if (drawable instanceof BitmapDrawable) {
       result = ((BitmapDrawable) drawable).getBitmap();
     } else if (!(drawable instanceof Animatable)) {
       result = drawToBitmap(bitmapPool, drawable, width, height);
+      // We created and drew to the Bitmap, so it's safe for us to recycle or re-use.
+      isRecycleable = true;
     }
 
-    if (result == null) {
-      return null;
-    }
-
-    return result;
+    BitmapPool toUse = isRecycleable ? bitmapPool : NO_RECYCLE_BITMAP_POOL;
+    return BitmapResource.obtain(result, toUse);
   }
 
+  @Nullable
   private static Bitmap drawToBitmap(
       BitmapPool bitmapPool, Drawable drawable, int width, int height) {
     if (width == Target.SIZE_ORIGINAL && drawable.getIntrinsicWidth() <= 0) {
-      throw new IllegalArgumentException("Unable to draw " + drawable + " to Bitmap with "
-          + "Target.SIZE_ORIGINAL because the Drawable has no intrinsic width");
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(
+            TAG,
+            "Unable to draw "
+                + drawable
+                + " to Bitmap with Target.SIZE_ORIGINAL because the"
+                + " Drawable has no intrinsic width");
+      }
+      return null;
     }
     if (height == Target.SIZE_ORIGINAL && drawable.getIntrinsicHeight() <= 0) {
-      throw new IllegalArgumentException("Unable to draw " + drawable + " to Bitmap with "
-          + "Target.SIZE_ORIGINAL because the Drawable has no intrinsic height");
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(
+            TAG,
+            "Unable to draw "
+                + drawable
+                + " to Bitmap with Target.SIZE_ORIGINAL because the"
+                + " Drawable has no intrinsic height");
+      }
+      return null;
     }
     int targetWidth = drawable.getIntrinsicWidth() > 0 ? drawable.getIntrinsicWidth() : width;
     int targetHeight = drawable.getIntrinsicHeight() > 0 ? drawable.getIntrinsicHeight() : height;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
index faf249761..601820af3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
@@ -4,6 +4,7 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
@@ -12,66 +13,66 @@
 
 /**
  * Applies a {@link Bitmap} {@link Transformation} to {@link Drawable}s by first attempting to
- * convert the {@link Drawable} to a {@link Bitmap} and then running the {@link Transformation}
- * on the converted {@link Bitmap}.
+ * convert the {@link Drawable} to a {@link Bitmap} and then running the {@link Transformation} on
+ * the converted {@link Bitmap}.
  *
  * <p>This class is relatively efficient for {@link BitmapDrawable} where the {@link Bitmap} is
  * readily accessible. For non-{@link Bitmap} based {@link Drawable}s, this class must first try to
  * draw the {@link Drawable} to a {@link Bitmap} using {@link android.graphics.Canvas}, which is
  * less efficient. {@link Drawable}s that implement {@link android.graphics.drawable.Animatable}
- * will fail with an exception. {@link Drawable}s that return <= 0 for
- * {@link Drawable#getIntrinsicHeight()} and/or {@link Drawable#getIntrinsicWidth()} will fail
- * with an exception if the requested size is
- * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}. {@link Drawable}s without
- * intrinsic dimensions are drawn using the dimensions provided in
- * {@link Transformation#transform(Context, Resource, int, int)}. As a result, they may be
- * transformed incorrectly or in unexpected ways.
+ * will fail with an exception. {@link Drawable}s that return <= 0 for {@link
+ * Drawable#getIntrinsicHeight()} and/or {@link Drawable#getIntrinsicWidth()} will fail with an
+ * exception if the requested size is {@link
+ * com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}. {@link Drawable}s without intrinsic
+ * dimensions are drawn using the dimensions provided in {@link Transformation#transform(Context,
+ * Resource, int, int)}. As a result, they may be transformed incorrectly or in unexpected ways.
  */
 public class DrawableTransformation implements Transformation<Drawable> {
 
   private final Transformation<Bitmap> wrapped;
+  private final boolean isRequired;
 
-  public DrawableTransformation(Transformation<Bitmap> wrapped) {
+  public DrawableTransformation(Transformation<Bitmap> wrapped, boolean isRequired) {
     this.wrapped = wrapped;
+    this.isRequired = isRequired;
   }
 
   @SuppressWarnings("unchecked")
   public Transformation<BitmapDrawable> asBitmapDrawable() {
-   return (Transformation<BitmapDrawable>) (Transformation<?>) this;
+    return (Transformation<BitmapDrawable>) (Transformation<?>) this;
   }
 
+  @NonNull
   @Override
-  public Resource<Drawable> transform(Context context, Resource<Drawable> resource, int outWidth,
-      int outHeight) {
+  public Resource<Drawable> transform(
+      @NonNull Context context, @NonNull Resource<Drawable> resource, int outWidth, int outHeight) {
     BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Drawable drawable = resource.get();
-    Bitmap bitmap = DrawableToBitmapConverter.convert(bitmapPool, drawable, outWidth, outHeight);
-    if (bitmap == null) {
-      throw new IllegalArgumentException("Unable to convert " + drawable + " to a Bitmap");
+    Resource<Bitmap> bitmapResourceToTransform =
+        DrawableToBitmapConverter.convert(bitmapPool, drawable, outWidth, outHeight);
+    if (bitmapResourceToTransform == null) {
+      if (isRequired) {
+        throw new IllegalArgumentException("Unable to convert " + drawable + " to a Bitmap");
+      } else {
+        return resource;
+      }
     }
-    Resource<Bitmap> bitmapResourceToTransform = new BitmapResource(bitmap, bitmapPool);
     Resource<Bitmap> transformedBitmapResource =
         wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
 
     if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
       transformedBitmapResource.recycle();
-      // If we extracted the Bitmap from a StateListDrawable, or a BitmapDrawable then we can't
-      // recycle it here. If on the other hand, we drew the Drawable to a Canvas, we can recycle
-      // the resulting unused Bitmap.
-      if (DrawableToBitmapConverter.willDraw(drawable)) {
-        bitmapResourceToTransform.recycle();
-      }
       return resource;
     } else {
-      return newDrawableResource(context, transformedBitmapResource.get());
+      return newDrawableResource(context, transformedBitmapResource);
     }
   }
 
-  @SuppressWarnings("unchecked")
-  private Resource<Drawable> newDrawableResource(
-      Context context, Bitmap transformed) {
+  // It's clearer to cast the result in a separate line from obtaining it.
+  @SuppressWarnings({"unchecked", "PMD.UnnecessaryLocalBeforeReturn"})
+  private Resource<Drawable> newDrawableResource(Context context, Resource<Bitmap> transformed) {
     Resource<? extends Drawable> result =
-        LazyBitmapDrawableResource.obtain(context, transformed);
+        LazyBitmapDrawableResource.obtain(context.getResources(), transformed);
     return (Resource<Drawable>) result;
   }
 
@@ -90,7 +91,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java
new file mode 100644
index 000000000..630b08170
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.media.ExifInterface;
+import android.os.Build;
+import androidx.annotation.NonNull;
+import androidx.annotation.RequiresApi;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.util.ByteBufferUtil;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Uses {@link ExifInterface} to parse orientation data.
+ *
+ * <p>ExifInterface supports the HEIF format on OMR1+. Glide's {@link DefaultImageHeaderParser}
+ * doesn't currently support HEIF. In the future we should reconcile these two classes, but for now
+ * this is a simple way to ensure that HEIF files are oriented correctly on platforms where they're
+ * supported.
+ */
+@RequiresApi(Build.VERSION_CODES.O_MR1)
+public final class ExifInterfaceImageHeaderParser implements ImageHeaderParser {
+
+  @NonNull
+  @Override
+  public ImageType getType(@NonNull InputStream is) throws IOException {
+    return ImageType.UNKNOWN;
+  }
+
+  @NonNull
+  @Override
+  public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {
+    return ImageType.UNKNOWN;
+  }
+
+  @Override
+  public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
+    ExifInterface exifInterface = new ExifInterface(is);
+    int result =
+        exifInterface.getAttributeInt(
+            ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
+    if (result == ExifInterface.ORIENTATION_UNDEFINED) {
+      return ImageHeaderParser.UNKNOWN_ORIENTATION;
+    }
+    return result;
+  }
+
+  @Override
+  public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
+    return getOrientation(ByteBufferUtil.toStream(byteBuffer), byteArrayPool);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index c29ef691d..c187fae10 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import java.security.MessageDigest;
 
@@ -15,29 +14,9 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.FitCenter";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public FitCenter() {
-    // Intentionally empty.
-  }
-
-  /**
-   * @deprecated Use {@link #FitCenter()}.
-   */
-  @Deprecated
-  public FitCenter(@SuppressWarnings("unused") Context context) {
-    this();
-  }
-
-  /**
-   * @deprecated Use {@link #FitCenter()}.
-   */
-  @Deprecated
-  public FitCenter(@SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this();
-  }
-
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.fitCenter(pool, toTransform, outWidth, outHeight);
   }
 
@@ -52,9 +31,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
-
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
index fe7c0357d..46bd42043 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
@@ -5,14 +5,15 @@
 import android.graphics.BitmapFactory;
 import android.os.Build;
 import android.util.Log;
-import com.bumptech.glide.load.DecodeFormat;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.VisibleForTesting;
 import java.io.File;
 
 /**
  * State and constants for interacting with {@link android.graphics.Bitmap.Config#HARDWARE} on
  * Android O+.
  */
-final class HardwareConfigState {
+public final class HardwareConfigState {
   /**
    * The minimum size in pixels a {@link Bitmap} must be in both dimensions to be created with the
    * {@link Bitmap.Config#HARDWARE} configuration.
@@ -22,7 +23,7 @@
    *
    * @see #FD_SIZE_LIST
    */
-  private static final int MIN_HARDWARE_DIMENSION = 128;
+  @VisibleForTesting static final int MIN_HARDWARE_DIMENSION = 128;
 
   /**
    * Allows us to check to make sure we're not exceeding the FD limit for a process with hardware
@@ -48,15 +49,27 @@
   /**
    * 700 with an error of 50 Bitmaps in between at two FDs each lets us use up to 800 FDs for
    * hardware Bitmaps.
+   *
+   * <p>Prior to P, the limit per process was 1024 FDs. In P, the limit was updated to 32k FDs per
+   * process.
+   *
+   * <p>Access to this variable will be removed in a future version without deprecation.
    */
-  private static final int MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
+  public static final int DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
 
-  private volatile int decodesSinceLastFdCheck;
-  private volatile boolean isHardwareConfigAllowed = true;
+  private static volatile int fdSizeLimit = DEFAULT_MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
 
   private static volatile HardwareConfigState instance;
 
-  static HardwareConfigState getInstance() {
+  private final boolean isHardwareConfigAllowedByDeviceModel;
+
+  @GuardedBy("this")
+  private int decodesSinceLastFdCheck;
+
+  @GuardedBy("this")
+  private boolean isFdSizeBelowHardwareLimit = true;
+
+  public static HardwareConfigState getInstance() {
     if (instance == null) {
       synchronized (HardwareConfigState.class) {
         if (instance == null) {
@@ -67,32 +80,40 @@ static HardwareConfigState getInstance() {
     return instance;
   }
 
-  private HardwareConfigState() {
+  @VisibleForTesting
+  HardwareConfigState() {
+    isHardwareConfigAllowedByDeviceModel = isHardwareConfigAllowedByDeviceModel();
     // Singleton constructor.
   }
 
-  @TargetApi(Build.VERSION_CODES.O)
-  @SuppressWarnings("deprecation")
-  boolean setHardwareConfigIfAllowed(
+  public boolean isHardwareConfigAllowed(
       int targetWidth,
       int targetHeight,
-      BitmapFactory.Options optionsWithScaling,
-      DecodeFormat decodeFormat,
       boolean isHardwareConfigAllowed,
       boolean isExifOrientationRequired) {
     if (!isHardwareConfigAllowed
+        || !isHardwareConfigAllowedByDeviceModel
         || Build.VERSION.SDK_INT < Build.VERSION_CODES.O
-        || decodeFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
         || isExifOrientationRequired) {
       return false;
     }
 
-    boolean result =
-        targetWidth >= MIN_HARDWARE_DIMENSION
-            && targetHeight >= MIN_HARDWARE_DIMENSION
-            // Make sure to call isFdSizeBelowHardwareLimit last because it has side affects.
-            && isFdSizeBelowHardwareLimit();
+    return targetWidth >= MIN_HARDWARE_DIMENSION
+        && targetHeight >= MIN_HARDWARE_DIMENSION
+        // Make sure to call isFdSizeBelowHardwareLimit last because it has side affects.
+        && isFdSizeBelowHardwareLimit();
+  }
 
+  @TargetApi(Build.VERSION_CODES.O)
+  boolean setHardwareConfigIfAllowed(
+      int targetWidth,
+      int targetHeight,
+      BitmapFactory.Options optionsWithScaling,
+      boolean isHardwareConfigAllowed,
+      boolean isExifOrientationRequired) {
+    boolean result =
+        isHardwareConfigAllowed(
+            targetWidth, targetHeight, isHardwareConfigAllowed, isExifOrientationRequired);
     if (result) {
       optionsWithScaling.inPreferredConfig = Bitmap.Config.HARDWARE;
       optionsWithScaling.inMutable = false;
@@ -100,20 +121,48 @@ boolean setHardwareConfigIfAllowed(
     return result;
   }
 
+  private static boolean isHardwareConfigAllowedByDeviceModel() {
+    if (Build.MODEL == null || Build.MODEL.length() < 7) {
+      return true;
+    }
+    switch (Build.MODEL.substring(0, 7)) {
+      case "SM-N935":
+        // Fall through
+      case "SM-J720":
+        // Fall through
+      case "SM-G960":
+        // Fall through
+      case "SM-G965":
+        // Fall through
+      case "SM-G935":
+        // Fall through
+      case "SM-G930":
+        // Fall through
+      case "SM-A520":
+        // Fall through
+        return Build.VERSION.SDK_INT != Build.VERSION_CODES.O;
+      default:
+        return true;
+    }
+  }
+
   private synchronized boolean isFdSizeBelowHardwareLimit() {
     if (++decodesSinceLastFdCheck >= MINIMUM_DECODES_BETWEEN_FD_CHECKS) {
       decodesSinceLastFdCheck = 0;
       int currentFds = FD_SIZE_LIST.list().length;
-      isHardwareConfigAllowed = currentFds < MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
+      isFdSizeBelowHardwareLimit = currentFds < fdSizeLimit;
 
-      if (!isHardwareConfigAllowed && Log.isLoggable(Downsampler.TAG, Log.WARN)) {
-        Log.w(Downsampler.TAG,
+      if (!isFdSizeBelowHardwareLimit && Log.isLoggable(Downsampler.TAG, Log.WARN)) {
+        Log.w(
+            Downsampler.TAG,
             "Excluding HARDWARE bitmap config because we're over the file descriptor limit"
-                + ", file descriptors " + currentFds
-                + ", limit " + MAXIMUM_FDS_FOR_HARDWARE_CONFIGS);
+                + ", file descriptors "
+                + currentFds
+                + ", limit "
+                + fdSizeLimit);
       }
     }
 
-    return isHardwareConfigAllowed;
+    return isFdSizeBelowHardwareLimit;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/InputStreamBitmapImageDecoderResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/InputStreamBitmapImageDecoderResourceDecoder.java
new file mode 100644
index 000000000..0c0c8c0e9
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/InputStreamBitmapImageDecoderResourceDecoder.java
@@ -0,0 +1,37 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.ImageDecoder;
+import android.graphics.ImageDecoder.Source;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.ByteBufferUtil;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/** {@link InputStream} specific implementation of {@link BitmapImageDecoderResourceDecoder}. */
+@RequiresApi(api = 28)
+public final class InputStreamBitmapImageDecoderResourceDecoder
+    implements ResourceDecoder<InputStream, Bitmap> {
+  private final BitmapImageDecoderResourceDecoder wrapped = new BitmapImageDecoderResourceDecoder();
+
+  @Override
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) throws IOException {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public Resource<Bitmap> decode(
+      @NonNull InputStream stream, int width, int height, @NonNull Options options)
+      throws IOException {
+    ByteBuffer buffer = ByteBufferUtil.fromStream(stream);
+    Source source = ImageDecoder.createSource(buffer);
+    return wrapped.decode(source, width, height, options);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index 412c5cc5b..47bc0ae65 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -4,61 +4,87 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
 
 /**
- * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
- * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
+ * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given {@link
+ * android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
-    Initializable {
+public final class LazyBitmapDrawableResource implements Resource<BitmapDrawable>, Initializable {
 
-  private final Bitmap bitmap;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
+  private final Resource<Bitmap> bitmapResource;
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   *     {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) {
-    return obtain(context.getResources(), Glide.get(context).getBitmapPool(), bitmap);
+    return (LazyBitmapDrawableResource)
+        obtain(
+            context.getResources(),
+            BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));
   }
 
-  public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool bitmapPool,
-      Bitmap bitmap) {
-    return new LazyBitmapDrawableResource(resources, bitmapPool, bitmap);
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   *     {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
+  public static LazyBitmapDrawableResource obtain(
+      Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {
+    return (LazyBitmapDrawableResource)
+        obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));
   }
 
-  LazyBitmapDrawableResource(Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {
+  @Nullable
+  public static Resource<BitmapDrawable> obtain(
+      @NonNull Resources resources, @Nullable Resource<Bitmap> bitmapResource) {
+    if (bitmapResource == null) {
+      return null;
+    }
+    return new LazyBitmapDrawableResource(resources, bitmapResource);
+  }
+
+  private LazyBitmapDrawableResource(
+      @NonNull Resources resources, @NonNull Resource<Bitmap> bitmapResource) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.bitmap = Preconditions.checkNotNull(bitmap);
+    this.bitmapResource = Preconditions.checkNotNull(bitmapResource);
   }
 
+  @NonNull
   @Override
   public Class<BitmapDrawable> getResourceClass() {
     return BitmapDrawable.class;
   }
 
+  @NonNull
   @Override
   public BitmapDrawable get() {
-    return new BitmapDrawable(resources, bitmap);
+    return new BitmapDrawable(resources, bitmapResource.get());
   }
 
   @Override
   public int getSize() {
-    return Util.getBitmapByteSize(bitmap);
+    return bitmapResource.getSize();
   }
 
   @Override
   public void recycle() {
-    bitmapPool.put(bitmap);
+    bitmapResource.recycle();
   }
 
   @Override
   public void initialize() {
-    bitmap.prepareToDraw();
+    if (bitmapResource instanceof Initializable) {
+      ((Initializable) bitmapResource).initialize();
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 24f2f35ef..ebe8827c3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -17,6 +17,8 @@
  *  limitations under the License.
  */
 
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -29,26 +31,20 @@
  * and that copying takes place when filling that buffer, but this is usually outweighed by the
  * performance benefits.
  *
- * <p>A typical application pattern for the class looks like this:</p>
+ * <p>A typical application pattern for the class looks like this:
  *
  * <pre>
  * BufferedInputStream buf = new BufferedInputStream(new FileInputStream("file.java"));
  * </pre>
  */
 public class RecyclableBufferedInputStream extends FilterInputStream {
-  /**
-   * The buffer containing the current bytes read from the target InputStream.
-   */
+  /** The buffer containing the current bytes read from the target InputStream. */
   private volatile byte[] buf;
 
-  /**
-   * The total number of bytes inside the byte array {@code buf}.
-   */
+  /** The total number of bytes inside the byte array {@code buf}. */
   private int count;
 
-  /**
-   * The current limit, which when passed, invalidates the current mark.
-   */
+  /** The current limit, which when passed, invalidates the current mark. */
   private int marklimit;
 
   /**
@@ -57,19 +53,18 @@
    */
   private int markpos = -1;
 
-  /**
-   * The current position within the byte array {@code buf}.
-   */
+  /** The current position within the byte array {@code buf}. */
   private int pos;
+
   private final ArrayPool byteArrayPool;
 
-  public RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool) {
+  public RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool) {
     this(in, byteArrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
   }
 
-  // Visible for testing
-  RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool,
-      int bufferSize) {
+  @VisibleForTesting
+  RecyclableBufferedInputStream(
+      @NonNull InputStream in, @NonNull ArrayPool byteArrayPool, int bufferSize) {
     super(in);
     this.byteArrayPool = byteArrayPool;
     buf = byteArrayPool.get(bufferSize, byte[].class);
@@ -104,13 +99,15 @@ private static IOException streamClosed() throws IOException {
    * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size to
    * increase.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public synchronized void fixMarkLimit() {
     marklimit = buf.length;
   }
 
   public synchronized void release() {
     if (buf != null) {
-      byteArrayPool.put(buf, byte[].class);
+      byteArrayPool.put(buf);
       buf = null;
     }
   }
@@ -124,7 +121,7 @@ public synchronized void release() {
   @Override
   public void close() throws IOException {
     if (buf != null) {
-      byteArrayPool.put(buf, byte[].class);
+      byteArrayPool.put(buf);
       buf = null;
     }
     InputStream localIn = in;
@@ -166,7 +163,7 @@ private int fillbuf(InputStream localIn, byte[] localBuf) throws IOException {
       // Reassign buf, which will invalidate any local references
       // FIXME: what if buf was null?
       localBuf = buf = newbuf;
-      byteArrayPool.put(oldbuf, byte[].class);
+      byteArrayPool.put(oldbuf);
     } else if (markpos > 0) {
       System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length - markpos);
     }
@@ -260,19 +257,18 @@ public synchronized int read() throws IOException {
    * @param buffer the byte array in which to store the bytes read.
    * @return the number of bytes actually read or -1 if end of stream.
    * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code byteCount < 0}, or if {@code
-   *                                   offset + byteCount} is greater than the size of {@code
-   *                                   buffer}.
-   * @throws IOException               if the stream is already closed or another IOException
-   *                                   occurs.
+   *     offset + byteCount} is greater than the size of {@code buffer}.
+   * @throws IOException if the stream is already closed or another IOException occurs.
    */
   @Override
-  public synchronized int read(byte[] buffer, int offset, int byteCount) throws IOException {
+  public synchronized int read(@NonNull byte[] buffer, int offset, int byteCount)
+      throws IOException {
     // Use local ref since buf may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
     if (localBuf == null) {
       throw streamClosed();
     }
-    //Arrays.checkOffsetAndCount(buffer.length, offset, byteCount);
+    // Arrays.checkOffsetAndCount(buffer.length, offset, byteCount);
     if (byteCount == 0) {
       return 0;
     }
@@ -336,8 +332,7 @@ public synchronized int read(byte[] buffer, int offset, int byteCount) throws IO
    * Resets this stream to the last marked location.
    *
    * @throws IOException if this stream is closed, no mark has been put or the mark is no longer
-   *                     valid because more than {@code readlimit} bytes have been read since
-   *                     setting the mark.
+   *     valid because more than {@code readlimit} bytes have been read since setting the mark.
    * @see #mark(int)
    */
   @Override
@@ -346,8 +341,8 @@ public synchronized void reset() throws IOException {
       throw new IOException("Stream is closed");
     }
     if (-1 == markpos) {
-      throw new InvalidMarkException("Mark has been invalidated, pos: " + pos + " markLimit: "
-          + marklimit);
+      throw new InvalidMarkException(
+          "Mark has been invalidated, pos: " + pos + " markLimit: " + marklimit);
     }
     pos = markpos;
   }
@@ -356,31 +351,32 @@ public synchronized void reset() throws IOException {
    * Skips {@code byteCount} bytes in this stream. Subsequent calls to {@link #read} will not return
    * these bytes unless {@link #reset} is used.
    *
-   * @param byteCount the number of bytes to skip. {@link #skip} does nothing and returns 0 if
-   *                  {@code byteCount} is less than zero.
+   * @param byteCount the number of bytes to skip. This method does nothing and returns 0 if {@code
+   *     byteCount} is less than zero.
    * @return the number of bytes actually skipped.
    * @throws IOException if this stream is closed or another IOException occurs.
    */
   @Override
   public synchronized long skip(long byteCount) throws IOException {
+    if (byteCount < 1) {
+      return 0;
+    }
     // Use local refs since buf and in may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
-    InputStream localIn = in;
     if (localBuf == null) {
       throw streamClosed();
     }
-    if (byteCount < 1) {
-      return 0;
-    }
+    InputStream localIn = in;
     if (localIn == null) {
       throw streamClosed();
     }
 
     if (count - pos >= byteCount) {
-      pos += byteCount;
+      pos = (int) (pos + byteCount);
       return byteCount;
     }
-    long read = count - pos;
+    // See https://errorprone.info/bugpattern/IntLongMath.
+    long read = (long) count - pos;
     pos = count;
 
     if (markpos != -1 && byteCount <= marklimit) {
@@ -388,7 +384,8 @@ public synchronized long skip(long byteCount) throws IOException {
         return read;
       }
       if (count - pos >= byteCount - read) {
-        pos += byteCount - read;
+        // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+        pos = (int) (pos + byteCount - read);
         return byteCount;
       }
       // Couldn't get all the bytes, skip what we read.
@@ -403,10 +400,10 @@ public synchronized long skip(long byteCount) throws IOException {
    * An exception thrown when a mark can no longer be obeyed because the underlying buffer size is
    * smaller than the amount of data read after the mark position.
    */
-  public static class InvalidMarkException extends IOException {
+  static class InvalidMarkException extends IOException {
     private static final long serialVersionUID = -4338378848813561757L;
 
-    public InvalidMarkException(String detailMessage) {
+    InvalidMarkException(String detailMessage) {
       super(detailMessage);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
index be4814e51..1d3b37649 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
@@ -5,28 +5,27 @@
 import android.graphics.Canvas;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
 import com.bumptech.glide.request.target.Target;
-import java.io.IOException;
 
 /**
  * Decodes {@link Bitmap}s from resource ids.
  *
- * <p>The framework will decode some resources as {@link Drawable}s that do not wrap
- * {@link Bitmap}s. This decoder will attempt to return a {@link Bitmap} for those
- * {@link Drawable}s anyway by drawing the {@link Drawable} to a {@link Canvas}s using
- * the {@link Drawable}'s intrinsic bounds or the dimensions provided to
- * {@link #decode(Object, int, int, Options)}.
+ * <p>The framework will decode some resources as {@link Drawable}s that do not wrap {@link
+ * Bitmap}s. This decoder will attempt to return a {@link Bitmap} for those {@link Drawable}s anyway
+ * by drawing the {@link Drawable} to a {@link Canvas}s using the {@link Drawable}'s intrinsic
+ * bounds or the dimensions provided to {@link #decode(Object, int, int, Options)}.
  *
- * <p>For non-{@link Bitmap} {@link Drawable}s that return <= 0 for
- * {@link Drawable#getIntrinsicWidth()} and/or {@link Drawable#getIntrinsicHeight()}, this
- * decoder will fail if the width and height provided to {@link #decode(Object, int, int, Options)}
- * are {@link Target#SIZE_ORIGINAL}.
+ * <p>For non-{@link Bitmap} {@link Drawable}s that return <= 0 for {@link
+ * Drawable#getIntrinsicWidth()} and/or {@link Drawable#getIntrinsicHeight()}, this decoder will
+ * fail if the width and height provided to {@link #decode(Object, int, int, Options)} are {@link
+ * Target#SIZE_ORIGINAL}.
  */
 public class ResourceBitmapDecoder implements ResourceDecoder<Uri, Bitmap> {
 
@@ -39,20 +38,19 @@ public ResourceBitmapDecoder(ResourceDrawableDecoder drawableDecoder, BitmapPool
   }
 
   @Override
-  public boolean handles(Uri source, Options options) throws IOException {
+  public boolean handles(@NonNull Uri source, @NonNull Options options) {
     return ContentResolver.SCHEME_ANDROID_RESOURCE.equals(source.getScheme());
   }
 
   @Nullable
   @Override
-  public Resource<Bitmap> decode(Uri source, int width, int height, Options options)
-      throws IOException {
+  public Resource<Bitmap> decode(
+      @NonNull Uri source, int width, int height, @NonNull Options options) {
     Resource<Drawable> drawableResource = drawableDecoder.decode(source, width, height, options);
-    Bitmap bitmap =
-        DrawableToBitmapConverter.convert(bitmapPool, drawableResource.get(), width, height);
-    if (bitmap == null) {
+    if (drawableResource == null) {
       return null;
     }
-    return new BitmapResource(bitmap, bitmapPool);
+    Drawable drawable = drawableResource.get();
+    return DrawableToBitmapConverter.convert(bitmapPool, drawable, width, height);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java
new file mode 100644
index 000000000..3fbd59854
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Util;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/** A {@link BitmapTransformation} which rotates the bitmap. */
+public class Rotate extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.Rotate";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  private final int degreesToRotate;
+
+  /**
+   * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is
+   *     not modified.
+   */
+  public Rotate(int degreesToRotate) {
+    this.degreesToRotate = degreesToRotate;
+  }
+
+  @Override
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.rotateImage(toTransform, degreesToRotate);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof Rotate) {
+      Rotate other = (Rotate) o;
+      return degreesToRotate == other.degreesToRotate;
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return Util.hashCode(ID.hashCode(), Util.hashCode(degreesToRotate));
+  }
+
+  @Override
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+
+    byte[] degreesData = ByteBuffer.allocate(4).putInt(degreesToRotate).array();
+    messageDigest.update(degreesData);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
index 0e0ce2622..87e42887a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -1,17 +1,14 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
-/**
- * A {@link BitmapTransformation} which rounds the corners of a bitmap.
- */
+/** A {@link BitmapTransformation} which rounds the corners of a bitmap. */
 public final class RoundedCorners extends BitmapTransformation {
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
@@ -27,28 +24,6 @@ public RoundedCorners(int roundingRadius) {
     this.roundingRadius = roundingRadius;
   }
 
-  /**
-   * @param roundingRadius the corner radius (in device-specific pixels).
-   * @throws IllegalArgumentException if rounding radius is 0 or less.
-   *
-   * @deprecated Use {@link #RoundedCorners(int)}
-   */
-  @Deprecated
-  public RoundedCorners(@SuppressWarnings("unused") BitmapPool bitmapPool, int roundingRadius) {
-    this(roundingRadius);
-  }
-
-  /**
-   * @param roundingRadius the corner radius (in device-specific pixels).
-   * @throws IllegalArgumentException if rounding radius is 0 or less.
-   *
-   * @deprecated Use {@link #RoundedCorners(int)}
-   */
-  @Deprecated
-  public RoundedCorners(@SuppressWarnings("unused") Context context, int roundingRadius) {
-    this(roundingRadius);
-  }
-
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
@@ -66,12 +41,11 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    return Util.hashCode(ID.hashCode(),
-        Util.hashCode(roundingRadius));
+    return Util.hashCode(ID.hashCode(), Util.hashCode(roundingRadius));
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
 
     byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index 78ec0ff8b..8d977e0fd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -25,12 +26,13 @@ public StreamBitmapDecoder(Downsampler downsampler, ArrayPool byteArrayPool) {
   }
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     return downsampler.handles(source);
   }
 
   @Override
-  public Resource<Bitmap> decode(InputStream source, int width, int height, Options options)
+  public Resource<Bitmap> decode(
+      @NonNull InputStream source, int width, int height, @NonNull Options options)
       throws IOException {
 
     // Use to fix the mark limit to avoid allocating buffers that fit entire images.
@@ -74,7 +76,8 @@ public boolean handles(InputStream source, Options options) throws IOException {
     private final RecyclableBufferedInputStream bufferedStream;
     private final ExceptionCatchingInputStream exceptionStream;
 
-    public UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
+    UntrustedCallbacks(
+        RecyclableBufferedInputStream bufferedStream,
         ExceptionCatchingInputStream exceptionStream) {
       this.bufferedStream = bufferedStream;
       this.exceptionStream = exceptionStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 881d0a5c1..91fdf2c53 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.graphics.BitmapShader;
 import android.graphics.Canvas;
 import android.graphics.Color;
@@ -12,22 +13,24 @@
 import android.graphics.Shader;
 import android.media.ExifInterface;
 import android.os.Build;
-import android.support.annotation.NonNull;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import java.util.Arrays;
-import java.util.List;
+import java.util.HashSet;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
-/**
- * A class with methods to efficiently resize Bitmaps.
- */
+/** A class with methods to efficiently resize Bitmaps. */
+// Legacy Public APIs.
+@SuppressWarnings("WeakerAccess")
 public final class TransformationUtils {
   private static final String TAG = "TransformationUtils";
   public static final int PAINT_FLAGS = Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
@@ -37,28 +40,49 @@
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
 
   // See #738.
-  private static final List<String> MODELS_REQUIRING_BITMAP_LOCK =
-      Arrays.asList(
-          // Moto X gen 2
-          "XT1085",
-          "XT1092",
-          "XT1093",
-          "XT1094",
-          "XT1095",
-          "XT1096",
-          "XT1097",
-          "XT1098"
-          );
+  private static final Set<String> MODELS_REQUIRING_BITMAP_LOCK =
+      new HashSet<>(
+          Arrays.asList(
+              // Moto X gen 2
+              "XT1085",
+              "XT1092",
+              "XT1093",
+              "XT1094",
+              "XT1095",
+              "XT1096",
+              "XT1097",
+              "XT1098",
+              // Moto G gen 1
+              "XT1031",
+              "XT1028",
+              "XT937C",
+              "XT1032",
+              "XT1008",
+              "XT1033",
+              "XT1035",
+              "XT1034",
+              "XT939G",
+              "XT1039",
+              "XT1040",
+              "XT1042",
+              "XT1045",
+              // Moto G gen 2
+              "XT1063",
+              "XT1064",
+              "XT1068",
+              "XT1069",
+              "XT1072",
+              "XT1077",
+              "XT1078",
+              "XT1079"));
+
   /**
-   * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap
-   * drawing is not thread safe.
-   * This lock only locks for these specific devices. For other types of devices the lock is always
-   * available and therefore does not impact performance
+   * https://github.com/bumptech/glide/issues/738 On some devices, bitmap drawing is not thread
+   * safe. This lock only locks for these specific devices. For other types of devices the lock is
+   * always available and therefore does not impact performance
    */
   private static final Lock BITMAP_DRAWABLE_LOCK =
-      MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL)
-          && Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP_MR1
-          ? new ReentrantLock() : new NoLock();
+      MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL) ? new ReentrantLock() : new NoLock();
 
   static {
     CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
@@ -69,7 +93,6 @@ private TransformationUtils() {
     // Utility class.
   }
 
-
   public static Lock getBitmapDrawableLock() {
     return BITMAP_DRAWABLE_LOCK;
   }
@@ -79,33 +102,36 @@ public static Lock getBitmapDrawableLock() {
    * dimensions. This operation is significantly less expensive in terms of memory if a mutable
    * Bitmap with the given dimensions is passed in as well.
    *
-   * @param pool     The BitmapPool to obtain a bitmap from.
-   * @param inBitmap   The Bitmap to resize.
-   * @param width    The width in pixels of the final Bitmap.
-   * @param height   The height in pixels of the final Bitmap.
+   * @param pool The BitmapPool to obtain a bitmap from.
+   * @param inBitmap The Bitmap to resize.
+   * @param width The width in pixels of the final Bitmap.
+   * @param height The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
-      int height) {
+  public static Bitmap centerCrop(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width, int height) {
     if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
       return inBitmap;
     }
     // From ImageView/Bitmap.createScaledBitmap.
     final float scale;
-    float dx = 0, dy = 0;
+    final float dx;
+    final float dy;
     Matrix m = new Matrix();
     if (inBitmap.getWidth() * height > width * inBitmap.getHeight()) {
       scale = (float) height / (float) inBitmap.getHeight();
       dx = (width - inBitmap.getWidth() * scale) * 0.5f;
+      dy = 0;
     } else {
       scale = (float) width / (float) inBitmap.getWidth();
+      dx = 0;
       dy = (height - inBitmap.getHeight() * scale) * 0.5f;
     }
 
     m.setScale(scale, scale);
     m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
 
-    Bitmap result = pool.get(width, height, getSafeConfig(inBitmap));
+    Bitmap result = pool.get(width, height, getNonNullConfig(inBitmap));
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
     TransformationUtils.setAlpha(inBitmap, result);
 
@@ -117,15 +143,15 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
    * An expensive operation to resize the given Bitmap down so that it fits within the given
    * dimensions maintain the original proportions.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
-   * @param inBitmap  The Bitmap to shrink.
-   * @param width  The width in pixels the final image will fit within.
+   * @param pool The BitmapPool obtain a bitmap from.
+   * @param inBitmap The Bitmap to shrink.
+   * @param width The width in pixels the final image will fit within.
    * @param height The height in pixels the final image will fit within.
    * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or
-   * height matches the given dimensions and toFit fits within the given dimensions
+   *     height matches the given dimensions and toFit fits within the given dimensions
    */
-  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
-      int height) {
+  public static Bitmap fitCenter(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width, int height) {
     if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size matches input, returning input");
@@ -154,7 +180,7 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
     targetWidth = (int) (minPercentage * inBitmap.getWidth());
     targetHeight = (int) (minPercentage * inBitmap.getHeight());
 
-    Bitmap.Config config = getSafeConfig(inBitmap);
+    Bitmap.Config config = getNonNullConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
 
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
@@ -178,15 +204,15 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
    * If the Bitmap is smaller or equal to the Target it returns the original size, if not then
    * {@link #fitCenter(BitmapPool, Bitmap, int, int)} is called instead.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
-   * @param inBitmap  The Bitmap to center.
-   * @param width  The width in pixels of the target.
+   * @param pool The BitmapPool obtain a bitmap from.
+   * @param inBitmap The Bitmap to center.
+   * @param width The width in pixels of the target.
    * @param height The height in pixels of the target.
    * @return returns input Bitmap if smaller or equal to target, or toFit if the Bitmap's width or
-   * height is larger than the given dimensions
+   *     height is larger than the given dimensions
    */
-  public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
-      int height) {
+  public static Bitmap centerInside(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width, int height) {
     if (inBitmap.getWidth() <= width && inBitmap.getHeight() <= height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size larger or equal to input, returning input");
@@ -206,8 +232,8 @@ public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBi
    * the transformation for transformations that don't add or remove transparent pixels.
    *
    * @param inBitmap The {@link android.graphics.Bitmap} that will be transformed.
-   * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
-   *                    transformation.
+   * @param outBitmap The {@link android.graphics.Bitmap} that will be returned from the
+   *     transformation.
    */
   public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
     outBitmap.setHasAlpha(inBitmap.hasAlpha());
@@ -217,9 +243,9 @@ public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
    * This is an expensive operation that copies the image in place with the pixels rotated. If
    * possible rather use getOrientationMatrix, and put that as the imageMatrix on an ImageView.
    *
-   * @param imageToOrient   Image Bitmap to orient.
+   * @param imageToOrient Image Bitmap to orient.
    * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is
-   *                        returned unmodified.
+   *     returned unmodified.
    * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
    */
   public static Bitmap rotateImage(@NonNull Bitmap imageToOrient, int degreesToRotate) {
@@ -228,8 +254,15 @@ public static Bitmap rotateImage(@NonNull Bitmap imageToOrient, int degreesToRot
       if (degreesToRotate != 0) {
         Matrix matrix = new Matrix();
         matrix.setRotate(degreesToRotate);
-        result = Bitmap.createBitmap(imageToOrient, 0, 0, imageToOrient.getWidth(),
-            imageToOrient.getHeight(), matrix, true /*filter*/);
+        result =
+            Bitmap.createBitmap(
+                imageToOrient,
+                0,
+                0,
+                imageToOrient.getWidth(),
+                imageToOrient.getHeight(),
+                matrix,
+                true /*filter*/);
       }
     } catch (Exception e) {
       if (Log.isLoggable(TAG, Log.ERROR)) {
@@ -270,14 +303,13 @@ public static int getExifOrientationDegrees(int exifOrientation) {
   /**
    * Rotate and/or flip the image to match the given exif orientation.
    *
-   * @param pool            A pool that may or may not contain an image of the necessary
-   *                        dimensions.
-   * @param inBitmap        The bitmap to rotate/flip.
+   * @param pool A pool that may or may not contain an image of the necessary dimensions.
+   * @param inBitmap The bitmap to rotate/flip.
    * @param exifOrientation the exif orientation [1-8].
    * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary.
    */
-  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
-      int exifOrientation) {
+  public static Bitmap rotateImageExif(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int exifOrientation) {
     if (!isExifOrientationRequired(exifOrientation)) {
       return inBitmap;
     }
@@ -292,11 +324,13 @@ public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap i
     final int newWidth = Math.round(newRect.width());
     final int newHeight = Math.round(newRect.height());
 
-    Bitmap.Config config = getSafeConfig(inBitmap);
+    Bitmap.Config config = getNonNullConfig(inBitmap);
     Bitmap result = pool.get(newWidth, newHeight, config);
 
     matrix.postTranslate(-newRect.left, -newRect.top);
 
+    result.setHasAlpha(inBitmap.hasAlpha());
+
     applyMatrix(inBitmap, result, matrix);
     return result;
   }
@@ -321,17 +355,17 @@ public static boolean isExifOrientationRequired(int exifOrientation) {
   }
 
   /**
-   * Crop the image to a circle and resize to the specified width/height.  The circle crop will
-   * have the same width and height equal to the min-edge of the result image.
+   * Crop the image to a circle and resize to the specified width/height. The circle crop will have
+   * the same width and height equal to the min-edge of the result image.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
-   * @param inBitmap   The Bitmap to resize.
-   * @param destWidth    The width in pixels of the final Bitmap.
-   * @param destHeight   The height in pixels of the final Bitmap.
+   * @param pool The BitmapPool obtain a bitmap from.
+   * @param inBitmap The Bitmap to resize.
+   * @param destWidth The width in pixels of the final Bitmap.
+   * @param destHeight The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
-      int destWidth, int destHeight) {
+  public static Bitmap circleCrop(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int destWidth, int destHeight) {
     int destMinEdge = Math.min(destWidth, destHeight);
     float radius = destMinEdge / 2f;
 
@@ -352,7 +386,8 @@ public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     // Alpha is required for this transformation.
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
 
-    Bitmap result = pool.get(destMinEdge, destMinEdge, Bitmap.Config.ARGB_8888);
+    Bitmap.Config outConfig = getAlphaSafeConfig(inBitmap);
+    Bitmap result = pool.get(destMinEdge, destMinEdge, outConfig);
     result.setHasAlpha(true);
 
     BITMAP_DRAWABLE_LOCK.lock();
@@ -374,14 +409,14 @@ public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     return result;
   }
 
-  private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
-      @NonNull Bitmap maybeAlphaSafe) {
-    if (Bitmap.Config.ARGB_8888.equals(maybeAlphaSafe.getConfig())) {
+  private static Bitmap getAlphaSafeBitmap(
+      @NonNull BitmapPool pool, @NonNull Bitmap maybeAlphaSafe) {
+    Bitmap.Config safeConfig = getAlphaSafeConfig(maybeAlphaSafe);
+    if (safeConfig.equals(maybeAlphaSafe.getConfig())) {
       return maybeAlphaSafe;
     }
 
-    Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(),
-        Bitmap.Config.ARGB_8888);
+    Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(), safeConfig);
     new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*paint*/);
 
     // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
@@ -389,6 +424,18 @@ private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
     return argbBitmap;
   }
 
+  @NonNull
+  private static Config getAlphaSafeConfig(@NonNull Bitmap inBitmap) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      // Avoid short circuiting the sdk check.
+      if (Bitmap.Config.RGBA_F16.equals(inBitmap.getConfig())) { // NOPMD
+        return Bitmap.Config.RGBA_F16;
+      }
+    }
+
+    return Bitmap.Config.ARGB_8888;
+  }
+
   /**
    * Creates a bitmap from a source bitmap and rounds the corners.
    *
@@ -398,9 +445,8 @@ private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
    * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
    * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
-   *
-   * @deprecated Width and height are unused and ignored. Use
-   * {@link #roundedCorners(BitmapPool, Bitmap, int)} instead.
+   * @deprecated Width and height are unused and ignored. Use {@link #roundedCorners(BitmapPool,
+   *     Bitmap, int)} instead.
    */
   @Deprecated
   public static Bitmap roundedCorners(
@@ -416,9 +462,9 @@ public static Bitmap roundedCorners(
    * Creates a bitmap from a source bitmap and rounds the corners.
    *
    * <p>This method does <em>NOT</em> resize the given {@link Bitmap}, it only rounds it's corners.
-   * To both resize and round the corners of an image, consider
-   * {@link com.bumptech.glide.request.RequestOptions#transforms(Transformation[])} and/or
-   * {@link com.bumptech.glide.load.MultiTransformation}.
+   * To both resize and round the corners of an image, consider {@link
+   * com.bumptech.glide.request.RequestOptions#transform(Transformation[])} and/or {@link
+   * com.bumptech.glide.load.MultiTransformation}.
    *
    * @param inBitmap the source bitmap to use as a basis for the created bitmap.
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
@@ -430,14 +476,14 @@ public static Bitmap roundedCorners(
     Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
 
     // Alpha is required for this transformation.
+    Bitmap.Config safeConfig = getAlphaSafeConfig(inBitmap);
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
-    Bitmap result =
-        pool.get(toTransform.getWidth(), toTransform.getHeight(), Bitmap.Config.ARGB_8888);
+    Bitmap result = pool.get(toTransform.getWidth(), toTransform.getHeight(), safeConfig);
 
     result.setHasAlpha(true);
 
-    BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
-        Shader.TileMode.CLAMP);
+    BitmapShader shader =
+        new BitmapShader(toTransform, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
     Paint paint = new Paint();
     paint.setAntiAlias(true);
     paint.setShader(shader);
@@ -464,12 +510,13 @@ private static void clear(Canvas canvas) {
     canvas.setBitmap(null);
   }
 
-  private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
+  @NonNull
+  private static Bitmap.Config getNonNullConfig(@NonNull Bitmap bitmap) {
     return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
   }
 
-  private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap,
-      Matrix matrix) {
+  private static void applyMatrix(
+      @NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap, Matrix matrix) {
     BITMAP_DRAWABLE_LOCK.lock();
     try {
       Canvas canvas = new Canvas(targetBitmap);
@@ -480,7 +527,7 @@ private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap target
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
     switch (exifOrientation) {
       case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
@@ -515,7 +562,7 @@ static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
   private static final class NoLock implements Lock {
 
     @Synthetic
-    NoLock() { }
+    NoLock() {}
 
     @Override
     public void lock() {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
new file mode 100644
index 000000000..e6d9c7653
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Util;
+
+/**
+ * Passes through a (hopefully) non-owned {@link Bitmap} as a {@link Bitmap} based {@link Resource}
+ * so that the given {@link Bitmap} is not recycled.
+ */
+public final class UnitBitmapDecoder implements ResourceDecoder<Bitmap, Bitmap> {
+
+  @Override
+  public boolean handles(@NonNull Bitmap source, @NonNull Options options) {
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(
+      @NonNull Bitmap source, int width, int height, @NonNull Options options) {
+    return new NonOwnedBitmapResource(source);
+  }
+
+  private static final class NonOwnedBitmapResource implements Resource<Bitmap> {
+
+    private final Bitmap bitmap;
+
+    NonOwnedBitmapResource(@NonNull Bitmap bitmap) {
+      this.bitmap = bitmap;
+    }
+
+    @NonNull
+    @Override
+    public Class<Bitmap> getResourceClass() {
+      return Bitmap.class;
+    }
+
+    @NonNull
+    @Override
+    public Bitmap get() {
+      return bitmap;
+    }
+
+    @Override
+    public int getSize() {
+      return Util.getBitmapByteSize(bitmap);
+    }
+
+    @Override
+    public void recycle() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index 7be917bf2..a2207b1f9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -1,147 +1,29 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.content.Context;
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.security.MessageDigest;
 
 /**
- * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame
- * {@link android.graphics.Bitmap} from a {@link android.os.ParcelFileDescriptor} containing a
- * video.
+ * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame {@link
+ * android.graphics.Bitmap} from a {@link android.os.ParcelFileDescriptor} containing a video.
  *
  * @see android.media.MediaMetadataRetriever
+ * @deprecated Use {@link VideoDecoder#parcel(BitmapPool)} instead. This class may be removed and
+ *     {@link VideoDecoder} may become final in a future version of Glide.
  */
-public class VideoBitmapDecoder implements ResourceDecoder<ParcelFileDescriptor, Bitmap> {
-  /**
-   * A constant indicating we should use whatever frame we consider best, frequently not the first
-   * frame.
-   */
-  public static final long DEFAULT_FRAME = -1;
-
-  /**
-   * A long indicating the time position (in microseconds) of the target frame which will be
-   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
-   * extract the video frame.
-   *
-   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
-   * source has a frame located at the position. When this happens, a frame nearby will be returned.
-   * If the long is negative, time position and option will ignored, and any frame that the
-   * implementation considers as representative may be returned.
-   */
-  public static final Option<Long> TARGET_FRAME = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
-      new Option.CacheKeyUpdater<Long>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
-        @Override
-        public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putLong(value).array());
-          }
-        }
-      });
-
-  /**
-   * An integer indicating the frame option used to retrieve a target frame.
-   *
-   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
-   * {@link #DEFAULT_FRAME}.
-   *
-   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
-   */
-  public static final Option<Integer> FRAME_OPTION = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
-      null /*defaultValue*/,
-      new Option.CacheKeyUpdater<Integer>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
-        @Override
-        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {
-          if (value == null) {
-            return;
-          }
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putInt(value).array());
-          }
-        }
-      }
-  );
-
-  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
-      new MediaMetadataRetrieverFactory();
-
-  private final BitmapPool bitmapPool;
-  private final MediaMetadataRetrieverFactory factory;
+@Deprecated
+public class VideoBitmapDecoder extends VideoDecoder<ParcelFileDescriptor> {
 
+  @SuppressWarnings("unused")
   public VideoBitmapDecoder(Context context) {
     this(Glide.get(context).getBitmapPool());
   }
 
+  // Public API
+  @SuppressWarnings("WeakerAccess")
   public VideoBitmapDecoder(BitmapPool bitmapPool) {
-    this(bitmapPool, DEFAULT_FACTORY);
-  }
-
-  // Visible for testing.
-  VideoBitmapDecoder(BitmapPool bitmapPool, MediaMetadataRetrieverFactory factory) {
-    this.bitmapPool = bitmapPool;
-    this.factory = factory;
-  }
-
-  @Override
-  public boolean handles(ParcelFileDescriptor data, Options options) {
-    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
-    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and
-    // 50-100ms.
-    return true;
-  }
-
-  @Override
-  public Resource<Bitmap> decode(ParcelFileDescriptor resource, int outWidth, int outHeight,
-      Options options) throws IOException {
-    long frameTimeMicros = options.get(TARGET_FRAME);
-    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
-      throw new IllegalArgumentException(
-          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
-    }
-    Integer frameOption = options.get(FRAME_OPTION);
-
-    final Bitmap result;
-    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-    try {
-      mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
-      if (frameTimeMicros == DEFAULT_FRAME) {
-        result = mediaMetadataRetriever.getFrameAtTime();
-      } else if (frameOption == null) {
-        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
-      } else {
-        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
-      }
-    } catch (RuntimeException e) {
-      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
-      throw new IOException(e);
-    } finally {
-      mediaMetadataRetriever.release();
-    }
-    resource.close();
-    return BitmapResource.obtain(result, bitmapPool);
-  }
-
-  // Visible for testing.
-  static class MediaMetadataRetrieverFactory {
-    public MediaMetadataRetriever build() {
-      return new MediaMetadataRetriever();
-    }
+    super(bitmapPool, new ParcelFileDescriptorInitializer());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
new file mode 100644
index 000000000..139d617a6
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
@@ -0,0 +1,302 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.annotation.TargetApi;
+import android.content.res.AssetFileDescriptor;
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.os.ParcelFileDescriptor;
+import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * Decodes video data to Bitmaps from {@link ParcelFileDescriptor}s and {@link
+ * AssetFileDescriptor}s.
+ *
+ * @param <T> The type of data, currently either {@link ParcelFileDescriptor} or {@link
+ *     AssetFileDescriptor}.
+ */
+public class VideoDecoder<T> implements ResourceDecoder<T, Bitmap> {
+  private static final String TAG = "VideoDecoder";
+
+  /**
+   * A constant indicating we should use whatever frame we consider best, frequently not the first
+   * frame.
+   */
+  public static final long DEFAULT_FRAME = -1;
+
+  /** Matches the behavior of {@link MediaMetadataRetriever#getFrameAtTime(long)}. */
+  @VisibleForTesting
+  static final int DEFAULT_FRAME_OPTION = MediaMetadataRetriever.OPTION_CLOSEST_SYNC;
+
+  /**
+   * A long indicating the time position (in microseconds) of the target frame which will be
+   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to extract
+   * the video frame.
+   *
+   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
+   * source has a frame located at the position. When this happens, a frame nearby will be returned.
+   * If the long is negative, time position and option will ignored, and any frame that the
+   * implementation considers as representative may be returned.
+   */
+  public static final Option<Long> TARGET_FRAME =
+      Option.disk(
+          "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame",
+          DEFAULT_FRAME,
+          new Option.CacheKeyUpdater<Long>() {
+            private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
+
+            @Override
+            public void update(
+                @NonNull byte[] keyBytes,
+                @NonNull Long value,
+                @NonNull MessageDigest messageDigest) {
+              messageDigest.update(keyBytes);
+              synchronized (buffer) {
+                buffer.position(0);
+                messageDigest.update(buffer.putLong(value).array());
+              }
+            }
+          });
+
+  /**
+   * An integer indicating the frame option used to retrieve a target frame.
+   *
+   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to {@link
+   * #DEFAULT_FRAME}.
+   *
+   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static final Option<Integer> FRAME_OPTION =
+      Option.disk(
+          "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
+          /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,
+          new Option.CacheKeyUpdater<Integer>() {
+            private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+
+            @Override
+            public void update(
+                @NonNull byte[] keyBytes,
+                @NonNull Integer value,
+                @NonNull MessageDigest messageDigest) {
+              //noinspection ConstantConditions public API, people could have been doing it wrong
+              if (value == null) {
+                return;
+              }
+              messageDigest.update(keyBytes);
+              synchronized (buffer) {
+                buffer.position(0);
+                messageDigest.update(buffer.putInt(value).array());
+              }
+            }
+          });
+
+  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
+      new MediaMetadataRetrieverFactory();
+
+  private final MediaMetadataRetrieverInitializer<T> initializer;
+  private final BitmapPool bitmapPool;
+  private final MediaMetadataRetrieverFactory factory;
+
+  public static ResourceDecoder<AssetFileDescriptor, Bitmap> asset(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new AssetFileDescriptorInitializer());
+  }
+
+  public static ResourceDecoder<ParcelFileDescriptor, Bitmap> parcel(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new ParcelFileDescriptorInitializer());
+  }
+
+  VideoDecoder(BitmapPool bitmapPool, MediaMetadataRetrieverInitializer<T> initializer) {
+    this(bitmapPool, initializer, DEFAULT_FACTORY);
+  }
+
+  @VisibleForTesting
+  VideoDecoder(
+      BitmapPool bitmapPool,
+      MediaMetadataRetrieverInitializer<T> initializer,
+      MediaMetadataRetrieverFactory factory) {
+    this.bitmapPool = bitmapPool;
+    this.initializer = initializer;
+    this.factory = factory;
+  }
+
+  @Override
+  public boolean handles(@NonNull T data, @NonNull Options options) {
+    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
+    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and
+    // 50-100ms.
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(
+      @NonNull T resource, int outWidth, int outHeight, @NonNull Options options)
+      throws IOException {
+    long frameTimeMicros = options.get(TARGET_FRAME);
+    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
+      throw new IllegalArgumentException(
+          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
+    }
+    Integer frameOption = options.get(FRAME_OPTION);
+    if (frameOption == null) {
+      frameOption = DEFAULT_FRAME_OPTION;
+    }
+    DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);
+    if (downsampleStrategy == null) {
+      downsampleStrategy = DownsampleStrategy.DEFAULT;
+    }
+
+    final Bitmap result;
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    try {
+      initializer.initialize(mediaMetadataRetriever, resource);
+      result =
+          decodeFrame(
+              mediaMetadataRetriever,
+              frameTimeMicros,
+              frameOption,
+              outWidth,
+              outHeight,
+              downsampleStrategy);
+
+    } catch (RuntimeException e) {
+      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
+      throw new IOException(e);
+    } finally {
+      mediaMetadataRetriever.release();
+    }
+
+    return BitmapResource.obtain(result, bitmapPool);
+  }
+
+  @Nullable
+  private static Bitmap decodeFrame(
+      MediaMetadataRetriever mediaMetadataRetriever,
+      long frameTimeMicros,
+      int frameOption,
+      int outWidth,
+      int outHeight,
+      DownsampleStrategy strategy) {
+    Bitmap result = null;
+    // Arguably we should handle the case where just width or just height is set to
+    // Target.SIZE_ORIGINAL. Up to and including OMR1, MediaMetadataRetriever defaults to setting
+    // the dimensions to the display width and height if they aren't specified (ie
+    // getScaledFrameAtTime is not used). Given that this is an optimization only if
+    // Target.SIZE_ORIGINAL is not used and not using getScaledFrameAtTime ever would match the
+    // behavior of Glide in all versions of Android prior to OMR1, it's probably fine for now.
+    if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1
+        && outWidth != Target.SIZE_ORIGINAL
+        && outHeight != Target.SIZE_ORIGINAL
+        && strategy != DownsampleStrategy.NONE) {
+      result =
+          decodeScaledFrame(
+              mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight, strategy);
+    }
+
+    if (result == null) {
+      result = decodeOriginalFrame(mediaMetadataRetriever, frameTimeMicros, frameOption);
+    }
+
+    return result;
+  }
+
+  @TargetApi(Build.VERSION_CODES.O_MR1)
+  private static Bitmap decodeScaledFrame(
+      MediaMetadataRetriever mediaMetadataRetriever,
+      long frameTimeMicros,
+      int frameOption,
+      int outWidth,
+      int outHeight,
+      DownsampleStrategy strategy) {
+    try {
+      int originalWidth =
+          Integer.parseInt(
+              mediaMetadataRetriever.extractMetadata(
+                  MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH));
+      int originalHeight =
+          Integer.parseInt(
+              mediaMetadataRetriever.extractMetadata(
+                  MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT));
+      int orientation =
+          Integer.parseInt(
+              mediaMetadataRetriever.extractMetadata(
+                  MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION));
+
+      if (orientation == 90 || orientation == 270) {
+        int temp = originalWidth;
+        //noinspection SuspiciousNameCombination
+        originalWidth = originalHeight;
+        originalHeight = temp;
+      }
+
+      float scaleFactor =
+          strategy.getScaleFactor(originalWidth, originalHeight, outWidth, outHeight);
+
+      int decodeWidth = Math.round(scaleFactor * originalWidth);
+      int decodeHeight = Math.round(scaleFactor * originalHeight);
+
+      return mediaMetadataRetriever.getScaledFrameAtTime(
+          frameTimeMicros, frameOption, decodeWidth, decodeHeight);
+    } catch (Throwable t) {
+      // This is aggressive, but we'd rather catch errors caused by reading and/or parsing metadata
+      // here and fall back to just decoding the frame whenever possible. If the exception is thrown
+      // just from decoding the frame, then it will be thrown and exposed to callers by the method
+      // below.
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Exception trying to decode frame on oreo+", t);
+      }
+
+      return null;
+    }
+  }
+
+  private static Bitmap decodeOriginalFrame(
+      MediaMetadataRetriever mediaMetadataRetriever, long frameTimeMicros, int frameOption) {
+    return mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+  }
+
+  @VisibleForTesting
+  static class MediaMetadataRetrieverFactory {
+    public MediaMetadataRetriever build() {
+      return new MediaMetadataRetriever();
+    }
+  }
+
+  @VisibleForTesting
+  interface MediaMetadataRetrieverInitializer<T> {
+    void initialize(MediaMetadataRetriever retriever, T data);
+  }
+
+  private static final class AssetFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<AssetFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, AssetFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor(), data.getStartOffset(), data.getLength());
+    }
+  }
+
+  // Visible for VideoBitmapDecoder.
+  static final class ParcelFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<ParcelFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, ParcelFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor());
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
index 41315a302..7eca08b97 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
@@ -1,21 +1,22 @@
 package com.bumptech.glide.load.resource.bytes;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.data.DataRewinder;
-import java.io.IOException;
 import java.nio.ByteBuffer;
 
-/**
- * Rewinds {@link java.nio.ByteBuffer}s.
- */
+/** Rewinds {@link java.nio.ByteBuffer}s. */
 public class ByteBufferRewinder implements DataRewinder<ByteBuffer> {
   private final ByteBuffer buffer;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ByteBufferRewinder(ByteBuffer buffer) {
     this.buffer = buffer;
   }
 
+  @NonNull
   @Override
-  public ByteBuffer rewindAndGet() throws IOException {
+  public ByteBuffer rewindAndGet() {
     buffer.position(0);
     return buffer;
   }
@@ -25,16 +26,16 @@ public void cleanup() {
     // Do nothing.
   }
 
-  /**
-   * Factory for {@link com.bumptech.glide.load.resource.bytes.ByteBufferRewinder}.
-   */
+  /** Factory for {@link com.bumptech.glide.load.resource.bytes.ByteBufferRewinder}. */
   public static class Factory implements DataRewinder.Factory<ByteBuffer> {
 
+    @NonNull
     @Override
     public DataRewinder<ByteBuffer> build(ByteBuffer data) {
       return new ByteBufferRewinder(data);
     }
 
+    @NonNull
     @Override
     public Class<ByteBuffer> getDataClass() {
       return ByteBuffer.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
index 6b0d7a2be..ce9887f07 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
@@ -1,11 +1,10 @@
 package com.bumptech.glide.load.resource.bytes;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
-/**
- * An {@link com.bumptech.glide.load.engine.Resource} wrapping a byte array.
- */
+/** An {@link com.bumptech.glide.load.engine.Resource} wrapping a byte array. */
 public class BytesResource implements Resource<byte[]> {
   private final byte[] bytes;
 
@@ -13,12 +12,24 @@ public BytesResource(byte[] bytes) {
     this.bytes = Preconditions.checkNotNull(bytes);
   }
 
+  @NonNull
   @Override
   public Class<byte[]> getResourceClass() {
     return byte[].class;
   }
 
+  /**
+   * In most cases it will only be retrieved once (see linked methods).
+   *
+   * @return the same array every time, do not mutate the contents. Not a copy returned, because
+   *     copying the array can be prohibitively expensive and/or lead to OOMs.
+   * @see com.bumptech.glide.load.ResourceEncoder
+   * @see com.bumptech.glide.load.resource.transcode.ResourceTranscoder
+   * @see com.bumptech.glide.request.SingleRequest#onResourceReady
+   */
+  @NonNull
   @Override
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
   public byte[] get() {
     return bytes;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
index 48d06dc15..405cbe981 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
@@ -4,10 +4,12 @@
 import android.content.res.Resources;
 import android.content.res.Resources.Theme;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.DrawableRes;
-import android.support.annotation.Nullable;
-import android.support.v4.content.res.ResourcesCompat;
-import android.support.v7.content.res.AppCompatResources;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.Nullable;
+import androidx.appcompat.content.res.AppCompatResources;
+import androidx.appcompat.view.ContextThemeWrapper;
+import androidx.core.content.ContextCompat;
+import androidx.core.content.res.ResourcesCompat;
 
 /**
  * Handles decoding Drawables with the v7 support library if present and falling back to the v4
@@ -15,15 +17,15 @@
  */
 public final class DrawableDecoderCompat {
   private static volatile boolean shouldCallAppCompatResources = true;
+
   private DrawableDecoderCompat() {
     // Utility class.
   }
 
-  /**
-   * @see #getDrawable(Context, int, Theme)
-   */
-  public static Drawable getDrawable(Context context, @DrawableRes int id) {
-    return getDrawable(context, id, /*theme=*/ null);
+  /** See {@code getDrawable(Context, int, Theme)}. */
+  public static Drawable getDrawable(
+      Context ourContext, Context targetContext, @DrawableRes int id) {
+    return getDrawable(ourContext, targetContext, id, /*theme=*/ null);
   }
 
   /**
@@ -31,24 +33,40 @@ public static Drawable getDrawable(Context context, @DrawableRes int id) {
    * otherwise, depending on whether or not the v7 support library is included in the application.
    *
    * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if
-   * non-null when loading the {@link Drawable}.
+   *     non-null when loading the {@link Drawable}.
    */
-  public static Drawable getDrawable(Context context, @DrawableRes int id, @Nullable Theme theme) {
+  public static Drawable getDrawable(
+      Context ourContext, @DrawableRes int id, @Nullable Theme theme) {
+    return getDrawable(ourContext, ourContext, id, theme);
+  }
+
+  private static Drawable getDrawable(
+      Context ourContext, Context targetContext, @DrawableRes int id, @Nullable Theme theme) {
     try {
       // Race conditions may cause us to attempt to load using v7 more than once. That's ok since
       // this check is a modest optimization and the output will be correct anyway.
       if (shouldCallAppCompatResources) {
-        return loadDrawableV7(context, id);
+        return loadDrawableV7(targetContext, id, theme);
       }
     } catch (NoClassDefFoundError error) {
       shouldCallAppCompatResources = false;
+    } catch (IllegalStateException e) {
+      if (ourContext.getPackageName().equals(targetContext.getPackageName())) {
+        throw e;
+      }
+      return ContextCompat.getDrawable(targetContext, id);
+    } catch (Resources.NotFoundException e) {
+      // Ignored, this can be thrown when drawable compat attempts to decode a canary resource. If
+      // that decode attempt fails, we still want to try with the v4 ResourcesCompat below.
     }
 
-    return loadDrawableV4(context, id, theme != null ? theme : context.getTheme());
+    return loadDrawableV4(targetContext, id, theme != null ? theme : targetContext.getTheme());
   }
 
-  private static Drawable loadDrawableV7(Context context, @DrawableRes int id) {
-    return AppCompatResources.getDrawable(context, id);
+  private static Drawable loadDrawableV7(
+      Context context, @DrawableRes int id, @Nullable Theme theme) {
+    Context resourceContext = theme != null ? new ContextThemeWrapper(context, theme) : context;
+    return AppCompatResources.getDrawable(resourceContext, id);
   }
 
   private static Drawable loadDrawableV4(
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 163cbe50a..c31dde6eb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -2,37 +2,44 @@
 
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.Drawable.ConstantState;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * Simple wrapper for an Android {@link Drawable} which returns a
- * {@link android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable}
- * based on it's {@link android.graphics.drawable.Drawable.ConstantState state}.
+ * Simple wrapper for an Android {@link Drawable} which returns a {@link
+ * android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable} based on it's {@link
+ * android.graphics.drawable.Drawable.ConstantState state}.
  *
- * <b>Suggested usages only include {@code T}s where the new drawable is of the same or descendant
- * class.</b>
+ * <p><b>Suggested usages only include {@code T}s where the new drawable is of the same or
+ * descendant class.</b>
  *
  * @param <T> type of the wrapped {@link Drawable}
  */
-public abstract class DrawableResource<T extends Drawable> implements Resource<T>,
-    Initializable {
+public abstract class DrawableResource<T extends Drawable> implements Resource<T>, Initializable {
   protected final T drawable;
 
   public DrawableResource(T drawable) {
     this.drawable = Preconditions.checkNotNull(drawable);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   @Override
   public final T get() {
+    @Nullable ConstantState state = drawable.getConstantState();
+    if (state == null) {
+      return drawable;
+    }
     // Drawables contain temporary state related to how they're being displayed
     // (alpha, color filter etc), so return a new copy each time.
     // If we ever return the original drawable, it's temporary state may be changed
     // and subsequent copies may end up with that temporary state. See #276.
-    return (T) drawable.getConstantState().newDrawable();
+    return (T) state.newDrawable();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 88eeeaffa..d05077a83 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -1,21 +1,23 @@
 package com.bumptech.glide.load.resource.drawable;
 
 import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
 import com.bumptech.glide.request.transition.TransitionFactory;
 
-/**
- * Contains {@link Drawable} specific animation options.
- */
-public final class DrawableTransitionOptions extends
-    TransitionOptions<DrawableTransitionOptions, Drawable> {
+/** Contains {@link Drawable} specific animation options. */
+// Public API.
+@SuppressWarnings("WeakerAccess")
+public final class DrawableTransitionOptions
+    extends TransitionOptions<DrawableTransitionOptions, Drawable> {
 
   /**
    * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
    *
    * @see #crossFade()
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade() {
     return new DrawableTransitionOptions().crossFade();
   }
@@ -25,6 +27,7 @@ public static DrawableTransitionOptions withCrossFade() {
    *
    * @see #crossFade(int)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
@@ -34,8 +37,9 @@ public static DrawableTransitionOptions withCrossFade(int duration) {
    *
    * @see #crossFade(DrawableCrossFadeFactory)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);
   }
 
@@ -44,8 +48,9 @@ public static DrawableTransitionOptions withCrossFade(
    *
    * @see #crossFade(DrawableCrossFadeFactory.Builder)
    */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(
-      DrawableCrossFadeFactory.Builder builder) {
+      @NonNull DrawableCrossFadeFactory.Builder builder) {
     return new DrawableTransitionOptions().crossFade(builder);
   }
 
@@ -54,8 +59,9 @@ public static DrawableTransitionOptions withCrossFade(
    *
    * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
    */
+  @NonNull
   public static DrawableTransitionOptions with(
-      TransitionFactory<Drawable> transitionFactory) {
+      @NonNull TransitionFactory<Drawable> transitionFactory) {
     return new DrawableTransitionOptions().transition(transitionFactory);
   }
 
@@ -63,6 +69,7 @@ public static DrawableTransitionOptions with(
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
+  @NonNull
   public DrawableTransitionOptions crossFade() {
     return crossFade(new DrawableCrossFadeFactory.Builder());
   }
@@ -71,10 +78,11 @@ public DrawableTransitionOptions crossFade() {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    *
-   * @param duration The duration of the animation, see
-   *     {@code DrawableCrossFadeFactory.Builder(int)}
+   * @param duration The duration of the animation, see {@code
+   *     DrawableCrossFadeFactory.Builder(int)}
    * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
    */
+  @NonNull
   public DrawableTransitionOptions crossFade(int duration) {
     return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
@@ -83,7 +91,9 @@ public DrawableTransitionOptions crossFade(int duration) {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+  @NonNull
+  public DrawableTransitionOptions crossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
     return transition(drawableCrossFadeFactory);
   }
 
@@ -91,8 +101,8 @@ public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCros
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    */
-  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+  @NonNull
+  public DrawableTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Builder builder) {
     return crossFade(builder.build());
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
new file mode 100644
index 000000000..0e7b940bf
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.load.engine.Resource;
+
+/**
+ * Handles generic {@link Drawable} types where we may be uncertain of their size or type and where
+ * we don't know that it's safe for us to recycle or re-use the Drawable.
+ */
+final class NonOwnedDrawableResource extends DrawableResource<Drawable> {
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  static Resource<Drawable> newInstance(@Nullable Drawable drawable) {
+    return drawable != null ? new NonOwnedDrawableResource(drawable) : null;
+  }
+
+  private NonOwnedDrawableResource(Drawable drawable) {
+    super(drawable);
+  }
+
+  @NonNull
+  @SuppressWarnings("unchecked")
+  @Override
+  public Class<Drawable> getResourceClass() {
+    return (Class<Drawable>) drawable.getClass();
+  }
+
+  @Override
+  public int getSize() {
+    // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If
+    // there are no intrinsic bounds, we can fall back just to 1.
+    return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);
+  }
+
+  @Override
+  public void recycle() {
+    // Do nothing.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
index 376ebbc26..4c7132cf9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
@@ -3,17 +3,15 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.PackageManager.NameNotFoundException;
-import android.graphics.drawable.BitmapDrawable;
+import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.support.annotation.DrawableRes;
-import android.support.annotation.NonNull;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableResource;
-import java.io.IOException;
 import java.util.List;
 
 /**
@@ -25,6 +23,18 @@
  * other packages.
  */
 public class ResourceDrawableDecoder implements ResourceDecoder<Uri, Drawable> {
+  /**
+   * The package name to provide {@link Resources#getIdentifier(String, String, String)} when trying
+   * to find system resource ids.
+   *
+   * <p>As far as I can tell this is undocumented, but works.
+   */
+  private static final String ANDROID_PACKAGE_NAME = "android";
+  /**
+   * {@link Resources#getIdentifier(String, String, String)} documents that it will return 0 and
+   * that 0 is not a valid resouce id.
+   */
+  private static final int MISSING_RESOURCE_ID = 0;
   // android.resource://<package_name>/<type>/<name>.
   private static final int NAME_URI_PATH_SEGMENTS = 2;
   private static final int TYPE_PATH_SEGMENT_INDEX = 0;
@@ -34,98 +44,85 @@
   private static final int RESOURCE_ID_SEGMENT_INDEX = 0;
 
   private final Context context;
-  private final BitmapPool bitmapPool;
 
-  public ResourceDrawableDecoder(Context context, BitmapPool bitmapPool) {
+  public ResourceDrawableDecoder(Context context) {
     this.context = context.getApplicationContext();
-    this.bitmapPool = bitmapPool;
   }
 
   @Override
-  public boolean handles(Uri source, Options options) throws IOException {
+  public boolean handles(@NonNull Uri source, @NonNull Options options) {
     return source.getScheme().equals(ContentResolver.SCHEME_ANDROID_RESOURCE);
   }
 
-  @NonNull
+  @Nullable
   @Override
-  public Resource<Drawable> decode(Uri source, int width, int height, Options options)
-      throws IOException {
-    @DrawableRes int resId = loadResourceIdFromUri(source);
+  public Resource<Drawable> decode(
+      @NonNull Uri source, int width, int height, @NonNull Options options) {
     String packageName = source.getAuthority();
-    Context toUse = packageName.equals(context.getPackageName())
-        ? context : getContextForPackage(source, packageName);
+    Context targetContext = findContextForPackage(source, packageName);
+    @DrawableRes int resId = findResourceIdFromUri(targetContext, source);
     // We can't get a theme from another application.
-    Drawable drawable = DrawableDecoderCompat.getDrawable(toUse, resId);
-    return getDrawableResource(drawable);
+    Drawable drawable = DrawableDecoderCompat.getDrawable(context, targetContext, resId);
+    return NonOwnedDrawableResource.newInstance(drawable);
   }
 
-  @SuppressWarnings("unchecked")
-  private Resource<Drawable> getDrawableResource(Drawable drawable) {
-   if (drawable instanceof BitmapDrawable) {
-      BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;
-      return (Resource<Drawable>) (Resource<? extends Drawable>)
-          new BitmapDrawableResource(bitmapDrawable, bitmapPool);
+  @NonNull
+  private Context findContextForPackage(Uri source, String packageName) {
+    // Fast path
+    if (packageName.equals(context.getPackageName())) {
+      return context;
     }
-    return new InternalDrawableResource(drawable);
-  }
 
-  @NonNull
-  private Context getContextForPackage(Uri source, String packageName) {
     try {
       return context.createPackageContext(packageName, /*flags=*/ 0);
     } catch (NameNotFoundException e) {
+      // The parent APK holds the correct context if the resource is located in a split
+      if (packageName.contains(context.getPackageName())) {
+        return context;
+      }
+
       throw new IllegalArgumentException(
           "Failed to obtain context or unrecognized Uri format for: " + source, e);
     }
   }
 
   @DrawableRes
-  private int loadResourceIdFromUri(Uri source) {
+  private int findResourceIdFromUri(Context context, Uri source) {
     List<String> segments = source.getPathSegments();
-    @DrawableRes Integer result = null;
     if (segments.size() == NAME_URI_PATH_SEGMENTS) {
-       String packageName = source.getAuthority();
-       String typeName = segments.get(TYPE_PATH_SEGMENT_INDEX);
-       String resourceName = segments.get(NAME_PATH_SEGMENT_INDEX);
-       result = context.getResources().getIdentifier(resourceName, typeName, packageName);
+      return findResourceIdFromTypeAndNameResourceUri(context, source);
     } else if (segments.size() == ID_PATH_SEGMENTS) {
-       try {
-         result = Integer.valueOf(segments.get(RESOURCE_ID_SEGMENT_INDEX));
-       } catch (NumberFormatException e) {
-         // Ignored.
-       }
-     }
-
-     if (result == null) {
-       throw new IllegalArgumentException("Unrecognized Uri format: " + source);
-     } else if (result == 0) {
-       throw new IllegalArgumentException("Failed to obtain resource id for: " + source);
-     }
-     return result;
-  }
-
-  private static final class InternalDrawableResource extends DrawableResource<Drawable> {
-
-    InternalDrawableResource(Drawable drawable) {
-      super(drawable);
+      return findResourceIdFromResourceIdUri(source);
+    } else {
+      throw new IllegalArgumentException("Unrecognized Uri format: " + source);
     }
+  }
 
-    @SuppressWarnings("unchecked")
-    @Override
-    public Class<Drawable> getResourceClass() {
-      return (Class<Drawable>) drawable.getClass();
+  // android.resource://com.android.camera2/mipmap/logo_camera_color
+  @DrawableRes
+  private int findResourceIdFromTypeAndNameResourceUri(Context context, Uri source) {
+    List<String> segments = source.getPathSegments();
+    String packageName = source.getAuthority();
+    String typeName = segments.get(TYPE_PATH_SEGMENT_INDEX);
+    String resourceName = segments.get(NAME_PATH_SEGMENT_INDEX);
+    int result = context.getResources().getIdentifier(resourceName, typeName, packageName);
+    if (result == MISSING_RESOURCE_ID) {
+      result = Resources.getSystem().getIdentifier(resourceName, typeName, ANDROID_PACKAGE_NAME);
     }
-
-    @Override
-    public int getSize() {
-      // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If
-      // there are no intrinsic bounds, we can fall back just to 1.
-      return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);
+    if (result == MISSING_RESOURCE_ID) {
+      throw new IllegalArgumentException("Failed to find resource id for: " + source);
     }
+    return result;
+  }
 
-    @Override
-    public void recycle() {
-      // Do nothing.
+  // android.resource://com.android.camera2/123456
+  @DrawableRes
+  private int findResourceIdFromResourceIdUri(Uri source) {
+    List<String> segments = source.getPathSegments();
+    try {
+      return Integer.parseInt(segments.get(RESOURCE_ID_SEGMENT_INDEX));
+    } catch (NumberFormatException e) {
+      throw new IllegalArgumentException("Unrecognized Uri format: " + source, e);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
new file mode 100644
index 000000000..f3f4a7731
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+
+/** Passes through a {@link Drawable} as a {@link Drawable} based {@link Resource}. */
+public class UnitDrawableDecoder implements ResourceDecoder<Drawable, Drawable> {
+  @Override
+  public boolean handles(@NonNull Drawable source, @NonNull Options options) {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public Resource<Drawable> decode(
+      @NonNull Drawable source, int width, int height, @NonNull Options options) {
+    return NonOwnedDrawableResource.newInstance(source);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
index e932f3caf..5c1f5a306 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.file;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -12,12 +13,13 @@
 public class FileDecoder implements ResourceDecoder<File, File> {
 
   @Override
-  public boolean handles(File source, Options options) {
+  public boolean handles(@NonNull File source, @NonNull Options options) {
     return true;
   }
 
   @Override
-  public Resource<File> decode(File source, int width, int height, Options options) {
+  public Resource<File> decode(
+      @NonNull File source, int width, int height, @NonNull Options options) {
     return new FileResource(source);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
index beeec792e..fa944a15f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
@@ -3,9 +3,9 @@
 import com.bumptech.glide.load.resource.SimpleResource;
 import java.io.File;
 
-/**
- * A simple {@link com.bumptech.glide.load.engine.Resource} that wraps a {@link File}.
- */
+/** A simple {@link com.bumptech.glide.load.engine.Resource} that wraps a {@link File}. */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class FileResource extends SimpleResource<File> {
   public FileResource(File file) {
     super(file);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 0c85fbd1c..9f2a5fb0e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -3,11 +3,15 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
 import com.bumptech.glide.gifdecoder.StandardGifDecoder;
+import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
@@ -36,22 +40,28 @@
   private final Context context;
   private final List<ImageHeaderParser> parsers;
   private final GifHeaderParserPool parserPool;
-  private final BitmapPool bitmapPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
-        Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
+    this(
+        context,
+        Glide.get(context).getRegistry().getImageHeaderParsers(),
+        Glide.get(context).getBitmapPool(),
+        Glide.get(context).getArrayPool());
   }
 
   public ByteBufferGifDecoder(
-      Context context, List<ImageHeaderParser> parsers, BitmapPool bitmapPool,
+      Context context,
+      List<ImageHeaderParser> parsers,
+      BitmapPool bitmapPool,
       ArrayPool arrayPool) {
     this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   ByteBufferGifDecoder(
       Context context,
       List<ImageHeaderParser> parsers,
@@ -61,87 +71,106 @@ public ByteBufferGifDecoder(
       GifDecoderFactory gifDecoderFactory) {
     this.context = context.getApplicationContext();
     this.parsers = parsers;
-    this.bitmapPool = bitmapPool;
     this.gifDecoderFactory = gifDecoderFactory;
     this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
     this.parserPool = parserPool;
   }
 
   @Override
-  public boolean handles(ByteBuffer source, Options options) throws IOException {
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) throws IOException {
     return !options.get(GifOptions.DISABLE_ANIMATION)
         && ImageHeaderParserUtils.getType(parsers, source) == ImageType.GIF;
   }
 
   @Override
-  public GifDrawableResource decode(ByteBuffer source, int width, int height, Options options) {
+  public GifDrawableResource decode(
+      @NonNull ByteBuffer source, int width, int height, @NonNull Options options) {
     final GifHeaderParser parser = parserPool.obtain(source);
     try {
-      return decode(source, width, height, parser);
+      return decode(source, width, height, parser, options);
     } finally {
       parserPool.release(parser);
     }
   }
 
-  private GifDrawableResource decode(ByteBuffer byteBuffer, int width, int height,
-      GifHeaderParser parser) {
+  @Nullable
+  private GifDrawableResource decode(
+      ByteBuffer byteBuffer, int width, int height, GifHeaderParser parser, Options options) {
     long startTime = LogTime.getLogTime();
-    final GifHeader header = parser.parseHeader();
-    if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
-      // If we couldn't decode the GIF, we will end up with a frame count of 0.
-      return null;
-    }
+    try {
+      final GifHeader header = parser.parseHeader();
+      if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
+        // If we couldn't decode the GIF, we will end up with a frame count of 0.
+        return null;
+      }
 
-    int sampleSize = getSampleSize(header, width, height);
-    GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
-    gifDecoder.advance();
-    Bitmap firstFrame = gifDecoder.getNextFrame();
-    if (firstFrame == null) {
-      return null;
-    }
+      Bitmap.Config config =
+          options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565
+              ? Bitmap.Config.RGB_565
+              : Bitmap.Config.ARGB_8888;
+
+      int sampleSize = getSampleSize(header, width, height);
+      GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
+      gifDecoder.setDefaultBitmapConfig(config);
+      gifDecoder.advance();
+      Bitmap firstFrame = gifDecoder.getNextFrame();
+      if (firstFrame == null) {
+        return null;
+      }
 
-    Transformation<Bitmap> unitTransformation = UnitTransformation.get();
+      Transformation<Bitmap> unitTransformation = UnitTransformation.get();
 
-    GifDrawable gifDrawable =
-        new GifDrawable(context, gifDecoder, bitmapPool, unitTransformation, width, height,
-            firstFrame);
+      GifDrawable gifDrawable =
+          new GifDrawable(context, gifDecoder, unitTransformation, width, height, firstFrame);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      return new GifDrawableResource(gifDrawable);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-
-    return new GifDrawableResource(gifDrawable);
   }
 
   private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {
-    int exactSampleSize = Math.min(gifHeader.getHeight() / targetHeight,
-        gifHeader.getWidth() / targetWidth);
+    int exactSampleSize =
+        Math.min(gifHeader.getHeight() / targetHeight, gifHeader.getWidth() / targetWidth);
     int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);
     // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code
     // than 0.
     int sampleSize = Math.max(1, powerOfTwoSampleSize);
     if (Log.isLoggable(TAG, Log.VERBOSE) && sampleSize > 1) {
-      Log.v(TAG, "Downsampling GIF"
-          + ", sampleSize: " + sampleSize
-          + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
-          + ", actual dimens: [" + gifHeader.getWidth() + "x" + gifHeader.getHeight() + "]");
+      Log.v(
+          TAG,
+          "Downsampling GIF"
+              + ", sampleSize: "
+              + sampleSize
+              + ", target dimens: ["
+              + targetWidth
+              + "x"
+              + targetHeight
+              + "]"
+              + ", actual dimens: ["
+              + gifHeader.getWidth()
+              + "x"
+              + gifHeader.getHeight()
+              + "]");
     }
     return sampleSize;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class GifDecoderFactory {
-    public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
-        ByteBuffer data, int sampleSize) {
+    GifDecoder build(
+        GifDecoder.BitmapProvider provider, GifHeader header, ByteBuffer data, int sampleSize) {
       return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class GifHeaderParserPool {
     private final Queue<GifHeaderParser> pool = Util.createQueue(0);
 
-    public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
+    synchronized GifHeaderParser obtain(ByteBuffer buffer) {
       GifHeaderParser result = pool.poll();
       if (result == null) {
         result = new GifHeaderParser();
@@ -149,7 +178,7 @@ public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
       return result.setData(buffer);
     }
 
-    public synchronized void release(GifHeaderParser parser) {
+    synchronized void release(GifHeaderParser parser) {
       parser.clear();
       pool.offer(parser);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index a9d231006..8060fc95a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load.resource.gif;
 
-
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -21,29 +20,29 @@
    * when requested.
    */
   public GifBitmapProvider(BitmapPool bitmapPool) {
-    this(bitmapPool, null /* arrayPool */);
+    this(bitmapPool, /*arrayPool=*/ null);
   }
 
-  /**
-   * Constructs an instance with a shared array pool. Arrays will be reused where
-   * possible.
-   */
-  public GifBitmapProvider(BitmapPool bitmapPool, ArrayPool arrayPool) {
+  /** Constructs an instance with a shared array pool. Arrays will be reused where possible. */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ArrayPool arrayPool) {
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
   }
 
   @NonNull
   @Override
-  public Bitmap obtain(int width, int height, Bitmap.Config config) {
+  public Bitmap obtain(int width, int height, @NonNull Bitmap.Config config) {
     return bitmapPool.getDirty(width, height, config);
   }
 
   @Override
-  public void release(Bitmap bitmap) {
+  public void release(@NonNull Bitmap bitmap) {
     bitmapPool.put(bitmap);
   }
 
+  @NonNull
   @Override
   public byte[] obtainByteArray(int size) {
     if (arrayPool == null) {
@@ -52,15 +51,15 @@ public void release(Bitmap bitmap) {
     return arrayPool.get(size, byte[].class);
   }
 
-  @SuppressWarnings("PMD.UseVarargs")
   @Override
-  public void release(byte[] bytes) {
+  public void release(@NonNull byte[] bytes) {
     if (arrayPool == null) {
       return;
     }
-    arrayPool.put(bytes, byte[].class);
+    arrayPool.put(bytes);
   }
 
+  @NonNull
   @Override
   public int[] obtainIntArray(int size) {
     if (arrayPool == null) {
@@ -71,10 +70,10 @@ public void release(byte[] bytes) {
 
   @SuppressWarnings("PMD.UseVarargs")
   @Override
-  public void release(int[] array) {
+  public void release(@NonNull int[] array) {
     if (arrayPool == null) {
       return;
     }
-    arrayPool.put(array, int[].class);
+    arrayPool.put(array);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 5e6f98eed..d62a48437 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -12,43 +12,45 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import androidx.vectordrawable.graphics.drawable.Animatable2Compat;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * An animated {@link android.graphics.drawable.Drawable} that plays the frames of an animated GIF.
  */
-public class GifDrawable extends Drawable implements GifFrameLoader.FrameCallback,
-    Animatable {
-  /**
-   * A constant indicating that an animated drawable should loop continuously.
-   */
+public class GifDrawable extends Drawable
+    implements GifFrameLoader.FrameCallback, Animatable, Animatable2Compat {
+  /** A constant indicating that an animated drawable should loop continuously. */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final int LOOP_FOREVER = -1;
   /**
    * A constant indicating that an animated drawable should loop for its default number of times.
    * For animated GIFs, this constant indicates the GIF should use the netscape loop count if
    * present.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final int LOOP_INTRINSIC = 0;
 
+  private static final int GRAVITY = Gravity.FILL;
+
   private final GifState state;
-  /**
-   * True if the drawable is currently animating.
-   */
+  /** True if the drawable is currently animating. */
   private boolean isRunning;
-  /**
-   * True if the drawable should animate while visible.
-   */
+  /** True if the drawable should animate while visible. */
   private boolean isStarted;
-  /**
-   * True if the drawable's resources have been recycled.
-   */
+  /** True if the drawable's resources have been recycled. */
   private boolean isRecycled;
   /**
    * True if the drawable is currently visible. Default to true because on certain platforms (at
@@ -57,46 +59,74 @@
    * See issue #130.
    */
   private boolean isVisible = true;
-  /**
-   * The number of times we've looped over all the frames in the GIF.
-   */
+  /** The number of times we've looped over all the frames in the GIF. */
   private int loopCount;
-  /**
-   * The number of times to loop through the GIF animation.
-   */
+  /** The number of times to loop through the GIF animation. */
   private int maxLoopCount = LOOP_FOREVER;
 
   private boolean applyGravity;
   private Paint paint;
   private Rect destRect;
 
+  /** Callbacks to notify loop completion of a gif, where the loop count is explicitly specified. */
+  private List<AnimationCallback> animationCallbacks;
+
+  /**
+   * Constructor for GifDrawable.
+   *
+   * @param context A context.
+   * @param bitmapPool Ignored, see deprecation note.
+   * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
+   *     applied to each frame.
+   * @param targetFrameWidth The desired width of the frames displayed by this drawable (the width
+   *     of the view or {@link com.bumptech.glide.request.target.Target} this drawable is being
+   *     loaded into).
+   * @param targetFrameHeight The desired height of the frames displayed by this drawable (the
+   *     height of the view or {@link com.bumptech.glide.request.target.Target} this drawable is
+   *     being loaded into).
+   * @param gifDecoder The decoder to use to decode GIF data.
+   * @param firstFrame The decoded and transformed first frame of this GIF.
+   * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
+   * @deprecated Use {@link #GifDrawable(Context, GifDecoder, Transformation, int, int, Bitmap)}
+   */
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public GifDrawable(
+      Context context,
+      GifDecoder gifDecoder,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
+      Transformation<Bitmap> frameTransformation,
+      int targetFrameWidth,
+      int targetFrameHeight,
+      Bitmap firstFrame) {
+    this(context, gifDecoder, frameTransformation, targetFrameWidth, targetFrameHeight, firstFrame);
+  }
+
   /**
    * Constructor for GifDrawable.
    *
-   * @param context             A context.
-   * @param bitmapPool          A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}
-   *                            that can be used to return the first frame when this drawable is
-   *                            recycled.
+   * @param context A context.
    * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
-   *                            applied to each frame.
-   * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
-   *                            width of the view or
-   *                            {@link com.bumptech.glide.request.target.Target}
-   *                            this drawable is being loaded into).
-   * @param targetFrameHeight   The desired height of the frames displayed by this drawable (the
-   *                            height of the view or
-   *                            {@link com.bumptech.glide.request.target.Target}
-   *                            this drawable is being loaded into).
-   * @param gifDecoder          The decoder to use to decode GIF data.
-   * @param firstFrame          The decoded and transformed first frame of this GIF.
+   *     applied to each frame.
+   * @param targetFrameWidth The desired width of the frames displayed by this drawable (the width
+   *     of the view or {@link com.bumptech.glide.request.target.Target} this drawable is being
+   *     loaded into).
+   * @param targetFrameHeight The desired height of the frames displayed by this drawable (the
+   *     height of the view or {@link com.bumptech.glide.request.target.Target} this drawable is
+   *     being loaded into).
+   * @param gifDecoder The decoder to use to decode GIF data.
+   * @param firstFrame The decoded and transformed first frame of this GIF.
    * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
    */
-  public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
-      Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
+  public GifDrawable(
+      Context context,
+      GifDecoder gifDecoder,
+      Transformation<Bitmap> frameTransformation,
+      int targetFrameWidth,
+      int targetFrameHeight,
       Bitmap firstFrame) {
     this(
         new GifState(
-            bitmapPool,
             new GifFrameLoader(
                 // TODO(b/27524013): Factor out this call to Glide.get()
                 Glide.get(context),
@@ -112,8 +142,8 @@ public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool
   }
 
   @VisibleForTesting
-  GifDrawable(GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
-    this(new GifState(bitmapPool, frameLoader));
+  GifDrawable(GifFrameLoader frameLoader, Paint paint) {
+    this(new GifState(frameLoader));
     this.paint = paint;
   }
 
@@ -125,8 +155,10 @@ public Bitmap getFirstFrame() {
     return state.frameLoader.getFirstFrame();
   }
 
-  public void setFrameTransformation(Transformation<Bitmap> frameTransformation,
-      Bitmap firstFrame) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public void setFrameTransformation(
+      Transformation<Bitmap> frameTransformation, Bitmap firstFrame) {
     state.frameLoader.setFrameTransformation(frameTransformation, firstFrame);
   }
 
@@ -146,6 +178,8 @@ public int getFrameCount() {
    * Returns the current frame index in the range 0..{@link #getFrameCount()} - 1, or -1 if no frame
    * is displayed.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public int getFrameIndex() {
     return state.frameLoader.getCurrentIndex();
   }
@@ -157,6 +191,8 @@ private void resetLoopCount() {
   /**
    * Starts the animation from the first frame. Can only be called while animation is not running.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public void startFromFirstFrame() {
     Preconditions.checkArgument(!isRunning, "You cannot restart a currently running animation.");
     state.frameLoader.setNextStartFromFirstFrame();
@@ -179,8 +215,10 @@ public void stop() {
   }
 
   private void startRunning() {
-    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that"
-        + "you clear any references to the Drawable when clearing the corresponding request.");
+    Preconditions.checkArgument(
+        !isRecycled,
+        "You cannot start a recycled Drawable. Ensure that"
+            + "you clear any references to the Drawable when clearing the corresponding request.");
     // If we have only a single frame, we don't want to decode it endlessly.
     if (state.frameLoader.getFrameCount() == 1) {
       invalidateSelf();
@@ -198,9 +236,11 @@ private void stopRunning() {
 
   @Override
   public boolean setVisible(boolean visible, boolean restart) {
-    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource."
-        + " Ensure that you unset the Drawable from your View before changing the View's"
-        + " visibility.");
+    Preconditions.checkArgument(
+        !isRecycled,
+        "Cannot change the visibility of a recycled resource."
+            + " Ensure that you unset the Drawable from your View before changing the View's"
+            + " visibility.");
     isVisible = visible;
     if (!visible) {
       stopRunning();
@@ -237,14 +277,13 @@ protected void onBoundsChange(Rect bounds) {
   }
 
   @Override
-  public void draw(Canvas canvas) {
+  public void draw(@NonNull Canvas canvas) {
     if (isRecycled) {
       return;
     }
 
     if (applyGravity) {
-      Gravity.apply(GifState.GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(),
-          getDestRect());
+      Gravity.apply(GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(), getDestRect());
       applyGravity = false;
     }
 
@@ -282,9 +321,18 @@ public int getOpacity() {
     return PixelFormat.TRANSPARENT;
   }
 
+  // See #1087.
+  private Callback findCallback() {
+    Callback callback = getCallback();
+    while (callback instanceof Drawable) {
+      callback = ((Drawable) callback).getCallback();
+    }
+    return callback;
+  }
+
   @Override
   public void onFrameReady() {
-    if (getCallback() == null) {
+    if (findCallback() == null) {
       stop();
       invalidateSelf();
       return;
@@ -297,18 +345,25 @@ public void onFrameReady() {
     }
 
     if (maxLoopCount != LOOP_FOREVER && loopCount >= maxLoopCount) {
+      notifyAnimationEndToListeners();
       stop();
     }
   }
 
+  private void notifyAnimationEndToListeners() {
+    if (animationCallbacks != null) {
+      for (int i = 0, size = animationCallbacks.size(); i < size; i++) {
+        animationCallbacks.get(i).onAnimationEnd(this);
+      }
+    }
+  }
+
   @Override
   public ConstantState getConstantState() {
     return state;
   }
 
-  /**
-   * Clears any resources for loading frames that are currently held on to by this object.
-   */
+  /** Clears any resources for loading frames that are currently held on to by this object. */
   public void recycle() {
     isRecycled = true;
     state.frameLoader.clear();
@@ -319,10 +374,13 @@ boolean isRecycled() {
     return isRecycled;
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public void setLoopCount(int loopCount) {
     if (loopCount <= 0 && loopCount != LOOP_FOREVER && loopCount != LOOP_INTRINSIC) {
-      throw new IllegalArgumentException("Loop count must be greater than 0, or equal to "
-          + "GlideDrawable.LOOP_FOREVER, or equal to GlideDrawable.LOOP_INTRINSIC");
+      throw new IllegalArgumentException(
+          "Loop count must be greater than 0, or equal to "
+              + "GlideDrawable.LOOP_FOREVER, or equal to GlideDrawable.LOOP_INTRINSIC");
     }
 
     if (loopCount == LOOP_INTRINSIC) {
@@ -334,21 +392,56 @@ public void setLoopCount(int loopCount) {
     }
   }
 
-  static class GifState extends ConstantState {
-    static final int GRAVITY = Gravity.FILL;
-    final BitmapPool bitmapPool;
-    final GifFrameLoader frameLoader;
+  /**
+   * Register callback to listen to GifDrawable animation end event after specific loop count set by
+   * {@link GifDrawable#setLoopCount(int)}.
+   *
+   * <p>Note: This will only be called if the Gif stop because it reaches the loop count. Unregister
+   * this in onLoadCleared to avoid potential memory leak.
+   *
+   * @see GifDrawable#unregisterAnimationCallback(AnimationCallback).
+   * @param animationCallback Animation callback {@link Animatable2Compat.AnimationCallback}.
+   */
+  @Override
+  public void registerAnimationCallback(@NonNull AnimationCallback animationCallback) {
+    if (animationCallback == null) {
+      return;
+    }
+    if (animationCallbacks == null) {
+      animationCallbacks = new ArrayList<>();
+    }
+    animationCallbacks.add(animationCallback);
+  }
+
+  @Override
+  public boolean unregisterAnimationCallback(@NonNull AnimationCallback animationCallback) {
+    if (animationCallbacks == null || animationCallback == null) {
+      return false;
+    }
+    return animationCallbacks.remove(animationCallback);
+  }
+
+  @Override
+  public void clearAnimationCallbacks() {
+    if (animationCallbacks != null) {
+      animationCallbacks.clear();
+    }
+  }
+
+  static final class GifState extends ConstantState {
+    @VisibleForTesting final GifFrameLoader frameLoader;
 
-    public GifState(BitmapPool bitmapPool, GifFrameLoader frameLoader) {
-      this.bitmapPool = bitmapPool;
+    GifState(GifFrameLoader frameLoader) {
       this.frameLoader = frameLoader;
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable(Resources res) {
       return newDrawable();
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable() {
       return new GifDrawable(this);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
index f2f842381..8aef882c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
@@ -16,13 +17,15 @@
 public class GifDrawableEncoder implements ResourceEncoder<GifDrawable> {
   private static final String TAG = "GifEncoder";
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(Resource<GifDrawable> data, File file, Options options) {
+  public boolean encode(
+      @NonNull Resource<GifDrawable> data, @NonNull File file, @NonNull Options options) {
     GifDrawable drawable = data.get();
     boolean success = false;
     try {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index d0275e023..4456d4b73 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,17 +1,18 @@
 package com.bumptech.glide.load.resource.gif;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
-/**
- * A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
- */
-public class GifDrawableResource extends DrawableResource<GifDrawable>
-    implements Initializable {
+/** A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}. */
+public class GifDrawableResource extends DrawableResource<GifDrawable> implements Initializable {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public GifDrawableResource(GifDrawable drawable) {
     super(drawable);
   }
 
+  @NonNull
   @Override
   public Class<GifDrawable> getResourceClass() {
     return GifDrawable.class;
@@ -19,7 +20,7 @@ public GifDrawableResource(GifDrawable drawable) {
 
   @Override
   public int getSize() {
-   return drawable.getSize();
+    return drawable.getSize();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 06b1a4fb4..a92be3afd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
@@ -11,9 +12,9 @@
 import java.security.MessageDigest;
 
 /**
- * An {@link com.bumptech.glide.load.Transformation} that wraps a transformation for a
- * {@link Bitmap} and can apply it to every frame of any
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+ * An {@link com.bumptech.glide.load.Transformation} that wraps a transformation for a {@link
+ * Bitmap} and can apply it to every frame of any {@link
+ * com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableTransformation implements Transformation<GifDrawable> {
   private final Transformation<Bitmap> wrapped;
@@ -22,27 +23,13 @@ public GifDrawableTransformation(Transformation<Bitmap> wrapped) {
     this.wrapped = Preconditions.checkNotNull(wrapped);
   }
 
-  /**
-   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}.
-   */
-  @Deprecated
-  public GifDrawableTransformation(
-      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
-    this(wrapped);
-  }
-
-  /**
-   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}
-   */
-  @Deprecated
-  public GifDrawableTransformation(
-      Transformation<Bitmap> wrapped, @SuppressWarnings("unused") BitmapPool bitmapPool) {
-    this(wrapped);
-  }
-
+  @NonNull
   @Override
   public Resource<GifDrawable> transform(
-      Context context, Resource<GifDrawable> resource, int outWidth, int outHeight) {
+      @NonNull Context context,
+      @NonNull Resource<GifDrawable> resource,
+      int outWidth,
+      int outHeight) {
     GifDrawable drawable = resource.get();
 
     // The drawable needs to be initialized with the correct width and height in order for a view
@@ -78,7 +65,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index bda033ce9..3fc10e582 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -4,10 +4,14 @@
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
 import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
@@ -17,7 +21,7 @@
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.RequestOptions;
-import com.bumptech.glide.request.target.SimpleTarget;
+import com.bumptech.glide.request.target.CustomTarget;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
@@ -31,24 +35,33 @@
   private final GifDecoder gifDecoder;
   private final Handler handler;
   private final List<FrameCallback> callbacks = new ArrayList<>();
-  @Synthetic final RequestManager requestManager;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final RequestManager requestManager;
+
   private final BitmapPool bitmapPool;
 
-  private boolean isRunning = false;
-  private boolean isLoadPending = false;
-  private boolean startFromFirstFrame = false;
+  private boolean isRunning;
+  private boolean isLoadPending;
+  private boolean startFromFirstFrame;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
   private DelayTarget next;
   private Bitmap firstFrame;
   private Transformation<Bitmap> transformation;
+  private DelayTarget pendingTarget;
+  @Nullable private GifFrameLoader.OnEveryFrameListener onEveryFrameListener;
+  private int firstFrameSize;
+  private int width;
+  private int height;
 
   public interface FrameCallback {
     void onFrameReady();
   }
 
-  public GifFrameLoader(
+  GifFrameLoader(
       Glide glide,
       GifDecoder gifDecoder,
       int width,
@@ -91,6 +104,10 @@ void setFrameTransformation(Transformation<Bitmap> transformation, Bitmap firstF
     this.transformation = Preconditions.checkNotNull(transformation);
     this.firstFrame = Preconditions.checkNotNull(firstFrame);
     requestBuilder = requestBuilder.apply(new RequestOptions().transform(transformation));
+
+    firstFrameSize = Util.getBitmapByteSize(firstFrame);
+    width = firstFrame.getWidth();
+    height = firstFrame.getHeight();
   }
 
   Transformation<Bitmap> getFrameTransformation() {
@@ -105,10 +122,10 @@ void subscribe(FrameCallback frameCallback) {
     if (isCleared) {
       throw new IllegalStateException("Cannot subscribe to a cleared frame loader");
     }
-    boolean start = callbacks.isEmpty();
     if (callbacks.contains(frameCallback)) {
       throw new IllegalStateException("Cannot subscribe twice in a row");
     }
+    boolean start = callbacks.isEmpty();
     callbacks.add(frameCallback);
     if (start) {
       start();
@@ -123,26 +140,21 @@ void unsubscribe(FrameCallback frameCallback) {
   }
 
   int getWidth() {
-    return getCurrentFrame().getWidth();
+    return width;
   }
 
   int getHeight() {
-    return getCurrentFrame().getHeight();
+    return height;
   }
 
   int getSize() {
-    return gifDecoder.getByteSize() + getFrameSize();
+    return gifDecoder.getByteSize() + firstFrameSize;
   }
 
   int getCurrentIndex() {
     return current != null ? current.index : -1;
   }
 
-  private int getFrameSize() {
-    return Util.getBitmapByteSize(getCurrentFrame().getWidth(), getCurrentFrame().getHeight(),
-        getCurrentFrame().getConfig());
-  }
-
   ByteBuffer getBuffer() {
     return gifDecoder.getData().asReadOnlyBuffer();
   }
@@ -181,6 +193,10 @@ void clear() {
       requestManager.clear(next);
       next = null;
     }
+    if (pendingTarget != null) {
+      requestManager.clear(pendingTarget);
+      pendingTarget = null;
+    }
     gifDecoder.clear();
     isCleared = true;
   }
@@ -194,9 +210,17 @@ private void loadNextFrame() {
       return;
     }
     if (startFromFirstFrame) {
+      Preconditions.checkArgument(
+          pendingTarget == null, "Pending target must be null when starting from the first frame");
       gifDecoder.resetFrameIndex();
       startFromFirstFrame = false;
     }
+    if (pendingTarget != null) {
+      DelayTarget temp = pendingTarget;
+      pendingTarget = null;
+      onFrameReady(temp);
+      return;
+    }
     isLoadPending = true;
     // Get the delay before incrementing the pointer because the delay indicates the amount of time
     // we want to spend on the current frame.
@@ -218,14 +242,35 @@ private void recycleFirstFrame() {
   void setNextStartFromFirstFrame() {
     Preconditions.checkArgument(!isRunning, "Can't restart a running animation");
     startFromFirstFrame = true;
+    if (pendingTarget != null) {
+      requestManager.clear(pendingTarget);
+      pendingTarget = null;
+    }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
+  void setOnEveryFrameReadyListener(@Nullable OnEveryFrameListener onEveryFrameListener) {
+    this.onEveryFrameListener = onEveryFrameListener;
+  }
+
+  @VisibleForTesting
   void onFrameReady(DelayTarget delayTarget) {
+    if (onEveryFrameListener != null) {
+      onEveryFrameListener.onFrameReady();
+    }
+    isLoadPending = false;
     if (isCleared) {
       handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, delayTarget).sendToTarget();
       return;
     }
+    // If we're not running, notifying here will recycle the frame that we might currently be
+    // showing, which breaks things (see #2526). We also can't discard this frame because we've
+    // already incremented the frame pointer and can't decode the same frame again. Instead we'll
+    // just hang on to this next frame until start() or clear() are called.
+    if (!isRunning) {
+      pendingTarget = delayTarget;
+      return;
+    }
 
     if (delayTarget.getResource() != null) {
       recycleFirstFrame();
@@ -242,16 +287,15 @@ void onFrameReady(DelayTarget delayTarget) {
       }
     }
 
-    isLoadPending = false;
     loadNextFrame();
   }
 
   private class FrameLoaderCallback implements Handler.Callback {
-    public static final int MSG_DELAY = 1;
-    public static final int MSG_CLEAR = 2;
+    static final int MSG_DELAY = 1;
+    static final int MSG_CLEAR = 2;
 
     @Synthetic
-    FrameLoaderCallback() { }
+    FrameLoaderCallback() {}
 
     @Override
     public boolean handleMessage(Message msg) {
@@ -267,8 +311,8 @@ public boolean handleMessage(Message msg) {
     }
   }
 
-  // Visible for testing.
-  static class DelayTarget extends SimpleTarget<Bitmap> {
+  @VisibleForTesting
+  static class DelayTarget extends CustomTarget<Bitmap> {
     private final Handler handler;
     @Synthetic final int index;
     private final long targetTime;
@@ -285,11 +329,17 @@ Bitmap getResource() {
     }
 
     @Override
-    public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+    public void onResourceReady(
+        @NonNull Bitmap resource, @Nullable Transition<? super Bitmap> transition) {
       this.resource = resource;
       Message msg = handler.obtainMessage(FrameLoaderCallback.MSG_DELAY, this);
       handler.sendMessageAtTime(msg, targetTime);
     }
+
+    @Override
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      this.resource = null;
+    }
   }
 
   private static RequestBuilder<Bitmap> getRequestBuilder(
@@ -308,4 +358,9 @@ private static Key getFrameSignature() {
     // See #1510.
     return new ObjectKey(Math.random());
   }
+
+  @VisibleForTesting
+  interface OnEveryFrameListener {
+    void onFrameReady();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index 4e887ed11..ccfcdd939 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.graphics.Bitmap;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -20,12 +21,13 @@ public GifFrameResourceDecoder(BitmapPool bitmapPool) {
   }
 
   @Override
-  public boolean handles(GifDecoder source, Options options) {
+  public boolean handles(@NonNull GifDecoder source, @NonNull Options options) {
     return true;
   }
 
   @Override
-  public Resource<Bitmap> decode(GifDecoder source, int width, int height, Options options) {
+  public Resource<Bitmap> decode(
+      @NonNull GifDecoder source, int width, int height, @NonNull Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
index cb2f71e5e..bb93374df 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
@@ -5,9 +5,7 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 
-/**
- * Options related to decoding GIFs.
- */
+/** Options related to decoding GIFs. */
 public final class GifOptions {
 
   /**
@@ -15,16 +13,17 @@
    * with the particular GIF to determine the {@link android.graphics.Bitmap.Config} to use when
    * decoding frames of GIFs.
    */
-  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(
-      "com.bumptech.glide.load.resource.gif.GifOptions.DecodeFormat", DecodeFormat.DEFAULT);
+  public static final Option<DecodeFormat> DECODE_FORMAT =
+      Option.memory(
+          "com.bumptech.glide.load.resource.gif.GifOptions.DecodeFormat", DecodeFormat.DEFAULT);
 
   /**
    * If set to {@code true}, disables the GIF {@link com.bumptech.glide.load.ResourceDecoder}s
    * ({@link ResourceDecoder#handles(Object, Options)} will return {@code false}). Defaults to
    * {@code false}.
    */
-  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
-      "com.bumptech.glide.load.resource.gif.GifOptions.DisableAnimation", false);
+  public static final Option<Boolean> DISABLE_ANIMATION =
+      Option.memory("com.bumptech.glide.load.resource.gif.GifOptions.DisableAnimation", false);
 
   private GifOptions() {
     // Utility class.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index 6f1e35632..45b220e92 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.util.Log;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
@@ -16,8 +17,8 @@
 
 /**
  * A relatively inefficient decoder for {@link com.bumptech.glide.load.resource.gif.GifDrawable}
- * that converts {@link java.io.InputStream}s to {@link java.nio.ByteBuffer}s and then passes
- * the buffer to a wrapped decoder.
+ * that converts {@link java.io.InputStream}s to {@link java.nio.ByteBuffer}s and then passes the
+ * buffer to a wrapped decoder.
  */
 public class StreamGifDecoder implements ResourceDecoder<InputStream, GifDrawable> {
   private static final String TAG = "StreamGifDecoder";
@@ -26,22 +27,25 @@
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private final ArrayPool byteArrayPool;
 
-  public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuffer,
-      GifDrawable> byteBufferDecoder, ArrayPool byteArrayPool) {
+  public StreamGifDecoder(
+      List<ImageHeaderParser> parsers,
+      ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
+      ArrayPool byteArrayPool) {
     this.parsers = parsers;
     this.byteBufferDecoder = byteBufferDecoder;
     this.byteArrayPool = byteArrayPool;
   }
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) throws IOException {
     return !options.get(GifOptions.DISABLE_ANIMATION)
         && ImageHeaderParserUtils.getType(parsers, source, byteArrayPool) == ImageType.GIF;
   }
 
   @Override
-  public Resource<GifDrawable> decode(InputStream source, int width, int height,
-      Options options) throws IOException {
+  public Resource<GifDrawable> decode(
+      @NonNull InputStream source, int width, int height, @NonNull Options options)
+      throws IOException {
     byte[] data = inputStreamToBytes(source);
     if (data == null) {
       return null;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index 2b09adb40..799876e12 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
@@ -9,8 +11,7 @@
 /**
  * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that converts {@link
  * android.graphics.Bitmap}s into byte arrays using {@link android.graphics.Bitmap#compress
- * (android.graphics.Bitmap.CompressFormat,
- * int, java.io.OutputStream)}.
+ * (android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}.
  */
 public class BitmapBytesTranscoder implements ResourceTranscoder<Bitmap, byte[]> {
   private final Bitmap.CompressFormat compressFormat;
@@ -20,13 +21,17 @@ public BitmapBytesTranscoder() {
     this(Bitmap.CompressFormat.JPEG, 100);
   }
 
-  public BitmapBytesTranscoder(Bitmap.CompressFormat compressFormat, int quality) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapBytesTranscoder(@NonNull Bitmap.CompressFormat compressFormat, int quality) {
     this.compressFormat = compressFormat;
     this.quality = quality;
   }
 
+  @Nullable
   @Override
-  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {
+  public Resource<byte[]> transcode(
+      @NonNull Resource<Bitmap> toTranscode, @NonNull Options options) {
     ByteArrayOutputStream os = new ByteArrayOutputStream();
     toTranscode.get().compress(compressFormat, quality, os);
     toTranscode.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index 03642bbe4..c4abeed72 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -4,7 +4,8 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -17,19 +18,28 @@
  */
 public class BitmapDrawableTranscoder implements ResourceTranscoder<Bitmap, BitmapDrawable> {
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
-  public BitmapDrawableTranscoder(Context context) {
-    this(context.getResources(), Glide.get(context).getBitmapPool());
+  // Public API.
+  @SuppressWarnings("unused")
+  public BitmapDrawableTranscoder(@NonNull Context context) {
+    this(context.getResources());
   }
 
-  public BitmapDrawableTranscoder(Resources resources, BitmapPool bitmapPool) {
+  /** @deprecated Use {@link #BitmapDrawableTranscoder(Resources)}, {@code bitmapPool} is unused. */
+  @Deprecated
+  public BitmapDrawableTranscoder(
+      @NonNull Resources resources, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(resources);
+  }
+
+  public BitmapDrawableTranscoder(@NonNull Resources resources) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
   }
 
+  @Nullable
   @Override
-  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, toTranscode.get());
+  public Resource<BitmapDrawable> transcode(
+      @NonNull Resource<Bitmap> toTranscode, @NonNull Options options) {
+    return LazyBitmapDrawableResource.obtain(resources, toTranscode);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
new file mode 100644
index 000000000..6c199c9b9
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide.load.resource.transcode;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+
+/**
+ * Obtains {@code byte[]} from {@link BitmapDrawable}s by delegating to a {@link ResourceTranscoder}
+ * for {@link Bitmap}s to {@code byte[]}s.
+ */
+public final class DrawableBytesTranscoder implements ResourceTranscoder<Drawable, byte[]> {
+  private final BitmapPool bitmapPool;
+  private final ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder;
+  private final ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder;
+
+  public DrawableBytesTranscoder(
+      @NonNull BitmapPool bitmapPool,
+      @NonNull ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder,
+      @NonNull ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder) {
+    this.bitmapPool = bitmapPool;
+    this.bitmapBytesTranscoder = bitmapBytesTranscoder;
+    this.gifDrawableBytesTranscoder = gifDrawableBytesTranscoder;
+  }
+
+  @Nullable
+  @Override
+  public Resource<byte[]> transcode(
+      @NonNull Resource<Drawable> toTranscode, @NonNull Options options) {
+    Drawable drawable = toTranscode.get();
+    if (drawable instanceof BitmapDrawable) {
+      return bitmapBytesTranscoder.transcode(
+          BitmapResource.obtain(((BitmapDrawable) drawable).getBitmap(), bitmapPool), options);
+    } else if (drawable instanceof GifDrawable) {
+      return gifDrawableBytesTranscoder.transcode(toGifDrawableResource(toTranscode), options);
+    }
+    return null;
+  }
+
+  @SuppressWarnings("unchecked")
+  @NonNull
+  private static Resource<GifDrawable> toGifDrawableResource(@NonNull Resource<Drawable> resource) {
+    return (Resource<GifDrawable>) (Resource<?>) resource;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 0bc3c12b3..7e8155c5d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
@@ -13,8 +15,10 @@
  * the GIF from the {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableBytesTranscoder implements ResourceTranscoder<GifDrawable, byte[]> {
+  @Nullable
   @Override
-  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode, Options options) {
+  public Resource<byte[]> transcode(
+      @NonNull Resource<GifDrawable> toTranscode, @NonNull Options options) {
     GifDrawable gifData = toTranscode.get();
     ByteBuffer byteBuffer = gifData.getBuffer();
     return new BytesResource(ByteBufferUtil.toBytes(byteBuffer));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index e84bd6b00..926a83b7e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -16,5 +18,6 @@
    *
    * @param toTranscode The resource to transcode.
    */
-  Resource<R> transcode(Resource<Z> toTranscode, Options options);
+  @Nullable
+  Resource<R> transcode(@NonNull Resource<Z> toTranscode, @NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
index b632c35ad..18bd05f16 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
@@ -15,29 +16,32 @@
    * Registers the given {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} using
    * the given classes so it can later be retrieved using the given classes.
    *
-   * @param decodedClass    The class of the resource that the transcoder transcodes from.
+   * @param decodedClass The class of the resource that the transcoder transcodes from.
    * @param transcodedClass The class of the resource that the transcoder transcodes to.
-   * @param transcoder      The transcoder.
-   * @param <Z>             The type of the resource that the transcoder transcodes from.
-   * @param <R>             The type of the resource that the transcoder transcodes to.
+   * @param transcoder The transcoder.
+   * @param <Z> The type of the resource that the transcoder transcodes from.
+   * @param <R> The type of the resource that the transcoder transcodes to.
    */
-  public synchronized <Z, R> void register(Class<Z> decodedClass, Class<R> transcodedClass,
-      ResourceTranscoder<Z, R> transcoder) {
+  public synchronized <Z, R> void register(
+      @NonNull Class<Z> decodedClass,
+      @NonNull Class<R> transcodedClass,
+      @NonNull ResourceTranscoder<Z, R> transcoder) {
     transcoders.add(new Entry<>(decodedClass, transcodedClass, transcoder));
   }
 
   /**
-   * Returns the currently registered
-   * {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} for the given classes.
+   * Returns the currently registered {@link
+   * com.bumptech.glide.load.resource.transcode.ResourceTranscoder} for the given classes.
    *
-   * @param resourceClass   The class of the resource that the transcoder transcodes from.
+   * @param resourceClass The class of the resource that the transcoder transcodes from.
    * @param transcodedClass The class of the resource that the transcoder transcodes to.
-   * @param <Z>             The type of the resource that the transcoder transcodes from.
-   * @param <R>             The type of the resource that the transcoder transcodes to.
+   * @param <Z> The type of the resource that the transcoder transcodes from.
+   * @param <R> The type of the resource that the transcoder transcodes to.
    */
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <Z, R> ResourceTranscoder<Z, R> get(Class<Z> resourceClass,
-      Class<R> transcodedClass) {
+  public synchronized <Z, R> ResourceTranscoder<Z, R> get(
+      @NonNull Class<Z> resourceClass, @NonNull Class<R> transcodedClass) {
     // For example, there may be a transcoder that can convert a GifDrawable to a Drawable, which
     // will be caught above. However, if there is no registered transcoder, we can still just use
     // the UnitTranscoder to return the Drawable because the transcode class (Drawable) is
@@ -55,8 +59,9 @@
         "No transcoder registered to transcode from " + resourceClass + " to " + transcodedClass);
   }
 
-  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(Class<Z> resourceClass,
-      Class<R> transcodeClass) {
+  @NonNull
+  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(
+      @NonNull Class<Z> resourceClass, @NonNull Class<R> transcodeClass) {
     List<Class<R>> transcodeClasses = new ArrayList<>();
     // GifDrawable -> Drawable is just the UnitTranscoder, as is GifDrawable -> GifDrawable.
     if (transcodeClass.isAssignableFrom(resourceClass)) {
@@ -78,7 +83,10 @@
     private final Class<R> toClass;
     @Synthetic final ResourceTranscoder<Z, R> transcoder;
 
-    Entry(Class<Z> fromClass, Class<R> toClass, ResourceTranscoder<Z, R> transcoder) {
+    Entry(
+        @NonNull Class<Z> fromClass,
+        @NonNull Class<R> toClass,
+        @NonNull ResourceTranscoder<Z, R> transcoder) {
       this.fromClass = fromClass;
       this.toClass = toClass;
       this.transcoder = transcoder;
@@ -86,11 +94,11 @@
 
     /**
      * If we convert from a specific Drawable, we must get that specific Drawable class or a
-     * subclass of that Drawable. In contrast, if we we convert <em>to</em> a specific Drawable,
-     * we can fulfill requests for a more generic parent class (like Drawable). As a result, we
-     * check fromClass and toClass in different orders.
+     * subclass of that Drawable. In contrast, if we we convert <em>to</em> a specific Drawable, we
+     * can fulfill requests for a more generic parent class (like Drawable). As a result, we check
+     * fromClass and toClass in different orders.
      */
-    public boolean handles(Class<?> fromClass, Class<?> toClass) {
+    public boolean handles(@NonNull Class<?> fromClass, @NonNull Class<?> toClass) {
       return this.fromClass.isAssignableFrom(fromClass) && toClass.isAssignableFrom(this.toClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
index 0fd6d0964..5001a60d1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -9,15 +11,16 @@
  * @param <Z> The type of the resource that will be transcoded from and to.
  */
 public class UnitTranscoder<Z> implements ResourceTranscoder<Z, Z> {
-  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<Object>();
+  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<>();
 
   @SuppressWarnings("unchecked")
   public static <Z> ResourceTranscoder<Z, Z> get() {
     return (ResourceTranscoder<Z, Z>) UNIT_TRANSCODER;
   }
 
+  @Nullable
   @Override
-  public Resource<Z> transcode(Resource<Z> toTranscode, Options options) {
+  public Resource<Z> transcode(@NonNull Resource<Z> toTranscode, @NonNull Options options) {
     return toTranscode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index fd88428e8..120278c59 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.util.Util;
 import java.util.Collections;
 import java.util.Set;
@@ -18,16 +19,16 @@
   /**
    * Adds the given listener to the list of listeners to be notified on each lifecycle event.
    *
-   * <p> The latest lifecycle event will be called on the given listener synchronously in this
+   * <p>The latest lifecycle event will be called on the given listener synchronously in this
    * method. If the activity or fragment is stopped, {@link LifecycleListener#onStop()}} will be
-   * called, and same for onStart and onDestroy. </p>
+   * called, and same for onStart and onDestroy.
    *
-   * <p> Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once
+   * <p>Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once
    * will have their lifecycle methods called more than once. It is the caller's responsibility to
-   * avoid adding listeners multiple times. </p>
+   * avoid adding listeners multiple times.
    */
   @Override
-  public void addListener(LifecycleListener listener) {
+  public void addListener(@NonNull LifecycleListener listener) {
     lifecycleListeners.add(listener);
 
     if (isDestroyed) {
@@ -40,7 +41,7 @@ public void addListener(LifecycleListener listener) {
   }
 
   @Override
-  public void removeListener(LifecycleListener listener) {
+  public void removeListener(@NonNull LifecycleListener listener) {
     lifecycleListeners.remove(listener);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
index 5911d5234..89870f853 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
@@ -1,20 +1,22 @@
 package com.bumptech.glide.manager;
 
+import androidx.annotation.NonNull;
+
 /**
  * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying
  * listeners of {@link android.app.Application} lifecycle events.
  *
- * <p> Since there are essentially no {@link android.app.Application} lifecycle events, this class
- * simply defaults to notifying new listeners that they are started. </p>
+ * <p>Since there are essentially no {@link android.app.Application} lifecycle events, this class
+ * simply defaults to notifying new listeners that they are started.
  */
 class ApplicationLifecycle implements Lifecycle {
   @Override
-  public void addListener(LifecycleListener listener) {
+  public void addListener(@NonNull LifecycleListener listener) {
     listener.onStart();
   }
 
   @Override
-  public void removeListener(LifecycleListener listener) {
+  public void removeListener(@NonNull LifecycleListener listener) {
     // Do nothing.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
index dc216c871..22153d246 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
@@ -1,13 +1,9 @@
 package com.bumptech.glide.manager;
 
-/**
- * An interface for monitoring network connectivity events.
- */
+/** An interface for monitoring network connectivity events. */
 public interface ConnectivityMonitor extends LifecycleListener {
 
-  /**
-   * An interface for listening to network connectivity events picked up by the monitor.
-   */
+  /** An interface for listening to network connectivity events picked up by the monitor. */
   interface ConnectivityListener {
     /**
      * Called when the connectivity state changes.
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
index b226cd425..50620b09e 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
@@ -1,16 +1,15 @@
 package com.bumptech.glide.manager;
 
 import android.content.Context;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 
 /**
- * A factory class that produces a functional
- * {@link com.bumptech.glide.manager.ConnectivityMonitor}.
+ * A factory class that produces a functional {@link
+ * com.bumptech.glide.manager.ConnectivityMonitor}.
  */
 public interface ConnectivityMonitorFactory {
 
   @NonNull
   ConnectivityMonitor build(
-      @NonNull Context context,
-      @NonNull ConnectivityMonitor.ConnectivityListener listener);
+      @NonNull Context context, @NonNull ConnectivityMonitor.ConnectivityListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index 4573dbb86..e28201bd0 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -7,30 +7,43 @@
 import android.content.IntentFilter;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.util.Log;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 
-/**
- * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
- */
-class DefaultConnectivityMonitor implements ConnectivityMonitor {
+/** Uses {@link android.net.ConnectivityManager} to identify connectivity changes. */
+final class DefaultConnectivityMonitor implements ConnectivityMonitor {
+  private static final String TAG = "ConnectivityMonitor";
   private final Context context;
-  @Synthetic final ConnectivityListener listener;
 
-  @Synthetic boolean isConnected;
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final ConnectivityListener listener;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  boolean isConnected;
+
   private boolean isRegistered;
 
-  private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
-    @Override
-    public void onReceive(Context context, Intent intent) {
-      boolean wasConnected = isConnected;
-      isConnected = isConnected(context);
-      if (wasConnected != isConnected) {
-        listener.onConnectivityChanged(isConnected);
-      }
-    }
-  };
+  private final BroadcastReceiver connectivityReceiver =
+      new BroadcastReceiver() {
+        @Override
+        public void onReceive(@NonNull Context context, Intent intent) {
+          boolean wasConnected = isConnected;
+          isConnected = isConnected(context);
+          if (wasConnected != isConnected) {
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+              Log.d(TAG, "connectivity changed, isConnected: " + isConnected);
+            }
 
-  public DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {
+            listener.onConnectivityChanged(isConnected);
+          }
+        }
+      };
+
+  DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) {
     this.context = context.getApplicationContext();
     this.listener = listener;
   }
@@ -40,10 +53,19 @@ private void register() {
       return;
     }
 
+    // Initialize isConnected.
     isConnected = isConnected(context);
-    context.registerReceiver(connectivityReceiver,
-        new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
-    isRegistered = true;
+    try {
+      // See #1405
+      context.registerReceiver(
+          connectivityReceiver, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+      isRegistered = true;
+    } catch (SecurityException e) {
+      // See #1417, registering the receiver can throw SecurityException.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to register", e);
+      }
+    }
   }
 
   private void unregister() {
@@ -55,13 +77,27 @@ private void unregister() {
     isRegistered = false;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   // Permissions are checked in the factory instead.
   @SuppressLint("MissingPermission")
-  boolean isConnected(Context context) {
+  boolean isConnected(@NonNull Context context) {
     ConnectivityManager connectivityManager =
-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+        Preconditions.checkNotNull(
+            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));
+    NetworkInfo networkInfo;
+    try {
+      networkInfo = connectivityManager.getActiveNetworkInfo();
+    } catch (RuntimeException e) {
+      // #1405 shows that this throws a SecurityException.
+      // b/70869360 shows that this throws NullPointerException on APIs 22, 23, and 24.
+      // b/70869360 also shows that this throws RuntimeException on API 24 and 25.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to determine connectivity status when connectivity changed", e);
+      }
+      // Default to true;
+      return true;
+    }
     return networkInfo != null && networkInfo.isConnected();
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
index 2d6702e53..c426ce18b 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -2,8 +2,9 @@
 
 import android.content.Context;
 import android.content.pm.PackageManager;
-import android.support.annotation.NonNull;
-import android.support.v4.content.ContextCompat;
+import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.core.content.ContextCompat;
 
 /**
  * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
@@ -12,15 +13,24 @@
  * the required permission.
  */
 public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory {
+  private static final String TAG = "ConnectivityMonitor";
   private static final String NETWORK_PERMISSION = "android.permission.ACCESS_NETWORK_STATE";
 
   @NonNull
+  @Override
   public ConnectivityMonitor build(
-      @NonNull Context context,
-      @NonNull ConnectivityMonitor.ConnectivityListener listener) {
+      @NonNull Context context, @NonNull ConnectivityMonitor.ConnectivityListener listener) {
     int permissionResult = ContextCompat.checkSelfPermission(context, NETWORK_PERMISSION);
     boolean hasPermission = permissionResult == PackageManager.PERMISSION_GRANTED;
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(
+          TAG,
+          hasPermission
+              ? "ACCESS_NETWORK_STATE permission granted, registering connectivity monitor"
+              : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");
+    }
     return hasPermission
-        ? new DefaultConnectivityMonitor(context, listener) : new NullConnectivityMonitor();
+        ? new DefaultConnectivityMonitor(context, listener)
+        : new NullConnectivityMonitor();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
index 5d811cc49..f40e5516a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -1,15 +1,15 @@
 package com.bumptech.glide.manager;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.RequestManager;
 import java.util.Collections;
 import java.util.Set;
 
-/**
- * A {@link RequestManagerTreeNode} that returns no relatives.
- */
+/** A {@link RequestManagerTreeNode} that returns no relatives. */
 final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
-    @Override
-    public Set<RequestManager> getDescendants() {
-        return Collections.emptySet();
-    }
+  @NonNull
+  @Override
+  public Set<RequestManager> getDescendants() {
+    return Collections.emptySet();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
index 53044cee1..37581d641 100644
--- a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.manager;
 
-/**
- * An interface for listening to Activity/Fragment lifecycle events.
- */
+import androidx.annotation.NonNull;
+
+/** An interface for listening to Activity/Fragment lifecycle events. */
 public interface Lifecycle {
-  /**
-   * Adds the given listener to the set of listeners managed by this Lifecycle implementation.
-   */
-  void addListener(LifecycleListener listener);
+  /** Adds the given listener to the set of listeners managed by this Lifecycle implementation. */
+  void addListener(@NonNull LifecycleListener listener);
 
   /**
    * Removes the given listener from the set of listeners managed by this Lifecycle implementation,
@@ -16,5 +14,5 @@
    * <p>This is an optimization only, there is no guarantee that every added listener will
    * eventually be removed.
    */
-  void removeListener(LifecycleListener listener);
+  void removeListener(@NonNull LifecycleListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
index b182cb0ab..ba7d0a9e6 100644
--- a/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.manager;
 
-/**
- * A no-op {@link com.bumptech.glide.manager.ConnectivityMonitor}.
- */
+/** A no-op {@link com.bumptech.glide.manager.ConnectivityMonitor}. */
 class NullConnectivityMonitor implements ConnectivityMonitor {
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 44dfb5979..b3d26fa18 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -5,8 +5,10 @@
 import android.app.Activity;
 import android.app.Fragment;
 import android.os.Build;
-import android.support.annotation.Nullable;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Synthetic;
@@ -23,25 +25,32 @@
  * @see com.bumptech.glide.manager.RequestManagerRetriever
  * @see com.bumptech.glide.RequestManager
  */
+@SuppressWarnings("DeprecatedIsStillUsed")
+@Deprecated
 public class RequestManagerFragment extends Fragment {
   private static final String TAG = "RMFragment";
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new FragmentRequestManagerTreeNode();
-  private final HashSet<RequestManagerFragment> childRequestManagerFragments =
-      new HashSet<>();
+
+  @SuppressWarnings("deprecation")
+  private final Set<RequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private RequestManager requestManager;
-  @Nullable private RequestManagerFragment rootRequestManagerFragment;
+
+  @SuppressWarnings("deprecation")
+  @Nullable
+  private RequestManagerFragment rootRequestManagerFragment;
+
   @Nullable private Fragment parentFragmentHint;
 
   public RequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
   }
 
-  // For testing only.
+  @VisibleForTesting
   @SuppressLint("ValidFragment")
-  RequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+  RequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
     this.lifecycle = lifecycle;
   }
 
@@ -50,33 +59,33 @@ public RequestManagerFragment() {
    *
    * @param requestManager The request manager to use.
    */
-  public void setRequestManager(RequestManager requestManager) {
+  public void setRequestManager(@Nullable RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
+  @NonNull
   ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
 
-  /**
-   * Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists.
-   */
+  /** Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists. */
   @Nullable
   public RequestManager getRequestManager() {
     return requestManager;
   }
 
-  /**
-   * Returns the {@link RequestManagerTreeNode} for this fragment.
-   */
+  /** Returns the {@link RequestManagerTreeNode} for this fragment. */
+  @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
   }
 
+  @SuppressWarnings("deprecation")
   private void addChildRequestManagerFragment(RequestManagerFragment child) {
     childRequestManagerFragments.add(child);
   }
 
+  @SuppressWarnings("deprecation")
   private void removeChildRequestManagerFragment(RequestManagerFragment child) {
     childRequestManagerFragments.remove(child);
   }
@@ -85,9 +94,12 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
    * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
    * our parent is the fragment that we are annotating).
    */
+  @SuppressWarnings("deprecation")
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
-    if (rootRequestManagerFragment == this) {
+  @Synthetic
+  @NonNull
+  Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
+    if (equals(rootRequestManagerFragment)) {
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else if (rootRequestManagerFragment == null
         || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
@@ -95,9 +107,9 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
       // so just return an empty set.
       return Collections.emptySet();
     } else {
-      HashSet<RequestManagerFragment> descendants = new HashSet<>();
-      for (RequestManagerFragment fragment : rootRequestManagerFragment
-          .getDescendantRequestManagerFragments()) {
+      Set<RequestManagerFragment> descendants = new HashSet<>();
+      for (RequestManagerFragment fragment :
+          rootRequestManagerFragment.getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragment())) {
           descendants.add(fragment);
         }
@@ -110,13 +122,14 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
    * Sets a hint for which fragment is our parent which allows the fragment to return correct
    * information about its parents before pending fragment transactions have been executed.
    */
-  void setParentFragmentHint(Fragment parentFragmentHint) {
+  void setParentFragmentHint(@Nullable Fragment parentFragmentHint) {
     this.parentFragmentHint = parentFragmentHint;
     if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
       registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
   }
 
+  @Nullable
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   private Fragment getParentFragmentUsingHint() {
     final Fragment fragment;
@@ -128,14 +141,13 @@ private Fragment getParentFragmentUsingHint() {
     return fragment != null ? fragment : parentFragmentHint;
   }
 
-  /**
-   * Returns true if the fragment is a descendant of our parent.
-   */
+  /** Returns true if the fragment is a descendant of our parent. */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private boolean isDescendant(Fragment fragment) {
-    Fragment root = this.getParentFragment();
-    while (fragment.getParentFragment() != null) {
-      if (fragment.getParentFragment() == root) {
+  private boolean isDescendant(@NonNull Fragment fragment) {
+    Fragment root = getParentFragment();
+    Fragment parentFragment;
+    while ((parentFragment = fragment.getParentFragment()) != null) {
+      if (parentFragment.equals(root)) {
         return true;
       }
       fragment = fragment.getParentFragment();
@@ -143,11 +155,12 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
-  private void registerFragmentWithRoot(Activity activity) {
+  @SuppressWarnings("deprecation")
+  private void registerFragmentWithRoot(@NonNull Activity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
-        .getRequestManagerFragment(activity.getFragmentManager(), null);
-    if (rootRequestManagerFragment != this) {
+    rootRequestManagerFragment =
+        Glide.get(activity).getRequestManagerRetriever().getRequestManagerFragment(activity);
+    if (!equals(rootRequestManagerFragment)) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
   }
@@ -206,12 +219,14 @@ public String toString() {
   private class FragmentRequestManagerTreeNode implements RequestManagerTreeNode {
 
     @Synthetic
-    FragmentRequestManagerTreeNode() { }
+    FragmentRequestManagerTreeNode() {}
 
+    @SuppressWarnings("deprecation")
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
       Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
-      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      Set<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (RequestManagerFragment fragment : descendantFragments) {
         if (fragment.getRequestManager() != null) {
           descendants.add(fragment.getRequestManager());
@@ -220,6 +235,7 @@ public String toString() {
       return descendants;
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public String toString() {
       return super.toString() + "{fragment=" + RequestManagerFragment.this + "}";
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index fedf092a4..bdf863fca 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -12,13 +12,15 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-import android.support.annotation.Nullable;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.support.v4.util.ArrayMap;
 import android.util.Log;
 import android.view.View;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.collection.ArrayMap;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
+import androidx.fragment.app.FragmentManager;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Preconditions;
@@ -32,8 +34,7 @@
  * retrieving existing ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-  // Visible for testing.
-  static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
+  @VisibleForTesting static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
   private static final String TAG = "RMRetriever";
 
   private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
@@ -43,29 +44,23 @@
   // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
   private static final String FRAGMENT_INDEX_KEY = "key";
 
-  /**
-   * The top application level RequestManager.
-   */
+  /** The top application level RequestManager. */
   private volatile RequestManager applicationManager;
 
-  // Visible for testing.
-  /**
-   * Pending adds for RequestManagerFragments.
-   */
+  /** Pending adds for RequestManagerFragments. */
+  @SuppressWarnings("deprecation")
+  @VisibleForTesting
   final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
       new HashMap<>();
 
-  // Visible for testing.
-  /**
-   * Pending adds for SupportRequestManagerFragments.
-   */
+  /** Pending adds for SupportRequestManagerFragments. */
+  @VisibleForTesting
   final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
       new HashMap<>();
 
-  /**
-   * Main thread handler to handle cleaning up pending fragment maps.
-   */
+  /** Main thread handler to handle cleaning up pending fragment maps. */
   private final Handler handler;
+
   private final RequestManagerFactory factory;
 
   // Objects used to find Fragments and Activities containing views.
@@ -73,13 +68,13 @@
   private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
   private final Bundle tempBundle = new Bundle();
 
-  // Visible for testing.
   public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
     this.factory = factory != null ? factory : DEFAULT_FACTORY;
     handler = new Handler(Looper.getMainLooper(), this /* Callback */);
   }
 
-  private RequestManager getApplicationManager(Context context) {
+  @NonNull
+  private RequestManager getApplicationManager(@NonNull Context context) {
     // Either an application context or we're on a background thread.
     if (applicationManager == null) {
       synchronized (this) {
@@ -104,7 +99,8 @@ private RequestManager getApplicationManager(Context context) {
     return applicationManager;
   }
 
-  public RequestManager get(Context context) {
+  @NonNull
+  public RequestManager get(@NonNull Context context) {
     if (context == null) {
       throw new IllegalArgumentException("You cannot start a load on a null Context");
     } else if (Util.isOnMainThread() && !(context instanceof Application)) {
@@ -112,7 +108,11 @@ public RequestManager get(Context context) {
         return get((FragmentActivity) context);
       } else if (context instanceof Activity) {
         return get((Activity) context);
-      } else if (context instanceof ContextWrapper) {
+      } else if (context instanceof ContextWrapper
+          // Only unwrap a ContextWrapper if the baseContext has a non-null application context.
+          // Context#createPackageContext may return a Context without an Application instance,
+          // in which case a ContextWrapper may be used to attach one.
+          && ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {
         return get(((ContextWrapper) context).getBaseContext());
       }
     }
@@ -120,45 +120,52 @@ public RequestManager get(Context context) {
     return getApplicationManager(context);
   }
 
-  public RequestManager get(FragmentActivity activity) {
+  @NonNull
+  public RequestManager get(@NonNull FragmentActivity activity) {
     if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(activity, fm, null /*parentHint*/);
+      return supportFragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
     }
   }
 
-  public RequestManager get(Fragment fragment) {
-    Preconditions.checkNotNull(fragment.getActivity(),
-          "You cannot start a load on a fragment before it is attached or after it is destroyed");
+  @NonNull
+  public RequestManager get(@NonNull Fragment fragment) {
+    Preconditions.checkNotNull(
+        fragment.getContext(),
+        "You cannot start a load on a fragment before it is attached or after it is destroyed");
     if (Util.isOnBackgroundThread()) {
-      return get(fragment.getActivity().getApplicationContext());
+      return get(fragment.getContext().getApplicationContext());
     } else {
       FragmentManager fm = fragment.getChildFragmentManager();
-      return supportFragmentGet(fragment.getActivity(), fm, fragment);
+      return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());
     }
   }
 
-  public RequestManager get(Activity activity) {
+  @SuppressWarnings("deprecation")
+  @NonNull
+  public RequestManager get(@NonNull Activity activity) {
     if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(activity, fm, null /*parentHint*/);
+      return fragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
     }
   }
 
-  public RequestManager get(View view) {
+  @SuppressWarnings("deprecation")
+  @NonNull
+  public RequestManager get(@NonNull View view) {
     if (Util.isOnBackgroundThread()) {
       return get(view.getContext().getApplicationContext());
     }
 
     Preconditions.checkNotNull(view);
-    Preconditions.checkNotNull(view.getContext(),
-        "Unable to obtain a request manager for a view without a Context");
+    Preconditions.checkNotNull(
+        view.getContext(), "Unable to obtain a request manager for a view without a Context");
     Activity activity = findActivity(view.getContext());
     // The view might be somewhere else, like a service.
     if (activity == null) {
@@ -183,8 +190,7 @@ public RequestManager get(View view) {
   }
 
   private static void findAllSupportFragmentsWithViews(
-      @Nullable Collection<Fragment> topLevelFragments,
-      Map<View, Fragment> result) {
+      @Nullable Collection<Fragment> topLevelFragments, @NonNull Map<View, Fragment> result) {
     if (topLevelFragments == null) {
       return;
     }
@@ -199,7 +205,7 @@ private static void findAllSupportFragmentsWithViews(
   }
 
   @Nullable
-  private Fragment findSupportFragment(View target, FragmentActivity activity) {
+  private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
     tempViewToSupportFragment.clear();
     findAllSupportFragmentsWithViews(
         activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
@@ -222,8 +228,10 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
     return result;
   }
 
+  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+  @Deprecated
   @Nullable
-  private android.app.Fragment findFragment(View target, Activity activity) {
+  private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {
     tempViewToFragment.clear();
     findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
 
@@ -231,7 +239,7 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
 
     View activityRoot = activity.findViewById(android.R.id.content);
     View current = target;
-     while (!current.equals(activityRoot)) {
+    while (!current.equals(activityRoot)) {
       result = tempViewToFragment.get(current);
       if (result != null) {
         break;
@@ -248,9 +256,12 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
 
   // TODO: Consider using an accessor class in the support library package to more directly retrieve
   // non-support Fragments.
+  @SuppressWarnings("deprecation")
+  @Deprecated
   @TargetApi(Build.VERSION_CODES.O)
   private void findAllFragmentsWithViews(
-      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+      @NonNull android.app.FragmentManager fragmentManager,
+      @NonNull ArrayMap<View, android.app.Fragment> result) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
       for (android.app.Fragment fragment : fragmentManager.getFragments()) {
         if (fragment.getView() != null) {
@@ -263,8 +274,11 @@ private void findAllFragmentsWithViews(
     }
   }
 
+  @SuppressWarnings("deprecation")
+  @Deprecated
   private void findAllFragmentsWithViewsPreO(
-      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+      @NonNull android.app.FragmentManager fragmentManager,
+      @NonNull ArrayMap<View, android.app.Fragment> result) {
     int index = 0;
     while (true) {
       tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
@@ -286,7 +300,8 @@ private void findAllFragmentsWithViewsPreO(
     }
   }
 
-  private Activity findActivity(Context context) {
+  @Nullable
+  private static Activity findActivity(@NonNull Context context) {
     if (context instanceof Activity) {
       return (Activity) context;
     } else if (context instanceof ContextWrapper) {
@@ -297,14 +312,17 @@ private Activity findActivity(Context context) {
   }
 
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private static void assertNotDestroyed(Activity activity) {
+  private static void assertNotDestroyed(@NonNull Activity activity) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
       throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
     }
   }
 
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public RequestManager get(android.app.Fragment fragment) {
+  public RequestManager get(@NonNull android.app.Fragment fragment) {
     if (fragment.getActivity() == null) {
       throw new IllegalArgumentException(
           "You cannot start a load on a fragment before it is attached");
@@ -313,19 +331,33 @@ public RequestManager get(android.app.Fragment fragment) {
       return get(fragment.getActivity().getApplicationContext());
     } else {
       android.app.FragmentManager fm = fragment.getChildFragmentManager();
-      return fragmentGet(fragment.getActivity(), fm, fragment);
+      return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  RequestManagerFragment getRequestManagerFragment(
-      final android.app.FragmentManager fm, android.app.Fragment parentHint) {
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
+  RequestManagerFragment getRequestManagerFragment(Activity activity) {
+    return getRequestManagerFragment(
+        activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
+  }
+
+  @SuppressWarnings("deprecation")
+  @NonNull
+  private RequestManagerFragment getRequestManagerFragment(
+      @NonNull final android.app.FragmentManager fm,
+      @Nullable android.app.Fragment parentHint,
+      boolean isParentVisible) {
     RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
       current = pendingRequestManagerFragments.get(fm);
       if (current == null) {
         current = new RequestManagerFragment();
         current.setParentFragmentHint(parentHint);
+        if (isParentVisible) {
+          current.getGlideLifecycle().onStart();
+        }
         pendingRequestManagerFragments.put(fm, current);
         fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
         handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
@@ -334,9 +366,15 @@ RequestManagerFragment getRequestManagerFragment(
     return current;
   }
 
-  private RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
-      android.app.Fragment parentHint) {
-    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
+  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+  @Deprecated
+  @NonNull
+  private RequestManager fragmentGet(
+      @NonNull Context context,
+      @NonNull android.app.FragmentManager fm,
+      @Nullable android.app.Fragment parentHint,
+      boolean isParentVisible) {
+    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
       // TODO(b/27524013): Factor out this Glide.get() call.
@@ -349,8 +387,23 @@ private RequestManager fragmentGet(Context context, android.app.FragmentManager
     return requestManager;
   }
 
+  @NonNull
   SupportRequestManagerFragment getSupportRequestManagerFragment(
-      final FragmentManager fm, Fragment parentHint) {
+      Context context, FragmentManager fragmentManager) {
+    return getSupportRequestManagerFragment(
+        fragmentManager, /*parentHint=*/ null, isActivityVisible(context));
+  }
+
+  private static boolean isActivityVisible(Context context) {
+    // This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible
+    // and start requests than on the side of invisible and ignore valid requests.
+    Activity activity = findActivity(context);
+    return activity == null || !activity.isFinishing();
+  }
+
+  @NonNull
+  private SupportRequestManagerFragment getSupportRequestManagerFragment(
+      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {
     SupportRequestManagerFragment current =
         (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
@@ -358,6 +411,9 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
       if (current == null) {
         current = new SupportRequestManagerFragment();
         current.setParentFragmentHint(parentHint);
+        if (isParentVisible) {
+          current.getGlideLifecycle().onStart();
+        }
         pendingSupportRequestManagerFragments.put(fm, current);
         fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
         handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
@@ -366,9 +422,14 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
     return current;
   }
 
-  private RequestManager supportFragmentGet(Context context, FragmentManager fm,
-      Fragment parentHint) {
-    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
+  @NonNull
+  private RequestManager supportFragmentGet(
+      @NonNull Context context,
+      @NonNull FragmentManager fm,
+      @Nullable Fragment parentHint,
+      boolean isParentVisible) {
+    SupportRequestManagerFragment current =
+        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
       // TODO(b/27524013): Factor out this Glide.get() call.
@@ -407,22 +468,26 @@ public boolean handleMessage(Message message) {
     return handled;
   }
 
-  /**
-   * Used internally to create {@link RequestManager}s.
-   */
+  /** Used internally to create {@link RequestManager}s. */
   public interface RequestManagerFactory {
+    @NonNull
     RequestManager build(
-        Glide glide,
-        Lifecycle lifecycle,
-        RequestManagerTreeNode requestManagerTreeNode,
-        Context context);
+        @NonNull Glide glide,
+        @NonNull Lifecycle lifecycle,
+        @NonNull RequestManagerTreeNode requestManagerTreeNode,
+        @NonNull Context context);
   }
 
-  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
-    @Override
-    public RequestManager build(Glide glide, Lifecycle lifecycle,
-        RequestManagerTreeNode requestManagerTreeNode, Context context) {
-      return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
-    }
-  };
+  private static final RequestManagerFactory DEFAULT_FACTORY =
+      new RequestManagerFactory() {
+        @NonNull
+        @Override
+        public RequestManager build(
+            @NonNull Glide glide,
+            @NonNull Lifecycle lifecycle,
+            @NonNull RequestManagerTreeNode requestManagerTreeNode,
+            @NonNull Context context) {
+          return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
+        }
+      };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
index 38d341b3a..601906a19 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.RequestManager;
 import java.util.Set;
 
@@ -10,8 +11,9 @@
  */
 public interface RequestManagerTreeNode {
   /**
-   * Returns all descendant {@link RequestManager}s relative to the context of the current
-   * {@link RequestManager}.
+   * Returns all descendant {@link RequestManager}s relative to the context of the current {@link
+   * RequestManager}.
    */
+  @NonNull
   Set<RequestManager> getDescendants();
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index f735e3618..ff39b7583 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -1,5 +1,9 @@
 package com.bumptech.glide.manager;
 
+import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Util;
 import java.util.ArrayList;
@@ -14,6 +18,7 @@
  * <p>This class is not thread safe and must be accessed on the main thread.
  */
 public class RequestTracker {
+  private static final String TAG = "RequestTracker";
   // Most requests will be for views and will therefore be held strongly (and safely) by the view
   // via the tag. However, a user can always pass in a different type of target which may end up not
   // being strongly referenced even though the user still would like the request to finish. Weak
@@ -28,70 +33,91 @@
   // before they start running or while they are paused. See #346.
   @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
   private final List<Request> pendingRequests = new ArrayList<>();
+
   private boolean isPaused;
 
-  /**
-   * Starts tracking the given request.
-   */
-  public void runRequest(Request request) {
+  /** Starts tracking the given request. */
+  public void runRequest(@NonNull Request request) {
     requests.add(request);
     if (!isPaused) {
       request.begin();
     } else {
+      request.clear();
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Paused, delaying request");
+      }
       pendingRequests.add(request);
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   void addRequest(Request request) {
     requests.add(request);
   }
 
   /**
    * Stops tracking the given request, clears, and recycles it, and returns {@code true} if the
-   * request was removed or {@code false} if the request was not found.
+   * request was removed or invalid or {@code false} if the request was not found.
    */
-  public boolean clearRemoveAndRecycle(Request request) {
+  public boolean clearRemoveAndRecycle(@Nullable Request request) {
+    // It's safe for us to recycle because this is only called when the user is explicitly clearing
+    // a Target so we know that there are no remaining references to the Request.
+    return clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ true);
+  }
+
+  private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean isSafeToRecycle) {
     if (request == null) {
-      return false;
+      // If the Request is null, the request is already cleared and we don't need to search further
+      // for its owner.
+      return true;
     }
     boolean isOwnedByUs = requests.remove(request);
     // Avoid short circuiting.
     isOwnedByUs = pendingRequests.remove(request) || isOwnedByUs;
     if (isOwnedByUs) {
       request.clear();
-      request.recycle();
+      if (isSafeToRecycle) {
+        request.recycle();
+      }
     }
     return isOwnedByUs;
   }
 
-  /**
-   * Returns {@code true} if requests are currently paused, and {@code false} otherwise.
-   */
+  /** Returns {@code true} if requests are currently paused, and {@code false} otherwise. */
   public boolean isPaused() {
     return isPaused;
   }
 
-  /**
-   * Stops any in progress requests.
-   */
+  /** Stops any in progress requests. */
   public void pauseRequests() {
     isPaused = true;
     for (Request request : Util.getSnapshot(requests)) {
       if (request.isRunning()) {
-        request.pause();
+        request.clear();
         pendingRequests.add(request);
       }
     }
   }
 
-  /**
-   * Starts any not yet completed or failed requests.
-   */
+  /** Stops any in progress requests and releases bitmaps associated with completed requests. */
+  public void pauseAllRequests() {
+    isPaused = true;
+    for (Request request : Util.getSnapshot(requests)) {
+      if (request.isRunning() || request.isComplete()) {
+        request.clear();
+        pendingRequests.add(request);
+      }
+    }
+  }
+
+  /** Starts any not yet completed or failed requests. */
   public void resumeRequests() {
     isPaused = false;
     for (Request request : Util.getSnapshot(requests)) {
-      if (!request.isComplete() && !request.isCancelled() && !request.isRunning()) {
+      // We don't need to check for cleared here. Any explicit clear by a user will remove the
+      // Request from the tracker, so the only way we'd find a cleared request here is if we cleared
+      // it. As a result it should be safe for us to resume cleared requests.
+      if (!request.isComplete() && !request.isRunning()) {
         request.begin();
       }
     }
@@ -105,22 +131,22 @@ public void resumeRequests() {
    */
   public void clearRequests() {
     for (Request request : Util.getSnapshot(requests)) {
-      clearRemoveAndRecycle(request);
+      // It's unsafe to recycle the Request here because we don't know who might else have a
+      // reference to it.
+      clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ false);
     }
     pendingRequests.clear();
   }
 
-  /**
-   * Restarts failed requests and cancels and restarts in progress requests.
-   */
+  /** Restarts failed requests and cancels and restarts in progress requests. */
   public void restartRequests() {
     for (Request request : Util.getSnapshot(requests)) {
-      if (!request.isComplete() && !request.isCancelled()) {
-        // Ensure the request will be restarted in onResume.
-        request.pause();
+      if (!request.isComplete() && !request.isCleared()) {
+        request.clear();
         if (!isPaused) {
           request.begin();
         } else {
+          // Ensure the request will be restarted in onResume.
           pendingRequests.add(request);
         }
       }
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index 8bf7c0ec0..f702355b3 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -2,10 +2,12 @@
 
 import android.annotation.SuppressLint;
 import android.content.Context;
-import android.support.annotation.Nullable;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Synthetic;
@@ -14,7 +16,7 @@
 import java.util.Set;
 
 /**
- * A view-less {@link android.support.v4.app.Fragment} used to safely store an {@link
+ * A view-less {@link androidx.fragment.app.Fragment} used to safely store an {@link
  * com.bumptech.glide.RequestManager} that can be used to start, stop and manage Glide requests
  * started for targets within the fragment or activity this fragment is a child of.
  *
@@ -27,8 +29,7 @@
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new SupportFragmentRequestManagerTreeNode();
-  private final HashSet<SupportRequestManagerFragment> childRequestManagerFragments =
-      new HashSet<>();
+  private final Set<SupportRequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private SupportRequestManagerFragment rootRequestManagerFragment;
   @Nullable private RequestManager requestManager;
@@ -38,9 +39,9 @@ public SupportRequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
   }
 
-  // For testing only.
+  @VisibleForTesting
   @SuppressLint("ValidFragment")
-  public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+  public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
     this.lifecycle = lifecycle;
   }
 
@@ -49,27 +50,26 @@ public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
    *
    * @param requestManager The manager to put.
    */
-  public void setRequestManager(RequestManager requestManager) {
+  public void setRequestManager(@Nullable RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
+  @NonNull
   ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
 
-  /**
-   * Returns the current {@link com.bumptech.glide.RequestManager} or null if none is put.
-   */
+  /** Returns the current {@link com.bumptech.glide.RequestManager} or null if none is put. */
   @Nullable
   public RequestManager getRequestManager() {
     return requestManager;
   }
 
   /**
-   * Returns the {@link RequestManagerTreeNode} that provides tree traversal methods relative
-   * to the
+   * Returns the {@link RequestManagerTreeNode} that provides tree traversal methods relative to the
    * associated {@link RequestManager}.
    */
+  @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
   }
@@ -86,15 +86,17 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
    * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
    * our parent is the fragment that we are annotating).
    */
-  public Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
+  @Synthetic
+  @NonNull
+  Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
     if (rootRequestManagerFragment == null) {
       return Collections.emptySet();
-    } else if (rootRequestManagerFragment == this) {
+    } else if (equals(rootRequestManagerFragment)) {
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else {
-      HashSet<SupportRequestManagerFragment> descendants = new HashSet<>();
-      for (SupportRequestManagerFragment fragment : rootRequestManagerFragment
-          .getDescendantRequestManagerFragments()) {
+      Set<SupportRequestManagerFragment> descendants = new HashSet<>();
+      for (SupportRequestManagerFragment fragment :
+          rootRequestManagerFragment.getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragmentUsingHint())) {
           descendants.add(fragment);
         }
@@ -107,25 +109,38 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
    * Sets a hint for which fragment is our parent which allows the fragment to return correct
    * information about its parents before pending fragment transactions have been executed.
    */
-  void setParentFragmentHint(Fragment parentFragmentHint) {
+  void setParentFragmentHint(@Nullable Fragment parentFragmentHint) {
     this.parentFragmentHint = parentFragmentHint;
-    if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
-      registerFragmentWithRoot(parentFragmentHint.getActivity());
+    if (parentFragmentHint == null || parentFragmentHint.getContext() == null) {
+      return;
+    }
+    FragmentManager rootFragmentManager = getRootFragmentManager(parentFragmentHint);
+    if (rootFragmentManager == null) {
+      return;
+    }
+    registerFragmentWithRoot(parentFragmentHint.getContext(), rootFragmentManager);
+  }
+
+  @Nullable
+  private static FragmentManager getRootFragmentManager(@NonNull Fragment fragment) {
+    while (fragment.getParentFragment() != null) {
+      fragment = fragment.getParentFragment();
     }
+    return fragment.getFragmentManager();
   }
 
+  @Nullable
   private Fragment getParentFragmentUsingHint() {
     Fragment fragment = getParentFragment();
     return fragment != null ? fragment : parentFragmentHint;
   }
 
-  /**
-   * Returns true if the fragment is a descendant of our parent.
-   */
-  private boolean isDescendant(Fragment fragment) {
-    Fragment root = this.getParentFragmentUsingHint();
-    while (fragment.getParentFragment() != null) {
-      if (fragment.getParentFragment() == root) {
+  /** Returns true if the fragment is a descendant of our parent. */
+  private boolean isDescendant(@NonNull Fragment fragment) {
+    Fragment root = getParentFragmentUsingHint();
+    Fragment parentFragment;
+    while ((parentFragment = fragment.getParentFragment()) != null) {
+      if (parentFragment.equals(root)) {
         return true;
       }
       fragment = fragment.getParentFragment();
@@ -133,11 +148,14 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
-  private void registerFragmentWithRoot(FragmentActivity activity) {
+  private void registerFragmentWithRoot(
+      @NonNull Context context, @NonNull FragmentManager fragmentManager) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
-        .getSupportRequestManagerFragment(activity.getSupportFragmentManager(), null);
-    if (rootRequestManagerFragment != this) {
+    rootRequestManagerFragment =
+        Glide.get(context)
+            .getRequestManagerRetriever()
+            .getSupportRequestManagerFragment(context, fragmentManager);
+    if (!equals(rootRequestManagerFragment)) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
   }
@@ -152,8 +170,18 @@ private void unregisterFragmentWithRoot() {
   @Override
   public void onAttach(Context context) {
     super.onAttach(context);
+
+    FragmentManager rootFragmentManager = getRootFragmentManager(this);
+    if (rootFragmentManager == null) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        // Not expected to occur; ancestor fragments should be attached before descendants.
+        Log.w(TAG, "Unable to register fragment with root, ancestor detached");
+      }
+      return;
+    }
+
     try {
-      registerFragmentWithRoot(getActivity());
+      registerFragmentWithRoot(getContext(), rootFragmentManager);
     } catch (IllegalStateException e) {
       // OnAttach can be called after the activity is destroyed, see #497.
       if (Log.isLoggable(TAG, Log.WARN)) {
@@ -196,13 +224,14 @@ public String toString() {
   private class SupportFragmentRequestManagerTreeNode implements RequestManagerTreeNode {
 
     @Synthetic
-    SupportFragmentRequestManagerTreeNode() { }
+    SupportFragmentRequestManagerTreeNode() {}
 
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
       Set<SupportRequestManagerFragment> descendantFragments =
           getDescendantRequestManagerFragments();
-      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      Set<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (SupportRequestManagerFragment fragment : descendantFragments) {
         if (fragment.getRequestManager() != null) {
           descendants.add(fragment.getRequestManager());
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 64dd276db..3802dd720 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -1,26 +1,26 @@
 package com.bumptech.glide.manager;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 import java.util.WeakHashMap;
 
 /**
- * Holds the set of {@link Target}s currently active for a
- * {@link com.bumptech.glide.RequestManager} and forwards on lifecycle events.
+ * Holds the set of {@link Target}s currently active for a {@link com.bumptech.glide.RequestManager}
+ * and forwards on lifecycle events.
  */
 public final class TargetTracker implements LifecycleListener {
   private final Set<Target<?>> targets =
       Collections.newSetFromMap(new WeakHashMap<Target<?>, Boolean>());
 
-  public void track(Target<?> target) {
+  public void track(@NonNull Target<?> target) {
     targets.add(target);
   }
 
-  public void untrack(Target<?> target) {
+  public void untrack(@NonNull Target<?> target) {
     targets.remove(target);
   }
 
@@ -45,8 +45,9 @@ public void onDestroy() {
     }
   }
 
+  @NonNull
   public List<Target<?>> getAll() {
-    return new ArrayList<>(targets);
+    return Util.getSnapshot(targets);
   }
 
   public void clear() {
diff --git a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
index 9d40b969c..b1e28f583 100644
--- a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
@@ -1,25 +1,28 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.GlideBuilder;
 
 /**
  * Defines a set of dependencies and options to use when initializing Glide within an application.
  *
- * <p>There can be at most one {@link AppGlideModule} in an application. Only Applications
- * can include a {@link AppGlideModule}. Libraries must use {@link LibraryGlideModule}.
+ * <p>There can be at most one {@link AppGlideModule} in an application. Only Applications can
+ * include a {@link AppGlideModule}. Libraries must use {@link LibraryGlideModule}.
  *
- * <p>Classes that extend {@link AppGlideModule} must be annotated with
- * {@link com.bumptech.glide.annotation.GlideModule} to be processed correctly.
+ * <p>Classes that extend {@link AppGlideModule} must be annotated with {@link
+ * com.bumptech.glide.annotation.GlideModule} to be processed correctly.
  *
- * <p>Classes that extend {@link AppGlideModule} can optionally be annotated with
- * {@link com.bumptech.glide.annotation.Excludes} to optionally exclude one or more
- * {@link LibraryGlideModule} and/or {@link GlideModule} classes.
+ * <p>Classes that extend {@link AppGlideModule} can optionally be annotated with {@link
+ * com.bumptech.glide.annotation.Excludes} to optionally exclude one or more {@link
+ * LibraryGlideModule} and/or {@link GlideModule} classes.
  *
  * <p>Once an application has migrated itself and all libraries it depends on to use Glide's
- * annotation processor, {@link AppGlideModule} implementations should override
- * {@link #isManifestParsingEnabled()} and return {@code false}.
+ * annotation processor, {@link AppGlideModule} implementations should override {@link
+ * #isManifestParsingEnabled()} and return {@code false}.
  */
+// Used only in javadoc.
+@SuppressWarnings("deprecation")
 public abstract class AppGlideModule extends LibraryGlideModule implements AppliesOptions {
   /**
    * Returns {@code true} if Glide should check the AndroidManifest for {@link GlideModule}s.
@@ -34,7 +37,7 @@ public boolean isManifestParsingEnabled() {
   }
 
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Default empty impl.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
index 923d364f7..26abf8694 100644
--- a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
+++ b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
@@ -1,20 +1,20 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.GlideBuilder;
 
-/**
- * An internal interface, to be removed when {@link GlideModule}s are removed.
- */
+/** An internal interface, to be removed when {@link GlideModule}s are removed. */
+@Deprecated
 interface AppliesOptions {
   /**
    * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
    * singleton is created.
    *
-   * <p> This method will be called once and only once per implementation. </p>
+   * <p>This method will be called once and only once per implementation.
    *
    * @param context An Application {@link android.content.Context}.
    * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
    */
-  void applyOptions(Context context, GlideBuilder builder);
+  void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder);
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
index b8e2108e6..7e6327c2c 100644
--- a/library/src/main/java/com/bumptech/glide/module/GlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -3,15 +3,17 @@
 import com.bumptech.glide.Registry;
 
 /**
- * An interface allowing lazy configuration of Glide including setting options using
- * {@link com.bumptech.glide.GlideBuilder} and registering
- * {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders}.
+ * An interface allowing lazy configuration of Glide including setting options using {@link
+ * com.bumptech.glide.GlideBuilder} and registering {@link com.bumptech.glide.load.model.ModelLoader
+ * ModelLoaders}.
  *
- * <p> To use this interface: <ol> <li> Implement the GlideModule interface in a class with public
- * visibility, calling
- * {@link Registry#prepend(Class, Class, com.bumptech.glide.load.ResourceDecoder)} for each
- * {@link com.bumptech.glide.load.model.ModelLoader} you'd like to register:
- * <pre>
+ * <p>To use this interface:
+ *
+ * <ol>
+ *   <li>Implement the GlideModule interface in a class with public visibility, calling {@link
+ *       Registry#prepend(Class, Class, com.bumptech.glide.load.ResourceDecoder)} for each {@link
+ *       com.bumptech.glide.load.model.ModelLoader} you'd like to register:
+ *       <pre>
  *                  <code>
  *                      public class FlickrGlideModule implements GlideModule {
  *                          {@literal @}Override
@@ -26,33 +28,29 @@
  *                      }
  *                  </code>
  *             </pre>
- * </li> <li> Add your implementation to your list of keeps in your proguard.cfg file:
- * <pre>
- *                  {@code
- *                      -keepnames class * com.bumptech.glide.samples.flickr.FlickrGlideModule
- *                  }
- *              </pre>
- * </li> <li> Add a metadata tag to your AndroidManifest.xml with your GlideModule implementation's
- * fully qualified classname as the key, and {@code GlideModule} as the value:
- * <pre>
- *                 {@code
- *                      <meta-data
- *                          android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
- *                          android:value="GlideModule" />
- *                 }
- *             </pre>
- * </li> </ol> </p>
+ *   <li>Add your implementation to your list of keeps in your proguard.cfg file:
+ *       <pre>{@code
+ * -keepnames class * com.bumptech.glide.samples.flickr.FlickrGlideModule
+ * }</pre>
+ *   <li>Add a metadata tag to your AndroidManifest.xml with your GlideModule implementation's fully
+ *       qualified classname as the key, and {@code GlideModule} as the value:
+ *       <pre>{@code
+ * <meta-data
+ *     android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
+ *     android:value="GlideModule" />
+ * }</pre>
+ * </ol>
  *
- * <p> All implementations must be publicly visible and contain only an empty constructor so they
- * can be instantiated via reflection when Glide is lazily initialized. </p>
+ * <p>All implementations must be publicly visible and contain only an empty constructor so they can
+ * be instantiated via reflection when Glide is lazily initialized.
  *
- * <p> There is no defined order in which modules are called, so projects should be careful to avoid
+ * <p>There is no defined order in which modules are called, so projects should be careful to avoid
  * applying conflicting settings in different modules. If an application depends on libraries that
  * have conflicting modules, the application should consider avoiding the library modules and
- * instead providing their required dependencies in a single application module. </p>
+ * instead providing their required dependencies in a single application module.
  *
- * @deprecated Libraries should use {@link LibraryGlideModule} and Applications should use
- * {@link AppGlideModule}.
+ * @deprecated Libraries should use {@link LibraryGlideModule} and Applications should use {@link
+ *     AppGlideModule}.
  */
 @Deprecated
-public interface GlideModule extends RegistersComponents, AppliesOptions { }
+public interface GlideModule extends RegistersComponents, AppliesOptions {}
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
index ccf368671..02330d369 100644
--- a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -1,23 +1,26 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
 /**
- * Registers a set of components to use when initializing Glide within an app when
- * Glide's annotation processor is used.
+ * Registers a set of components to use when initializing Glide within an app when Glide's
+ * annotation processor is used.
  *
  * <p>Any number of LibraryGlideModules can be contained within any library or application.
  *
  * <p>LibraryGlideModules are called in no defined order. If LibraryGlideModules within an
- * application conflict, {@link AppGlideModule}s can use the
- * {@link com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of
- * the conflicting modules.
+ * application conflict, {@link AppGlideModule}s can use the {@link
+ * com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of the
+ * conflicting modules.
  */
+@SuppressWarnings("deprecation")
 public abstract class LibraryGlideModule implements RegistersComponents {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     // Default empty impl.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 9b0eb69a8..af42f709e 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -4,12 +4,16 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.util.Log;
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
  */
+// Used only in javadoc.
+@SuppressWarnings("deprecation")
+@Deprecated
 public final class ManifestParser {
   private static final String TAG = "ManifestParser";
   private static final String GLIDE_MODULE_VALUE = "GlideModule";
@@ -27,8 +31,10 @@ public ManifestParser(Context context) {
     }
     List<GlideModule> modules = new ArrayList<>();
     try {
-      ApplicationInfo appInfo = context.getPackageManager()
-          .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
+      ApplicationInfo appInfo =
+          context
+              .getPackageManager()
+              .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
       if (appInfo.metaData == null) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Got null app info metadata");
@@ -65,16 +71,18 @@ private static GlideModule parseModule(String className) {
       throw new IllegalArgumentException("Unable to find GlideModule implementation", e);
     }
 
-    Object module;
+    Object module = null;
     try {
-      module = clazz.newInstance();
-    } catch (InstantiationException e) {
-      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-              e);
+      module = clazz.getDeclaredConstructor().newInstance();
       // These can't be combined until API minimum is 19.
+    } catch (InstantiationException e) {
+      throwInstantiateGlideModuleException(clazz, e);
     } catch (IllegalAccessException e) {
-      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-              e);
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (NoSuchMethodException e) {
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (InvocationTargetException e) {
+      throwInstantiateGlideModuleException(clazz, e);
     }
 
     if (!(module instanceof GlideModule)) {
@@ -82,4 +90,8 @@ private static GlideModule parseModule(String className) {
     }
     return (GlideModule) module;
   }
+
+  private static void throwInstantiateGlideModuleException(Class<?> clazz, Exception e) {
+    throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz, e);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
index f87a7409a..40a848a42 100644
--- a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -1,23 +1,26 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
-/**
- * An internal interface, to be removed when {@link GlideModule}s are removed.
- */
+/** An internal interface, to be removed when {@link GlideModule}s are removed. */
+// Used only in javadocs.
+@SuppressWarnings("deprecation")
+@Deprecated
 interface RegistersComponents {
 
   /**
    * Lazily register components immediately after the Glide singleton is created but before any
    * requests can be started.
    *
-   * <p> This method will be called once and only once per implementation. </p>
+   * <p>This method will be called once and only once per implementation.
    *
-   * @param context  An Application {@link android.content.Context}.
+   * @param context An Application {@link android.content.Context}.
    * @param glide The Glide singleton that is in the process of being initialized.
    * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
    */
-  void registerComponents(Context context, Glide glide, Registry registry);
+  void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry);
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index 1cc3bba81..8e65f5fb3 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -1,21 +1,20 @@
 package com.bumptech.glide.provider;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
-/**
- * Contains an ordered list of {@link Encoder}s capable of encoding arbitrary data types.
- */
+/** Contains an ordered list of {@link Encoder}s capable of encoding arbitrary data types. */
 public class EncoderRegistry {
   // TODO: This registry should probably contain a put, rather than a list.
   private final List<Entry<?>> encoders = new ArrayList<>();
 
   @SuppressWarnings("unchecked")
   @Nullable
-  public synchronized <T> Encoder<T> getEncoder(Class<T> dataClass) {
+  public synchronized <T> Encoder<T> getEncoder(@NonNull Class<T> dataClass) {
     for (Entry<?> entry : encoders) {
       if (entry.handles(dataClass)) {
         return (Encoder<T>) entry.encoder;
@@ -24,24 +23,27 @@
     return null;
   }
 
-  public synchronized <T> void append(Class<T> dataClass, Encoder<T> encoder) {
+  public synchronized <T> void append(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
     encoders.add(new Entry<>(dataClass, encoder));
   }
 
-  public synchronized <T> void prepend(Class<T> dataClass, Encoder<T> encoder) {
+  public synchronized <T> void prepend(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
     encoders.add(0, new Entry<>(dataClass, encoder));
   }
 
   private static final class Entry<T> {
     private final Class<T> dataClass;
-    @Synthetic final Encoder<T> encoder;
 
-    public Entry(Class<T> dataClass, Encoder<T> encoder) {
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    final Encoder<T> encoder;
+
+    Entry(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
       this.dataClass = dataClass;
       this.encoder = encoder;
     }
 
-    public boolean handles(Class<?> dataClass) {
+    boolean handles(@NonNull Class<?> dataClass) {
       return this.dataClass.isAssignableFrom(dataClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
index af329320e..d574b3f28 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -1,20 +1,20 @@
 package com.bumptech.glide.provider;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.ImageHeaderParser;
 import java.util.ArrayList;
 import java.util.List;
 
-/**
- * Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers.
- */
+/** Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers. */
 public final class ImageHeaderParserRegistry {
   private final List<ImageHeaderParser> parsers = new ArrayList<>();
 
+  @NonNull
   public synchronized List<ImageHeaderParser> getParsers() {
     return parsers;
   }
 
-  public synchronized void add(ImageHeaderParser parser) {
+  public synchronized void add(@NonNull ImageHeaderParser parser) {
     parsers.add(parser);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
index 6cc5d9630..36dec33fe 100644
--- a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
@@ -1,29 +1,52 @@
 package com.bumptech.glide.provider;
 
-import android.support.annotation.Nullable;
-import android.support.v4.util.ArrayMap;
+import androidx.annotation.Nullable;
+import androidx.collection.ArrayMap;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.DecodePath;
 import com.bumptech.glide.load.engine.LoadPath;
+import com.bumptech.glide.load.resource.transcode.UnitTranscoder;
 import com.bumptech.glide.util.MultiClassKey;
+import java.util.Collections;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
- * Maintains a cache of data, resource, and transcode classes to available
- * {@link com.bumptech.glide.load.engine.LoadPath}s capable of decoding with the requested types.
+ * Maintains a cache of data, resource, and transcode classes to available {@link
+ * com.bumptech.glide.load.engine.LoadPath}s capable of decoding with the requested types.
  */
 public class LoadPathCache {
+  private static final LoadPath<?, ?, ?> NO_PATHS_SIGNAL =
+      new LoadPath<>(
+          Object.class,
+          Object.class,
+          Object.class,
+          Collections.singletonList(
+              new DecodePath<>(
+                  Object.class,
+                  Object.class,
+                  Object.class,
+                  Collections.<ResourceDecoder<Object, Object>>emptyList(),
+                  new UnitTranscoder<>(),
+                  /*listPool=*/ null)),
+          /*listPool=*/ null);
+
   private final ArrayMap<MultiClassKey, LoadPath<?, ?, ?>> cache = new ArrayMap<>();
   private final AtomicReference<MultiClassKey> keyRef = new AtomicReference<>();
 
-  public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass) {
-    MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
-    boolean result;
-    synchronized (cache) {
-      result = cache.containsKey(key);
-    }
-    keyRef.set(key);
-    return result;
+  /**
+   * Returns {@code} true if the given {@link LoadPath} is the signal object returned from {@link
+   * #get(Class, Class, Class)} that indicates that we've previously found that there are no
+   * available paths to load the requested resources and {@code false} otherwise.
+   */
+  public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {
+    return NO_PATHS_SIGNAL.equals(path);
   }
 
+  /**
+   * May return {@link #NO_PATHS_SIGNAL} to indicate that we've previously found that there are 0
+   * available load paths for the requested types. Callers must check using {@link
+   * #isEmptyLoadPath(LoadPath)} before using any load path returned by this method.
+   */
   @SuppressWarnings("unchecked")
   @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> get(
@@ -31,23 +54,28 @@ public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> tra
     MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
     LoadPath<?, ?, ?> result;
     synchronized (cache) {
-       result = cache.get(key);
+      result = cache.get(key);
     }
     keyRef.set(key);
 
     return (LoadPath<Data, TResource, Transcode>) result;
   }
 
-  public void put(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass,
-      LoadPath<?, ?, ?> loadPath) {
+  public void put(
+      Class<?> dataClass,
+      Class<?> resourceClass,
+      Class<?> transcodeClass,
+      @Nullable LoadPath<?, ?, ?> loadPath) {
     synchronized (cache) {
-      cache.put(new MultiClassKey(dataClass, resourceClass, transcodeClass), loadPath);
+      cache.put(
+          new MultiClassKey(dataClass, resourceClass, transcodeClass),
+          loadPath != null ? loadPath : NO_PATHS_SIGNAL);
     }
   }
 
-  private MultiClassKey getKey(Class<?> dataClass, Class<?> resourceClass,
-      Class<?> transcodeClass) {
-     MultiClassKey key = keyRef.getAndSet(null);
+  private MultiClassKey getKey(
+      Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass) {
+    MultiClassKey key = keyRef.getAndSet(null);
     if (key == null) {
       key = new MultiClassKey();
     }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
index 076661dfa..92f09f500 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.provider;
 
-import android.support.annotation.Nullable;
-import android.support.v4.util.ArrayMap;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.collection.ArrayMap;
 import com.bumptech.glide.util.MultiClassKey;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
@@ -16,25 +17,32 @@
       new ArrayMap<>();
 
   @Nullable
-  public List<Class<?>> get(Class<?> modelClass, Class<?> resourceClass) {
+  public List<Class<?>> get(
+      @NonNull Class<?> modelClass,
+      @NonNull Class<?> resourceClass,
+      @NonNull Class<?> transcodeClass) {
     MultiClassKey key = resourceClassKeyRef.getAndSet(null);
     if (key == null) {
-      key = new MultiClassKey(modelClass, resourceClass);
+      key = new MultiClassKey(modelClass, resourceClass, transcodeClass);
     } else {
-      key.set(modelClass, resourceClass);
+      key.set(modelClass, resourceClass, transcodeClass);
     }
     final List<Class<?>> result;
     synchronized (registeredResourceClassCache) {
-       result = registeredResourceClassCache.get(key);
+      result = registeredResourceClassCache.get(key);
     }
     resourceClassKeyRef.set(key);
     return result;
   }
 
-  public void put(Class<?> modelClass, Class<?> resourceClass, List<Class<?>> resourceClasses) {
+  public void put(
+      @NonNull Class<?> modelClass,
+      @NonNull Class<?> resourceClass,
+      @NonNull Class<?> transcodeClass,
+      @NonNull List<Class<?>> resourceClasses) {
     synchronized (registeredResourceClassCache) {
-      registeredResourceClassCache
-          .put(new MultiClassKey(modelClass, resourceClass), resourceClasses);
+      registeredResourceClassCache.put(
+          new MultiClassKey(modelClass, resourceClass, transcodeClass), resourceClasses);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
index b7e95fd40..7884fc97a 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.provider;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
@@ -16,7 +17,7 @@
   private final List<String> bucketPriorityList = new ArrayList<>();
   private final Map<String, List<Entry<?, ?>>> decoders = new HashMap<>();
 
-  public synchronized void setBucketPriorityList(List<String> buckets) {
+  public synchronized void setBucketPriorityList(@NonNull List<String> buckets) {
     List<String> previousBuckets = new ArrayList<>(bucketPriorityList);
     bucketPriorityList.clear();
     bucketPriorityList.addAll(buckets);
@@ -29,9 +30,10 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
     }
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(Class<T> dataClass,
-      Class<R> resourceClass) {
+  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
     List<ResourceDecoder<T, R>> result = new ArrayList<>();
     for (String bucket : bucketPriorityList) {
       List<Entry<?, ?>> entries = decoders.get(bucket);
@@ -49,9 +51,10 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
     return result;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<Class<R>> getResourceClasses(Class<T> dataClass,
-      Class<R> resourceClass) {
+  public synchronized <T, R> List<Class<R>> getResourceClasses(
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
     List<Class<R>> result = new ArrayList<>();
     for (String bucket : bucketPriorityList) {
       List<Entry<?, ?>> entries = decoders.get(bucket);
@@ -59,7 +62,8 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
         continue;
       }
       for (Entry<?, ?> entry : entries) {
-        if (entry.handles(dataClass, resourceClass)) {
+        if (entry.handles(dataClass, resourceClass)
+            && !result.contains((Class<R>) entry.resourceClass)) {
           result.add((Class<R>) entry.resourceClass);
         }
       }
@@ -68,16 +72,23 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
   }
 
   public synchronized <T, R> void append(
-      String bucket, ResourceDecoder<T, R> decoder, Class<T> dataClass, Class<R> resourceClass) {
+      @NonNull String bucket,
+      @NonNull ResourceDecoder<T, R> decoder,
+      @NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     getOrAddEntryList(bucket).add(new Entry<>(dataClass, resourceClass, decoder));
   }
 
   public synchronized <T, R> void prepend(
-      String bucket, ResourceDecoder<T, R> decoder, Class<T> dataClass, Class<R> resourceClass) {
+      @NonNull String bucket,
+      @NonNull ResourceDecoder<T, R> decoder,
+      @NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     getOrAddEntryList(bucket).add(0, new Entry<>(dataClass, resourceClass, decoder));
   }
 
-  private synchronized List<Entry<?, ?>> getOrAddEntryList(String bucket) {
+  @NonNull
+  private synchronized List<Entry<?, ?>> getOrAddEntryList(@NonNull String bucket) {
     if (!bucketPriorityList.contains(bucket)) {
       // Add this unspecified bucket as a low priority bucket.
       bucketPriorityList.add(bucket);
@@ -95,15 +106,18 @@ public synchronized void setBucketPriorityList(List<String> buckets) {
     @Synthetic final Class<R> resourceClass;
     @Synthetic final ResourceDecoder<T, R> decoder;
 
-    public Entry(Class<T> dataClass, Class<R> resourceClass, ResourceDecoder<T, R> decoder) {
+    public Entry(
+        @NonNull Class<T> dataClass,
+        @NonNull Class<R> resourceClass,
+        ResourceDecoder<T, R> decoder) {
       this.dataClass = dataClass;
       this.resourceClass = resourceClass;
       this.decoder = decoder;
     }
 
-    public boolean handles(Class<?> dataClass, Class<?> resourceClass) {
-      return this.dataClass.isAssignableFrom(dataClass) && resourceClass
-          .isAssignableFrom(this.resourceClass);
+    public boolean handles(@NonNull Class<?> dataClass, @NonNull Class<?> resourceClass) {
+      return this.dataClass.isAssignableFrom(dataClass)
+          && resourceClass.isAssignableFrom(this.resourceClass);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index a0e9e32d2..5b87eb145 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.provider;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
@@ -12,21 +13,23 @@
  */
 public class ResourceEncoderRegistry {
   // TODO: this should probably be a put.
-  final List<Entry<?>> encoders = new ArrayList<>();
+  private final List<Entry<?>> encoders = new ArrayList<>();
 
-  public synchronized <Z> void append(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void append(
+      @NonNull Class<Z> resourceClass, @NonNull ResourceEncoder<Z> encoder) {
     encoders.add(new Entry<>(resourceClass, encoder));
   }
 
-  public synchronized <Z> void prepend(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void prepend(
+      @NonNull Class<Z> resourceClass, @NonNull ResourceEncoder<Z> encoder) {
     encoders.add(0, new Entry<>(resourceClass, encoder));
   }
 
   @SuppressWarnings("unchecked")
   @Nullable
-  public synchronized <Z> ResourceEncoder<Z> get(Class<Z> resourceClass) {
-    int size = encoders.size();
-    for (int i = 0; i < size; i++) {
+  public synchronized <Z> ResourceEncoder<Z> get(@NonNull Class<Z> resourceClass) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = encoders.size(); i < size; i++) {
       Entry<?> entry = encoders.get(i);
       if (entry.handles(resourceClass)) {
         return (ResourceEncoder<Z>) entry.encoder;
@@ -40,13 +43,13 @@
     private final Class<T> resourceClass;
     @Synthetic final ResourceEncoder<T> encoder;
 
-    Entry(Class<T> resourceClass, ResourceEncoder<T> encoder) {
+    Entry(@NonNull Class<T> resourceClass, @NonNull ResourceEncoder<T> encoder) {
       this.resourceClass = resourceClass;
       this.encoder = encoder;
     }
 
     @Synthetic
-    boolean handles(Class<?> resourceClass) {
+    boolean handles(@NonNull Class<?> resourceClass) {
       return this.resourceClass.isAssignableFrom(resourceClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
new file mode 100644
index 000000000..6472b8060
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -0,0 +1,1433 @@
+package com.bumptech.glide.request;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.MultiTransformation;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.DrawableTransformation;
+import com.bumptech.glide.load.resource.bitmap.FitCenter;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
+import com.bumptech.glide.load.resource.gif.GifOptions;
+import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.util.CachedHashCodeArrayMap;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+import java.util.Map;
+
+/**
+ * A base object to allow method sharing between {@link RequestOptions} and {@link
+ * com.bumptech.glide.RequestBuilder}.
+ *
+ * <p>This class is not meant for general use and may change at any time.
+ *
+ * @param <T> The particular child implementation
+ */
+@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
+public abstract class BaseRequestOptions<T extends BaseRequestOptions<T>> implements Cloneable {
+  private static final int UNSET = -1;
+  private static final int SIZE_MULTIPLIER = 1 << 1;
+  private static final int DISK_CACHE_STRATEGY = 1 << 2;
+  private static final int PRIORITY = 1 << 3;
+  private static final int ERROR_PLACEHOLDER = 1 << 4;
+  private static final int ERROR_ID = 1 << 5;
+  private static final int PLACEHOLDER = 1 << 6;
+  private static final int PLACEHOLDER_ID = 1 << 7;
+  private static final int IS_CACHEABLE = 1 << 8;
+  private static final int OVERRIDE = 1 << 9;
+  private static final int SIGNATURE = 1 << 10;
+  private static final int TRANSFORMATION = 1 << 11;
+  private static final int RESOURCE_CLASS = 1 << 12;
+  private static final int FALLBACK = 1 << 13;
+  private static final int FALLBACK_ID = 1 << 14;
+  private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
+  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
+  private static final int USE_ANIMATION_POOL = 1 << 20;
+
+  private int fields;
+  private float sizeMultiplier = 1f;
+  @NonNull private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  @NonNull private Priority priority = Priority.NORMAL;
+  @Nullable private Drawable errorPlaceholder;
+  private int errorId;
+  @Nullable private Drawable placeholderDrawable;
+  private int placeholderId;
+  private boolean isCacheable = true;
+  private int overrideHeight = UNSET;
+  private int overrideWidth = UNSET;
+  @NonNull private Key signature = EmptySignature.obtain();
+  private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
+  @Nullable private Drawable fallbackDrawable;
+  private int fallbackId;
+  @NonNull private Options options = new Options();
+
+  @NonNull
+  private Map<Class<?>, Transformation<?>> transformations = new CachedHashCodeArrayMap<>();
+
+  @NonNull private Class<?> resourceClass = Object.class;
+  private boolean isLocked;
+  @Nullable private Resources.Theme theme;
+  private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
+  private boolean onlyRetrieveFromCache;
+  private boolean isScaleOnlyOrNoTransform = true;
+  private boolean useAnimationPool;
+
+  private static boolean isSet(int fields, int flag) {
+    return (fields & flag) != 0;
+  }
+
+  /**
+   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
+   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
+   * (particularly {@link Bitmap}s on devices with overly dense screens.
+   *
+   * @param sizeMultiplier The multiplier to apply to the {@link
+   *     com.bumptech.glide.request.target.Target}'s dimensions when loading the resource.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T sizeMultiplier(@FloatRange(from = 0, to = 1) float sizeMultiplier) {
+    if (isAutoCloneEnabled) {
+      return clone().sizeMultiplier(sizeMultiplier);
+    }
+
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.sizeMultiplier = sizeMultiplier;
+    fields |= SIZE_MULTIPLIER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to {@code true}, uses a cached unlimited {@link java.util.concurrent.Executor} to run
+   * the request.
+   *
+   * <p>This method should <em>ONLY</em> be used when a Glide load is started recursively on one of
+   * Glide's threads as part of another request. Using this method in other scenarios can lead to
+   * excessive memory usage and OOMs and/or a significant decrease in performance across an
+   * application.
+   *
+   * <p>If both this method and {@link #useAnimationPool(boolean)} are set, this method will be
+   * preferred and {@link #useAnimationPool(boolean)} will be ignored.
+   */
+  @NonNull
+  @CheckResult
+  public T useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to {@code true}, uses a special {@link java.util.concurrent.Executor} that is used
+   * exclusively for decoding frames of animated resources, like GIFs.
+   *
+   * <p>The animation executor disallows network operations and must not be used for loads that may
+   * load remote data. The animation executor has fewer threads available to it than Glide's normal
+   * executors and is only useful as a way of avoiding blocking on longer and more expensive reads
+   * for critical requests like those in an animating GIF.
+   *
+   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and this method are set, {@link
+   * #useUnlimitedSourceGeneratorsPool(boolean)} will be preferred and this method will be ignored.
+   */
+  @NonNull
+  @CheckResult
+  public T useAnimationPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useAnimationPool(flag);
+    }
+
+    useAnimationPool = flag;
+    fields |= USE_ANIMATION_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to true, will only load an item if found in the cache, and will not fetch from source.
+   */
+  @NonNull
+  @CheckResult
+  public T onlyRetrieveFromCache(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().onlyRetrieveFromCache(flag);
+    }
+
+    this.onlyRetrieveFromCache = flag;
+    fields |= ONLY_RETRIEVE_FROM_CACHE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link DiskCacheStrategy} to use for this load.
+   *
+   * <p>Defaults to {@link DiskCacheStrategy#AUTOMATIC}.
+   *
+   * <p>For most applications {@link DiskCacheStrategy#RESOURCE} is ideal. Applications that use the
+   * same resource multiple times in multiple sizes and are willing to trade off some speed and disk
+   * space in return for lower bandwidth usage may want to consider using {@link
+   * DiskCacheStrategy#DATA} or {@link DiskCacheStrategy#ALL}.
+   *
+   * @param strategy The strategy to use.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    if (isAutoCloneEnabled) {
+      return clone().diskCacheStrategy(strategy);
+    }
+    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
+    fields |= DISK_CACHE_STRATEGY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the priority for this load.
+   *
+   * @param priority A priority.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T priority(@NonNull Priority priority) {
+    if (isAutoCloneEnabled) {
+      return clone().priority(priority);
+    }
+
+    this.priority = Preconditions.checkNotNull(priority);
+    fields |= PRIORITY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display while a resource is loading.
+   *
+   * <p>Replaces any previous calls to this method or {@link #placeholder(int)}.
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T placeholder(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(drawable);
+    }
+
+    this.placeholderDrawable = drawable;
+    fields |= PLACEHOLDER;
+
+    placeholderId = 0;
+    fields &= ~PLACEHOLDER_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an Android resource id for a {@link Drawable} resource to display while a resource is
+   * loading.
+   *
+   * <p>Replaces any previous calls to this method or {@link #placeholder(Drawable)}
+   *
+   * @param resourceId The id of the resource to use as a placeholder
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T placeholder(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(resourceId);
+    }
+
+    this.placeholderId = resourceId;
+    fields |= PLACEHOLDER_ID;
+
+    placeholderDrawable = null;
+    fields &= ~PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display if the model provided to {@link
+   * com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p>If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * <p>Replaces any previous calls to this method or {@link #fallback(int)}.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T fallback(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(drawable);
+    }
+
+    this.fallbackDrawable = drawable;
+    fields |= FALLBACK;
+
+    fallbackId = 0;
+    fields &= ~FALLBACK_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if the model provided to {@link
+   * com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p>If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * <p>Replaces any previous calls to this method or {@link #fallback(Drawable)}.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   * @param resourceId The id of the resource to use as a fallback.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T fallback(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(resourceId);
+    }
+
+    this.fallbackId = resourceId;
+    fields |= FALLBACK_ID;
+
+    fallbackDrawable = null;
+    fields &= ~FALLBACK;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a {@link Drawable} to display if a load fails.
+   *
+   * <p>Replaces any previous calls to this method or {@link #error(int)}
+   *
+   * @param drawable The drawable to display.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T error(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().error(drawable);
+    }
+
+    this.errorPlaceholder = drawable;
+    fields |= ERROR_PLACEHOLDER;
+
+    this.errorId = 0;
+    fields &= ~ERROR_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if a load fails.
+   *
+   * <p>Replaces any previous calls to this method or {@link #error(Drawable)}
+   *
+   * @param resourceId The id of the resource to use as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T error(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().error(resourceId);
+    }
+    this.errorId = resourceId;
+    fields |= ERROR_ID;
+
+    this.errorPlaceholder = null;
+    fields &= ~ERROR_PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and {@link
+   * #fallback(Drawable)}.
+   *
+   * <p>The theme is <em>NOT</em> applied in the decoder that will attempt to decode a given
+   * resource id model on Glide's background threads. The theme is used exclusively on the main
+   * thread to obtain placeholder/error/fallback drawables to avoid leaking Activities.
+   *
+   * <p>If the {@link android.content.Context} of the {@link android.app.Fragment} or {@link
+   * android.app.Activity} used to start this load has a different {@link
+   * android.content.res.Resources.Theme}, the {@link android.content.res.Resources.Theme} provided
+   * here will override the {@link android.content.res.Resources.Theme} of the {@link
+   * android.content.Context}.
+   *
+   * @param theme The theme to use when loading Drawables.
+   * @return this request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T theme(@Nullable Resources.Theme theme) {
+    if (isAutoCloneEnabled) {
+      return clone().theme(theme);
+    }
+
+    this.theme = theme;
+    fields |= THEME;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Allows the loaded resource to skip the memory cache.
+   *
+   * <p>Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.
+   *
+   * @param skip True to allow the resource to skip the memory cache.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T skipMemoryCache(boolean skip) {
+    if (isAutoCloneEnabled) {
+      return clone().skipMemoryCache(true);
+    }
+
+    this.isCacheable = !skip;
+    fields |= IS_CACHEABLE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given values. This is useful for thumbnails, and should only be used for other cases when you
+   * need a very specific image size.
+   *
+   * @param width The width in pixels to use to load the resource.
+   * @param height The height in pixels to use to load the resource.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T override(int width, int height) {
+    if (isAutoCloneEnabled) {
+      return clone().override(width, height);
+    }
+
+    this.overrideWidth = width;
+    this.overrideHeight = height;
+    fields |= OVERRIDE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given size.
+   *
+   * @see #override(int, int)
+   * @param size The width and height to use.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public T override(int size) {
+    return override(size, size);
+  }
+
+  /**
+   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
+   * more control over when cached data is invalidated.
+   *
+   * <p>Note - The signature does not replace the cache key, it is purely additive.
+   *
+   * @param signature A unique non-null {@link Key} representing the current state of the model that
+   *     will be mixed in to the cache key.
+   * @return This request builder.
+   * @see com.bumptech.glide.signature.ObjectKey
+   */
+  @NonNull
+  @CheckResult
+  public T signature(@NonNull Key signature) {
+    if (isAutoCloneEnabled) {
+      return clone().signature(signature);
+    }
+
+    this.signature = Preconditions.checkNotNull(signature);
+    fields |= SIGNATURE;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p>This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders.
+   *
+   * <p>Even if this object was locked, the cloned object returned from this method will not be
+   * locked.
+   */
+  @SuppressWarnings({
+    "unchecked",
+    // we don't want to throw to be user friendly
+    "PMD.CloneThrowsCloneNotSupportedException",
+    // The types we're using here do this automatically.
+    "PMD.CloneMethodReturnTypeMustMatchClassName"
+  })
+  @CheckResult
+  @Override
+  public T clone() {
+    try {
+      BaseRequestOptions<?> result = (BaseRequestOptions<?>) super.clone();
+      result.options = new Options();
+      result.options.putAll(options);
+      result.transformations = new CachedHashCodeArrayMap<>();
+      result.transformations.putAll(transformations);
+      result.isLocked = false;
+      result.isAutoCloneEnabled = false;
+      return (T) result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @NonNull
+  @CheckResult
+  public <Y> T set(@NonNull Option<Y> option, @NonNull Y value) {
+    if (isAutoCloneEnabled) {
+      return clone().set(option, value);
+    }
+
+    Preconditions.checkNotNull(option);
+    Preconditions.checkNotNull(value);
+    options.set(option, value);
+    return selfOrThrowIfLocked();
+  }
+
+  @NonNull
+  @CheckResult
+  public T decode(@NonNull Class<?> resourceClass) {
+    if (isAutoCloneEnabled) {
+      return clone().decode(resourceClass);
+    }
+
+    this.resourceClass = Preconditions.checkNotNull(resourceClass);
+    fields |= RESOURCE_CLASS;
+    return selfOrThrowIfLocked();
+  }
+
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
+  public final boolean isTransformationSet() {
+    return isSet(TRANSFORMATION);
+  }
+
+  public final boolean isLocked() {
+    return isLocked;
+  }
+
+  /**
+   * Sets the value for key {@link
+   * com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   */
+  @NonNull
+  @CheckResult
+  public T encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /** Sets the value for key {@link BitmapEncoder#COMPRESSION_QUALITY}. */
+  @NonNull
+  @CheckResult
+  public T encodeQuality(@IntRange(from = 0, to = 100) int quality) {
+    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+  }
+
+  /**
+   * Sets the time position of the frame to extract from a video.
+   *
+   * <p>This is a component option specific to {@link VideoDecoder}. If the default video decoder is
+   * replaced or skipped because of your configuration, this option may be ignored.
+   *
+   * @see VideoDecoder#TARGET_FRAME
+   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
+   *     Android framework implementation return a representative frame.
+   */
+  @NonNull
+  @CheckResult
+  public T frame(@IntRange(from = 0) long frameTimeMicros) {
+    return set(VideoDecoder.TARGET_FRAME, frameTimeMicros);
+  }
+
+  /**
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using {@link
+   * Downsampler} and Glide's default GIF decoders.
+   *
+   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
+   * decoded using a decoder that cannot control the format ({@link
+   * android.media.MediaMetadataRetriever} for example), or that the decoder may choose to ignore
+   * the requested format if it can't display the image (i.e. RGB_565 is requested, but the image
+   * has alpha).
+   *
+   * <p>This is a component option specific to {@link Downsampler} and Glide's GIF decoders. If the
+   * default Bitmap decoders are replaced or skipped because of your configuration, this option may
+   * be ignored.
+   *
+   * <p>To set only the format used when decoding {@link Bitmap}s, use {@link #set(Option, Object)}}
+   * and {@link Downsampler#DECODE_FORMAT}. To set only the format used when decoding GIF frames,
+   * use {@link #set(Option, Object)} and {@link GifOptions#DECODE_FORMAT}.
+   *
+   * @see Downsampler#DECODE_FORMAT
+   * @see GifOptions#DECODE_FORMAT
+   */
+  @NonNull
+  @CheckResult
+  public T format(@NonNull DecodeFormat format) {
+    Preconditions.checkNotNull(format);
+    return set(Downsampler.DECODE_FORMAT, format).set(GifOptions.DECODE_FORMAT, format);
+  }
+
+  /**
+   * Disables the use of {@link android.graphics.Bitmap.Config#HARDWARE} in {@link Downsampler} to
+   * avoid errors caused by inspecting Bitmap pixels, drawing with hardware support disabled,
+   * drawing to {@link android.graphics.Canvas}s backed by {@link Bitmap}s etc.
+   *
+   * <p>It's almost never safe to set {@link Downsampler#ALLOW_HARDWARE_CONFIG} to {@code true} so
+   * we only provide a way to disable hardware configs entirely. If no option is set for {@link
+   * Downsampler#ALLOW_HARDWARE_CONFIG}, Glide will set the value per request based on whether or
+   * not a {@link Transformation} is applied and if one is, the type of {@link Transformation}
+   * applied. Built in transformations like {@link FitCenter} and {@link
+   * com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.CenterOutside} can safely use {@link
+   * android.graphics.Bitmap.Config#HARDWARE} because they can be entirely replaced by scaling
+   * within {@link Downsampler}. {@link Transformation}s like {@link #circleCrop()} that can't be
+   * replicated by {@link Downsampler} cannot use {@link Bitmap.Config#HARDWARE} because {@link
+   * android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to {@link android.graphics.Canvas}s,
+   * which is required by most {@link Transformation}s.
+   */
+  @NonNull
+  @CheckResult
+  public T disallowHardwareConfig() {
+    return set(Downsampler.ALLOW_HARDWARE_CONFIG, false);
+  }
+
+  /**
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using {@link
+   * Downsampler}.
+   *
+   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
+   * is replaced or skipped because of your configuration, this option may be ignored.
+   */
+  @NonNull
+  @CheckResult
+  public T downsample(@NonNull DownsampleStrategy strategy) {
+    return set(DownsampleStrategy.OPTION, Preconditions.checkNotNull(strategy));
+  }
+
+  /**
+   * Sets the read and write timeout for the http requests used to load the image.
+   *
+   * <p>This is a component option specific to Glide's default networking library and {@link
+   * com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other networking
+   * library including Glide's Volley or OkHttp integration libraries, this option will be ignored.
+   *
+   * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT
+   * @param timeoutMs The read and write timeout in milliseconds.
+   */
+  @NonNull
+  @CheckResult
+  public T timeout(@IntRange(from = 0) int timeoutMs) {
+    return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public T optionalCenterCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()} ()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public T centerCrop() {
+    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
+   * image types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to {@link
+   * #downsample(DownsampleStrategy)}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public T optionalFitCenter() {
+    return optionalScaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
+   * image types, and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to {@link
+   * #downsample(DownsampleStrategy)}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public T fitCenter() {
+    return scaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types,
+   * {@link DownsampleStrategy#CENTER_INSIDE} to image types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to {@link
+   * #downsample(DownsampleStrategy)}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public T optionalCenterInside() {
+    return optionalScaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CenterInside} to all default types, {@link DownsampleStrategy#CENTER_INSIDE} to
+   * image types and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to {@link
+   * #downsample(DownsampleStrategy)}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public T centerInside() {
+    return scaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Transformation)
+   * @see #circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public T optionalCircleCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public T circleCrop() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
+  }
+
+  // calling optionalTransform() on the result of clone() requires greater access.
+  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  @NonNull
+  final T optionalTransform(
+      @NonNull DownsampleStrategy downsampleStrategy,
+      @NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation, /*isRequired=*/ false);
+  }
+
+  // calling transform() on the result of clone() requires greater access.
+  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  @NonNull
+  @CheckResult
+  final T transform(
+      @NonNull DownsampleStrategy downsampleStrategy,
+      @NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation);
+  }
+
+  @NonNull
+  private T scaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy, @NonNull Transformation<Bitmap> transformation) {
+    return scaleOnlyTransform(strategy, transformation, true /*isTransformationRequired*/);
+  }
+
+  @NonNull
+  private T optionalScaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy, @NonNull Transformation<Bitmap> transformation) {
+    return scaleOnlyTransform(strategy, transformation, false /*isTransformationRequired*/);
+  }
+
+  // We know that result will always be T since we created result.
+  @SuppressWarnings("unchecked")
+  @NonNull
+  private T scaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy,
+      @NonNull Transformation<Bitmap> transformation,
+      boolean isTransformationRequired) {
+    BaseRequestOptions<T> result =
+        isTransformationRequired
+            ? transform(strategy, transformation)
+            : optionalTransform(strategy, transformation);
+    result.isScaleOnlyOrNoTransform = true;
+    return (T) result;
+  }
+
+  /**
+   * Applies the given {@link Transformation} for {@link Bitmap Bitmaps} to the default types
+   * ({@link Bitmap}, {@link android.graphics.drawable.BitmapDrawable}, and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}) and throws an exception if asked to
+   * transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public T transform(@NonNull Transformation<Bitmap> transformation) {
+    return transform(transformation, /*isRequired=*/ true);
+  }
+
+  /**
+   * Applies the given {@link Transformation}s in the given order for {@link Bitmap Bitmaps} to the
+   * default types ({@link Bitmap}, {@link android.graphics.drawable.BitmapDrawable}, and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}) and throws an exception if asked to
+   * transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
+  @NonNull
+  @CheckResult
+  public T transform(@NonNull Transformation<Bitmap>... transformations) {
+    if (transformations.length > 1) {
+      return transform(new MultiTransformation<>(transformations), /*isRequired=*/ true);
+    } else if (transformations.length == 1) {
+      return transform(transformations[0]);
+    } else {
+      return selfOrThrowIfLocked();
+    }
+  }
+
+  /**
+   * Applies the given {@link Transformation}s in the given order for {@link Bitmap Bitmaps} to the
+   * default types ({@link Bitmap}, {@link android.graphics.drawable.BitmapDrawable}, and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}) and throws an exception if asked to
+   * transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @deprecated Deprecated due to api update, use {@link #transform(Transformation[])} instead
+   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
+  @NonNull
+  @CheckResult
+  @Deprecated
+  public T transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return transform(new MultiTransformation<>(transformations), /*isRequired=*/ true);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for {@link Bitmap Bitmaps} to the default types
+   * ({@link Bitmap}, {@link android.graphics.drawable.BitmapDrawable}, and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
+   * @see #transform(Transformation)
+   * @see #transform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public T optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return transform(transformation, /*isRequired=*/ false);
+  }
+
+  @NonNull
+  T transform(@NonNull Transformation<Bitmap> transformation, boolean isRequired) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(transformation, isRequired);
+    }
+
+    DrawableTransformation drawableTransformation =
+        new DrawableTransformation(transformation, isRequired);
+    transform(Bitmap.class, transformation, isRequired);
+    transform(Drawable.class, drawableTransformation, isRequired);
+    // TODO: remove BitmapDrawable decoder and this transformation.
+    // Registering as BitmapDrawable is simply an optimization to avoid some iteration and
+    // isAssignableFrom checks when obtaining the transformation later on. It can be removed without
+    // affecting the functionality.
+    transform(BitmapDrawable.class, drawableTransformation.asBitmapDrawable(), isRequired);
+    transform(GifDrawable.class, new GifDrawableTransformation(transformation), isRequired);
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of the given type and allows
+   * unknown resource types to be ignored.
+   *
+   * <p>Users can apply different transformations for each resource class. Applying a {@link
+   * Transformation} for a resource type that already has a {@link Transformation} will override the
+   * previous call.
+   *
+   * <p>If any calls are made to the non-optional transform methods, then attempting to transform an
+   * unknown resource class will throw an exception. To allow unknown types, users must always call
+   * the optional version of each method.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   */
+  @NonNull
+  @CheckResult
+  public <Y> T optionalTransform(
+      @NonNull Class<Y> resourceClass, @NonNull Transformation<Y> transformation) {
+    return transform(resourceClass, transformation, /*isRequired=*/ false);
+  }
+
+  @NonNull
+  <Y> T transform(
+      @NonNull Class<Y> resourceClass,
+      @NonNull Transformation<Y> transformation,
+      boolean isRequired) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(resourceClass, transformation, isRequired);
+    }
+
+    Preconditions.checkNotNull(resourceClass);
+    Preconditions.checkNotNull(transformation);
+    transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
+    // Always set to false here. Known scale only transformations will call this method and then
+    // set isScaleOnlyOrNoTransform to true immediately after.
+    isScaleOnlyOrNoTransform = false;
+    if (isRequired) {
+      fields |= TRANSFORMATION_REQUIRED;
+      isTransformationRequired = true;
+    }
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of the given type and throws
+   * if asked to transform an unknown resource type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public <Y> T transform(
+      @NonNull Class<Y> resourceClass, @NonNull Transformation<Y> transformation) {
+    return transform(resourceClass, transformation, /*isRequired=*/ true);
+  }
+
+  /**
+   * Removes all applied {@link Transformation Transformations} for all resource classes and allows
+   * unknown resource types to be transformed without throwing an exception.
+   */
+  @NonNull
+  @CheckResult
+  public T dontTransform() {
+    if (isAutoCloneEnabled) {
+      return clone().dontTransform();
+    }
+
+    transformations.clear();
+    fields &= ~TRANSFORMATION;
+    isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
+    isScaleOnlyOrNoTransform = true;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Disables resource decoders that return animated resources so any resource returned will be
+   * static.
+   *
+   * <p>To disable transitions (fades etc) use {@link
+   * com.bumptech.glide.TransitionOptions#dontTransition()}
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public T dontAnimate() {
+    return set(GifOptions.DISABLE_ANIMATION, true);
+  }
+
+  /**
+   * Updates this options set with any options that are explicitly set in the given {@code T} object
+   * and returns this object if {@link #autoClone()} is disabled or a new {@code T} object if {@link
+   * #autoClone()} is enabled.
+   *
+   * <p>{@code #apply} only replaces those values that are explicitly set in the given {@code T}. If
+   * you need to completely reset all previously set options, create a new {@code T} object instead
+   * of using this method.
+   *
+   * <p>The options that will be set to values in the returned {@code T} object is the intersection
+   * of the set of options in this {@code T} object and the given {@code T} object that were
+   * explicitly set. If the values of any of the options conflict, the values in the returned {@code
+   * T} object will be set to those in the given {@code T} object.
+   */
+  @NonNull
+  @CheckResult
+  public T apply(@NonNull BaseRequestOptions<?> o) {
+    if (isAutoCloneEnabled) {
+      return clone().apply(o);
+    }
+    BaseRequestOptions<?> other = o;
+
+    if (isSet(other.fields, SIZE_MULTIPLIER)) {
+      sizeMultiplier = other.sizeMultiplier;
+    }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
+    if (isSet(other.fields, USE_ANIMATION_POOL)) {
+      useAnimationPool = other.useAnimationPool;
+    }
+    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
+      diskCacheStrategy = other.diskCacheStrategy;
+    }
+    if (isSet(other.fields, PRIORITY)) {
+      priority = other.priority;
+    }
+    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
+      errorPlaceholder = other.errorPlaceholder;
+      errorId = 0;
+      fields &= ~ERROR_ID;
+    }
+    if (isSet(other.fields, ERROR_ID)) {
+      errorId = other.errorId;
+      errorPlaceholder = null;
+      fields &= ~ERROR_PLACEHOLDER;
+    }
+    if (isSet(other.fields, PLACEHOLDER)) {
+      placeholderDrawable = other.placeholderDrawable;
+      placeholderId = 0;
+      fields &= ~PLACEHOLDER_ID;
+    }
+    if (isSet(other.fields, PLACEHOLDER_ID)) {
+      placeholderId = other.placeholderId;
+      placeholderDrawable = null;
+      fields &= ~PLACEHOLDER;
+    }
+    if (isSet(other.fields, IS_CACHEABLE)) {
+      isCacheable = other.isCacheable;
+    }
+    if (isSet(other.fields, OVERRIDE)) {
+      overrideWidth = other.overrideWidth;
+      overrideHeight = other.overrideHeight;
+    }
+    if (isSet(other.fields, SIGNATURE)) {
+      signature = other.signature;
+    }
+    if (isSet(other.fields, RESOURCE_CLASS)) {
+      resourceClass = other.resourceClass;
+    }
+    if (isSet(other.fields, FALLBACK)) {
+      fallbackDrawable = other.fallbackDrawable;
+      fallbackId = 0;
+      fields &= ~FALLBACK_ID;
+    }
+    if (isSet(other.fields, FALLBACK_ID)) {
+      fallbackId = other.fallbackId;
+      fallbackDrawable = null;
+      fields &= ~FALLBACK;
+    }
+    if (isSet(other.fields, THEME)) {
+      theme = other.theme;
+    }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+      isScaleOnlyOrNoTransform = other.isScaleOnlyOrNoTransform;
+    }
+    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
+      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+      isScaleOnlyOrNoTransform = true;
+    }
+
+    fields |= other.fields;
+    options.putAll(other.options);
+
+    return selfOrThrowIfLocked();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof BaseRequestOptions<?>) {
+      BaseRequestOptions<?> other = (BaseRequestOptions<?>) o;
+      return Float.compare(other.sizeMultiplier, sizeMultiplier) == 0
+          && errorId == other.errorId
+          && Util.bothNullOrEqual(errorPlaceholder, other.errorPlaceholder)
+          && placeholderId == other.placeholderId
+          && Util.bothNullOrEqual(placeholderDrawable, other.placeholderDrawable)
+          && fallbackId == other.fallbackId
+          && Util.bothNullOrEqual(fallbackDrawable, other.fallbackDrawable)
+          && isCacheable == other.isCacheable
+          && overrideHeight == other.overrideHeight
+          && overrideWidth == other.overrideWidth
+          && isTransformationRequired == other.isTransformationRequired
+          && isTransformationAllowed == other.isTransformationAllowed
+          && useUnlimitedSourceGeneratorsPool == other.useUnlimitedSourceGeneratorsPool
+          && onlyRetrieveFromCache == other.onlyRetrieveFromCache
+          && diskCacheStrategy.equals(other.diskCacheStrategy)
+          && priority == other.priority
+          && options.equals(other.options)
+          && transformations.equals(other.transformations)
+          && resourceClass.equals(other.resourceClass)
+          && Util.bothNullOrEqual(signature, other.signature)
+          && Util.bothNullOrEqual(theme, other.theme);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hashCode = Util.hashCode(sizeMultiplier);
+    hashCode = Util.hashCode(errorId, hashCode);
+    hashCode = Util.hashCode(errorPlaceholder, hashCode);
+    hashCode = Util.hashCode(placeholderId, hashCode);
+    hashCode = Util.hashCode(placeholderDrawable, hashCode);
+    hashCode = Util.hashCode(fallbackId, hashCode);
+    hashCode = Util.hashCode(fallbackDrawable, hashCode);
+    hashCode = Util.hashCode(isCacheable, hashCode);
+    hashCode = Util.hashCode(overrideHeight, hashCode);
+    hashCode = Util.hashCode(overrideWidth, hashCode);
+    hashCode = Util.hashCode(isTransformationRequired, hashCode);
+    hashCode = Util.hashCode(isTransformationAllowed, hashCode);
+    hashCode = Util.hashCode(useUnlimitedSourceGeneratorsPool, hashCode);
+    hashCode = Util.hashCode(onlyRetrieveFromCache, hashCode);
+    hashCode = Util.hashCode(diskCacheStrategy, hashCode);
+    hashCode = Util.hashCode(priority, hashCode);
+    hashCode = Util.hashCode(options, hashCode);
+    hashCode = Util.hashCode(transformations, hashCode);
+    hashCode = Util.hashCode(resourceClass, hashCode);
+    hashCode = Util.hashCode(signature, hashCode);
+    hashCode = Util.hashCode(theme, hashCode);
+    return hashCode;
+  }
+
+  /**
+   * Throws if any further mutations are attempted.
+   *
+   * <p>Once locked, the only way to unlock is to use {@link #clone()}
+   */
+  @NonNull
+  @SuppressWarnings("unchecked")
+  public T lock() {
+    isLocked = true;
+    // This is the only place we should not check locked.
+    return self();
+  }
+
+  /**
+   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
+   * before the mutation resulting in all methods returning a new Object and leaving the original
+   * locked object unmodified.
+   *
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects are
+   * mutable and are not locked.
+   */
+  @NonNull
+  public T autoClone() {
+    if (isLocked && !isAutoCloneEnabled) {
+      throw new IllegalStateException(
+          "You cannot auto lock an already locked options object" + ", try clone() first");
+    }
+    isAutoCloneEnabled = true;
+    return lock();
+  }
+
+  @NonNull
+  @SuppressWarnings("unchecked")
+  private T selfOrThrowIfLocked() {
+    if (isLocked) {
+      throw new IllegalStateException("You cannot modify locked T, consider clone()");
+    }
+    return self();
+  }
+
+  protected boolean isAutoCloneEnabled() {
+    return isAutoCloneEnabled;
+  }
+
+  public final boolean isDiskCacheStrategySet() {
+    return isSet(DISK_CACHE_STRATEGY);
+  }
+
+  public final boolean isSkipMemoryCacheSet() {
+    return isSet(IS_CACHEABLE);
+  }
+
+  @NonNull
+  public final Map<Class<?>, Transformation<?>> getTransformations() {
+    return transformations;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final boolean isTransformationRequired() {
+    return isTransformationRequired;
+  }
+
+  @NonNull
+  public final Options getOptions() {
+    return options;
+  }
+
+  @NonNull
+  public final Class<?> getResourceClass() {
+    return resourceClass;
+  }
+
+  @NonNull
+  public final DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getErrorPlaceholder() {
+    return errorPlaceholder;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getErrorId() {
+    return errorId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getPlaceholderId() {
+    return placeholderId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getPlaceholderDrawable() {
+    return placeholderDrawable;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getFallbackId() {
+    return fallbackId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getFallbackDrawable() {
+    return fallbackDrawable;
+  }
+
+  @Nullable
+  public final Resources.Theme getTheme() {
+    return theme;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final boolean isMemoryCacheable() {
+    return isCacheable;
+  }
+
+  @NonNull
+  public final Key getSignature() {
+    return signature;
+  }
+
+  public final boolean isPrioritySet() {
+    return isSet(PRIORITY);
+  }
+
+  @NonNull
+  public final Priority getPriority() {
+    return priority;
+  }
+
+  public final int getOverrideWidth() {
+    return overrideWidth;
+  }
+
+  public final boolean isValidOverride() {
+    return Util.isValidDimensions(overrideWidth, overrideHeight);
+  }
+
+  public final int getOverrideHeight() {
+    return overrideHeight;
+  }
+
+  public final float getSizeMultiplier() {
+    return sizeMultiplier;
+  }
+
+  boolean isScaleOnlyOrNoTransform() {
+    return isScaleOnlyOrNoTransform;
+  }
+
+  private boolean isSet(int flag) {
+    return isSet(fields, flag);
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getUseAnimationPool() {
+    return useAnimationPool;
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getOnlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
+
+  @SuppressWarnings("unchecked")
+  private T self() {
+    return (T) this;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
index e1037656b..648c2efc3 100644
--- a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -1,18 +1,19 @@
 package com.bumptech.glide.request;
 
+import androidx.annotation.Nullable;
+
 /**
  * Runs a single primary {@link Request} until it completes and then a fallback error request only
  * if the single primary request fails.
  */
-public final class ErrorRequestCoordinator implements RequestCoordinator,
-    Request {
+public final class ErrorRequestCoordinator implements RequestCoordinator, Request {
 
-  private final RequestCoordinator coordinator;
+  @Nullable private final RequestCoordinator parent;
   private Request primary;
   private Request error;
 
-  public ErrorRequestCoordinator(RequestCoordinator coordinator) {
-    this.coordinator = coordinator;
+  public ErrorRequestCoordinator(@Nullable RequestCoordinator parent) {
+    this.parent = parent;
   }
 
   public void setRequests(Request primary, Request error) {
@@ -27,30 +28,16 @@ public void begin() {
     }
   }
 
-  @Override
-  public void pause() {
-    if (!primary.isFailed()) {
-      primary.pause();
-    }
-    if (error.isRunning()) {
-      error.pause();
-    }
-  }
-
   @Override
   public void clear() {
-    if (primary.isFailed()) {
+    primary.clear();
+    // Don't check primary.isFailed() here because it will have been reset by the clear call
+    // immediately before this.
+    if (error.isRunning()) {
       error.clear();
-    } else {
-      primary.clear();
     }
   }
 
-  @Override
-  public boolean isPaused() {
-    return primary.isFailed() ? error.isPaused() : primary.isPaused();
-  }
-
   @Override
   public boolean isRunning() {
     return primary.isFailed() ? error.isRunning() : primary.isRunning();
@@ -67,8 +54,8 @@ public boolean isResourceSet() {
   }
 
   @Override
-  public boolean isCancelled() {
-    return primary.isFailed() ? error.isCancelled() : primary.isCancelled();
+  public boolean isCleared() {
+    return primary.isFailed() ? error.isCleared() : primary.isCleared();
   }
 
   @Override
@@ -97,7 +84,7 @@ public boolean canSetImage(Request request) {
   }
 
   private boolean parentCanSetImage() {
-    return coordinator == null || coordinator.canSetImage(this);
+    return parent == null || parent.canSetImage(this);
   }
 
   @Override
@@ -105,8 +92,17 @@ public boolean canNotifyStatusChanged(Request request) {
     return parentCanNotifyStatusChanged() && isValidRequest(request);
   }
 
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && isValidRequest(request);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return parent == null || parent.canNotifyCleared(this);
+  }
+
   private boolean parentCanNotifyStatusChanged() {
-    return coordinator == null || coordinator.canNotifyStatusChanged(this);
+    return parent == null || parent.canNotifyStatusChanged(this);
   }
 
   private boolean isValidRequest(Request request) {
@@ -119,13 +115,13 @@ public boolean isAnyResourceSet() {
   }
 
   private boolean parentIsAnyResourceSet() {
-    return coordinator != null && coordinator.isAnyResourceSet();
+    return parent != null && parent.isAnyResourceSet();
   }
 
   @Override
   public void onRequestSuccess(Request request) {
-    if (coordinator != null) {
-      coordinator.onRequestSuccess(this);
+    if (parent != null) {
+      parent.onRequestSuccess(this);
     }
   }
 
@@ -138,8 +134,8 @@ public void onRequestFailed(Request request) {
       return;
     }
 
-    if (coordinator != null) {
-      coordinator.onRequestFailed(error);
+    if (parent != null) {
+      parent.onRequestFailed(this);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
index 063b96dd8..ace71ad6a 100644
--- a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
@@ -6,8 +6,8 @@
 /**
  * An interface for an object that is both a {@link com.bumptech.glide.request.target.Target} and a
  * {@link java.util.concurrent.Future}. For example:
- * <pre>
- * {@code
+ *
+ * <pre>{@code
  * FutureTarget<Bitmap> futureTarget = Glide.with(fragment)
  *                                       .load("http://goo.gl/1asf12")
  *                                       .asBitmap()
@@ -15,13 +15,11 @@
  * Bitmap myBitmap = futureTarget.get();
  * ... // do things with bitmap and then release when finished:
  * futureTarget.cancel(false);
- * }
- * </pre>
+ * }</pre>
  *
- * <p> Note - {@link #get()} and {@link #get(long, java.util.concurrent.TimeUnit)} must be called
- * off of the main thread or they will block forever. </p>
+ * <p>Note - {@link #get()} and {@link #get(long, java.util.concurrent.TimeUnit)} must be called off
+ * of the main thread or they will block forever.
  *
  * @param <R> The type of resource this FutureTarget will retrieve.
  */
-public interface FutureTarget<R> extends Future<R>, Target<R> {
-}
+public interface FutureTarget<R> extends Future<R>, Target<R> {}
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index ad89792fb..ac08ed719 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -1,20 +1,11 @@
 package com.bumptech.glide.request;
 
-/**
- * A request that loads a resource for an {@link com.bumptech.glide.request.target.Target}.
- */
+/** A request that loads a resource for an {@link com.bumptech.glide.request.target.Target}. */
 public interface Request {
 
-  /**
-   * Starts an asynchronous load.
-   */
+  /** Starts an asynchronous load. */
   void begin();
 
-  /**
-   * Identical to {@link #clear()} except that the request may later be restarted.
-   */
-  void pause();
-
   /**
    * Prevents any bitmaps being loaded from previous requests, releases any resources held by this
    * request, displays the current placeholder if one was provided, and marks the request as having
@@ -22,19 +13,10 @@
    */
   void clear();
 
-  /**
-   * Returns true if this request is paused and may be restarted.
-   */
-  boolean isPaused();
-
-  /**
-   * Returns true if this request is running and has not completed or failed.
-   */
+  /** Returns true if this request is running and has not completed or failed. */
   boolean isRunning();
 
-  /**
-   * Returns true if the request has completed successfully.
-   */
+  /** Returns true if the request has completed successfully. */
   boolean isComplete();
 
   /**
@@ -43,19 +25,13 @@
    */
   boolean isResourceSet();
 
-  /**
-   * Returns true if the request has been cancelled.
-   */
-  boolean isCancelled();
+  /** Returns true if the request has been cleared. */
+  boolean isCleared();
 
-  /**
-   * Returns true if the request has failed.
-   */
+  /** Returns true if the request has failed. */
   boolean isFailed();
 
-  /**
-   * Recycles the request object and releases its resources.
-   */
+  /** Recycles the request object and releases its resources. */
   void recycle();
 
   /**
@@ -65,10 +41,10 @@
    * <p>This method is identical to {@link Object#equals(Object)} except that it's specific to
    * {@link Request} subclasses. We do not use {@link Object#equals(Object)} directly because we
    * track {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate
-   * to have two different {@link Request} objects for two different
-   * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different
-   * method let's us selectively compare {@link Request} objects to each other when it's useful in
-   * specific scenarios.
+   * to have two different {@link Request} objects for two different {@link
+   * com.bumptech.glide.request.target.Target}s (for example). Using a similar but different method
+   * let's us selectively compare {@link Request} objects to each other when it's useful in specific
+   * scenarios.
    */
   boolean isEquivalentTo(Request other);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
index 36f3915e9..8a13b53f9 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
@@ -20,6 +20,12 @@
    */
   boolean canNotifyStatusChanged(Request request);
 
+  /**
+   * Returns {@code true} if the {@link Request} can clear the {@link
+   * com.bumptech.glide.request.target.Target}.
+   */
+  boolean canNotifyCleared(Request request);
+
   /**
    * Returns true if any coordinated {@link Request} has successfully completed.
    *
@@ -27,9 +33,7 @@
    */
   boolean isAnyResourceSet();
 
-  /**
-   * Must be called when a {@link Request} coordinated by this object completes successfully.
-   */
+  /** Must be called when a {@link Request} coordinated by this object completes successfully. */
   void onRequestSuccess(Request request);
 
   /** Must be called when a {@link Request} coordinated by this object fails. */
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 7bc94ab03..dcdb60d8b 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -1,16 +1,15 @@
 package com.bumptech.glide.request;
 
 import android.graphics.drawable.Drawable;
-import android.os.Handler;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
-import java.io.PrintStream;
-import java.io.PrintWriter;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -20,43 +19,38 @@
  * A {@link java.util.concurrent.Future} implementation for Glide that can be used to load resources
  * in a blocking manner on background threads.
  *
- * <p> Note - Unlike most targets, RequestFutureTargets can be used once and only once. Attempting
- * to reuse a RequestFutureTarget will probably result in undesirable behavior or exceptions.
- * Instead of reusing objects of this class, the pattern should be:
+ * <p>Note - Unlike most targets, RequestFutureTargets can be used once and only once. Attempting to
+ * reuse a RequestFutureTarget will probably result in undesirable behavior or exceptions. Instead
+ * of reusing objects of this class, the pattern should be:
  *
- * <pre>
- *     {@code
- *      FutureTarget<File> target = null;
- *      RequestManager requestManager = Glide.with(context);
- *      try {
- *        target = requestManager
- *           .downloadOnly()
- *           .load(model)
- *           .submit();
- *        File downloadedFile = target.get();
- *        // ... do something with the file (usually throws IOException)
- *      } catch (ExecutionException | InterruptedException | IOException e) {
- *        // ... bug reporting or recovery
- *      } finally {
- *        // make sure to cancel pending operations and free resources
- *        if (target != null) {
- *          target.cancel(true); // mayInterruptIfRunning
- *        }
- *      }
- *     }
- *     </pre>
- * The {@link #cancel(boolean)} call will cancel pending operations and
- * make sure that any resources used are recycled.
- * </p>
+ * <pre>{@code
+ * FutureTarget<File> target = null;
+ * RequestManager requestManager = Glide.with(context);
+ * try {
+ *   target = requestManager
+ *      .downloadOnly()
+ *      .load(model)
+ *      .submit();
+ *   File downloadedFile = target.get();
+ *   // ... do something with the file (usually throws IOException)
+ * } catch (ExecutionException | InterruptedException | IOException e) {
+ *   // ... bug reporting or recovery
+ * } finally {
+ *   // make sure to cancel pending operations and free resources
+ *   if (target != null) {
+ *     target.cancel(true); // mayInterruptIfRunning
+ *   }
+ * }
+ * }</pre>
+ *
+ * The {@link #cancel(boolean)} call will cancel pending operations and make sure that any resources
+ * used are recycled.
  *
  * @param <R> The type of the resource that will be loaded.
  */
-public class RequestFutureTarget<R> implements FutureTarget<R>,
-    RequestListener<R>,
-    Runnable {
+public class RequestFutureTarget<R> implements FutureTarget<R>, RequestListener<R> {
   private static final Waiter DEFAULT_WAITER = new Waiter();
 
-  private final Handler mainHandler;
   private final int width;
   private final int height;
   // Exists for testing only.
@@ -70,16 +64,12 @@
   private boolean loadFailed;
   @Nullable private GlideException exception;
 
-  /**
-   * Constructor for a RequestFutureTarget. Should not be used directly.
-   */
-  public RequestFutureTarget(Handler mainHandler, int width, int height) {
-    this(mainHandler, width, height, true, DEFAULT_WAITER);
+  /** Constructor for a RequestFutureTarget. Should not be used directly. */
+  public RequestFutureTarget(int width, int height) {
+    this(width, height, true, DEFAULT_WAITER);
   }
 
-  RequestFutureTarget(Handler mainHandler, int width, int height, boolean assertBackgroundThread,
-      Waiter waiter) {
-    this.mainHandler = mainHandler;
+  RequestFutureTarget(int width, int height, boolean assertBackgroundThread, Waiter waiter) {
     this.width = width;
     this.height = height;
     this.assertBackgroundThread = assertBackgroundThread;
@@ -93,8 +83,9 @@ public synchronized boolean cancel(boolean mayInterruptIfRunning) {
     }
     isCancelled = true;
     waiter.notifyAll(this);
-    if (mayInterruptIfRunning) {
-      clearOnMainThread();
+    if (mayInterruptIfRunning && request != null) {
+      request.clear();
+      request = null;
     }
     return true;
   }
@@ -119,64 +110,55 @@ public R get() throws InterruptedException, ExecutionException {
   }
 
   @Override
-  public R get(long time, TimeUnit timeUnit)
+  public R get(long time, @NonNull TimeUnit timeUnit)
       throws InterruptedException, ExecutionException, TimeoutException {
     return doGet(timeUnit.toMillis(time));
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
-  public void getSize(SizeReadyCallback cb) {
+  public void getSize(@NonNull SizeReadyCallback cb) {
     cb.onSizeReady(width, height);
   }
 
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     // Do nothing because we do not retain references to SizeReadyCallbacks.
   }
 
   @Override
-  public void setRequest(@Nullable Request request) {
+  public synchronized void setRequest(@Nullable Request request) {
     this.request = request;
   }
 
   @Override
   @Nullable
-  public Request getRequest() {
+  public synchronized Request getRequest() {
     return request;
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
-  public void onLoadStarted(Drawable placeholder) {
+  public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
-  public synchronized void onLoadFailed(Drawable errorDrawable) {
+  public synchronized void onLoadFailed(@Nullable Drawable errorDrawable) {
     // Ignored, synchronized for backwards compatibility.
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
-  public synchronized void onResourceReady(R resource, Transition<? super R> transition) {
+  public synchronized void onResourceReady(
+      @NonNull R resource, @Nullable Transition<? super R> transition) {
     // Ignored, synchronized for backwards compatibility.
   }
 
@@ -197,13 +179,18 @@ private synchronized R doGet(Long timeoutMillis)
     if (timeoutMillis == null) {
       waiter.waitForTimeout(this, 0);
     } else if (timeoutMillis > 0) {
-      waiter.waitForTimeout(this, timeoutMillis);
+      long now = System.currentTimeMillis();
+      long deadline = now + timeoutMillis;
+      while (!isDone() && now < deadline) {
+        waiter.waitForTimeout(this, deadline - now);
+        now = System.currentTimeMillis();
+      }
     }
 
     if (Thread.interrupted()) {
       throw new InterruptedException();
     } else if (loadFailed) {
-      throw new GlideExecutionException(exception);
+      throw new ExecutionException(exception);
     } else if (isCancelled) {
       throw new CancellationException();
     } else if (!resultReceived) {
@@ -213,21 +200,6 @@ private synchronized R doGet(Long timeoutMillis)
     return resource;
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
-  @Override
-  public void run() {
-    if (request != null) {
-      request.clear();
-      request = null;
-    }
-  }
-
-  private void clearOnMainThread() {
-    mainHandler.post(this);
-  }
-
   @Override
   public void onStart() {
     // Do nothing.
@@ -262,44 +234,17 @@ public synchronized boolean onResourceReady(
     return false;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Waiter {
-
-    public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
+    // This is a simple wrapper class that is used to enable testing. The call to the wrapping class
+    // is waited on appropriately.
+    @SuppressWarnings("WaitNotInLoop")
+    void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
       toWaitOn.wait(timeoutMillis);
     }
 
-    public void notifyAll(Object toNotify) {
+    void notifyAll(Object toNotify) {
       toNotify.notifyAll();
     }
   }
-
-  private static class GlideExecutionException extends ExecutionException {
-
-    private final GlideException cause;
-
-    GlideExecutionException(GlideException cause) {
-      super();
-      this.cause = cause;
-    }
-
-    @Override
-    public void printStackTrace() {
-      printStackTrace(System.err);
-    }
-
-    @Override
-    public void printStackTrace(PrintStream s) {
-      super.printStackTrace(s);
-      s.print("Caused by: ");
-      cause.printStackTrace(s);
-    }
-
-    @Override
-    public void printStackTrace(PrintWriter s) {
-      super.printStackTrace(s);
-      s.print("Caused by: ");
-      cause.printStackTrace(s);
-    }
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index a6156b495..8eb955dda 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.request;
 
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
+import android.widget.ImageView;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.Target;
@@ -9,59 +11,74 @@
 /**
  * A class for monitoring the status of a request while images load.
  *
+ * <p>All methods in this interface will be called from a background thread if the {@code
+ * RequestListener} is added to a request that is started with {@link RequestBuilder#submit()},
+ * {@link RequestBuilder#submit(int, int)}, or {@link RequestBuilder#into(int, int)}. Those methods
+ * no longer post results back to the main thread to avoid the unnecessary thread interactions and
+ * corresponding latency. As a side affect though, listeners added to those requests are no longer
+ * called on the main thread. {@code RequestListeners} added to requests started with {@link
+ * RequestBuilder#into(Target)} or {@link RequestBuilder#into(ImageView)} will continue to be called
+ * back on the main thread.
+ *
  * @param <R> The type of resource being loaded.
  */
 public interface RequestListener<R> {
 
   /**
-   * Called when an exception occurs during a load, immediately before
-   * {@link Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an
-   * image for the given model in the given target. It is recommended to create a single instance
-   * per activity/fragment rather than instantiate a new object for each call to {@code
-   * Glide.load()} to avoid object churn.
+   * Called when an exception occurs during a load, immediately before {@link
+   * Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an image
+   * for the given model in the given target. It is recommended to create a single instance per
+   * activity/fragment rather than instantiate a new object for each call to {@code
+   * Glide.with(fragment/activity).load()} to avoid object churn.
+   *
+   * <p>It is not safe to reload this or a different model in this callback. If you need to do so
+   * use {@link com.bumptech.glide.RequestBuilder#error(RequestBuilder)} instead.
+   *
+   * <p>Although you can't start an entirely new load, it is safe to change what is displayed in the
+   * {@link Target} at this point, as long as you return {@code true} from the method to prevent
+   * {@link Target#onLoadFailed(Drawable)} from being called.
+   *
+   * <p>For threading guarantees, see the class comment.
    *
-   * <p> It is safe to reload this or a different model or change what is displayed in the target at
-   * this point. For example:
-   * <pre>
-   * {@code
-   * public void onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
+   * <p>For example:
+   *
+   * <pre>{@code
+   * public boolean onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
    *     target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
-   *     Glide.load(model).into(target);
-   * }
+   *     return true; // Prevent onLoadFailed from being called on the Target.
    * }
-   * </pre>
-   * </p>
+   * }</pre>
    *
-   * <p> Note - if you want to reload this or any other model after an exception, you will need to
-   * include all relevant builder calls (like centerCrop, placeholder etc).
-   *
-   * @param e               The maybe {@code null} exception containing information about why the
-   *                        request failed.
-   * @param model           The model we were trying to load when the exception occurred.
-   * @param target          The {@link Target} we were trying to load the image into.
+   * @param e The maybe {@code null} exception containing information about why the request failed.
+   * @param model The model we were trying to load when the exception occurred.
+   * @param target The {@link Target} we were trying to load the image into.
    * @param isFirstResource {@code true} if this exception is for the first resource to load.
-   * @return {@code true} if the listener has handled updating the target for the given exception,
-   *         {@code false} to allow Glide's request to update the target.
+   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
+   *     {@code target}, typically because the listener wants to update the {@code target} or the
+   *     object the {@code target} wraps itself or {@code false} to allow {@link
+   *     Target#onLoadFailed(Drawable)} to be called on {@code target}.
    */
-  boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
-      boolean isFirstResource);
+  boolean onLoadFailed(
+      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource);
 
   /**
    * Called when a load completes successfully, immediately before {@link
    * Target#onResourceReady(Object, com.bumptech.glide.request.transition.Transition)}.
    *
-   * @param resource          The resource that was loaded for the target.
-   * @param model             The specific model that was used to load the image.
-   * @param target            The target the model was loaded into.
-   * @param dataSource        The {@link DataSource} the resource was loaded from.
-   * @param isFirstResource   {@code true} if this is the first resource to in this load to be
-   *                          loaded into the target. For example when loading a thumbnail and a
-   *                          full-sized image, this will be {@code true} for the first image to
-   *                          load and {@code false} for the second.
-   * @return {@code true} if the listener has handled setting the resource on the target,
-   *         {@code false} to allow Glide's request to update the target.
-   *         Setting the resource includes handling animations, be sure to take that into account.
+   * <p>For threading guarantees, see the class comment.
+   *
+   * @param resource The resource that was loaded for the target.
+   * @param model The specific model that was used to load the image.
+   * @param target The target the model was loaded into.
+   * @param dataSource The {@link DataSource} the resource was loaded from.
+   * @param isFirstResource {@code true} if this is the first resource to in this load to be loaded
+   *     into the target. For example when loading a thumbnail and a full-sized image, this will be
+   *     {@code true} for the first image to load and {@code false} for the second.
+   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
+   *     {@code target}, typically because the listener wants to update the {@code target} or the
+   *     object the {@code target} wraps itself or {@code false} to allow {@link
+   *     Target#onLoadFailed(Drawable)} to be called on {@code target}.
    */
-  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,
-      boolean isFirstResource);
+  boolean onResourceReady(
+      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index cf322bcdb..c2a1882a8 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1,127 +1,42 @@
 package com.bumptech.glide.request;
 
-import android.content.res.Resources;
 import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.CheckResult;
-import android.support.annotation.DrawableRes;
-import android.support.annotation.FloatRange;
-import android.support.annotation.IntRange;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.CheckResult;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.FloatRange;
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.MultiTransformation;
 import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
-import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.CenterInside;
-import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
-import com.bumptech.glide.load.resource.bitmap.Downsampler;
-import com.bumptech.glide.load.resource.bitmap.DrawableTransformation;
-import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.gif.GifOptions;
-import com.bumptech.glide.signature.EmptySignature;
-import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
  * Provides type independent options to customize loads with Glide.
+ *
+ * <p>Non-final to allow Glide's generated classes to be assignable to their non-generated
+ * equivalents.
  */
-@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
-public class RequestOptions implements Cloneable {
-  private static final int UNSET = -1;
-  private static final int SIZE_MULTIPLIER = 1 << 1;
-  private static final int DISK_CACHE_STRATEGY = 1 << 2;
-  private static final int PRIORITY = 1 << 3;
-  private static final int ERROR_PLACEHOLDER = 1 << 4;
-  private static final int ERROR_ID = 1 << 5;
-  private static final int PLACEHOLDER = 1 << 6;
-  private static final int PLACEHOLDER_ID = 1 << 7;
-  private static final int IS_CACHEABLE = 1 << 8;
-  private static final int OVERRIDE = 1 << 9;
-  private static final int SIGNATURE = 1 << 10;
-  private static final int TRANSFORMATION = 1 << 11;
-  private static final int RESOURCE_CLASS = 1 << 12;
-  private static final int FALLBACK = 1 << 13;
-  private static final int FALLBACK_ID = 1 << 14;
-  private static final int THEME = 1 << 15;
-  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
-  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
-  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
-  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
-  private static final int USE_ANIMATION_POOL = 1 << 20;
-
-  @Nullable
-  private static RequestOptions skipMemoryCacheTrueOptions;
-  @Nullable
-  private static RequestOptions skipMemoryCacheFalseOptions;
-  @Nullable
-  private static RequestOptions fitCenterOptions;
-  @Nullable
-  private static RequestOptions centerInsideOptions;
-  @Nullable
-  private static RequestOptions centerCropOptions;
-  @Nullable
-  private static RequestOptions circleCropOptions;
-  @Nullable
-  private static RequestOptions noTransformOptions;
-  @Nullable
-  private static RequestOptions noAnimationOptions;
-
-  private int fields;
-  private float sizeMultiplier = 1f;
-  @NonNull
-  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
-  @NonNull
-  private Priority priority = Priority.NORMAL;
-  @Nullable
-  private Drawable errorPlaceholder;
-  private int errorId;
-  @Nullable
-  private Drawable placeholderDrawable;
-  private int placeholderId;
-  private boolean isCacheable = true;
-  private int overrideHeight = RequestOptions.UNSET;
-  private int overrideWidth = RequestOptions.UNSET;
-  @NonNull
-  private Key signature = EmptySignature.obtain();
-  private boolean isTransformationRequired;
-  private boolean isTransformationAllowed = true;
-  @Nullable
-  private Drawable fallbackDrawable;
-  private int fallbackId;
-  @NonNull
-  private Options options = new Options();
-  @NonNull
-  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-  @NonNull
-  private Class<?> resourceClass = Object.class;
-  private boolean isLocked;
-  @Nullable
-  private Resources.Theme theme;
-  private boolean isAutoCloneEnabled;
-  private boolean useUnlimitedSourceGeneratorsPool;
-  private boolean onlyRetrieveFromCache;
-  private boolean isScaleOnlyOrNoTransform = true;
-  private boolean useAnimationPool;
-
-  /**
-   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
-   */
+@SuppressWarnings("PMD.UseUtilityClass")
+public class RequestOptions extends BaseRequestOptions<RequestOptions> {
+
+  @Nullable private static RequestOptions skipMemoryCacheTrueOptions;
+  @Nullable private static RequestOptions skipMemoryCacheFalseOptions;
+  @Nullable private static RequestOptions fitCenterOptions;
+  @Nullable private static RequestOptions centerInsideOptions;
+  @Nullable private static RequestOptions centerCropOptions;
+  @Nullable private static RequestOptions circleCropOptions;
+  @Nullable private static RequestOptions noTransformOptions;
+  @Nullable private static RequestOptions noAnimationOptions;
+
+  /** Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions sizeMultiplierOf(
       @FloatRange(from = 0, to = 1) float sizeMultiplier) {
@@ -131,55 +46,53 @@ public static RequestOptions sizeMultiplierOf(
   /**
    * Returns a {@link RequestOptions} object with {@link #diskCacheStrategy(DiskCacheStrategy)} set.
    */
+  @NonNull
   @CheckResult
   public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {
     return new RequestOptions().diskCacheStrategy(diskCacheStrategy);
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #priority(Priority)}} set.
+   * Returns a {@link RequestOptions} object with {@link BaseRequestOptions#priority(Priority)}}
+   * set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions priorityOf(@NonNull Priority priority) {
     return new RequestOptions().priority(priority);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
     return new RequestOptions().placeholder(placeholder);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #placeholder(int)} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions placeholderOf(@DrawableRes int placeholderId) {
     return new RequestOptions().placeholder(placeholderId);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #error(Drawable)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #error(Drawable)} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
     return new RequestOptions().error(errorDrawable);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #error(int)}} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions errorOf(@DrawableRes int errorId) {
     return new RequestOptions().error(errorId);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     if (skipMemoryCache) {
@@ -195,14 +108,11 @@ public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     }
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #override(int, int)}} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #override(int, int)}} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
-  public static RequestOptions overrideOf(
-      @IntRange(from = 0) int width,
-      @IntRange(from = 0) int height) {
+  public static RequestOptions overrideOf(int width, int height) {
     return new RequestOptions().override(width, height);
   }
 
@@ -211,154 +121,135 @@ public static RequestOptions overrideOf(
    * height are the given size.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
-  public static RequestOptions overrideOf(@IntRange(from = 0) int size) {
+  public static RequestOptions overrideOf(int size) {
     return overrideOf(size, size);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #signature} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #signature} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions signatureOf(@NonNull Key signature) {
     return new RequestOptions().signature(signature);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #fitCenter()} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions fitCenterTransform() {
     if (fitCenterOptions == null) {
-      fitCenterOptions = new RequestOptions()
-          .fitCenter()
-          .autoClone();
+      fitCenterOptions = new RequestOptions().fitCenter().autoClone();
     }
     return fitCenterOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #centerInside()} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions centerInsideTransform() {
     if (centerInsideOptions == null) {
-      centerInsideOptions = new RequestOptions()
-              .centerInside()
-              .autoClone();
+      centerInsideOptions = new RequestOptions().centerInside().autoClone();
     }
     return centerInsideOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #centerCrop()} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions centerCropTransform() {
     if (centerCropOptions == null) {
-      centerCropOptions = new RequestOptions()
-          .centerCrop()
-          .autoClone();
+      centerCropOptions = new RequestOptions().centerCrop().autoClone();
     }
     return centerCropOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions circleCropTransform() {
     if (circleCropOptions == null) {
-      circleCropOptions = new RequestOptions()
-          .circleCrop()
-          .autoClone();
+      circleCropOptions = new RequestOptions().circleCrop().autoClone();
     }
     return circleCropOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
     return new RequestOptions().transform(transformation);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #dontTransform()} set. */
   @SuppressWarnings("WeakerAccess")
+  @NonNull
   @CheckResult
   public static RequestOptions noTransformation() {
     if (noTransformOptions == null) {
-      noTransformOptions = new RequestOptions()
-          .dontTransform()
-          .autoClone();
+      noTransformOptions = new RequestOptions().dontTransform().autoClone();
     }
     return noTransformOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with the given {@link Option} set via
-   * {@link #set(Option, Object)}.
+   * Returns a {@link RequestOptions} object with the given {@link Option} set via {@link
+   * #set(Option, Object)}.
    */
+  @NonNull
   @CheckResult
   public static <T> RequestOptions option(@NonNull Option<T> option, @NonNull T value) {
     return new RequestOptions().set(option, value);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #decode(Class)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #decode(Class)} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
     return new RequestOptions().decode(resourceClass);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions formatOf(@NonNull DecodeFormat format) {
     return new RequestOptions().format(format);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #frame(long)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #frame(long)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions frameOf(@IntRange(from = 0) long frameTimeMicros) {
     return new RequestOptions().frame(frameTimeMicros);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
     return new RequestOptions().downsample(strategy);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #timeout(int)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #timeout(int)} set. */
+  @NonNull
   @CheckResult
   public static RequestOptions timeoutOf(@IntRange(from = 0) int timeout) {
     return new RequestOptions().timeout(timeout);
   }
 
   /**
-   * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
-   * #encodeQuality(int)} called with the given quality.
+   * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link #encodeQuality(int)}
+   * called with the given quality.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions encodeQualityOf(@IntRange(from = 0, to = 100) int quality) {
     return new RequestOptions().encodeQuality(quality);
@@ -369,6 +260,7 @@ public static RequestOptions encodeQualityOf(@IntRange(from = 0, to = 100) int q
    * #encodeFormat(android.graphics.Bitmap.CompressFormat)} called with the given format.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
     return new RequestOptions().encodeFormat(format);
@@ -379,1201 +271,12 @@ public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat forma
    * called.
    */
   @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
   @CheckResult
   public static RequestOptions noAnimation() {
     if (noAnimationOptions == null) {
-      noAnimationOptions = new RequestOptions()
-          .dontAnimate()
-          .autoClone();
+      noAnimationOptions = new RequestOptions().dontAnimate().autoClone();
     }
     return noAnimationOptions;
   }
-
-  private static boolean isSet(int fields, int flag) {
-    return (fields & flag) != 0;
-  }
-
-  /**
-   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
-   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
-   * (particularly {@link Bitmap}s on devices with overly dense screens.
-   *
-   * @param sizeMultiplier The multiplier to apply to the
-   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
-   *                       loading the resource.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions sizeMultiplier(@FloatRange(from = 0, to = 1) float sizeMultiplier) {
-    if (isAutoCloneEnabled) {
-      return clone().sizeMultiplier(sizeMultiplier);
-    }
-
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-    }
-    this.sizeMultiplier = sizeMultiplier;
-    fields |= SIZE_MULTIPLIER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * If set to {@code true}, uses a cached unlimited {@link java.util.concurrent.Executor} to run
-   * the request.
-   *
-   * <p>This method should <em>ONLY</em> be used when a Glide load is started recursively on one
-   * of Glide's threads as part of another request. Using this method in other scenarios can lead
-   * to excessive memory usage and OOMs and/or a significant decrease in performance across an
-   * application.
-   *
-   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and
-   * {@link #useAnimationPool(boolean)} are set, {@link #useUnlimitedSourceGeneratorsPool(boolean)}
-   * will be preferred and {@link #useAnimationPool(boolean)} will be ignored.
-   */
-  @CheckResult
-  public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
-    if (isAutoCloneEnabled) {
-      return clone().useUnlimitedSourceGeneratorsPool(flag);
-    }
-
-    this.useUnlimitedSourceGeneratorsPool = flag;
-    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * If set to {@code true}, uses a special {@link java.util.concurrent.Executor} that is used
-   * exclusively for decoding frames of animated resources, like GIFs.
-   *
-   * <p>The animation executor disallows network operations and must not be used for loads that
-   * may load remote data. The animation executor has fewer threads available to it than Glide's
-   * normal executors and is only useful as a way of avoiding blocking on longer and more expensive
-   * reads for critical requests like those in an animating GIF.
-   *
-   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and
-   * {@link #useAnimationPool(boolean)} are set, {@link #useUnlimitedSourceGeneratorsPool(boolean)}
-   * will be preferred and {@link #useAnimationPool(boolean)} will be ignored.
-   */
-  @CheckResult
-  public RequestOptions useAnimationPool(boolean flag) {
-    if (isAutoCloneEnabled) {
-      return clone().useAnimationPool(flag);
-    }
-
-    useAnimationPool = flag;
-    fields |= USE_ANIMATION_POOL;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * If set to true, will only load an item if found in the cache, and will not fetch from source.
-   */
-  @CheckResult
-  public RequestOptions onlyRetrieveFromCache(boolean flag) {
-    if (isAutoCloneEnabled) {
-      return clone().onlyRetrieveFromCache(flag);
-    }
-
-    this.onlyRetrieveFromCache = flag;
-    fields |= ONLY_RETRIEVE_FROM_CACHE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link DiskCacheStrategy} to use for this load.
-   *
-   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
-   *
-   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
-   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
-   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
-   * using {@link DiskCacheStrategy#DATA} or
-   * {@link DiskCacheStrategy#ALL}. </p>
-   *
-   * @param strategy The strategy to use.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
-    if (isAutoCloneEnabled) {
-      return clone().diskCacheStrategy(strategy);
-    }
-    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
-    fields |= DISK_CACHE_STRATEGY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the priority for this load.
-   *
-   * @param priority A priority.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions priority(@NonNull Priority priority) {
-    if (isAutoCloneEnabled) {
-      return clone().priority(priority);
-    }
-
-    this.priority = Preconditions.checkNotNull(priority);
-    fields |= PRIORITY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link Drawable} to display while a resource is loading.
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions placeholder(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(drawable);
-    }
-
-    this.placeholderDrawable = drawable;
-    fields |= PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an Android resource id for a {@link Drawable} resource to
-   * display while a resource is loading.
-   *
-   * @param resourceId The id of the resource to use as a placeholder
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions placeholder(@DrawableRes int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(resourceId);
-    }
-
-    this.placeholderId = resourceId;
-    fields |= PLACEHOLDER_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link Drawable} to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
-   * error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions fallback(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(drawable);
-    }
-
-    this.fallbackDrawable = drawable;
-    fields |= FALLBACK;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
-   * the error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param resourceId The id of the resource to use as a fallback.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions fallback(@DrawableRes int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(resourceId);
-    }
-
-    this.fallbackId = resourceId;
-    fields |= FALLBACK_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a {@link Drawable} to display if a load fails.
-   *
-   * @param drawable The drawable to display.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions error(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().error(drawable);
-    }
-
-    this.errorPlaceholder = drawable;
-    fields |= ERROR_PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if a load fails.
-   *
-   * @param resourceId The id of the resource to use as a placeholder.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions error(@DrawableRes int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().error(resourceId);
-    }
-    this.errorId = resourceId;
-    fields |= ERROR_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
-   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
-   * {@link #fallback(Drawable)}.
-   *
-   * <p>The theme is <em>NOT</em> applied in the decoder that will attempt to decode a given
-   * resource id model on Glide's background threads. The theme is used exclusively on the main
-   * thread to obtain placeholder/error/fallback drawables to avoid leaking Activities.
-   *
-   * <p>If the {@link android.content.Context} of the {@link android.app.Fragment} or
-   * {@link android.app.Activity} used to start this load has a different
-   * {@link android.content.res.Resources.Theme}, the {@link android.content.res.Resources.Theme}
-   * provided here will override the {@link android.content.res.Resources.Theme} of the
-   * {@link android.content.Context}.
-   *
-   * @param theme The theme to use when loading Drawables.
-   * @return this request builder.
-   */
-  @CheckResult
-  public RequestOptions theme(@Nullable Resources.Theme theme) {
-    if (isAutoCloneEnabled) {
-      return clone().theme(theme);
-    }
-
-    this.theme = theme;
-    fields |= THEME;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Allows the loaded resource to skip the memory cache.
-   *
-   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
-   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
-   *
-   * @param skip True to allow the resource to skip the memory cache.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions skipMemoryCache(boolean skip) {
-    if (isAutoCloneEnabled) {
-      return clone().skipMemoryCache(true);
-    }
-
-    this.isCacheable = !skip;
-    fields |= IS_CACHEABLE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given values. This is useful for thumbnails, and should only be used for other cases when you
-   * need a very specific image size.
-   *
-   * @param width  The width in pixels to use to load the resource.
-   * @param height The height in pixels to use to load the resource.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions override(int width, int height) {
-    if (isAutoCloneEnabled) {
-      return clone().override(width, height);
-    }
-
-    this.overrideWidth = width;
-    this.overrideHeight = height;
-    fields |= OVERRIDE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given size.
-   *
-   * @see #override(int, int)
-   * @param size The width and height to use.
-   * @return This request builder.
-   */
-  @CheckResult
-  public RequestOptions override(int size) {
-    return override(size, size);
-  }
-
-  /**
-   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
-   * more control over when cached data is invalidated.
-   *
-   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
-   *
-   * @param signature A unique non-null {@link Key} representing the current
-   *                  state of the model that will be mixed in to the cache key.
-   * @return This request builder.
-   * @see com.bumptech.glide.signature.ObjectKey
-   */
-  @CheckResult
-  public RequestOptions signature(@NonNull Key signature) {
-    if (isAutoCloneEnabled) {
-      return clone().signature(signature);
-    }
-
-    this.signature = Preconditions.checkNotNull(signature);
-    fields |= SIGNATURE;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   *
-   * <p> Even if this object was locked, the cloned object returned from this method will not be
-   * locked. </p>
-   */
-  @SuppressWarnings("unchecked")
-  @CheckResult
-  @Override
-  public RequestOptions clone() {
-    try {
-      RequestOptions result = (RequestOptions) super.clone();
-      result.options = new Options();
-      result.options.putAll(options);
-      result.transformations = new HashMap<>();
-      result.transformations.putAll(transformations);
-      result.isLocked = false;
-      result.isAutoCloneEnabled = false;
-      return result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @CheckResult
-  public <T> RequestOptions set(@NonNull Option<T> option, @NonNull T value) {
-    if (isAutoCloneEnabled) {
-      return clone().set(option, value);
-    }
-
-    Preconditions.checkNotNull(option);
-    Preconditions.checkNotNull(value);
-    options.set(option, value);
-    return selfOrThrowIfLocked();
-  }
-
-  @CheckResult
-  public RequestOptions decode(@NonNull Class<?> resourceClass) {
-    if (isAutoCloneEnabled) {
-      return clone().decode(resourceClass);
-    }
-
-    this.resourceClass = Preconditions.checkNotNull(resourceClass);
-    fields |= RESOURCE_CLASS;
-    return selfOrThrowIfLocked();
-  }
-
-  public final boolean isTransformationAllowed() {
-    return isTransformationAllowed;
-  }
-
-  public final boolean isTransformationSet() {
-    return isSet(TRANSFORMATION);
-  }
-
-  public final boolean isLocked() {
-    return isLocked;
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
-   */
-  @CheckResult
-  public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
-    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the value for key
-   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
-   */
-  @CheckResult
-  public RequestOptions encodeQuality(@IntRange(from = 0, to = 100) int quality) {
-    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
-  }
-
-  /**
-   * Sets the time position of the frame to extract from a video.
-   *
-   * <p>This is a component option specific to {@link VideoBitmapDecoder}. If the default video
-   * decoder is replaced or skipped because of your configuration, this option may be ignored.
-   *
-   * @see VideoBitmapDecoder#TARGET_FRAME
-   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
-   *                        Android framework implementation return a representative frame.
-   */
-  @CheckResult
-  public RequestOptions frame(@IntRange(from = 0) long frameTimeMicros) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
-  }
-
-  /**
-   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
-   * {@link Downsampler} and Glide's default GIF decoders.
-   *
-   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
-   * decoded using a decoder that cannot control the format
-   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
-   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
-   * image has alpha).
-   *
-   * <p>This is a component option specific to {@link Downsampler} and Glide's GIF decoders. If the
-   * default Bitmap decoders are replaced or skipped because of your configuration, this option may
-   * be ignored.
-   *
-   * <p>To set only the format used when decoding {@link Bitmap}s, use
-   * {@link #option(Option, Object)} and {@link Downsampler#DECODE_FORMAT}. To set only the format
-   * used when decoding GIF frames, use {@link #option(Option, Object)} and
-   * {@link GifOptions#DECODE_FORMAT}.
-   *
-   * @see Downsampler#DECODE_FORMAT
-   * @see GifOptions#DECODE_FORMAT
-   */
-  @CheckResult
-  public RequestOptions format(@NonNull DecodeFormat format) {
-    Preconditions.checkNotNull(format);
-    return set(Downsampler.DECODE_FORMAT, format)
-        .set(GifOptions.DECODE_FORMAT, format);
-  }
-
-  /**
-   * Disables the use of {@link android.graphics.Bitmap.Config#HARDWARE} in {@link Downsampler} to
-   * avoid errors caused by inspecting Bitmap pixels, drawing with hardware support disabled,
-   * drawing to {@link android.graphics.Canvas}s backed by {@link Bitmap}s etc.
-   *
-   * <p>It's almost never safe to set {@link Downsampler#ALLOW_HARDWARE_CONFIG} to {@code true} so
-   * we only provide a way to disable hardware configs entirely. If no option is set for
-   * {@link Downsampler#ALLOW_HARDWARE_CONFIG}, Glide will set the value per request based on
-   * whether or not a {@link Transformation} is applied and if one is, the type of
-   * {@link Transformation} applied. Built in transformations like {@link FitCenter} and
-   * {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.CenterOutside} can safely use
-   * {@link android.graphics.Bitmap.Config#HARDWARE} because they can be entirely replaced by
-   * scaling within {@link Downsampler}. {@link Transformation}s like {@link #circleCrop()} that
-   * can't be replicated by {@link Downsampler} cannot use {@link Bitmap.Config#HARDWARE} because
-   * {@link android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to
-   * {@link android.graphics.Canvas}s, which is required by most {@link Transformation}s.
-   */
-  @CheckResult
-  public RequestOptions disallowHardwareConfig() {
-    return set(Downsampler.ALLOW_HARDWARE_CONFIG, false);
-  }
-
-  /**
-   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
-   * {@link Downsampler}.
-   *
-   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
-   * is replaced or skipped because of your configuration, this option may be ignored.
-   */
-  @CheckResult
-  public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
-    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
-  }
-
-  /**
-   * Sets the read and write timeout for the http requests used to load the image.
-   *
-   * <p>This is a component option specific to Glide's default networking library and
-   * {@link com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other
-   * networking library including Glide's Volley or OkHttp integration libraries, this option will
-   * be ignored.
-   *
-   * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT
-   * @param timeoutMs The read and write timeout in milliseconds.
-   */
-  @CheckResult
-  public RequestOptions timeout(@IntRange(from = 0) int timeoutMs) {
-    return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Class, Transformation)
-   * @see #centerCrop()
-   */
-  @CheckResult
-  public RequestOptions optionalCenterCrop() {
-    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
-  }
-
-  /**
-   * Applies {@link CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>this will override previous calls to {@link #dontTransform()} ()}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop()
-   */
-  @CheckResult
-  public RequestOptions centerCrop() {
-    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
-  }
-
-  /**
-   *
-   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
-   * image types, and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
-   * {@link #downsample(DownsampleStrategy)}.
-   *
-   * @see #optionalTransform(Class, Transformation)
-   * @see #fitCenter()
-   */
-  @CheckResult
-  public RequestOptions optionalFitCenter() {
-    return optionalScaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
-  }
-
-  /**
-   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
-   * image types, and throws an exception if asked to transform an unknown
-   * type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
-   * {@link #downsample(DownsampleStrategy)}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalFitCenter()
-   */
-  @CheckResult
-  public RequestOptions fitCenter() {
-    return scaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types,
-   * {@link DownsampleStrategy#CENTER_INSIDE} to image types, and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
-   * {@link #downsample(DownsampleStrategy)}.
-   *
-   * @see #optionalTransform(Class, Transformation)
-   * @see #centerInside()
-   */
-  @CheckResult
-  public RequestOptions optionalCenterInside() {
-    return optionalScaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
-  }
-
-  /**
-   * Applies {@link CenterInside} to all default types, {@link DownsampleStrategy#CENTER_INSIDE} to
-   * image types and throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
-   * {@link #downsample(DownsampleStrategy)}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterInside()
-   */
-  @CheckResult
-  public RequestOptions centerInside() {
-    return scaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Transformation)
-   * @see #circleCrop()
-   */
-  @CheckResult
-  public RequestOptions optionalCircleCrop() {
-    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
-   * an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop()
-   */
-  @CheckResult
-  public RequestOptions circleCrop() {
-    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
-  }
-
-  // calling optionalTransform() on the result of clone() requires greater access.
-  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
-  @SuppressWarnings({"WeakerAccess", "CheckResult"})
-  final RequestOptions optionalTransform(DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return optionalTransform(transformation);
-  }
-
-  // calling transform() on the result of clone() requires greater access.
-  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
-  @SuppressWarnings({"WeakerAccess", "CheckResult"})
-  @CheckResult
-  final RequestOptions transform(DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return transform(transformation);
-  }
-
-  private RequestOptions scaleOnlyTransform(
-      DownsampleStrategy strategy, Transformation<Bitmap> transformation) {
-    return scaleOnlyTransform(strategy, transformation, true /*isTransformationRequired*/);
-  }
-
-  private RequestOptions optionalScaleOnlyTransform(
-      DownsampleStrategy strategy, Transformation<Bitmap> transformation) {
-    return scaleOnlyTransform(strategy, transformation, false /*isTransformationRequired*/);
-  }
-
-  private RequestOptions scaleOnlyTransform(
-      DownsampleStrategy strategy,
-      Transformation<Bitmap> transformation,
-      boolean isTransformationRequired) {
-    RequestOptions result = isTransformationRequired
-          ? transform(strategy, transformation) : optionalTransform(strategy, transformation);
-    result.isScaleOnlyOrNoTransform = true;
-    return result;
-  }
-
-  /**
-   * Applies the given {@link Transformation} for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
-   * @see #optionalTransform(Transformation)
-   * @see #optionalTransform(Class, Transformation)
-   */
-  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
-  @SuppressWarnings("CheckResult")
-  @CheckResult
-  public RequestOptions transform(@NonNull Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(transformation);
-    }
-
-    optionalTransform(transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link Transformation}s in the given order for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
-   * @see #optionalTransform(Transformation)
-   * @see #optionalTransform(Class, Transformation)
-   */
-  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
-  @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
-  @CheckResult
-  public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
-    if (isAutoCloneEnabled) {
-      return clone().transforms(transformations);
-    }
-
-    optionalTransform(new MultiTransformation<>(transformations));
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link Transformation} for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
-   * @see #transform(Transformation)
-   * @see #transform(Class, Transformation)
-   */
-  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
-  @SuppressWarnings("CheckResult")
-  @CheckResult
-  public RequestOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(transformation);
-    }
-
-    DrawableTransformation drawableTransformation = new DrawableTransformation(transformation);
-    optionalTransform(Bitmap.class, transformation);
-    optionalTransform(Drawable.class, drawableTransformation);
-    // TODO: remove BitmapDrawable decoder and this transformation.
-    // Registering as BitmapDrawable is simply an optimization to avoid some iteration and
-    // isAssignableFrom checks when obtaining the transformation later on. It can be removed without
-    // affecting the functionality.
-    optionalTransform(BitmapDrawable.class, drawableTransformation.asBitmapDrawable());
-    optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link Transformation} for any decoded resource of
-   * the given type and allows unknown resource types to be ignored.
-   *
-   * <p> Users can apply different transformations for each resource class. Applying a
-   * {@link Transformation} for a resource type that already has a
-   * {@link Transformation} will override the previous call. </p>
-   *
-   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
-   * an unknown resource class will throw an exception. To allow unknown types, users must always
-   * call the optional version of each method. </p>
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link Transformation} to apply.
-   */
-  @CheckResult
-  public <T> RequestOptions optionalTransform(
-      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(resourceClass, transformation);
-    }
-
-    Preconditions.checkNotNull(resourceClass);
-    Preconditions.checkNotNull(transformation);
-    transformations.put(resourceClass, transformation);
-    fields |= TRANSFORMATION;
-    isTransformationAllowed = true;
-    fields |= TRANSFORMATION_ALLOWED;
-    // Always set to false here. Known scale only transformations will call this method and then
-    // set isScaleOnlyOrNoTransform to true immediately after.
-    isScaleOnlyOrNoTransform = false;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link Transformation} for any decoded resource of
-   * the given type and throws if asked to transform an unknown resource type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link Transformation} to apply.
-   * @see #optionalTransform(Class, Transformation)
-   */
-  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
-  @SuppressWarnings("CheckResult")
-  @CheckResult
-  public <T> RequestOptions transform(
-      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(resourceClass, transformation);
-    }
-
-    optionalTransform(resourceClass, transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Removes all applied {@link Transformation Transformations} for all
-   * resource classes and allows unknown resource types to be transformed without throwing an
-   * exception.
-   */
-  @CheckResult
-  public RequestOptions dontTransform() {
-    if (isAutoCloneEnabled) {
-      return clone().dontTransform();
-    }
-
-    transformations.clear();
-    fields &= ~TRANSFORMATION;
-    isTransformationRequired = false;
-    fields &= ~TRANSFORMATION_REQUIRED;
-    isTransformationAllowed = false;
-    fields |= TRANSFORMATION_ALLOWED;
-    isScaleOnlyOrNoTransform = true;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Disables resource decoders that return animated resources so any resource returned will be
-   * static.
-   *
-   * <p> To disable transitions (fades etc) use
-   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
-   */
-  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
-  @SuppressWarnings("CheckResult")
-  @CheckResult
-  public RequestOptions dontAnimate() {
-    return set(GifOptions.DISABLE_ANIMATION, true);
-  }
-
-  @CheckResult
-  public RequestOptions apply(@NonNull RequestOptions other) {
-    if (isAutoCloneEnabled) {
-      return clone().apply(other);
-    }
-
-    if (isSet(other.fields, SIZE_MULTIPLIER)) {
-      sizeMultiplier = other.sizeMultiplier;
-    }
-    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
-      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
-    }
-    if (isSet(other.fields, USE_ANIMATION_POOL)) {
-      useAnimationPool = other.useAnimationPool;
-    }
-    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
-      diskCacheStrategy = other.diskCacheStrategy;
-    }
-    if (isSet(other.fields, PRIORITY)) {
-      priority = other.priority;
-    }
-    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
-      errorPlaceholder = other.errorPlaceholder;
-    }
-    if (isSet(other.fields, ERROR_ID)) {
-      errorId = other.errorId;
-    }
-    if (isSet(other.fields, PLACEHOLDER)) {
-      placeholderDrawable = other.placeholderDrawable;
-    }
-    if (isSet(other.fields, PLACEHOLDER_ID)) {
-      placeholderId = other.placeholderId;
-    }
-    if (isSet(other.fields, IS_CACHEABLE)) {
-      isCacheable = other.isCacheable;
-    }
-    if (isSet(other.fields, OVERRIDE)) {
-      overrideWidth = other.overrideWidth;
-      overrideHeight = other.overrideHeight;
-    }
-    if (isSet(other.fields, SIGNATURE)) {
-      signature = other.signature;
-    }
-    if (isSet(other.fields, RESOURCE_CLASS)) {
-      resourceClass = other.resourceClass;
-    }
-    if (isSet(other.fields, FALLBACK)) {
-      fallbackDrawable = other.fallbackDrawable;
-    }
-    if (isSet(other.fields, FALLBACK_ID)) {
-      fallbackId = other.fallbackId;
-    }
-    if (isSet(other.fields, THEME)) {
-      theme = other.theme;
-    }
-    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
-      isTransformationAllowed = other.isTransformationAllowed;
-    }
-    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
-      isTransformationRequired = other.isTransformationRequired;
-    }
-    if (isSet(other.fields, TRANSFORMATION)) {
-      transformations.putAll(other.transformations);
-      isScaleOnlyOrNoTransform = other.isScaleOnlyOrNoTransform;
-    }
-    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
-      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
-    }
-
-    // Applying options with dontTransform() is expected to clear our transformations.
-    if (!isTransformationAllowed) {
-      transformations.clear();
-      fields &= ~TRANSFORMATION;
-      isTransformationRequired = false;
-      fields &= ~TRANSFORMATION_REQUIRED;
-      isScaleOnlyOrNoTransform = true;
-    }
-
-    fields |= other.fields;
-    options.putAll(other.options);
-
-    return selfOrThrowIfLocked();
-  }
-
-
-  @Override
-  public boolean equals(Object o) {
-    if (o instanceof RequestOptions) {
-      RequestOptions other = (RequestOptions) o;
-      return Float.compare(other.sizeMultiplier, sizeMultiplier) == 0
-          && errorId == other.errorId
-          && Util.bothNullOrEqual(errorPlaceholder, other.errorPlaceholder)
-          && placeholderId == other.placeholderId
-          && Util.bothNullOrEqual(placeholderDrawable, other.placeholderDrawable)
-          && fallbackId == other.fallbackId
-          && Util.bothNullOrEqual(fallbackDrawable, other.fallbackDrawable)
-          && isCacheable == other.isCacheable
-          && overrideHeight == other.overrideHeight
-          && overrideWidth == other.overrideWidth
-          && isTransformationRequired == other.isTransformationRequired
-          && isTransformationAllowed == other.isTransformationAllowed
-          && useUnlimitedSourceGeneratorsPool == other.useUnlimitedSourceGeneratorsPool
-          && onlyRetrieveFromCache == other.onlyRetrieveFromCache
-          && diskCacheStrategy.equals(other.diskCacheStrategy)
-          && priority == other.priority
-          && options.equals(other.options)
-          && transformations.equals(other.transformations)
-          && resourceClass.equals(other.resourceClass)
-          && Util.bothNullOrEqual(signature, other.signature)
-          && Util.bothNullOrEqual(theme, other.theme);
-    }
-    return false;
-  }
-
-  @Override
-  public int hashCode() {
-    int hashCode = Util.hashCode(sizeMultiplier);
-    hashCode = Util.hashCode(errorId, hashCode);
-    hashCode = Util.hashCode(errorPlaceholder, hashCode);
-    hashCode = Util.hashCode(placeholderId, hashCode);
-    hashCode = Util.hashCode(placeholderDrawable, hashCode);
-    hashCode = Util.hashCode(fallbackId, hashCode);
-    hashCode = Util.hashCode(fallbackDrawable, hashCode);
-    hashCode = Util.hashCode(isCacheable, hashCode);
-    hashCode = Util.hashCode(overrideHeight, hashCode);
-    hashCode = Util.hashCode(overrideWidth, hashCode);
-    hashCode = Util.hashCode(isTransformationRequired, hashCode);
-    hashCode = Util.hashCode(isTransformationAllowed, hashCode);
-    hashCode = Util.hashCode(useUnlimitedSourceGeneratorsPool, hashCode);
-    hashCode = Util.hashCode(onlyRetrieveFromCache, hashCode);
-    hashCode = Util.hashCode(diskCacheStrategy, hashCode);
-    hashCode = Util.hashCode(priority, hashCode);
-    hashCode = Util.hashCode(options, hashCode);
-    hashCode = Util.hashCode(transformations, hashCode);
-    hashCode = Util.hashCode(resourceClass, hashCode);
-    hashCode = Util.hashCode(signature, hashCode);
-    hashCode = Util.hashCode(theme, hashCode);
-    return hashCode;
-  }
-
-  /**
-   * Throws if any further mutations are attempted.
-   *
-   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
-   */
-  @SuppressWarnings("unchecked")
-  public RequestOptions lock() {
-    isLocked = true;
-    // This is the only place we should not check locked.
-    return this;
-  }
-
-  /**
-   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
-   * before the mutation resulting in all methods returning a new Object and leaving the original
-   * locked object unmodified.
-   *
-   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
-   * are mutable and are not locked.
-   */
-  public RequestOptions autoClone() {
-    if (isLocked && !isAutoCloneEnabled) {
-      throw new IllegalStateException("You cannot auto lock an already locked options object"
-          + ", try clone() first");
-    }
-    isAutoCloneEnabled = true;
-    return lock();
-  }
-
-  @SuppressWarnings("unchecked")
-  private RequestOptions selfOrThrowIfLocked() {
-    if (isLocked) {
-      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
-    }
-    return this;
-  }
-
-  protected boolean isAutoCloneEnabled() {
-    return isAutoCloneEnabled;
-  }
-
-  @NonNull
-  public final Map<Class<?>, Transformation<?>> getTransformations() {
-    return transformations;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final boolean isTransformationRequired() {
-    return isTransformationRequired;
-  }
-
-  @NonNull
-  public final Options getOptions() {
-    return options;
-  }
-
-  @NonNull
-  public final Class<?> getResourceClass() {
-    return resourceClass;
-  }
-
-  @NonNull
-  public final DiskCacheStrategy getDiskCacheStrategy() {
-    return diskCacheStrategy;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  @Nullable
-  public final Drawable getErrorPlaceholder() {
-    return errorPlaceholder;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final int getErrorId() {
-    return errorId;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final int getPlaceholderId() {
-    return placeholderId;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  @Nullable
-  public final Drawable getPlaceholderDrawable() {
-    return placeholderDrawable;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final int getFallbackId() {
-    return fallbackId;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  @Nullable
-  public final Drawable getFallbackDrawable() {
-    return fallbackDrawable;
-  }
-
-  @Nullable
-  public final Resources.Theme getTheme() {
-    return theme;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  public final boolean isMemoryCacheable() {
-    return isCacheable;
-  }
-
-  @NonNull
-  public final Key getSignature() {
-    return signature;
-  }
-
-  public final boolean isPrioritySet() {
-    return isSet(PRIORITY);
-  }
-
-  @NonNull
-  public final Priority getPriority() {
-    return priority;
-  }
-
-  public final int getOverrideWidth() {
-    return overrideWidth;
-  }
-
-  public final boolean isValidOverride() {
-    return Util.isValidDimensions(overrideWidth, overrideHeight);
-  }
-
-  public final int getOverrideHeight() {
-    return overrideHeight;
-  }
-
-  public final float getSizeMultiplier() {
-    return sizeMultiplier;
-  }
-
-  public boolean isScaleOnlyOrNoTransform() {
-    return isScaleOnlyOrNoTransform;
-  }
-
-  private boolean isSet(int flag) {
-    return isSet(fields, flag);
-  }
-
-  public final boolean getUseUnlimitedSourceGeneratorsPool() {
-    return useUnlimitedSourceGeneratorsPool;
-  }
-
-  public final boolean getUseAnimationPool() {
-    return useAnimationPool;
-  }
-
-  public final boolean getOnlyRetrieveFromCache() {
-    return onlyRetrieveFromCache;
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index f33cc4cf7..9f02dffb9 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -3,10 +3,12 @@
 import android.content.Context;
 import android.content.res.Resources.Theme;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.DrawableRes;
-import android.support.annotation.Nullable;
-import android.support.v4.util.Pools;
 import android.util.Log;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.util.Pools;
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -23,6 +25,8 @@
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
+import java.util.List;
+import java.util.concurrent.Executor;
 
 /**
  * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given
@@ -30,104 +34,93 @@
  *
  * @param <R> The type of the resource that will be transcoded from the loaded resource.
  */
-public final class SingleRequest<R> implements Request,
-    SizeReadyCallback,
-    ResourceCallback,
-    FactoryPools.Poolable {
+public final class SingleRequest<R>
+    implements Request, SizeReadyCallback, ResourceCallback, FactoryPools.Poolable {
   /** Tag for logging internal events, not generally suitable for public use. */
   private static final String TAG = "Request";
   /** Tag for logging externally useful events (request completion, timing etc). */
   private static final String GLIDE_TAG = "Glide";
-  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.simple(150,
-      new FactoryPools.Factory<SingleRequest<?>>() {
-        @Override
-        public SingleRequest<?> create() {
-          return new SingleRequest<Object>();
-        }
-      });
+
+  private static final Pools.Pool<SingleRequest<?>> POOL =
+      FactoryPools.threadSafe(
+          150,
+          new FactoryPools.Factory<SingleRequest<?>>() {
+            @Override
+            public SingleRequest<?> create() {
+              return new SingleRequest<Object>();
+            }
+          });
   private boolean isCallingCallbacks;
 
+  private static final boolean IS_VERBOSE_LOGGABLE = Log.isLoggable(TAG, Log.VERBOSE);
+
   private enum Status {
-    /**
-     * Created but not yet running.
-     */
+    /** Created but not yet running. */
     PENDING,
-    /**
-     * In the process of fetching media.
-     */
+    /** In the process of fetching media. */
     RUNNING,
-    /**
-     * Waiting for a callback given to the Target to be called to determine target dimensions.
-     */
+    /** Waiting for a callback given to the Target to be called to determine target dimensions. */
     WAITING_FOR_SIZE,
-    /**
-     * Finished loading media successfully.
-     */
+    /** Finished loading media successfully. */
     COMPLETE,
-    /**
-     * Failed to load media, may be restarted.
-     */
+    /** Failed to load media, may be restarted. */
     FAILED,
-    /**
-     * Cancelled by the user, may not be restarted.
-     */
-    CANCELLED,
-    /**
-     * Cleared by the user with a placeholder set, may not be restarted.
-     */
+    /** Cleared by the user with a placeholder set, may be restarted. */
     CLEARED,
-    /**
-     * Temporarily paused by the system, may be restarted.
-     */
-    PAUSED,
   }
 
-  private final String tag = String.valueOf(super.hashCode());
+  @Nullable
+  private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
+
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
-  @Nullable
-  private RequestListener<R> targetListener;
+  @Nullable private RequestListener<R> targetListener;
   private RequestCoordinator requestCoordinator;
   private Context context;
   private GlideContext glideContext;
-  @Nullable
-  private Object model;
+  @Nullable private Object model;
   private Class<R> transcodeClass;
-  private RequestOptions requestOptions;
+  private BaseRequestOptions<?> requestOptions;
   private int overrideWidth;
   private int overrideHeight;
   private Priority priority;
   private Target<R> target;
-  private RequestListener<R> requestListener;
+  @Nullable private List<RequestListener<R>> requestListeners;
   private Engine engine;
   private TransitionFactory<? super R> animationFactory;
+  private Executor callbackExecutor;
   private Resource<R> resource;
   private Engine.LoadStatus loadStatus;
   private long startTime;
+
+  @GuardedBy("this")
   private Status status;
+
   private Drawable errorDrawable;
   private Drawable placeholderDrawable;
   private Drawable fallbackDrawable;
   private int width;
   private int height;
+  @Nullable private RuntimeException requestOrigin;
 
   public static <R> SingleRequest<R> obtain(
       Context context,
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      RequestOptions requestOptions,
+      BaseRequestOptions<?> requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
       Target<R> target,
       RequestListener<R> targetListener,
-      RequestListener<R> requestListener,
+      @Nullable List<RequestListener<R>> requestListeners,
       RequestCoordinator requestCoordinator,
       Engine engine,
-      TransitionFactory<? super R> animationFactory) {
-    @SuppressWarnings("unchecked") SingleRequest<R> request =
-        (SingleRequest<R>) POOL.acquire();
+      TransitionFactory<? super R> animationFactory,
+      Executor callbackExecutor) {
+    @SuppressWarnings("unchecked")
+    SingleRequest<R> request = (SingleRequest<R>) POOL.acquire();
     if (request == null) {
       request = new SingleRequest<>();
     }
@@ -142,33 +135,36 @@
         priority,
         target,
         targetListener,
-        requestListener,
+        requestListeners,
         requestCoordinator,
         engine,
-        animationFactory);
+        animationFactory,
+        callbackExecutor);
     return request;
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
   SingleRequest() {
     // just create, instances are reused with recycle/init
   }
 
-  private void init(
+  private synchronized void init(
       Context context,
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      RequestOptions requestOptions,
+      BaseRequestOptions<?> requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
       Target<R> target,
       RequestListener<R> targetListener,
-      RequestListener<R> requestListener,
+      @Nullable List<RequestListener<R>> requestListeners,
       RequestCoordinator requestCoordinator,
       Engine engine,
-      TransitionFactory<? super R> animationFactory) {
+      TransitionFactory<? super R> animationFactory,
+      Executor callbackExecutor) {
     this.context = context;
     this.glideContext = glideContext;
     this.model = model;
@@ -179,20 +175,26 @@ private void init(
     this.priority = priority;
     this.target = target;
     this.targetListener = targetListener;
-    this.requestListener = requestListener;
+    this.requestListeners = requestListeners;
     this.requestCoordinator = requestCoordinator;
     this.engine = engine;
     this.animationFactory = animationFactory;
+    this.callbackExecutor = callbackExecutor;
     status = Status.PENDING;
+
+    if (requestOrigin == null && glideContext.isLoggingRequestOriginsEnabled()) {
+      requestOrigin = new RuntimeException("Glide request origin trace");
+    }
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
   @Override
-  public void recycle() {
+  public synchronized void recycle() {
     assertNotCallingCallbacks();
     context = null;
     glideContext = null;
@@ -202,7 +204,7 @@ public void recycle() {
     overrideWidth = -1;
     overrideHeight = -1;
     target = null;
-    requestListener = null;
+    requestListeners = null;
     targetListener = null;
     requestCoordinator = null;
     animationFactory = null;
@@ -212,11 +214,12 @@ public void recycle() {
     fallbackDrawable = null;
     width = -1;
     height = -1;
+    requestOrigin = null;
     POOL.release(this);
   }
 
   @Override
-  public void begin() {
+  public synchronized void begin() {
     assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
@@ -261,7 +264,7 @@ public void begin() {
         && canNotifyStatusChanged()) {
       target.onLoadStarted(getPlaceholderDrawable());
     }
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished run method in " + LogTime.getElapsedMillis(startTime));
     }
   }
@@ -270,15 +273,14 @@ public void begin() {
    * Cancels the current load but does not release any resources held by the request and continues
    * to display the loaded resource if the load completed before the call to cancel.
    *
-   * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
+   * <p>Cancelled requests can be restarted with a subsequent call to {@link #begin()}.
    *
    * @see #clear()
    */
-  void cancel() {
+  private void cancel() {
     assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     target.removeCallback(this);
-    status = Status.CANCELLED;
     if (loadStatus != null) {
       loadStatus.cancel();
       loadStatus = null;
@@ -288,10 +290,11 @@ void cancel() {
   // Avoids difficult to understand errors like #2413.
   private void assertNotCallingCallbacks() {
     if (isCallingCallbacks) {
-      throw new IllegalStateException("You can't start or clear loads in RequestListener or"
-          + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
-          + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
-          + " clear() calls to the main thread using a Handler instead.");
+      throw new IllegalStateException(
+          "You can't start or clear loads in RequestListener or"
+              + " Target callbacks. If you're trying to start a fallback request when a load fails,"
+              + " use RequestBuilder#error(RequestBuilder). Otherwise consider posting your into()"
+              + " or clear() calls to the main thread using a Handler instead.");
     }
   }
 
@@ -299,14 +302,14 @@ private void assertNotCallingCallbacks() {
    * Cancels the current load if it is in progress, clears any resources held onto by the request
    * and replaces the loaded resource if the load completed with the placeholder.
    *
-   * <p> Cleared requests can be restarted with a subsequent call to {@link #begin()} </p>
+   * <p>Cleared requests can be restarted with a subsequent call to {@link #begin()}
    *
    * @see #cancel()
    */
   @Override
-  public void clear() {
-    Util.assertMainThread();
+  public synchronized void clear() {
     assertNotCallingCallbacks();
+    stateVerifier.throwIfRecycled();
     if (status == Status.CLEARED) {
       return;
     }
@@ -315,22 +318,11 @@ public void clear() {
     if (resource != null) {
       releaseResource(resource);
     }
-    if (canNotifyStatusChanged()) {
+    if (canNotifyCleared()) {
       target.onLoadCleared(getPlaceholderDrawable());
     }
-    // Must be after cancel().
-    status = Status.CLEARED;
-  }
-
-  @Override
-  public boolean isPaused() {
-    return status == Status.PAUSED;
-  }
 
-  @Override
-  public void pause() {
-    clear();
-    status = Status.PAUSED;
+    status = Status.CLEARED;
   }
 
   private void releaseResource(Resource<?> resource) {
@@ -339,27 +331,27 @@ private void releaseResource(Resource<?> resource) {
   }
 
   @Override
-  public boolean isRunning() {
+  public synchronized boolean isRunning() {
     return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
   }
 
   @Override
-  public boolean isComplete() {
+  public synchronized boolean isComplete() {
     return status == Status.COMPLETE;
   }
 
   @Override
-  public boolean isResourceSet() {
+  public synchronized boolean isResourceSet() {
     return isComplete();
   }
 
   @Override
-  public boolean isCancelled() {
-    return status == Status.CANCELLED || status == Status.CLEARED;
+  public synchronized boolean isCleared() {
+    return status == Status.CLEARED;
   }
 
   @Override
-  public boolean isFailed() {
+  public synchronized boolean isFailed() {
     return status == Status.FAILED;
   }
 
@@ -374,7 +366,7 @@ private Drawable getErrorDrawable() {
   }
 
   private Drawable getPlaceholderDrawable() {
-     if (placeholderDrawable == null) {
+    if (placeholderDrawable == null) {
       placeholderDrawable = requestOptions.getPlaceholderDrawable();
       if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
         placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
@@ -394,12 +386,12 @@ private Drawable getFallbackDrawable() {
   }
 
   private Drawable loadDrawable(@DrawableRes int resourceId) {
-    Theme theme = requestOptions.getTheme() != null
-        ? requestOptions.getTheme() : context.getTheme();
+    Theme theme =
+        requestOptions.getTheme() != null ? requestOptions.getTheme() : context.getTheme();
     return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
   }
 
-  private void setErrorPlaceholder() {
+  private synchronized void setErrorPlaceholder() {
     if (!canNotifyStatusChanged()) {
       return;
     }
@@ -419,13 +411,11 @@ private void setErrorPlaceholder() {
     target.onLoadFailed(error);
   }
 
-  /**
-   * A callback method that should never be invoked directly.
-   */
+  /** A callback method that should never be invoked directly. */
   @Override
-  public void onSizeReady(int width, int height) {
+  public synchronized void onSizeReady(int width, int height) {
     stateVerifier.throwIfRecycled();
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
     if (status != Status.WAITING_FOR_SIZE) {
@@ -437,29 +427,38 @@ public void onSizeReady(int width, int height) {
     this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
     this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
     }
-    loadStatus = engine.load(
-        glideContext,
-        model,
-        requestOptions.getSignature(),
-        this.width,
-        this.height,
-        requestOptions.getResourceClass(),
-        transcodeClass,
-        priority,
-        requestOptions.getDiskCacheStrategy(),
-        requestOptions.getTransformations(),
-        requestOptions.isTransformationRequired(),
-        requestOptions.isScaleOnlyOrNoTransform(),
-        requestOptions.getOptions(),
-        requestOptions.isMemoryCacheable(),
-        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
-        requestOptions.getUseAnimationPool(),
-        requestOptions.getOnlyRetrieveFromCache(),
-        this);
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    loadStatus =
+        engine.load(
+            glideContext,
+            model,
+            requestOptions.getSignature(),
+            this.width,
+            this.height,
+            requestOptions.getResourceClass(),
+            transcodeClass,
+            priority,
+            requestOptions.getDiskCacheStrategy(),
+            requestOptions.getTransformations(),
+            requestOptions.isTransformationRequired(),
+            requestOptions.isScaleOnlyOrNoTransform(),
+            requestOptions.getOptions(),
+            requestOptions.isMemoryCacheable(),
+            requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+            requestOptions.getUseAnimationPool(),
+            requestOptions.getOnlyRetrieveFromCache(),
+            this,
+            callbackExecutor);
+
+    // This is a hack that's only useful for testing right now where loads complete synchronously
+    // even though under any executor running on any thread but the main thread, the load would
+    // have completed asynchronously.
+    if (status != Status.RUNNING) {
+      loadStatus = null;
+    }
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
   }
@@ -472,6 +471,10 @@ private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
 
+  private boolean canNotifyCleared() {
+    return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
+  }
+
   private boolean canNotifyStatusChanged() {
     return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
   }
@@ -492,17 +495,19 @@ private void notifyLoadFailed() {
     }
   }
 
-  /**
-   * A callback method that should never be invoked directly.
-   */
+  /** A callback method that should never be invoked directly. */
   @SuppressWarnings("unchecked")
   @Override
-  public void onResourceReady(Resource<?> resource, DataSource dataSource) {
+  public synchronized void onResourceReady(Resource<?> resource, DataSource dataSource) {
     stateVerifier.throwIfRecycled();
     loadStatus = null;
     if (resource == null) {
-      GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
-          + "object of " + transcodeClass + " inside, but instead got null.");
+      GlideException exception =
+          new GlideException(
+              "Expected to receive a Resource<R> with an "
+                  + "object of "
+                  + transcodeClass
+                  + " inside, but instead got null.");
       onLoadFailed(exception);
       return;
     }
@@ -510,12 +515,25 @@ public void onResourceReady(Resource<?> resource, DataSource dataSource) {
     Object received = resource.get();
     if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
       releaseResource(resource);
-      GlideException exception = new GlideException("Expected to receive an object of "
-          + transcodeClass + " but instead" + " got "
-          + (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
-          + "Resource{" + resource + "}."
-          + (received != null ? "" : " " + "To indicate failure return a null Resource "
-          + "object, rather than a Resource object containing null data."));
+      GlideException exception =
+          new GlideException(
+              "Expected to receive an object of "
+                  + transcodeClass
+                  + " but instead"
+                  + " got "
+                  + (received != null ? received.getClass() : "")
+                  + "{"
+                  + received
+                  + "} inside"
+                  + " "
+                  + "Resource{"
+                  + resource
+                  + "}."
+                  + (received != null
+                      ? ""
+                      : " "
+                          + "To indicate failure return a null Resource "
+                          + "object, rather than a Resource object containing null data."));
       onLoadFailed(exception);
       return;
     }
@@ -534,29 +552,48 @@ public void onResourceReady(Resource<?> resource, DataSource dataSource) {
    * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
    *
    * @param resource original {@link Resource}, never <code>null</code>
-   * @param result   object returned by {@link Resource#get()}, checked for type and never
-   *                 <code>null</code>
+   * @param result object returned by {@link Resource#get()}, checked for type and never <code>null
+   *     </code>
    */
-  private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
+  private synchronized void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
     // We must call isFirstReadyResource before setting status.
     boolean isFirstResource = isFirstReadyResource();
     status = Status.COMPLETE;
     this.resource = resource;
 
     if (glideContext.getLogLevel() <= Log.DEBUG) {
-      Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
-          + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
-          + LogTime.getElapsedMillis(startTime) + " ms");
+      Log.d(
+          GLIDE_TAG,
+          "Finished loading "
+              + result.getClass().getSimpleName()
+              + " from "
+              + dataSource
+              + " for "
+              + model
+              + " with size ["
+              + width
+              + "x"
+              + height
+              + "] in "
+              + LogTime.getElapsedMillis(startTime)
+              + " ms");
     }
 
     isCallingCallbacks = true;
     try {
-      if ((requestListener == null
-          || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))
-          && (targetListener == null
-          || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) {
-        Transition<? super R> animation =
-            animationFactory.build(dataSource, isFirstResource);
+      boolean anyListenerHandledUpdatingTarget = false;
+      if (requestListeners != null) {
+        for (RequestListener<R> listener : requestListeners) {
+          anyListenerHandledUpdatingTarget |=
+              listener.onResourceReady(result, model, target, dataSource, isFirstResource);
+        }
+      }
+      anyListenerHandledUpdatingTarget |=
+          targetListener != null
+              && targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);
+
+      if (!anyListenerHandledUpdatingTarget) {
+        Transition<? super R> animation = animationFactory.build(dataSource, isFirstResource);
         target.onResourceReady(result, animation);
       }
     } finally {
@@ -566,16 +603,15 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
     notifyLoadSuccess();
   }
 
-  /**
-   * A callback method that should never be invoked directly.
-   */
+  /** A callback method that should never be invoked directly. */
   @Override
-  public void onLoadFailed(GlideException e) {
+  public synchronized void onLoadFailed(GlideException e) {
     onLoadFailed(e, Log.WARN);
   }
 
-  private void onLoadFailed(GlideException e, int maxLogLevel) {
+  private synchronized void onLoadFailed(GlideException e, int maxLogLevel) {
     stateVerifier.throwIfRecycled();
+    e.setOrigin(requestOrigin);
     int logLevel = glideContext.getLogLevel();
     if (logLevel <= maxLogLevel) {
       Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
@@ -589,11 +625,19 @@ private void onLoadFailed(GlideException e, int maxLogLevel) {
 
     isCallingCallbacks = true;
     try {
-      //TODO: what if this is a thumbnail request?
-      if ((requestListener == null
-          || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource()))
-          && (targetListener == null
-          || !targetListener.onLoadFailed(e, model, target, isFirstReadyResource()))) {
+      // TODO: what if this is a thumbnail request?
+      boolean anyListenerHandledUpdatingTarget = false;
+      if (requestListeners != null) {
+        for (RequestListener<R> listener : requestListeners) {
+          anyListenerHandledUpdatingTarget |=
+              listener.onLoadFailed(e, model, target, isFirstReadyResource());
+        }
+      }
+      anyListenerHandledUpdatingTarget |=
+          targetListener != null
+              && targetListener.onLoadFailed(e, model, target, isFirstReadyResource());
+
+      if (!anyListenerHandledUpdatingTarget) {
         setErrorPlaceholder();
       }
     } finally {
@@ -603,25 +647,36 @@ private void onLoadFailed(GlideException e, int maxLogLevel) {
     notifyLoadFailed();
   }
 
+  @SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
   @Override
-  public boolean isEquivalentTo(Request o) {
+  public synchronized boolean isEquivalentTo(Request o) {
     if (o instanceof SingleRequest) {
-      SingleRequest that = (SingleRequest) o;
-      return overrideWidth == that.overrideWidth
-          && overrideHeight == that.overrideHeight
-          && Util.bothModelsNullEquivalentOrEquals(model, that.model)
-          && transcodeClass.equals(that.transcodeClass)
-          && requestOptions.equals(that.requestOptions)
-          && priority == that.priority
-          // We do not want to require that RequestListeners implement equals/hashcode, so we don't
-          // compare them using equals(). We can however, at least assert that the request listener
-          // is either present or not present in both requests.
-          && (requestListener != null
-          ? that.requestListener != null : that.requestListener == null);
+      SingleRequest<?> that = (SingleRequest<?>) o;
+      synchronized (that) {
+        return overrideWidth == that.overrideWidth
+            && overrideHeight == that.overrideHeight
+            && Util.bothModelsNullEquivalentOrEquals(model, that.model)
+            && transcodeClass.equals(that.transcodeClass)
+            && requestOptions.equals(that.requestOptions)
+            && priority == that.priority
+            // We do not want to require that RequestListeners implement equals/hashcode, so we
+            // don't compare them using equals(). We can however, at least assert that the same
+            // amount of request listeners are present in both requests.
+            && listenerCountEquals(that);
+      }
     }
     return false;
   }
 
+  @SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
+  private synchronized boolean listenerCountEquals(SingleRequest<?> other) {
+    synchronized (other) {
+      int firstListenerCount = requestListeners == null ? 0 : requestListeners.size();
+      int secondListenerCount = other.requestListeners == null ? 0 : other.requestListeners.size();
+      return firstListenerCount == secondListenerCount;
+    }
+  }
+
   private void logV(String message) {
     Log.v(TAG, message + " this: " + tag);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 8bee19db7..90726a656 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -1,24 +1,26 @@
 package com.bumptech.glide.request;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 
 /**
  * A coordinator that coordinates two individual {@link Request}s that load a small thumbnail
  * version of an image and the full size version of the image at the same time.
  */
-public class ThumbnailRequestCoordinator implements RequestCoordinator,
-    Request {
+public class ThumbnailRequestCoordinator implements RequestCoordinator, Request {
+  @Nullable private final RequestCoordinator parent;
+
   private Request full;
   private Request thumb;
-  @Nullable private RequestCoordinator coordinator;
   private boolean isRunning;
 
-  public ThumbnailRequestCoordinator() {
-    this(null);
+  @VisibleForTesting
+  ThumbnailRequestCoordinator() {
+    this(/*parent=*/ null);
   }
 
-  public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
-    this.coordinator = coordinator;
+  public ThumbnailRequestCoordinator(@Nullable RequestCoordinator parent) {
+    this.parent = parent;
   }
 
   public void setRequests(Request full, Request thumb) {
@@ -38,7 +40,7 @@ public boolean canSetImage(Request request) {
   }
 
   private boolean parentCanSetImage() {
-    return coordinator == null || coordinator.canSetImage(this);
+    return parent == null || parent.canSetImage(this);
   }
 
   /**
@@ -52,8 +54,17 @@ public boolean canNotifyStatusChanged(Request request) {
     return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
   }
 
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && request.equals(full);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return parent == null || parent.canNotifyCleared(this);
+  }
+
   private boolean parentCanNotifyStatusChanged() {
-    return coordinator == null || coordinator.canNotifyStatusChanged(this);
+    return parent == null || parent.canNotifyStatusChanged(this);
   }
 
   @Override
@@ -66,8 +77,8 @@ public void onRequestSuccess(Request request) {
     if (request.equals(thumb)) {
       return;
     }
-    if (coordinator != null) {
-      coordinator.onRequestSuccess(this);
+    if (parent != null) {
+      parent.onRequestSuccess(this);
     }
     // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
     // as a layer in a cross fade for example. The only way we know the thumb is not being
@@ -83,22 +94,22 @@ public void onRequestFailed(Request request) {
       return;
     }
 
-    if (coordinator != null) {
-      coordinator.onRequestFailed(this);
+    if (parent != null) {
+      parent.onRequestFailed(this);
     }
   }
 
   private boolean parentIsAnyResourceSet() {
-    return coordinator != null && coordinator.isAnyResourceSet();
+    return parent != null && parent.isAnyResourceSet();
   }
 
-  /**
-   * Starts first the thumb request and then the full request.
-   */
+  /** Starts first the thumb request and then the full request. */
   @Override
   public void begin() {
     isRunning = true;
-    if (!thumb.isRunning()) {
+    // If the request has completed previously, there's no need to restart both the full and the
+    // thumb, we can just restart the full.
+    if (!full.isComplete() && !thumb.isRunning()) {
       thumb.begin();
     }
     if (isRunning && !full.isRunning()) {
@@ -106,13 +117,6 @@ public void begin() {
     }
   }
 
-  @Override
-  public void pause() {
-    isRunning = false;
-    full.pause();
-    thumb.pause();
-  }
-
   @Override
   public void clear() {
     isRunning = false;
@@ -120,22 +124,13 @@ public void clear() {
     full.clear();
   }
 
-  @Override
-  public boolean isPaused() {
-    return full.isPaused();
-  }
-
-  /**
-   * Returns true if the full request is still running.
-   */
+  /** Returns true if the full request is still running. */
   @Override
   public boolean isRunning() {
     return full.isRunning();
   }
 
-  /**
-   * Returns true if the full request is complete.
-   */
+  /** Returns true if the full request is complete. */
   @Override
   public boolean isComplete() {
     return full.isComplete() || thumb.isComplete();
@@ -147,13 +142,11 @@ public boolean isResourceSet() {
   }
 
   @Override
-  public boolean isCancelled() {
-    return full.isCancelled();
+  public boolean isCleared() {
+    return full.isCleared();
   }
 
-  /**
-   * Returns true if the full request has failed.
-   */
+  /** Returns true if the full request has failed. */
   @Override
   public boolean isFailed() {
     return full.isFailed();
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index 5259a5973..cf3e582bc 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -4,7 +4,10 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.widget.RemoteViews;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
 
@@ -12,10 +15,12 @@
  * This class is used in order to display downloaded Bitmap inside an ImageView of an AppWidget
  * through RemoteViews.
  *
- * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
- * for every subsequent load. </p>
+ * <p>Note - For cancellation to work correctly, you must pass in the same instance of this class
+ * for every subsequent load.
  */
-public class AppWidgetTarget extends SimpleTarget<Bitmap> {
+// Public API.
+@SuppressWarnings("WeakerAccess")
+public class AppWidgetTarget extends CustomTarget<Bitmap> {
   private final int[] widgetIds;
   private final ComponentName componentName;
   private final RemoteViews remoteViews;
@@ -26,17 +31,22 @@
    * Constructor using an int array of widgetIds to get a handle on the Widget in order to update
    * it.
    *
-   * @param context     Context to use in the AppWidgetManager initialization.
-   * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be
-   *                    manually put because of RemoteViews limitations.)
-   * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be
-   *                    manually put because of RemoteViews limitations.)
-   * @param viewId      The id of the ImageView view that will load the image.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param width Desired width in pixels of the bitmap that will be loaded. (Needs to be manually
+   *     put because of RemoteViews limitations.)
+   * @param height Desired height in pixels of the bitmap that will be loaded. (Needs to be manually
+   *     put because of RemoteViews limitations.)
+   * @param viewId The id of the ImageView view that will load the image.
    * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-   * @param widgetIds   The int[] that contains the widget ids of an application.
+   * @param widgetIds The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, int width, int height,
-      int viewId, RemoteViews remoteViews, int... widgetIds) {
+  public AppWidgetTarget(
+      Context context,
+      int width,
+      int height,
+      int viewId,
+      RemoteViews remoteViews,
+      int... widgetIds) {
     super(width, height);
     if (widgetIds.length == 0) {
       throw new IllegalArgumentException("WidgetIds must have length > 0");
@@ -53,31 +63,34 @@ public AppWidgetTarget(Context context, int width, int height,
    * Constructor using an int array of widgetIds to get a handle on the Widget in order to update it
    * that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
-   * @param context     Context to use in the AppWidgetManager initialization.
-   * @param viewId      The id of the ImageView view that will load the image.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param viewId The id of the ImageView view that will load the image.
    * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-   * @param widgetIds   The int[] that contains the widget ids of an application.
+   * @param widgetIds The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context,
-      int viewId, RemoteViews remoteViews, int... widgetIds) {
+  public AppWidgetTarget(Context context, int viewId, RemoteViews remoteViews, int... widgetIds) {
     this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);
   }
 
   /**
    * Constructor using a ComponentName to get a handle on the Widget in order to update it.
    *
-   * @param context       Context to use in the AppWidgetManager initialization.
-   * @param width         Desired width in pixels of the bitmap that will be loaded. (Needs to be
-   *                      manually put because of RemoteViews limitations.)
-   * @param height        Desired height in pixels of the bitmap that will be loaded. (Needs to be
-   *                      manually put because of RemoteViews limitations.)
-   * @param viewId        The id of the ImageView view that will load the image.
-   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
-   *                      bitmap.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param width Desired width in pixels of the bitmap that will be loaded. (Needs to be manually
+   *     put because of RemoteViews limitations.)
+   * @param height Desired height in pixels of the bitmap that will be loaded. (Needs to be manually
+   *     put because of RemoteViews limitations.)
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, int width, int height,
-      int viewId, RemoteViews remoteViews, ComponentName componentName) {
+  public AppWidgetTarget(
+      Context context,
+      int width,
+      int height,
+      int viewId,
+      RemoteViews remoteViews,
+      ComponentName componentName) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context can not be null!");
     this.remoteViews =
@@ -92,20 +105,17 @@ public AppWidgetTarget(Context context, int width, int height,
    * Constructor using a ComponentName, when override has been put to get a handle on the Widget in
    * order to update it that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
-   * @param context       Context to use in the AppWidgetManager initialization.
-   * @param viewId        The id of the ImageView view that will load the image.
-   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
-   *                      bitmap.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context,
-      int viewId, RemoteViews remoteViews, ComponentName componentName) {
+  public AppWidgetTarget(
+      Context context, int viewId, RemoteViews remoteViews, ComponentName componentName) {
     this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);
   }
 
-  /**
-   * Updates the AppWidget after the ImageView has loaded the Bitmap.
-   */
+  /** Updates the AppWidget after the ImageView has loaded the Bitmap. */
   private void update() {
     AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this.context);
     if (this.componentName != null) {
@@ -116,8 +126,18 @@ private void update() {
   }
 
   @Override
-  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
-    this.remoteViews.setImageViewBitmap(this.viewId, resource);
-    this.update();
+  public void onResourceReady(
+      @NonNull Bitmap resource, @Nullable Transition<? super Bitmap> transition) {
+    setBitmap(resource);
+  }
+
+  @Override
+  public void onLoadCleared(@Nullable Drawable placeholder) {
+    setBitmap(null);
+  }
+
+  private void setBitmap(@Nullable Bitmap bitmap) {
+    this.remoteViews.setImageViewBitmap(viewId, bitmap);
+    update();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
index 792de64a3..50c0612f9 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
@@ -1,23 +1,30 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.request.Request;
 
 /**
  * A base {@link Target} for loading {@link com.bumptech.glide.load.engine.Resource}s that provides
  * basic or empty implementations for most methods.
  *
- * <p> For maximum efficiency, clear this target when you have finished using or displaying the
- * {@link com.bumptech.glide.load.engine.Resource} loaded into it using
- * {@link com.bumptech.glide.RequestManager#clear(Target)}.</p>
+ * <p>For maximum efficiency, clear this target when you have finished using or displaying the
+ * {@link com.bumptech.glide.load.engine.Resource} loaded into it using {@link
+ * com.bumptech.glide.RequestManager#clear(Target)}.
  *
- * <p> For loading {@link com.bumptech.glide.load.engine.Resource}s into {@link android.view.View}s,
- * {@link com.bumptech.glide.request.target.ViewTarget} or
- * {@link com.bumptech.glide.request.target.ImageViewTarget} are preferable.</p>
+ * <p>For loading {@link com.bumptech.glide.load.engine.Resource}s into {@link android.view.View}s,
+ * {@link com.bumptech.glide.request.target.ViewTarget} or {@link
+ * com.bumptech.glide.request.target.ImageViewTarget} are preferable.
  *
  * @param <Z> The type of resource that will be received by this target.
+ * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if
+ *     in the background
+ *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a a fully
+ *     implemented {@link Target} for any specialized use-cases. Using BaseView is unsafe if the
+ *     user does not implement {@link #onLoadCleared}, resulting in recycled bitmaps being
+ *     referenced from the UI and hard to root-cause crashes.
  */
+@Deprecated
 public abstract class BaseTarget<Z> implements Target<Z> {
 
   private Request request;
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
index 42c701091..03b7b5fb2 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
@@ -8,10 +8,16 @@
  * android.graphics.Bitmap} in an {@link android.widget.ImageView}.
  */
 public class BitmapImageViewTarget extends ImageViewTarget<Bitmap> {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /** @deprecated Use {@link #waitForLayout()} instead. */
+  // Public API.
+  @SuppressWarnings({"unused", "deprecation"})
+  @Deprecated
   public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
index 46b909ffa..683367eb5 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
@@ -8,11 +8,16 @@
 /**
  * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {
   public BitmapThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /** @deprecated Use {@link #waitForLayout()} instead. */
+  @SuppressWarnings("deprecation")
+  @Deprecated
   public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
new file mode 100644
index 000000000..2d39c3b4c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
@@ -0,0 +1,125 @@
+package com.bumptech.glide.request.target;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Util;
+
+/**
+ * A base {@link Target} for loading resources ({@link android.graphics.Bitmap}, {@link Drawable}
+ * etc) that are used outside of {@link android.view.View}s.
+ *
+ * <p>If you're loading a resource into a {@link View}, use {@link
+ * com.bumptech.glide.RequestBuilder#into(ImageView)}, a subclass of {@link ImageViewTarget}, or
+ * {@link CustomViewTarget}. Using this class to load resources into {@link View}s can prevent Glide
+ * from correctly cancelling any previous loads, which may result in incorrect images appearing in
+ * the view, especially in scrolling views like {@link androidx.recyclerview.widget.RecyclerView}.
+ *
+ * <p>You <em>MUST</em> implement {@link #onLoadCleared(Drawable)} and ensure that all references to
+ * any resource passed into the target in {@link #onResourceReady(Object, Transition)} are removed
+ * before {@link #onLoadCleared(Drawable)} completes. Failing to do so can result in graphical
+ * corruption, crashes caused by recycled {@link Bitmap}s, and other undefined behavior. It is never
+ * safe to leave {@link #onLoadCleared(Drawable)} unimplemented or empty. Even if you do not
+ * manually clear this {@link Target}, Glide may do so automatically after certain lifecycle events
+ * in {@link androidx.fragment.app.Fragment}s and {@link android.app.Activity}s.
+ *
+ * <p>This class can only be used with {@link Target#SIZE_ORIGINAL} or when the desired resource
+ * dimensions are known when the {@link Target} is created. If you'd like to run some asynchronous
+ * process and make full use of {@link #getSize(SizeReadyCallback)} and {@link SizeReadyCallback},
+ * extend {@link Target} directly instead of using this class.
+ *
+ * @param <T> The type of resource that will be loaded (e.g. {@link Bitmap}).
+ */
+public abstract class CustomTarget<T> implements Target<T> {
+
+  private final int width;
+  private final int height;
+
+  @Nullable private Request request;
+
+  /**
+   * Creates a new {@link CustomTarget} that will attempt to load the resource in its original size.
+   *
+   * <p>This constructor can cause very memory inefficient loads if the resource is large and can
+   * cause OOMs. It's provided as a convenience for when you'd like to specify dimensions with
+   * {@link com.bumptech.glide.request.RequestOptions#override(int)}. In all other cases, prefer
+   * {@link #CustomTarget(int, int)}.
+   */
+  public CustomTarget() {
+    this(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+  }
+
+  /**
+   * Creates a new {@code CustomTarget} that will return the given {@code width} and {@code height}
+   * as the requested size (unless overridden by {@link
+   * com.bumptech.glide.request.RequestOptions#override(int)} in the request).
+   *
+   * @param width The requested width (> 0, or == Target.SIZE_ORIGINAL).
+   * @param height The requested height (> 0, or == Target.SIZE_ORIGINAL).
+   * @throws IllegalArgumentException if width/height doesn't meet (> 0, or == Target.SIZE_ORIGINAL)
+   */
+  public CustomTarget(int width, int height) {
+    if (!Util.isValidDimensions(width, height)) {
+      throw new IllegalArgumentException(
+          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given"
+              + " width: "
+              + width
+              + " and height: "
+              + height);
+    }
+
+    this.width = width;
+    this.height = height;
+  }
+
+  @Override
+  public void onStart() {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public void onStop() {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public void onDestroy() {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public void onLoadStarted(@Nullable Drawable placeholder) {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public void onLoadFailed(@Nullable Drawable errorDrawable) {
+    // Intentionally empty, this can be optionally implemented by subclasses.
+  }
+
+  @Override
+  public final void getSize(@NonNull SizeReadyCallback cb) {
+    cb.onSizeReady(width, height);
+  }
+
+  @Override
+  public final void removeCallback(@NonNull SizeReadyCallback cb) {
+    // Do nothing, this class does not retain SizeReadyCallbacks.
+  }
+
+  @Override
+  public final void setRequest(@Nullable Request request) {
+    this.request = request;
+  }
+
+  @Nullable
+  @Override
+  public final Request getRequest() {
+    return request;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
new file mode 100644
index 000000000..35e55305f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
@@ -0,0 +1,494 @@
+package com.bumptech.glide.request.target;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.graphics.drawable.Drawable;
+import android.util.Log;
+import android.view.Display;
+import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
+import android.view.ViewGroup.LayoutParams;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.bumptech.glide.R;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A base {@link Target} for loading resources ({@link android.graphics.Bitmap}, {@link Drawable}
+ * etc) into {@link View}s that provides default implementations for most methods and can determine
+ * the size of views using a {@link android.view.ViewTreeObserver.OnDrawListener}.
+ *
+ * @param <T> The specific subclass of view wrapped by this target (e.g. {@link
+ *     android.widget.ImageView})
+ * @param <Z> The resource type this target will receive (e.g. {@link android.graphics.Bitmap}).
+ */
+public abstract class CustomViewTarget<T extends View, Z> implements Target<Z> {
+  private static final String TAG = "CustomViewTarget";
+  @IdRes private static final int VIEW_TAG_ID = R.id.glide_custom_view_target_tag;
+
+  private final SizeDeterminer sizeDeterminer;
+
+  protected final T view;
+  @Nullable private OnAttachStateChangeListener attachStateListener;
+  private boolean isClearedByUs;
+  private boolean isAttachStateListenerAdded;
+
+  /** Constructor that defaults {@code waitForLayout} to {@code false}. */
+  public CustomViewTarget(@NonNull T view) {
+    this.view = Preconditions.checkNotNull(view);
+    sizeDeterminer = new SizeDeterminer(view);
+  }
+
+  /**
+   * A required callback invoked when the resource is no longer valid and must be freed.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer used before redrawing the container (usually a View) or changing its
+   * visibility. <b>Not doing so will result in crashes in your app.</b>
+   *
+   * @param placeholder The placeholder drawable to optionally show, or null.
+   */
+  protected abstract void onResourceCleared(@Nullable Drawable placeholder);
+
+  /**
+   * An optional callback invoked when a resource load is started.
+   *
+   * @see Target#onLoadStarted(Drawable)
+   * @param placeholder The placeholder drawable to optionally show, or null.
+   */
+  protected void onResourceLoading(@Nullable Drawable placeholder) {
+    // Default empty.
+  }
+
+  @Override
+  public void onStart() {
+    // Default empty.
+  }
+
+  @Override
+  public void onStop() {
+    // Default empty.
+  }
+
+  @Override
+  public void onDestroy() {
+    // Default empty.
+  }
+
+  /**
+   * Indicates that Glide should always wait for any pending layout pass before checking for the
+   * size an {@link View}.
+   *
+   * <p>By default, Glide will only wait for a pending layout pass if it's unable to resolve the
+   * size from the {@link LayoutParams} or valid non-zero values for {@link View#getWidth()} and
+   * {@link View#getHeight()}.
+   *
+   * <p>Because calling this method forces Glide to wait for the layout pass to occur before
+   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load an
+   * image even if it's in the memory cache. The load will happen asynchronously because Glide has
+   * to wait for a layout pass to occur, which won't necessarily happen in the same frame as when
+   * the image is requested. As a result, using this method can resulting in flashing in some cases
+   * and should be used sparingly.
+   *
+   * <p>If the {@link LayoutParams} of the wrapped {@link View} are set to fixed sizes, they will
+   * still be used instead of the {@link View}'s dimensions even if this method is called. This
+   * parameter is a fallback only.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public final CustomViewTarget<T, Z> waitForLayout() {
+    sizeDeterminer.waitForLayout = true;
+    return this;
+  }
+
+  /**
+   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its {@link
+   * android.view.Window} and restarts the {@link Request} when the {@link View} is re-attached from
+   * its {@link android.view.Window}.
+   *
+   * <p>This is an experimental API that may be removed in a future version.
+   *
+   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when
+   * transitioning screens or swapping adapters in scrolling views. However it also substantially
+   * increases the odds that images will not be in memory if users subsequently return to a screen
+   * where images were previously loaded. Whether or not this happens will depend on the number of
+   * images loaded in the new screen and the size of the memory cache. Increasing the size of the
+   * memory cache can improve this behavior but it largely negates the memory benefits of using this
+   * method.
+   *
+   * <p>Use this method with caution and measure your memory usage to ensure that it's actually
+   * improving your memory usage in the cases you care about.
+   */
+  // Public API.
+  @NonNull
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final CustomViewTarget<T, Z> clearOnDetach() {
+    if (attachStateListener != null) {
+      return this;
+    }
+    attachStateListener =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {
+            resumeMyRequest();
+          }
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {
+            pauseMyRequest();
+          }
+        };
+    maybeAddAttachStateListener();
+    return this;
+  }
+
+  /**
+   * Override the android resource id to store temporary state allowing loads to be automatically
+   * cancelled and resources re-used in scrolling lists.
+   *
+   * <p>Unlike {@link ViewTarget}, it is <b>not</b> necessary to set a custom tag id if your app
+   * uses {@link View#setTag(Object)}. It is only necessary if loading several Glide resources into
+   * the same view, for example one foreground and one background view.
+   *
+   * @param tagId The android resource id to use.
+   * @deprecated Using this method prevents clearing the target from working properly. Glide uses
+   *     its own internal tag id so this method should not be necessary. This method is currently a
+   *     no-op.
+   */
+  // Public API.
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  @Deprecated
+  public final CustomViewTarget<T, Z> useTagId(@IdRes int tagId) {
+    return this;
+  }
+
+  /** Returns the wrapped {@link android.view.View}. */
+  @NonNull
+  public final T getView() {
+    return view;
+  }
+
+  /**
+   * Determines the size of the view by first checking {@link android.view.View#getWidth()} and
+   * {@link android.view.View#getHeight()}. If one or both are zero, it then checks the view's
+   * {@link LayoutParams}. If one or both of the params width and height are less than or equal to
+   * zero, it then adds an {@link android.view.ViewTreeObserver.OnPreDrawListener} which waits until
+   * the view has been measured before calling the callback with the view's drawn width and height.
+   *
+   * @param cb {@inheritDoc}
+   */
+  @Override
+  public final void getSize(@NonNull SizeReadyCallback cb) {
+    sizeDeterminer.getSize(cb);
+  }
+
+  @Override
+  public final void removeCallback(@NonNull SizeReadyCallback cb) {
+    sizeDeterminer.removeCallback(cb);
+  }
+
+  @Override
+  public final void onLoadStarted(@Nullable Drawable placeholder) {
+    maybeAddAttachStateListener();
+    onResourceLoading(placeholder);
+  }
+
+  @Override
+  public final void onLoadCleared(@Nullable Drawable placeholder) {
+    sizeDeterminer.clearCallbacksAndListener();
+
+    onResourceCleared(placeholder);
+    if (!isClearedByUs) {
+      maybeRemoveAttachStateListener();
+    }
+  }
+
+  /**
+   * Stores the request using {@link View#setTag(Object)}.
+   *
+   * @param request {@inheritDoc}
+   */
+  @Override
+  public final void setRequest(@Nullable Request request) {
+    setTag(request);
+  }
+
+  /** Returns any stored request using {@link android.view.View#getTag()}. */
+  @Override
+  @Nullable
+  public final Request getRequest() {
+    Object tag = getTag();
+    if (tag != null) {
+      if (tag instanceof Request) {
+        return (Request) tag;
+      } else {
+        throw new IllegalArgumentException("You must not pass non-R.id ids to setTag(id)");
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public String toString() {
+    return "Target for: " + view;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final void resumeMyRequest() {
+    Request request = getRequest();
+    if (request != null && request.isCleared()) {
+      request.begin();
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final void pauseMyRequest() {
+    Request request = getRequest();
+    if (request != null) {
+      isClearedByUs = true;
+      request.clear();
+      isClearedByUs = false;
+    }
+  }
+
+  private void setTag(@Nullable Object tag) {
+    view.setTag(VIEW_TAG_ID, tag);
+  }
+
+  @Nullable
+  private Object getTag() {
+    return view.getTag(VIEW_TAG_ID);
+  }
+
+  private void maybeAddAttachStateListener() {
+    if (attachStateListener == null || isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.addOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = true;
+  }
+
+  private void maybeRemoveAttachStateListener() {
+    if (attachStateListener == null || !isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.removeOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = false;
+  }
+
+  @VisibleForTesting
+  static final class SizeDeterminer {
+    // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
+    private static final int PENDING_SIZE = 0;
+    @VisibleForTesting @Nullable static Integer maxDisplayLength;
+    private final View view;
+    private final List<SizeReadyCallback> cbs = new ArrayList<>();
+    @Synthetic boolean waitForLayout;
+
+    @Nullable private SizeDeterminerLayoutListener layoutListener;
+
+    SizeDeterminer(@NonNull View view) {
+      this.view = view;
+    }
+
+    // Use the maximum to avoid depending on the device's current orientation.
+    private static int getMaxDisplayLength(@NonNull Context context) {
+      if (maxDisplayLength == null) {
+        WindowManager windowManager =
+            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+        Point displayDimensions = new Point();
+        display.getSize(displayDimensions);
+        maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);
+      }
+      return maxDisplayLength;
+    }
+
+    private void notifyCbs(int width, int height) {
+      // One or more callbacks may trigger the removal of one or more additional callbacks, so we
+      // need a copy of the list to avoid a concurrent modification exception. One place this
+      // happens is when a full request completes from the in memory cache while its thumbnail is
+      // still being loaded asynchronously. See #2237.
+      for (SizeReadyCallback cb : new ArrayList<>(cbs)) {
+        cb.onSizeReady(width, height);
+      }
+    }
+
+    @Synthetic
+    void checkCurrentDimens() {
+      if (cbs.isEmpty()) {
+        return;
+      }
+
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (!isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        return;
+      }
+
+      notifyCbs(currentWidth, currentHeight);
+      clearCallbacksAndListener();
+    }
+
+    void getSize(@NonNull SizeReadyCallback cb) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        cb.onSizeReady(currentWidth, currentHeight);
+        return;
+      }
+
+      // We want to notify callbacks in the order they were added and we only expect one or two
+      // callbacks to be added a time, so a List is a reasonable choice.
+      if (!cbs.contains(cb)) {
+        cbs.add(cb);
+      }
+      if (layoutListener == null) {
+        ViewTreeObserver observer = view.getViewTreeObserver();
+        layoutListener = new SizeDeterminerLayoutListener(this);
+        observer.addOnPreDrawListener(layoutListener);
+      }
+    }
+
+    /**
+     * The callback may be called anyway if it is removed by another {@link SizeReadyCallback} or
+     * otherwise removed while we're notifying the list of callbacks.
+     *
+     * <p>See #2237.
+     */
+    void removeCallback(@NonNull SizeReadyCallback cb) {
+      cbs.remove(cb);
+    }
+
+    void clearCallbacksAndListener() {
+      // Keep a reference to the layout attachStateListener and remove it here
+      // rather than having the observer remove itself because the observer
+      // we add the attachStateListener to will be almost immediately merged into
+      // another observer and will therefore never be alive. If we instead
+      // keep a reference to the attachStateListener and remove it here, we get the
+      // current view tree observer and should succeed.
+      ViewTreeObserver observer = view.getViewTreeObserver();
+      if (observer.isAlive()) {
+        observer.removeOnPreDrawListener(layoutListener);
+      }
+      layoutListener = null;
+      cbs.clear();
+    }
+
+    private boolean isViewStateAndSizeValid(int width, int height) {
+      return isDimensionValid(width) && isDimensionValid(height);
+    }
+
+    private int getTargetHeight() {
+      int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;
+      return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);
+    }
+
+    private int getTargetWidth() {
+      int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE;
+      return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding);
+    }
+
+    private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
+      // We consider the View state as valid if the View has non-null layout params and a non-zero
+      // layout params width and height. This is imperfect. We're making an assumption that View
+      // parents will obey their child's layout parameters, which isn't always the case.
+      int adjustedParamSize = paramSize - paddingSize;
+      if (adjustedParamSize > 0) {
+        return adjustedParamSize;
+      }
+
+      // Since we always prefer layout parameters with fixed sizes, even if waitForLayout is true,
+      // we might as well ignore it and just return the layout parameters above if we have them.
+      // Otherwise we should wait for a layout pass before checking the View's dimensions.
+      if (waitForLayout && view.isLayoutRequested()) {
+        return PENDING_SIZE;
+      }
+
+      // We also consider the View state valid if the View has a non-zero width and height. This
+      // means that the View has gone through at least one layout pass. It does not mean the Views
+      // width and height are from the current layout pass. For example, if a View is re-used in
+      // RecyclerView or ListView, this width/height may be from an old position. In some cases
+      // the dimensions of the View at the old position may be different than the dimensions of the
+      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to
+      // change them. Nevertheless, in most cases this should be a reasonable choice.
+      int adjustedViewSize = viewSize - paddingSize;
+      if (adjustedViewSize > 0) {
+        return adjustedViewSize;
+      }
+
+      // Finally we consider the view valid if the layout parameter size is set to wrap_content.
+      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a
+      // coherent choice, it's extremely dangerous because original images may be much too large to
+      // fit in memory or so large that only a couple can fit in memory, causing OOMs. If users want
+      // the original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content
+      // may never resolve to a real size unless we load something, we aim for a square whose length
+      // is the largest screen size. That way we're loading something and that something has some
+      // hope of being downsampled to a size that the device can support. We also log a warning that
+      // tries to explain what Glide is doing and why some alternatives are preferable.
+      // Since WRAP_CONTENT is sometimes used as a default layout parameter, we always wait for
+      // layout to complete before using this fallback parameter (ConstraintLayout among others).
+      if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
+        if (Log.isLoggable(TAG, Log.INFO)) {
+          Log.i(
+              TAG,
+              "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
+                  + " this device's screen dimensions. If you want to load the original image and"
+                  + " are ok with the corresponding memory cost and OOMs (depending on the input"
+                  + " size), use .override(Target.SIZE_ORIGINAL). Otherwise, use"
+                  + " LayoutParams.MATCH_PARENT, set layout_width and layout_height to fixed"
+                  + " dimension, or use .override() with fixed dimensions.");
+        }
+        return getMaxDisplayLength(view.getContext());
+      }
+
+      // If the layout parameters are < padding, the view size is < padding, or the layout
+      // parameters are set to match_parent or wrap_content and no layout has occurred, we should
+      // wait for layout and repeat.
+      return PENDING_SIZE;
+    }
+
+    private boolean isDimensionValid(int size) {
+      return size > 0 || size == SIZE_ORIGINAL;
+    }
+
+    private static final class SizeDeterminerLayoutListener
+        implements ViewTreeObserver.OnPreDrawListener {
+      private final WeakReference<SizeDeterminer> sizeDeterminerRef;
+
+      SizeDeterminerLayoutListener(@NonNull SizeDeterminer sizeDeterminer) {
+        sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
+      }
+
+      @Override
+      public boolean onPreDraw() {
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "OnGlobalLayoutListener called attachStateListener=" + this);
+        }
+        SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
+        if (sizeDeterminer != null) {
+          sizeDeterminer.checkCurrentDimens();
+        }
+        return true;
+      }
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
index 58119e4df..e11b46a05 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
@@ -1,18 +1,20 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
 import android.widget.ImageView;
+import androidx.annotation.Nullable;
 
-/**
- * A target for display {@link Drawable} objects in {@link ImageView}s.
- */
+/** A target for display {@link Drawable} objects in {@link ImageView}s. */
 public class DrawableImageViewTarget extends ImageViewTarget<Drawable> {
 
   public DrawableImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /** @deprecated Use {@link #waitForLayout()} instead. */
+  // Public API.
+  @SuppressWarnings({"unused", "deprecation"})
+  @Deprecated
   public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
index 34a99302f..41951dcc9 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
@@ -6,11 +6,16 @@
 /**
  * Efficiently displays multiple Drawables loaded serially into a single {@link android.view.View}.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class DrawableThumbnailImageViewTarget extends ThumbnailImageViewTarget<Drawable> {
   public DrawableThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /** @deprecated Use {@link #waitForLayout()} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public DrawableThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
index a1f56e1af..798acd84d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.request.target;
 
-import android.annotation.TargetApi;
 import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
@@ -10,6 +9,8 @@
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import androidx.annotation.NonNull;
+import androidx.annotation.RequiresApi;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 
@@ -27,6 +28,8 @@
   private State state;
   private boolean mutated;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public FixedSizeDrawable(Drawable wrapped, int width, int height) {
     this(new State(wrapped.getConstantState(), width, height), wrapped);
   }
@@ -51,7 +54,7 @@ public void setBounds(int left, int top, int right, int bottom) {
   }
 
   @Override
-  public void setBounds(Rect bounds) {
+  public void setBounds(@NonNull Rect bounds) {
     super.setBounds(bounds);
     this.bounds.set(bounds);
     updateMatrix();
@@ -87,14 +90,14 @@ public Callback getCallback() {
     return wrapped.getCallback();
   }
 
-  @TargetApi(Build.VERSION_CODES.KITKAT)
+  @RequiresApi(Build.VERSION_CODES.KITKAT)
   @Override
   public int getAlpha() {
     return wrapped.getAlpha();
   }
 
   @Override
-  public void setColorFilter(int color, PorterDuff.Mode mode) {
+  public void setColorFilter(int color, @NonNull PorterDuff.Mode mode) {
     wrapped.setColorFilter(color, mode);
   }
 
@@ -103,6 +106,7 @@ public void clearColorFilter() {
     wrapped.clearColorFilter();
   }
 
+  @NonNull
   @Override
   public Drawable getCurrent() {
     return wrapped.getCurrent();
@@ -134,7 +138,7 @@ public int getMinimumHeight() {
   }
 
   @Override
-  public boolean getPadding(Rect padding) {
+  public boolean getPadding(@NonNull Rect padding) {
     return wrapped.getPadding(padding);
   }
 
@@ -145,19 +149,19 @@ public void invalidateSelf() {
   }
 
   @Override
-  public void unscheduleSelf(Runnable what) {
+  public void unscheduleSelf(@NonNull Runnable what) {
     super.unscheduleSelf(what);
     wrapped.unscheduleSelf(what);
   }
 
   @Override
-  public void scheduleSelf(Runnable what, long when) {
+  public void scheduleSelf(@NonNull Runnable what, long when) {
     super.scheduleSelf(what, when);
     wrapped.scheduleSelf(what, when);
   }
 
   @Override
-  public void draw(Canvas canvas) {
+  public void draw(@NonNull Canvas canvas) {
     canvas.save();
     canvas.concat(matrix);
     wrapped.draw(canvas);
@@ -179,6 +183,7 @@ public int getOpacity() {
     return wrapped.getOpacity();
   }
 
+  @NonNull
   @Override
   public Drawable mutate() {
     if (!mutated && super.mutate() == this) {
@@ -194,7 +199,7 @@ public ConstantState getConstantState() {
     return state;
   }
 
-  static class State extends ConstantState {
+  static final class State extends ConstantState {
     private final ConstantState wrapped;
     @Synthetic final int width;
     @Synthetic final int height;
@@ -209,11 +214,13 @@ public ConstantState getConstantState() {
       this.height = height;
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable() {
       return new FixedSizeDrawable(this, wrapped.newDrawable());
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable(Resources res) {
       return new FixedSizeDrawable(this, wrapped.newDrawable(res));
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index 68a37e401..ce53193f7 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -2,8 +2,9 @@
 
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.request.transition.Transition;
 
 /**
@@ -11,18 +12,22 @@
  * android.widget.ImageView}s.
  *
  * @param <Z> The type of resource that this target will display in the wrapped {@link
- *            android.widget.ImageView}.
+ *     android.widget.ImageView}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z>
     implements Transition.ViewAdapter {
 
-  @Nullable
-  private Animatable animatable;
+  @Nullable private Animatable animatable;
 
   public ImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /** @deprecated Use {@link #waitForLayout()} instead. */
+  @SuppressWarnings({"deprecation"})
+  @Deprecated
   public ImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
@@ -83,12 +88,15 @@ public void onLoadFailed(@Nullable Drawable errorDrawable) {
   @Override
   public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
+    if (animatable != null) {
+      animatable.stop();
+    }
     setResourceInternal(null);
     setDrawable(placeholder);
   }
 
   @Override
-  public void onResourceReady(Z resource, @Nullable Transition<? super Z> transition) {
+  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
     if (transition == null || !transition.transition(resource, this)) {
       setResourceInternal(resource);
     } else {
@@ -111,8 +119,10 @@ public void onStop() {
   }
 
   private void setResourceInternal(@Nullable Z resource) {
-    maybeUpdateAnimatable(resource);
+    // Order matters here. Set the resource first to make sure that the Drawable has a valid and
+    // non-null Callback before starting it.
     setResource(resource);
+    maybeUpdateAnimatable(resource);
   }
 
   private void maybeUpdateAnimatable(@Nullable Z resource) {
@@ -126,4 +136,3 @@ private void maybeUpdateAnimatable(@Nullable Z resource) {
 
   protected abstract void setResource(@Nullable Z resource);
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 33454b46a..a073febce 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -3,19 +3,21 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
 
 /**
- * A factory responsible for producing the correct type of
- * {@link com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
+ * A factory responsible for producing the correct type of {@link
+ * com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
  */
 public class ImageViewTargetFactory {
-
+  @NonNull
   @SuppressWarnings("unchecked")
-  public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {
+  public <Z> ViewTarget<ImageView, Z> buildTarget(
+      @NonNull ImageView view, @NonNull Class<Z> clazz) {
     if (Bitmap.class.equals(clazz)) {
-      return (Target<Z>) new BitmapImageViewTarget(view);
+      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
     } else if (Drawable.class.isAssignableFrom(clazz)) {
-      return (Target<Z>) new DrawableImageViewTarget(view);
+      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
     } else {
       throw new IllegalArgumentException(
           "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index 481523111..d958f6220 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.request.target;
 
-
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.widget.RemoteViews;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
 
@@ -13,10 +15,12 @@
  * This class is used to display downloaded Bitmap inside an ImageView of a Notification through
  * RemoteViews.
  *
- * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
- * for every subsequent load. </p>
+ * <p>Note - For cancellation to work correctly, you must pass in the same instance of this class
+ * for every subsequent load.
  */
-public class NotificationTarget extends SimpleTarget<Bitmap> {
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
+public class NotificationTarget extends CustomTarget<Bitmap> {
   private final RemoteViews remoteViews;
   private final Context context;
   private final int notificationId;
@@ -29,57 +33,76 @@
    * Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target width and
    * height.
    *
-   * @param context         Context to use in the AppWidgetManager initialization.
-   * @param viewId          The id of the ImageView view that will load the image.
-   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
-   *                        bitmap.
-   * @param notification    The Notification object that we want to update.
-   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+   * @param notification The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    */
-  public NotificationTarget(Context context,
-      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
+  public NotificationTarget(
+      Context context,
+      int viewId,
+      RemoteViews remoteViews,
+      Notification notification,
+      int notificationId) {
     this(context, viewId, remoteViews, notification, notificationId, null);
   }
 
   /**
    * Constructor using a Notification object, a notificationId, and a notificationTag to get a
-   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the
-   * target width and height.
+   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target
+   * width and height.
    *
-   * @param context         Context to use in the AppWidgetManager initialization.
-   * @param viewId          The id of the ImageView view that will load the image.
-   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
-   *                        bitmap.
-   * @param notification    The Notification object that we want to update.
-   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+   * @param notification The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap.
-   *                        May be {@code null}.
+   *     May be {@code null}.
    */
-  public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,
-      Notification notification, int notificationId, String notificationTag) {
-    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,
-      notificationTag);
+  public NotificationTarget(
+      Context context,
+      int viewId,
+      RemoteViews remoteViews,
+      Notification notification,
+      int notificationId,
+      String notificationTag) {
+    this(
+        context,
+        SIZE_ORIGINAL,
+        SIZE_ORIGINAL,
+        viewId,
+        remoteViews,
+        notification,
+        notificationId,
+        notificationTag);
   }
 
   /**
    * Constructor using a Notification object, a notificationId, and a notificationTag to get a
    * handle on the Notification in order to update it.
    *
-   * @param context         Context to use in the AppWidgetManager initialization.
-   * @param width           Desired width of the bitmap that will be loaded.(Need to be manually put
-   *                        because of RemoteViews limitations.)
-   * @param height          Desired height of the bitmap that will be loaded. (Need to be manually
-   *                        put because of RemoteViews limitations.)
-   * @param viewId          The id of the ImageView view that will load the image.
-   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
-   *                        bitmap.
-   * @param notification    The Notification object that we want to update.
-   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
-   * @param notificationTag The notificationTag of the Notification that we want to load the
-   *                        Bitmap. May be {@code null}.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param width Desired width of the bitmap that will be loaded.(Need to be manually put because
+   *     of RemoteViews limitations.)
+   * @param height Desired height of the bitmap that will be loaded. (Need to be manually put
+   *     because of RemoteViews limitations.)
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+   * @param notification The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap.
+   *     May be {@code null}.
    */
-  public NotificationTarget(Context context, int width, int height, int viewId,
-      RemoteViews remoteViews, Notification notification, int notificationId,
+  public NotificationTarget(
+      Context context,
+      int width,
+      int height,
+      int viewId,
+      RemoteViews remoteViews,
+      Notification notification,
+      int notificationId,
       String notificationTag) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context must not be null!");
@@ -92,18 +115,27 @@ public NotificationTarget(Context context, int width, int height, int viewId,
     this.notificationTag = notificationTag;
   }
 
-  /**
-   * Updates the Notification after the Bitmap resource is loaded.
-   */
+  /** Updates the Notification after the Bitmap resource is loaded. */
   private void update() {
     NotificationManager manager =
         (NotificationManager) this.context.getSystemService(Context.NOTIFICATION_SERVICE);
-    manager.notify(this.notificationTag, this.notificationId, this.notification);
+    Preconditions.checkNotNull(manager)
+        .notify(this.notificationTag, this.notificationId, this.notification);
   }
 
   @Override
-  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
-    this.remoteViews.setImageViewBitmap(this.viewId, resource);
+  public void onResourceReady(
+      @NonNull Bitmap resource, @Nullable Transition<? super Bitmap> transition) {
+    setBitmap(resource);
+  }
+
+  @Override
+  public void onLoadCleared(@Nullable Drawable placeholder) {
+    setBitmap(null);
+  }
+
+  private void setBitmap(@Nullable Bitmap bitmap) {
+    this.remoteViews.setImageViewBitmap(this.viewId, bitmap);
     this.update();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
index caab4ac19..952100532 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
@@ -1,11 +1,15 @@
 package com.bumptech.glide.request.target;
 
+import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.os.Handler.Callback;
 import android.os.Looper;
 import android.os.Message;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A one time use {@link com.bumptech.glide.request.target.Target} class that loads a resource into
@@ -13,27 +17,30 @@
  *
  * @param <Z> The type of resource that will be loaded into memory.
  */
-public final class PreloadTarget<Z> extends SimpleTarget<Z> {
+public final class PreloadTarget<Z> extends CustomTarget<Z> {
   private static final int MESSAGE_CLEAR = 1;
-  private static final Handler HANDLER = new Handler(Looper.getMainLooper(), new Callback() {
-    @Override
-    public boolean handleMessage(Message message) {
-      if (message.what == MESSAGE_CLEAR) {
-        ((PreloadTarget<?>) message.obj).clear();
-        return true;
-      }
-      return false;
-    }
-  });
+  private static final Handler HANDLER =
+      new Handler(
+          Looper.getMainLooper(),
+          new Callback() {
+            @Override
+            public boolean handleMessage(Message message) {
+              if (message.what == MESSAGE_CLEAR) {
+                ((PreloadTarget<?>) message.obj).clear();
+                return true;
+              }
+              return false;
+            }
+          });
 
   private final RequestManager requestManager;
 
   /**
    * Returns a PreloadTarget.
    *
-   * @param width  The width in pixels of the desired resource.
+   * @param width The width in pixels of the desired resource.
    * @param height The height in pixels of the desired resource.
-   * @param <Z>    The type of the desired resource.
+   * @param <Z> The type of the desired resource.
    */
   public static <Z> PreloadTarget<Z> obtain(RequestManager requestManager, int width, int height) {
     return new PreloadTarget<>(requestManager, width, height);
@@ -45,11 +52,18 @@ private PreloadTarget(RequestManager requestManager, int width, int height) {
   }
 
   @Override
-  public void onResourceReady(Z resource, Transition<? super Z> transition) {
+  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
     HANDLER.obtainMessage(MESSAGE_CLEAR, this).sendToTarget();
   }
 
-  private void clear() {
+  @Override
+  public void onLoadCleared(@Nullable Drawable placeholder) {
+    // Do nothing, we don't retain a reference to our resource.
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  void clear() {
     requestManager.clear(this);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index fd1baf5b7..388253dcc 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -1,30 +1,72 @@
 package com.bumptech.glide.request.target;
 
+import android.graphics.drawable.Drawable;
+import android.view.View;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.util.Util;
 
 /**
- * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop)
+ * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually no-op)
  * implementations of non essential methods that allows the caller to specify an exact width/height.
  * Typically use cases look something like this:
+ *
  * <pre>
  * <code>
- * Glide.load("http://somefakeurl.com/fakeImage.jpeg")
- *      .asBitmap()
- *      .withFitCenter()
- *      .into(new SimpleTarget<Bitmap>(250, 250) {
+ * Target<Bitmap> target =
+ *     Glide.with(fragment)
+ *       .asBitmap()
+ *       .load("http://somefakeurl.com/fakeImage.jpeg")
+ *       .apply(fitCenterTransform())
+ *       .into(new SimpleTarget<Bitmap>(250, 250) {
  *
- *          {@literal @Override}
- *          public void onResourceReady(Bitmap resource, GlideAnimation<Bitmap> glideAnimation) {
- *              // Do something with bitmap here.
- *          }
+ *         {@literal @Override}
+ *         public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+ *           // Do something with bitmap here.
+ *         }
  *
- *      });
+ *       });
  * }
+ * // At some later point, clear the Target to release the resources, prevent load queues from
+ * // blowing out proportion, and to improve load times for future requests:
+ * Glide.with(fragment).clear(target);
  * </code>
  * </pre>
  *
+ * <p><em>Warning!</em> this class is extremely prone to mis-use. Use SimpleTarget only as a last
+ * resort. {@link ViewTarget} or a subclass of {@link ViewTarget} is almost always a better choice.
+ *
+ * <p><em>Don't forget to clear instances of this class!</em>. If you must use this class, keep in
+ * mind that unlike {@link ViewTarget} it is not safe to load into new instances of this class
+ * repeatedly if every instance updates the same underlying {@link View} or caller. If you need to
+ * load into the same {@link View} or caller repeatedly using this class, always retain a reference
+ * to the previous instance and either call {@link com.bumptech.glide.RequestManager#clear(Target)}
+ * on the old instance before starting a new load or you must re-use the old instance for the new
+ * load. Glide's {@link com.bumptech.glide.RequestBuilder#into(Target)} method returns the {@link
+ * Target} instance you provided to make retaining a reference to the {@link Target} as easy as
+ * possible. That said, you must wait until you're completely finished with the resource before
+ * calling {@link com.bumptech.glide.RequestManager#clear(Target)} and you should always null out
+ * references to any loaded resources in {@link Target#onLoadCleared(Drawable)}.
+ *
+ * <p>Always try to provide a size when using this class. Use {@link SimpleTarget#SimpleTarget(int,
+ * int)} whenever possible with values that are <em>not</em> {@link Target#SIZE_ORIGINAL}. Using
+ * {@link Target#SIZE_ORIGINAL} is unsafe if you're loading large images or are running your
+ * application on older or memory constrained devices because it can cause Glide to load very large
+ * images into memory. In some cases those images may throw {@link OutOfMemoryError} and in others
+ * they may exceed the texture limit for the device, which will prevent them from being rendered.
+ * Providing a valid size allows Glide to downsample large images, which can avoid issues with
+ * texture size or memory limitations. You don't have to worry about providing a size in most cases
+ * if you use {@link ViewTarget} so prefer {@link ViewTarget} over this class whenver possible.
+ *
+ * @see <a href="http://bumptech.github.io/glide/doc/targets.html">Glide's Target docs page</a>
  * @param <Z> The type of resource that this target will receive.
+ * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if
+ *     in the background
+ *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a {@link
+ *     CustomTarget} for any specialized use-cases. Using {@link SimpleTarget} or {@link BaseTarget}
+ *     is unsafe if the user does not implement {@link #onLoadCleared}, resulting in recycled
+ *     bitmaps being referenced from the UI and hard to root-cause crashes.
  */
+@Deprecated
 public abstract class SimpleTarget<Z> extends BaseTarget<Z> {
   private final int width;
   private final int height;
@@ -33,6 +75,8 @@
    * Constructor for the target that uses {@link Target#SIZE_ORIGINAL} as the target width and
    * height.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public SimpleTarget() {
     this(SIZE_ORIGINAL, SIZE_ORIGINAL);
   }
@@ -41,9 +85,11 @@ public SimpleTarget() {
    * Constructor for the target that takes the desired dimensions of the decoded and/or transformed
    * resource.
    *
-   * @param width  The width in pixels of the desired resource.
+   * @param width The width in pixels of the desired resource.
    * @param height The height in pixels of the desired resource.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public SimpleTarget(int width, int height) {
     this.width = width;
     this.height = height;
@@ -55,18 +101,22 @@ public SimpleTarget(int width, int height) {
    * @param cb {@inheritDoc}
    */
   @Override
-  public final void getSize(SizeReadyCallback cb) {
+  public final void getSize(@NonNull SizeReadyCallback cb) {
     if (!Util.isValidDimensions(width, height)) {
       throw new IllegalArgumentException(
-          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: "
-              + width + " and height: " + height + ", either provide dimensions in the constructor"
+          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given"
+              + " width: "
+              + width
+              + " and height: "
+              + height
+              + ", either provide dimensions in the constructor"
               + " or call override()");
     }
     cb.onSizeReady(width, height);
   }
 
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     // Do nothing, we never retain a reference to the callback.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java b/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
index 2ff5b19a2..238ea2aa8 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
@@ -8,10 +8,10 @@
   /**
    * A callback called on the main thread.
    *
-   * @param width  The width in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate
-   *               that we want the resource at its original width.
+   * @param width The width in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate
+   *     that we want the resource at its original width.
    * @param height The height in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate
-   *               that we want the resource at its original height.
+   *     that we want the resource at its original height.
    */
   void onSizeReady(int width, int height);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index dbdbc4779..292b705a6 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.manager.LifecycleListener;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
@@ -10,49 +11,49 @@
  * An interface that Glide can load a resource into and notify of relevant lifecycle events during a
  * load.
  *
- * <p> The lifecycle events in this class are as follows: <ul> <li>onLoadStarted</li>
- * <li>onResourceReady</li> <li>onLoadCleared</li> <li>onLoadFailed</li> </ul>
+ * <p>The lifecycle events in this class are as follows:
+ *
+ * <ul>
+ *   <li>onLoadStarted
+ *   <li>onResourceReady
+ *   <li>onLoadCleared
+ *   <li>onLoadFailed
+ * </ul>
  *
  * The typical lifecycle is onLoadStarted -> onResourceReady or onLoadFailed -> onLoadCleared.
  * However, there are no guarantees. onLoadStarted may not be called if the resource is in memory or
  * if the load will fail because of a null model object. onLoadCleared similarly may never be called
- * if the target is never cleared. See the docs for the individual methods for details. </p>
+ * if the target is never cleared. See the docs for the individual methods for details.
  *
  * @param <R> The type of resource the target can display.
  */
 public interface Target<R> extends LifecycleListener {
-  /**
-   * Indicates that we want the resource in its original unmodified width and/or height.
-   */
+  /** Indicates that we want the resource in its original unmodified width and/or height. */
   int SIZE_ORIGINAL = Integer.MIN_VALUE;
 
   /**
    * A lifecycle callback that is called when a load is started.
    *
-   * <p> Note - This may not be called for every load, it is possible for example for loads to fail
+   * <p>Note - This may not be called for every load, it is possible for example for loads to fail
    * before the load starts (when the model object is null).
    *
-   * <p> Note - This method may be called multiple times before any other lifecycle method is
-   * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
-   * restart may cause a call here.
-   *
-   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
-   * Transition)} is no longer displayed before redrawing the container (usually a View) or
-   * changing its visibility.
+   * <p>Note - This method may be called multiple times before any other lifecycle method is called.
+   * Loads can be paused and restarted due to lifecycle or connectivity events and each restart may
+   * cause a call here.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
   void onLoadStarted(@Nullable Drawable placeholder);
 
   /**
-   * A lifecycle callback that is called when a load fails.
+   * A <b>mandatory</b> lifecycle callback that is called when a load fails.
    *
-   * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
-   * } if the model object is null.
+   * <p>Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable) }
+   * if the model object is null.
    *
-   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
-   * Transition)} is no longer displayed before redrawing the container (usually a View) or
-   * changing its visibility.
+   * <p>You <b>must</b> ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer used before redrawing the container (usually a View) or changing its
+   * visibility.
    *
    * @param errorDrawable The error drawable to optionally show, or null.
    */
@@ -63,14 +64,15 @@
    *
    * @param resource the loaded resource.
    */
-  void onResourceReady(R resource, Transition<? super R> transition);
+  void onResourceReady(@NonNull R resource, @Nullable Transition<? super R> transition);
 
   /**
-   * A lifecycle callback that is called when a load is cancelled and its resources are freed.
+   * A <b>mandatory</b> lifecycle callback that is called when a load is cancelled and its resources
+   * are freed.
    *
-   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
-   * Transition)} is no longer displayed before redrawing the container (usually a View) or
-   * changing its visibility.
+   * <p>You <b>must</b> ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer used before redrawing the container (usually a View) or changing its
+   * visibility.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
@@ -81,23 +83,19 @@
    *
    * @param cb The callback that must be called when the size of the target has been determined
    */
-  void getSize(SizeReadyCallback cb);
+  void getSize(@NonNull SizeReadyCallback cb);
 
   /**
    * Removes the given callback from the pending set if it's still retained.
    *
    * @param cb The callback to remove.
    */
-  void removeCallback(SizeReadyCallback cb);
+  void removeCallback(@NonNull SizeReadyCallback cb);
 
-  /**
-   * Sets the current request for this target to retain, should not be called outside of Glide.
-   */
+  /** Sets the current request for this target to retain, should not be called outside of Glide. */
   void setRequest(@Nullable Request request);
 
-  /**
-   * Retrieves the current request for this target, should not be called outside of Glide.
-   */
+  /** Retrieves the current request for this target, should not be called outside of Glide. */
   @Nullable
   Request getRequest();
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
index 0bce1750d..d8b2689ea 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
@@ -1,31 +1,35 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+import androidx.annotation.Nullable;
 
 /**
- * Avoids extra calls to {@link android.view.View#requestLayout} when loading more than once
- * image into an {@link android.widget.ImageView} with fixed dimensions.
+ * Avoids extra calls to {@link android.view.View#requestLayout} when loading more than once image
+ * into an {@link android.widget.ImageView} with fixed dimensions.
  *
- * <p>Typically it makes sense
- * to use this class when loading multiple images with the {@link
+ * <p>Typically it makes sense to use this class when loading multiple images with the {@link
  * com.bumptech.glide.RequestBuilder#thumbnail(com.bumptech.glide.RequestBuilder)} API into views in
  * a scrolling list like ListView, GridView, or RecyclerView.
  *
- * <p>{@link FixedSizeDrawable} may cause skewing or other undesirable behavior depending on
- * your images, views, and scaling. If this occurs, consider {@link DrawableImageViewTarget} or
- * {@link BitmapImageViewTarget} as alternatives.
+ * <p>{@link FixedSizeDrawable} may cause skewing or other undesirable behavior depending on your
+ * images, views, and scaling. If this occurs, consider {@link DrawableImageViewTarget} or {@link
+ * BitmapImageViewTarget} as alternatives.
  *
  * @param <T> The type of resource that will be displayed in the ImageView.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class ThumbnailImageViewTarget<T> extends ImageViewTarget<T> {
 
   public ThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /** @deprecated Use {@link #waitForLayout()} insetad. */
+  @Deprecated
+  @SuppressWarnings({"deprecation"})
   public ThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
     super(view, waitForLayout);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index d2f97dca2..4f78dd97c 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -3,14 +3,18 @@
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
-import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import android.view.Display;
 import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
 import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
+import androidx.annotation.CallSuper;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.bumptech.glide.R;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
@@ -23,54 +27,178 @@
  * provides default implementations for most most methods and can determine the size of views using
  * a {@link android.view.ViewTreeObserver.OnDrawListener}.
  *
- * <p> To detect {@link View} reuse in {@link android.widget.ListView} or any {@link
+ * <p>To detect {@link View} reuse in {@link android.widget.ListView} or any {@link
  * android.view.ViewGroup} that reuses views, this class uses the {@link View#setTag(Object)} method
  * to store some metadata so that if a view is reused, any previous loads or resources from previous
- * loads can be cancelled or reused. </p>
+ * loads can be cancelled or reused.
  *
- * <p> Any calls to {@link View#setTag(Object)}} on a View given to this class will result in
+ * <p>Any calls to {@link View#setTag(Object)}} on a View given to this class will result in
  * excessive allocations and and/or {@link IllegalArgumentException}s. If you must call {@link
- * View#setTag(Object)} on a view, consider using {@link BaseTarget} or {@link SimpleTarget}
- * instead. </p>
+ * View#setTag(Object)} on a view, use {@link #setTagId(int)} to specify a custom tag for Glide to
+ * use.
  *
- * <p> Subclasses must call super in {@link #onLoadCleared(Drawable)} </p>
+ * <p>Subclasses must call super in {@link #onLoadCleared(Drawable)}
  *
  * @param <T> The specific subclass of view wrapped by this target.
  * @param <Z> The resource type this target will receive.
+ * @deprecated Use {@link CustomViewTarget}. Using this class is unsafe without implementing {@link
+ *     #onLoadCleared} and results in recycled bitmaps being referenced from the UI and hard to
+ *     root-cause crashes.
  */
+@Deprecated
 public abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {
   private static final String TAG = "ViewTarget";
-  private static boolean isTagUsedAtLeastOnce = false;
-  @Nullable private static Integer tagId = null;
+  private static boolean isTagUsedAtLeastOnce;
+  private static int tagId = R.id.glide_custom_view_target_tag;
 
   protected final T view;
   private final SizeDeterminer sizeDeterminer;
+  @Nullable private OnAttachStateChangeListener attachStateListener;
+  private boolean isClearedByUs;
+  private boolean isAttachStateListenerAdded;
+
+  /** Constructor that defaults {@code waitForLayout} to {@code false}. */
+  public ViewTarget(@NonNull T view) {
+    this.view = Preconditions.checkNotNull(view);
+    sizeDeterminer = new SizeDeterminer(view);
+  }
 
   /**
-   * Constructor that defaults {@code waitForLayout} to {@code false}.
+   * @param waitForLayout If set to {@code true}, Glide will always wait for any pending layout pass
+   *     before checking for the size a View. If set to {@code false} Glide will only wait for a
+   *     pending layout pass if it's unable to resolve the size from layout parameters or an
+   *     existing View size. Because setting this parameter to {@code true} forces Glide to wait for
+   *     the layout pass to occur before starting the load, setting this parameter to {@code true}
+   *     can cause flashing in some cases and should be used sparingly. If layout parameters are set
+   *     to fixed sizes, they will still be used instead of the View's dimensions even if this
+   *     parameter is set to {@code true}. This parameter is a fallback only.
+   * @deprecated Use {@link #waitForLayout()} instead.
    */
-  public ViewTarget(T view) {
-    this(view, false /*waitForLayout*/);
+  @SuppressWarnings("WeakerAccess") // Public API
+  @Deprecated
+  public ViewTarget(@NonNull T view, boolean waitForLayout) {
+    this(view);
+    if (waitForLayout) {
+      waitForLayout();
+    }
   }
 
   /**
-   * @param waitForLayout If set to {@code true}, Glide will always wait for any pending layout pass
-   * before checking for the size a View. If set to {@code false} Glide will only wait for a pending
-   * layout pass if it's unable to resolve the size from layout parameters or an existing View size.
-   * Because setting this parameter to {@code true} forces Glide to wait for the layout pass to
-   * occur before starting the load, setting this parameter to {@code true} can cause flashing in
-   * some cases and should be used sparingly. If layout parameters are set to fixed sizes, they will
-   * still be used instead of the View's dimensions even if this parameter is set to {@code true}.
-   * This parameter is a fallback only.
+   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its {@link
+   * android.view.Window} and restarts the {@link Request} when the {@link View} is re-attached from
+   * its {@link android.view.Window}.
+   *
+   * <p>This is an experimental API that may be removed in a future version.
+   *
+   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when
+   * transitioning screens or swapping adapters in scrolling views. However it also substantially
+   * increases the odds that images will not be in memory if users subsequently return to a screen
+   * where images were previously loaded. Whether or not this happens will depend on the number of
+   * images loaded in the new screen and the size of the memory cache. Increasing the size of the
+   * memory cache can improve this behavior but it largely negates the memory benefits of using this
+   * method.
+   *
+   * <p>Use this method with caution and measure your memory usage to ensure that it's actually
+   * improving your memory usage in the cases you care about.
    */
-  public ViewTarget(T view, boolean waitForLayout) {
-    this.view = Preconditions.checkNotNull(view);
-    sizeDeterminer = new SizeDeterminer(view, waitForLayout);
+  // Public API.
+  @NonNull
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final ViewTarget<T, Z> clearOnDetach() {
+    if (attachStateListener != null) {
+      return this;
+    }
+    attachStateListener =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {
+            resumeMyRequest();
+          }
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {
+            pauseMyRequest();
+          }
+        };
+    maybeAddAttachStateListener();
+    return this;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  void resumeMyRequest() {
+    Request request = getRequest();
+    if (request != null && request.isCleared()) {
+      request.begin();
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  void pauseMyRequest() {
+    Request request = getRequest();
+    // If the Request were cleared by the developer, it would be null here. The only way it's
+    // present is if the developer hasn't previously cleared this Target.
+    if (request != null) {
+      isClearedByUs = true;
+      request.clear();
+      isClearedByUs = false;
+    }
   }
 
   /**
-   * Returns the wrapped {@link android.view.View}.
+   * Indicates that Glide should always wait for any pending layout pass before checking for the
+   * size an {@link View}.
+   *
+   * <p>By default, Glide will only wait for a pending layout pass if it's unable to resolve the
+   * size from the {@link LayoutParams} or valid non-zero values for {@link View#getWidth()} and
+   * {@link View#getHeight()}.
+   *
+   * <p>Because calling this method forces Glide to wait for the layout pass to occur before
+   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load an
+   * image even if it's in the memory cache. The load will happen asynchronously because Glide has
+   * to wait for a layout pass to occur, which won't necessarily happen in the same frame as when
+   * the image is requested. As a result, using this method can resulting in flashing in some cases
+   * and should be used sparingly.
+   *
+   * <p>If the {@link LayoutParams} of the wrapped {@link View} are set to fixed sizes, they will
+   * still be used instead of the {@link View}'s dimensions even if this method is called. This
+   * parameter is a fallback only.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public final ViewTarget<T, Z> waitForLayout() {
+    sizeDeterminer.waitForLayout = true;
+    return this;
+  }
+
+  @CallSuper
+  @Override
+  public void onLoadStarted(@Nullable Drawable placeholder) {
+    super.onLoadStarted(placeholder);
+    maybeAddAttachStateListener();
+  }
+
+  private void maybeAddAttachStateListener() {
+    if (attachStateListener == null || isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.addOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = true;
+  }
+
+  private void maybeRemoveAttachStateListener() {
+    if (attachStateListener == null || !isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.removeOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = false;
+  }
+
+  /** Returns the wrapped {@link android.view.View}. */
+  @NonNull
   public T getView() {
     return view;
   }
@@ -84,20 +212,27 @@ public T getView() {
    *
    * @param cb {@inheritDoc}
    */
+  @CallSuper
   @Override
-  public void getSize(SizeReadyCallback cb) {
+  public void getSize(@NonNull SizeReadyCallback cb) {
     sizeDeterminer.getSize(cb);
   }
 
+  @CallSuper
   @Override
-  public void removeCallback(SizeReadyCallback cb) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
     sizeDeterminer.removeCallback(cb);
   }
 
+  @CallSuper
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
     sizeDeterminer.clearCallbacksAndListener();
+
+    if (!isClearedByUs) {
+      maybeRemoveAttachStateListener();
+    }
   }
 
   /**
@@ -113,13 +248,13 @@ public void setRequest(@Nullable Request request) {
   /**
    * Returns any stored request using {@link android.view.View#getTag()}.
    *
-   * <p> For Glide to function correctly, Glide must be the only thing that calls {@link
+   * <p>For Glide to function correctly, Glide must be the only thing that calls {@link
    * View#setTag(Object)}. If the tag is cleared or put to another object type, Glide will not be
    * able to retrieve and cancel previous loads which will not only prevent Glide from reusing
    * resource, but will also result in incorrect images being loaded and lots of flashing of images
    * in lists. As a result, this will throw an {@link java.lang.IllegalArgumentException} if {@link
    * android.view.View#getTag()}} returns a non null object that is not an {@link
-   * com.bumptech.glide.request.Request}. </p>
+   * com.bumptech.glide.request.Request}.
    */
   @Override
   @Nullable
@@ -143,73 +278,64 @@ public String toString() {
   }
 
   private void setTag(@Nullable Object tag) {
-    if (tagId == null) {
-      isTagUsedAtLeastOnce = true;
-      view.setTag(tag);
-    } else {
-      view.setTag(tagId, tag);
-    }
+    isTagUsedAtLeastOnce = true;
+    view.setTag(tagId, tag);
   }
 
   @Nullable
   private Object getTag() {
-    if (tagId == null) {
-      return view.getTag();
-    } else {
-      return view.getTag(tagId);
-    }
+    return view.getTag(tagId);
   }
 
   /**
-   * Sets the android resource id to use in conjunction with {@link View#setTag(int, Object)}
-   * to store temporary state allowing loads to be automatically cancelled and resources re-used
-   * in scrolling lists.
+   * Sets the android resource id to use in conjunction with {@link View#setTag(int, Object)} to
+   * store temporary state allowing loads to be automatically cancelled and resources re-used in
+   * scrolling lists.
    *
-   * <p>
-   *   If no tag id is set, Glide will use {@link View#setTag(Object)}.
-   * </p>
+   * <p>If no tag id is set, Glide will use {@link View#setTag(Object)}.
    *
-   * <p>
-   *   Warning: prior to Android 4.0 tags were stored in a static map. Using this method prior
-   *   to Android 4.0 may cause memory leaks and isn't recommended. If you do use this method
-   *   on older versions, be sure to call {@link com.bumptech.glide.RequestManager#clear(View)} on
-   *   any view you start a load into to ensure that the static state is removed.
-   * </p>
+   * <p>Warning: prior to Android 4.0 tags were stored in a static map. Using this method prior to
+   * Android 4.0 may cause memory leaks and isn't recommended. If you do use this method on older
+   * versions, be sure to call {@link com.bumptech.glide.RequestManager#clear(View)} on any view you
+   * start a load into to ensure that the static state is removed.
    *
+   * @deprecated Glide uses it's own default tag id, so there's no need to specify your own. This
+   *     method will be removed in a future version.
    * @param tagId The android resource to use.
    */
+  // Public API.
+  @SuppressWarnings("unused")
+  @Deprecated
   public static void setTagId(int tagId) {
-      if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {
-          throw new IllegalArgumentException("You cannot set the tag id more than once or change"
+    if (isTagUsedAtLeastOnce) {
+      throw new IllegalArgumentException(
+          "You cannot set the tag id more than once or change"
               + " the tag id after the first request has been made");
-      }
-      ViewTarget.tagId = tagId;
+    }
+    ViewTarget.tagId = tagId;
   }
 
   @VisibleForTesting
   static final class SizeDeterminer {
     // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
-    @VisibleForTesting
-    @Nullable
-    static Integer maxDisplayLength;
+    @VisibleForTesting @Nullable static Integer maxDisplayLength;
     private final View view;
-    private final boolean waitForLayout;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
+    @Synthetic boolean waitForLayout;
 
     @Nullable private SizeDeterminerLayoutListener layoutListener;
 
-    SizeDeterminer(View view, boolean waitForLayout) {
+    SizeDeterminer(@NonNull View view) {
       this.view = view;
-      this.waitForLayout = waitForLayout;
     }
 
     // Use the maximum to avoid depending on the device's current orientation.
-    private static int getMaxDisplayLength(Context context) {
+    private static int getMaxDisplayLength(@NonNull Context context) {
       if (maxDisplayLength == null) {
         WindowManager windowManager =
             (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-        Display display = windowManager.getDefaultDisplay();
+        Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
         Point displayDimensions = new Point();
         display.getSize(displayDimensions);
         maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);
@@ -243,7 +369,7 @@ void checkCurrentDimens() {
       clearCallbacksAndListener();
     }
 
-    void getSize(SizeReadyCallback cb) {
+    void getSize(@NonNull SizeReadyCallback cb) {
       int currentWidth = getTargetWidth();
       int currentHeight = getTargetHeight();
       if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
@@ -269,16 +395,16 @@ void getSize(SizeReadyCallback cb) {
      *
      * <p>See #2237.
      */
-    void removeCallback(SizeReadyCallback cb) {
+    void removeCallback(@NonNull SizeReadyCallback cb) {
       cbs.remove(cb);
     }
 
     void clearCallbacksAndListener() {
-      // Keep a reference to the layout listener and remove it here
+      // Keep a reference to the layout attachStateListener and remove it here
       // rather than having the observer remove itself because the observer
-      // we add the listener to will be almost immediately merged into
+      // we add the attachStateListener to will be almost immediately merged into
       // another observer and will therefore never be alive. If we instead
-      // keep a reference to the listener and remove it here, we get the
+      // keep a reference to the attachStateListener and remove it here, we get the
       // current view tree observer and should succeed.
       ViewTreeObserver observer = view.getViewTreeObserver();
       if (observer.isAlive()) {
@@ -347,12 +473,14 @@ private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
       // layout to complete before using this fallback parameter (ConstraintLayout among others).
       if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
         if (Log.isLoggable(TAG, Log.INFO)) {
-          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
-              + " this device's screen dimensions. If you want to load the original image and are"
-              + " ok with the corresponding memory cost and OOMs (depending on the input size), use"
-              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set"
-              + " layout_width and layout_height to fixed dimension, or use .override() with fixed"
-              + " dimensions.");
+          Log.i(
+              TAG,
+              "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of this"
+                  + " device's screen dimensions. If you want to load the original image and are"
+                  + " ok with the corresponding memory cost and OOMs (depending on the input size),"
+                  + " use override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT,"
+                  + " set layout_width and layout_height to fixed dimension, or use .override()"
+                  + " with fixed dimensions.");
         }
         return getMaxDisplayLength(view.getContext());
       }
@@ -371,14 +499,14 @@ private boolean isDimensionValid(int size) {
         implements ViewTreeObserver.OnPreDrawListener {
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
-      SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
+      SizeDeterminerLayoutListener(@NonNull SizeDeterminer sizeDeterminer) {
         sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
       }
 
       @Override
       public boolean onPreDraw() {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
-          Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
+          Log.v(TAG, "OnGlobalLayoutListener called attachStateListener=" + this);
         }
         SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
         if (sizeDeterminer != null) {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
index 012d2009b..1792789f5 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
@@ -8,15 +8,17 @@
 
 /**
  * A {@link TransitionFactory} for complex types that have a {@link android.graphics.Bitmap} inside.
- * The transitioning bitmap is wrapped in a {@link android.graphics.drawable.BitmapDrawable}.
- * Most commonly used with {@link DrawableCrossFadeFactory}.
+ * The transitioning bitmap is wrapped in a {@link android.graphics.drawable.BitmapDrawable}. Most
+ * commonly used with {@link DrawableCrossFadeFactory}.
  *
  * @param <R> The type of the composite object that contains the {@link android.graphics.Bitmap} to
- *            be transitioned.
+ *     be transitioned.
  */
 public abstract class BitmapContainerTransitionFactory<R> implements TransitionFactory<R> {
   private final TransitionFactory<Drawable> realFactory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory) {
     this.realFactory = realFactory;
   }
@@ -29,18 +31,19 @@ public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory)
 
   /**
    * Retrieve the Bitmap from a composite object.
-   * <p><b>Warning:</b> Do not convert any arbitrary object to Bitmap
-   * via expensive drawing here, this method is called on the UI thread.</p>
+   *
+   * <p><b>Warning:</b> Do not convert any arbitrary object to Bitmap via expensive drawing here,
+   * this method is called on the UI thread.
    *
    * @param current composite object containing a Bitmap and some other information
    * @return the Bitmap contained within {@code current}
    */
   protected abstract Bitmap getBitmap(R current);
 
-  private class BitmapGlideAnimation implements Transition<R> {
+  private final class BitmapGlideAnimation implements Transition<R> {
     private final Transition<Drawable> transition;
 
-    public BitmapGlideAnimation(Transition<Drawable> transition) {
+    BitmapGlideAnimation(Transition<Drawable> transition) {
       this.transition = transition;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
index a6982b5d5..51010f301 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
@@ -2,7 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 
 /**
  * A {@link TransitionFactory} for {@link android.graphics.Bitmap}s that uses a Drawable transition
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index 3aeab1922..58cf57d42 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -8,11 +8,13 @@
  * the drawable was loaded from the memory cache and whether or not the drawable is the first image
  * to be put on the target.
  *
- * <p> Resources are usually loaded from the memory cache just before the user can see the view, for
+ * <p>Resources are usually loaded from the memory cache just before the user can see the view, for
  * example when the user changes screens or scrolls back and forth in a list. In those cases the
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
  * the memory cache this factory produces an {@link NoTransition}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
   private final int duration;
   private final boolean isCrossFadeEnabled;
@@ -26,31 +28,29 @@ protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {
   @Override
   public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {
     return dataSource == DataSource.MEMORY_CACHE
-        ? NoTransition.<Drawable>get() : getResourceTransition();
+        ? NoTransition.<Drawable>get()
+        : getResourceTransition();
   }
 
   private Transition<Drawable> getResourceTransition() {
-      if (resourceTransition == null) {
-        resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);
-      }
-      return resourceTransition;
+    if (resourceTransition == null) {
+      resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);
+    }
+    return resourceTransition;
   }
 
-  /**
-   * A Builder for {@link DrawableCrossFadeFactory}.
-   */
+  /** A Builder for {@link DrawableCrossFadeFactory}. */
+  @SuppressWarnings("unused")
   public static class Builder {
     private static final int DEFAULT_DURATION_MS = 300;
-    private int durationMillis;
+    private final int durationMillis;
     private boolean isCrossFadeEnabled;
 
     public Builder() {
       this(DEFAULT_DURATION_MS);
     }
 
-    /**
-     * @param durationMillis The duration of the cross fade animation in milliseconds.
-     */
+    /** @param durationMillis The duration of the cross fade animation in milliseconds. */
     public Builder(int durationMillis) {
       this.durationMillis = durationMillis;
     }
@@ -62,10 +62,10 @@ public Builder(int durationMillis) {
      * <p>Defaults to {@code false}.
      *
      * @param isCrossFadeEnabled If {@code true} the previous {@link Drawable}'s alpha will be
-     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is
-     *     animated from 0 to 100. Otherwise the previous {@link Drawable}'s
-     *     alpha will remain at 100 throughout the animation. See
-     *     {@link android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
+     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is animated from 0 to 100.
+     *     Otherwise the previous {@link Drawable}'s alpha will remain at 100 throughout the
+     *     animation. See {@link
+     *     android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
      */
     public Builder setCrossFadeEnabled(boolean isCrossFadeEnabled) {
       this.isCrossFadeEnabled = isCrossFadeEnabled;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index cfdf30b31..0960c4f97 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -18,15 +18,15 @@
 
   /**
    * @param duration The duration that the cross fade animation should run if there is something to
-   *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
+   *     cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
    * @param isCrossFadeEnabled If {@code true}, animates the previous resource's alpha to 0 while
-   *                         animating the new resource's alpha to 100. Otherwise, only animates
-   *                         the new resource's alpha to 100 while leaving the previous resource's
-   *                         alpha at 100. See
-   *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
+   *     animating the new resource's alpha to 100. Otherwise, only animates the new resource's
+   *     alpha to 100 while leaving the previous resource's alpha at 100. See {@link
+   *     TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
-  public DrawableCrossFadeTransition(int duration,
-      boolean isCrossFadeEnabled) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public DrawableCrossFadeTransition(int duration, boolean isCrossFadeEnabled) {
     this.duration = duration;
     this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
@@ -34,9 +34,11 @@ public DrawableCrossFadeTransition(int duration,
   /**
    * Animates from the previous drawable to the current drawable in one of two ways.
    *
-   * <ol> <li>Using the default animation provided in the constructor if the previous drawable is
-   * null</li> <li>Using the cross fade animation with the duration provided in the constructor if
-   * the previous drawable is non null</li> </ol>
+   * <ol>
+   *   <li>Using the default animation provided in the constructor if the previous drawable is null
+   *   <li>Using the cross fade animation with the duration provided in the constructor if the
+   *       previous drawable is non null
+   * </ol>
    *
    * @param current {@inheritDoc}
    * @param adapter {@inheritDoc}
@@ -49,7 +51,7 @@ public boolean transition(Drawable current, ViewAdapter adapter) {
       previous = new ColorDrawable(Color.TRANSPARENT);
     }
     TransitionDrawable transitionDrawable =
-        new TransitionDrawable(new Drawable[] { previous, current });
+        new TransitionDrawable(new Drawable[] {previous, current});
     transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
     transitionDrawable.startTransition(duration);
     adapter.setDrawable(transitionDrawable);
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index d5a1c1e33..b0bbbd921 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -6,19 +6,20 @@
 /**
  * A simple {@link Transition} that performs no actions.
  *
- * @param <R> the resource type that will be transitioned into a
- * {@link com.bumptech.glide.request.target.Target}.
+ * @param <R> the resource type that will be transitioned into a {@link
+ *     com.bumptech.glide.request.target.Target}.
  */
 public class NoTransition<R> implements Transition<R> {
-  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
+  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<>();
+
   @SuppressWarnings("rawtypes")
   private static final TransitionFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
 
   /**
    * A factory that always returns the same {@link NoTransition}.
    *
-   * @param <R> the resource type that will be transitioned into a
-   * {@link com.bumptech.glide.request.target.Target}.
+   * @param <R> the resource type that will be transitioned into a {@link
+   *     com.bumptech.glide.request.target.Target}.
    */
   public static class NoAnimationFactory<R> implements TransitionFactory<R> {
     @SuppressWarnings("unchecked")
@@ -28,25 +29,19 @@
     }
   }
 
-  /**
-   * Returns an instance of a factory that produces {@link NoTransition}s.
-   */
+  /** Returns an instance of a factory that produces {@link NoTransition}s. */
   @SuppressWarnings("unchecked")
   public static <R> TransitionFactory<R> getFactory() {
     return (TransitionFactory<R>) NO_ANIMATION_FACTORY;
   }
 
-  /**
-   * Returns an instance of {@link NoTransition}.
-   */
+  /** Returns an instance of {@link NoTransition}. */
   @SuppressWarnings("unchecked")
   public static <R> Transition<R> get() {
     return (Transition<R>) NO_ANIMATION;
   }
 
-  /**
-   * Performs no animation and always returns {@code false}.
-   */
+  /** Performs no animation and always returns {@code false}. */
   @Override
   public boolean transition(Object current, ViewAdapter adapter) {
     return false;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/Transition.java b/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
index 50debd7b9..38390bd31 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.request.transition;
 
 import android.graphics.drawable.Drawable;
-import android.support.annotation.Nullable;
 import android.view.View;
+import androidx.annotation.Nullable;
 
 /**
  * An interface that allows a transition to be applied to {@link android.view.View}s in {@link
@@ -22,9 +22,7 @@
    * animated {@link android.graphics.drawable.Drawable}s).
    */
   interface ViewAdapter {
-    /**
-     * Returns the wrapped {@link android.view.View}.
-     */
+    /** Returns the wrapped {@link android.view.View}. */
     View getView();
 
     /**
@@ -49,9 +47,9 @@
    *
    * @param current The new resource that will be displayed in the view.
    * @param adapter The {@link Transition.ViewAdapter} wrapping a view that can at least return an
-   *                {@link android.view.View} from {@link Transition.ViewAdapter#getView()}.
+   *     {@link android.view.View} from {@link Transition.ViewAdapter#getView()}.
    * @return True if in the process of running the transition, the new resource was put on the view,
-   * false if the caller needs to manually put the current resource on the view.
+   *     false if the caller needs to manually put the current resource on the view.
    */
   boolean transition(R current, ViewAdapter adapter);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
index 727b508a7..e0022df28 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
@@ -3,8 +3,7 @@
 import com.bumptech.glide.load.DataSource;
 
 /**
- * A factory class that can produce different {@link Transition}s based on the state of the
- * request.
+ * A factory class that can produce different {@link Transition}s based on the state of the request.
  *
  * @param <R> The type of resource that needs to be animated into the target.
  */
@@ -13,8 +12,7 @@
   /**
    * Returns a new {@link Transition}.
    *
-   * @param dataSource      The {@link com.bumptech.glide.load.DataSource} the resource was loaded
-   *                        from.
+   * @param dataSource The {@link com.bumptech.glide.load.DataSource} the resource was loaded from.
    * @param isFirstResource True if this is the first resource to be loaded into the target.
    */
   Transition<R> build(DataSource dataSource, boolean isFirstResource);
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
index 661c27715..0942c308c 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
@@ -14,6 +14,8 @@
   private final ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
   private Transition<R> transition;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ViewAnimationFactory(Animation animation) {
     this(new ConcreteViewTransitionAnimationFactory(animation));
   }
@@ -33,7 +35,7 @@ public ViewAnimationFactory(int animationId) {
    * {@link ViewTransition}.
    *
    * @param dataSource {@inheritDoc}
-   * @param isFirstResource   {@inheritDoc}
+   * @param isFirstResource {@inheritDoc}
    */
   @Override
   public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
@@ -48,11 +50,11 @@ public ViewAnimationFactory(int animationId) {
     return transition;
   }
 
-  private static class ConcreteViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+  private static class ConcreteViewTransitionAnimationFactory
+      implements ViewTransition.ViewTransitionAnimationFactory {
     private final Animation animation;
 
-    public ConcreteViewTransitionAnimationFactory(Animation animation) {
+    ConcreteViewTransitionAnimationFactory(Animation animation) {
       this.animation = animation;
     }
 
@@ -62,11 +64,11 @@ public Animation build(Context context) {
     }
   }
 
-  private static class ResourceViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+  private static class ResourceViewTransitionAnimationFactory
+      implements ViewTransition.ViewTransitionAnimationFactory {
     private final int animationId;
 
-    public ResourceViewTransitionAnimationFactory(int animationId) {
+    ResourceViewTransitionAnimationFactory(int animationId) {
       this.animationId = animationId;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
index e863a83be..e6b02121b 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
@@ -19,6 +19,8 @@
    *
    * @param animator The animator to use.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ViewPropertyTransition(Animator animator) {
     this.animator = animator;
   }
@@ -53,5 +55,4 @@ public boolean transition(R current, ViewAdapter adapter) {
      */
     void animate(View view);
   }
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java
index c8a18cb6c..4c05137a6 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java
@@ -6,8 +6,8 @@
 
 /**
  * A {@link Transition} that can apply a {@link android.view.animation.Animation Animation} to a
- * {@link android.view.View View} using
- * {@link android.view.View#startAnimation(android.view.animation.Animation)}.
+ * {@link android.view.View View} using {@link
+ * android.view.View#startAnimation(android.view.animation.Animation)}.
  *
  * @param <R> The type of the resource that will be transitioned into a view.
  */
@@ -24,11 +24,11 @@
   }
 
   /**
-   * Always clears the current animation on the view using
-   * {@link android.view.View#clearAnimation()}, then starts the
-   * {@link android.view.animation.Animation} given in the constructor using
-   * {@link android.view.View#startAnimation(android.view.animation.Animation)} and then returns
-   * {@code false} because the animation does not actually put the current resource on the view.
+   * Always clears the current animation on the view using {@link
+   * android.view.View#clearAnimation()}, then starts the {@link android.view.animation.Animation}
+   * given in the constructor using {@link
+   * android.view.View#startAnimation(android.view.animation.Animation)} and then returns {@code
+   * false} because the animation does not actually put the current resource on the view.
    *
    * @param current {@inheritDoc}
    * @param adapter {@inheritDoc}
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 974dc0abd..d954d857b 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -3,23 +3,29 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.load.Key;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * A utility class for obtaining a {@link com.bumptech.glide.load.Key} signature containing the
  * application version name using {@link android.content.pm.PackageInfo#versionCode}.
  */
 public final class ApplicationVersionSignature {
-  private static final ConcurrentHashMap<String, Key> PACKAGE_NAME_TO_KEY =
-      new ConcurrentHashMap<>();
+  private static final String TAG = "AppVersionSignature";
+  private static final ConcurrentMap<String, Key> PACKAGE_NAME_TO_KEY = new ConcurrentHashMap<>();
 
   /**
    * Returns the signature {@link com.bumptech.glide.load.Key} for version code of the Application
    * of the given Context.
    */
-  public static Key obtain(Context context) {
+  @NonNull
+  public static Key obtain(@NonNull Context context) {
     String packageName = context.getPackageName();
     Key result = PACKAGE_NAME_TO_KEY.get(packageName);
     if (result == null) {
@@ -34,26 +40,37 @@ public static Key obtain(Context context) {
     return result;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static void reset() {
     PACKAGE_NAME_TO_KEY.clear();
   }
 
-  private static Key obtainVersionSignature(Context context) {
-    PackageInfo pInfo = null;
-    try {
-      pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      // Should never happen.
-      e.printStackTrace();
-    }
-    final String versionCode;
-    if (pInfo != null) {
-      versionCode = String.valueOf(pInfo.versionCode);
+  @NonNull
+  private static Key obtainVersionSignature(@NonNull Context context) {
+    PackageInfo packageInfo = getPackageInfo(context);
+    String versionCode = getVersionCode(packageInfo);
+    return new ObjectKey(versionCode);
+  }
+
+  @NonNull
+  private static String getVersionCode(@Nullable PackageInfo packageInfo) {
+    String versionCode;
+    if (packageInfo != null) {
+      versionCode = String.valueOf(packageInfo.versionCode);
     } else {
       versionCode = UUID.randomUUID().toString();
     }
-    return new ObjectKey(versionCode);
+    return versionCode;
+  }
+
+  @Nullable
+  private static PackageInfo getPackageInfo(@NonNull Context context) {
+    try {
+      return context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+    } catch (PackageManager.NameNotFoundException e) {
+      Log.e(TAG, "Cannot resolve info for" + context.getPackageName(), e);
+      return null;
+    }
   }
 
   private ApplicationVersionSignature() {
diff --git a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
index 93f572c0f..8f48b18e4 100644
--- a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
@@ -1,14 +1,14 @@
 package com.bumptech.glide.signature;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 
-/**
- * An empty key that is always equal to all other empty keys.
- */
+/** An empty key that is always equal to all other empty keys. */
 public final class EmptySignature implements Key {
   private static final EmptySignature EMPTY_KEY = new EmptySignature();
 
+  @NonNull
   public static EmptySignature obtain() {
     return EMPTY_KEY;
   }
@@ -23,7 +23,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     // Do nothing.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index e14e1a573..dbf4350c4 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.signature;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -10,24 +11,24 @@
  * media store files like edits, rotations, and temporary file replacement.
  */
 public class MediaStoreSignature implements Key {
-  private final String mimeType;
+  @NonNull private final String mimeType;
   private final long dateModified;
   private final int orientation;
 
   /**
    * Constructor for {@link com.bumptech.glide.signature.MediaStoreSignature}.
    *
-   * @param mimeType     The mime type of the media store media. Ok to default to empty string "".
-   *                     See {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or
-   *                     {@link android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}.
+   * @param mimeType The mime type of the media store media. Ok to default to empty string "". See
+   *     {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or {@link
+   *     android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}.
    * @param dateModified The date modified time of the media store media. Ok to default to 0. See
-   *                     {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or
-   *                     {@link android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}.
-   * @param orientation  The orientation of the media store media. Ok to default to 0. See {@link
-   *                     android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
+   *     {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or {@link
+   *     android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}.
+   * @param orientation The orientation of the media store media. Ok to default to 0. See {@link
+   *     android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
    */
-  public MediaStoreSignature(String mimeType, long dateModified, int orientation) {
-    this.mimeType = mimeType;
+  public MediaStoreSignature(@Nullable String mimeType, long dateModified, int orientation) {
+    this.mimeType = mimeType == null ? "" : mimeType;
     this.dateModified = dateModified;
     this.orientation = orientation;
   }
@@ -50,7 +51,7 @@ public boolean equals(Object o) {
     if (orientation != that.orientation) {
       return false;
     }
-    if (!Util.bothNullOrEqual(mimeType, that.mimeType)) {
+    if (!mimeType.equals(that.mimeType)) {
       return false;
     }
     return true;
@@ -58,14 +59,14 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    int result = mimeType != null ? mimeType.hashCode() : 0;
+    int result = mimeType.hashCode();
     result = 31 * result + (int) (dateModified ^ (dateModified >>> 32));
     result = 31 * result + orientation;
     return result;
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     byte[] data = ByteBuffer.allocate(12).putLong(dateModified).putInt(orientation).array();
     messageDigest.update(data);
     messageDigest.update(mimeType.getBytes(CHARSET));
diff --git a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
index 50ccc9f3f..41cf2295e 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.signature;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 import java.security.MessageDigest;
@@ -7,24 +8,22 @@
 /**
  * Wraps an {@link java.lang.Object}, delegating {@link #equals(Object)} and {@link #hashCode()} to
  * the wrapped Object and providing the bytes of the result of the Object's {@link #toString()}
- * method to the {@link java.security.MessageDigest} in
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}.
+ * method to the {@link java.security.MessageDigest} in {@link
+ * #updateDiskCacheKey(java.security.MessageDigest)}.
  *
  * <p>The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
- * key.</p>
+ * key.
  */
 public final class ObjectKey implements Key {
   private final Object object;
 
-  public ObjectKey(Object object) {
+  public ObjectKey(@NonNull Object object) {
     this.object = Preconditions.checkNotNull(object);
   }
 
   @Override
   public String toString() {
-    return "ObjectKey{"
-        + "object=" + object
-        + '}';
+    return "ObjectKey{" + "object=" + object + '}';
   }
 
   @Override
@@ -42,8 +41,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(object.toString().getBytes(CHARSET));
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index 003a10592..c84cb83ff 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
@@ -10,9 +12,8 @@
 import java.nio.channels.FileChannel;
 import java.util.concurrent.atomic.AtomicReference;
 
-/**
- * Utilities for interacting with {@link java.nio.ByteBuffer}s.
- */
+/** Utilities for interacting with {@link java.nio.ByteBuffer}s. */
+@SuppressWarnings({"unused", "WeakerAccess"}) // Public API
 public final class ByteBufferUtil {
   // 16 Kb
   private static final int BUFFER_SIZE = 16384;
@@ -22,7 +23,8 @@ private ByteBufferUtil() {
     // Utility class.
   }
 
-  public static ByteBuffer fromFile(File file) throws IOException {
+  @NonNull
+  public static ByteBuffer fromFile(@NonNull File file) throws IOException {
     RandomAccessFile raf = null;
     FileChannel channel = null;
     try {
@@ -57,7 +59,7 @@ public static ByteBuffer fromFile(File file) throws IOException {
     }
   }
 
-  public static void toFile(ByteBuffer buffer, File file) throws IOException {
+  public static void toFile(@NonNull ByteBuffer buffer, @NonNull File file) throws IOException {
     buffer.position(0);
     RandomAccessFile raf = null;
     FileChannel channel = null;
@@ -86,7 +88,8 @@ public static void toFile(ByteBuffer buffer, File file) throws IOException {
     }
   }
 
-  public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOException {
+  public static void toStream(@NonNull ByteBuffer byteBuffer, @NonNull OutputStream os)
+      throws IOException {
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null) {
       os.write(safeArray.data, safeArray.offset, safeArray.offset + safeArray.limit);
@@ -106,7 +109,10 @@ public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOExc
     }
   }
 
-  public static byte[] toBytes(ByteBuffer byteBuffer) {
+  // We check the appropriate offsets, so this is a spurious warning.
+  @SuppressWarnings("ByteBufferBackingArray")
+  @NonNull
+  public static byte[] toBytes(@NonNull ByteBuffer byteBuffer) {
     final byte[] result;
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null && safeArray.offset == 0 && safeArray.limit == safeArray.data.length) {
@@ -120,11 +126,13 @@ public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOExc
     return result;
   }
 
-  public static InputStream toStream(ByteBuffer buffer) {
+  @NonNull
+  public static InputStream toStream(@NonNull ByteBuffer buffer) {
     return new ByteBufferStream(buffer);
   }
 
-  public static ByteBuffer fromStream(InputStream stream) throws IOException {
+  @NonNull
+  public static ByteBuffer fromStream(@NonNull InputStream stream) throws IOException {
     ByteArrayOutputStream outStream = new ByteArrayOutputStream(BUFFER_SIZE);
 
     byte[] buffer = BUFFER_REF.getAndSet(null);
@@ -132,7 +140,7 @@ public static ByteBuffer fromStream(InputStream stream) throws IOException {
       buffer = new byte[BUFFER_SIZE];
     }
 
-    int n = -1;
+    int n;
     while ((n = stream.read(buffer)) >= 0) {
       outStream.write(buffer, 0, n);
     }
@@ -145,7 +153,8 @@ public static ByteBuffer fromStream(InputStream stream) throws IOException {
     return (ByteBuffer) ByteBuffer.allocateDirect(bytes.length).put(bytes).position(0);
   }
 
-  private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
+  @Nullable
+  private static SafeArray getSafeArray(@NonNull ByteBuffer byteBuffer) {
     if (!byteBuffer.isReadOnly() && byteBuffer.hasArray()) {
       return new SafeArray(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit());
     }
@@ -157,7 +166,9 @@ private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
     @Synthetic final int limit;
     @Synthetic final byte[] data;
 
-    public SafeArray(byte[] data, int offset, int limit) {
+    // PMD.ArrayIsStoredDirectly Copying would be prohibitively expensive and/or lead to OOMs.
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
+    SafeArray(@NonNull byte[] data, int offset, int limit) {
       this.data = data;
       this.offset = offset;
       this.limit = limit;
@@ -166,20 +177,20 @@ public SafeArray(byte[] data, int offset, int limit) {
 
   private static class ByteBufferStream extends InputStream {
     private static final int UNSET = -1;
-    private final ByteBuffer byteBuffer;
+    @NonNull private final ByteBuffer byteBuffer;
     private int markPos = UNSET;
 
-    public ByteBufferStream(ByteBuffer byteBuffer) {
+    ByteBufferStream(@NonNull ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
     }
 
     @Override
-    public int available() throws IOException {
+    public int available() {
       return byteBuffer.remaining();
     }
 
     @Override
-    public int read() throws IOException {
+    public int read() {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
@@ -187,7 +198,7 @@ public int read() throws IOException {
     }
 
     @Override
-    public synchronized void mark(int readlimit) {
+    public synchronized void mark(int readLimit) {
       markPos = byteBuffer.position();
     }
 
@@ -197,7 +208,7 @@ public boolean markSupported() {
     }
 
     @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/CachedHashCodeArrayMap.java b/library/src/main/java/com/bumptech/glide/util/CachedHashCodeArrayMap.java
new file mode 100644
index 000000000..3b77efc6b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/CachedHashCodeArrayMap.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.util;
+
+import androidx.collection.ArrayMap;
+import androidx.collection.SimpleArrayMap;
+
+/**
+ * An {@link ArrayMap} that caches its hashCode to support efficient lookup.
+ *
+ * @param <K> the key type.
+ * @param <V> the value type.
+ */
+// We're overriding hashcode, but not in a way that changes the output, so we don't need to
+// override equals.
+@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")
+public final class CachedHashCodeArrayMap<K, V> extends ArrayMap<K, V> {
+
+  private int hashCode;
+
+  @Override
+  public void clear() {
+    hashCode = 0;
+    super.clear();
+  }
+
+  @Override
+  public V setValueAt(int index, V value) {
+    hashCode = 0;
+    return super.setValueAt(index, value);
+  }
+
+  @Override
+  public V put(K key, V value) {
+    hashCode = 0;
+    return super.put(key, value);
+  }
+
+  @Override
+  public void putAll(SimpleArrayMap<? extends K, ? extends V> simpleArrayMap) {
+    hashCode = 0;
+    super.putAll(simpleArrayMap);
+  }
+
+  @Override
+  public V removeAt(int index) {
+    hashCode = 0;
+    return super.removeAt(index);
+  }
+
+  @Override
+  public int hashCode() {
+    if (hashCode == 0) {
+      hashCode = super.hashCode();
+    }
+    return hashCode;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
index 0f4803ace..ab4f45672 100644
--- a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -2,6 +2,8 @@
 
 import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -17,15 +19,18 @@
   private final long contentLength;
   private int readSoFar;
 
-  public static InputStream obtain(InputStream other, String contentLengthHeader) {
+  @NonNull
+  public static InputStream obtain(
+      @NonNull InputStream other, @Nullable String contentLengthHeader) {
     return obtain(other, parseContentLength(contentLengthHeader));
   }
 
-  public static InputStream obtain(InputStream other, long contentLength) {
+  @NonNull
+  public static InputStream obtain(@NonNull InputStream other, long contentLength) {
     return new ContentLengthInputStream(other, contentLength);
   }
 
-  private static int parseContentLength(String contentLengthHeader) {
+  private static int parseContentLength(@Nullable String contentLengthHeader) {
     int result = UNKNOWN;
     if (!TextUtils.isEmpty(contentLengthHeader)) {
       try {
@@ -39,7 +44,7 @@ private static int parseContentLength(String contentLengthHeader) {
     return result;
   }
 
-  ContentLengthInputStream(InputStream in, long contentLength) {
+  private ContentLengthInputStream(@NonNull InputStream in, long contentLength) {
     super(in);
     this.contentLength = contentLength;
   }
@@ -47,7 +52,7 @@ private static int parseContentLength(String contentLengthHeader) {
   @Override
   public synchronized int available() throws IOException {
     return (int) Math.max(contentLength - readSoFar, in.available());
- }
+  }
 
   @Override
   public synchronized int read() throws IOException {
@@ -70,9 +75,12 @@ private int checkReadSoFarOrThrow(int read) throws IOException {
     if (read >= 0) {
       readSoFar += read;
     } else if (contentLength - readSoFar > 0) {
-      throw new IOException("Failed to read all expected data"
-          + ", expected: " + contentLength
-          + ", but read: " + readSoFar);
+      throw new IOException(
+          "Failed to read all expected data"
+              + ", expected: "
+              + contentLength
+              + ", but read: "
+              + readSoFar);
     }
     return read;
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
index c64b8572b..9dc224401 100644
--- a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Queue;
@@ -10,7 +12,7 @@
  * framework issue where exceptions during reads while decoding bitmaps in {@link
  * android.graphics.BitmapFactory} can return partially decoded bitmaps.
  *
- * See https://github.com/bumptech/glide/issues/126.
+ * <p>See https://github.com/bumptech/glide/issues/126.
  */
 public class ExceptionCatchingInputStream extends InputStream {
 
@@ -19,7 +21,8 @@
   private InputStream wrapped;
   private IOException exception;
 
-  public static ExceptionCatchingInputStream obtain(InputStream toWrap) {
+  @NonNull
+  public static ExceptionCatchingInputStream obtain(@NonNull InputStream toWrap) {
     ExceptionCatchingInputStream result;
     synchronized (QUEUE) {
       result = QUEUE.poll();
@@ -42,7 +45,7 @@ static void clearQueue() {
     // Do nothing.
   }
 
-  void setInputStream(InputStream toWrap) {
+  void setInputStream(@NonNull InputStream toWrap) {
     wrapped = toWrap;
   }
 
@@ -57,8 +60,8 @@ public void close() throws IOException {
   }
 
   @Override
-  public void mark(int readlimit) {
-    wrapped.mark(readlimit);
+  public void mark(int readLimit) {
+    wrapped.mark(readLimit);
   }
 
   @Override
@@ -67,7 +70,7 @@ public boolean markSupported() {
   }
 
   @Override
-  public int read(byte[] buffer) throws IOException {
+  public int read(byte[] buffer) {
     int read;
     try {
       read = wrapped.read(buffer);
@@ -79,7 +82,7 @@ public int read(byte[] buffer) throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(byte[] buffer, int byteOffset, int byteCount) {
     int read;
     try {
       read = wrapped.read(buffer, byteOffset, byteCount);
@@ -96,7 +99,7 @@ public synchronized void reset() throws IOException {
   }
 
   @Override
-  public long skip(long byteCount) throws IOException {
+  public long skip(long byteCount) {
     long skipped;
     try {
       skipped = wrapped.skip(byteCount);
@@ -108,7 +111,7 @@ public long skip(long byteCount) throws IOException {
   }
 
   @Override
-  public int read() throws IOException {
+  public int read() {
     int result;
     try {
       result = wrapped.read();
@@ -119,6 +122,7 @@ public int read() throws IOException {
     return result;
   }
 
+  @Nullable
   public IOException getException() {
     return exception;
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/Executors.java b/library/src/main/java/com/bumptech/glide/util/Executors.java
new file mode 100644
index 000000000..4828c3bbf
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/Executors.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.util;
+
+import android.os.Handler;
+import android.os.Looper;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+
+/** Generic {@link Executor} implementations. */
+public final class Executors {
+  private Executors() {
+    // Utility class.
+  }
+
+  private static final Executor MAIN_THREAD_EXECUTOR =
+      new Executor() {
+        private final Handler handler = new Handler(Looper.getMainLooper());
+
+        @Override
+        public void execute(@NonNull Runnable command) {
+          handler.post(command);
+        }
+      };
+  private static final Executor DIRECT_EXECUTOR =
+      new Executor() {
+        @Override
+        public void execute(@NonNull Runnable command) {
+          command.run();
+        }
+      };
+
+  /** Posts executions to the main thread. */
+  public static Executor mainThreadExecutor() {
+    return MAIN_THREAD_EXECUTOR;
+  }
+
+  /** Immediately calls {@link Runnable#run()} on the current thread. */
+  public static Executor directExecutor() {
+    return DIRECT_EXECUTOR;
+  }
+
+  @VisibleForTesting
+  public static void shutdownAndAwaitTermination(ExecutorService pool) {
+    long shutdownSeconds = 5;
+    pool.shutdownNow();
+    try {
+      if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+        pool.shutdownNow();
+        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+          throw new RuntimeException("Failed to shutdown");
+        }
+      }
+    } catch (InterruptedException ie) {
+      pool.shutdownNow();
+      Thread.currentThread().interrupt();
+      throw new RuntimeException(ie);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index b6c9e40d4..99538b219 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.util;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.ListPreloader;
-import java.util.Arrays;
 
 /**
  * A {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} with a fixed width and height.
@@ -15,15 +16,19 @@
   /**
    * Constructor for a PreloadSizeProvider with a fixed size.
    *
-   * @param width  The width of the preload size in pixels.
+   * @param width The width of the preload size in pixels.
    * @param height The height of the preload size in pixels.
    */
   public FixedPreloadSizeProvider(int width, int height) {
-    this.size = new int[] { width, height };
+    this.size = new int[] {width, height};
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
-    return Arrays.copyOf(this.size, this.size.length);
+  // It's better to take on the risk that callers may mutate the array when there isn't any reason
+  // for them to do so than it the performance overhead of copying the array with every call.
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
+  public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
+    return size;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/LogTime.java b/library/src/main/java/com/bumptech/glide/util/LogTime.java
index 344dbaa12..401094878 100644
--- a/library/src/main/java/com/bumptech/glide/util/LogTime.java
+++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java
@@ -4,12 +4,10 @@
 import android.os.Build;
 import android.os.SystemClock;
 
-/**
- * A class for logging elapsed real time in millis.
- */
+/** A class for logging elapsed real time in millis. */
 public final class LogTime {
   private static final double MILLIS_MULTIPLIER =
-      Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT ? 1d / Math.pow(10, 6) : 1d;
+      Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 ? 1d / Math.pow(10, 6) : 1d;
 
   private LogTime() {
     // Utility class.
@@ -21,7 +19,7 @@ private LogTime() {
    */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public static long getLogTime() {
-    if (Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
       return SystemClock.elapsedRealtimeNanos();
     } else {
       return SystemClock.uptimeMillis();
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index 1311fa176..2cffcf4b6 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,6 +1,8 @@
 package com.bumptech.glide.util;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -13,18 +15,18 @@
  * @param <Y> The type of the values.
  */
 public class LruCache<T, Y> {
-  private final LinkedHashMap<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
-  private final int initialMaxSize;
-  private int maxSize;
-  private int currentSize = 0;
+  private final Map<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
+  private final long initialMaxSize;
+  private long maxSize;
+  private long currentSize;
 
   /**
    * Constructor for LruCache.
    *
    * @param size The maximum size of the cache, the units must match the units used in {@link
-   *             #getSize(Object)}.
+   *     #getSize(Object)}.
    */
-  public LruCache(int size) {
+  public LruCache(long size) {
     this.initialMaxSize = size;
     this.maxSize = size;
   }
@@ -51,13 +53,11 @@ public synchronized void setSizeMultiplier(float multiplier) {
    *
    * @param item The item to get the size of.
    */
-  protected int getSize(Y item) {
+  protected int getSize(@Nullable Y item) {
     return 1;
   }
 
-  /**
-   * Returns the number of entries stored in cache.
-   */
+  /** Returns the number of entries stored in cache. */
   protected synchronized int getCount() {
     return cache.size();
   }
@@ -65,24 +65,20 @@ protected synchronized int getCount() {
   /**
    * A callback called whenever an item is evicted from the cache. Subclasses can override.
    *
-   * @param key  The key of the evicted item.
+   * @param key The key of the evicted item.
    * @param item The evicted item.
    */
-  protected void onItemEvicted(T key, Y item) {
+  protected void onItemEvicted(@NonNull T key, @Nullable Y item) {
     // optional override
   }
 
-  /**
-   * Returns the current maximum size of the cache in bytes.
-   */
-  public synchronized int getMaxSize() {
+  /** Returns the current maximum size of the cache in bytes. */
+  public synchronized long getMaxSize() {
     return maxSize;
   }
 
-  /**
-   * Returns the sum of the sizes of all items in the cache.
-   */
-  public synchronized int getCurrentSize() {
+  /** Returns the sum of the sizes of all items in the cache. */
+  public synchronized long getCurrentSize() {
     return currentSize;
   }
 
@@ -91,8 +87,7 @@ public synchronized int getCurrentSize() {
    *
    * @param key The key to check.
    */
-
-  public synchronized boolean contains(T key) {
+  public synchronized boolean contains(@NonNull T key) {
     return cache.containsKey(key);
   }
 
@@ -102,7 +97,7 @@ public synchronized boolean contains(T key) {
    * @param key The key to check.
    */
   @Nullable
-  public synchronized Y get(T key) {
+  public synchronized Y get(@NonNull T key) {
     return cache.get(key);
   }
 
@@ -110,31 +105,35 @@ public synchronized Y get(T key) {
    * Adds the given item to the cache with the given key and returns any previous entry for the
    * given key that may have already been in the cache.
    *
-   * <p> If the size of the item is larger than the total cache size, the item will not be added to
+   * <p>If the size of the item is larger than the total cache size, the item will not be added to
    * the cache and instead {@link #onItemEvicted(Object, Object)} will be called synchronously with
-   * the given key and item. </p>
+   * the given key and item.
    *
-   * @param key  The key to add the item at.
+   * @param key The key to add the item at.
    * @param item The item to add.
    */
-  public synchronized Y put(T key, Y item) {
+  @Nullable
+  public synchronized Y put(@NonNull T key, @Nullable Y item) {
     final int itemSize = getSize(item);
     if (itemSize >= maxSize) {
       onItemEvicted(key, item);
       return null;
     }
 
-    final Y result = cache.put(key, item);
     if (item != null) {
-      currentSize += getSize(item);
+      currentSize += itemSize;
     }
-    if (result != null) {
-      // TODO: should we call onItemEvicted here?
-      currentSize -= getSize(result);
+    @Nullable final Y old = cache.put(key, item);
+    if (old != null) {
+      currentSize -= getSize(old);
+
+      if (!old.equals(item)) {
+        onItemEvicted(key, old);
+      }
     }
     evict();
 
-    return result;
+    return old;
   }
 
   /**
@@ -143,7 +142,7 @@ public synchronized Y put(T key, Y item) {
    * @param key The key to remove the item at.
    */
   @Nullable
-  public synchronized Y remove(T key) {
+  public synchronized Y remove(@NonNull T key) {
     final Y value = cache.remove(key);
     if (value != null) {
       currentSize -= getSize(value);
@@ -151,9 +150,7 @@ public synchronized Y remove(T key) {
     return value;
   }
 
-  /**
-   * Clears all items in the cache.
-   */
+  /** Clears all items in the cache. */
   public void clearMemory() {
     trimToSize(0);
   }
@@ -164,14 +161,16 @@ public void clearMemory() {
    *
    * @param size The size the cache should be less than.
    */
-  protected synchronized void trimToSize(int size) {
+  protected synchronized void trimToSize(long size) {
     Map.Entry<T, Y> last;
+    Iterator<Map.Entry<T, Y>> cacheIterator;
     while (currentSize > size) {
-      last = cache.entrySet().iterator().next();
+      cacheIterator = cache.entrySet().iterator();
+      last = cacheIterator.next();
       final Y toRemove = last.getValue();
       currentSize -= getSize(toRemove);
       final T key = last.getKey();
-      cache.remove(key);
+      cacheIterator.remove();
       onItemEvicted(key, toRemove);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
index d2ce60308..9bbb19a7f 100644
--- a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import androidx.annotation.NonNull;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -14,14 +15,14 @@
 
   private int availableBytes = UNSET;
 
-  public MarkEnforcingInputStream(InputStream in) {
+  public MarkEnforcingInputStream(@NonNull InputStream in) {
     super(in);
   }
 
   @Override
-  public void mark(int readlimit) {
-    super.mark(readlimit);
-    availableBytes = readlimit;
+  public synchronized void mark(int readLimit) {
+    super.mark(readLimit);
+    availableBytes = readLimit;
   }
 
   @Override
@@ -36,7 +37,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
     int toRead = (int) getBytesToRead(byteCount);
     if (toRead == END_OF_STREAM) {
       return END_OF_STREAM;
@@ -48,7 +49,7 @@ public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException
   }
 
   @Override
-  public void reset() throws IOException {
+  public synchronized void reset() throws IOException {
     super.reset();
     availableBytes = UNSET;
   }
@@ -67,7 +68,8 @@ public long skip(long byteCount) throws IOException {
 
   @Override
   public int available() throws IOException {
-    return availableBytes == UNSET ? super.available()
+    return availableBytes == UNSET
+        ? super.available()
         : Math.min(availableBytes, super.available());
   }
 
@@ -83,7 +85,8 @@ private long getBytesToRead(long targetByteCount) {
 
   private void updateAvailableBytesAfterRead(long bytesRead) {
     if (availableBytes != UNSET && bytesRead != END_OF_STREAM) {
-      availableBytes -= bytesRead;
+      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      availableBytes = (int) (availableBytes - bytesRead);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index 18fd5e04e..dd8450a86 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.util;
 
-/**
- * A key of two {@link Class}es to be used in hashed collections.
- */
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+/** A key of two {@link Class}es to be used in hashed collections. */
 @SuppressWarnings({"PMD.ConstructorCallsOverridableMethod"})
 public class MultiClassKey {
   private Class<?> first;
@@ -13,19 +14,20 @@ public MultiClassKey() {
     // leave them null
   }
 
-  public MultiClassKey(Class<?> first, Class<?> second) {
+  public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second);
   }
 
-  public MultiClassKey(Class<?> first, Class<?> second, Class<?> third) {
+  public MultiClassKey(
+      @NonNull Class<?> first, @NonNull Class<?> second, @Nullable Class<?> third) {
     set(first, second, third);
   }
 
-  public void set(Class<?> first, Class<?> second) {
+  public void set(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second, null);
   }
 
-  public void set(Class<?> first, Class<?> second, Class<?> third) {
+  public void set(@NonNull Class<?> first, @NonNull Class<?> second, @Nullable Class<?> third) {
     this.first = first;
     this.second = second;
     this.third = third;
diff --git a/library/src/main/java/com/bumptech/glide/util/Preconditions.java b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
index 121ead84c..e9a696a5b 100644
--- a/library/src/main/java/com/bumptech/glide/util/Preconditions.java
+++ b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
@@ -1,42 +1,46 @@
 package com.bumptech.glide.util;
 
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import java.util.Collection;
 
-/**
- * Contains common assertions.
- */
+/** Contains common assertions. */
 public final class Preconditions {
 
   private Preconditions() {
     // Utility class.
   }
 
-  public static void checkArgument(boolean expression, String message) {
+  public static void checkArgument(boolean expression, @NonNull String message) {
     if (!expression) {
       throw new IllegalArgumentException(message);
     }
   }
 
-  public static <T> T checkNotNull(T arg) {
+  @NonNull
+  public static <T> T checkNotNull(@Nullable T arg) {
     return checkNotNull(arg, "Argument must not be null");
   }
 
-  public static <T> T checkNotNull(T arg, String message) {
+  @NonNull
+  public static <T> T checkNotNull(@Nullable T arg, @NonNull String message) {
     if (arg == null) {
       throw new NullPointerException(message);
     }
     return arg;
   }
 
-  public static String checkNotEmpty(String string) {
+  @NonNull
+  public static String checkNotEmpty(@Nullable String string) {
     if (TextUtils.isEmpty(string)) {
       throw new IllegalArgumentException("Must not be null or empty");
     }
     return string;
   }
 
-  public static <T extends Collection<Y>, Y> T checkNotEmpty(T collection) {
+  @NonNull
+  public static <T extends Collection<Y>, Y> T checkNotEmpty(@NonNull T collection) {
     if (collection.isEmpty()) {
       throw new IllegalArgumentException("Must not be empty.");
     }
diff --git a/library/src/main/java/com/bumptech/glide/util/Synthetic.java b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
index 0d1140b04..fea7ff048 100644
--- a/library/src/main/java/com/bumptech/glide/util/Synthetic.java
+++ b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
@@ -5,10 +5,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/**
- * Indicates that target's visibility can be relaxed to avoid synthetic methods.
- */
+/** Indicates that target's visibility can be relaxed to avoid synthetic methods. */
 @Retention(RetentionPolicy.SOURCE)
 @Target({ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.TYPE})
-public @interface Synthetic {
-}
+public @interface Synthetic {}
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index ed5224809..c4f075db2 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -4,6 +4,8 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Looper;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.model.Model;
 import com.bumptech.glide.request.target.Target;
 import java.util.ArrayDeque;
@@ -12,9 +14,7 @@
 import java.util.List;
 import java.util.Queue;
 
-/**
- * A collection of assorted utility classes.
- */
+/** A collection of assorted utility classes. */
 public final class Util {
   private static final int HASH_MULTIPLIER = 31;
   private static final int HASH_ACCUMULATOR = 17;
@@ -26,10 +26,9 @@ private Util() {
     // Utility class.
   }
 
-  /**
-   * Returns the hex string of the given byte array representing a SHA256 hash.
-   */
-  public static String sha256BytesToHex(byte[] bytes) {
+  /** Returns the hex string of the given byte array representing a SHA256 hash. */
+  @NonNull
+  public static String sha256BytesToHex(@NonNull byte[] bytes) {
     synchronized (SHA_256_CHARS) {
       return bytesToHex(bytes, SHA_256_CHARS);
     }
@@ -39,7 +38,8 @@ public static String sha256BytesToHex(byte[] bytes) {
   // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
   // /9655275#9655275
   @SuppressWarnings("PMD.UseVarargs")
-  private static String bytesToHex(byte[] bytes, char[] hexChars) {
+  @NonNull
+  private static String bytesToHex(@NonNull byte[] bytes, @NonNull char[] hexChars) {
     int v;
     for (int j = 0; j < bytes.length; j++) {
       v = bytes[j] & 0xFF;
@@ -54,30 +54,37 @@ private static String bytesToHex(byte[] bytes, char[] hexChars) {
    *
    * @see #getBitmapByteSize(android.graphics.Bitmap)
    * @deprecated Use {@link #getBitmapByteSize(android.graphics.Bitmap)} instead. Scheduled to be
-   * removed in Glide 4.0.
+   *     removed in Glide 4.0.
    */
   @Deprecated
-  public static int getSize(Bitmap bitmap) {
+  public static int getSize(@NonNull Bitmap bitmap) {
     return getBitmapByteSize(bitmap);
   }
 
-  /**
-   * Returns the in memory size of the given {@link Bitmap} in bytes.
-   */
+  /** Returns the in memory size of the given {@link Bitmap} in bytes. */
   @TargetApi(Build.VERSION_CODES.KITKAT)
-  public static int getBitmapByteSize(Bitmap bitmap) {
+  public static int getBitmapByteSize(@NonNull Bitmap bitmap) {
     // The return value of getAllocationByteCount silently changes for recycled bitmaps from the
     // internal buffer size to row bytes * height. To avoid random inconsistencies in caches, we
     // instead assert here.
     if (bitmap.isRecycled()) {
-      throw new IllegalStateException("Cannot obtain size for recycled Bitmap: " + bitmap
-          + "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig());
+      throw new IllegalStateException(
+          "Cannot obtain size for recycled Bitmap: "
+              + bitmap
+              + "["
+              + bitmap.getWidth()
+              + "x"
+              + bitmap.getHeight()
+              + "] "
+              + bitmap.getConfig());
     }
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148.
       try {
         return bitmap.getAllocationByteCount();
-      } catch (NullPointerException e) {
+      } catch (
+          @SuppressWarnings("PMD.AvoidCatchingNPE")
+          NullPointerException e) {
         // Do nothing.
       }
     }
@@ -88,11 +95,11 @@ public static int getBitmapByteSize(Bitmap bitmap) {
    * Returns the in memory size of {@link android.graphics.Bitmap} with the given width, height, and
    * {@link android.graphics.Bitmap.Config}.
    */
-  public static int getBitmapByteSize(int width, int height, Bitmap.Config config) {
+  public static int getBitmapByteSize(int width, int height, @Nullable Bitmap.Config config) {
     return width * height * getBytesPerPixel(config);
   }
 
-  private static int getBytesPerPixel(Bitmap.Config config) {
+  private static int getBytesPerPixel(@Nullable Bitmap.Config config) {
     // A bitmap by decoding a GIF has null "config" in certain environments.
     if (config == null) {
       config = Bitmap.Config.ARGB_8888;
@@ -107,6 +114,9 @@ private static int getBytesPerPixel(Bitmap.Config config) {
       case ARGB_4444:
         bytesPerPixel = 2;
         break;
+      case RGBA_F16:
+        bytesPerPixel = 8;
+        break;
       case ARGB_8888:
       default:
         bytesPerPixel = 4;
@@ -115,9 +125,7 @@ private static int getBytesPerPixel(Bitmap.Config config) {
     return bytesPerPixel;
   }
 
-  /**
-   * Returns true if width and height are both > 0 and/or equal to {@link Target#SIZE_ORIGINAL}.
-   */
+  /** Returns true if width and height are both > 0 and/or equal to {@link Target#SIZE_ORIGINAL}. */
   public static boolean isValidDimensions(int width, int height) {
     return isValidDimension(width) && isValidDimension(height);
   }
@@ -136,32 +144,25 @@ public static void assertMainThread() {
     }
   }
 
-  /**
-   * Throws an {@link java.lang.IllegalArgumentException} if called on the main thread.
-   */
+  /** Throws an {@link java.lang.IllegalArgumentException} if called on the main thread. */
   public static void assertBackgroundThread() {
     if (!isOnBackgroundThread()) {
       throw new IllegalArgumentException("You must call this method on a background thread");
     }
   }
 
-  /**
-   * Returns {@code true} if called on the main thread, {@code false} otherwise.
-   */
+  /** Returns {@code true} if called on the main thread, {@code false} otherwise. */
   public static boolean isOnMainThread() {
     return Looper.myLooper() == Looper.getMainLooper();
   }
 
-  /**
-   * Returns {@code true} if called on a background thread, {@code false} otherwise.
-   */
+  /** Returns {@code true} if called on a background thread, {@code false} otherwise. */
   public static boolean isOnBackgroundThread() {
     return !isOnMainThread();
   }
 
-  /**
-   * Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation.
-   */
+  /** Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation. */
+  @NonNull
   public static <T> Queue<T> createQueue(int size) {
     return new ArrayDeque<>(size);
   }
@@ -170,14 +171,20 @@ public static boolean isOnBackgroundThread() {
    * Returns a copy of the given list that is safe to iterate over and perform actions that may
    * modify the original list.
    *
-   * <p> See #303 and #375. </p>
+   * <p>See #303, #375, #322, #2262.
    */
-  public static <T> List<T> getSnapshot(Collection<T> other) {
-    // toArray creates a new ArrayList internally and this way we can guarantee entries will not
-    // be null. See #322.
-    List<T> result = new ArrayList<T>(other.size());
+  @NonNull
+  @SuppressWarnings("UseBulkOperation")
+  public static <T> List<T> getSnapshot(@NonNull Collection<T> other) {
+    // toArray creates a new ArrayList internally and does not guarantee that the values it contains
+    // are non-null. Collections.addAll in ArrayList uses toArray internally and therefore also
+    // doesn't guarantee that entries are non-null. WeakHashMap's iterator does avoid returning null
+    // and is therefore safe to use. See #322, #2262.
+    List<T> result = new ArrayList<>(other.size());
     for (T item : other) {
-      result.add(item);
+      if (item != null) {
+        result.add(item);
+      }
     }
     return result;
   }
@@ -187,11 +194,11 @@ public static boolean isOnBackgroundThread() {
    *
    * @see java.util.Objects#equals
    */
-  public static boolean bothNullOrEqual(Object a, Object b) {
+  public static boolean bothNullOrEqual(@Nullable Object a, @Nullable Object b) {
     return a == null ? b == null : a.equals(b);
   }
 
-  public static boolean bothModelsNullEquivalentOrEquals(Object a, Object b) {
+  public static boolean bothModelsNullEquivalentOrEquals(@Nullable Object a, @Nullable Object b) {
     if (a == null) {
       return b == null;
     }
@@ -217,7 +224,7 @@ public static int hashCode(float value, int accumulator) {
     return hashCode(Float.floatToIntBits(value), accumulator);
   }
 
-  public static int hashCode(Object object, int accumulator) {
+  public static int hashCode(@Nullable Object object, int accumulator) {
     return hashCode(object == null ? 0 : object.hashCode(), accumulator);
   }
 
@@ -228,5 +235,4 @@ public static int hashCode(boolean value, int accumulator) {
   public static int hashCode(boolean value) {
     return hashCode(value, HASH_ACCUMULATOR);
   }
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index 5f341a5b4..16a1af36a 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -1,9 +1,12 @@
 package com.bumptech.glide.util;
 
+import android.graphics.drawable.Drawable;
 import android.view.View;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.ListPreloader;
+import com.bumptech.glide.request.target.CustomViewTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.request.transition.Transition;
 import java.util.Arrays;
 
@@ -13,8 +16,8 @@
  *
  * @param <T> The type of the model the size should be provided for.
  */
-public class ViewPreloadSizeProvider<T> implements ListPreloader.PreloadSizeProvider<T>,
-    SizeReadyCallback {
+public class ViewPreloadSizeProvider<T>
+    implements ListPreloader.PreloadSizeProvider<T>, SizeReadyCallback {
   private int[] size;
   // We need to keep a strong reference to the Target so that it isn't garbage collected due to a
   // weak reference
@@ -35,52 +38,61 @@ public ViewPreloadSizeProvider() {
    * Constructor that will extract the preload size from a given {@link android.view.View}.
    *
    * @param view A not null View the size will be extracted from async using an {@link
-   *             android.view.ViewTreeObserver .OnPreDrawListener}
+   *     android.view.ViewTreeObserver .OnPreDrawListener}
    */
-  public ViewPreloadSizeProvider(View view) {
-    this.viewTarget = new SizeViewTarget(view, this);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public ViewPreloadSizeProvider(@NonNull View view) {
+    viewTarget = new SizeViewTarget(view);
+    viewTarget.getSize(this);
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
+  public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
     if (size == null) {
       return null;
     } else {
-      return Arrays.copyOf(this.size, this.size.length);
+      return Arrays.copyOf(size, size.length);
     }
   }
 
   @Override
   public void onSizeReady(int width, int height) {
-    this.size = new int[] { width, height };
+    size = new int[] {width, height};
     viewTarget = null;
   }
 
   /**
    * Sets the {@link android.view.View} the size will be extracted.
    *
-   * <p> Note - only the first call to this method will be obeyed, subsequent requests will be
-   * ignored. </p>
+   * <p>Note - only the first call to this method will be obeyed, subsequent requests will be
+   * ignored.
    *
    * @param view A not null View the size will be extracted async with an {@link
-   *             android.view.ViewTreeObserver .OnPreDrawListener}
+   *     android.view.ViewTreeObserver .OnPreDrawListener}
    */
-  public void setView(View view) {
-    if (this.size != null || viewTarget != null) {
+  public void setView(@NonNull View view) {
+    if (size != null || viewTarget != null) {
       return;
     }
-    this.viewTarget = new SizeViewTarget(view, this);
+    viewTarget = new SizeViewTarget(view);
+    viewTarget.getSize(this);
   }
 
-  private static final class SizeViewTarget extends ViewTarget<View, Object> {
-    public SizeViewTarget(View view, SizeReadyCallback callback) {
+  static final class SizeViewTarget extends CustomViewTarget<View, Object> {
+    SizeViewTarget(@NonNull View view) {
       super(view);
-      getSize(callback);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
-      // Do nothing
-    }
+    protected void onResourceCleared(@Nullable Drawable placeholder) {}
+
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {}
+
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {}
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
index 23416d80d..96600b2d3 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide.util.pool;
 
-import android.support.v4.util.Pools.Pool;
-import android.support.v4.util.Pools.SimplePool;
-import android.support.v4.util.Pools.SynchronizedPool;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.core.util.Pools.Pool;
+import androidx.core.util.Pools.SimplePool;
+import androidx.core.util.Pools.SynchronizedPool;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -15,40 +16,43 @@
 public final class FactoryPools {
   private static final String TAG = "FactoryPools";
   private static final int DEFAULT_POOL_SIZE = 20;
-  private static final Resetter<Object> EMPTY_RESETTER = new Resetter<Object>() {
-    @Override
-    public void reset(Object object) {
-      // Do nothing.
-    }
-  };
+  private static final Resetter<Object> EMPTY_RESETTER =
+      new Resetter<Object>() {
+        @Override
+        public void reset(@NonNull Object object) {
+          // Do nothing.
+        }
+      };
 
-  private FactoryPools() { }
+  private FactoryPools() {}
 
   /**
-   * Returns a non-thread safe {@link Pool} that never returns {@code null} from
-   * {@link Pool#acquire()} and that contains objects of the type created by the given
-   * {@link Factory} with the given maximum size.
+   * Returns a non-thread safe {@link Pool} that never returns {@code null} from {@link
+   * Pool#acquire()} and that contains objects of the type created by the given {@link Factory} with
+   * the given maximum size.
    *
    * <p>If the pool is empty when {@link Pool#acquire()} is called, the given {@link Factory} will
    * be used to create a new instance.
    *
    * @param <T> The type of object the pool will contains.
    */
-  public static <T extends Poolable> Pool<T> simple(int size, Factory<T> factory) {
+  @NonNull
+  public static <T extends Poolable> Pool<T> simple(int size, @NonNull Factory<T> factory) {
     return build(new SimplePool<T>(size), factory);
   }
 
   /**
-   * Returns a new thread safe {@link Pool} that never returns {@code null} from
-   * {@link Pool#acquire()} and that contains objects of the type created by the given
-   * {@link Factory} with the given maximum size.
+   * Returns a new thread safe {@link Pool} that never returns {@code null} from {@link
+   * Pool#acquire()} and that contains objects of the type created by the given {@link Factory} with
+   * the given maximum size.
    *
    * <p>If the pool is empty when {@link Pool#acquire()} is called, the given {@link Factory} will
    * be used to create a new instance.
    *
    * @param <T> The type of object the pool will contains.
    */
-  public static <T extends Poolable> Pool<T> threadSafe(int size, Factory<T> factory) {
+  @NonNull
+  public static <T extends Poolable> Pool<T> threadSafe(int size, @NonNull Factory<T> factory) {
     return build(new SynchronizedPool<T>(size), factory);
   }
 
@@ -61,42 +65,54 @@ private FactoryPools() { }
    *
    * @param <T> The type of object that the {@link List Lists} will contain.
    */
+  @NonNull
   public static <T> Pool<List<T>> threadSafeList() {
     return threadSafeList(DEFAULT_POOL_SIZE);
   }
 
   /**
-   * Returns a new thread safe {@link Pool} that never returns {@code null} and that contains
-   * {@link List Lists} of a specific generic type with the given maximum size.
+   * Returns a new thread safe {@link Pool} that never returns {@code null} and that contains {@link
+   * List Lists} of a specific generic type with the given maximum size.
    *
    * <p>If the pool is empty when {@link Pool#acquire()} is called, a new {@link List} will be
    * created.
    *
    * @param <T> The type of object that the {@link List Lists} will contain.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
   public static <T> Pool<List<T>> threadSafeList(int size) {
-    return build(new SynchronizedPool<List<T>>(size), new Factory<List<T>>() {
-      @Override
-      public List<T> create() {
-        return new ArrayList<>();
-      }
-    }, new Resetter<List<T>>() {
-      @Override
-      public void reset(List<T> object) {
-        object.clear();
-      }
-    });
+    return build(
+        new SynchronizedPool<List<T>>(size),
+        new Factory<List<T>>() {
+          @NonNull
+          @Override
+          public List<T> create() {
+            return new ArrayList<>();
+          }
+        },
+        new Resetter<List<T>>() {
+          @Override
+          public void reset(@NonNull List<T> object) {
+            object.clear();
+          }
+        });
   }
 
-  private static <T extends Poolable> Pool<T> build(Pool<T> pool, Factory<T> factory) {
+  @NonNull
+  private static <T extends Poolable> Pool<T> build(
+      @NonNull Pool<T> pool, @NonNull Factory<T> factory) {
     return build(pool, factory, FactoryPools.<T>emptyResetter());
   }
 
-  private static <T> Pool<T> build(Pool<T> pool, Factory<T> factory,
-      Resetter<T> resetter) {
+  @NonNull
+  private static <T> Pool<T> build(
+      @NonNull Pool<T> pool, @NonNull Factory<T> factory, @NonNull Resetter<T> resetter) {
     return new FactoryPool<>(pool, factory, resetter);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <T> Resetter<T> emptyResetter() {
     return (Resetter<T>) EMPTY_RESETTER;
@@ -117,14 +133,15 @@ public void reset(List<T> object) {
    * @param <T> The type of Object that will be reset.
    */
   public interface Resetter<T> {
-    void reset(T object);
+    void reset(@NonNull T object);
   }
 
   /**
-   * Allows additional verification to catch errors caused by using objects while they are in
-   * an object pool.
+   * Allows additional verification to catch errors caused by using objects while they are in an
+   * object pool.
    */
   public interface Poolable {
+    @NonNull
     StateVerifier getVerifier();
   }
 
@@ -133,7 +150,7 @@ public void reset(List<T> object) {
     private final Resetter<T> resetter;
     private final Pool<T> pool;
 
-    FactoryPool(Pool<T> pool, Factory<T> factory, Resetter<T> resetter) {
+    FactoryPool(@NonNull Pool<T> pool, @NonNull Factory<T> factory, @NonNull Resetter<T> resetter) {
       this.pool = pool;
       this.factory = factory;
       this.resetter = resetter;
@@ -155,7 +172,7 @@ public T acquire() {
     }
 
     @Override
-    public boolean release(T instance) {
+    public boolean release(@NonNull T instance) {
       if (instance instanceof Poolable) {
         ((Poolable) instance).getVerifier().setRecycled(true /*isRecycled*/);
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java b/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java
new file mode 100644
index 000000000..207511f3a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.util.pool;
+
+import androidx.core.os.TraceCompat;
+
+/** Systracing utilities for Glide. */
+public final class GlideTrace {
+
+  // Enable this locally to see tracing statements.
+  private static final boolean TRACING_ENABLED = false;
+
+  /** Maximum length of a systrace tag. */
+  private static final int MAX_LENGTH = 127;
+
+  private GlideTrace() {
+    // Utility class.
+  }
+
+  private static String truncateTag(String tag) {
+    if (tag.length() > MAX_LENGTH) {
+      return tag.substring(0, MAX_LENGTH - 1);
+    }
+    return tag;
+  }
+
+  public static void beginSection(String tag) {
+    if (TRACING_ENABLED) {
+      TraceCompat.beginSection(truncateTag(tag));
+    }
+  }
+
+  public static void beginSectionFormat(String format, Object arg1) {
+    if (TRACING_ENABLED) {
+      TraceCompat.beginSection(truncateTag(String.format(format, arg1)));
+    }
+  }
+
+  public static void beginSectionFormat(String format, Object arg1, Object arg2) {
+    if (TRACING_ENABLED) {
+      TraceCompat.beginSection(truncateTag(String.format(format, arg1, arg2)));
+    }
+  }
+
+  public static void beginSectionFormat(String format, Object arg1, Object arg2, Object arg3) {
+    if (TRACING_ENABLED) {
+      TraceCompat.beginSection(truncateTag(String.format(format, arg1, arg2, arg3)));
+    }
+  }
+
+  public static void endSection() {
+    if (TRACING_ENABLED) {
+      TraceCompat.endSection();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
index 7e6577dd3..3d7c15454 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -1,16 +1,14 @@
 package com.bumptech.glide.util.pool;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.util.Synthetic;
 
-/**
- * Verifies that the job is not in the recycled state.
- */
+/** Verifies that the job is not in the recycled state. */
 public abstract class StateVerifier {
   private static final boolean DEBUG = false;
 
-  /**
-   * Creates a new {@link StateVerifier} instance.
-   */
+  /** Creates a new {@link StateVerifier} instance. */
+  @NonNull
   public static StateVerifier newInstance() {
     if (DEBUG) {
       return new DebugStateVerifier();
@@ -19,7 +17,7 @@ public static StateVerifier newInstance() {
     }
   }
 
-  private StateVerifier() { }
+  private StateVerifier() {}
 
   /**
    * Throws an exception if we believe our object is recycled and inactive (i.e. is currently in an
@@ -27,16 +25,14 @@ private StateVerifier() { }
    */
   public abstract void throwIfRecycled();
 
-  /**
-   * Sets whether or not our object is recycled.
-   */
+  /** Sets whether or not our object is recycled. */
   abstract void setRecycled(boolean isRecycled);
 
   private static class DefaultStateVerifier extends StateVerifier {
     private volatile boolean isReleased;
 
     @Synthetic
-    DefaultStateVerifier() { }
+    DefaultStateVerifier() {}
 
     @Override
     public void throwIfRecycled() {
@@ -56,7 +52,7 @@ public void setRecycled(boolean isRecycled) {
     private volatile RuntimeException recycledAtStackTraceException;
 
     @Synthetic
-    DebugStateVerifier() { }
+    DebugStateVerifier() {}
 
     @Override
     public void throwIfRecycled() {
@@ -68,9 +64,9 @@ public void throwIfRecycled() {
     @Override
     void setRecycled(boolean isRecycled) {
       if (isRecycled) {
-        this.recycledAtStackTraceException = new RuntimeException("Released");
+        recycledAtStackTraceException = new RuntimeException("Released");
       } else {
-        this.recycledAtStackTraceException = null;
+        recycledAtStackTraceException = null;
       }
     }
   }
diff --git a/library/src/main/res/values/ids.xml b/library/src/main/res/values/ids.xml
new file mode 100644
index 000000000..c8c7c74dd
--- /dev/null
+++ b/library/src/main/res/values/ids.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <item name="glide_custom_view_target_tag" type="id"/>
+</resources>
\ No newline at end of file
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
deleted file mode 100644
index 08517533e..000000000
--- a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ /dev/null
@@ -1,398 +0,0 @@
-package com.bumptech.glide;
-
-import static com.bumptech.glide.tests.Util.cast;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.support.annotation.NonNull;
-import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.Target;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.verification.VerificationMode;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ListPreloaderTest {
-
-  @Mock private RequestBuilder<Object> request;
-  @Mock private RequestManager requestManager;
-
-  @Before
-  public void setUp() throws Exception {
-    MockitoAnnotations.initMocks(this);
-  }
-
-  @Test
-  public void testGetItemsIsCalledIncreasing() {
-    final AtomicBoolean called = new AtomicBoolean(false);
-    final AtomicInteger calledCount = new AtomicInteger();
-
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        called.set(true);
-        final int count = calledCount.getAndIncrement();
-        assertEquals(11 + count, position);
-        return super.getPreloadItems(position);
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-    preloader.onScroll(null, 1, 10, 30);
-    assertEquals(10, calledCount.get());
-  }
-
-  @Test
-  public void testGetItemsIsCalledInOrderIncreasing() {
-    final int toPreload = 10;
-    final List<Object> objects = new ArrayList<>();
-    for (int i = 0; i < toPreload; i++) {
-      objects.add(i);
-    }
-
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      private int expectedPosition;
-
-      @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
-        return new int[] { 10, 10 };
-      }
-
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        return objects.subList(position - 11, position + 1 - 11);
-      }
-
-      @NonNull
-      @Override
-      @SuppressWarnings("unchecked")
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
-        assertEquals(objects.get(expectedPosition), item);
-        expectedPosition++;
-        return mock(RequestBuilder.class);
-      }
-    };
-    ListPreloader<Object> preloader =
-        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);
-    preloader.onScroll(null, 1, 10, 20);
-  }
-
-  @Test
-  public void testGetItemsIsCalledDecreasing() {
-    final AtomicBoolean called = new AtomicBoolean(false);
-    final AtomicInteger calledCount = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        // Ignore the preload caused from us starting at the end
-        if (position >= 40) {
-          return Collections.emptyList();
-        }
-        final int count = calledCount.getAndIncrement();
-        called.set(true);
-        assertEquals(28 - count, position);
-        return super.getPreloadItems(position);
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-    preloader.onScroll(null, 30, 10, 40);
-    preloader.onScroll(null, 29, 10, 40);
-    assertTrue(called.get());
-  }
-
-  @Test
-  public void testGetItemsIsCalledInOrderDecreasing() {
-    final int toPreload = 10;
-    final List<Object> objects = new ArrayList<>();
-    for (int i = 0; i < toPreload; i++) {
-      objects.add(new Object());
-    }
-
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      private int expectedPosition = toPreload - 1;
-
-      @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
-        return new int[] { 10, 10 };
-      }
-
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        if (position == 40) {
-          return null;
-        }
-        return objects.subList(position, position + 1);
-      }
-
-      @NonNull
-      @Override
-      @SuppressWarnings("unchecked")
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
-        assertEquals(objects.get(expectedPosition), item);
-        expectedPosition--;
-        return mock(RequestBuilder.class);
-      }
-    };
-    ListPreloader<Object> preloader =
-        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);
-    preloader.onScroll(null, 30, 10, 10);
-    preloader.onScroll(null, 29, 10, 10);
-  }
-
-  @Test
-  public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
-    final AtomicBoolean called = new AtomicBoolean(false);
-    final AtomicInteger calledCount = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        called.set(true);
-        final int count = calledCount.getAndIncrement();
-        assertEquals(26 + count, position);
-        return super.getPreloadItems(position);
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-    preloader.onScroll(null, 16, 10, 30);
-    assertTrue(called.get());
-  }
-
-  @Test
-  public void testGetItemsIsNeverCalledWithStartLessThanZero() {
-    final AtomicBoolean called = new AtomicBoolean(false);
-    final AtomicInteger calledCount = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        if (position >= 17) {
-          return Collections.emptyList();
-        }
-        called.set(true);
-        final int count = calledCount.getAndIncrement();
-        assertEquals(5 - count, position);
-        return super.getPreloadItems(position);
-      }
-    };
-
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-    preloader.onScroll(null, 7, 10, 30);
-    preloader.onScroll(null, 6, 10, 30);
-    assertTrue(called.get());
-  }
-
-  @Test
-  public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
-    final AtomicInteger called = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        final int current = called.getAndIncrement();
-        assertEquals(11 + current, position);
-        return super.getPreloadItems(position);
-      }
-    };
-
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-    preloader.onScroll(null, 1, 10, 30);
-    preloader.onScroll(null, 4, 10, 30);
-
-    assertEquals(13, called.get());
-  }
-
-  @Test
-  public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
-    final AtomicInteger called = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        if (position >= 20) {
-          return Collections.emptyList();
-        }
-        final int current = called.getAndIncrement();
-        assertEquals(19 - current, position);
-        return super.getPreloadItems(position);
-      }
-    };
-
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-    preloader.onScroll(null, 21, 10, 30);
-    preloader.onScroll(null, 20, 10, 30);
-    preloader.onScroll(null, 17, 10, 30);
-    assertEquals(13, called.get());
-  }
-
-  @Test
-  public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException {
-    final List<Object> objects = new ArrayList<>();
-    objects.add(new Object());
-    objects.add(new Object());
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      private int expectedPosition = (1 + 10) * 2;
-
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        return objects;
-      }
-
-      @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPosition);
-        assertEquals(expectedPosition % 2, itemPosition);
-        expectedPosition++;
-        return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
-      }
-
-      @NonNull
-      @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
-        return request;
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-    Iterable<Integer> expected = Arrays.asList(10, 11, 20, 21, 10, 11, 20, 21);
-
-    preloader.onScroll(null, 1, 10, 1 + 10 + 2);
-
-    List<Integer> allValues = getTargetsSizes(request, times(4));
-    assertEquals(expected, allValues);
-  }
-
-  @Test
-  public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException {
-    final List<Object> objects = new ArrayList<>();
-    objects.add(new Object());
-    objects.add(new Object());
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      private int expectedPosition = objects.size() * 2 - 1;
-
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        return objects;
-      }
-
-      @Override
-      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPosition);
-        assertEquals(expectedPosition % 2, itemPosition);
-        expectedPosition--;
-        return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
-      }
-
-      @NonNull
-      @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
-        return request;
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-    Iterable<Integer> expected = Arrays.asList(20, 21, 10, 11, 20, 21, 10, 11);
-
-    preloader.onScroll(null, 3, 2, 3 + 2);
-    preloader.onScroll(null, 2, 2, 3 + 2);
-
-    List<Integer> allValues = getTargetsSizes(request, times(4));
-    assertEquals(expected, allValues);
-  }
-
-  private <R> List<Integer> getTargetsSizes(
-      RequestBuilder<R> requestBuilder, VerificationMode mode) {
-    ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
-    ArgumentCaptor<Target<R>> targetArgumentCaptor = cast(ArgumentCaptor.forClass(Target.class));
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
-    for (Target<R> target : targetArgumentCaptor.getAllValues()) {
-      target.getSize(cb);
-    }
-    verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
-    return integerArgumentCaptor.getAllValues();
-  }
-
-  @Test
-  public void testItemsArePreloadedWithGlide() {
-    final List<Object> objects = new ArrayList<>();
-    objects.add(new Object());
-    objects.add(new Object());
-    final HashSet<Object> loadedObjects = new HashSet<>();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        return objects.subList(position - 11, position - 10);
-      }
-
-      @NonNull
-      @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
-        loadedObjects.add(item);
-        return super.getPreloadRequestBuilder(item);
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
-
-    preloader.onScroll(null, 1, 10, 13);
-    assertThat(loadedObjects).containsAllIn(objects);
-  }
-
-  private static class ListPreloaderAdapter implements ListPreloader.PreloadModelProvider<Object>,
-      ListPreloader.PreloadSizeProvider<Object> {
-
-    public ListPreloaderAdapter() {
-    }
-
-    @NonNull
-    @Override
-    public List<Object> getPreloadItems(int position) {
-      ArrayList<Object> result = new ArrayList<>(1);
-      Collections.fill(result, new Object());
-      return result;
-    }
-
-    @NonNull
-    @Override
-    @SuppressWarnings("unchecked")
-    public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
-      return mock(RequestBuilder.class);
-    }
-
-    @Override
-    public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
-      return new int[] { 100, 100 };
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
deleted file mode 100644
index 0091ddb8d..000000000
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ /dev/null
@@ -1,156 +0,0 @@
-package com.bumptech.glide;
-
-import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import com.bumptech.glide.manager.ConnectivityMonitor;
-import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
-import com.bumptech.glide.manager.ConnectivityMonitorFactory;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestManagerTreeNode;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.tests.BackgroundUtil;
-import com.bumptech.glide.tests.GlideShadowLooper;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
-public class RequestManagerTest {
-  @Mock Lifecycle lifecycle = mock(Lifecycle.class);
-  @Mock RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-
-  private RequestManager manager;
-  private ConnectivityMonitor connectivityMonitor;
-  private RequestTracker requestTracker;
-  private ConnectivityListener connectivityListener;
-
-  @Before
-  public void setUp() {
-    MockitoAnnotations.initMocks(this);
-    Context context = RuntimeEnvironment.application;
-    connectivityMonitor = mock(ConnectivityMonitor.class);
-    ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
-    when(factory.build(isA(Context.class), isA(ConnectivityMonitor.ConnectivityListener.class)))
-        .thenAnswer(new Answer<ConnectivityMonitor>() {
-          @Override
-          public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
-            connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
-            return connectivityMonitor;
-          }
-        });
-    requestTracker = mock(RequestTracker.class);
-    manager =
-        new RequestManager(
-            Glide.get(RuntimeEnvironment.application),
-            lifecycle,
-            treeNode,
-            requestTracker,
-            factory,
-            context);
-  }
-
-  @Test
-  public void testPauseRequestsPausesRequests() {
-    manager.pauseRequests();
-
-    verify(requestTracker).pauseRequests();
-  }
-
-  @Test
-  public void testResumeRequestsResumesRequests() {
-    manager.resumeRequests();
-
-    verify(requestTracker).resumeRequests();
-  }
-
-  @Test
-  public void testPausesRequestsOnStop() {
-    manager.onStart();
-    manager.onStop();
-
-    verify(requestTracker).pauseRequests();
-  }
-
-  @Test
-  public void testResumesRequestsOnStart() {
-    manager.onStart();
-
-    verify(requestTracker).resumeRequests();
-  }
-
-  @Test
-  public void testClearsRequestsOnDestroy() {
-    manager.onDestroy();
-
-    verify(requestTracker).clearRequests();
-  }
-
-  @Test
-  public void testAddsConnectivityMonitorToLifecycleWhenConstructed() {
-    verify(lifecycle).addListener(eq(connectivityMonitor));
-  }
-
-  @Test
-  public void testAddsSelfToLifecycleWhenConstructed() {
-    verify(lifecycle).addListener(eq(manager));
-  }
-
-  @Test
-  public void testRestartsRequestOnConnected() {
-    connectivityListener.onConnectivityChanged(true);
-
-    verify(requestTracker).restartRequests();
-  }
-
-  @Test
-  public void testDoesNotRestartRequestsOnDisconnected() {
-    connectivityListener.onConnectivityChanged(false);
-
-    verify(requestTracker, never()).restartRequests();
-  }
-
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfResumeCalledOnBackgroundThread() throws InterruptedException {
-    testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() throws Exception {
-        manager.resumeRequests();
-      }
-    });
-  }
-
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfPauseCalledOnBackgroundThread() throws InterruptedException {
-    testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() throws Exception {
-        manager.pauseRequests();
-      }
-    });
-  }
-
-  @Test
-  public void testDelegatesIsPausedToRequestTracker() {
-    when(requestTracker.isPaused()).thenReturn(true);
-    assertTrue(manager.isPaused());
-    when(requestTracker.isPaused()).thenReturn(false);
-    assertFalse(manager.isPaused());
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
deleted file mode 100644
index bac793e3b..000000000
--- a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.load;
-
-import com.google.common.testing.EqualsTester;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class OptionsTest {
-
-  @Test
-  public void testEquals() {
-    Option<Object> firstOption = Option.memory("firstKey");
-    Object firstValue = new Object();
-    Option<Object> secondOption = Option.memory("secondKey");
-    Object secondValue = new Object();
-    new EqualsTester()
-        .addEqualityGroup(new Options(), new Options())
-        .addEqualityGroup(
-            new Options().set(firstOption, firstValue),
-            new Options().set(firstOption, firstValue)
-        )
-        .addEqualityGroup(
-            new Options().set(secondOption, secondValue),
-            new Options().set(secondOption, secondValue)
-        )
-        .addEqualityGroup(
-            new Options().set(firstOption, firstValue).set(secondOption, secondValue),
-            new Options().set(firstOption, firstValue).set(secondOption, secondValue)
-        ).testEquals();
-  }
-
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
deleted file mode 100644
index 01c767634..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util.WriteDigest;
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class DataCacheKeyTest {
-
-  @Mock Key firstKey;
-  @Mock Key firstSignature;
-  @Mock Key secondKey;
-  @Mock Key secondSignature;
-
-  @Before
-  public void setUp() throws UnsupportedEncodingException {
-    MockitoAnnotations.initMocks(this);
-    doAnswer(new WriteDigest("firstKey")).when(firstKey)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    doAnswer(new WriteDigest("firstSignature")).when(firstSignature)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    doAnswer(new WriteDigest("secondKey")).when(secondKey)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    doAnswer(new WriteDigest("secondSignature")).when(secondSignature)
-        .updateDiskCacheKey(any(MessageDigest.class));
-  }
-
-  @Test
-  public void testDiffersIfIdDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(secondKey, firstSignature);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(firstKey, secondSignature);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSameIfIdAndSignatureAreTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(firstKey, firstSignature);
-
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
deleted file mode 100644
index 0e691225f..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collections;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-/**
- * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object)
- * equals} and SHA-1 disk cache key are different on any difference in ID or existence of a certain
- * workflow part. Also checking whether the equals method is symmetric.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class EngineKeyTest {
-  private Harness harness;
-
-  @Before
-  public void setUp() {
-    harness = new Harness();
-  }
-
-  private static class Harness {
-    String id = "testId";
-    int width = 1;
-    int height = 2;
-    Class<?> resourceClass = Object.class;
-    Class<?> transcodeClass = Integer.class;
-    Key signature = mock(Key.class);
-    @SuppressWarnings("unchecked")
-    Transformation<Object> transformation = mock(Transformation.class);
-    Options options = new Options();
-
-    public Harness() {
-      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
-          .updateDiskCacheKey(any(MessageDigest.class));
-    }
-
-    public EngineKey build() {
-      return new EngineKey(id, signature, width, height,
-          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
-          resourceClass, transcodeClass, options);
-    }
-  }
-
-  @Test
-  public void testIsIdenticalWithSameArguments() {
-    assertEquals(harness.build(), harness.build());
-  }
-
-  @Test
-  public void testDiffersIfIdDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.id = harness.id + "2";
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfHeightDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.height += 1;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfWidthDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.width += 1;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    Key signature = mock(Key.class);
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        MessageDigest digest = (MessageDigest) invocationOnMock.getArguments()[0];
-        digest.update("signature".getBytes("UTF-8"));
-        return null;
-      }
-    }).when(signature).updateDiskCacheKey(any(MessageDigest.class));
-    harness.signature = signature;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfResourceClassDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.resourceClass = Long.class;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfTranscodeClassDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.transcodeClass = Long.class;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-
-    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    harness.transformation = other;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfOptionsDiffer() throws NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.options = new Options();
-    harness.options.set(Option.memory("fakeKey"), "someValue");
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
deleted file mode 100644
index 9f17c6768..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ /dev/null
@@ -1,536 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static com.bumptech.glide.tests.Util.anyResource;
-import static com.bumptech.glide.tests.Util.isADataSource;
-import static com.bumptech.glide.tests.Util.mockResource;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.GlideContext;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DataSource;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.cache.DiskCache;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.load.engine.executor.GlideExecutor;
-import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
-import com.bumptech.glide.request.ResourceCallback;
-import com.bumptech.glide.tests.BackgroundUtil;
-import com.bumptech.glide.tests.GlideShadowLooper;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.Map;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { GlideShadowLooper.class })
-@SuppressWarnings("unchecked")
-public class EngineTest {
-  private EngineTestHarness harness;
-
-  @Before
-  public void setUp() {
-    harness = new EngineTestHarness();
-  }
-
-  @Test
-  public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
-    harness.doLoad();
-
-    verify(harness.job).start((DecodeJob) any());
-  }
-
-  @Test
-  public void testCallbackIsAddedToNewEngineJobWithNoExistingLoad() {
-    harness.doLoad();
-
-    verify(harness.job).addCallback(eq(harness.cb));
-  }
-
-  @Test
-  public void testLoadStatusIsReturnedForNewLoad() {
-    assertNotNull(harness.doLoad());
-  }
-
-  @Test
-  public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
-    Engine.LoadStatus loadStatus = harness.doLoad();
-    loadStatus.cancel();
-
-    verify(harness.job).removeCallback(eq(harness.cb));
-  }
-
-  @Test
-  public void testNewRunnerIsAddedToRunnersMap() {
-    harness.doLoad();
-
-    assertThat(harness.jobs).containsKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
-    harness.doLoad();
-    harness.doLoad();
-
-    verify(harness.job, times(1)).start((DecodeJob) any());
-  }
-
-  @Test
-  public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
-    harness.doLoad();
-
-    ResourceCallback newCallback = mock(ResourceCallback.class);
-    harness.cb = newCallback;
-    harness.doLoad();
-
-    verify(harness.job).addCallback(eq(newCallback));
-  }
-
-  @Test
-  public void testLoadStatusIsReturnedForExistingJob() {
-    harness.doLoad();
-    Engine.LoadStatus loadStatus = harness.doLoad();
-
-    assertNotNull(loadStatus);
-  }
-
-  @Test
-  public void testResourceIsReturnedFromActiveResourcesIfPresent() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-  }
-
-  @Test
-  public void testResourceIsNotReturnedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());
-  }
-
-  @Test
-  public void testKeyIsRemovedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testResourceIsAcquiredIfReturnedFromActiveResources() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.doLoad();
-
-    verify(harness.resource).acquire();
-  }
-
-  @Test
-  public void testNewLoadIsNotStartedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.doLoad();
-
-    verify(harness.job, never()).start(any(DecodeJob.class));
-  }
-
-  @Test
-  public void testNullLoadStatusIsReturnedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    assertNull(harness.doLoad());
-  }
-
-  @Test
-  public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-    EngineResource<?> other = mock(EngineResource.class);
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());
-  }
-
-  @Test
-  public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.isMemoryCacheable = false;
-    harness.doLoad();
-
-    verify(harness.resource, never()).acquire();
-    verify(harness.job).start((DecodeJob) any());
-  }
-
-  @Test
-  public void testCacheIsCheckedIfMemoryCacheable() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-  }
-
-  @Test
-  public void testCacheIsNotCheckedIfNotMemoryCacheable() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.isMemoryCacheable = false;
-    harness.doLoad();
-
-    verify(harness.job).start((DecodeJob) any());
-  }
-
-  @Test
-  public void testResourceIsReturnedFromCacheIfPresent() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-  }
-
-  @Test
-  public void testHandlesNonEngineResourcesFromCacheIfPresent() {
-    final Object expected = new Object();
-    @SuppressWarnings("rawtypes") Resource fromCache = mockResource();
-    when(fromCache.get()).thenReturn(expected);
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
-
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[0];
-        assertEquals(expected, resource.get());
-        return null;
-      }
-    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(anyResource(), isADataSource());
-  }
-
-  @Test
-  public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.doLoad();
-
-    assertEquals(harness.resource, harness.activeResources.get(harness.cacheKey).get());
-  }
-
-  @Test
-  public void testResourceIsAcquiredIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.doLoad();
-
-    verify(harness.resource).acquire();
-  }
-
-  @Test
-  public void testNewLoadIsNotStartedIfResourceIsCached() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
-
-    harness.doLoad();
-
-    verify(harness.job, never()).start(any(DecodeJob.class));
-  }
-
-  @Test
-  public void testNullLoadStatusIsReturnedForCachedResource() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
-
-    Engine.LoadStatus loadStatus = harness.doLoad();
-    assertNull(loadStatus);
-  }
-
-  @Test
-  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testEngineIsSetAsResourceListenerOnJobComplete() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.engine));
-  }
-
-  @Test
-  public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
-  }
-
-  @Test
-  public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
-    when(harness.resource.isCacheable()).thenReturn(true);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-    WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
-    assertThat(harness.resource).isEqualTo(resourceRef.get());
-  }
-
-  @Test
-  public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
-    when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);
-
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
-
-    assertEquals(harness.job, harness.jobs.get(harness.cacheKey));
-  }
-
-  @Test
-  public void testResourceIsAddedToCacheOnReleased() {
-    final Object expected = new Object();
-    when(harness.resource.isCacheable()).thenReturn(true);
-    when(harness.resource.get()).thenReturn(expected);
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
-        assertEquals(expected, resource.get());
-        return null;
-      }
-    }).when(harness.cache).put(eq(harness.cacheKey), anyResource());
-
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-    verify(harness.cache).put(eq(harness.cacheKey), anyResource());
-  }
-
-  @Test
-  public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
-    when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-    verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
-  }
-
-  @Test
-  public void testResourceIsRecycledIfNotCacheableWhenReleased() {
-    when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-    verify(harness.resourceRecycler).recycle(eq(harness.resource));
-  }
-
-  @Test
-  public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testEngineAddedAsListenerToMemoryCache() {
-    verify(harness.cache).setResourceRemovedListener(eq(harness.engine));
-  }
-
-  @Test
-  public void testResourceIsRecycledWhenRemovedFromCache() {
-    harness.engine.onResourceRemoved(harness.resource);
-    verify(harness.resourceRecycler).recycle(eq(harness.resource));
-  }
-
-  @Test
-  public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
-    harness.doLoad();
-
-    assertThat(harness.jobs).containsEntry(harness.cacheKey, harness.job);
-  }
-
-  @Test
-  public void testKeyFactoryIsGivenNecessaryArguments() {
-    harness.doLoad();
-
-    verify(harness.keyFactory)
-        .buildKey(eq(harness.model), eq(harness.signature), eq(harness.width), eq(harness.height),
-            eq(harness.transformations), eq(Object.class), eq(Object.class), eq(harness.options));
-  }
-
-  @Test
-  public void testFactoryIsGivenNecessaryArguments() {
-    harness.doLoad();
-
-    verify(harness.engineJobFactory).build(
-        eq(harness.cacheKey),
-        eq(true) /*isMemoryCacheable*/,
-        eq(false) /*useUnlimitedSourceGeneratorPool*/,
-        /*useAnimationPool=*/ eq(false));
-  }
-
-  @Test
-  public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
-    harness.useUnlimitedSourceGeneratorPool = true;
-    harness.doLoad();
-
-    verify(harness.engineJobFactory).build(
-        eq(harness.cacheKey),
-        eq(true) /*isMemoryCacheable*/,
-        eq(true) /*useUnlimitedSourceGeneratorPool*/,
-        /*useAnimationPool=*/ eq(false));
-  }
-
-  @Test
-  public void testReleaseReleasesEngineResource() {
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    harness.engine.release(engineResource);
-    verify(engineResource).release();
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testThrowsIfAskedToReleaseNonEngineResource() {
-    harness.engine.release(mockResource());
-  }
-
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
-    BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() throws Exception {
-        harness.doLoad();
-      }
-    });
-  }
-
-  private static class EngineTestHarness {
-    EngineKey cacheKey = mock(EngineKey.class);
-    EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
-    ResourceCallback cb = mock(ResourceCallback.class);
-    @SuppressWarnings("rawtypes")
-    EngineResource resource = mock(EngineResource.class);
-    Map<Key, EngineJob<?>> jobs = new HashMap<>();
-    Map<Key, WeakReference<EngineResource<?>>> activeResources = new HashMap<>();
-
-    int width = 100;
-    int height = 100;
-
-    Object model = new Object();
-    MemoryCache cache = mock(MemoryCache.class);
-    EngineJob<?> job;
-    Engine engine;
-    Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
-    Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
-    ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
-    Key signature = mock(Key.class);
-    Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-    Options options = new Options();
-    GlideContext glideContext = mock(GlideContext.class);
-    boolean isMemoryCacheable = true;
-    boolean useUnlimitedSourceGeneratorPool = false;
-    boolean onlyRetrieveFromCache = false;
-    boolean isScaleOnlyOrNoTransform = true;
-
-    public EngineTestHarness() {
-      when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
-          eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);
-
-      job = mock(EngineJob.class);
-
-      engine =
-          new Engine(
-              cache,
-              mock(DiskCache.Factory.class),
-              GlideExecutor.newDiskCacheExecutor(),
-              MockGlideExecutor.newMainThreadExecutor(),
-              MockGlideExecutor.newMainThreadUnlimitedExecutor(),
-              MockGlideExecutor.newMainThreadUnlimitedExecutor(),
-              jobs,
-              keyFactory,
-              activeResources,
-              engineJobFactory,
-              decodeJobFactory,
-              resourceRecycler);
-    }
-
-    public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean()))
-          .thenReturn((EngineJob<Object>) job);
-      return engine.load(glideContext,
-          model,
-          signature,
-          width,
-          height,
-          Object.class /*resourceClass*/,
-          Object.class /*transcodeClass*/,
-          Priority.HIGH,
-          DiskCacheStrategy.ALL,
-          transformations,
-          false /*isTransformationRequired*/,
-          isScaleOnlyOrNoTransform,
-          options,
-          isMemoryCacheable,
-          useUnlimitedSourceGeneratorPool,
-          /*useAnimationPool=*/ false,
-          onlyRetrieveFromCache,
-          cb);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
deleted file mode 100644
index b2d467fac..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
+++ /dev/null
@@ -1,135 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.signature.ObjectKey;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ResourceCacheKeyTest {
-
-  private Factory factory;
-
-  @Before
-  public void setUp() {
-    factory = new Factory();
-  }
-
-  @Test
-  public void testIdenticalWithSameArguments()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    KeyAssertions.assertSame(factory.build(), factory.build());
-  }
-
-  @Test
-  public void testDifferIfSourceKeyDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.sourceKey = new ObjectKey("secondKey");
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.signature = new ObjectKey("secondSignature");
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfWidthDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.width = factory.width * 2;
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfHeightDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.height = factory.height * 2;
-      }
-    });
-  }
-
-  @Test
-  public void tesDiffersIfTransformationDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.transformation = mock(Transformation.class);
-        doAnswer(new Util.WriteDigest("otherTransformation")).when(factory.transformation)
-            .updateDiskCacheKey(any(MessageDigest.class));
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfResourceDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.resourceClass = Integer.class;
-      }
-    });
-  }
-
-  interface FactoryMutation {
-    void mutate(Factory factory);
-  }
-
-  private void mutateAndAssertDifferent(FactoryMutation mutation) {
-    ResourceCacheKey original = factory.build();
-    mutation.mutate(factory);
-    ResourceCacheKey mutated = factory.build();
-
-    try {
-      KeyAssertions.assertDifferent(original, mutated);
-    } catch (NoSuchAlgorithmException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static class Factory {
-    Key sourceKey = new ObjectKey("sourceKey");
-    Key signature = new ObjectKey("signature");
-    int width = 100;
-    int height = 100;
-    Transformation<?> transformation = mock(Transformation.class);
-    Class<?> resourceClass = Object.class;
-    Options options = new Options();
-
-    Factory() {
-      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
-          .updateDiskCacheKey(any(MessageDigest.class));
-    }
-
-    ResourceCacheKey build() {
-      return new ResourceCacheKey(sourceKey, signature, width, height, transformation,
-          resourceClass, options);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
deleted file mode 100644
index ab9604ddc..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class GroupedLinkedMapTest {
-
-    private GroupedLinkedMap<Key, Object> map;
-
-    @Before
-    public void setUp() {
-        map = new GroupedLinkedMap<Key, Object>();
-    }
-
-    @Test
-    public void testReturnsNullForGetWithNoBitmap() {
-        assertNull(map.get(mock(Key.class)));
-    }
-
-    @Test
-    public void testCanAddAndRemoveABitmap() {
-        Key key = new Key("key", 1, 1);
-        Object expected = new Object();
-
-        map.put(key, expected);
-
-        assertThat(map.get(key)).isEqualTo(expected);
-    }
-
-    @Test
-    public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
-        Key key = new Key("key", 1, 1);
-        Integer value = 20;
-
-        int numToAdd = 10;
-
-        for (int i = 0; i < numToAdd; i++) {
-            map.put(key, new Integer(value));
-        }
-
-        for (int i = 0; i < numToAdd; i++) {
-            assertThat(map.get(key)).isEqualTo(value);
-        }
-    }
-
-    @Test
-    public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
-        Key firstKey = new Key("key", 1, 1);
-        Integer firstValue = 10;
-        map.put(firstKey, firstValue);
-        map.put(firstKey, new Integer(firstValue));
-
-        Key secondKey = new Key("key", 2, 2);
-        Integer secondValue = 20;
-        map.put(secondKey, secondValue);
-
-        map.get(firstKey);
-
-        assertThat(map.removeLast()).isEqualTo(secondValue);
-    }
-
-    @Test
-    public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
-        Key firstKey = new Key("key", 1, 1);
-        Integer firstValue = 10;
-
-        map.put(firstKey, firstValue);
-        map.put(firstKey, new Integer(firstValue));
-
-        map.get(firstKey);
-
-        Integer secondValue = 20;
-        map.put(new Key("key", 2, 2), secondValue);
-
-        assertThat(map.removeLast()).isEqualTo(secondValue);
-    }
-
-    private static class Key implements Poolable {
-
-        private final String key;
-        private final int width;
-        private final int height;
-
-        public Key(String key, int width, int height) {
-            this.key = key;
-            this.width = width;
-            this.height = height;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Key) {
-                Key other = (Key) o;
-                return key.equals(other.key) && width == other.width && height == other.height;
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = key != null ? key.hashCode() : 0;
-            result = 31 * result + width;
-            result = 31 * result + height;
-            return result;
-        }
-
-        @Override
-        public void offer() {
-            // Do nothing.
-        }
-    }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
deleted file mode 100644
index 4f6016cf3..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
+++ /dev/null
@@ -1,114 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-import android.annotation.TargetApi;
-import android.os.Build;
-import java.util.Arrays;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-public class LruArrayPoolTest {
-  private static final int MAX_SIZE = 10;
-  private static final Class<byte[]> ARRAY_CLASS = byte[].class;
-  private static final ArrayAdapterInterface<byte[]> ADAPTER = new ByteArrayAdapter();
-  private LruArrayPool pool;
-
-  @Before
-  public void setUp() throws Exception {
-    pool = new LruArrayPool(MAX_SIZE);
-  }
-
-  @Test
-  public void testNewPoolIsEmpty() {
-    assertEquals(pool.getCurrentSize(), 0);
-  }
-
-  @Test
-  public void testICanAddAndGetValidArray() {
-    int size = 758;
-    int value = 564;
-    fillPool(pool, size - 1, value);
-    pool.put(createArray(ARRAY_CLASS, size, value), ARRAY_CLASS);
-    Object array = pool.get(size, ARRAY_CLASS);
-    assertNotNull(array);
-    assertTrue(array.getClass() == ARRAY_CLASS);
-    assertTrue(ADAPTER.getArrayLength((byte[]) array) >= size);
-    assertTrue(((byte[]) array)[0] == (byte) 0);
-  }
-
-  @Test
-  public void testItIsSizeLimited() {
-    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 1);
-    assertTrue(pool.getCurrentSize() <= MAX_SIZE);
-  }
-
-  @Test
-  public void testArrayLargerThanPoolIsNotAdded() {
-    pool = new LruArrayPool(MAX_SIZE);
-    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0),
-        ARRAY_CLASS);
-    assertEquals(0, pool.getCurrentSize());
-  }
-
-  @Test
-  public void testClearMemoryRemovesAllArrays() {
-    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0);
-    pool.clearMemory();
-    assertEquals(0, pool.getCurrentSize());
-  }
-
-  @Test
-  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {
-    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
-  }
-
-  @Test
-  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {
-    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
-  }
-
-  @Test
-  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
-    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
-      testTrimMemory(MAX_SIZE, trimLevel, 0);
-    }
-  }
-
-  private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
-    pool = new LruArrayPool(MAX_SIZE);
-    fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
-    pool.trimMemory(trimLevel);
-    assertEquals("Failed level=" + trimLevel, expectedSize, pool.getCurrentSize());
-  }
-
-  private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
-    for (int i = 0; i < arrayCount; i++) {
-      pool.put(createArray(ARRAY_CLASS, arrayLength, 10), ARRAY_CLASS);
-    }
-  }
-
-  @SuppressWarnings("unchecked")
-  private static <T> T createArray(Class<T> type, int size, int value) {
-    Object array = null;
-    if (type.equals(int[].class)) {
-      array = new int[size];
-      Arrays.fill((int[]) array, value);
-    } else if (type.equals(byte[].class)) {
-      array = new byte[size];
-      Arrays.fill((byte[]) array, (byte) value);
-    }
-    return (T) array;
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
deleted file mode 100644
index 2242dcf03..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import android.graphics.Bitmap;
-import com.google.common.testing.EqualsTester;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class SizeConfigStrategyTest {
-
-    @Mock SizeConfigStrategy.KeyPool pool;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test
-    public void testKeyEquals() {
-        new EqualsTester()
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, null /*config*/)
-                )
-                .testEquals();
-
-    }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
deleted file mode 100644
index 29b03a1ec..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.Util;
-import java.io.File;
-import java.io.IOException;
-import java.security.MessageDigest;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class DiskLruCacheWrapperTest {
-  private DiskLruCacheWrapper cache;
-  private byte[] data;
-  private StringKey key;
-
-  @Before
-  public void setUp() {
-    File dir = RuntimeEnvironment.application.getCacheDir();
-    cache = new DiskLruCacheWrapper(dir, 10 * 1024 * 1024);
-    key = new StringKey("test" + Math.random());
-    data = new byte[] { 1, 2, 3, 4, 5, 6 };
-  }
-
-  @Test
-  public void testCanInsertAndGet() throws IOException {
-    cache.put(key, new DiskCache.Writer() {
-      @Override
-      public boolean write(File file) {
-        try {
-          Util.writeFile(file, data);
-        } catch (IOException e) {
-          fail(e.toString());
-        }
-        return true;
-      }
-    });
-
-    byte[] received = Util.readFile(cache.get(key), data.length);
-
-    assertArrayEquals(data, received);
-  }
-
-  @Test
-  public void testDoesNotCommitIfWriterReturnsFalse() {
-    cache.put(key, new DiskCache.Writer() {
-      @Override
-      public boolean write(File file) {
-        return false;
-      }
-    });
-
-    assertNull(cache.get(key));
-  }
-
-  @Test
-  public void testDoesNotCommitIfWriterWritesButReturnsFalse() {
-    cache.put(key, new DiskCache.Writer() {
-      @Override
-      public boolean write(File file) {
-        try {
-          Util.writeFile(file, data);
-        } catch (IOException e) {
-          fail(e.toString());
-        }
-        return false;
-      }
-    });
-
-    assertNull(cache.get(key));
-  }
-
-  @Test
-  public void testEditIsAbortedIfWriterThrows() throws IOException {
-    try {
-      cache.put(key, new DiskCache.Writer() {
-        @Override
-        public boolean write(File file) {
-          throw new RuntimeException("test");
-        }
-      });
-    } catch (RuntimeException e) {
-      // Expected.
-    }
-
-    cache.put(key, new DiskCache.Writer() {
-      @Override
-      public boolean write(File file) {
-        try {
-          Util.writeFile(file, data);
-        } catch (IOException e) {
-          fail(e.toString());
-        }
-        return true;
-      }
-    });
-
-    byte[] received = Util.readFile(cache.get(key), data.length);
-
-    assertArrayEquals(data, received);
-  }
-
-  private static class StringKey implements Key {
-    private final String key;
-
-    public StringKey(String key) {
-      this.key = key;
-    }
-
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      messageDigest.update(key.getBytes());
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
deleted file mode 100644
index 00ffc8295..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
-import static com.bumptech.glide.tests.Util.mockResource;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.annotation.TargetApi;
-import android.content.ComponentCallbacks2;
-import android.os.Build;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.Resource;
-import java.security.MessageDigest;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-public class LruResourceCacheTest {
-  private static class TrimClearMemoryCacheHarness {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> first = mockResource();
-    Resource<?> second = mockResource();
-
-    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-    public TrimClearMemoryCacheHarness() {
-      when(first.getSize()).thenReturn(50);
-      when(second.getSize()).thenReturn(50);
-      resourceCache.put(new MockKey(), first);
-      resourceCache.put(new MockKey(), second);
-      resourceCache.setResourceRemovedListener(listener);
-    }
-  }
-
-  @Test
-  public void testTrimMemoryBackground() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
-
-    verify(harness.listener).onResourceRemoved(eq(harness.first));
-    verify(harness.listener).onResourceRemoved(eq(harness.second));
-  }
-
-  @Test
-  public void testTrimMemoryModerate() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
-
-    verify(harness.listener).onResourceRemoved(harness.first);
-    verify(harness.listener).onResourceRemoved(harness.second);
-  }
-
-  @Test
-  public void testTrimMemoryUiHidden() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
-
-    verify(harness.listener).onResourceRemoved(harness.first);
-    verify(harness.listener, never()).onResourceRemoved(harness.second);
-  }
-
-  @Test
-  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> resource = mockResource();
-    when(resource.getSize()).thenReturn(200);
-
-    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-    resourceCache.setResourceRemovedListener(listener);
-    resourceCache.put(new MockKey(), resource);
-
-    verify(listener).onResourceRemoved(eq(resource));
-  }
-
-  @Test
-  public void testSizeIsBasedOnResource() {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource<?> first = getResource(50);
-    MockKey firstKey = new MockKey();
-    resourceCache.put(firstKey, first);
-    Resource<?> second = getResource(50);
-    MockKey secondKey = new MockKey();
-    resourceCache.put(secondKey, second);
-
-    assertTrue(resourceCache.contains(firstKey));
-    assertTrue(resourceCache.contains(secondKey));
-
-    Resource<?> third = getResource(50);
-    MockKey thirdKey = new MockKey();
-    resourceCache.put(thirdKey, third);
-
-    assertFalse(resourceCache.contains(firstKey));
-    assertTrue(resourceCache.contains(secondKey));
-    assertTrue(resourceCache.contains(thirdKey));
-  }
-
-  private Resource<?> getResource(int size) {
-    Resource<?> resource = mockResource();
-    when(resource.getSize()).thenReturn(size);
-    return resource;
-  }
-
-  private static class MockKey implements Key {
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      messageDigest.update(toString().getBytes(CHARSET));
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
deleted file mode 100644
index af0dce220..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.bumptech.glide.load.engine.executor;
-
-/**
- * Creates mock {@link GlideExecutor}s.
- */
-public final class MockGlideExecutor {
-
-  private MockGlideExecutor() { }
-
-  public static GlideExecutor newMainThreadExecutor() {
-    return new GlideExecutor(1 /*poolSize*/, "mock-glide-executor",
-        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
-        true /*runAllOnMainThread*/);
-  }
-
-  public static GlideExecutor newMainThreadUnlimitedExecutor() {
-    return new GlideExecutor(0 /* corePoolSize */,
-        Integer.MAX_VALUE /* maximumPoolSize */,
-        java.util.concurrent.TimeUnit.SECONDS.toMillis(10) /* keepAliveTimeInMs */,
-        "mock-unlimited-glide-executor",
-        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
-        true /*runAllOnMainThread*/);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
deleted file mode 100644
index 40b9bfb7a..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
+++ /dev/null
@@ -1,402 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-
-import com.bumptech.glide.load.ImageHeaderParser;
-import com.bumptech.glide.load.ImageHeaderParser.ImageType;
-import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.testutil.TestResourceUtil;
-import java.io.ByteArrayInputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.util.Util;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class DefaultImageHeaderParserTest {
-
-  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
-      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
-          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
-
-  private ArrayPool byteArrayPool;
-
-  @Before
-  public void setUp() {
-    byteArrayPool = new LruArrayPool();
-  }
-
-  @Test
-  public void testCanParsePngType() throws IOException {
-    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
-    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.PNG, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.PNG, parser.getType(byteBuffer));
-      }
-    });
-  }
-
-  @Test
-  public void testCanParsePngWithAlpha() throws IOException {
-    for (int i = 3; i <= 6; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-            throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType(is));
-        }
-        @Override
-        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-            ArrayPool byteArrayPool) throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParsePngWithoutAlpha() throws IOException {
-    for (int i = 0; i < 3; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-            throws IOException {
-          assertEquals(ImageType.PNG, parser.getType(is));
-        }
-        @Override
-        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-            ArrayPool byteArrayPool) throws IOException {
-          assertEquals(ImageType.PNG, parser.getType(byteBuffer));
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParseJpegType() throws IOException {
-    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseGifType() throws IOException {
-    byte[] data = new byte[] { 'G', 'I', 'F' };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.GIF, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.GIF, parser.getType(byteBuffer));
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseWebpWithAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
-        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.WEBP_A, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseWebpWithoutAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
-        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.WEBP, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
-    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
-      }
-    });
-  }
-
-  // Test for #286.
-  @Test
-  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
-    byte[] data =
-        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(-1, parser.getOrientation(is, byteArrayPool));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownForEmptyData() throws IOException {
-    runTest(new byte[0], new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
-      }
-    });
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialReads() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    assertThat(parser.getOrientation(new PartialReadInputStream(is), byteArrayPool)).isEqualTo(6);
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialSkips() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    assertThat(parser.getOrientation(new PartialSkipInputStream(is), byteArrayPool)).isEqualTo(6);
-  }
-
-  @Test
-  public void testHandlesSometimesZeroSkips() throws IOException {
-    InputStream is = new ByteArrayInputStream(
-        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
-    DefaultImageHeaderParser parser =
-        new DefaultImageHeaderParser();
-    assertEquals(ImageType.PNG, parser.getType(new SometimesZeroSkipInputStream(is)));
-  }
-
-  @Test
-  public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {
-    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
-    byte[] data = new byte[] {
-        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
-        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
-        (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
-        // SEGMENT_LENGTH
-        (byte) 0xFF, (byte) 0xFF,
-    };
-    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
-    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
-        parser.getOrientation(byteBuffer, byteArrayPool));
-  }
-
-  @Test
-  public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {
-    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
-    byte[] data = new byte[] {
-        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
-        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
-        // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
-        (byte) 0xE5,
-        // SEGMENT_LENGTH
-        (byte) 0xFF, (byte) 0xFF,
-    };
-    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
-    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
-        parser.getOrientation(byteBuffer, byteArrayPool));
-  }
-
-  @Test
-  public void getOrientation_withExifSegmentAndPreambleButLessThanLength_returnsUnknown()
-      throws IOException {
-    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
-    ByteBuffer exifSegmentPreamble =
-        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
-
-    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity());
-    data.put(jpegHeaderBytes)
-        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
-        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
-        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
-        // beyond the preamble bytes length for the test.
-        .putShort(
-            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
-        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
-
-    data.position(0);
-    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
-  }
-
-  @Test
-  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown()
-      throws IOException {
-    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
-    ByteBuffer exifSegmentPreamble =
-        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
-
-    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity() + 2 + 1);
-    data.put(jpegHeaderBytes)
-        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
-        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
-        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
-        // beyond the preamble bytes length for the test.
-        .putShort(
-            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
-        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
-
-    data.position(0);
-    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
-  }
-
-  private static ByteBuffer getExifMagicNumber() {
-    ByteBuffer jpegHeaderBytes = ByteBuffer.allocate(2);
-    jpegHeaderBytes.putShort((short) DefaultImageHeaderParser.EXIF_MAGIC_NUMBER);
-    jpegHeaderBytes.position(0);
-    return jpegHeaderBytes;
-  }
-
-  private interface ParserTestCase {
-    void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-        throws IOException;
-    void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
-        throws IOException;
-  }
-
-  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
-    InputStream is = new ByteArrayInputStream(data);
-    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    test.run(parser, is, new LruArrayPool());
-
-    ByteBuffer buffer = ByteBuffer.wrap(data);
-    parser = new DefaultImageHeaderParser();
-    test.run(parser, buffer, new LruArrayPool());
-  }
-
-  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
-    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
-    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
-    result[result.length - 1] = (byte) bitDepth;
-    return result;
-  }
-
-  private static class SometimesZeroSkipInputStream extends FilterInputStream {
-    boolean returnZeroFlag = true;
-
-    protected SometimesZeroSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-      final long result;
-      if (returnZeroFlag) {
-        result = 0;
-      } else {
-        result = super.skip(byteCount);
-      }
-      returnZeroFlag = !returnZeroFlag;
-      return result;
-    }
-  }
-
-  private static class PartialSkipInputStream extends FilterInputStream {
-
-    protected PartialSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-        long toActuallySkip = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallySkip = 1;
-        }
-        return super.skip(toActuallySkip);
-    }
-  }
-
-  private static class PartialReadInputStream extends FilterInputStream {
-
-    protected PartialReadInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
-        int toActuallyRead = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallyRead = 1;
-        }
-        return super.read(buffer, byteOffset, toActuallyRead);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
deleted file mode 100644
index 4b034d2fc..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
-import android.os.ParcelFileDescriptor;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import java.io.FileDescriptor;
-import java.io.IOException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class VideoBitmapDecoderTest {
-  @Mock private ParcelFileDescriptor resource;
-  @Mock private VideoBitmapDecoder.MediaMetadataRetrieverFactory factory;
-  @Mock private MediaMetadataRetriever retriever;
-  @Mock private BitmapPool bitmapPool;
-  private VideoBitmapDecoder decoder;
-  private Options options;
-
-  @Before
-  public void setup() {
-    MockitoAnnotations.initMocks(this);
-    when(factory.build()).thenReturn(retriever);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-    options = new Options();
-  }
-
-  @Test
-  public void testReturnsRetrievedFrameForResource() throws IOException {
-    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(retriever.getFrameAtTime()).thenReturn(expected);
-
-    FileDescriptor toSet = FileDescriptor.in;
-    when(resource.getFileDescriptor()).thenReturn(toSet);
-    Resource<Bitmap> result = decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).setDataSource(eq(toSet));
-    assertEquals(expected, result.get());
-  }
-
-  @Test
-  public void testReleasesMediaMetadataRetriever() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(retriever).release();
-  }
-
-  @Test
-  public void testClosesResource() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(resource).close();
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
-    options.set(VideoBitmapDecoder.TARGET_FRAME, -5L);
-    new VideoBitmapDecoder(bitmapPool, factory).decode(resource, 100, 100, options);
-  }
-
-  @Test
-  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
-    long frame = 5;
-    options.set(VideoBitmapDecoder.TARGET_FRAME, frame);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-
-    decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).getFrameAtTime(frame);
-    verify(retriever, never()).getFrameAtTime();
-  }
-
-  @Test
-  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-    decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).getFrameAtTime();
-    verify(retriever, never()).getFrameAtTime(anyLong());
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
deleted file mode 100644
index 889cd2ba2..000000000
--- a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ /dev/null
@@ -1,357 +0,0 @@
-package com.bumptech.glide.manager;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.request.Request;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-@RunWith(JUnit4.class)
-public class RequestTrackerTest {
-  private RequestTracker tracker;
-
-  @Before
-  public void setUp() {
-    tracker = new RequestTracker();
-  }
-
-  @Test
-  public void testClearsAddedRequestsOnDestroy() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-
-    tracker.clearRequests();
-
-    verify(request).clear();
-    verify(request).recycle();
-  }
-
-  @Test
-  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsFalse() {
-    assertThat(tracker.clearRemoveAndRecycle(null)).isFalse();
-  }
-
-  @Test
-  public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
-    Request request = mock(Request.class);
-
-    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
-
-    verify(request, never()).clear();
-    verify(request, never()).recycle();
-  }
-
-  @Test
-  public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-
-    assertThat(tracker.clearRemoveAndRecycle(request)).isTrue();
-    verify(request).clear();
-    verify(request).recycle();
-  }
-
-  @Test
-  public void testClearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-    tracker.clearRemoveAndRecycle(request);
-    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
-
-    verify(request, times(1)).clear();
-    verify(request, times(1)).recycle();
-  }
-
-  @Test
-  public void testCanAddAndRemoveRequest() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-    tracker.clearRemoveAndRecycle(request);
-
-    tracker.clearRequests();
-
-    verify(request, times(1)).clear();
-  }
-
-  @Test
-  public void testCanAddMultipleRequests() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.clearRequests();
-
-    verify(first).clear();
-    verify(second).clear();
-  }
-
-  @Test
-  public void testPausesInProgressRequestsWhenPaused() {
-    Request request = mock(Request.class);
-    when(request.isRunning()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.pauseRequests();
-
-    verify(request).pause();
-  }
-
-  @Test
-  public void testDoesNotClearCompleteRequestsWhenPaused() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-
-    when(request.isComplete()).thenReturn(true);
-    tracker.pauseRequests();
-
-    verify(request, never()).clear();
-  }
-
-  @Test
-  public void testStartsRequestOnRun() {
-    Request request = mock(Request.class);
-    tracker.runRequest(request);
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotStartRequestOnRunIfPaused() {
-    Request request = mock(Request.class);
-    tracker.pauseRequests();
-    tracker.runRequest(request);
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testStartsRequestAddedWhenPausedWhenResumed() {
-    Request request = mock(Request.class);
-    tracker.pauseRequests();
-    tracker.runRequest(request);
-    tracker.resumeRequests();
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotClearFailedRequestsWhenPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.pauseRequests();
-
-    verify(request, never()).clear();
-  }
-
-  @Test
-  public void testRestartsStoppedRequestWhenResumed() {
-    Request request = mock(Request.class);
-    tracker.addRequest(request);
-
-    tracker.resumeRequests();
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotRestartCompletedRequestsWhenResumed() {
-    Request request = mock(Request.class);
-    when(request.isComplete()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.resumeRequests();
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testDoesRestartFailedRequestsWhenResumed() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.resumeRequests();
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotStartStartedRequestsWhenResumed() {
-    Request request = mock(Request.class);
-    when(request.isRunning()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.resumeRequests();
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testAvoidsConcurrentModificationWhenResuming() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-
-    doAnswer(new ClearAndRemoveRequest(second)).when(first).begin();
-
-    tracker.addRequest(mock(Request.class));
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.resumeRequests();
-  }
-
-  @Test
-  public void testAvoidsConcurrentModificationWhenPausing() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-
-    when(first.isRunning()).thenReturn(true);
-    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();
-
-    tracker.addRequest(mock(Request.class));
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.pauseRequests();
-  }
-
-  @Test
-  public void testAvoidsConcurrentModificationWhenClearing() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-
-    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
-
-    tracker.addRequest(mock(Request.class));
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.clearRequests();
-  }
-
-  @Test
-  public void testAvoidsConcurrentModificationWhenRestarting() {
-    Request first = mock(Request.class);
-    Request second = mock(Request.class);
-
-    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();
-
-    tracker.addRequest(mock(Request.class));
-    tracker.addRequest(first);
-    tracker.addRequest(second);
-
-    tracker.restartRequests();
-  }
-
-  @Test
-  public void testRestartsFailedRequestRestart() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.addRequest(request);
-
-    tracker.restartRequests();
-
-    verify(request).begin();
-  }
-
-  @Test
-  public void testPausesAndRestartsNotYetFinishedRequestsOnRestart() {
-    Request request = mock(Request.class);
-    when(request.isComplete()).thenReturn(false);
-    tracker.addRequest(request);
-
-    tracker.restartRequests();
-
-    verify(request).pause();
-    verify(request).begin();
-  }
-
-  @Test
-  public void testDoesNotBeginFailedRequestOnRestartIfPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.pauseRequests();
-    tracker.addRequest(request);
-
-    tracker.restartRequests();
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testPausesFailedRequestOnRestartIfPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(true);
-    tracker.pauseRequests();
-    tracker.addRequest(request);
-
-    tracker.restartRequests();
-    verify(request).pause();
-  }
-
-  @Test
-  public void testDoesNotBeginIncompleteRequestsOnRestartIfPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(false);
-    when(request.isComplete()).thenReturn(false);
-    tracker.pauseRequests();
-    tracker.addRequest(request);
-    tracker.restartRequests();
-
-    verify(request, never()).begin();
-  }
-
-  @Test
-  public void testPausesIncompleteRequestsOnRestartIfPaused() {
-    Request request = mock(Request.class);
-    when(request.isFailed()).thenReturn(false);
-    when(request.isComplete()).thenReturn(false);
-    tracker.pauseRequests();
-    tracker.addRequest(request);
-    tracker.restartRequests();
-
-    verify(request).pause();
-  }
-
-  @Test
-  public void testReturnsTrueFromIsPausedWhenPaused() {
-    tracker.pauseRequests();
-    assertTrue(tracker.isPaused());
-  }
-
-  @Test
-  public void testReturnsFalseFromIsPausedWhenResumed() {
-    tracker.resumeRequests();
-    assertFalse(tracker.isPaused());
-  }
-
-  private class ClearAndRemoveRequest implements Answer<Void> {
-
-    private Request toRemove;
-
-    public ClearAndRemoveRequest(Request toRemove) {
-      this.toRemove = toRemove;
-    }
-
-    @Override
-    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-      tracker.clearRemoveAndRecycle(toRemove);
-      return null;
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
deleted file mode 100644
index b8940197b..000000000
--- a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
+++ /dev/null
@@ -1,361 +0,0 @@
-package com.bumptech.glide.request;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.app.Application;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.GradientDrawable;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.MultiTransformation;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.CircleCrop;
-import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
-import com.bumptech.glide.signature.ObjectKey;
-import com.bumptech.glide.util.Util;
-import com.google.common.testing.EqualsTester;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
-public class RequestOptionsTest {
-
-  private RequestOptions options;
-  @Mock private Transformation<Bitmap> transformation;
-  private Application app;
-
-  @Before
-  public void setUp() {
-    MockitoAnnotations.initMocks(this);
-    options = new RequestOptions();
-
-    app = RuntimeEnvironment.application;
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_byDefault_isTrue() {
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withFitCenter_isTrue() {
-    options.fitCenter();
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-    options.optionalFitCenter();
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withCenterInside_isTrue() {
-    options.centerInside();
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-    options.optionalCenterInside();
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withCenterCrop_isFalse() {
-    options.centerCrop();
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-    options.optionalCenterCrop();
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withCircleCrop_isFalse() {
-    options.circleCrop();
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-    options.circleCrop();
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withBitmapTransformation_isFalse() {
-    options.transform(transformation);
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-    options.optionalTransform(transformation);
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withCustomTransformation_isFalse() {
-    options.transform(Bitmap.class, transformation);
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-    options.optionalTransform(Bitmap.class, transformation);
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withDownsampleStrategy_isTrue() {
-    options.downsample(DownsampleStrategy.CENTER_OUTSIDE);
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withNonScaleAndThenDontTransform_isTrue() {
-    options.circleCrop().dontTransform();
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withNonScaleAndAppliedDontTransform_isTrue() {
-    options.circleCrop();
-    options.apply(new RequestOptions().dontTransform());
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withDontTransformAndAppliedNonScaleTransform_isFalse() {
-    options.fitCenter();
-    options.apply(new RequestOptions().circleCrop());
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withNonScaleOnly_andAppliedWithScaleOnly_isTrue() {
-    options.circleCrop();
-    options.apply(new RequestOptions().fitCenter());
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withScaleOnlyAndAppliedWithoutTransform_isTrue() {
-    options.fitCenter();
-    options.apply(new RequestOptions().dontAnimate());
-    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
-  }
-
-  @Test
-  public void isScaleOnlyOrNoTransform_withNonScaleOnlyAndAppliedWithoutTransform_isFalse() {
-    options.circleCrop();
-    options.apply(new RequestOptions().dontAnimate());
-    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationRequired_byDefault_isFalse() {
-    assertThat(options.isTransformationRequired()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationSet_byDefault_isFalse() {
-    assertThat(options.isTransformationSet()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationAllowed_byDefault_isTrue() {
-    assertThat(options.isTransformationAllowed()).isTrue();
-  }
-
-  @Test
-  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
-    RequestOptions other = new RequestOptions();
-    other.transform(Bitmap.class, transformation);
-    options.apply(other);
-    assertThat(options.isTransformationSet()).isTrue();
-  }
-
-  @Test
-  public void testIsTransformationSet_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationSet()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationAllowed()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationRequired_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationRequired()).isFalse();
-  }
-
-  @Test
-  public void testApplyingDontTransform_overridesTransformations() {
-    options.transform(transformation);
-    options.dontTransform();
-    assertThat(options.isTransformationSet()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingTransformation_overridesDontTransform() {
-    options.dontTransform();
-    options.transform(transformation);
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  @Test
-  public void testApplyingOptions_withDontTransform_overridesTransformations() {
-    options.transform(transformation);
-    RequestOptions other = new RequestOptions();
-    other.dontTransform();
-
-    options.apply(other);
-
-    assertThat(options.isTransformationAllowed()).isFalse();
-    assertThat(options.isTransformationSet()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingOptions_withTransformation_overridesDontTransform() {
-    options.dontTransform();
-    RequestOptions other = new RequestOptions();
-    other.transform(transformation);
-
-    options.apply(other);
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationSet()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  @Test
-  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
-    options.dontTransform();
-    options.apply(new RequestOptions());
-
-    assertThat(options.isTransformationAllowed()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
-    options.transform(transformation);
-    options.apply(new RequestOptions());
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  @Test
-  @SuppressWarnings({"unchecked", "varargs"})
-  public void testApplyMultiTransform() {
-    options.transforms(new CircleCrop(), new CenterCrop());
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsKey(Bitmap.class);
-    assertThat(options.getTransformations().get(Bitmap.class))
-      .isInstanceOf(MultiTransformation.class);
-  }
-
-  @Test
-  public void testEqualsHashCode() {
-    Drawable first = new ColorDrawable(Color.RED);
-    Drawable second = new GradientDrawable();
-    assertThat(first).isNotEqualTo(second);
-    assertThat(Util.bothNullOrEqual(first, second)).isFalse();
-    new EqualsTester()
-        .addEqualityGroup(
-            new RequestOptions().sizeMultiplier(.7f),
-            new RequestOptions().sizeMultiplier(.7f))
-        .addEqualityGroup(new RequestOptions().sizeMultiplier(0.8f))
-        .addEqualityGroup(new RequestOptions().error(1), new RequestOptions().error(1))
-        .addEqualityGroup(new RequestOptions().error(2))
-        .addEqualityGroup(new RequestOptions().error(first), new RequestOptions().error(first))
-        .addEqualityGroup(new RequestOptions().error(second))
-        .addEqualityGroup(new RequestOptions().placeholder(1), new RequestOptions().placeholder(1))
-        .addEqualityGroup(new RequestOptions().placeholder(2))
-        .addEqualityGroup(
-            new RequestOptions().placeholder(first),
-            new RequestOptions().placeholder(first))
-        .addEqualityGroup(new RequestOptions().placeholder(second))
-        .addEqualityGroup(new RequestOptions().fallback(1), new RequestOptions().fallback(1))
-        .addEqualityGroup(new RequestOptions().fallback(2))
-        .addEqualityGroup(
-            new RequestOptions().fallback(first),
-            new RequestOptions().fallback(first))
-        .addEqualityGroup(new RequestOptions().fallback(second))
-        .addEqualityGroup(
-            new RequestOptions().skipMemoryCache(true),
-            new RequestOptions().skipMemoryCache(true))
-        .addEqualityGroup(
-            new RequestOptions(),
-            new RequestOptions().skipMemoryCache(false),
-            new RequestOptions().theme(null),
-            new RequestOptions().onlyRetrieveFromCache(false),
-            new RequestOptions().useUnlimitedSourceGeneratorsPool(false))
-        .addEqualityGroup(
-            new RequestOptions().override(100),
-            new RequestOptions().override(100, 100))
-        .addEqualityGroup(
-            new RequestOptions().override(200),
-            new RequestOptions().override(200, 200))
-        .addEqualityGroup(
-            new RequestOptions().override(100, 200),
-            new RequestOptions().override(100, 200))
-        .addEqualityGroup(
-            new RequestOptions().override(200, 100),
-            new RequestOptions().override(200, 100))
-        .addEqualityGroup(
-            new RequestOptions().centerCrop(),
-            new RequestOptions().centerCrop())
-        .addEqualityGroup(
-            new RequestOptions().optionalCenterCrop(),
-            new RequestOptions().optionalCenterCrop())
-        .addEqualityGroup(new RequestOptions().fitCenter())
-        .addEqualityGroup(new RequestOptions().circleCrop())
-        .addEqualityGroup(new RequestOptions().centerInside())
-        .addEqualityGroup(
-            new RequestOptions().useUnlimitedSourceGeneratorsPool(true),
-            new RequestOptions().useUnlimitedSourceGeneratorsPool(true))
-        .addEqualityGroup(
-            new RequestOptions().onlyRetrieveFromCache(true),
-            new RequestOptions().onlyRetrieveFromCache(true))
-        .addEqualityGroup(
-            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL),
-            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL))
-        .addEqualityGroup(
-            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE))
-        .addEqualityGroup(
-            new RequestOptions().priority(Priority.HIGH),
-            new RequestOptions().priority(Priority.HIGH))
-        .addEqualityGroup(
-            new RequestOptions().priority(Priority.LOW))
-        .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test"), true),
-            new RequestOptions().set(Option.<Boolean>memory("test"), true))
-        .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test"), false))
-        .addEqualityGroup(
-            new RequestOptions().set(Option.<Boolean>memory("test2"), true))
-        .addEqualityGroup(
-            new RequestOptions().decode(Integer.class),
-            new RequestOptions().decode(Integer.class))
-        .addEqualityGroup(
-            new RequestOptions().decode(Float.class))
-        .addEqualityGroup(
-            new RequestOptions().signature(new ObjectKey("test")),
-            new RequestOptions().signature(new ObjectKey("test")))
-        .addEqualityGroup(
-            new RequestOptions().signature(new ObjectKey("test2")))
-        .addEqualityGroup(
-            new RequestOptions().theme(app.getTheme()),
-            new RequestOptions().theme(app.getTheme()))
-        .testEquals();
-  }
-
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
new file mode 100644
index 000000000..0442624e7
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
@@ -0,0 +1,702 @@
+package com.bumptech.glide.request.target;
+
+import static android.view.ViewGroup.LayoutParams;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.view.Display;
+import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import com.google.common.truth.Truth;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.TextLayoutMode;
+import org.robolectric.util.ReflectionHelpers;
+
+/**
+ * Test for {@link CustomViewTarget}.
+ *
+ * <p>TODO: This should really be in the tests subproject, but that causes errors because the R
+ * class referenced in {@link CustomViewTarget} can't be found. This should be fixable with some
+ * gradle changes, but I've so far failed to figure out the right set of commands.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 19, manifest = "build/intermediates/manifests/full/debug/AndroidManifest.xml")
+@TextLayoutMode(value = TextLayoutMode.Mode.LEGACY, issueId = "130378660")
+public class CustomViewTargetTest {
+  private ActivityController<Activity> activity;
+  private View view;
+  private ViewGroup parent;
+  private CustomViewTarget<View, Object> target;
+  @Mock private SizeReadyCallback cb;
+  @Mock private Request request;
+  private int sdkVersion;
+  private AttachStateTarget attachStateTarget;
+
+  @Before
+  public void setUp() {
+    sdkVersion = Build.VERSION.SDK_INT;
+    MockitoAnnotations.initMocks(this);
+    activity = Robolectric.buildActivity(Activity.class).create().start().postCreate(null).resume();
+    view = new View(activity.get());
+    target = new TestViewTarget(view);
+    attachStateTarget = new AttachStateTarget(view);
+
+    LinearLayout linearLayout = new LinearLayout(activity.get());
+    View expandView = new View(activity.get());
+    LinearLayout.LayoutParams linearLayoutParams =
+        new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, /*height=*/ 0);
+    linearLayoutParams.weight = 1f;
+    expandView.setLayoutParams(linearLayoutParams);
+    linearLayout.addView(expandView);
+
+    parent = new FrameLayout(activity.get());
+    parent.addView(view);
+    linearLayout.addView(parent);
+
+    activity.get().setContentView(linearLayout);
+  }
+
+  @After
+  public void tearDown() {
+    setSdkVersionInt(sdkVersion);
+    CustomViewTarget.SizeDeterminer.maxDisplayLength = null;
+  }
+
+  @Test
+  public void testReturnsWrappedView() {
+    assertEquals(view, target.getView());
+  }
+
+  @Test
+  public void testReturnsNullFromGetRequestIfNoRequestSet() {
+    assertNull(target.getRequest());
+  }
+
+  @Test
+  public void testCanSetAndRetrieveRequest() {
+    target.setRequest(request);
+
+    assertEquals(request, target.getRequest());
+  }
+
+  @Test
+  public void testRetrievesRequestFromPreviousTargetForView() {
+    target.setRequest(request);
+
+    CustomViewTarget<View, Object> second = new TestViewTarget(view);
+
+    assertEquals(request, second.getRequest());
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
+    int dimens = 333;
+    // activity.get().setContentView(view);
+    view.layout(0, 0, dimens, dimens);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet() {
+    int dimens = 444;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(dimens, dimens);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void getSize_withBothWrapContent_usesDisplayDimens() {
+    LayoutParams layoutParams =
+        new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(layoutParams);
+
+    setDisplayDimens(200, 300);
+
+    activity.visible();
+    view.layout(0, 0, 0, 0);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(300, 300);
+  }
+
+  @Test
+  public void getSize_withWrapContentWidthAndValidHeight_usesDisplayDimenAndValidHeight() {
+    int height = 100;
+    LayoutParams params = new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, height);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(100, 200);
+
+    activity.visible();
+    view.setRight(0);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(200, height);
+  }
+
+  @Test
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndDisplayDimen() {
+    int width = 100;
+    LayoutParams params = new FrameLayout.LayoutParams(width, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+    setDisplayDimens(200, 100);
+    parent.getLayoutParams().height = 200;
+
+    activity.visible();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(width, 200);
+  }
+
+  @Test
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesDisplayDimenWidthAndHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(500, 600);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int height = 32;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(600, height);
+  }
+
+  @Test
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndDisplayDimenHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(300, 400);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int width = 32;
+    parent.getLayoutParams().width = 32;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(width, 400);
+  }
+
+  @Test
+  public void testMatchParentWidthAndHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(parent.getWidth()), eq(parent.getHeight()));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
+    target.getSize(cb);
+
+    int width = 12;
+    int height = 32;
+    parent.getLayoutParams().width = width;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbacksAreCalledInOrderPreDraw() {
+    SizeReadyCallback[] cbs = new SizeReadyCallback[25];
+    for (int i = 0; i < cbs.length; i++) {
+      cbs[i] = mock(SizeReadyCallback.class);
+      target.getSize(cbs[i]);
+    }
+
+    int width = 100, height = 111;
+    parent.getLayoutParams().width = width;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    InOrder order = inOrder((Object[]) cbs);
+    for (SizeReadyCallback cb : cbs) {
+      order.verify(cb).onSizeReady(eq(width), eq(height));
+    }
+  }
+
+  @Test
+  public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
+    target.getSize(cb);
+    target.getSize(cb);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testDoesNotAddMultipleListenersIfMultipleCallbacksAreAdded() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+    target.getSize(cb2);
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    // assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
+  }
+
+  @Test
+  public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    view.setLayoutParams(
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+    target.getSize(cb2);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb2).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
+    target.getSize(cb);
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    activity.visible();
+    verify(cb).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
+    target.getSize(cb);
+
+    int width = 689;
+    int height = 354;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
+    activity.visible();
+    target.getSize(cb);
+
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(1234, 4123);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
+    SizeReadyCallback firstCb = mock(SizeReadyCallback.class);
+    SizeReadyCallback secondCb = mock(SizeReadyCallback.class);
+    target.getSize(firstCb);
+    target.getSize(secondCb);
+
+    int width = 68;
+    int height = 875;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(firstCb, times(1)).onSizeReady(eq(width), eq(height));
+    verify(secondCb, times(1)).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
+    target.getSize(cb);
+
+    int width = 1;
+    int height = 2;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    ViewTreeObserver vto = view.getViewTreeObserver();
+    view.requestLayout();
+    activity.visible();
+    assertFalse(vto.isAlive());
+    vto.dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfGivenNullView() {
+    new TestViewTarget(null);
+  }
+
+  @Test
+  public void testDecreasesDimensionsByViewPadding() {
+    activity.visible();
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.setPadding(25, 25, 25, 25);
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(50, 50);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_notLaidOut_notLayoutRequested_callsSizeReady() {
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withLayoutParams_notLaidOut_doesCallSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(10, 10));
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_emptyParams_notLaidOutOrLayoutRequested_callsSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(0, 0));
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeReady() {
+    setSdkVersionInt(18);
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.requestLayout();
+    view.setPadding(50, 50, 50, 50);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  private void setDisplayDimens(Integer width, Integer height) {
+    WindowManager windowManager =
+        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
+    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+    if (width != null) {
+      Shadows.shadowOf(display).setWidth(width);
+    }
+
+    if (height != null) {
+      Shadows.shadowOf(display).setHeight(height);
+    }
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    activity.visible();
+  }
+
+  // This behavior isn't clearly correct, but it doesn't seem like there's any harm to clear an
+  // already cleared request, so we might as well avoid the extra check/complexity in the code.
+  @Test
+  public void clearOnDetach_onDetach_withClearedRequest_clearsRequest() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withRunningRequest_pausesRequestOnce() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_moreThanOnce_registersObserverOnce() {
+    activity.visible();
+    attachStateTarget.setRequest(request);
+    attachStateTarget.clearOnDetach().clearOnDetach();
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
+    activity.visible();
+    attachStateTarget.clearOnDetach().clearOnDetach().clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterLoadCleared_clearsRequest() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    activity.visible();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withRunningRequest_doesNotBeginRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(false);
+    activity.visible();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withClearedRequest_beginsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    activity.visible();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_afterLoadClearedAndRestarted_onAttach_beginsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    activity.visible();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_afterLoadCleared_doesNotBeingRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    activity.visible();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void onLoadStarted_withoutClearOnDetach_doesNotAddListener() {
+    activity.visible();
+    target.setRequest(request);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void onLoadCleared_withoutClearOnDetach_doesNotRemoveListeners() {
+    final AtomicInteger count = new AtomicInteger();
+    OnAttachStateChangeListener expected =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {
+            count.incrementAndGet();
+          }
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {
+            // Intentionally Empty.
+          }
+        };
+    view.addOnAttachStateChangeListener(expected);
+
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+
+    activity.visible();
+
+    Truth.assertThat(count.get()).isEqualTo(1);
+  }
+
+  private static final class AttachStateTarget extends CustomViewTarget<View, Object> {
+    AttachStateTarget(View view) {
+      super(view);
+    }
+
+    @Override
+    protected void onResourceCleared(@Nullable Drawable placeholder) {
+      // Intentionally Empty.
+    }
+
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Intentionally Empty.
+    }
+
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+      // Intentionally Empty.
+    }
+  }
+
+  private static final class TestViewTarget extends CustomViewTarget<View, Object> {
+
+    TestViewTarget(View view) {
+      super(view);
+    }
+
+    @Override
+    protected void onResourceCleared(@Nullable Drawable placeholder) {
+      // Intentionally Empty.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onResourceLoading(@Nullable Drawable placeholder) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Avoid calling super.
+    }
+  }
+
+  private static void setSdkVersionInt(int version) {
+    ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", version);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
deleted file mode 100644
index 7a55e9990..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.bumptech.glide.signature;
-
-import static org.junit.Assert.assertNotNull;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-import org.junit.After;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ApplicationVersionSignatureTest {
-
-  @After
-  public void tearDown() {
-    ApplicationVersionSignature.reset();
-  }
-
-  @Test
-  public void testCanGetKeyForSignature() {
-    Key key = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    assertNotNull(key);
-  }
-
-  @Test
-  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
-      throws NoSuchAlgorithmException, UnsupportedEncodingException {
-    Key first = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    Key second = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
deleted file mode 100644
index 7f465fb23..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MediaStoreSignatureTest {
-
-  @Test
-  public void testSignaturesDifferIfMimeTypeDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("first", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("second", 100, 1);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesDifferIfDateModifiedDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 999, 1);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesDifferIfOrientationDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 9);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesAreTheSameIfAllArgsAreTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 1);
-
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
deleted file mode 100644
index 21570323c..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-import java.security.NoSuchAlgorithmException;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ObjectKeyTest {
-
-  @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    Object object = new Object();
-    KeyAssertions.assertSame(new ObjectKey(object), new ObjectKey(object));
-    KeyAssertions.assertDifferent(new ObjectKey(object), new ObjectKey(new Object()));
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
deleted file mode 100644
index 7b94a888c..000000000
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.bumptech.glide.tests;
-
-import static org.mockito.Mockito.mock;
-
-import android.os.Looper;
-import android.os.MessageQueue;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowLooper;
-
-@Implements(Looper.class)
-public class GlideShadowLooper extends ShadowLooper {
-
-  @Implementation
-  public static MessageQueue myQueue() {
-    return mock(MessageQueue.class);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
deleted file mode 100644
index 5ee17790a..000000000
--- a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.bumptech.glide.tests;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.bumptech.glide.load.Key;
-import com.google.common.testing.EqualsTester;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public class KeyAssertions {
-
-  public static void assertSame(Key first, Key second) throws NoSuchAlgorithmException {
-    assertSameOrdered(first, second);
-    assertSameOrdered(second, first);
-  }
-
-  private static void assertSameOrdered(Key first, Key second) throws NoSuchAlgorithmException {
-    new EqualsTester()
-        .addEqualityGroup(first, second)
-        .testEquals();
-
-    assertThat(getDigest(first)).isEqualTo(getDigest(second));
-  }
-
-  public static void assertDifferent(Key first, Key second) throws NoSuchAlgorithmException {
-    assertDifferent(first, second, true);
-    assertDifferent(second, first, true);
-  }
-
-  public static void assertDifferent(Key first, Key second, boolean checkDiskCacheKey)
-      throws NoSuchAlgorithmException {
-    new EqualsTester()
-        .addEqualityGroup(first)
-        .addEqualityGroup(second)
-        .testEquals();
-
-    if (checkDiskCacheKey) {
-      MessageDigest firstDigest = MessageDigest.getInstance("SHA-1");
-      first.updateDiskCacheKey(firstDigest);
-      MessageDigest secondDigest = MessageDigest.getInstance("SHA-1");
-      second.updateDiskCacheKey(secondDigest);
-
-      assertThat(getDigest(first)).isNotEqualTo(getDigest(second));
-    }
-  }
-
-  private static byte[] getDigest(Key key) throws NoSuchAlgorithmException {
-    MessageDigest md = MessageDigest.getInstance("SHA-1");
-    key.updateDiskCacheKey(md);
-    return md.digest();
-  }
-}
diff --git a/library/src/test/java/javax/microedition/khronos/opengles/GL.java b/library/src/test/java/javax/microedition/khronos/opengles/GL.java
deleted file mode 100644
index 40792a85f..000000000
--- a/library/src/test/java/javax/microedition/khronos/opengles/GL.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package javax.microedition.khronos.opengles;
-
-/**
- * TODO: Figure out why this is necessary and remove it.
- * See: https://github.com/robolectric/robolectric-gradle-plugin/issues/145
- */
-public interface GL {
-}
-
diff --git a/library/src/test/resources/exif-orientation-examples b/library/src/test/resources/exif-orientation-examples
deleted file mode 160000
index 85c6e142e..000000000
--- a/library/src/test/resources/exif-orientation-examples
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 85c6e142ee57d1c5c7a29b2efcd5980a584758e2
diff --git a/library/test/build.gradle b/library/test/build.gradle
new file mode 100644
index 000000000..41f86f441
--- /dev/null
+++ b/library/test/build.gradle
@@ -0,0 +1,63 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    testImplementation "androidx.appcompat:appcompat:${ANDROID_X_VERSION}"
+    testImplementation project(':library')
+    testImplementation project(':testutil')
+    testImplementation 'com.google.guava:guava-testlib:18.0'
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation "androidx.legacy:legacy-support-v4:${ANDROID_X_VERSION}"
+    testImplementation "androidx.test:core:${ANDROID_X_VERSION}"
+}
+
+tasks.withType(JavaCompile) {
+    options.fork = true
+}
+
+afterEvaluate {
+    lint.enabled = false
+    compileDebugJavaWithJavac.enabled = false
+}
+
+android.testOptions.unitTests.all { Test testTask ->
+    // configure max heap size of the test JVM
+    testTask.maxHeapSize = TEST_JVM_MEMORY_SIZE as String
+    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
+        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
+        testTask.jvmArgs "-XX:MaxPermSize=${TEST_JVM_MEMORY_SIZE}"
+    }
+
+    // Initializing Robolectric is expensive, two threads seem to be around the only level where any
+    // improvement is seen.
+    testTask.maxParallelForks = 2
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
+    testOptions.unitTests.includeAndroidResources = true
+
+    sourceSets {
+        androidTest {
+            resources.srcDirs += ['../../third_party/exif_orientation_examples']
+        }
+        test {
+            resources.srcDirs += ['../../third_party/exif_orientation_examples']
+        }
+    }
+}
diff --git a/library/test/gradle.properties b/library/test/gradle.properties
new file mode 100644
index 000000000..9eff84e6c
--- /dev/null
+++ b/library/test/gradle.properties
@@ -0,0 +1 @@
+android.enableUnitTestBinaryResources=true
diff --git a/library/test/src/main/AndroidManifest.xml b/library/test/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..600ac91f9
--- /dev/null
+++ b/library/test/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.bumptech.glide.test">
+    <application/>
+</manifest>
diff --git a/library/src/test/java/com/bumptech/glide/GlideContextTest.java b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
similarity index 71%
rename from library/src/test/java/com/bumptech/glide/GlideContextTest.java
rename to library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
index 199ecb38e..2217668ca 100644
--- a/library/src/test/java/com/bumptech/glide/GlideContextTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
@@ -8,11 +8,16 @@
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.util.Log;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.Glide.RequestOptionsFactory;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import org.junit.Before;
@@ -20,10 +25,8 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
 public final class GlideContextTest {
   private Map<Class<?>, TransitionOptions<?, ?>> transitionOptions;
   private GlideContext context;
@@ -33,9 +36,24 @@ public void setUp() {
     Application app = RuntimeEnvironment.application;
 
     transitionOptions = new HashMap<>();
-    context = new GlideContext(app, new Registry(),
-        new ImageViewTargetFactory(), new RequestOptions(),
-        transitionOptions, mock(Engine.class), Log.DEBUG);
+    context =
+        new GlideContext(
+            app,
+            new LruArrayPool(),
+            new Registry(),
+            new ImageViewTargetFactory(),
+            new RequestOptionsFactory() {
+              @NonNull
+              @Override
+              public RequestOptions build() {
+                return new RequestOptions();
+              }
+            },
+            transitionOptions,
+            /*defaultRequestListeners=*/ Collections.<RequestListener<Object>>emptyList(),
+            mock(Engine.class),
+            /*isLoggingRequestOriginsEnabled=*/ false,
+            Log.DEBUG);
   }
 
   @Test
@@ -55,17 +73,14 @@ public void getDefaultTransitionOptions_withNonMatchingOptionRegistered_returnsD
   public void getDefaultTransitionOptions_withMatchingOptionsRegistered_returnsMatchingOptions() {
     GenericTransitionOptions<Object> expected = new GenericTransitionOptions<>();
     transitionOptions.put(Bitmap.class, expected);
-    assertThat(context.getDefaultTransitionOptions(Bitmap.class))
-        .isEqualTo(expected);
+    assertThat(context.getDefaultTransitionOptions(Bitmap.class)).isEqualTo(expected);
   }
 
   @Test
   public void getDefaultTransitionOptions_withSuperClassRegistered_returnsSuperClassOptions() {
     DrawableTransitionOptions expected = new DrawableTransitionOptions();
     transitionOptions.put(Drawable.class, expected);
-    assertThat(context.getDefaultTransitionOptions(BitmapDrawable.class))
-        .isEqualTo(expected);
-    assertThat(context.getDefaultTransitionOptions(GifDrawable.class))
-        .isEqualTo(expected);
+    assertThat(context.getDefaultTransitionOptions(BitmapDrawable.class)).isEqualTo(expected);
+    assertThat(context.getDefaultTransitionOptions(GifDrawable.class)).isEqualTo(expected);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
similarity index 64%
rename from library/src/test/java/com/bumptech/glide/GlideTest.java
rename to library/test/src/test/java/com/bumptech/glide/GlideTest.java
index dfb45ba0c..406a2da6a 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
@@ -3,8 +3,10 @@
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
 import static com.bumptech.glide.request.RequestOptions.errorOf;
 import static com.bumptech.glide.request.RequestOptions.placeholderOf;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -14,11 +16,9 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Shadows.shadowOf;
 
 import android.content.ContentResolver;
 import android.content.Context;
-import android.content.pm.ApplicationInfo;
 import android.content.res.AssetFileDescriptor;
 import android.graphics.Bitmap;
 import android.graphics.Color;
@@ -27,11 +27,12 @@
 import android.graphics.drawable.Drawable;
 import android.media.MediaMetadataRetriever;
 import android.net.Uri;
-import android.os.Bundle;
 import android.os.Handler;
 import android.os.ParcelFileDescriptor;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
@@ -51,25 +52,31 @@
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.CustomTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.testutil.TestResourceUtil;
+import com.bumptech.glide.util.Preconditions;
 import java.io.ByteArrayInputStream;
 import java.io.File;
-import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.HashMap;
 import java.util.Map;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
@@ -81,70 +88,90 @@
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
-import org.robolectric.shadows.ShadowPackageManager;
 
-/**
- * Tests for the {@link Glide} interface and singleton.
- */
+/** Tests for the {@link Glide} interface and singleton. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
-    GlideTest.ShadowFileDescriptorContentResolver.class,
-    GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
-    GlideTest.MutableShadowBitmap.class })
-@SuppressWarnings({"unchecked", "deprecation"})
+@Config(
+    sdk = 18,
+    shadows = {
+      GlideTest.ShadowFileDescriptorContentResolver.class,
+      GlideTest.ShadowMediaMetadataRetriever.class,
+      GlideShadowLooper.class,
+      GlideTest.MutableShadowBitmap.class
+    })
+@SuppressWarnings("unchecked")
 public class GlideTest {
+  // Fixes method overload confusion.
+  private static final Object NULL = null;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   @SuppressWarnings("rawtypes")
-  private Target target = null;
+  @Mock
+  private Target target;
+
+  @Mock private DiskCache.Factory diskCacheFactory;
+  @Mock private DiskCache diskCache;
+  @Mock private MemoryCache memoryCache;
+  @Mock private Handler bgHandler;
+  @Mock private Lifecycle lifecycle;
+  @Mock private RequestManagerTreeNode treeNode;
+  @Mock private BitmapPool bitmapPool;
+
   private ImageView imageView;
   private RequestManager requestManager;
+  private Context context;
 
   @Before
-  public void setUp() throws Exception {
-    Glide.tearDown();
-
-    ShadowPackageManager pm = shadowOf(RuntimeEnvironment.application.getPackageManager());
-    ApplicationInfo info =
-        pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
-    info.metaData = new Bundle();
-    info.metaData.putString(SetupModule.class.getName(), "GlideModule");
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+    // Run all tasks on the main thread so they complete synchronously.
+    GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
+    when(diskCacheFactory.build()).thenReturn(diskCache);
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(memoryCache)
+            .setDiskCache(diskCacheFactory)
+            .setSourceExecutor(executor)
+            .setDiskCacheExecutor(executor));
+    Registry registry = Glide.get(context).getRegistry();
+    registerMockModelLoader(
+        GlideUrl.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, ParcelFileDescriptor.class, mock(ParcelFileDescriptor.class), registry);
+    registerMockModelLoader(File.class, ByteBuffer.class, ByteBuffer.allocate(10), registry);
 
     // Ensure that target's size ready callback will be called synchronously.
-    target = mock(Target.class);
-    imageView = new ImageView(RuntimeEnvironment.application);
+    imageView = new ImageView(context);
     imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
     imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
-    Handler bgHandler = mock(Handler.class);
-    when(bgHandler.post(isA(Runnable.class))).thenAnswer(new Answer<Boolean>() {
-      @Override
-      public Boolean answer(InvocationOnMock invocation) throws Throwable {
-        Runnable runnable = (Runnable) invocation.getArguments()[0];
-        runnable.run();
-        return true;
-      }
-    });
-
-    Lifecycle lifecycle = mock(Lifecycle.class);
-    RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(Glide.get(getContext()), lifecycle, treeNode, getContext());
+    when(bgHandler.post(isA(Runnable.class)))
+        .thenAnswer(
+            new Answer<Boolean>() {
+              @Override
+              public Boolean answer(InvocationOnMock invocation) {
+                Runnable runnable = (Runnable) invocation.getArguments()[0];
+                runnable.run();
+                return true;
+              }
+            });
+
+    requestManager = new RequestManager(Glide.get(context), lifecycle, treeNode, context);
     requestManager.resumeRequests();
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
   @Test
   public void testCanSetMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -153,13 +180,9 @@ public void testCanSetMemoryCategory() {
 
   @Test
   public void testCanIncreaseMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -176,13 +199,9 @@ public void testCanIncreaseMemoryCategory() {
 
   @Test
   public void testCanDecreaseMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -199,12 +218,8 @@ public void testCanDecreaseMemoryCategory() {
 
   @Test
   public void testClearMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
 
     glide.clearMemory();
 
@@ -214,12 +229,8 @@ public void testClearMemory() {
 
   @Test
   public void testTrimMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .build(getContext());
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
 
     final int level = 123;
 
@@ -230,13 +241,13 @@ public void testTrimMemory() {
   }
 
   @Test
-  public void testFileDefaultLoaderWithInputStream() throws Exception {
+  public void testFileDefaultLoaderWithInputStream() {
     registerFailFactory(File.class, ParcelFileDescriptor.class);
     runTestFileDefaultLoader();
   }
 
   @Test
-  public void testFileDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testFileDefaultLoaderWithFileDescriptor() {
     registerFailFactory(File.class, InputStream.class);
     runTestFileDefaultLoader();
   }
@@ -259,6 +270,7 @@ private void runTestFileDefaultLoader() {
     assertNotNull(imageView.getDrawable());
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   public void testUrlDefaultLoader() throws MalformedURLException {
     URL url = new URL("http://www.google.com");
@@ -293,13 +305,49 @@ public void testToBytesOption() {
   }
 
   @Test
-  public void testUriDefaultLoaderWithInputStream() throws Exception {
+  public void testLoadColorDrawable_withUnitBitmapTransformation_returnsColorDrawable() {
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(colorDrawable)
+        .apply(new RequestOptions().override(100, 100).centerCrop())
+        .into(target);
+
+    ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(argumentCaptor.capture(), isA(Transition.class));
+
+    Object result = argumentCaptor.getValue();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  @Test
+  public void testLoadColorDrawable_withNonUnitBitmapTransformation_returnsBitmapDrawable() {
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(colorDrawable)
+        .apply(new RequestOptions().override(100, 100).circleCrop())
+        .into(target);
+
+    ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(argumentCaptor.capture(), isA(Transition.class));
+
+    Object result = argumentCaptor.getValue();
+
+    assertThat(result).isInstanceOf(BitmapDrawable.class);
+    Bitmap bitmap = ((BitmapDrawable) result).getBitmap();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(100);
+  }
+
+  @Test
+  public void testUriDefaultLoaderWithInputStream() {
     registerFailFactory(Uri.class, ParcelFileDescriptor.class);
     runTestUriDefaultLoader();
   }
 
   @Test
-  public void testUriDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testUriDefaultLoaderWithFileDescriptor() {
     registerFailFactory(Uri.class, InputStream.class);
     runTestUriDefaultLoader();
   }
@@ -328,13 +376,13 @@ public void testStringDefaultLoaderWithUrl() {
   }
 
   @Test
-  public void testFileStringDefaultLoaderWithInputStream() throws Exception {
+  public void testFileStringDefaultLoaderWithInputStream() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestFileStringDefaultLoader();
   }
 
   @Test
-  public void testFileStringDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testFileStringDefaultLoaderWithFileDescriptor() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestFileStringDefaultLoader();
   }
@@ -351,13 +399,13 @@ private void runTestFileStringDefaultLoader() {
   }
 
   @Test
-  public void testUriStringDefaultLoaderWithInputStream() throws Exception {
+  public void testUriStringDefaultLoaderWithInputStream() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestUriStringDefaultLoader();
   }
 
   @Test
-  public void testUriStringDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testUriStringDefaultLoaderWithFileDescriptor() {
     registerFailFactory(String.class, InputStream.class);
     runTestUriStringDefaultLoader();
   }
@@ -374,19 +422,30 @@ private void runTestUriStringDefaultLoader() {
   }
 
   private void runTestStringDefaultLoader(String string) {
-    requestManager.load(string).listener(new RequestListener<Drawable>() {
-      @Override
-      public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
-          boolean isFirstResource) {
-        throw new RuntimeException("Load failed");
-      }
-
-      @Override
-      public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
-          DataSource dataSource, boolean isFirstResource) {
-        return false;
-      }
-    }).into(target);
+    requestManager
+        .load(string)
+        .listener(
+            new RequestListener<Drawable>() {
+              @Override
+              public boolean onLoadFailed(
+                  GlideException e,
+                  Object model,
+                  Target<Drawable> target,
+                  boolean isFirstResource) {
+                throw new RuntimeException("Load failed");
+              }
+
+              @Override
+              public boolean onResourceReady(
+                  Drawable resource,
+                  Object model,
+                  Target<Drawable> target,
+                  DataSource dataSource,
+                  boolean isFirstResource) {
+                return false;
+              }
+            })
+        .into(target);
     requestManager.load(string).into(imageView);
 
     verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
@@ -396,13 +455,13 @@ public boolean onResourceReady(Drawable resource, Object model, Target<Drawable>
   }
 
   @Test
-  public void testIntegerDefaultLoaderWithInputStream() throws Exception {
+  public void testIntegerDefaultLoaderWithInputStream() {
     registerFailFactory(Integer.class, ParcelFileDescriptor.class);
     runTestIntegerDefaultLoader();
   }
 
   @Test
-  public void testIntegerDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testIntegerDefaultLoaderWithFileDescriptor() {
     registerFailFactory(Integer.class, InputStream.class);
     runTestIntegerDefaultLoader();
   }
@@ -437,7 +496,6 @@ public void testByteArrayDefaultLoader() {
     assertNotNull(imageView.getDrawable());
   }
 
-
   @Test(expected = Exception.class)
   public void testUnregisteredModelThrowsException() {
     Float unregistered = 0.5f;
@@ -453,9 +511,9 @@ public void testNonDefaultModelWithRegisteredFactoryDoesNotThrow() {
   }
 
   @Test
-  public void testReceivesGif() throws IOException {
+  public void testReceivesGif() {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.asGif().load(fakeUri).into(target);
@@ -464,12 +522,15 @@ public void testReceivesGif() throws IOException {
   }
 
   @Test
-  public void testReceivesGifBytes() throws IOException {
+  public void testReceivesGifBytes() {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
-    requestManager.as(byte[].class).apply(decodeTypeOf(GifDrawable.class)).load(fakeUri)
+    requestManager
+        .as(byte[].class)
+        .apply(decodeTypeOf(GifDrawable.class))
+        .load(fakeUri)
         .into(target);
 
     verify(target).onResourceReady(isA(byte[].class), isA(Transition.class));
@@ -488,27 +549,30 @@ public void testReceivesBitmapBytes() {
   public void testReceivesThumbnails() {
     String full = mockUri("content://full");
     String thumb = mockUri("content://thumb");
-    requestManager
-        .load(full)
-        .thumbnail(requestManager.load(thumb))
-        .into(target);
+    requestManager.load(full).thumbnail(requestManager.load(thumb)).into(target);
 
     verify(target, times(2)).onResourceReady(isA(Drawable.class), isA(Transition.class));
   }
 
   @Test
   public void testReceivesRecursiveThumbnails() {
-    requestManager.load(mockUri("content://first")).thumbnail(
-        requestManager.load(mockUri("content://second")).thumbnail(
-            requestManager.load(mockUri("content://third")).thumbnail(
-                requestManager.load(mockUri("content://fourth")))))
+    requestManager
+        .load(mockUri("content://first"))
+        .thumbnail(
+            requestManager
+                .load(mockUri("content://second"))
+                .thumbnail(
+                    requestManager
+                        .load(mockUri("content://third"))
+                        .thumbnail(requestManager.load(mockUri("content://fourth")))))
         .into(target);
     verify(target, times(4)).onResourceReady(isA(Drawable.class), isA(Transition.class));
   }
 
   @Test
   public void testReceivesRecursiveThumbnailWithPercentage() {
-    requestManager.load(mockUri("content://first"))
+    requestManager
+        .load(mockUri("content://first"))
         .thumbnail(requestManager.load(mockUri("content://second")).thumbnail(0.5f))
         .into(target);
     verify(target, times(3)).onResourceReady(isA(Drawable.class), isA(Transition.class));
@@ -516,26 +580,23 @@ public void testReceivesRecursiveThumbnailWithPercentage() {
 
   @Test
   public void testNullModelInGenericImageLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericVideoLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelDoesNotThrow() {
     Drawable drawable = new ColorDrawable(Color.RED);
-    requestManager
-        .load(null)
-        .apply(errorOf(drawable))
-        .into(target);
+    requestManager.load(NULL).apply(errorOf(drawable)).into(target);
 
     verify(target).onLoadFailed(eq(drawable));
   }
@@ -545,15 +606,40 @@ public void testNullModelPrefersErrorDrawable() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
     Drawable error = new ColorDrawable(Color.RED);
 
-    requestManager
-        .load(null)
-        .apply(placeholderOf(placeholder)
-            .error(error))
-        .into(target);
+    requestManager.load(NULL).apply(placeholderOf(placeholder).error(error)).into(target);
 
     verify(target).onLoadFailed(eq(error));
   }
 
+  @Test
+  public void testLoadBitmap_asBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager.asBitmap().load(bitmap).into(target);
+
+    verify(target).onResourceReady(eq(bitmap), any(Transition.class));
+  }
+
+  @Test
+  public void testLoadBitmap_asDrawable() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager.load(bitmap).into(target);
+
+    ArgumentCaptor<Object> captor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(captor.capture(), any(Transition.class));
+    BitmapDrawable drawable = (BitmapDrawable) captor.getValue();
+    assertThat(drawable.getBitmap()).isEqualTo(bitmap);
+  }
+
+  @Test
+  public void testLoadDrawable() {
+    Drawable drawable = new ColorDrawable(Color.RED);
+    requestManager.load(drawable).into(target);
+
+    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);
+    verify(target).onResourceReady(drawableCaptor.capture(), any(Transition.class));
+    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.RED);
+  }
+
   @Test
   public void testNullModelPrefersFallbackDrawable() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
@@ -561,10 +647,8 @@ public void testNullModelPrefersFallbackDrawable() {
     Drawable fallback = new ColorDrawable(Color.BLUE);
 
     requestManager
-        .load(null)
-        .apply(placeholderOf(placeholder)
-            .error(error)
-            .fallback(fallback))
+        .load(NULL)
+        .apply(placeholderOf(placeholder).error(error).fallback(fallback))
         .into(target);
 
     verify(target).onLoadFailed(eq(fallback));
@@ -574,42 +658,64 @@ public void testNullModelPrefersFallbackDrawable() {
   public void testNullModelResolvesToUsePlaceholder() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
 
-    requestManager
-        .load(null)
-        .apply(placeholderOf(placeholder))
-        .into(target);
+    requestManager.load(NULL).apply(placeholderOf(placeholder)).into(target);
 
     verify(target).onLoadFailed(eq(placeholder));
   }
 
   @Test
   public void testByteData() {
-    byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };
+    byte[] data = new byte[] {1, 2, 3, 4, 5, 6};
     requestManager.load(data).into(target);
   }
 
   @Test
-  public void testClone() throws IOException {
+  public void removeFromManagers_afterRequestManagerRemoved_clearsRequest() {
+    target =
+        requestManager
+            .load(mockUri("content://uri"))
+            .into(
+                new CustomTarget<Drawable>() {
+                  @Override
+                  public void onResourceReady(
+                      @NonNull Drawable resource,
+                      @Nullable Transition<? super Drawable> transition) {
+                    // Do nothing.
+                  }
+
+                  @Override
+                  public void onLoadCleared(@Nullable Drawable placeholder) {
+                    // Do nothing, we don't retain a reference to our resource.
+                  }
+                });
+
+    Request request = Preconditions.checkNotNull(target.getRequest());
+
+    requestManager.onDestroy();
+    requestManager.clear(target);
+
+    assertThat(target.getRequest()).isNull();
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void testClone() {
     Target<Drawable> firstTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
     Target<Drawable> secondTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(isA(SizeReadyCallback.class));
-    RequestBuilder<Drawable> firstRequest = requestManager
-        .load(mockUri("content://first"));
+    RequestBuilder<Drawable> firstRequest = requestManager.load(mockUri("content://first"));
 
     firstRequest.into(firstTarget);
 
-    firstRequest.clone()
-        .apply(placeholderOf(new ColorDrawable(Color.RED)))
-        .into(secondTarget);
+    firstRequest.clone().apply(placeholderOf(new ColorDrawable(Color.RED))).into(secondTarget);
 
     verify(firstTarget).onResourceReady(isA(Drawable.class), isA(Transition.class));
     verify(secondTarget).onResourceReady(notNull(Drawable.class), isA(Transition.class));
   }
 
   @SuppressWarnings("unchecked")
-  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource)
-      throws Exception {
+  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource) {
     DataFetcher<Z> failFetcher = mock(DataFetcher.class);
     doAnswer(new Util.CallDataReady<>(null))
         .when(failFetcher)
@@ -622,24 +728,23 @@ public void testClone() throws IOException {
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
     when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
-    Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
+    Glide.get(context).getRegistry().prepend(failModel, failResource, failFactory);
   }
 
   private String mockUri(String uriString) {
     return mockUri(Uri.parse(uriString), null);
   }
 
-  private String mockUri(Uri uri) {
-    return mockUri(uri, null);
+  private void mockUri(Uri uri) {
+    mockUri(uri, null);
   }
 
   private String mockUri(Uri uri, InputStream is) {
     if (is == null) {
       is = new ByteArrayInputStream(new byte[0]);
     }
-    ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
-    ShadowFileDescriptorContentResolver shadowContentResolver =
-        (ShadowFileDescriptorContentResolver) Shadow.extract(contentResolver);
+    ContentResolver contentResolver = context.getContentResolver();
+    ShadowFileDescriptorContentResolver shadowContentResolver = Shadow.extract(contentResolver);
     shadowContentResolver.registerInputStream(uri, is);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
@@ -650,18 +755,13 @@ private String mockUri(Uri uri, InputStream is) {
     return uri.toString();
   }
 
-  private Context getContext() {
-    return RuntimeEnvironment.application;
-  }
-
   @SuppressWarnings("unchecked")
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
     when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
-    Glide.get(RuntimeEnvironment.application).getRegistry()
-        .prepend(modelClass, InputStream.class, modelLoaderFactory);
+    Glide.get(context).getRegistry().prepend(modelClass, InputStream.class, modelLoaderFactory);
   }
 
   @SuppressWarnings("unchecked")
@@ -669,7 +769,8 @@ private Context getContext() {
     ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);
     DataFetcher<InputStream> fetcher = mock(DataFetcher.class);
     try {
-      doAnswer(new Util.CallDataReady<>(new ByteArrayInputStream(new byte[0]))).when(fetcher)
+      doAnswer(new Util.CallDataReady<>(new ByteArrayInputStream(new byte[0])))
+          .when(fetcher)
           .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
     } catch (Exception e) {
       // Do nothing.
@@ -682,19 +783,19 @@ private Context getContext() {
     return modelLoader;
   }
 
-  private InputStream openResource(String imageName) throws IOException {
-    return TestResourceUtil.openResource(getClass(), imageName);
+  private InputStream openGif() {
+    return TestResourceUtil.openResource(getClass(), "test.gif");
   }
 
   private static class CallSizeReady implements Answer<Void> {
-    private int width;
-    private int height;
+    private final int width;
+    private final int height;
 
-    public CallSizeReady() {
+    CallSizeReady() {
       this(100, 100);
     }
 
-    public CallSizeReady(int width, int height) {
+    CallSizeReady(int width, int height) {
       this.width = width;
       this.height = height;
     }
@@ -707,53 +808,25 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class SetupModule implements com.bumptech.glide.module.GlideModule {
-
-    @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
-      // Run all tasks on the main thread so they complete synchronously.
-      GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
-
-      DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
-      when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
-
-      builder.setMemoryCache(mock(MemoryCache.class)).setDiskCache(diskCacheFactory)
-          .setResizeExecutor(executor).setDiskCacheExecutor(executor);
-    }
-
-    @Override
-    public void registerComponents(Context context, Glide glide, Registry registry) {
-      registerMockModelLoader(GlideUrl.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, ParcelFileDescriptor.class,
-          mock(ParcelFileDescriptor.class), registry);
-      registerMockModelLoader(File.class, ByteBuffer.class,
-          ByteBuffer.allocate(10), registry);
+  private static <X, Y> void registerMockModelLoader(
+      Class<X> modelClass, Class<Y> dataClass, Y loadedData, Registry registry) {
+    DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
+    when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
+    try {
+      doAnswer(new Util.CallDataReady<>(loadedData))
+          .when(mockStreamFetcher)
+          .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
+    ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
+    when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
+    when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
+    ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
+    when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(mockUrlLoader);
 
-    private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
-          Y loadedData, Registry registry) {
-      DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
-      when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
-      try {
-        doAnswer(new Util.CallDataReady<>(loadedData))
-            .when(mockStreamFetcher)
-            .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-      ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
-      when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
-          .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
-      when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
-      ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
-          .thenReturn(mockUrlLoader);
-
-      registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
-    }
+    registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
   }
 
   // TODO: Extending ShadowContentResolver results in exceptions because of some state issues
@@ -772,11 +845,11 @@ public static void reset() {
       URI_TO_FILE_DESCRIPTOR.clear();
     }
 
-    public void registerInputStream(Uri uri, InputStream inputStream) {
+    void registerInputStream(Uri uri, InputStream inputStream) {
       URI_TO_INPUT_STREAMS.put(uri, inputStream);
     }
 
-    public void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
+    void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
       URI_TO_FILE_DESCRIPTOR.put(uri, assetFileDescriptor);
     }
 
@@ -822,4 +895,3 @@ public Bitmap getFrameAtTime() {
     }
   }
 }
-
diff --git a/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
new file mode 100644
index 000000000..7d1f1aacd
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -0,0 +1,414 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.tests.Util.cast;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.verification.VerificationMode;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class ListPreloaderTest {
+
+  @Mock private RequestBuilder<Object> request;
+  @Mock private RequestManager requestManager;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testGetItemsIsCalledIncreasing() {
+    final AtomicBoolean called = new AtomicBoolean(false);
+    final AtomicInteger calledCount = new AtomicInteger();
+
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            called.set(true);
+            final int count = calledCount.getAndIncrement();
+            assertEquals(11 + count, position);
+            return super.getPreloadItems(position);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 1, 10, 30);
+    assertEquals(10, calledCount.get());
+  }
+
+  @Test
+  public void testGetItemsIsCalledInOrderIncreasing() {
+    final int toPreload = 10;
+    final List<Object> objects = new ArrayList<>();
+    for (int i = 0; i < toPreload; i++) {
+      objects.add(i);
+    }
+
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          private int expectedPosition;
+
+          @Override
+          public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+            return new int[] {10, 10};
+          }
+
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            return objects.subList(position - 11, position + 1 - 11);
+          }
+
+          @Nullable
+          @Override
+          @SuppressWarnings("unchecked")
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            assertEquals(objects.get(expectedPosition), item);
+            expectedPosition++;
+            return mock(RequestBuilder.class);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);
+    preloader.onScroll(null, 1, 10, 20);
+  }
+
+  @Test
+  public void testGetItemsIsCalledDecreasing() {
+    final AtomicBoolean called = new AtomicBoolean(false);
+    final AtomicInteger calledCount = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            // Ignore the preload caused from us starting at the end
+            if (position >= 40) {
+              return Collections.emptyList();
+            }
+            final int count = calledCount.getAndIncrement();
+            called.set(true);
+            assertEquals(28 - count, position);
+            return super.getPreloadItems(position);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 30, 10, 40);
+    preloader.onScroll(null, 29, 10, 40);
+    assertTrue(called.get());
+  }
+
+  @Test
+  public void testGetItemsIsCalledInOrderDecreasing() {
+    final int toPreload = 10;
+    final List<Object> objects = new ArrayList<>();
+    for (int i = 0; i < toPreload; i++) {
+      objects.add(new Object());
+    }
+
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          private int expectedPosition = toPreload - 1;
+
+          @Override
+          public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+            return new int[] {10, 10};
+          }
+
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            if (position == 40) {
+              return Collections.emptyList();
+            }
+            return objects.subList(position, position + 1);
+          }
+
+          @Nullable
+          @Override
+          @SuppressWarnings("unchecked")
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            assertEquals(objects.get(expectedPosition), item);
+            expectedPosition--;
+            return mock(RequestBuilder.class);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);
+    preloader.onScroll(null, 30, 10, 10);
+    preloader.onScroll(null, 29, 10, 10);
+  }
+
+  @Test
+  public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
+    final AtomicBoolean called = new AtomicBoolean(false);
+    final AtomicInteger calledCount = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            called.set(true);
+            final int count = calledCount.getAndIncrement();
+            assertEquals(26 + count, position);
+            return super.getPreloadItems(position);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 16, 10, 30);
+    assertTrue(called.get());
+  }
+
+  @Test
+  public void testGetItemsIsNeverCalledWithStartLessThanZero() {
+    final AtomicBoolean called = new AtomicBoolean(false);
+    final AtomicInteger calledCount = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            if (position >= 17) {
+              return Collections.emptyList();
+            }
+            called.set(true);
+            final int count = calledCount.getAndIncrement();
+            assertEquals(5 - count, position);
+            return super.getPreloadItems(position);
+          }
+        };
+
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 7, 10, 30);
+    preloader.onScroll(null, 6, 10, 30);
+    assertTrue(called.get());
+  }
+
+  @Test
+  public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
+    final AtomicInteger called = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            final int current = called.getAndIncrement();
+            assertEquals(11 + current, position);
+            return super.getPreloadItems(position);
+          }
+        };
+
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 1, 10, 30);
+    preloader.onScroll(null, 4, 10, 30);
+
+    assertEquals(13, called.get());
+  }
+
+  @Test
+  public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
+    final AtomicInteger called = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            if (position >= 20) {
+              return Collections.emptyList();
+            }
+            final int current = called.getAndIncrement();
+            assertEquals(19 - current, position);
+            return super.getPreloadItems(position);
+          }
+        };
+
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 21, 10, 30);
+    preloader.onScroll(null, 20, 10, 30);
+    preloader.onScroll(null, 17, 10, 30);
+    assertEquals(13, called.get());
+  }
+
+  @Test
+  public void testMultipleItemsForPositionIncreasing() {
+    final List<Object> objects = new ArrayList<>();
+    objects.add(new Object());
+    objects.add(new Object());
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          private int expectedPosition = (1 + 10) * 2;
+
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            return objects;
+          }
+
+          @Override
+          public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+            assertEquals(expectedPosition / 2, adapterPosition);
+            assertEquals(expectedPosition % 2, itemPosition);
+            expectedPosition++;
+            return itemPosition == 0 ? new int[] {10, 11} : new int[] {20, 21};
+          }
+
+          @Nullable
+          @Override
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            return request;
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+    Iterable<Integer> expected = Arrays.asList(10, 11, 20, 21, 10, 11, 20, 21);
+
+    preloader.onScroll(null, 1, 10, 1 + 10 + 2);
+
+    List<Integer> allValues = getTargetsSizes(request, times(4));
+    assertEquals(expected, allValues);
+  }
+
+  @Test
+  public void testMultipleItemsForPositionDecreasing() {
+    final List<Object> objects = new ArrayList<>();
+    objects.add(new Object());
+    objects.add(new Object());
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          private int expectedPosition = objects.size() * 2 - 1;
+
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            return objects;
+          }
+
+          @Override
+          public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+            assertEquals(expectedPosition / 2, adapterPosition);
+            assertEquals(expectedPosition % 2, itemPosition);
+            expectedPosition--;
+            return itemPosition == 0 ? new int[] {10, 11} : new int[] {20, 21};
+          }
+
+          @Nullable
+          @Override
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            return request;
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+    Iterable<Integer> expected = Arrays.asList(20, 21, 10, 11, 20, 21, 10, 11);
+
+    preloader.onScroll(null, 3, 2, 3 + 2);
+    preloader.onScroll(null, 2, 2, 3 + 2);
+
+    List<Integer> allValues = getTargetsSizes(request, times(4));
+    assertEquals(expected, allValues);
+  }
+
+  private <Resource> List<Integer> getTargetsSizes(
+      RequestBuilder<Resource> requestBuilder, VerificationMode mode) {
+    ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
+    ArgumentCaptor<Target<Resource>> targetArgumentCaptor =
+        cast(ArgumentCaptor.forClass(Target.class));
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
+    for (Target<Resource> target : targetArgumentCaptor.getAllValues()) {
+      target.getSize(cb);
+    }
+    verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
+    return integerArgumentCaptor.getAllValues();
+  }
+
+  // It's safe to ignore the return value of containsAllIn.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void testItemsArePreloadedWithGlide() {
+    final List<Object> objects = new ArrayList<>();
+    objects.add(new Object());
+    objects.add(new Object());
+    final HashSet<Object> loadedObjects = new HashSet<>();
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            return objects.subList(position - 11, position - 10);
+          }
+
+          @Nullable
+          @Override
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            loadedObjects.add(item);
+            return super.getPreloadRequestBuilder(item);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
+
+    preloader.onScroll(null, 1, 10, 13);
+    assertThat(loadedObjects).containsAtLeastElementsIn(objects);
+  }
+
+  private static class ListPreloaderAdapter
+      implements ListPreloader.PreloadModelProvider<Object>,
+          ListPreloader.PreloadSizeProvider<Object> {
+
+    public ListPreloaderAdapter() {}
+
+    @NonNull
+    @Override
+    public List<Object> getPreloadItems(int position) {
+      ArrayList<Object> result = new ArrayList<>(1);
+      Collections.fill(result, new Object());
+      return result;
+    }
+
+    @Nullable
+    @Override
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+      return mock(RequestBuilder.class);
+    }
+
+    @Nullable
+    @Override
+    public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+      return new int[] {100, 100};
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/RegistryTest.java b/library/test/src/test/java/com/bumptech/glide/RegistryTest.java
new file mode 100644
index 000000000..1d7ab409e
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/RegistryTest.java
@@ -0,0 +1,160 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public class RegistryTest {
+
+  @Mock private ModelLoaderFactory<Model, Data> modelLoaderFactory;
+  @Mock private ResourceDecoder<Data, ResourceOne> resourceOneDecoder;
+  @Mock private ResourceDecoder<Data, ResourceTwo> resourceTwoDecoder;
+  @Mock private ResourceTranscoder<ResourceOne, TranscodeOne> resourceOneTranscodeOneTranscoder;
+  private Registry registry;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    registry = new Registry();
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withNoResources_isEmpty() {
+    assertThat(getRegisteredResourceClasses()).isEmpty();
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withOneDataClass_noResourceClasses_isEmpty() {
+    registry.append(Model.class, Data.class, modelLoaderFactory);
+    assertThat(getRegisteredResourceClasses()).isEmpty();
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withOneDataAndResourceClass_noTranscodeClass_isEmpty() {
+    registry.append(Model.class, Data.class, modelLoaderFactory);
+    registry.append(Data.class, ResourceOne.class, resourceOneDecoder);
+    assertThat(getRegisteredResourceClasses()).isEmpty();
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withOneDataAndResourceAndTranscodeClass_isNotEmpty() {
+    registry.append(Model.class, Data.class, modelLoaderFactory);
+    registry.append(Data.class, ResourceOne.class, resourceOneDecoder);
+    registry.register(ResourceOne.class, TranscodeOne.class, resourceOneTranscodeOneTranscoder);
+    assertThat(getRegisteredResourceClasses()).containsExactly(ResourceOne.class);
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withMissingTranscodeForOneOfTwoResources_isNotEmpty() {
+    // The loop allows us to make sure that the order in which we call getRegisteredResourceClasses
+    // doesn't affect the output.
+    for (int i = 0; i < 2; i++) {
+      Registry registry = new Registry();
+      registry.append(Model.class, Data.class, modelLoaderFactory);
+
+      registry.append(Data.class, ResourceOne.class, resourceOneDecoder);
+      registry.append(Data.class, ResourceTwo.class, resourceTwoDecoder);
+
+      registry.register(ResourceOne.class, TranscodeOne.class, resourceOneTranscodeOneTranscoder);
+
+      List<Class<?>> resourceOneClasses;
+      List<Class<?>> resourceTwoClasses;
+      if (i == 0) {
+        resourceOneClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeOne.class);
+        resourceTwoClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceTwo.class, TranscodeOne.class);
+      } else {
+        resourceTwoClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceTwo.class, TranscodeOne.class);
+        resourceOneClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeOne.class);
+      }
+      // ResourceOne has a corresponding transcode class, so we should return it.
+      assertThat(resourceOneClasses).containsExactly(ResourceOne.class);
+      // ResourceTwo has no matching transcode class, so we shouldn't return it.
+      assertThat(resourceTwoClasses).isEmpty();
+    }
+  }
+
+  @Test
+  public void getRegisteredResourceClasses_withOneOfTwoMissingTranscoders_isNotEmpty() {
+    // The loop allows us to make sure that the order in which we call getRegisteredResourceClasses
+    // doesn't affect the output.
+    for (int i = 0; i < 2; i++) {
+      Registry registry = new Registry();
+      registry.append(Model.class, Data.class, modelLoaderFactory);
+
+      registry.append(Data.class, ResourceOne.class, resourceOneDecoder);
+
+      registry.register(ResourceOne.class, TranscodeOne.class, resourceOneTranscodeOneTranscoder);
+
+      List<Class<?>> transcodeOneClasses;
+      List<Class<?>> transcodeTwoClasses;
+      if (i == 0) {
+        transcodeOneClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeOne.class);
+        transcodeTwoClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeTwo.class);
+      } else {
+        transcodeTwoClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeTwo.class);
+        transcodeOneClasses =
+            registry.getRegisteredResourceClasses(
+                Model.class, ResourceOne.class, TranscodeOne.class);
+      }
+      // TranscodeOne has a corresponding ResourceTranscoder, so we expect to see the resource
+      // class.
+      assertThat(transcodeOneClasses).containsExactly(ResourceOne.class);
+      // TranscodeTwo has no corresponding ResourceTranscoder class, so we shouldn't return the
+      // resource class.
+      assertThat(transcodeTwoClasses).isEmpty();
+    }
+  }
+
+  private List<Class<?>> getRegisteredResourceClasses() {
+    return registry.getRegisteredResourceClasses(
+        Model.class, ResourceOne.class, TranscodeOne.class);
+  }
+
+  private static final class Model {
+    // Empty class to represent model classes for readability.
+  }
+
+  private static final class Data {
+    // Empty class to represent data classes for readability.
+  }
+
+  private static final class ResourceOne {
+    // Empty class to represent resource classes for readability.
+  }
+
+  private static final class ResourceTwo {
+    // Empty class to represent another resource class for readability.
+  }
+
+  private static final class TranscodeOne {
+    // Empty class to represent transcode classes for readability.
+  }
+
+  private static final class TranscodeTwo {
+    // Empty class to represent transcode classes for readability.
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
similarity index 52%
rename from library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
rename to library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index 4a9d72750..9f3918664 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -2,22 +2,32 @@
 
 import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.app.Application;
 import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.resource.SimpleResource;
 import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.SingleRequest;
 import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.tests.BackgroundUtil;
-import org.junit.After;
+import com.bumptech.glide.request.target.ViewTarget;
+import com.bumptech.glide.tests.BackgroundUtil.BackgroundTester;
+import com.bumptech.glide.tests.TearDownGlide;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
@@ -26,10 +36,16 @@
 
 @SuppressWarnings("unchecked")
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class RequestBuilderTest {
-  @Mock GlideContext glideContext;
-  @Mock RequestManager requestManager;
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private RequestListener<Object> listener1;
+  @Mock private RequestListener<Object> listener2;
+  @Mock private Target<Object> target;
+  @Mock private GlideContext glideContext;
+  @Mock private RequestManager requestManager;
+  @Captor private ArgumentCaptor<SingleRequest<Object>> requestCaptor;
   private Glide glide;
   private Application context;
 
@@ -40,11 +56,6 @@ public void setUp() {
     context = RuntimeEnvironment.application;
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
     new RequestBuilder<>(null /*context*/, requestManager, Object.class, context);
@@ -58,12 +69,11 @@ public void testThrowsWhenTransitionsOptionsIsNull() {
 
   @Test
   public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
-    getNullModelRequest().into(mock(Target.class));
+    getNullModelRequest().into(target);
   }
 
   @Test
   public void testAddsNewRequestToRequestTracker() {
-    Target<Object> target = mock(Target.class);
     getNullModelRequest().into(target);
 
     verify(requestManager).track(eq(target), isA(Request.class));
@@ -72,7 +82,6 @@ public void testAddsNewRequestToRequestTracker() {
   @Test
   public void testRemovesPreviousRequestFromRequestTracker() {
     Request previous = mock(Request.class);
-    Target<Object> target = mock(Target.class);
     when(target.getRequest()).thenReturn(previous);
 
     getNullModelRequest().into(target);
@@ -94,35 +103,59 @@ public void testThrowsIfGivenNullView() {
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
     final ImageView imageView = new ImageView(RuntimeEnvironment.application);
-    testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() throws Exception {
-        getNullModelRequest().into(imageView);
-
-      }
-    });
+    testInBackground(
+        new BackgroundTester() {
+          @Override
+          public void runTest() {
+            getNullModelRequest().into(imageView);
+          }
+        });
   }
 
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
+  @Test
+  public void doesNotThrowIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
     final Target<Object> target = mock(Target.class);
-    testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() throws Exception {
-        getNullModelRequest().into(target);
-      }
-    });
+    testInBackground(
+        new BackgroundTester() {
+          @Override
+          public void runTest() {
+            getNullModelRequest().into(target);
+          }
+        });
+  }
+
+  @Test
+  public void testMultipleRequestListeners() {
+    getNullModelRequest().addListener(listener1).addListener(listener2).into(target);
+    verify(requestManager).track(any(Target.class), requestCaptor.capture());
+    requestCaptor.getValue().onResourceReady(new SimpleResource<>(new Object()), DataSource.LOCAL);
+
+    verify(listener1)
+        .onResourceReady(any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+    verify(listener2)
+        .onResourceReady(any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+  }
+
+  @Test
+  public void testListenerApiOverridesListeners() {
+    getNullModelRequest().addListener(listener1).listener(listener2).into(target);
+    verify(requestManager).track(any(Target.class), requestCaptor.capture());
+    requestCaptor.getValue().onResourceReady(new SimpleResource<>(new Object()), DataSource.LOCAL);
+
+    // The #listener API removes any previous listeners, so the first listener should not be called.
+    verify(listener1, never())
+        .onResourceReady(any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+    verify(listener2)
+        .onResourceReady(any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
   }
 
   private RequestBuilder<Object> getNullModelRequest() {
     when(glideContext.buildImageViewTarget(isA(ImageView.class), isA(Class.class)))
-        .thenReturn(mock(Target.class));
+        .thenReturn(mock(ViewTarget.class));
     when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
-    when(requestManager.getDefaultRequestOptions())
-        .thenReturn(new RequestOptions());
+    when(requestManager.getDefaultRequestOptions()).thenReturn(new RequestOptions());
     when(requestManager.getDefaultTransitionOptions(any(Class.class)))
         .thenReturn(new GenericTransitionOptions<>());
-    return new RequestBuilder<>(glide, requestManager, Object.class, context)
-        .load((Object) null);
+    return new RequestBuilder<>(glide, requestManager, Object.class, context).load((Object) null);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
new file mode 100644
index 000000000..1847063e5
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -0,0 +1,298 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import com.bumptech.glide.manager.ConnectivityMonitor;
+import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.manager.RequestTracker;
+import com.bumptech.glide.request.target.CustomTarget;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
+import java.io.File;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18, shadows = GlideShadowLooper.class)
+public class RequestManagerTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private Lifecycle lifecycle = mock(Lifecycle.class);
+  @Mock private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
+
+  private RequestManager manager;
+  private ConnectivityMonitor connectivityMonitor;
+  private RequestTracker requestTracker;
+  private ConnectivityListener connectivityListener;
+  private Application context;
+  private CustomTarget<Drawable> target;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+    connectivityMonitor = mock(ConnectivityMonitor.class);
+    ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
+    when(factory.build(isA(Context.class), isA(ConnectivityMonitor.ConnectivityListener.class)))
+        .thenAnswer(
+            new Answer<ConnectivityMonitor>() {
+              @Override
+              public ConnectivityMonitor answer(InvocationOnMock invocation) {
+                connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
+                return connectivityMonitor;
+              }
+            });
+
+    target =
+        new CustomTarget<Drawable>() {
+          @Override
+          public void onResourceReady(
+              @NonNull Drawable resource, @Nullable Transition<? super Drawable> transition) {
+            // Empty.
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {}
+        };
+
+    requestTracker = mock(RequestTracker.class);
+    manager =
+        new RequestManager(
+            Glide.get(RuntimeEnvironment.application),
+            lifecycle,
+            treeNode,
+            requestTracker,
+            factory,
+            context);
+  }
+
+  @Test
+  public void testPauseRequestsPausesRequests() {
+    manager.pauseRequests();
+
+    verify(requestTracker).pauseRequests();
+  }
+
+  @Test
+  public void testResumeRequestsResumesRequests() {
+    manager.resumeRequests();
+
+    verify(requestTracker).resumeRequests();
+  }
+
+  @Test
+  public void testPausesRequestsOnStop() {
+    manager.onStart();
+    manager.onStop();
+
+    verify(requestTracker).pauseRequests();
+  }
+
+  @Test
+  public void testResumesRequestsOnStart() {
+    manager.onStart();
+
+    verify(requestTracker).resumeRequests();
+  }
+
+  @Test
+  public void testClearsRequestsOnDestroy() {
+    manager.onDestroy();
+
+    verify(requestTracker).clearRequests();
+  }
+
+  @Test
+  public void testAddsConnectivityMonitorToLifecycleWhenConstructed() {
+    verify(lifecycle).addListener(eq(connectivityMonitor));
+  }
+
+  @Test
+  public void testAddsSelfToLifecycleWhenConstructed() {
+    verify(lifecycle).addListener(eq(manager));
+  }
+
+  @Test
+  public void testRestartsRequestOnConnected() {
+    connectivityListener.onConnectivityChanged(true);
+
+    verify(requestTracker).restartRequests();
+  }
+
+  @Test
+  public void testDoesNotRestartRequestsOnDisconnected() {
+    connectivityListener.onConnectivityChanged(false);
+
+    verify(requestTracker, never()).restartRequests();
+  }
+
+  @Test
+  public void resumeRequests_whenCalledOnBackgroundThread_doesNotThrow()
+      throws InterruptedException {
+    testInBackground(
+        new BackgroundUtil.BackgroundTester() {
+          @Override
+          public void runTest() {
+            manager.resumeRequests();
+          }
+        });
+  }
+
+  @Test
+  public void pauseRequests_whenCalledOnBackgroundThread_doesNotThrow()
+      throws InterruptedException {
+    testInBackground(
+        new BackgroundUtil.BackgroundTester() {
+          @Override
+          public void runTest() {
+            manager.pauseRequests();
+          }
+        });
+  }
+
+  @Test
+  public void testDelegatesIsPausedToRequestTracker() {
+    when(requestTracker.isPaused()).thenReturn(true);
+    assertTrue(manager.isPaused());
+    when(requestTracker.isPaused()).thenReturn(false);
+    assertFalse(manager.isPaused());
+  }
+
+  @Test
+  public void clear_withRequestStartedInSiblingManager_doesNotThrow() {
+    final RequestManager child1 =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.emptySet();
+              }
+            },
+            context);
+    final RequestManager child2 =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.emptySet();
+              }
+            },
+            context);
+    new RequestManager(
+        Glide.get(context),
+        lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return new HashSet<>(java.util.Arrays.asList(child1, child2));
+          }
+        },
+        context);
+
+    File file = new File("fake");
+    child1.load(file).into(target);
+    child2.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInChildManager_doesNotThrow() {
+    final RequestManager child =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.emptySet();
+              }
+            },
+            context);
+    RequestManager parent =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.singleton(child);
+              }
+            },
+            context);
+
+    File file = new File("fake");
+    child.load(file).into(target);
+    parent.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInParentManager_doesNotThrow() {
+    final RequestManager child =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.emptySet();
+              }
+            },
+            context);
+    RequestManager parent =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.singleton(child);
+              }
+            },
+            context);
+
+    File file = new File("fake");
+
+    parent.load(file).into(target);
+    child.clear(target);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
similarity index 76%
rename from library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
index 9a23a4680..5936d466f 100644
--- a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -14,11 +14,12 @@
 
 import android.app.Application;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -29,12 +30,13 @@
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
 public class MultiTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Transformation<Object> first;
-  @Mock Transformation<Object> second;
-  @Mock Resource<Object> initial;
-  @Mock Resource<Object> firstTransformed;
-  @Mock Resource<Object> secondTransformed;
+  @Mock private Transformation<Object> first;
+  @Mock private Transformation<Object> second;
+  @Mock private Resource<Object> initial;
+  @Mock private Resource<Object> firstTransformed;
+  @Mock private Resource<Object> secondTransformed;
   private Application context;
 
   @Before
@@ -42,6 +44,13 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     context = RuntimeEnvironment.application;
+
+    doAnswer(new Util.WriteDigest("first"))
+        .when(first)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("second"))
+        .when(second)
+        .updateDiskCacheKey(any(MessageDigest.class));
   }
 
   @Test
@@ -84,7 +93,7 @@ public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformati
 
   @Test
   public void
-  testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
+      testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
     when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
     when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
         .thenReturn(mockResource());
@@ -123,13 +132,17 @@ public void testIntermediateResourcesAreRecycled() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("first")).when(first)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(new MultiTransformation<>(first), new MultiTransformation<>(first));
-
-    doAnswer(new Util.WriteDigest("second")).when(second)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(
-        new MultiTransformation<>(first), new MultiTransformation<>(second));
+    keyTester
+        .addEquivalenceGroup(new MultiTransformation<>(first), new MultiTransformation<>(first))
+        .addEquivalenceGroup(new MultiTransformation<>(second))
+        .addEquivalenceGroup(new MultiTransformation<>(first, second))
+        .addEquivalenceGroup(new MultiTransformation<>(second, first))
+        .addRegressionTest(
+            new MultiTransformation<>(first),
+            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e")
+        .addRegressionTest(
+            new MultiTransformation<>(first, second),
+            "da83f63e1a473003712c18f5afc5a79044221943d1083c7c5a7ac7236d85e8d2")
+        .test();
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
new file mode 100644
index 000000000..cf96d4bb2
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
@@ -0,0 +1,74 @@
+package com.bumptech.glide.load;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.tests.KeyTester;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class OptionsTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEquals() {
+    Option<Object> firstMemoryOption = Option.memory("firstKey");
+    Object firstValue = new Object();
+    Option<Object> secondMemoryOption = Option.memory("secondKey");
+    Object secondValue = new Object();
+
+    CacheKeyUpdater<Integer> updater =
+        new CacheKeyUpdater<Integer>() {
+          @Override
+          public void update(
+              @NonNull byte[] keyBytes,
+              @NonNull Integer value,
+              @NonNull MessageDigest messageDigest) {
+            messageDigest.update(keyBytes);
+            messageDigest.update(ByteBuffer.allocate(4).putInt(value).array());
+          }
+        };
+    Option<Integer> firstDiskOption = Option.disk("firstDisk", updater);
+    Option<Integer> secondDiskOption = Option.disk("secondDisk", updater);
+
+    keyTester
+        .addEquivalenceGroup(new Options(), new Options())
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, firstValue),
+            new Options().set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(secondMemoryOption, secondValue),
+            new Options().set(secondMemoryOption, secondValue))
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
+            new Options().set(secondMemoryOption, secondValue).set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(new Options().set(firstMemoryOption, secondValue))
+        .addEquivalenceGroup(new Options().set(secondMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 1), new Options().set(firstDiskOption, 1))
+        .addEquivalenceGroup(
+            new Options().set(secondDiskOption, 1), new Options().set(secondDiskOption, 1))
+        .addEquivalenceGroup(new Options().set(firstDiskOption, 2))
+        .addEquivalenceGroup(new Options().set(secondDiskOption, 2))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 1).set(secondDiskOption, 2),
+            new Options().set(secondDiskOption, 2).set(firstDiskOption, 1))
+        .addEmptyDigestRegressionTest(new Options().set(firstMemoryOption, firstValue))
+        .addEmptyDigestRegressionTest(
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue))
+        .addRegressionTest(
+            new Options().set(firstDiskOption, 123),
+            "3c87124d1a765dc3d566f947d536ef140a4aca645c0947f702356714855b4a8e")
+        .addRegressionTest(
+            new Options().set(firstDiskOption, 123).set(secondDiskOption, 123),
+            "6697f654686c9a925905db3840e9c99944642c2b91d6200360d77639c1754d51")
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
new file mode 100644
index 000000000..cd72f4bf0
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
@@ -0,0 +1,182 @@
+package com.bumptech.glide.load.data;
+
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Runs some tests based on a random seed that asserts the output of writing to our buffered stream
+ * matches the output of writing to {@link java.io.ByteArrayOutputStream}.
+ */
+@RunWith(JUnit4.class)
+public class BufferedOutputStreamFuzzTest {
+  private static final int TESTS = 500;
+  private static final int BUFFER_SIZE = 10;
+  private static final int WRITES_PER_TEST = 50;
+  private static final int MAX_BYTES_PER_WRITE = BUFFER_SIZE * 6;
+  private static final Random RANDOM = new Random(-3207167907493985134L);
+
+  @Mock private ArrayPool arrayPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(arrayPool.get(anyInt(), eq(byte[].class)))
+        .thenAnswer(
+            new Answer<byte[]>() {
+              @Override
+              public byte[] answer(InvocationOnMock invocation) throws Throwable {
+                int size = (Integer) invocation.getArguments()[0];
+                return new byte[size];
+              }
+            });
+  }
+
+  @Test
+  public void runFuzzTest() throws IOException {
+    for (int i = 0; i < TESTS; i++) {
+      runTest(RANDOM);
+    }
+  }
+
+  private void runTest(Random random) throws IOException {
+    List<Write> writes = new ArrayList<>(WRITES_PER_TEST);
+    for (int i = 0; i < WRITES_PER_TEST; i++) {
+      WriteType writeType = getType(random);
+      writes.add(getWrite(random, writeType));
+    }
+
+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+
+    ByteArrayOutputStream wrapped = new ByteArrayOutputStream();
+    BufferedOutputStream bufferedOutputStream =
+        new BufferedOutputStream(wrapped, arrayPool, BUFFER_SIZE);
+
+    for (Write write : writes) {
+      switch (write.writeType) {
+        case BYTE:
+          byteArrayOutputStream.write(write.data[0]);
+          bufferedOutputStream.write(write.data[0]);
+          break;
+        case BUFFER:
+          byteArrayOutputStream.write(write.data);
+          bufferedOutputStream.write(write.data);
+          break;
+        case OFFSET_BUFFER:
+          byteArrayOutputStream.write(write.data, write.offset, write.length);
+          bufferedOutputStream.write(write.data, write.offset, write.length);
+          break;
+        default:
+          throw new IllegalArgumentException();
+      }
+    }
+
+    byte[] fromByteArrayStream = byteArrayOutputStream.toByteArray();
+    bufferedOutputStream.close();
+    byte[] fromWrappedStream = wrapped.toByteArray();
+    if (!Arrays.equals(fromWrappedStream, fromByteArrayStream)) {
+      StringBuilder writesBuilder = new StringBuilder();
+      for (Write write : writes) {
+        writesBuilder.append(write).append("\n");
+      }
+      fail(
+          "Expected: "
+              + Arrays.toString(fromByteArrayStream)
+              + "\n"
+              + "but got: "
+              + Arrays.toString(fromWrappedStream)
+              + "\n"
+              + writesBuilder.toString());
+    }
+  }
+
+  private Write getWrite(Random random, WriteType type) {
+    switch (type) {
+      case BYTE:
+        return getByteWrite(random);
+      case BUFFER:
+        return getBufferWrite(random);
+      case OFFSET_BUFFER:
+        return getOffsetBufferWrite(random);
+      default:
+        throw new IllegalArgumentException("Unrecognized type: " + type);
+    }
+  }
+
+  private Write getOffsetBufferWrite(Random random) {
+    int dataSize = random.nextInt(MAX_BYTES_PER_WRITE * 2);
+    byte[] data = new byte[dataSize];
+    int length = dataSize == 0 ? 0 : random.nextInt(dataSize);
+    int offset = dataSize - length <= 0 ? 0 : random.nextInt(dataSize - length);
+    random.nextBytes(data);
+    return new Write(data, length, offset, WriteType.OFFSET_BUFFER);
+  }
+
+  private Write getBufferWrite(Random random) {
+    byte[] data = new byte[random.nextInt(MAX_BYTES_PER_WRITE)];
+    random.nextBytes(data);
+    return new Write(data, /*length=*/ data.length, /*offset=*/ 0, WriteType.BUFFER);
+  }
+
+  private Write getByteWrite(Random random) {
+    byte[] data = new byte[1];
+    random.nextBytes(data);
+    return new Write(data, /*length=*/ 1, /*offset=*/ 0, WriteType.BYTE);
+  }
+
+  private WriteType getType(Random random) {
+    return WriteType.values()[random.nextInt(WriteType.values().length)];
+  }
+
+  private static final class Write {
+    private final byte[] data;
+    private final int length;
+    private final int offset;
+    private final WriteType writeType;
+
+    @Override
+    public String toString() {
+      return "Write{"
+          + "data="
+          + Arrays.toString(data)
+          + ", length="
+          + length
+          + ", offset="
+          + offset
+          + ", writeType="
+          + writeType
+          + '}';
+    }
+
+    Write(byte[] data, int length, int offset, WriteType writeType) {
+      this.data = data;
+      this.length = length;
+      this.offset = offset;
+      this.writeType = writeType;
+    }
+  }
+
+  private enum WriteType {
+    BYTE,
+    BUFFER,
+    OFFSET_BUFFER
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
new file mode 100644
index 000000000..5299140d1
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
@@ -0,0 +1,947 @@
+package com.bumptech.glide.load.data;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class BufferedOutputStreamTest {
+  @Mock private ArrayPool arrayPool;
+  @Mock private OutputStream mockOutputStream;
+
+  private final int bufferSize = 10;
+  private final ByteArrayOutputStream inner = new ByteArrayOutputStream();
+  private int currentValue = 0;
+  private BufferedOutputStream os;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(arrayPool.get(bufferSize, byte[].class)).thenReturn(new byte[bufferSize]);
+    os = new BufferedOutputStream(inner, arrayPool, bufferSize);
+  }
+
+  @Test
+  public void constructor_obtainsBufferFromArrayPool() {
+    verify(arrayPool).get(bufferSize, byte[].class);
+  }
+
+  @Test
+  public void close_returnsBufferObtainedFromConstructor() throws IOException {
+    byte[] data = new byte[bufferSize];
+    when(arrayPool.get(bufferSize, byte[].class)).thenReturn(data);
+    os = new BufferedOutputStream(inner, arrayPool, bufferSize);
+
+    os.close();
+    verify(arrayPool).put(data);
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andSingleByte_doesNotWriteToStream() throws IOException {
+    os.write(next());
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataSmallerThanBuffer_doesNotWriteToStream()
+      throws IOException {
+    os.write(next(bufferSize - 1));
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetSizeSmallerThanBuffer_doesNotWriteToStream()
+      throws IOException {
+    int offset = 1;
+    int length = bufferSize - offset;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingSizeSmallerThanBuffer_doesNotWriteToStream()
+      throws IOException {
+    int padding = 1;
+    int length = bufferSize - padding;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataEqualToBufferSize_writesDataToStream()
+      throws IOException {
+    os.write(next(bufferSize));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataGreaterThanBufferSize_writesDataToStream()
+      throws IOException {
+    os.write(next(bufferSize + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetAndLengthEqualToBufferSize_writesDataToStream()
+      throws IOException {
+    int offset = 5;
+    int length = bufferSize;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingAndLengthEqualToBufferSize_writesData()
+      throws IOException {
+    int padding = 5;
+    int length = bufferSize;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetAndLengthGreaterThanBuffer_writesDataToStream()
+      throws IOException {
+    int offset = 5;
+    int length = bufferSize + 1;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingAndLengthGreaterThanBuffer_writesData()
+      throws IOException {
+    int padding = 5;
+    int length = bufferSize + 1;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void writeSingleByte_whenBufferAlmostFull_writesBufferToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_withSingleByteInBuffer_writesBufferToStream() throws IOException {
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritingByteAfterBufferFull_writesByteToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flushAfterPreviousFlush_withSingleByte_writesOnlySingleByte() throws IOException {
+    os.write(next());
+    os.flush();
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_withSingleByteInBuffer_writesBufferToStream() throws IOException {
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritingByteAfterBufferFull_writesByteToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void closeAfterPreviousFlush_withSingleByte_writesOnlySingleByte() throws IOException {
+    os.write(next());
+    os.flush();
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withDataInBuffer_bufferLessThanRemaining_doesNotWriteToStream()
+      throws IOException {
+    os.write(next());
+    os.write(next(remaining() - 1));
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void flush_afterWriteWithDataInBuffer_bufferLessThanRemaining_writesToStream()
+      throws IOException {
+    os.write(next());
+    byte[] data = next(remaining() - 1);
+
+    os.write(data);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteWithDataInBuffer_bufferLessThanRemaining_writesToStream()
+      throws IOException {
+    os.write(next());
+    byte[] data = next(remaining());
+
+    os.write(data);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferEqualToRemaining_lessThanLength_writesToStream() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteBufferEqualToRemaining_doesNothing() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferEqualToRemaining_doesNothing() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_lessThanLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_lessThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_lessThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_greaterThanLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_greaterThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_greaterThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_greaterThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_greaterThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_flushesUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.flush();
+
+    verify(mockOutputStream).flush();
+  }
+
+  @Test
+  public void overflowBuffer_doesNotFlushUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.write(1);
+    os.write(next(remaining() + 1));
+
+    verify(mockOutputStream, never()).flush();
+  }
+
+  @Test
+  public void close_closesUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.close();
+
+    verify(mockOutputStream).close();
+  }
+
+  @Test
+  public void close_whenUnderlyingStreamThrows_closesStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    doThrow(new IOException()).when(mockOutputStream).write(any(byte[].class), anyInt(), anyInt());
+
+    os.write(1);
+    try {
+      os.close();
+      fail("Failed to receive expected exception");
+    } catch (IOException e) {
+      // Expected.
+    }
+
+    verify(mockOutputStream).close();
+  }
+
+  @Test
+  public void flush_withZeroBytesWritten_doesNotWriteToStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.flush();
+
+    verify(mockOutputStream, never()).write(anyInt());
+    verify(mockOutputStream, never()).write(any(byte[].class));
+    verify(mockOutputStream, never()).write(any(byte[].class), anyInt(), anyInt());
+  }
+
+  @Test
+  public void write_throwsIfOffsetIsLessThanZero() {
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[0], /*initialOffset=*/ -1, /*length=*/ 0);
+          }
+        });
+  }
+
+  @Test
+  public void write_throwsIfLengthIsLessThanZero() {
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ -1);
+          }
+        });
+  }
+
+  @Test
+  public void write_throwsIfOffsetIsGreaterThanLength() {
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[0], /*initialOffset=*/ 1, /*length=*/ 0);
+          }
+        });
+  }
+
+  @Test
+  public void write_throwsIfLengthsIsGreaterThanLength() {
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ 1);
+          }
+        });
+  }
+
+  @Test
+  public void write_throwsIfLengthAndOffsetsIsGreaterThanLength() {
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[1], /*initialOffset=*/ 1, /*length=*/ 1);
+          }
+        });
+  }
+
+  @Test
+  public void write_withZeroLengthBuffer_doesNothing() throws IOException {
+    os.write(new byte[0]);
+
+    assertThat(inner.toByteArray()).hasLength(0);
+  }
+
+  @Test
+  public void write_withZeroLengthBufferAndZeroOffsetAndLength_doesNothing() throws IOException {
+    os.write(new byte[0], 0, 0);
+
+    assertThat(inner.toByteArray()).hasLength(0);
+  }
+
+  @Test
+  public void write_afterWriteWithZeroLengthBuffer_writesExpected() throws IOException {
+    os.write(new byte[0]);
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_afterWriteZeroLengthBufferAndZeroOffsetAndLength_writesExpected()
+      throws IOException {
+    os.write(new byte[0], 0, 0);
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  private int soFar() {
+    return currentValue;
+  }
+
+  private int remaining() {
+    return bufferSize - soFar();
+  }
+
+  private int next() {
+    return nextWithOffset(0, 1)[0];
+  }
+
+  private byte[] next(int count) {
+    return nextWithOffset(0, count);
+  }
+
+  private byte[] nextWithPadding(int count, int padding) {
+    byte[] result = new byte[count + padding];
+    for (int i = 0; i < count; i++) {
+      result[i] = (byte) ++currentValue;
+    }
+    for (int i = count; i < count + padding; i++) {
+      result[i] = (byte) (i + currentValue);
+    }
+    return result;
+  }
+
+  private byte[] nextWithOffset(int offset, int count) {
+    byte[] result = new byte[offset + count];
+    for (int i = offset - 1; i >= 0; i--) {
+      result[i] = (byte) -offset;
+    }
+    for (int i = offset; i < offset + count; i++) {
+      result[i] = (byte) ++currentValue;
+    }
+    return result;
+  }
+
+  private byte[] upTo(int size) {
+    assertThat(size).isLessThan(currentValue);
+    byte[] result = new byte[size];
+    for (int i = 0; i < size; i++) {
+      result[i] = (byte) (i + 1);
+    }
+    return result;
+  }
+
+  private byte[] all() {
+    byte[] result = new byte[currentValue];
+    for (int i = 0; i < currentValue; i++) {
+      result[i] = (byte) (i + 1);
+    }
+    return result;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index 77c6a93f5..118306807 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -15,14 +15,13 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ExifOrientationStreamTest {
   private ArrayPool byteArrayPool;
 
   private InputStream openOrientationExample(boolean isLandscape, int item) {
     String filePrefix = isLandscape ? "Landscape" : "Portrait";
-    return TestResourceUtil.openResource(getClass(),
-        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
+    return TestResourceUtil.openResource(getClass(), filePrefix + "_" + item + ".jpg");
   }
 
   @Before
diff --git a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
index ae3982203..ef0f1c385 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
@@ -20,21 +20,20 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class FileDescriptorAssetPathFetcherTest {
 
-  @Mock AssetManager assetManager;
-  @Mock AssetFileDescriptor assetFileDescriptor;
-  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock private AssetManager assetManager;
+  @Mock private AssetFileDescriptor assetFileDescriptor;
+  @Mock private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   private FileDescriptorAssetPathFetcher fetcher;
   private ParcelFileDescriptor expected;
-  private String assetPath;
 
   @Before
   public void setUp() throws IOException {
     MockitoAnnotations.initMocks(this);
-    assetPath = "/some/asset/path";
+    String assetPath = "/some/asset/path";
     fetcher = new FileDescriptorAssetPathFetcher(assetManager, assetPath);
     expected = mock(ParcelFileDescriptor.class);
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(expected);
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
similarity index 75%
rename from library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 94fd216bf..a515b740a 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -32,8 +32,8 @@
 
 /**
  * Tests {@link com.bumptech.glide.load.data.HttpUrlFetcher} against server responses. Tests for
- * behavior (connection/disconnection/options) should go in
- * {@link com.bumptech.glide.load.data.HttpUrlFetcherTest}, response handling should go here.
+ * behavior (connection/disconnection/options) should go in {@link
+ * com.bumptech.glide.load.data.HttpUrlFetcherTest}, response handling should go here.
  */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -41,7 +41,7 @@
   private static final String DEFAULT_PATH = "/fakepath";
   private static final int TIMEOUT_TIME_MS = 300;
 
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private MockWebServer mockWebServer;
   private boolean defaultFollowRedirects;
@@ -72,43 +72,54 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
     fetcher.loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
-    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(301)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
-    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(302)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
   public void testHandlesRelativeRedirects() throws Exception {
     String expected = "fakedata";
-    mockWebServer
-        .enqueue(new MockResponse().setResponseCode(301).setHeader("Location", "/redirect"));
+    mockWebServer.enqueue(
+        new MockResponse().setResponseCode(301).setHeader("Location", "/redirect"));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    mockWebServer.takeRequest();
+    RecordedRequest first = mockWebServer.takeRequest();
+    assertThat(first.getMethod()).isEqualTo("GET");
     RecordedRequest second = mockWebServer.takeRequest();
     assertThat(second.getPath()).endsWith("/redirect");
+    assertThat(second.getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -117,8 +128,10 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String expected = "redirectedData";
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
-      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
+      mockWebServer.enqueue(
+          new MockResponse()
+              .setResponseCode(301)
+              .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -126,18 +139,26 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
+    RecordedRequest request = mockWebServer.takeRequest();
+    assertThat(request.getPath()).contains(DEFAULT_PATH);
+    assertThat(request.getMethod()).isEqualTo("GET");
     for (int i = 0; i < numRedirects; i++) {
-      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
+      RecordedRequest current = mockWebServer.takeRequest();
+      assertThat(current.getPath()).contains(redirectBase + i);
+      assertThat(current.getMethod()).isEqualTo("GET");
     }
   }
 
   @Test
   public void testFailsOnRedirectLoops() throws Exception {
-    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
-    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(301)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(301)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
 
     getFetcher().loadData(Priority.IMMEDIATE, callback);
 
@@ -173,8 +194,10 @@ public void testFailsIfStatusCodeIsNegativeOne() throws Exception {
   @Test
   public void testFailsAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 10; i++) {
-      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
+      mockWebServer.enqueue(
+          new MockResponse()
+              .setResponseCode(301)
+              .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
 
@@ -236,7 +259,7 @@ private HttpUrlFetcher getFetcher() {
 
   private HttpUrlFetcher getFetcher(Headers headers) {
     URL url = mockWebServer.url(DEFAULT_PATH).url();
-    return new HttpUrlFetcher(new GlideUrl(url, headers), TIMEOUT_TIME_MS,
-        HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
+    return new HttpUrlFetcher(
+        new GlideUrl(url, headers), TIMEOUT_TIME_MS, HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 7ad707409..cd309b100 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -24,13 +24,13 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class HttpUrlFetcherTest {
-  @Mock HttpURLConnection urlConnection;
-  @Mock HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
-  @Mock GlideUrl glideUrl;
-  @Mock InputStream stream;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private HttpURLConnection urlConnection;
+  @Mock private HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
+  @Mock private GlideUrl glideUrl;
+  @Mock private InputStream stream;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private static final int TIMEOUT_MS = 100;
   private HttpUrlFetcher fetcher;
@@ -89,8 +89,7 @@ public void testDoesNotThrowIfCancelCalledBeforeStart() {
   }
 
   @Test
-  public void testCancelDoesNotDisconnectIfAlreadyConnected()
-      throws IOException {
+  public void testCancelDoesNotDisconnectIfAlreadyConnected() throws IOException {
     fetcher.loadData(Priority.HIGH, callback);
     fetcher.cancel();
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index c3d818ffc..cf26c7c1f 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -8,7 +8,7 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import java.io.Closeable;
 import java.io.FileNotFoundException;
@@ -23,10 +23,10 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class LocalUriFetcherTest {
   private TestLocalUriFetcher fetcher;
-  @Mock DataFetcher.DataCallback<Closeable> callback;
+  @Mock private DataFetcher.DataCallback<Closeable> callback;
 
   @Before
   public void setUp() {
@@ -61,7 +61,7 @@ public void testHandlesExceptionOnClose() throws Exception {
   private static class TestLocalUriFetcher extends LocalUriFetcher<Closeable> {
     final Closeable closeable = mock(Closeable.class);
 
-    public TestLocalUriFetcher(Context context, Uri uri) {
+    TestLocalUriFetcher(Context context, Uri uri) {
       super(context.getContentResolver(), uri);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
index 5b03e0f83..cde59b222 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
@@ -18,19 +18,18 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class StreamAssetPathFetcherTest {
-  @Mock AssetManager assetManager;
-  @Mock InputStream expected;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private AssetManager assetManager;
+  @Mock private InputStream expected;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private StreamAssetPathFetcher fetcher;
-  private String assetPath;
 
   @Before
   public void setUp() throws IOException {
     MockitoAnnotations.initMocks(this);
-    assetPath = "/some/asset/path";
+    String assetPath = "/some/asset/path";
     fetcher = new StreamAssetPathFetcher(assetManager, assetPath);
     when(assetManager.open(eq(assetPath))).thenReturn(expected);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
index 4ceec4c8f..3c3b5cbe8 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -19,12 +19,12 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ThumbFetcherTest {
 
-  @Mock ThumbnailStreamOpener opener;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
-  @Mock InputStream expected;
+  @Mock private ThumbnailStreamOpener opener;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
+  @Mock private InputStream expected;
 
   private ThumbFetcher fetcher;
   private Uri uri;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index 50535836c..ac3d5a933 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.load.data.mediastore;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
@@ -32,7 +34,7 @@
 import org.robolectric.fakes.RoboCursor;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ThumbnailStreamOpenerTest {
   private Harness harness;
 
@@ -56,7 +58,7 @@ public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
   @Test
   public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
     MatrixCursor cursor = new MatrixCursor(new String[1]);
-    cursor.addRow(new Object[] { "" });
+    cursor.addRow(new Object[] {""});
     when(harness.query.query(eq(harness.uri))).thenReturn(cursor);
     assertNull(harness.get().open(harness.uri));
   }
@@ -89,6 +91,12 @@ public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundExcep
     assertEquals(expected, harness.get().open(harness.uri));
   }
 
+  @Test
+  public void open_returnsNull_whenQueryThrowsSecurityException() throws FileNotFoundException {
+    when(harness.query.query(any(Uri.class))).thenThrow(new SecurityException());
+    assertThat(harness.get().open(harness.uri)).isNull();
+  }
+
   @Test
   public void testVideoQueryReturnsVideoCursor() {
     Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
@@ -116,15 +124,15 @@ private static ContentResolver getContentResolver() {
   }
 
   private static class Harness {
-    MatrixCursor cursor = new MatrixCursor(new String[1]);
-    File file = new File("fake/uri");
-    Uri uri = Uri.fromFile(file);
-    ThumbnailQuery query = mock(ThumbnailQuery.class);
-    FileService service = mock(FileService.class);
-    ArrayPool byteArrayPool = new LruArrayPool();
-
-    public Harness() {
-      cursor.addRow(new String[] { file.getAbsolutePath() });
+    final MatrixCursor cursor = new MatrixCursor(new String[1]);
+    final File file = new File("fake/uri");
+    final Uri uri = Uri.fromFile(file);
+    final ThumbnailQuery query = mock(ThumbnailQuery.class);
+    final FileService service = mock(FileService.class);
+    final ArrayPool byteArrayPool = new LruArrayPool();
+
+    Harness() {
+      cursor.addRow(new String[] {file.getAbsolutePath()});
       when(query.query(eq(uri))).thenReturn(cursor);
       when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
       when(service.exists(eq(file))).thenReturn(true);
@@ -132,7 +140,7 @@ public Harness() {
     }
 
     public ThumbnailStreamOpener get() {
-      List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+      List<ImageHeaderParser> parsers = new ArrayList<>();
       parsers.add(new DefaultImageHeaderParser());
       return new ThumbnailStreamOpener(
           parsers, service, query, byteArrayPool, getContentResolver());
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index 81687fa35..7ca4dac65 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -27,10 +27,12 @@
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
+@Config(
+    sdk = 18,
+    shadows = {ContentResolverShadow.class})
 public class FileDescriptorLocalUriFetcherTest {
 
-  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   @Before
   public void setUp() {
@@ -43,7 +45,7 @@ public void testLoadResource_returnsFileDescriptor() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
     ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
@@ -62,7 +64,7 @@ public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
     shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
 
     FileDescriptorLocalUriFetcher fetcher =
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index a7fb2d580..f9f5a1c50 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -25,9 +25,11 @@
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
+@Config(
+    sdk = 18,
+    shadows = {ContentResolverShadow.class})
 public class StreamLocalUriFetcherTest {
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   @Before
   public void setUp() {
@@ -40,7 +42,7 @@ public void testLoadResource_returnsInputStream() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
     shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
 
     StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
@@ -54,7 +56,7 @@ public void testLoadResource_withNullInputStream_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
 
     shadow.registerInputStream(uri, null /*inputStream*/);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
new file mode 100644
index 000000000..33cbf8ed9
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
@@ -0,0 +1,414 @@
+package com.bumptech.glide.load.engine;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+import android.os.Looper;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.ActiveResources.DequeuedResourceCallback;
+import com.bumptech.glide.load.engine.ActiveResources.ResourceWeakReference;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = GlideShadowLooper.class)
+public class ActiveResourcesTest {
+
+  @Mock private ResourceListener listener;
+  @Mock private Key key;
+  @Mock private Resource<Object> resource;
+
+  private ActiveResources resources;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
+    resources.setListener(listener);
+
+    reset(GlideShadowLooper.queue);
+  }
+
+  @After
+  public void tearDown() {
+    resources.shutdown();
+  }
+
+  @Test
+  public void get_withMissingKey_returnsNull() {
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveKey_returnsResource() {
+    EngineResource<Object> expected = newCacheableEngineResource();
+    resources.activate(key, expected);
+    assertThat(resources.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void get_withDeactivatedKey_returnsNull() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+    resources.deactivate(key);
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void deactivate_withNotActiveKey_doesNotThrow() {
+    resources.deactivate(key);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_returnsNull() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithWrappedResource() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithNotRecycleable() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    captor.getValue().recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithCacheable() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().isMemoryCacheable()).isTrue();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andNotCacheableResource_doesNotCallListener() {
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterResourceRemovedFromActive_doesNotCallListener() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    resources.deactivate(key);
+
+    enqueueAndWaitForRef(weakRef);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_callListener() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    EngineResource<?> released = captor.getValue();
+    assertThat(released.getResource()).isEqualTo(resource);
+    assertThat(released.isMemoryCacheable()).isTrue();
+
+    released.recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_doesNotCallListener() {
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+    enqueueAndWaitForRef(weakRef);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_removesResourceFromActive() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_removesResourceFromActive() {
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_notifiesListener() {
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+
+    resources.get(key);
+
+    enqueueAndWaitForRef(weakRef);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGetAndNotCacheable_doesNotNotifyListener() {
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceDeactivated_doesNotNotifyListener() {
+    final ExecutorService delegate = Executors.newSingleThreadExecutor();
+    try {
+      final CountDownLatch blockExecutor = new CountDownLatch(1);
+      resources =
+          new ActiveResources(
+              /*isActiveResourceRetentionAllowed=*/ true,
+              new Executor() {
+                @Override
+                public void execute(@NonNull final Runnable command) {
+                  delegate.execute(
+                      new Runnable() {
+                        @Override
+                        public void run() {
+                          try {
+                            blockExecutor.await();
+                          } catch (InterruptedException e) {
+                            throw new RuntimeException(e);
+                          }
+                          command.run();
+                        }
+                      });
+                }
+              });
+      resources.setListener(listener);
+
+      EngineResource<Object> engineResource = newCacheableEngineResource();
+      resources.activate(key, engineResource);
+
+      ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+      CountDownLatch latch = getLatchForClearedRef();
+      weakRef.enqueue();
+      resources.deactivate(key);
+      blockExecutor.countDown();
+
+      waitForLatch(latch);
+
+      verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    } finally {
+      resources.shutdown();
+      com.bumptech.glide.util.Executors.shutdownAndAwaitTermination(delegate);
+    }
+  }
+
+  @Test
+  public void queueIdle_afterReferenceQueuedThenReactivated_doesNotNotifyListener() {
+    final ExecutorService delegate = Executors.newSingleThreadExecutor();
+    try {
+      final CountDownLatch blockExecutor = new CountDownLatch(1);
+      resources =
+          new ActiveResources(
+              /*isActiveResourceRetentionAllowed=*/ true,
+              new Executor() {
+                @Override
+                public void execute(@NonNull final Runnable command) {
+                  delegate.execute(
+                      new Runnable() {
+                        @Override
+                        public void run() {
+                          try {
+                            blockExecutor.await();
+                          } catch (InterruptedException e) {
+                            throw new RuntimeException(e);
+                          }
+                          command.run();
+                        }
+                      });
+                }
+              });
+      resources.setListener(listener);
+
+      EngineResource<Object> first = newCacheableEngineResource();
+      resources.activate(key, first);
+
+      ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+      CountDownLatch latch = getLatchForClearedRef();
+      weakRef.enqueue();
+
+      EngineResource<Object> second = newCacheableEngineResource();
+      resources.activate(key, second);
+      blockExecutor.countDown();
+
+      waitForLatch(latch);
+
+      verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    } finally {
+      resources.shutdown();
+      com.bumptech.glide.util.Executors.shutdownAndAwaitTermination(delegate);
+    }
+  }
+
+  @Test
+  public void activate_withNonCacheableResource_doesNotSaveResource() {
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    assertThat(resources.activeEngineResources.get(key).resource).isNull();
+  }
+
+  @Test
+  public void get_withActiveClearedKey_cacheableResource_retentionDisabled_doesNotCallListener() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    resources.setListener(listener);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_retentionDisabled_doesNotNotify() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    resources.setListener(listener);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  private void enqueueAndWaitForRef(ResourceWeakReference ref) {
+    CountDownLatch latch = getLatchForClearedRef();
+    ref.enqueue();
+    waitForLatch(latch);
+  }
+
+  private void waitForLatch(CountDownLatch latch) {
+    try {
+      latch.await(10, TimeUnit.SECONDS);
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+    Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
+  }
+
+  private CountDownLatch getLatchForClearedRef() {
+    final CountDownLatch toWait = new CountDownLatch(1);
+    resources.setDequeuedResourceCallback(
+        new DequeuedResourceCallback() {
+          @Override
+          public void onResourceDequeued() {
+            toWait.countDown();
+          }
+        });
+    return toWait;
+  }
+
+  private EngineResource<Object> newCacheableEngineResource() {
+    return new EngineResource<>(
+        resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, key, listener);
+  }
+
+  private EngineResource<Object> newNonCacheableEngineResource() {
+    return new EngineResource<>(
+        resource, /*isMemoryCacheable=*/ false, /*isRecyclable=*/ false, key, listener);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static ArgumentCaptor<EngineResource<?>> getEngineResourceCaptor() {
+    return (ArgumentCaptor<EngineResource<?>>)
+        (ArgumentCaptor<?>) ArgumentCaptor.forClass(EngineResource.class);
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
new file mode 100644
index 000000000..acba45e0a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
@@ -0,0 +1,59 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util.WriteDigest;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class DataCacheKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Mock private Key firstKey;
+  @Mock private Key firstSignature;
+  @Mock private Key secondKey;
+  @Mock private Key secondSignature;
+
+  @Before
+  public void setUp() throws UnsupportedEncodingException {
+    MockitoAnnotations.initMocks(this);
+    doAnswer(new WriteDigest("firstKey"))
+        .when(firstKey)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new WriteDigest("firstSignature"))
+        .when(firstSignature)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new WriteDigest("secondKey"))
+        .when(secondKey)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new WriteDigest("secondSignature"))
+        .when(secondSignature)
+        .updateDiskCacheKey(any(MessageDigest.class));
+  }
+
+  @Test
+  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
+    keyTester
+        .addEquivalenceGroup(
+            new DataCacheKey(firstKey, firstSignature), new DataCacheKey(firstKey, firstSignature))
+        .addEquivalenceGroup(new DataCacheKey(firstKey, secondSignature))
+        .addEquivalenceGroup(new DataCacheKey(secondKey, firstSignature))
+        .addEquivalenceGroup(new DataCacheKey(secondKey, secondSignature))
+        .addRegressionTest(
+            new DataCacheKey(firstKey, firstSignature),
+            "801d7440d65a0e7c9ad0097d417f346dac4d4c4d5630724110fa3f3fe66236d9")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
similarity index 61%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 417845a13..89be0fd8c 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -17,12 +17,15 @@
 import static org.mockito.Mockito.when;
 
 import android.os.Handler;
-import android.support.v4.util.Pools;
+import android.os.Looper;
+import androidx.core.util.Pools;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Executors;
 import java.util.ArrayList;
 import java.util.List;
 import org.junit.Before;
@@ -37,7 +40,7 @@
 import org.robolectric.shadows.ShadowLooper;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class EngineJobTest {
   private EngineJobHarness harness;
 
@@ -47,7 +50,7 @@ public void setUp() {
   }
 
   @Test
-  public void testOnResourceReadyPassedToCallbacks() throws Exception {
+  public void testOnResourceReadyPassedToCallbacks() {
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
@@ -64,7 +67,8 @@ public void testListenerNotifiedJobCompleteOnOnResourceReady() {
 
     ShadowLooper.runUiThreadTasks();
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));
+    verify(harness.engineJobListener)
+        .onEngineJobComplete(eq(job), eq(harness.key), eq(harness.engineResource));
   }
 
   @Test
@@ -107,7 +111,8 @@ public void testListenerNotifiedJobCompleteOnException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
     ShadowLooper.runUiThreadTasks();
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
+    verify(harness.engineJobListener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
   }
 
   @Test
@@ -118,7 +123,9 @@ public void testResourceIsCacheableWhenIsCacheableOnReady() {
     job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
-    verify(harness.factory).build(anyResource(), eq(harness.isCacheable));
+    verify(harness.factory)
+        .build(
+            anyResource(), eq(harness.isCacheable), eq(harness.key), eq(harness.resourceListener));
   }
 
   @Test
@@ -129,7 +136,9 @@ public void testResourceIsCacheableWhenNotIsCacheableOnReady() {
     job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
-    verify(harness.factory).build(anyResource(), eq(harness.isCacheable));
+    verify(harness.factory)
+        .build(
+            anyResource(), eq(harness.isCacheable), eq(harness.key), eq(harness.resourceListener));
   }
 
   @Test
@@ -138,7 +147,7 @@ public void testListenerNotifiedOfCancelOnCancel() {
     job.start(harness.decodeJob);
     job.cancel();
 
-    verify(harness.listener).onEngineJobCancelled(eq(job), eq(harness.key));
+    verify(harness.engineJobListener).onEngineJobCancelled(eq(job), eq(harness.key));
   }
 
   @Test
@@ -179,7 +188,7 @@ public void testRemovingAllCallbacksCancelsRunner() {
   @Test
   public void removingSomeCallbacksDoesNotCancelRunner() {
     EngineJob<Object> job = harness.getJob();
-    job.addCallback(mock(ResourceCallback.class));
+    job.addCallback(mock(ResourceCallback.class), Executors.directExecutor());
     job.removeCallback(harness.cb);
 
     assertFalse(job.isCancelled());
@@ -201,7 +210,7 @@ public void testDoesNotNotifyCancelledIfCompletes() {
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
 
-    verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));
+    verify(harness.engineJobListener, never()).onEngineJobCancelled(eq(job), eq(harness.key));
   }
 
   @Test
@@ -211,7 +220,7 @@ public void testDoesNotNotifyCancelledIfAlreadyCancelled() {
     job.cancel();
     job.cancel();
 
-    verify(harness.listener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));
+    verify(harness.engineJobListener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));
   }
 
   @Test
@@ -220,20 +229,21 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
-    verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
+    verify(harness.engineJobListener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
+    verify(harness.engineJobListener, never())
+        .onEngineJobCancelled(any(EngineJob.class), any(Key.class));
   }
 
   @Test
   public void testReleasesResourceIfCancelledOnReady() {
-    ShadowLooper shadowLooper = Shadows.shadowOf(harness.mainHandler.getLooper());
-    shadowLooper.pause();
+    Looper looper = harness.mainHandler.getLooper();
+    Shadows.shadowOf(looper).pause();
 
-    EngineJob<Object> job = harness.getJob();
+    final EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource, harness.dataSource);
     job.cancel();
-    shadowLooper.runOneTask();
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     verify(harness.resource).recycle();
   }
@@ -254,15 +264,18 @@ public void testNotifiesNewCallbackOfResourceIfCallbackIsAddedDuringOnResourceRe
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.addCallback(newCallback);
-        return null;
-      }
-    }).when(existingCallback).onResourceReady(anyResource(), isADataSource());
-
-    job.addCallback(existingCallback);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.addCallback(newCallback, Executors.directExecutor());
+                return null;
+              }
+            })
+        .when(existingCallback)
+        .onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(existingCallback, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
 
@@ -276,16 +289,19 @@ public void testNotifiesNewCallbackOfExceptionIfCallbackIsAddedDuringOnException
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.addCallback(newCallback);
-        return null;
-      }
-    }).when(existingCallback).onLoadFailed(any(GlideException.class));
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.addCallback(newCallback, Executors.directExecutor());
+                return null;
+              }
+            })
+        .when(existingCallback)
+        .onLoadFailed(any(GlideException.class));
 
     GlideException exception = new GlideException("test");
-    job.addCallback(existingCallback);
+    job.addCallback(existingCallback, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onLoadFailed(exception);
 
@@ -297,15 +313,18 @@ public void testRemovingCallbackDuringOnResourceReadyIsIgnoredIfCallbackHasAlrea
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(cb);
-        return null;
-      }
-    }).when(cb).onResourceReady(anyResource(), isADataSource());
-
-    job.addCallback(cb);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(cb);
+                return null;
+              }
+            })
+        .when(cb)
+        .onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(cb, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
 
@@ -318,16 +337,19 @@ public void testRemovingCallbackDuringOnExceptionIsIgnoredIfCallbackHasAlreadyBe
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(cb);
-        return null;
-      }
-    }).when(cb).onLoadFailed(any(GlideException.class));
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(cb);
+                return null;
+              }
+            })
+        .when(cb)
+        .onLoadFailed(any(GlideException.class));
 
     GlideException exception = new GlideException("test");
-    job.addCallback(cb);
+    job.addCallback(cb, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onLoadFailed(exception);
 
@@ -336,19 +358,22 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
 
   @Test
   public void
-  testRemovingCallbackDuringOnResourceReadyPreventsCallbackFromBeingCalledIfNotYetCalled() {
+      testRemovingCallbackDuringOnResourceReadyPreventsCallbackFromBeingCalledIfNotYetCalled() {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(notYetCalled);
-        return null;
-      }
-    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
-
-    job.addCallback(notYetCalled);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(notYetCalled);
+                return null;
+              }
+            })
+        .when(harness.cb)
+        .onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(notYetCalled, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
 
@@ -357,19 +382,22 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
 
   @Test
   public void
-  testRemovingCallbackDuringOnResourceReadyPreventsResourceFromBeingAcquiredForCallback() {
+      testRemovingCallbackDuringOnResourceReadyPreventsResourceFromBeingAcquiredForCallback() {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(notYetCalled);
-        return null;
-      }
-    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
-
-    job.addCallback(notYetCalled);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(notYetCalled);
+                return null;
+              }
+            })
+        .when(harness.cb)
+        .onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(notYetCalled, Executors.directExecutor());
     job.start(harness.decodeJob);
 
     job.onResourceReady(harness.resource, harness.dataSource);
@@ -385,16 +413,19 @@ public void testRemovingCallbackDuringOnExceptionPreventsCallbackFromBeingCalled
     final ResourceCallback called = mock(ResourceCallback.class);
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(notYetCalled);
-        return null;
-      }
-    }).when(called).onLoadFailed(any(GlideException.class));
-
-    job.addCallback(called);
-    job.addCallback(notYetCalled);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(notYetCalled);
+                return null;
+              }
+            })
+        .when(called)
+        .onLoadFailed(any(GlideException.class));
+
+    job.addCallback(called, Executors.directExecutor());
+    job.addCallback(notYetCalled, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
@@ -423,7 +454,7 @@ public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
   public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
-    harness.diskCacheService.shutdownNow();
+    harness.sourceService.shutdownNow();
     job.start(harness.decodeJob);
 
     verify(harness.decodeJob).run();
@@ -453,78 +484,95 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
 
   @SuppressWarnings("unchecked")
   private static class MultiCbHarness {
-    Key key = mock(Key.class);
-    Resource<Object> resource = mockResource();
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    EngineJobListener listener = mock(EngineJobListener.class);
-    boolean isCacheable = true;
-    boolean useUnlimitedSourceGeneratorPool = false;
-    boolean useAnimationPool = false;
-    int numCbs = 10;
-    List<ResourceCallback> cbs = new ArrayList<>();
-    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-    EngineJob<Object> job;
-    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
-    GlideExecutor animationService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
-    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
-    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    DataSource dataSource = DataSource.LOCAL;
+    final Key key = mock(Key.class);
+    final Resource<Object> resource = mockResource();
+    final EngineResource<Object> engineResource = mock(EngineResource.class);
+    final EngineJobListener engineJobListener = mock(EngineJobListener.class);
+    final ResourceListener resourceListener = mock(ResourceListener.class);
+    final boolean isCacheable = true;
+    final boolean useUnlimitedSourceGeneratorPool = false;
+    final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
+    final int numCbs = 10;
+    final List<ResourceCallback> cbs = new ArrayList<>();
+    final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    final EngineJob<Object> job;
+    final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    final DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
-      when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
+      when(factory.build(resource, isCacheable, key, resourceListener)).thenReturn(engineResource);
       job =
           new EngineJob<>(
               diskCacheService,
               sourceService,
               sourceUnlimitedService,
               animationService,
-              listener,
+              engineJobListener,
+              resourceListener,
               pool,
-              factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool, useAnimationPool);
+              factory);
+      job.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
       for (ResourceCallback cb : cbs) {
-        job.addCallback(cb);
+        job.addCallback(cb, Executors.directExecutor());
       }
     }
   }
 
   @SuppressWarnings("unchecked")
   private static class EngineJobHarness {
-    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-    Key key = mock(Key.class);
-    Handler mainHandler = new Handler();
-    ResourceCallback cb = mock(ResourceCallback.class);
-    Resource<Object> resource = mockResource();
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    EngineJobListener listener = mock(EngineJobListener.class);
-    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
-    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
-    GlideExecutor animationService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
+    final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    final Key key = mock(Key.class);
+    final Handler mainHandler = new Handler();
+    final ResourceCallback cb = mock(ResourceCallback.class);
+    final Resource<Object> resource = mockResource();
+    final EngineResource<Object> engineResource = mock(EngineResource.class);
+    final EngineJobListener engineJobListener = mock(EngineJobListener.class);
+    final ResourceListener resourceListener = mock(ResourceListener.class);
+    final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
     boolean isCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
-    boolean useAnimationPool = false;
-    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
-    DataSource dataSource = DataSource.DATA_DISK_CACHE;
-
-    public EngineJob<Object> getJob() {
-      when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
+    final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
+    final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SynchronizedPool<>(1);
+    final DataSource dataSource = DataSource.DATA_DISK_CACHE;
+
+    EngineJob<Object> getJob() {
+      when(factory.build(resource, isCacheable, key, resourceListener)).thenReturn(engineResource);
       EngineJob<Object> result =
           new EngineJob<>(
               diskCacheService,
               sourceService,
               sourceUnlimitedService,
               animationService,
-              listener,
+              engineJobListener,
+              resourceListener,
               pool,
-              factory)
-              .init(key, isCacheable, useUnlimitedSourceGeneratorPool, useAnimationPool);
-      result.addCallback(cb);
+              factory);
+      result.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
+      result.addCallback(cb, Executors.directExecutor());
       return result;
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
new file mode 100644
index 000000000..6ea803c99
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -0,0 +1,191 @@
+package com.bumptech.glide.load.engine;
+
+import static org.junit.Assert.assertThrows;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.signature.ObjectKey;
+import com.google.common.testing.EqualsTester;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class EngineKeyTest {
+  @Mock private Transformation<Object> transformation;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void updateDiskCacheKey_throwsException() throws NoSuchAlgorithmException {
+    // If this test fails, update testEqualsAndHashcode to use KeyTester including regression tests.
+    final EngineKey key =
+        new EngineKey(
+            "id",
+            new ObjectKey("signature"),
+            100,
+            100,
+            Collections.<Class<?>, Transformation<?>>emptyMap(),
+            Object.class,
+            Object.class,
+            new Options());
+    assertThrows(
+        UnsupportedOperationException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws NoSuchAlgorithmException {
+            key.updateDiskCacheKey(MessageDigest.getInstance("SHA-1"));
+          }
+        });
+  }
+
+  @Test
+  public void testEqualsAndHashCode() {
+    Options memoryOptions = new Options();
+    memoryOptions.set(Option.memory("key", new Object()), new Object());
+
+    Options diskOptions = new Options();
+    diskOptions.set(
+        Option.disk(
+            "key",
+            new CacheKeyUpdater<String>() {
+              @Override
+              public void update(
+                  @NonNull byte[] keyBytes,
+                  @NonNull String value,
+                  @NonNull MessageDigest messageDigest) {
+                messageDigest.update(keyBytes);
+                messageDigest.update(value.getBytes(Key.CHARSET));
+              }
+            }),
+        "value");
+
+    new EqualsTester()
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()),
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "otherId",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("otherSignature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                200,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                200,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Integer.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Integer.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                memoryOptions))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                diskOptions))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
similarity index 57%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index c4a05be94..c308be1fe 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -5,8 +5,9 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -14,23 +15,25 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class EngineResourceTest {
   private EngineResource<Object> engineResource;
-  private EngineResource.ResourceListener listener;
-  private Key cacheKey = mock(Key.class);
-  private Resource<Object> resource;
+  @Mock private EngineResource.ResourceListener listener;
+  @Mock private Key cacheKey;
+  @Mock private Resource<Object> resource;
 
   @Before
   public void setUp() {
-    resource = mockResource();
-    engineResource = new EngineResource<>(resource, true /*isMemoryCacheable*/);
-    listener = mock(EngineResource.ResourceListener.class);
-    engineResource.setResourceListener(cacheKey, listener);
+    MockitoAnnotations.initMocks(this);
+    engineResource =
+        new EngineResource<>(
+            resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, cacheKey, listener);
   }
 
   @Test
@@ -98,17 +101,19 @@ public void testThrowsIfAcquiredAfterRecycled() {
 
   @Test
   public void testThrowsIfAcquiredOnBackgroundThread() throws InterruptedException {
-    Thread otherThread = new Thread(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          engineResource.acquire();
-        } catch (IllegalThreadStateException e) {
-          return;
-        }
-        fail("Failed to receive expected IllegalThreadStateException");
-      }
-    });
+    Thread otherThread =
+        new Thread(
+            new Runnable() {
+              @Override
+              public void run() {
+                try {
+                  engineResource.acquire();
+                } catch (IllegalThreadStateException e) {
+                  return;
+                }
+                fail("Failed to receive expected IllegalThreadStateException");
+              }
+            });
     otherThread.start();
     otherThread.join();
   }
@@ -116,17 +121,19 @@ public void run() {
   @Test
   public void testThrowsIfReleasedOnBackgroundThread() throws InterruptedException {
     engineResource.acquire();
-    Thread otherThread = new Thread(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          engineResource.release();
-        } catch (IllegalThreadStateException e) {
-          return;
-        }
-        fail("Failed to receive expected IllegalThreadStateException");
-      }
-    });
+    Thread otherThread =
+        new Thread(
+            new Runnable() {
+              @Override
+              public void run() {
+                try {
+                  engineResource.release();
+                } catch (IllegalThreadStateException e) {
+                  return;
+                }
+                fail("Failed to receive expected IllegalThreadStateException");
+              }
+            });
     otherThread.start();
     otherThread.join();
   }
@@ -140,14 +147,39 @@ public void testThrowsIfReleasedMoreThanAcquired() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfWrappedResourceIsNull() {
-    new EngineResource<>(null, false);
+    new EngineResource<>(
+        /*toWrap=*/ null, /*isMemoryCacheable=*/ false, /*isRecyclable=*/ true, cacheKey, listener);
   }
 
   @Test
   public void testCanSetAndGetIsCacheable() {
-    engineResource = new EngineResource<>(mockResource(), true);
-    assertTrue(engineResource.isCacheable());
-    engineResource = new EngineResource<>(mockResource(), false);
-    assertFalse(engineResource.isCacheable());
+    engineResource =
+        new EngineResource<>(
+            mockResource(),
+            /*isMemoryCacheable=*/ true,
+            /*isRecyclable=*/ true,
+            cacheKey,
+            listener);
+    assertTrue(engineResource.isMemoryCacheable());
+    engineResource =
+        new EngineResource<>(
+            mockResource(),
+            /*isMemoryCacheable=*/ false,
+            /*isRecyclable=*/ true,
+            cacheKey,
+            listener);
+    assertFalse(engineResource.isMemoryCacheable());
+  }
+
+  @Test
+  public void release_whenNotRecycleable_doesNotRecycleResource() {
+    resource = mockResource();
+    engineResource =
+        new EngineResource<>(
+            resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, cacheKey, listener);
+    engineResource.recycle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    verify(resource, never()).recycle();
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
new file mode 100644
index 000000000..5e57eb5c4
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -0,0 +1,747 @@
+package com.bumptech.glide.load.engine;
+
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.util.Executors;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(
+    sdk = 18,
+    shadows = {GlideShadowLooper.class})
+@SuppressWarnings("unchecked")
+public class EngineTest {
+  private EngineTestHarness harness;
+
+  @Before
+  public void setUp() {
+    harness = new EngineTestHarness();
+  }
+
+  @Test
+  public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
+    harness.doLoad();
+
+    verify(harness.job).start((DecodeJob) any());
+  }
+
+  @Test
+  public void testCallbackIsAddedToNewEngineJobWithNoExistingLoad() {
+    harness.doLoad();
+
+    verify(harness.job).addCallback(eq(harness.cb), any(Executor.class));
+  }
+
+  @Test
+  public void testLoadStatusIsReturnedForNewLoad() {
+    assertNotNull(harness.doLoad());
+  }
+
+  @Test
+  public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
+    Engine.LoadStatus loadStatus = harness.doLoad();
+    loadStatus.cancel();
+
+    verify(harness.job).removeCallback(eq(harness.cb));
+  }
+
+  @Test
+  public void testNewRunnerIsAddedToRunnersMap() {
+    harness.doLoad();
+
+    assertThat(harness.jobs.getAll()).containsKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
+    harness.doLoad();
+    harness.doLoad();
+
+    verify(harness.job, times(1)).start((DecodeJob) any());
+  }
+
+  @Test
+  public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
+    harness.doLoad();
+
+    ResourceCallback newCallback = mock(ResourceCallback.class);
+    harness.cb = newCallback;
+    harness.doLoad();
+
+    verify(harness.job).addCallback(eq(newCallback), any(Executor.class));
+  }
+
+  @Test
+  public void testLoadStatusIsReturnedForExistingJob() {
+    harness.doLoad();
+    Engine.LoadStatus loadStatus = harness.doLoad();
+
+    assertNotNull(loadStatus);
+  }
+
+  @Test
+  public void testResourceIsReturnedFromActiveResourcesIfPresent() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testResourceIsAcquiredIfReturnedFromActiveResources() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.resource).acquire();
+  }
+
+  @Test
+  public void testNewLoadIsNotStartedIfResourceIsActive() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.job, never()).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void testNullLoadStatusIsReturnedIfResourceIsActive() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    assertNull(harness.doLoad());
+  }
+
+  @Test
+  public void load_withResourceInActiveResources_doesNotCheckMemoryCache() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+    verify(harness.cache, never()).remove(any(Key.class));
+  }
+
+  @Test
+  public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.isMemoryCacheable = false;
+    harness.doLoad();
+
+    verify(harness.resource, never()).acquire();
+    verify(harness.job).start((DecodeJob) any());
+  }
+
+  @Test
+  public void testCacheIsCheckedIfMemoryCacheable() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testCacheIsNotCheckedIfNotMemoryCacheable() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.isMemoryCacheable = false;
+    harness.doLoad();
+
+    verify(harness.job).start((DecodeJob) any());
+  }
+
+  @Test
+  public void testResourceIsReturnedFromCacheIfPresent() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testHandlesNonEngineResourcesFromCacheIfPresent() {
+    final Object expected = new Object();
+    @SuppressWarnings("rawtypes")
+    Resource fromCache = mockResource();
+    when(fromCache.get()).thenReturn(expected);
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
+
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[0];
+                assertEquals(expected, resource.get());
+                return null;
+              }
+            })
+        .when(harness.cb)
+        .onResourceReady(anyResource(), isADataSource());
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(anyResource(), isADataSource());
+  }
+
+  @Test
+  public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+    EngineResource<?> activeResource = harness.activeResources.get(harness.cacheKey);
+    assertThat(activeResource).isEqualTo(harness.resource);
+  }
+
+  @Test
+  public void testResourceIsAcquiredIfReturnedFromCache() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.resource).acquire();
+  }
+
+  @Test
+  public void testNewLoadIsNotStartedIfResourceIsCached() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.job, never()).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void testNullLoadStatusIsReturnedForCachedResource() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    Engine.LoadStatus loadStatus = harness.doLoad();
+    assertNull(loadStatus);
+  }
+
+  @Test
+  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
+    harness.doLoad();
+
+    harness.callOnEngineJobComplete();
+
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
+    harness.doLoad();
+
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
+  }
+
+  @Test
+  public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
+    when(harness.resource.isMemoryCacheable()).thenReturn(true);
+    harness.callOnEngineJobComplete();
+
+    EngineResource<?> resource = harness.activeResources.get(harness.cacheKey);
+    assertThat(harness.resource).isEqualTo(resource);
+  }
+
+  @Test
+  public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
+  }
+
+  @Test
+  public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
+    when(harness.resource.isMemoryCacheable()).thenReturn(false);
+    harness.callOnEngineJobComplete();
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
+  }
+
+  @Test
+  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
+    harness.doLoad();
+
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
+    harness.doLoad();
+
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    assertEquals(harness.job, harness.jobs.get(harness.cacheKey, harness.onlyRetrieveFromCache));
+  }
+
+  @Test
+  public void testResourceIsAddedToCacheOnReleased() {
+    final Object expected = new Object();
+    when(harness.resource.isMemoryCacheable()).thenReturn(true);
+    when(harness.resource.get()).thenReturn(expected);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
+                assertEquals(expected, resource.get());
+                return null;
+              }
+            })
+        .when(harness.cache)
+        .put(eq(harness.cacheKey), anyResource());
+
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+
+    verify(harness.cache).put(eq(harness.cacheKey), anyResource());
+  }
+
+  @Test
+  public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
+    when(harness.resource.isMemoryCacheable()).thenReturn(false);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+
+    verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
+  }
+
+  @Test
+  public void testResourceIsRecycledIfNotCacheableWhenReleased() {
+    when(harness.resource.isMemoryCacheable()).thenReturn(false);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+    verify(harness.resourceRecycler).recycle(eq(harness.resource));
+  }
+
+  @Test
+  public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
+  }
+
+  @Test
+  public void testEngineAddedAsListenerToMemoryCache() {
+    harness.getEngine();
+    verify(harness.cache).setResourceRemovedListener(eq(harness.getEngine()));
+  }
+
+  @Test
+  public void testResourceIsRecycledWhenRemovedFromCache() {
+    harness.getEngine().onResourceRemoved(harness.resource);
+    verify(harness.resourceRecycler).recycle(eq(harness.resource));
+  }
+
+  @Test
+  public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
+    harness.doLoad();
+
+    assertThat(harness.jobs.getAll()).containsEntry(harness.cacheKey, harness.job);
+  }
+
+  @Test
+  public void testKeyFactoryIsGivenNecessaryArguments() {
+    harness.doLoad();
+
+    verify(harness.keyFactory)
+        .buildKey(
+            eq(harness.model),
+            eq(harness.signature),
+            eq(harness.width),
+            eq(harness.height),
+            eq(harness.transformations),
+            eq(Object.class),
+            eq(Object.class),
+            eq(harness.options));
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArguments() {
+    harness.doLoad();
+
+    verify(harness.engineJobFactory)
+        .build(
+            eq(harness.cacheKey),
+            eq(true) /*isMemoryCacheable*/,
+            eq(false) /*useUnlimitedSourceGeneratorPool*/,
+            /*useAnimationPool=*/ eq(false),
+            /*onlyRetrieveFromCache=*/ eq(false));
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    harness.doLoad();
+
+    verify(harness.engineJobFactory)
+        .build(
+            eq(harness.cacheKey),
+            eq(true) /*isMemoryCacheable*/,
+            eq(true) /*useUnlimitedSourceGeneratorPool*/,
+            /*useAnimationPool=*/ eq(false),
+            /*onlyRetrieveFromCache=*/ eq(false));
+  }
+
+  @Test
+  public void testReleaseReleasesEngineResource() {
+    EngineResource<Object> engineResource = mock(EngineResource.class);
+    harness.getEngine().release(engineResource);
+    verify(engineResource).release();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfAskedToReleaseNonEngineResource() {
+    harness.getEngine().release(mockResource());
+  }
+
+  @Test
+  public void load_whenCalledOnBackgroundThread_doesNotThrow() throws InterruptedException {
+    BackgroundUtil.testInBackground(
+        new BackgroundUtil.BackgroundTester() {
+          @Override
+          public void runTest() {
+            harness.doLoad();
+          }
+        });
+  }
+
+  @Test
+  public void load_afterResourceIsLoadedInActiveResources_returnsFromMemoryCache() {
+    when(harness.resource.isMemoryCacheable()).thenReturn(true);
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocationOnMock) {
+                harness.callOnEngineJobComplete();
+                return null;
+              }
+            })
+        .when(harness.job)
+        .start(anyDecodeJobOrNull());
+    harness.doLoad();
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_afterResourceIsLoadedAndReleased_returnsFromMemoryCache() {
+    harness.cache = new LruResourceCache(100);
+    when(harness.resource.isMemoryCacheable()).thenReturn(true);
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocationOnMock) {
+                harness.callOnEngineJobComplete();
+                return null;
+              }
+            })
+        .when(harness.job)
+        .start(anyDecodeJobOrNull());
+    harness.doLoad();
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_andPreviousNormalLoad_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    verify(first).start(anyDecodeJobOrNull());
+    verify(second).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void load_withNormalLoad_afterPreviousRetrieveFromCache_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(first).start(anyDecodeJobOrNull());
+    verify(second).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void load_afterFinishedOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(anyDecodeJobOrNull());
+    verify(secondNormal, never()).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void load_afterCancelledOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(anyDecodeJobOrNull());
+    verify(secondNormal, never()).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_withOtherRetrieveFromCachePending_doesNotStartNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second, never()).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousFinishedOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousCancelledOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void onEngineJobComplete_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness
+        .getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void onEngineJobComplete_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness
+        .getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(anyDecodeJobOrNull());
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(anyDecodeJobOrNull());
+  }
+
+  @SuppressWarnings({"unchecked", "rawtypes"})
+  private static DecodeJob anyDecodeJobOrNull() {
+    return any();
+  }
+
+  private static class EngineTestHarness {
+    final EngineKey cacheKey = mock(EngineKey.class);
+    final EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
+    ResourceCallback cb = mock(ResourceCallback.class);
+
+    @SuppressWarnings("rawtypes")
+    final EngineResource resource = mock(EngineResource.class);
+
+    final Jobs jobs = new Jobs();
+    final ActiveResources activeResources =
+        new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
+
+    final int width = 100;
+    final int height = 100;
+
+    final Object model = new Object();
+    MemoryCache cache = mock(MemoryCache.class);
+    EngineJob<?> job;
+    private Engine engine;
+    final Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
+    final Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
+    final ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
+    final Key signature = mock(Key.class);
+    final Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+    final Options options = new Options();
+    final GlideContext glideContext = mock(GlideContext.class);
+    boolean isMemoryCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
+    boolean onlyRetrieveFromCache = false;
+    final boolean isScaleOnlyOrNoTransform = true;
+
+    EngineTestHarness() {
+      when(keyFactory.buildKey(
+              eq(model),
+              eq(signature),
+              anyInt(),
+              anyInt(),
+              eq(transformations),
+              eq(Object.class),
+              eq(Object.class),
+              eq(options)))
+          .thenReturn(cacheKey);
+      when(resource.getResource()).thenReturn(mock(Resource.class));
+
+      job = mock(EngineJob.class);
+    }
+
+    void callOnEngineJobComplete() {
+      getEngine().onEngineJobComplete(job, cacheKey, resource);
+    }
+
+    Engine.LoadStatus doLoad() {
+      when(engineJobFactory.build(
+              eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean(), anyBoolean()))
+          .thenReturn((EngineJob<Object>) job);
+      when(job.onlyRetrieveFromCache()).thenReturn(onlyRetrieveFromCache);
+      return getEngine()
+          .load(
+              glideContext,
+              model,
+              signature,
+              width,
+              height,
+              Object.class /*resourceClass*/,
+              Object.class /*transcodeClass*/,
+              Priority.HIGH,
+              DiskCacheStrategy.ALL,
+              transformations,
+              false /*isTransformationRequired*/,
+              isScaleOnlyOrNoTransform,
+              options,
+              isMemoryCacheable,
+              useUnlimitedSourceGeneratorPool,
+              /*useAnimationPool=*/ false,
+              onlyRetrieveFromCache,
+              cb,
+              Executors.directExecutor());
+    }
+
+    Engine getEngine() {
+      if (engine == null) {
+        engine =
+            new Engine(
+                cache,
+                mock(DiskCache.Factory.class),
+                GlideExecutor.newDiskCacheExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                jobs,
+                keyFactory,
+                activeResources,
+                engineJobFactory,
+                decodeJobFactory,
+                resourceRecycler,
+                /*isActiveResourceRetentionAllowed=*/ true);
+      }
+      return engine;
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
new file mode 100644
index 000000000..97ea3c666
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -0,0 +1,198 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public class ResourceCacheKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Mock private Transformation<Object> transformation1;
+  @Mock private Transformation<Object> transformation2;
+  private LruArrayPool arrayPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    arrayPool = new LruArrayPool();
+    doAnswer(new Util.WriteDigest("transformation1"))
+        .when(transformation1)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("transformation1"))
+        .when(transformation2)
+        .updateDiskCacheKey(any(MessageDigest.class));
+  }
+
+  @Test
+  public void testEqualsAndHashCode() {
+    Options memoryOptions = new Options();
+    memoryOptions.set(Option.memory("key", new Object()), new Object());
+
+    Options diskOptions = new Options();
+    diskOptions.set(
+        Option.disk(
+            "key",
+            new CacheKeyUpdater<String>() {
+              @Override
+              public void update(
+                  @NonNull byte[] keyBytes,
+                  @NonNull String value,
+                  @NonNull MessageDigest messageDigest) {
+                messageDigest.update(keyBytes);
+                messageDigest.update(value.getBytes(Key.CHARSET));
+              }
+            }),
+        "value");
+
+    for (int i = 0; i < 20; i++) {
+      byte[] array = new byte[9];
+      Arrays.fill(array, (byte) 2);
+      arrayPool.put(array);
+    }
+
+    keyTester
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()),
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("otherSource"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("otherSignature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                200,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                200,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation2,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Integer.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                memoryOptions))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                diskOptions))
+        .addRegressionTest(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()),
+            "04d632bfe8e588544909fc44edb7328fa28bea6831b96927ade22b44818654e2")
+        .addRegressionTest(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                diskOptions),
+            "781ff8cd30aaaf248134580004ea6d63a1b87ae20ea0f769caf379d7d84986d0")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
index 80405ffc9..322e9349c 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
@@ -16,7 +16,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ResourceRecyclerTest {
 
   private ResourceRecycler recycler;
@@ -38,13 +38,16 @@ public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
   public void testDoesNotRecycleChildResourceSynchronously() {
     Resource<?> parent = mockResource();
     final Resource<?> child = mockResource();
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        recycler.recycle(child);
-        return null;
-      }
-    }).when(parent).recycle();
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+                recycler.recycle(child);
+                return null;
+              }
+            })
+        .when(parent)
+        .recycle();
 
     Shadows.shadowOf(Looper.getMainLooper()).pause();
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
index 5ee47b04b..faf704043 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
@@ -16,7 +16,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class AttributeStrategyKeyTest {
 
   private AttributeStrategy.KeyPool keyPool;
@@ -42,8 +42,12 @@ public void testEquality() {
     Key fifth = new Key(keyPool);
     fifth.init(100, 100, Bitmap.Config.RGB_565);
 
-    new EqualsTester().addEqualityGroup(first, second).addEqualityGroup(third)
-        .addEqualityGroup(fourth).addEqualityGroup(fifth).testEquals();
+    new EqualsTester()
+        .addEqualityGroup(first, second)
+        .addEqualityGroup(third)
+        .addEqualityGroup(fourth)
+        .addEqualityGroup(fifth)
+        .testEquals();
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
similarity index 67%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
index 234b0f0e3..d2337f51e 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -9,10 +9,9 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class AttributeStrategyTest {
 
   private AttributeStrategy strategy;
@@ -29,52 +28,52 @@ public void testIGetNullIfNoMatchingBitmapExists() {
 
   @Test
   public void testICanAddAndGetABitmapOfTheSameSizeAndDimensions() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
-    assertEquals(bitmap,
-        strategy.get(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888));
+    assertEquals(
+        bitmap, strategy.get(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testICantGetABitmapOfTheSameDimensionsButDifferentConfigs() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
   }
 
   @Test
   public void testICantGetABitmapOfTheSameDimensionsAndSizeButDifferentConfigs() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentWidths() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(99, 100, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentHeights() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 99, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentDimensionsButTheSameSize() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(50, 200, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testMultipleBitmapsOfDifferentAttributesCanBeAddedAtOnce() {
-    Bitmap first = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Bitmap second = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Bitmap third = ShadowBitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);
+    Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    Bitmap second = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap third = Bitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);
 
     strategy.put(first);
     strategy.put(second);
@@ -87,9 +86,9 @@ public void testMultipleBitmapsOfDifferentAttributesCanBeAddedAtOnce() {
 
   @Test
   public void testLeastRecentlyUsedAttributeSetIsRemovedFirst() {
-    final Bitmap leastRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    final Bitmap other = ShadowBitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);
-    final Bitmap mostRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final Bitmap leastRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    final Bitmap other = Bitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);
+    final Bitmap mostRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     strategy.get(100, 100, Bitmap.Config.ALPHA_8);
     strategy.get(1000, 1000, Bitmap.Config.RGB_565);
@@ -102,6 +101,7 @@ public void testLeastRecentlyUsedAttributeSetIsRemovedFirst() {
     Bitmap removed = strategy.removeLast();
     assertEquals(
         "Expected=" + strategy.logBitmap(leastRecentlyUsed) + " got=" + strategy.logBitmap(removed),
-        leastRecentlyUsed, removed);
+        leastRecentlyUsed,
+        removed);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
new file mode 100644
index 000000000..6689d6d57
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
@@ -0,0 +1,121 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class GroupedLinkedMapTest {
+
+  private GroupedLinkedMap<Key, Object> map;
+
+  @Before
+  public void setUp() {
+    map = new GroupedLinkedMap<>();
+  }
+
+  @Test
+  public void testReturnsNullForGetWithNoBitmap() {
+    Key key = new Key("key", /*width=*/ 1, /*height=*/ 1);
+    assertNull(map.get(key));
+  }
+
+  @Test
+  public void testCanAddAndRemoveABitmap() {
+    Key key = new Key("key", 1, 1);
+    Object expected = new Object();
+
+    map.put(key, expected);
+
+    assertThat(map.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
+    Key key = new Key("key", 1, 1);
+    Integer value = 20;
+
+    int numToAdd = 10;
+
+    for (int i = 0; i < numToAdd; i++) {
+      map.put(key, value);
+    }
+
+    for (int i = 0; i < numToAdd; i++) {
+      assertThat(map.get(key)).isEqualTo(value);
+    }
+  }
+
+  @Test
+  public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
+    Key firstKey = new Key("key", 1, 1);
+    Integer firstValue = 10;
+    map.put(firstKey, firstValue);
+    map.put(firstKey, firstValue);
+
+    Key secondKey = new Key("key", 2, 2);
+    Integer secondValue = 20;
+    map.put(secondKey, secondValue);
+
+    map.get(firstKey);
+
+    assertThat(map.removeLast()).isEqualTo(secondValue);
+  }
+
+  @Test
+  public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
+    Key firstKey = new Key("key", 1, 1);
+    Integer firstValue = 10;
+
+    map.put(firstKey, firstValue);
+    map.put(firstKey, firstValue);
+
+    map.get(firstKey);
+
+    Integer secondValue = 20;
+    map.put(new Key("key", 2, 2), secondValue);
+
+    assertThat(map.removeLast()).isEqualTo(secondValue);
+  }
+
+  private static final class Key implements Poolable {
+
+    private final String key;
+    private final int width;
+    private final int height;
+
+    Key(String key, int width, int height) {
+      this.key = key;
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return key.equals(other.key) && width == other.width && height == other.height;
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = key != null ? key.hashCode() : 0;
+      result = 31 * result + width;
+      result = 31 * result + height;
+      return result;
+    }
+
+    @Override
+    public void offer() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
new file mode 100644
index 000000000..6df26cc5e
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -0,0 +1,205 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class LruArrayPoolTest {
+  private static final int MAX_SIZE = 10;
+  private static final int MAX_PUT_SIZE = MAX_SIZE / 2;
+  private static final Class<byte[]> ARRAY_CLASS = byte[].class;
+  private static final ArrayAdapterInterface<byte[]> ADAPTER = new ByteArrayAdapter();
+  private LruArrayPool pool;
+
+  @Before
+  public void setUp() {
+    pool = new LruArrayPool(MAX_SIZE);
+  }
+
+  @Test
+  public void testNewPoolIsEmpty() {
+    assertEquals(pool.getCurrentSize(), 0);
+  }
+
+  @Test
+  public void testICanAddAndGetValidArray() {
+    int size = 758;
+    int value = 564;
+    fillPool(pool, size - 1, value);
+    pool.put(createArray(ARRAY_CLASS, size, value));
+    Object array = pool.get(size, ARRAY_CLASS);
+    assertNotNull(array);
+    assertTrue(array.getClass() == ARRAY_CLASS);
+    assertTrue(ADAPTER.getArrayLength((byte[]) array) >= size);
+    assertTrue(((byte[]) array)[0] == (byte) 0);
+  }
+
+  @Test
+  public void testItIsSizeLimited() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 1);
+    assertTrue(pool.getCurrentSize() <= MAX_SIZE);
+  }
+
+  @Test
+  public void testArrayLargerThanPoolIsNotAdded() {
+    pool = new LruArrayPool(MAX_SIZE);
+    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0));
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testClearMemoryRemovesAllArrays() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0);
+    pool.clearMemory();
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
+    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
+      testTrimMemory(MAX_SIZE, trimLevel, 0);
+    }
+  }
+
+  @Test
+  public void get_withEmptyPool_returnsExactArray() {
+    assertThat(pool.get(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void get_withPoolContainingLargerArray_returnsLargerArray() {
+    byte[] expected = new byte[MAX_PUT_SIZE];
+    pool.put(expected);
+    assertThat(pool.get(MAX_PUT_SIZE - 1, byte[].class)).isSameInstanceAs(expected);
+  }
+
+  @Test
+  public void get_withPoolContainingSmallerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE - 1]);
+    assertThat(pool.get(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void get_withPoolLessThanHalfFull_returnsFromPools() {
+    int size = MAX_SIZE / 2;
+    byte[] expected = new byte[size];
+    pool.put(expected);
+    assertThat(pool.get(1, byte[].class)).isSameInstanceAs(expected);
+  }
+
+  @Test
+  public void get_withPoolMoreThanHalfFull_sizeMoreThanHalfArrayInPool_returnsArray() {
+    Set<byte[]> expected = new HashSet<>();
+    for (int i = 0; i < 3; i++) {
+      byte[] toPut = new byte[MAX_SIZE / 3];
+      expected.add(toPut);
+      pool.put(toPut);
+    }
+    byte[] received = pool.get(2, byte[].class);
+    assertThat(expected).contains(received);
+  }
+
+  @Test
+  public void get_withPoolMoreThanHalfFull_sizeLessThanHalfArrayInPool_returnsNewArray() {
+    pool = new LruArrayPool(100);
+    for (int i = 0; i < 3; i++) {
+      byte[] toPut = new byte[100 / 3];
+      pool.put(toPut);
+    }
+    int requestedSize = 100 / 3 / LruArrayPool.MAX_OVER_SIZE_MULTIPLE;
+    byte[] received = pool.get(requestedSize, byte[].class);
+    assertThat(received).hasLength(requestedSize);
+  }
+
+  @Test
+  public void getExact_withEmptyPool_returnsExactArray() {
+    byte[] result = pool.getExact(MAX_PUT_SIZE, byte[].class);
+    assertThat(result).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void getExact_withPoolContainingLargerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE]);
+    int expectedSize = MAX_PUT_SIZE - 1;
+    assertThat(pool.getExact(expectedSize, byte[].class)).hasLength(expectedSize);
+  }
+
+  @Test
+  public void getExact_withPoolContainingSmallerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE - 1]);
+    assertThat(pool.getExact(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void getExact_withPoolContainingExactArray_returnsArray() {
+    byte[] expected = new byte[MAX_PUT_SIZE];
+    pool.put(expected);
+    assertThat(pool.getExact(MAX_PUT_SIZE, byte[].class)).isSameInstanceAs(expected);
+  }
+
+  @Test
+  public void put_withArrayMoreThanHalfPoolSize_doesNotRetainArray() {
+    int targetSize = (MAX_SIZE / 2) + 1;
+    byte[] toPut = new byte[targetSize];
+    pool.put(toPut);
+    assertThat(pool.getCurrentSize()).isEqualTo(0);
+    assertThat(pool.get(targetSize, byte[].class)).isNotSameInstanceAs(toPut);
+  }
+
+  private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
+    pool = new LruArrayPool(MAX_SIZE);
+    fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
+    pool.trimMemory(trimLevel);
+    assertEquals("Failed level=" + trimLevel, expectedSize, pool.getCurrentSize());
+  }
+
+  private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
+    for (int i = 0; i < arrayCount; i++) {
+      pool.put(createArray(ARRAY_CLASS, arrayLength, 10));
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> T createArray(Class<T> type, int size, int value) {
+    Object array = null;
+    if (type.equals(int[].class)) {
+      array = new int[size];
+      Arrays.fill((int[]) array, value);
+    } else if (type.equals(byte[].class)) {
+      array = new byte[size];
+      Arrays.fill((byte[]) array, (byte) value);
+    }
+    return (T) array;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index 2b515c771..bc26eaf28 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -2,6 +2,7 @@
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
@@ -13,9 +14,9 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 import org.junit.Before;
@@ -24,10 +25,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 28)
 public class LruBitmapPoolTest {
   private static final int MAX_SIZE = 10;
   private static final Set<Bitmap.Config> ALLOWED_CONFIGS =
@@ -64,12 +64,13 @@ public void testItIsSizeLimited() {
 
   @Test
   public void testBitmapLargerThanPoolIsNotAdded() {
-    strategy = new MockStrategy() {
-      @Override
-      public int getSize(Bitmap bitmap) {
-        return 4;
-      }
-    };
+    strategy =
+        new MockStrategy() {
+          @Override
+          public int getSize(Bitmap bitmap) {
+            return 4;
+          }
+        };
     pool = new LruBitmapPool(3, strategy, ALLOWED_CONFIGS);
     pool.put(createMutableBitmap());
     assertEquals(0, strategy.numRemoves);
@@ -88,9 +89,7 @@ public void testClearMemoryRemovesAllBitmaps() {
   public void testEvictedBitmapsAreRecycled() {
     fillPool(pool, MAX_SIZE);
     List<Bitmap> bitmaps = new ArrayList<>(MAX_SIZE);
-    for (Bitmap b : strategy.bitmaps) {
-      bitmaps.add(b);
-    }
+    bitmaps.addAll(strategy.bitmaps);
 
     pool.clearMemory();
 
@@ -104,6 +103,11 @@ public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {
     testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
   }
 
+  @Test
+  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);
+  }
+
   @Test
   public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
     testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);
@@ -111,7 +115,7 @@ public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull()
 
   @Test
   public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {
-    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {
+    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
       testTrimMemory(MAX_SIZE, trimLevel, MAX_SIZE);
     }
   }
@@ -140,6 +144,18 @@ public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetD
     assertEquals(expected, result);
   }
 
+  @Test
+  public void get_withNullConfig_andEmptyPool_returnsNewArgb8888Bitmap() {
+    Bitmap result = pool.get(100, 100, /*config=*/ null);
+    assertThat(result.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void getDirty_withNullConfig_andEmptyPool_returnsNewArgb8888Bitmap() {
+    Bitmap result = pool.getDirty(100, 100, /*config=*/ null);
+    assertThat(result.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
   private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
     MockStrategy strategy = new MockStrategy();
     LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);
@@ -176,7 +192,7 @@ public void testCanResetSizeDynamically() {
 
     pool.setSizeMultiplier(1);
 
-    assertEquals(Math.round(MAX_SIZE * sizeMultiplier) - MAX_SIZE, strategy.numRemoves);
+    assertEquals(MAX_SIZE * sizeMultiplier - MAX_SIZE, strategy.numRemoves);
   }
 
   @Test
@@ -201,11 +217,12 @@ public void testBitmapsWithDisallowedConfigsAreIgnored() {
   }
 
   @Test
+  @Config(sdk = 19)
   public void testBitmapsWithAllowedNullConfigsAreAllowed() {
     pool = new LruBitmapPool(100, strategy, Collections.<Bitmap.Config>singleton(null));
 
     Bitmap bitmap = createMutableBitmap();
-    Shadows.shadowOf(bitmap).setConfig(null);
+    bitmap.setConfig(null);
 
     pool.put(bitmap);
 
@@ -223,14 +240,13 @@ private Bitmap createMutableBitmap() {
   }
 
   private Bitmap createMutableBitmap(Bitmap.Config config) {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, config);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, config);
     Shadows.shadowOf(bitmap).setMutable(true);
     return bitmap;
-
   }
 
   private static class MockStrategy implements LruPoolStrategy {
-    private LinkedList<Bitmap> bitmaps = new LinkedList<>();
+    private final ArrayDeque<Bitmap> bitmaps = new ArrayDeque<>();
     private int numRemoves;
     private int numPuts;
 
@@ -242,7 +258,7 @@ public void put(Bitmap bitmap) {
 
     @Override
     public Bitmap get(int width, int height, Bitmap.Config config) {
-      return bitmaps.removeLast();
+      return bitmaps.isEmpty() ? null : bitmaps.removeLast();
     }
 
     @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
new file mode 100644
index 000000000..ddfd6d4ab
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.graphics.Bitmap;
+import com.google.common.testing.EqualsTester;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class SizeConfigStrategyTest {
+
+  @Mock private SizeConfigStrategy.KeyPool pool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testKeyEquals() {
+    new EqualsTester()
+        .addEqualityGroup(
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, null /*config*/))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
new file mode 100644
index 000000000..f1f144899
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -0,0 +1,173 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.mock;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.tests.Util;
+import java.io.File;
+import java.io.IOException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class DiskLruCacheWrapperTest {
+  private DiskCache cache;
+  private byte[] data;
+  private ObjectKey key;
+  private File dir;
+
+  @Before
+  public void setUp() {
+    dir = RuntimeEnvironment.application.getCacheDir();
+    cache = DiskLruCacheWrapper.create(dir, 10 * 1024 * 1024);
+    key = new ObjectKey("test" + Math.random());
+    data = new byte[] {1, 2, 3, 4, 5, 6};
+  }
+
+  @After
+  public void tearDown() {
+    try {
+      cache.clear();
+    } finally {
+      deleteRecursive(dir);
+    }
+  }
+
+  private static void deleteRecursive(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursive(f);
+        }
+      }
+    }
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+
+  @Test
+  public void testCanInsertAndGet() throws IOException {
+    cache.put(
+        key,
+        new DiskCache.Writer() {
+          @Override
+          public boolean write(@NonNull File file) {
+            try {
+              Util.writeFile(file, data);
+            } catch (IOException e) {
+              fail(e.toString());
+            }
+            return true;
+          }
+        });
+
+    byte[] received = Util.readFile(cache.get(key), data.length);
+
+    assertArrayEquals(data, received);
+  }
+
+  @Test
+  public void testDoesNotCommitIfWriterReturnsFalse() {
+    cache.put(
+        key,
+        new DiskCache.Writer() {
+          @Override
+          public boolean write(@NonNull File file) {
+            return false;
+          }
+        });
+
+    assertNull(cache.get(key));
+  }
+
+  @Test
+  public void testDoesNotCommitIfWriterWritesButReturnsFalse() {
+    cache.put(
+        key,
+        new DiskCache.Writer() {
+          @Override
+          public boolean write(@NonNull File file) {
+            try {
+              Util.writeFile(file, data);
+            } catch (IOException e) {
+              fail(e.toString());
+            }
+            return false;
+          }
+        });
+
+    assertNull(cache.get(key));
+  }
+
+  @Test
+  public void testEditIsAbortedIfWriterThrows() throws IOException {
+    try {
+      cache.put(
+          key,
+          new DiskCache.Writer() {
+            @Override
+            public boolean write(@NonNull File file) {
+              throw new RuntimeException("test");
+            }
+          });
+    } catch (RuntimeException e) {
+      // Expected.
+    }
+
+    cache.put(
+        key,
+        new DiskCache.Writer() {
+          @Override
+          public boolean write(@NonNull File file) {
+            try {
+              Util.writeFile(file, data);
+            } catch (IOException e) {
+              fail(e.toString());
+            }
+            return true;
+          }
+        });
+
+    byte[] received = Util.readFile(cache.get(key), data.length);
+
+    assertArrayEquals(data, received);
+  }
+
+  // Tests #2465.
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    assumeTrue("A file handle is likely open, so cannot delete dir", !Util.isWindows());
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+  }
+
+  // Tests #2465.
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    assumeTrue("A file handle is likely open, so cannot delete dir", !Util.isWindows());
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
index 3e3451e81..021e965fb 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyObject;
 import static org.mockito.Matchers.eq;
@@ -13,6 +14,8 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.util.LruCache;
 import org.junit.Before;
 import org.junit.Test;
@@ -28,7 +31,7 @@
   private String currentKey;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     currentKey = "";
     listener = mock(CacheListener.class);
     cache = new TestLruCache(SIZE, listener);
@@ -60,14 +63,15 @@ public void testCanPutNullItemWithoutChangingSize() {
   @Test
   public void testReplacingNonNullItemWithNullItemDecreasesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, null);
 
     for (int i = 0; i < SIZE; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener, never()).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
   }
 
   @Test
@@ -86,14 +90,16 @@ public void testReplacingNullItemWIthNullItemIncreasesSize() {
   @Test
   public void testReplacingNonNullItemWithNonNullItemUpdatesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, new Object());
 
-    for (int i = 0; i < SIZE; i++) {
+    for (int i = 0; i < SIZE - 1; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
+    verify(listener, never()).onItemRemoved(not(eq(initialValue)));
   }
 
   @Test
@@ -191,6 +197,34 @@ public void testCanPutSameItemMultipleTimes() {
     verify(listener, never()).onItemRemoved(anyObject());
   }
 
+  @Test
+  public void put_withSameValueTwice_doesNotEvictItems() {
+    String key = getKey();
+    Object value = new Object();
+    cache.put(key, value);
+    cache.put(key, value);
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withExistingNullValue_doesNotNotifyListener() {
+    String key = getKey();
+    cache.put(key, /* item= */ null);
+    cache.put(key, new Object());
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withNullValue_withSizeGreaterThanMaximum_notifiesListener() {
+    String key = getKey();
+    when(listener.getSize(null)).thenReturn((int) (cache.getMaxSize() * 2));
+    cache.put(key, null);
+
+    verify(listener).onItemRemoved(anyObject());
+  }
+
   @Test
   public void testCanIncreaseSizeDynamically() {
     int sizeMultiplier = 2;
@@ -259,7 +293,7 @@ public void testDecreasesSizeWhenRemovesKey() {
     Object value = new Object();
     cache.put(key, value);
     for (int i = 0; i < SIZE - 1; i++) {
-      cache.put(key, value);
+      cache.put(getKey(), value);
     }
     cache.remove(key);
     cache.put(key, value);
@@ -326,26 +360,26 @@ private String getKey() {
   }
 
   private interface CacheListener {
-    public void onItemRemoved(Object item);
+    void onItemRemoved(Object item);
 
-    public int getSize(Object item);
+    int getSize(Object item);
   }
 
   private static class TestLruCache extends LruCache<String, Object> {
     private final CacheListener listener;
 
-    public TestLruCache(int size, CacheListener listener) {
+    TestLruCache(int size, CacheListener listener) {
       super(size);
       this.listener = listener;
     }
 
     @Override
-    protected void onItemEvicted(String key, Object item) {
+    protected void onItemEvicted(@NonNull String key, @Nullable Object item) {
       listener.onItemRemoved(item);
     }
 
     @Override
-    protected int getSize(Object item) {
+    protected int getSize(@Nullable Object item) {
       return listener.getSize(item);
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
new file mode 100644
index 000000000..447c6f755
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -0,0 +1,228 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.ComponentCallbacks2;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.LruCache;
+import java.security.MessageDigest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class LruResourceCacheTest {
+
+  @Test
+  public void put_withExistingItem_updatesSizeCorrectly() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.getCurrentSize()).isEqualTo(harness.second.getSize());
+  }
+
+  @Test
+  public void put_withExistingItem_evictsExistingItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+  }
+
+  @Test
+  public void get_afterPutWithExistingItem_returnsNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.get(harness.key)).isEqualTo(harness.second);
+  }
+
+  @Test
+  public void onItemEvicted_withNullValue_doesNotNotifyListener() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.onItemEvicted(new MockKey(), null);
+    verify(harness.listener, never()).onResourceRemoved(anyResource());
+  }
+
+  @Test
+  public void clearMemory_afterPutWithExistingItem_evictsOnlyNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+
+    harness.cache.clearMemory();
+
+    verify(harness.listener, times(1)).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryBackground() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+
+    verify(harness.listener).onResourceRemoved(eq(harness.first));
+    verify(harness.listener).onResourceRemoved(eq(harness.second));
+  }
+
+  @Test
+  public void testTrimMemoryModerate() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryUiHidden() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryRunningCritical() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource<?> resource = mockResource();
+    when(resource.getSize()).thenReturn(200);
+
+    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    resourceCache.setResourceRemovedListener(listener);
+    resourceCache.put(new MockKey(), resource);
+
+    verify(listener).onResourceRemoved(eq(resource));
+  }
+
+  @Test
+  public void testSizeIsBasedOnResource() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource<?> first = getResource(50);
+    MockKey firstKey = new MockKey();
+    resourceCache.put(firstKey, first);
+    Resource<?> second = getResource(50);
+    MockKey secondKey = new MockKey();
+    resourceCache.put(secondKey, second);
+
+    assertTrue(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+
+    Resource<?> third = getResource(50);
+    MockKey thirdKey = new MockKey();
+    resourceCache.put(thirdKey, third);
+
+    assertFalse(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+    assertTrue(resourceCache.contains(thirdKey));
+  }
+
+  @Test
+  public void testPreventEviction() {
+    final MemoryCache cache = new LruResourceCache(100);
+    final Resource<?> first = getResource(30);
+    final Key firstKey = new MockKey();
+    cache.put(firstKey, first);
+    Resource<?> second = getResource(30);
+    Key secondKey = new MockKey();
+    cache.put(secondKey, second);
+    Resource<?> third = getResource(30);
+    Key thirdKey = new MockKey();
+    cache.put(thirdKey, third);
+    cache.setResourceRemovedListener(
+        new ResourceRemovedListener() {
+          @Override
+          public void onResourceRemoved(@NonNull Resource<?> removed) {
+            if (removed == first) {
+              cache.put(firstKey, first);
+            }
+          }
+        });
+
+    // trims from 100 to 50, having 30+30+30 items, it should trim to 1 item
+    cache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    // and that 1 item must be first, because it's forced to return to cache in the listener
+    @SuppressWarnings("unchecked")
+    LruCache<Key, Resource<?>> lruCache = (LruCache<Key, Resource<?>>) cache;
+    assertTrue(lruCache.contains(firstKey));
+    assertFalse(lruCache.contains(secondKey));
+    assertFalse(lruCache.contains(thirdKey));
+  }
+
+  private Resource<?> getResource(int size) {
+    Resource<?> resource = mockResource();
+    when(resource.getSize()).thenReturn(size);
+    return resource;
+  }
+
+  private static class MockKey implements Key {
+    @Override
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+      messageDigest.update(toString().getBytes(CHARSET));
+    }
+  }
+
+  private static class PutWithExistingEntryHarness {
+    final LruResourceCache cache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+    final Key key = new MockKey();
+
+    PutWithExistingEntryHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      cache.setResourceRemovedListener(listener);
+    }
+  }
+
+  private static class TrimClearMemoryCacheHarness {
+    final LruResourceCache resourceCache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    TrimClearMemoryCacheHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      resourceCache.put(new MockKey(), first);
+      resourceCache.put(new MockKey(), second);
+      resourceCache.setResourceRemovedListener(listener);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 98c4b8371..38adb5c56 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -24,7 +24,7 @@
 import org.robolectric.shadows.ShadowActivityManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 19, shadows = LowRamActivityManager.class)
+@Config(sdk = 19, shadows = LowRamActivityManager.class)
 public class MemorySizeCalculatorTest {
   private MemorySizeHarness harness;
   private int initialSdkVersion;
@@ -32,7 +32,6 @@
   @Before
   public void setUp() {
     initialSdkVersion = Build.VERSION.SDK_INT;
-    Util.setSdkVersionInt(18);
     harness = new MemorySizeHarness();
   }
 
@@ -69,8 +68,7 @@ public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
 
     float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
 
-    assertThat(memoryCacheSize)
-        .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
+    assertThat(memoryCacheSize).isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
   }
 
   @Test
@@ -107,9 +105,11 @@ public void testDefaultBitmapPoolSizeIsLimitedByMemoryClass() {
 
   @Test
   public void testCumulativePoolAndMemoryCacheSizeAreLimitedByMemoryClass() {
-    final int memoryClassBytes = Math.round(
-        harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens)
-            * harness.sizeMultiplier);
+    final int memoryClassBytes =
+        Math.round(
+            harness.getScreenSize()
+                * (harness.bitmapPoolScreens + harness.memoryCacheScreens)
+                * harness.sizeMultiplier);
     Shadows.shadowOf(harness.activityManager).setMemoryClass(memoryClassBytes / (1024 * 1024));
 
     int memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
@@ -138,11 +138,9 @@ public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices()
 
   @Test
   public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
-    LowRamActivityManager activityManager =
-        (LowRamActivityManager) Shadow.extract(harness.activityManager);
-    Util.setSdkVersionInt(19);
+    LowRamActivityManager activityManager = Shadow.extract(harness.activityManager);
     activityManager.setMemoryClass(getLargeEnoughMemoryClass());
-    activityManager.setIsLowRam(true);
+    activityManager.setIsLowRam();
 
     int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
@@ -159,18 +157,18 @@ private int getLargeEnoughMemoryClass() {
   }
 
   private static class MemorySizeHarness {
-    int pixelSize = 500;
-    int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
+    final int pixelSize = 500;
+    final int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
     float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;
     float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;
-    float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
+    final float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
     int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.ARRAY_POOL_SIZE_BYTES;
-    ActivityManager activityManager =
+    final ActivityManager activityManager =
         (ActivityManager) RuntimeEnvironment.application.getSystemService(Context.ACTIVITY_SERVICE);
-    MemorySizeCalculator.ScreenDimensions screenDimensions =
+    final MemorySizeCalculator.ScreenDimensions screenDimensions =
         mock(MemorySizeCalculator.ScreenDimensions.class);
 
-    public MemorySizeCalculator getCalculator() {
+    MemorySizeCalculator getCalculator() {
       when(screenDimensions.getWidthPixels()).thenReturn(pixelSize);
       when(screenDimensions.getHeightPixels()).thenReturn(pixelSize);
       return new MemorySizeCalculator.Builder(RuntimeEnvironment.application)
@@ -183,7 +181,7 @@ public MemorySizeCalculator getCalculator() {
           .build();
     }
 
-    public int getScreenSize() {
+    int getScreenSize() {
       return pixelSize * pixelSize * bytesPerPixel;
     }
   }
@@ -193,11 +191,12 @@ public int getScreenSize() {
 
     private boolean isLowRam;
 
-    void setIsLowRam(boolean isLowRam) {
-      this.isLowRam = isLowRam;
+    void setIsLowRam() {
+      this.isLowRam = true;
     }
 
     @Implementation
+    @Override
     public boolean isLowRamDevice() {
       return isLowRam;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
index 207ccaf9b..0510e3e62 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
@@ -2,6 +2,7 @@
 
 import static org.junit.Assert.assertTrue;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 import java.util.regex.Matcher;
@@ -13,13 +14,13 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class SafeKeyGeneratorTest {
   private SafeKeyGenerator keyGenerator;
   private int nextId;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     nextId = 0;
     keyGenerator = new SafeKeyGenerator();
   }
@@ -42,15 +43,15 @@ private String getNextId() {
     return String.valueOf(nextId++);
   }
 
-  private static class MockKey implements Key {
-    private String id;
+  private static final class MockKey implements Key {
+    private final String id;
 
-    public MockKey(String id) {
+    MockKey(String id) {
       this.id = id;
     }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
       messageDigest.update(id.getBytes(CHARSET));
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
similarity index 70%
rename from library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index fa9dba251..c9d9438ce 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -2,6 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import androidx.annotation.NonNull;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -12,7 +13,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class GlideExecutorTest {
 
   @Test
@@ -20,12 +21,15 @@ public void testLoadsAreExecutedInOrder() throws InterruptedException {
     final List<Integer> resultPriorities = Collections.synchronizedList(new ArrayList<Integer>());
     GlideExecutor executor = GlideExecutor.newDiskCacheExecutor();
     for (int i = 5; i > 0; i--) {
-      executor.execute(new MockRunnable(i, new MockRunnable.OnRun() {
-        @Override
-        public void onRun(int priority) {
-          resultPriorities.add(priority);
-        }
-      }));
+      executor.execute(
+          new MockRunnable(
+              i,
+              new MockRunnable.OnRun() {
+                @Override
+                public void onRun(int priority) {
+                  resultPriorities.add(priority);
+                }
+              }));
     }
 
     executor.shutdown();
@@ -36,21 +40,20 @@ public void onRun(int priority) {
     assertThat(resultPriorities).containsExactly(5, 1, 2, 3, 4).inOrder();
   }
 
-  private static class MockRunnable implements Runnable,
-      Comparable<MockRunnable> {
+  private static final class MockRunnable implements Runnable, Comparable<MockRunnable> {
     private final int priority;
     private final OnRun onRun;
 
     @Override
-    public int compareTo(MockRunnable another) {
+    public int compareTo(@NonNull MockRunnable another) {
       return priority - another.priority;
     }
 
-    public interface OnRun {
+    interface OnRun {
       void onRun(int priority);
     }
 
-    public MockRunnable(int priority, OnRun onRun) {
+    MockRunnable(int priority, OnRun onRun) {
       this.priority = priority;
       this.onRun = onRun;
     }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..ab35c4e64
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,110 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/** Creates mock {@link GlideExecutor}s. */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /** @deprecated Use {@link #newMainThreadExecutor} instead. */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder().detectNetwork().penaltyDeath().build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(
+          new Runnable() {
+            @Override
+            public void run() {
+              StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+              StrictMode.setThreadPolicy(THREAD_POLICY);
+              try {
+                command.run();
+              } finally {
+                StrictMode.setThreadPolicy(oldPolicy);
+              }
+            }
+          });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
similarity index 78%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index d00b03193..6bbaf090e 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -16,10 +16,13 @@
 
 import android.graphics.Bitmap;
 import android.os.Handler;
+import android.util.Log;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
@@ -37,15 +40,16 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapPreFillRunnerTest {
-  @Mock BitmapPreFillRunner.Clock clock;
-  @Mock BitmapPool pool;
-  @Mock MemoryCache cache;
-  @Mock Handler mainHandler;
-  private List<Bitmap> addedBitmaps = new ArrayList<>();
+  @Mock private BitmapPreFillRunner.Clock clock;
+  @Mock private BitmapPool pool;
+  @Mock private MemoryCache cache;
+  @Mock private Handler mainHandler;
+  private final List<Bitmap> addedBitmaps = new ArrayList<>();
 
   @Before
   public void setUp() {
@@ -59,8 +63,8 @@ public void setUp() {
   }
 
   private BitmapPreFillRunner getHandler(Map<PreFillType, Integer> allocationOrder) {
-    return new BitmapPreFillRunner(pool, cache, new PreFillQueue(allocationOrder), clock,
-        mainHandler);
+    return new BitmapPreFillRunner(
+        pool, cache, new PreFillQueue(allocationOrder), clock, mainHandler);
   }
 
   @Test
@@ -85,7 +89,9 @@ public void testAllocatesBitmapsInOrderGivenByAllocationOrder() {
         new PreFillType.Builder(100, 50).setConfig(Bitmap.Config.RGB_565).build();
 
     PreFillType[] expectedOrder =
-        new PreFillType[] { smallWidth, smallHeight, smallWidth, smallHeight, };
+        new PreFillType[] {
+          smallWidth, smallHeight, smallWidth, smallHeight,
+        };
 
     HashMap<PreFillType, Integer> allocationOrder = new HashMap<>();
     allocationOrder.put(smallWidth, 2);
@@ -156,14 +162,18 @@ public void testPreFillHandlerPostsWithBackoffIfHasBitmapsToAllocateAfterRunning
     handler.run();
     verify(mainHandler).postDelayed(eq(handler), eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS));
 
-    when(clock.now()).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS).thenReturn(
-        BitmapPreFillRunner.MAX_DURATION_MS
-            + BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO);
+    when(clock.now())
+        .thenReturn(BitmapPreFillRunner.MAX_DURATION_MS)
+        .thenReturn(
+            BitmapPreFillRunner.MAX_DURATION_MS
+                + BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO);
 
     handler.run();
 
-    verify(mainHandler).postDelayed(eq(handler),
-        eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO));
+    verify(mainHandler)
+        .postDelayed(
+            eq(handler),
+            eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO));
 
     when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
     handler.run();
@@ -195,10 +205,11 @@ public void testPreFillHandlerDoesNotPostIfHasBitmapsButIsCancelled() {
   @Test
   public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));
+    when(cache.getMaxSize()).thenReturn(Long.valueOf(Util.getBitmapByteSize(bitmap)));
 
     PreFillType size =
-        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+            .setConfig(bitmap.getConfig())
             .build();
     Map<PreFillType, Integer> allocationOrder = new HashMap<>();
     allocationOrder.put(size, 1);
@@ -214,10 +225,11 @@ public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
   @Test
   public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(0);
+    when(cache.getMaxSize()).thenReturn(0L);
 
     PreFillType size =
-        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+            .setConfig(bitmap.getConfig())
             .build();
     Map<PreFillType, Integer> allocationOrder = new HashMap<>();
     allocationOrder.put(size, 1);
@@ -233,10 +245,11 @@ public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
   @Test
   public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);
+    when(cache.getMaxSize()).thenReturn((long) Util.getBitmapByteSize(bitmap) / 2);
 
     PreFillType size =
-        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+            .setConfig(bitmap.getConfig())
             .build();
     Map<PreFillType, Integer> allocationOrder = new HashMap<>();
     allocationOrder.put(size, 1);
@@ -245,20 +258,22 @@ public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
 
     verify(cache, never()).put(any(Key.class), anyResource());
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
-    //verify(pool).put(eq(bitmap));
-    //assertThat(addedBitmaps).containsExactly(bitmap);
+    // verify(pool).put(eq(bitmap));
+    // assertThat(addedBitmaps).containsExactly(bitmap);
   }
 
   @Test
   public void testDoesAGetFromPoolBeforeAddingForEachSize() {
     Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     PreFillType firstSize =
-        new PreFillType.Builder(first.getWidth(), first.getHeight()).setConfig(first.getConfig())
+        new PreFillType.Builder(first.getWidth(), first.getHeight())
+            .setConfig(first.getConfig())
             .build();
 
     Bitmap second = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
     PreFillType secondSize =
-        new PreFillType.Builder(second.getWidth(), second.getHeight()).setConfig(second.getConfig())
+        new PreFillType.Builder(second.getWidth(), second.getHeight())
+            .setConfig(second.getConfig())
             .build();
 
     Map<PreFillType, Integer> allocationOrder = new HashMap<>();
@@ -268,13 +283,15 @@ public void testDoesAGetFromPoolBeforeAddingForEachSize() {
     getHandler(allocationOrder).run();
 
     InOrder firstOrder = inOrder(pool);
-    firstOrder.verify(pool).getDirty(eq(first.getWidth()), eq(first.getHeight()),
-        eq(first.getConfig()));
+    firstOrder
+        .verify(pool)
+        .getDirty(eq(first.getWidth()), eq(first.getHeight()), eq(first.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // firstOrder.verify(pool).put(eq(first));
 
     InOrder secondOrder = inOrder(pool);
-    secondOrder.verify(pool)
+    secondOrder
+        .verify(pool)
         .getDirty(eq(second.getWidth()), eq(second.getHeight()), eq(second.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // secondOrder.verify(pool).put(eq(second));
@@ -284,7 +301,8 @@ public void testDoesAGetFromPoolBeforeAddingForEachSize() {
   public void testDoesNotGetMoreThanOncePerSize() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     PreFillType size =
-        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+            .setConfig(bitmap.getConfig())
             .build();
 
     final int numBitmaps = 5;
@@ -294,16 +312,35 @@ public void testDoesNotGetMoreThanOncePerSize() {
     getHandler(allocationOrder).run();
 
     InOrder order = inOrder(pool);
-    order.verify(pool).getDirty(eq(bitmap.getWidth()), eq(bitmap.getHeight()),
-        eq(bitmap.getConfig()));
+    order
+        .verify(pool)
+        .getDirty(eq(bitmap.getWidth()), eq(bitmap.getHeight()), eq(bitmap.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // order.verify(pool, times(numBitmaps)).put(eq(bitmap));
   }
 
-  private static class AddBitmapPoolAnswer implements Answer<Void> {
-    private List<Bitmap> bitmaps;
+  @Test
+  public void allocate_whenBitmapPoolIsAtCapacity_doesNotLogWithRecycledBitmap() {
+    ShadowLog.setLoggable(BitmapPreFillRunner.TAG, Log.VERBOSE);
+
+    int dimensions = 10;
+    Bitmap.Config config = Bitmap.Config.ARGB_8888;
+    int bitmapByteSize = Util.getBitmapByteSize(dimensions, dimensions, config);
+    PreFillType preFillType = new PreFillType.Builder(dimensions).setConfig(config).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(preFillType, 1);
+    PreFillQueue queue = new PreFillQueue(allocationOrder);
+    BitmapPreFillRunner runner =
+        new BitmapPreFillRunner(
+            new LruBitmapPool(bitmapByteSize - 1), new MemoryCacheAdapter(), queue);
+
+    runner.allocate();
+  }
+
+  private static final class AddBitmapPoolAnswer implements Answer<Void> {
+    private final List<Bitmap> bitmaps;
 
-    public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
+    AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
       this.bitmaps = bitmaps;
     }
 
@@ -315,10 +352,10 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
   }
 
-  private static class AddBitmapCacheAnswer implements Answer<Resource<?>> {
-    private List<Bitmap> bitmaps;
+  private static final class AddBitmapCacheAnswer implements Answer<Resource<?>> {
+    private final List<Bitmap> bitmaps;
 
-    public AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
+    AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
       this.bitmaps = bitmaps;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
similarity index 68%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
index 539cefa65..2c5f4062f 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -30,7 +30,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapPreFillerTest {
   private static final int DEFAULT_BITMAP_WIDTH = 100;
   private static final int DEFAULT_BITMAP_HEIGHT = 50;
@@ -41,12 +41,12 @@
   private final Bitmap.Config defaultBitmapConfig = PreFillType.DEFAULT_CONFIG;
   private final Bitmap defaultBitmap =
       Bitmap.createBitmap(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT, defaultBitmapConfig);
-  private final int defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
-  private final int poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
-  private final int cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
+  private final long defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
+  private final long poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
+  private final long cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
 
-  @Mock BitmapPool pool;
-  @Mock MemoryCache cache;
+  @Mock private BitmapPool pool;
+  @Mock private MemoryCache cache;
   private BitmapPreFiller bitmapPreFiller;
 
   @Before
@@ -62,22 +62,29 @@ public void setUp() {
 
   @Test
   public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build() });
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     assertEquals(BITMAPS_IN_POOL + BITMAPS_IN_CACHE, allocationOrder.getSize());
   }
 
   @Test
   public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
-    PreFillType[] sizes = new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build(), };
+    PreFillType[] sizes =
+        new PreFillType[] {
+          new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+              .setConfig(defaultBitmapConfig)
+              .build(),
+          new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+              .setConfig(defaultBitmapConfig)
+              .build(),
+          new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+              .setConfig(defaultBitmapConfig)
+              .build(),
+        };
     PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(sizes);
 
     int byteSize = 0;
@@ -88,11 +95,12 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
     }
 
     int expectedSize = 0;
-    int maxSize = poolSize + cacheSize;
+    long maxSize = poolSize + cacheSize;
     for (PreFillType current : sizes) {
       int currentSize =
           Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-      expectedSize += currentSize * (maxSize / (3 * currentSize));
+      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      expectedSize = (int) (expectedSize + (currentSize * (maxSize / (3 * currentSize))));
     }
 
     assertEquals(expectedSize, byteSize);
@@ -100,15 +108,19 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build() });
-
-    int byteSize = 0;
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build(),
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build(),
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+                .setConfig(defaultBitmapConfig)
+                .build());
+
+    long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
       PreFillType current = allocationOrder.remove();
       byteSize +=
@@ -120,15 +132,21 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).setWeight(4).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
-            .setConfig(defaultBitmapConfig).setWeight(3).build() });
-
-    int byteSize = 0;
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .setWeight(4)
+                .build(),
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build(),
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
+                .setConfig(defaultBitmapConfig)
+                .setWeight(3)
+                .build());
+
+    long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
       PreFillType current = allocationOrder.remove();
       byteSize +=
@@ -140,9 +158,11 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
 
   @Test
   public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build() });
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     while (!allocationOrder.isEmpty()) {
       PreFillType size = allocationOrder.remove();
@@ -156,12 +176,13 @@ public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
   public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
     PreFillType smallWidth =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build();
+            .setConfig(defaultBitmapConfig)
+            .build();
     PreFillType smallHeight =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+            .setConfig(defaultBitmapConfig)
+            .build();
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     int numSmallWidth = 0, numSmallHeight = 0;
     while (!allocationOrder.isEmpty()) {
@@ -182,11 +203,13 @@ public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
   public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualWeights() {
     PreFillType smallWidth =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build();
-    PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-        .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, normal });
+            .setConfig(defaultBitmapConfig)
+            .build();
+    PreFillType normal =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig)
+            .build();
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, normal);
 
     int numSmallWidth = 0, numNormal = 0;
     while (!allocationOrder.isEmpty()) {
@@ -207,11 +230,14 @@ public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualW
   public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequalWeights() {
     PreFillType doubleWeight =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).setWeight(2).build();
-    PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-        .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { doubleWeight, normal });
+            .setConfig(defaultBitmapConfig)
+            .setWeight(2)
+            .build();
+    PreFillType normal =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+            .setConfig(defaultBitmapConfig)
+            .build();
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(doubleWeight, normal);
 
     int numDoubleWeight = 0, numNormal = 0;
     while (!allocationOrder.isEmpty()) {
@@ -234,13 +260,14 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
     when(cache.getMaxSize()).thenReturn(defaultBitmapSize);
     PreFillType smallWidth =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build();
+            .setConfig(defaultBitmapConfig)
+            .build();
     PreFillType smallHeight =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build();
+            .setConfig(defaultBitmapConfig)
+            .build();
 
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     List<PreFillType> attributes = new ArrayList<>();
     while (!allocationOrder.isEmpty()) {
@@ -249,10 +276,12 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
 
     // Either width, height, width, height or height, width, height, width.
     try {
-      assertThat(attributes).containsExactly(smallWidth, smallHeight, smallWidth, smallHeight)
+      assertThat(attributes)
+          .containsExactly(smallWidth, smallHeight, smallWidth, smallHeight)
           .inOrder();
     } catch (AssertionError e) {
-      assertThat(attributes).containsExactly(smallHeight, smallWidth, smallHeight, smallWidth)
+      assertThat(attributes)
+          .containsExactly(smallHeight, smallWidth, smallHeight, smallWidth)
           .inOrder();
     }
   }
@@ -267,9 +296,12 @@ public void testSetsConfigOnBuildersToDefaultIfNotSet() {
     bitmapPreFiller.preFill(builder);
 
     InOrder order = inOrder(builder);
-    order.verify(builder).setConfig(DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
-        || DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
+    order
+        .verify(builder)
+        .setConfig(
+            DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
+                ? Bitmap.Config.ARGB_8888
+                : Bitmap.Config.RGB_565);
     order.verify(builder).build();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
index bd14089f4..f3e6acb4d 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
@@ -10,7 +10,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class PreFillTypeTest {
 
   @Test(expected = IllegalArgumentException.class)
@@ -64,11 +64,14 @@ public void testGetWeightReturnsGivenWeight() {
 
   @Test
   public void testEquality() {
-    new EqualsTester().addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1),
-        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1))
+    new EqualsTester()
+        .addEqualityGroup(
+            new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1),
+            new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1))
         .addEqualityGroup(new PreFillType(200, 100, Bitmap.Config.ARGB_4444, 1))
         .addEqualityGroup(new PreFillType(100, 200, Bitmap.Config.ARGB_4444, 1))
         .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_8888, 1))
-        .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 2)).testEquals();
+        .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 2))
+        .testEquals();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
similarity index 77%
rename from library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
index 1dd269502..89798e10e 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
@@ -10,6 +10,7 @@
 import android.net.Uri;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,12 +21,12 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class AssetUriLoaderTest {
   private static final int IMAGE_SIDE = 10;
 
-  @Mock AssetUriLoader.AssetFetcherFactory<Object> factory;
-  @Mock DataFetcher<Object> fetcher;
+  @Mock private AssetUriLoader.AssetFetcherFactory<Object> factory;
+  @Mock private DataFetcher<Object> fetcher;
   private AssetUriLoader<Object> loader;
 
   @Before
@@ -39,7 +40,10 @@ public void testHandlesAssetUris() {
     Uri assetUri = Uri.parse("file:///android_asset/assetName");
     when(factory.buildFetcher(any(AssetManager.class), eq("assetName"))).thenReturn(fetcher);
     assertTrue(loader.handles(assetUri));
-    assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,
-        new Options()).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+                loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE, new Options()))
+            .fetcher);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
similarity index 67%
rename from library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
index e17ecc6b9..2fe39587a 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,8 +21,8 @@
 @RunWith(JUnit4.class)
 public class ByteArrayLoaderTest {
 
-  @Mock ByteArrayLoader.Converter<Object> converter;
-  @Mock DataFetcher.DataCallback<Object> callback;
+  @Mock private ByteArrayLoader.Converter<Object> converter;
+  @Mock private DataFetcher.DataCallback<Object> callback;
   private ByteArrayLoader<Object> loader;
   private Options options;
 
@@ -35,24 +36,30 @@ public void setUp() {
   @Test
   public void testCanHandleByteArray() {
     byte[] data = new byte[10];
-    DataFetcher<Object> fetcher = loader.buildLoadData(data, -1, -1, options).fetcher;
+    DataFetcher<Object> fetcher =
+        Preconditions.checkNotNull(loader.buildLoadData(data, -1, -1, options)).fetcher;
     assertNotNull(fetcher);
   }
 
   @Test
   public void testFetcherReturnsObjectReceivedFromConverter() throws IOException {
-    byte[] data = "fake".getBytes();
+    byte[] data = "fake".getBytes("UTF-8");
     Object expected = new Object();
     when(converter.convert(eq(data))).thenReturn(expected);
 
-    loader.buildLoadData(data, 10, 10, options).fetcher.loadData(Priority.HIGH, callback);
+    Preconditions.checkNotNull(loader.buildLoadData(data, 10, 10, options))
+        .fetcher
+        .loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(eq(expected));
   }
 
   @Test
   public void testFetcherReturnsDataClassFromConverter() {
     when(converter.getDataClass()).thenReturn(Object.class);
-    assertEquals(Object.class,
-        loader.buildLoadData(new byte[10], 10, 10, options).fetcher.getDataClass());
+    assertEquals(
+        Object.class,
+        Preconditions.checkNotNull(loader.buildLoadData(new byte[10], 10, 10, options))
+            .fetcher
+            .getDataClass());
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
similarity index 60%
rename from library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
index 6665f0720..7c2678d43 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -6,8 +6,9 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
-import android.support.annotation.Nullable;
 import android.util.Base64;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -23,29 +24,28 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for the {@link DataUrlLoader} class.
- */
+/** Tests for the {@link DataUrlLoader} class. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class DataUrlLoaderTest {
 
   // A valid base64-encoded PNG (a small "Google" logo).
   @SuppressWarnings("SpellCheckingInspection")
-  private static final String VALID_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCA"
-      + "YAAAAeEY8BAAADFElEQVR42mNgAAK5ig+CiiUfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtC"
-      + "mTHkFfO/iCsUfTykUPFeASH6n1Es+3WjSM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n"
-      + "8Gxv/7pTT+75PQBrFh4iq5b/lk8z+aiue+tZDKeaPBMC8qh2leFNgB/xkYGO+Eu+ncCnZRAiuWyHv3VDzngxMui0EW"
-      + "Pgpx6n4U4Wx7J8De86aP2blrrgaq//fwCv8/KNT//5CU0f99okn/dwse+b9fQECx9IObQvGHMrn8D66See9eiWa9s2"
-      + "GYE57DMCdi6Qs3N+6HIc4T70a4mtz2t55909u0jkE85+1Tsdx30ciWSuQ+F+VPe6kskPFc4Z6XRcp9H8t2mNxVF72G"
-      + "q066K//vZe//v4cDru//ds7V/7dx1MoXf9gtW/zRFGLO+x7x7DeVDDOBDpgZvvSut3nWXR/LyptuxgG33Axzr7rr2T"
-      + "KIZb1eIpL1ejco3mGGCWe8cRJMf7FVKO1F/y1Xww4gng6Tu+Ko7X7JTvPo/52Mm//vYMqBO2AbU/H/LUwzpQreT5LO"
-      + "f98PEhPLftslkfvGjGF6aA4QL73halh7y9XgwHVnM2G4b0G+FM549Uw440U7Q+h/eCoVSH0+GYjrrjrr2V530n16w1"
-      + "qdFyR+wUYr6YKNRtH/7QzpQHzsfwMDE9gBmxl6/29hcNdu+M8G9HmCWM7bQ6I5bxPBhk0NzmGYErT0mpOe0TVHnY+X"
-      + "HXRMQMKrQhkg9omkvZYUSHvZJ5T+Yh3IUoHUZ/mCqc87BdOe2UB9HXzZQWvCeTuNqPO2GgmghAROgFsZ8oCWtgBxDN"
-      + "ABASC1olmveEQyX/sB8SKRzJcPgbQxw0S/IoaJvksZJvsqXnLQDLhoq7n7nI3GxHOWWs4M1AQ8ic9FhdNf7ZRKeyYC"
-      + "jsrUly7AqDzOQC8glP7SFWjhCVhUKiTc5xBIebaAbg4AWcyf+qxNMPXZKoGU57UCqU+KQKGCTwsAbxBBmvLaD+cAAA"
-      + "AASUVORK5CYII=";
+  private static final String VALID_PNG =
+      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCAYAAAAeEY8BAAADFElEQVR42mNgAAK5ig+Cii"
+          + "UfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtCmTHkFfO/iCsUfTykUPFeASH6n1Es+3Wj"
+          + "SM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n8Gxv/7pTT+75PQBrFh4iq5b/lk8z"
+          + "+aiue+tZDKeaPBMC8qh2leFNgB/xkYGO+Eu+ncCnZRAiuWyHv3VDzngxMui0EWPgpx6n4U4Wx7J8De86aP2blr"
+          + "rgaq//fwCv8/KNT//5CU0f99okn/dwse+b9fQECx9IObQvGHMrn8D66See9eiWa9s2GYE57DMCdi6Qs3N+6HIc"
+          + "4T70a4mtz2t55909u0jkE85+1Tsdx30ciWSuQ+F+VPe6kskPFc4Z6XRcp9H8t2mNxVF72Gq066K//vZe//v4cD"
+          + "ru//ds7V/7dx1MoXf9gtW/zRFGLO+x7x7DeVDDOBDpgZvvSut3nWXR/LyptuxgG33Axzr7rr2TKIZb1eIpL1ej"
+          + "co3mGGCWe8cRJMf7FVKO1F/y1Xww4gng6Tu+Ko7X7JTvPo/52Mm//vYMqBO2AbU/H/LUwzpQreT5LOf98PEhPL"
+          + "ftslkfvGjGF6aA4QL73halh7y9XgwHVnM2G4b0G+FM549Uw440U7Q+h/eCoVSH0+GYjrrjrr2V530n16w1qdFy"
+          + "R+wUYr6YKNRtH/7QzpQHzsfwMDE9gBmxl6/29hcNdu+M8G9HmCWM7bQ6I5bxPBhk0NzmGYErT0mpOe0TVHnY+X"
+          + "HXRMQMKrQhkg9omkvZYUSHvZJ5T+Yh3IUoHUZ/mCqc87BdOe2UB9HXzZQWvCeTuNqPO2GgmghAROgFsZ8oCWtg"
+          + "BxDNABASC1olmveEQyX/sB8SKRzJcPgbQxw0S/IoaJvksZJvsqXnLQDLhoq7n7nI3GxHOWWs4M1AQ8ic9FhdNf"
+          + "7ZRKeyYCjsrUly7AqDzOQC8glP7SFWjhCVhUKiTc5xBIebaAbg4AWcyf+qxNMPXZKoGU57UCqU+KQKGCTwsAbx"
+          + "BBmvLaD+cAAAAASUVORK5CYII=";
 
   private static final String INVALID_URL_WRONG_SCHEME1 = "test";
   private static final String INVALID_URL_WRONG_SCHEME2 = "http://google.com";
@@ -53,20 +53,18 @@
   private static final String INVALID_URL_MISSING_COMMA = "data:image/png;base64=NOT_BASE64";
   private static final String INVALID_URL_WRONG_ENCODING = "data:image/png;base32,";
 
-  @Mock
-  private MultiModelLoaderFactory multiFactory;
-  private DataUrlLoader<InputStream> dataUrlLoader;
+  @Mock private MultiModelLoaderFactory multiFactory;
+  private DataUrlLoader<String, InputStream> dataUrlLoader;
   private DataFetcher<InputStream> fetcher;
   private Options options;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
-    DataUrlLoader.StreamFactory factory = new DataUrlLoader.StreamFactory();
+    DataUrlLoader.StreamFactory<String> factory = new DataUrlLoader.StreamFactory<>();
     options = new Options();
-    dataUrlLoader = (DataUrlLoader<InputStream>) factory.build(multiFactory);
+    dataUrlLoader = (DataUrlLoader<String, InputStream>) factory.build(multiFactory);
     fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
-
   }
 
   @Test
@@ -83,8 +81,8 @@ public void testHandleFalseDataUri() {
 
   @Test
   public void testDecode() throws IOException {
-    byte[] expected = Base64
-        .decode(VALID_PNG.substring(VALID_PNG.indexOf(',') + 1), Base64.DEFAULT);
+    byte[] expected =
+        Base64.decode(VALID_PNG.substring(VALID_PNG.indexOf(',') + 1), Base64.DEFAULT);
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
     byte[] result = new byte[((ByteArrayInputStream) callback.data).available()];
@@ -94,7 +92,7 @@ public void testDecode() throws IOException {
   }
 
   @Test
-  public void testDecodeInvalidScheme() throws IOException {
+  public void testDecodeInvalidScheme() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_SCHEME1, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
@@ -102,7 +100,7 @@ public void testDecodeInvalidScheme() throws IOException {
   }
 
   @Test
-  public void testDecodeMissingComma() throws IOException {
+  public void testDecodeMissingComma() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_MISSING_COMMA, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
@@ -110,14 +108,14 @@ public void testDecodeMissingComma() throws IOException {
   }
 
   @Test
-  public void testDecodeWrongEncoding() throws IOException {
+  public void testDecodeWrongEncoding() {
     fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_ENCODING, -1, -1, options).fetcher;
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
     assertNotNull(callback.exception);
   }
 
-  private class CallBack implements DataFetcher.DataCallback<Object> {
+  private static final class CallBack implements DataFetcher.DataCallback<Object> {
 
     public Object data;
     public Exception exception;
@@ -128,7 +126,7 @@ public void onDataReady(@Nullable Object data) {
     }
 
     @Override
-    public void onLoadFailed(Exception e) {
+    public void onLoadFailed(@NonNull Exception e) {
       this.exception = e;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
similarity index 73%
rename from library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
index 2548b0e59..12892f9c4 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 
@@ -12,7 +13,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class GlideUrlTest {
 
   @Test(expected = NullPointerException.class)
@@ -68,11 +69,13 @@ public void testProducesEquivalentStringFromURL() throws MalformedURLException {
   @Test
   public void testIssue133() throws MalformedURLException {
     // u00e0=à
-    final String original = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
-        + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";
+    final String original =
+        "http://www.commitstrip.com/wp-content/uploads/2014/07/"
+            + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";
 
-    final String escaped = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
-        + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";
+    final String escaped =
+        "http://www.commitstrip.com/wp-content/uploads/2014/07/"
+            + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";
 
     GlideUrl glideUrlFromString = new GlideUrl(original);
     assertEquals(escaped, glideUrlFromString.toURL().toString());
@@ -87,6 +90,16 @@ public void testIssue133() throws MalformedURLException {
     assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());
   }
 
+  @Test
+  public void issue_2583() throws MalformedURLException {
+    String original =
+        "http://api.met.no/weatherapi/weathericon/1.1/?symbol=9;content_type=image/png";
+
+    GlideUrl glideUrl = new GlideUrl(original);
+    assertThat(glideUrl.toURL().toString()).isEqualTo(original);
+    assertThat(glideUrl.toStringUrl()).isEqualTo(original);
+  }
+
   @Test
   public void testEquals() throws MalformedURLException {
     Headers headers = mock(Headers.class);
@@ -98,19 +111,10 @@ public void testEquals() throws MalformedURLException {
             new GlideUrl(url),
             new GlideUrl(url),
             new GlideUrl(new URL(url)),
-            new GlideUrl(new URL(url))
-        )
-        .addEqualityGroup(
-            new GlideUrl(otherUrl),
-            new GlideUrl(new URL(otherUrl))
-        )
-        .addEqualityGroup(
-            new GlideUrl(url, headers),
-            new GlideUrl(new URL(url), headers)
-        )
-        .addEqualityGroup(
-            new GlideUrl(url, otherHeaders),
-            new GlideUrl(new URL(url), otherHeaders)
-        ).testEquals();
+            new GlideUrl(new URL(url)))
+        .addEqualityGroup(new GlideUrl(otherUrl), new GlideUrl(new URL(otherUrl)))
+        .addEqualityGroup(new GlideUrl(url, headers), new GlideUrl(new URL(url), headers))
+        .addEqualityGroup(new GlideUrl(url, otherHeaders), new GlideUrl(new URL(url), otherHeaders))
+        .testEquals();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
similarity index 78%
rename from library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index b0e2d1402..db2de337f 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -4,7 +4,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.model.LazyHeaders.Builder;
 import com.google.common.testing.EqualsTester;
 import java.util.Map;
@@ -16,7 +16,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class LazyHeadersTest {
   private static final String DEFAULT_USER_AGENT = "default_user_agent";
   private static final String DEFAULT_USER_AGENT_PROPERTY = "http.agent";
@@ -38,8 +38,7 @@ public void tearDown() {
   // Tests for #2331.
   @Test
   public void getSanitizedUserAgent_withInvalidAgent_returnsAgentWithInvalidCharactersRemoved() {
-    String invalidUserAgent =
-        "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G八核版(A8H8) Build/LRX21M)";
+    String invalidUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G八核版(A8H8) Build/LRX21M)";
     String validUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G???(A8H8) Build/LRX21M)";
     System.setProperty(DEFAULT_USER_AGENT_PROPERTY, invalidUserAgent);
     assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(validUserAgent);
@@ -74,10 +73,7 @@ public void getSanitizedUserAgent_withWhitespace_returnsWhitespaceString() {
 
   @Test
   public void testIncludesEagerHeaders() {
-    Map<String, String> headers = new Builder()
-        .addHeader("key", "value")
-        .build()
-        .getHeaders();
+    Map<String, String> headers = new Builder().addHeader("key", "value").build().getHeaders();
     assertThat(headers).containsEntry("key", "value");
   }
 
@@ -85,21 +81,15 @@ public void testIncludesEagerHeaders() {
   public void testIncludesLazyHeaders() {
     LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
     when(factory.buildHeader()).thenReturn("value");
-    Map<String, String> headers = new Builder()
-        .addHeader("key", factory)
-        .build()
-        .getHeaders();
+    Map<String, String> headers = new Builder().addHeader("key", factory).build().getHeaders();
 
     assertThat(headers).containsEntry("key", "value");
   }
 
   @Test
   public void testMultipleEagerValuesAreSeparatedByCommas() {
-    Map<String, String> headers = new Builder()
-        .addHeader("key", "first")
-        .addHeader("key", "second")
-        .build()
-        .getHeaders();
+    Map<String, String> headers =
+        new Builder().addHeader("key", "first").addHeader("key", "second").build().getHeaders();
 
     assertThat(headers).containsEntry("key", "first,second");
   }
@@ -111,11 +101,8 @@ public void testMultipleLazyValuesAreSeparatedByCommas() {
     LazyHeaderFactory second = mock(LazyHeaderFactory.class);
     when(second.buildHeader()).thenReturn("second");
 
-    Map<String, String> headers = new Builder()
-        .addHeader("key", first)
-        .addHeader("key", second)
-        .build()
-        .getHeaders();
+    Map<String, String> headers =
+        new Builder().addHeader("key", first).addHeader("key", second).build().getHeaders();
     assertThat(headers).containsEntry("key", "first,second");
   }
 
@@ -123,19 +110,13 @@ public void testMultipleLazyValuesAreSeparatedByCommas() {
   public void testMixedEagerAndLazyValuesAreIncluded() {
     LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
     when(factory.buildHeader()).thenReturn("first");
-    Map<String, String> headers = new Builder()
-        .addHeader("key", factory)
-        .addHeader("key", "second")
-        .build()
-        .getHeaders();
+    Map<String, String> headers =
+        new Builder().addHeader("key", factory).addHeader("key", "second").build().getHeaders();
 
     assertThat(headers).containsEntry("key", "first,second");
 
-    headers = new Builder()
-        .addHeader("key", "second")
-        .addHeader("key", factory)
-        .build()
-        .getHeaders();
+    headers =
+        new Builder().addHeader("key", "second").addHeader("key", factory).build().getHeaders();
 
     assertThat(headers).containsEntry("key", "second,first");
   }
@@ -144,11 +125,8 @@ public void testMixedEagerAndLazyValuesAreIncluded() {
   public void testCanAddMultipleKeys() {
     LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
     when(factory.buildHeader()).thenReturn("lazy");
-    Map<String, String> headers = new Builder()
-        .addHeader("first", factory)
-        .addHeader("second", "eager")
-        .build()
-        .getHeaders();
+    Map<String, String> headers =
+        new Builder().addHeader("first", factory).addHeader("second", "eager").build().getHeaders();
 
     assertThat(headers).containsEntry("first", "lazy");
     assertThat(headers).containsEntry("second", "eager");
@@ -179,9 +157,7 @@ public void testUpdatingBuilderAfterBuildingDoesNotModifyOriginalHeaders() {
   @Test
   public void testSetHeaderReplacesExistingHeaders() {
     Builder builder = new Builder();
-    builder.addHeader("key", "first")
-        .addHeader("key", "second")
-        .setHeader("key", "third");
+    builder.addHeader("key", "first").addHeader("key", "second").setHeader("key", "third");
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).containsEntry("key", "third");
   }
@@ -189,9 +165,7 @@ public void testSetHeaderReplacesExistingHeaders() {
   @Test
   public void testSetHeaderWithNullStringRemovesExistingHeader() {
     Builder builder = new Builder();
-    builder.addHeader("key", "first")
-        .addHeader("key", "second")
-        .setHeader("key", (String) null);
+    builder.addHeader("key", "first").addHeader("key", "second").setHeader("key", (String) null);
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).doesNotContainKey("key");
   }
@@ -199,7 +173,8 @@ public void testSetHeaderWithNullStringRemovesExistingHeader() {
   @Test
   public void testSetHeaderWithNullLazyHeaderFactoryRemovesExistingHeader() {
     Builder builder = new Builder();
-    builder.addHeader("key", "first")
+    builder
+        .addHeader("key", "first")
         .addHeader("key", "second")
         .setHeader("key", (LazyHeaderFactory) null);
     LazyHeaders headers = builder.build();
@@ -267,13 +242,15 @@ public void testRemovingAndAddingUserAgentHeaderReplacesDefaultThenAppends() {
   @Test
   public void testKeyNotIncludedWithFactoryThatReturnsNullValue() {
     Builder builder = new Builder();
-    builder.setHeader("test", new LazyHeaderFactory() {
-      @Nullable
-      @Override
-      public String buildHeader() {
-        return null;
-      }
-    });
+    builder.setHeader(
+        "test",
+        new LazyHeaderFactory() {
+          @Nullable
+          @Override
+          public String buildHeader() {
+            return null;
+          }
+        });
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).doesNotContainKey("test");
   }
@@ -281,13 +258,15 @@ public String buildHeader() {
   @Test
   public void testKeyNotIncludedWithFactoryThatReturnsEmptyValue() {
     Builder builder = new Builder();
-    builder.setHeader("test", new LazyHeaderFactory() {
-      @Nullable
-      @Override
-      public String buildHeader() {
-        return "";
-      }
-    });
+    builder.setHeader(
+        "test",
+        new LazyHeaderFactory() {
+          @Nullable
+          @Override
+          public String buildHeader() {
+            return "";
+          }
+        });
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).doesNotContainKey("test");
   }
@@ -295,20 +274,24 @@ public String buildHeader() {
   @Test
   public void testKeyIncludedWithOneFactoryThatReturnsNullAndOneFactoryThatDoesNotReturnNull() {
     Builder builder = new Builder();
-    builder.addHeader("test", new LazyHeaderFactory() {
-      @Nullable
-      @Override
-      public String buildHeader() {
-        return null;
-      }
-    });
-    builder.addHeader("test", new LazyHeaderFactory() {
-      @Nullable
-      @Override
-      public String buildHeader() {
-        return "value";
-      }
-    });
+    builder.addHeader(
+        "test",
+        new LazyHeaderFactory() {
+          @Nullable
+          @Override
+          public String buildHeader() {
+            return null;
+          }
+        });
+    builder.addHeader(
+        "test",
+        new LazyHeaderFactory() {
+          @Nullable
+          @Override
+          public String buildHeader() {
+            return "value";
+          }
+        });
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).containsEntry("test", "value");
   }
@@ -318,27 +301,19 @@ public void testEquals() {
     LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
     LazyHeaderFactory secondLazyFactory = mock(LazyHeaderFactory.class);
     new EqualsTester()
-        .addEqualityGroup(
-            new Builder().build(),
-            new Builder().build()
-        )
+        .addEqualityGroup(new Builder().build(), new Builder().build())
         .addEqualityGroup(
             new Builder().addHeader("key", "value").build(),
-            new Builder().addHeader("key", "value").build()
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("key", "value").addHeader("key", "value").build()
-        )
+            new Builder().addHeader("key", "value").build())
+        .addEqualityGroup(new Builder().addHeader("key", "value").addHeader("key", "value").build())
         .addEqualityGroup(
             new Builder().addHeader("key", firstLazyFactory).build(),
-            new Builder().addHeader("key", firstLazyFactory).build()
-        )
+            new Builder().addHeader("key", firstLazyFactory).build())
         .addEqualityGroup(
             new Builder()
                 .addHeader("key", firstLazyFactory)
                 .addHeader("key", firstLazyFactory)
-                .build()
-        )
+                .build())
         .addEqualityGroup(
             new Builder()
                 .addHeader("firstKey", "value")
@@ -347,20 +322,11 @@ public void testEquals() {
             new Builder()
                 .addHeader("secondKey", firstLazyFactory)
                 .addHeader("firstKey", "value")
-                .build()
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("key", "secondValue")
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("secondKey", "value")
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("key", secondLazyFactory)
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("secondKey", firstLazyFactory)
-        )
+                .build())
+        .addEqualityGroup(new Builder().addHeader("key", "secondValue"))
+        .addEqualityGroup(new Builder().addHeader("secondKey", "value"))
+        .addEqualityGroup(new Builder().addHeader("key", secondLazyFactory))
+        .addEqualityGroup(new Builder().addHeader("secondKey", firstLazyFactory))
         .addEqualityGroup(
             new Builder()
                 .addHeader("firstKey", "firstValue")
@@ -373,8 +339,7 @@ public void testEquals() {
             new Builder()
                 .addHeader("secondKey", "secondValue")
                 .addHeader("firstKey", "firstValue")
-                .build()
-        )
+                .build())
         .addEqualityGroup(
             new Builder()
                 .addHeader("firstKey", firstLazyFactory)
@@ -387,8 +352,7 @@ public void testEquals() {
             new Builder()
                 .addHeader("secondKey", secondLazyFactory)
                 .addHeader("firstKey", firstLazyFactory)
-                .build()
-        )
+                .build())
         .testEquals();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
index 041f67992..744eba369 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
@@ -20,11 +20,13 @@ public void setUp() {
 
   @Test
   public void testModelKeyEquivalence() {
-    new EqualsTester().addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 200),
-        ModelCache.ModelKey.get(14f, 100, 200))
+    new EqualsTester()
+        .addEqualityGroup(
+            ModelCache.ModelKey.get(14f, 100, 200), ModelCache.ModelKey.get(14f, 100, 200))
         .addEqualityGroup(ModelCache.ModelKey.get(13f, 100, 200))
         .addEqualityGroup(ModelCache.ModelKey.get(14f, 200, 200))
-        .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 300)).testEquals();
+        .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 300))
+        .testEquals();
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index b6acd775c..5136a1253 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -1,21 +1,21 @@
 package com.bumptech.glide.load.model;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.support.v4.util.Pools.Pool;
+import androidx.core.util.Pools.Pool;
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import java.util.ArrayList;
 import java.util.List;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
+import org.junit.function.ThrowingRunnable;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
@@ -23,28 +23,26 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+// containsExactly produces a spurious warning.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class MultiModelLoaderFactoryTest {
+  @Mock private ModelLoaderFactory<String, String> firstFactory;
+  @Mock private ModelLoader<String, String> firstModelLoader;
+  @Mock private MultiModelLoaderFactory.Factory multiModelLoaderFactory;
+  @Mock private ModelLoaderFactory<String, String> secondFactory;
+  @Mock private ModelLoader<String, String> secondModelLoader;
 
-  @Mock ModelLoaderFactory<String, String> firstFactory;
-  @Mock ModelLoader<String, String> firstModelLoader;
-  @Mock MultiModelLoaderFactory.Factory multiModelLoaderFactory;
-  @Mock ModelLoaderFactory<String, String> secondFactory;
-  @Mock ModelLoader<String, String> secondModelLoader;
-
-  @Rule public ExpectedException exception = ExpectedException.none();
-
-  private Pool<List<Exception>> exceptionListPool;
+  private Pool<List<Throwable>> throwableListPool;
   private MultiModelLoaderFactory multiFactory;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    exceptionListPool = FactoryPools.threadSafeList();
+    throwableListPool = FactoryPools.threadSafeList();
 
-    multiFactory = new MultiModelLoaderFactory(exceptionListPool,
-        multiModelLoaderFactory);
+    multiFactory = new MultiModelLoaderFactory(throwableListPool, multiModelLoaderFactory);
     when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
     when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
@@ -104,7 +102,7 @@ public void testReplace_returnsPreviouslyRegisteredFactories_withModelAndDataCla
     multiFactory.append(String.class, String.class, firstOtherFactory);
     multiFactory.append(String.class, String.class, secondOtherFactory);
 
-    List<ModelLoaderFactory<String, String>> removed =
+    List<ModelLoaderFactory<? extends String, ? extends String>> removed =
         multiFactory.replace(String.class, String.class, firstFactory);
     assertThat(removed).containsExactly(firstOtherFactory, secondOtherFactory);
   }
@@ -126,7 +124,7 @@ public void testRemove_returnsPreviouslyRegisteredFactories_withModelAndDataClas
     multiFactory.append(String.class, String.class, other);
     multiFactory.append(String.class, String.class, firstFactory);
 
-    List<ModelLoaderFactory<String, String>> removed =
+    List<ModelLoaderFactory<? extends String, ? extends String>> removed =
         multiFactory.remove(String.class, String.class);
     assertThat(removed).containsExactly(firstFactory, other);
   }
@@ -153,7 +151,7 @@ public void testBuild_withModelClass_returnsMultipleModelLoaders_ofGivenModelAnd
 
   @Test
   public void
-  testBuild_withModelClass_returnsMultipleModelLoaders_ofGivenModelClassWithDifferentDataClasses() {
+      testBuild_withModelClass_returnsMultipleModelLoaders_ofGivenModelClassWithDifferentDataClasses() {
     ModelLoader<String, Integer> otherLoader = appendFactoryFor(String.class, Integer.class);
     multiFactory.append(String.class, String.class, firstFactory);
 
@@ -170,7 +168,7 @@ public void testBuild_withModelClass_excludesModelLoadersForOtherModelClasses()
 
   @Test
   public void
-  testBuild_withModelAndDataClasses_returnsMultipleModelLoaders_ofGivenModelAndDataClasses() {
+      testBuild_withModelAndDataClasses_returnsMultipleModelLoaders_ofGivenModelAndDataClasses() {
     ModelLoader<String, String> otherLoader = appendFactoryFor(String.class, String.class);
     multiFactory.append(String.class, String.class, firstFactory);
 
@@ -182,16 +180,28 @@ public void testBuild_withModelClass_excludesModelLoadersForOtherModelClasses()
   public void testBuild_withModelAndDataClasses_excludesModelLoadersForOtherDataClasses() {
     multiFactory.append(String.class, String.class, firstFactory);
 
-    exception.expect(NoModelLoaderAvailableException.class);
-    multiFactory.build(String.class, Integer.class);
+    assertThrows(
+        NoModelLoaderAvailableException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            multiFactory.build(String.class, Integer.class);
+          }
+        });
   }
 
   @Test
   public void testBuild_withModelAndDataClasses_excludesModelLoadersForOtherModelClasses() {
     multiFactory.append(String.class, String.class, firstFactory);
 
-    exception.expect(NoModelLoaderAvailableException.class);
-    multiFactory.build(Integer.class, String.class);
+    assertThrows(
+        NoModelLoaderAvailableException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            multiFactory.build(Integer.class, String.class);
+          }
+        });
   }
 
   @Test
@@ -211,15 +221,28 @@ public void testBuild_withModelClass_matchesSuperclassesOfModelClass() {
   @Test
   public void testBuild_withModelAndDataClass_doesNotMatchSubclassesOfModelClass() {
     appendFactoryFor(String.class, Object.class);
-    exception.expect(NoModelLoaderAvailableException.class);
-    multiFactory.build(Object.class, Object.class);
+
+    assertThrows(
+        NoModelLoaderAvailableException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            multiFactory.build(Object.class, Object.class);
+          }
+        });
   }
 
   @Test
   public void testBuild_withModelAndDataClass_doesNotMatchSubclassesOfDataClass() {
     appendFactoryFor(Object.class, String.class);
-    exception.expect(NoModelLoaderAvailableException.class);
-    multiFactory.build(Object.class, Object.class);
+    assertThrows(
+        NoModelLoaderAvailableException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            multiFactory.build(Object.class, Object.class);
+          }
+        });
   }
 
   @Test
@@ -264,17 +287,15 @@ public void testBuild_respectsPrependOrder() {
     assertThat(modelLoaders).containsExactly(third, second, first).inOrder();
   }
 
-  private <X, Y> List<ModelLoader<X, Y>> buildModelLoaders(Class<X> modelClass,
-      Class<Y> dataClass) {
+  private <X, Y> List<ModelLoader<X, Y>> buildModelLoaders(
+      Class<X> modelClass, Class<Y> dataClass) {
     ArgumentCaptor<List<ModelLoader<X, Y>>> captor = Util.cast(ArgumentCaptor.forClass(List.class));
     multiFactory.build(modelClass, dataClass);
-    verify(multiModelLoaderFactory).build(captor.capture(), eq(exceptionListPool));
+    verify(multiModelLoaderFactory).build(captor.capture(), eq(throwableListPool));
 
     List<ModelLoader<X, Y>> captured = captor.getValue();
     List<ModelLoader<X, Y>> result = new ArrayList<>(captured.size());
-    for (ModelLoader<X, Y> modelLoader : captured) {
-      result.add(modelLoader);
-    }
+    result.addAll(captured);
     return result;
   }
 
@@ -289,7 +310,8 @@ public void testBuild_respectsPrependOrder() {
   private <X, Y> ModelLoader<X, Y> registerFactoryFor(
       Class<X> modelClass, Class<Y> dataClass, boolean append) {
     ModelLoaderFactory<X, Y> factory = mockFactory();
-    @SuppressWarnings("unchecked") ModelLoader<X, Y> loader = mock(ModelLoader.class);
+    @SuppressWarnings("unchecked")
+    ModelLoader<X, Y> loader = mock(ModelLoader.class);
     when(factory.build(eq(multiFactory))).thenReturn(loader);
     if (append) {
       multiFactory.append(modelClass, dataClass, factory);
@@ -304,4 +326,3 @@ public void testBuild_respectsPrependOrder() {
     return mock(ModelLoaderFactory.class);
   }
 }
-
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
similarity index 70%
rename from library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index a5038c23a..8725c9544 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -14,6 +14,7 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,16 +24,14 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for the {@link com.bumptech.glide.load.model.ResourceLoader} class.
- */
+/** Tests for the {@link com.bumptech.glide.load.model.ResourceLoader} class. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ResourceLoaderTest {
 
-  @Mock ModelLoader<Uri, Object> uriLoader;
-  @Mock DataFetcher<Object> fetcher;
-  @Mock Key key;
+  @Mock private ModelLoader<Uri, Object> uriLoader;
+  @Mock private DataFetcher<Object> fetcher;
+  @Mock private Key key;
   private Options options;
 
   private ResourceLoader<Object> loader;
@@ -53,13 +52,15 @@ public void testCanHandleId() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(id));
-    assertEquals(fetcher, loader.buildLoadData(id, 100, 100, new Options()).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(id, 100, 100, new Options())).fetcher);
   }
 
-    @Test
-    public void testDoesNotThrowOnInvalidOrMissingId() {
-      assertThat(loader.buildLoadData(1234, 0, 0, options)).isNull();
-      verify(uriLoader, never()).buildLoadData(any(Uri.class), anyInt(), anyInt(),
-          any(Options.class));
-    }
+  @Test
+  public void testDoesNotThrowOnInvalidOrMissingId() {
+    assertThat(loader.buildLoadData(1234, 0, 0, options)).isNull();
+    verify(uriLoader, never())
+        .buildLoadData(any(Uri.class), anyInt(), anyInt(), any(Options.class));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
similarity index 79%
rename from library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
index 3eecb3718..55b4f1d50 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -17,7 +17,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class StreamEncoderTest {
   private StreamEncoder encoder;
   private File file;
@@ -30,17 +30,21 @@ public void setUp() {
 
   @After
   public void tearDown() {
-    file.delete();
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
+    if (!file.delete()) {
+      throw new IllegalStateException("Failed to delete: " + file);
+    }
   }
 
   @Test
   public void testWritesDataFromInputStreamToOutputStream() throws IOException {
     String fakeData = "SomeRandomFakeData";
-    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes());
+    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes("UTF-8"));
     encoder.encode(is, file, new Options());
 
     byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
 
-    assertEquals(fakeData, new String(data));
+    assertEquals(fakeData, new String(data, "UTF-8"));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
similarity index 69%
rename from library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
index 42bc40545..4108a1718 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
@@ -13,8 +13,8 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
-import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,24 +24,22 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for the {@link com.bumptech.glide.load.model.StringLoader} class.
- */
+/** Tests for the {@link com.bumptech.glide.load.model.StringLoader} class. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class StringLoaderTest {
   // Not a magic number, just an arbitrary non zero value.
   private static final int IMAGE_SIDE = 100;
 
-  @Mock ModelLoader<Uri, Object> uriLoader;
-  @Mock DataFetcher<Object> fetcher;
-  @Mock Key key;
+  @Mock private ModelLoader<Uri, Object> uriLoader;
+  @Mock private DataFetcher<Object> fetcher;
+  @Mock private Key key;
 
   private StringLoader<Object> loader;
   private Options options;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
@@ -50,9 +48,9 @@ public void setUp() throws Exception {
   }
 
   @Test
-  public void testHandlesPaths() throws IOException {
-    // TODO on windows it will fail with schema being the drive letter (C:\... -> C)
-    assumeTrue(!Util.isWindows());
+  public void testHandlesPaths() {
+    // TODO fix drive letter parsing somehow
+    assumeTrue("it will fail with schema being the drive letter (C:\\... -> C)", !Util.isWindows());
 
     File f = RuntimeEnvironment.application.getCacheDir();
     Uri expected = Uri.fromFile(f);
@@ -60,14 +58,15 @@ public void testHandlesPaths() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(f.getAbsolutePath()));
-    assertEquals(fetcher,
-        loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+                loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
   public void testCanHandleComplexFilePaths() {
-    assumeTrue(!Util.isWindows());
-
     String testPath =
         "/storage/emulated/0/DCIM/Camera/IMG_20140520_100001:nopm:.jpg,mimeType=image/jpeg,"
             + "2448x3264,orientation=0,date=Tue";
@@ -76,11 +75,14 @@ public void testCanHandleComplexFilePaths() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(testPath));
-    assertEquals(fetcher, loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
-  public void testHandlesFileUris() throws IOException {
+  public void testHandlesFileUris() {
     File f = RuntimeEnvironment.application.getCacheDir();
 
     Uri expected = Uri.fromFile(f);
@@ -88,20 +90,26 @@ public void testHandlesFileUris() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(f.getAbsolutePath()));
-    assertEquals(fetcher,
-        loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+                loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
-  public void testHandlesResourceUris() throws IOException {
+  public void testHandlesResourceUris() {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
 
     when(uriLoader.buildLoadData(eq(resourceUri), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(resourceUri.toString()));
-    assertEquals(fetcher,
-        loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+                loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -113,7 +121,10 @@ public void testHandlesHttp() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(url));
-    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -125,7 +136,10 @@ public void testHandlesHttps() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(url));
-    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -137,7 +151,10 @@ public void testHandlesContent() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(content));
-    assertEquals(fetcher, loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
similarity index 69%
rename from library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index 846ed783c..f8f10af34 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -8,6 +8,7 @@
 import android.net.Uri;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 import java.io.IOException;
 import org.junit.Before;
@@ -18,17 +19,15 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for the {@link UriLoader} class.
- */
+/** Tests for the {@link UriLoader} class. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class UriLoaderTest {
   // Not a magic number, just arbitrary non zero.
   private static final int IMAGE_SIDE = 120;
 
-  @Mock DataFetcher<Object> localUriFetcher;
-  @Mock UriLoader.LocalUriFetcherFactory<Object> factory;
+  @Mock private DataFetcher<Object> localUriFetcher;
+  @Mock private UriLoader.LocalUriFetcherFactory<Object> factory;
   private UriLoader<Object> loader;
   private Options options;
 
@@ -46,8 +45,10 @@ public void testHandlesFileUris() throws IOException {
     when(factory.build(eq(fileUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(fileUri));
-    assertEquals(localUriFetcher,
-        loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -56,8 +57,11 @@ public void testHandlesResourceUris() throws IOException {
     when(factory.build(eq(resourceUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(resourceUri));
-    assertEquals(localUriFetcher,
-        loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+                loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -66,7 +70,10 @@ public void testHandlesContentUris() {
     when(factory.build(eq(contentUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(contentUri));
-    assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
-        options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+                loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
similarity index 63%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
index 0c87d5f1b..aa719ddbb 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -9,12 +9,14 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.util.Preconditions;
 import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
@@ -27,12 +29,12 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BaseGlideUrlLoaderTest {
 
-  @Mock ModelCache<Object, GlideUrl> modelCache;
-  @Mock ModelLoader<GlideUrl, InputStream> wrapped;
-  @Mock DataFetcher<InputStream> fetcher;
+  @Mock private ModelCache<Object, GlideUrl> modelCache;
+  @Mock private ModelLoader<GlideUrl, InputStream> wrapped;
+  @Mock private DataFetcher<InputStream> fetcher;
   private TestLoader urlLoader;
   private Options options;
 
@@ -68,7 +70,9 @@ public void testReturnsUrlFromCacheIfPresent() {
     when(wrapped.buildLoadData(eq(expectedUrl), eq(width), eq(height), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
 
-    assertEquals(fetcher, urlLoader.buildLoadData(model, width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(urlLoader.buildLoadData(model, width, height, options)).fetcher);
   }
 
   @Test
@@ -78,18 +82,20 @@ public void testBuildsNewUrlIfNotPresentInCache() {
 
     urlLoader.resultUrl = "fakeUrl";
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
-        .thenAnswer(new Answer<ModelLoader.LoadData<InputStream>>() {
-          @Override
-          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock)
-              throws Throwable {
-            GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
-            assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
-            return new ModelLoader.LoadData<>(mock(Key.class), fetcher);
-
-          }
-        });
-    assertEquals(fetcher,
-        urlLoader.buildLoadData(new GlideUrl(urlLoader.resultUrl), width, height, options).fetcher);
+        .thenAnswer(
+            new Answer<ModelLoader.LoadData<InputStream>>() {
+              @Override
+              public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock) {
+                GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
+                assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
+                return new ModelLoader.LoadData<>(mock(Key.class), fetcher);
+              }
+            });
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+                urlLoader.buildLoadData(new GlideUrl(urlLoader.resultUrl), width, height, options))
+            .fetcher);
   }
 
   @Test
@@ -99,14 +105,17 @@ public void testAddsNewUrlToCacheIfNotPresentInCache() {
     int width = 400;
     int height = 500;
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
-        assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
-        return null;
-      }
-    }).when(modelCache).put(eq(model), eq(width), eq(height), any(GlideUrl.class));
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
+                assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
+                return null;
+              }
+            })
+        .when(modelCache)
+        .put(eq(model), eq(width), eq(height), any(GlideUrl.class));
 
     urlLoader.buildLoadData(model, width, height, options);
 
@@ -124,13 +133,17 @@ public void testDoesNotInteractWithModelCacheIfNull() {
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
 
-    assertEquals(fetcher, urlLoader.buildLoadData(new Object(), width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(urlLoader.buildLoadData(new Object(), width, height, options))
+            .fetcher);
   }
 
-  private class TestLoader extends BaseGlideUrlLoader<Object> {
-    public String resultUrl;
+  private static final class TestLoader extends BaseGlideUrlLoader<Object> {
+    String resultUrl;
 
-    public TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+    TestLoader(
+        ModelLoader<GlideUrl, InputStream> concreteLoader,
         ModelCache<Object, GlideUrl> modelCache) {
       super(concreteLoader, modelCache);
     }
@@ -141,7 +154,7 @@ protected String getUrl(Object model, int width, int height, Options options) {
     }
 
     @Override
-    public boolean handles(Object model) {
+    public boolean handles(@NonNull Object model) {
       return true;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
index 92efc86ce..446c15931 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
@@ -7,15 +7,14 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.Preconditions;
 import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
 public class HttpGlideUrlLoaderTest {
   private HttpGlideUrlLoader loader;
   private GlideUrl model;
@@ -29,7 +28,8 @@ public void setUp() {
 
   @Test
   public void testReturnsValidFetcher() {
-    DataFetcher<InputStream> result = loader.buildLoadData(model, 100, 100, new Options()).fetcher;
+    DataFetcher<InputStream> result =
+        Preconditions.checkNotNull(loader.buildLoadData(model, 100, 100, new Options())).fetcher;
     assertThat(result).isInstanceOf(HttpUrlFetcher.class);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
similarity index 73%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
index 92dae6dbb..512c5f7ee 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
@@ -19,12 +19,12 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class HttpUriLoaderTest {
   private static final int IMAGE_SIDE = 100;
   private static final Options OPTIONS = new Options();
 
-  @Mock ModelLoader<GlideUrl, InputStream> urlLoader;
+  @Mock private ModelLoader<GlideUrl, InputStream> urlLoader;
   private HttpUriLoader loader;
 
   @Before
@@ -41,8 +41,8 @@ public void testHandlesHttpUris() throws MalformedURLException {
 
     assertTrue(loader.handles(httpUri));
     verify(urlLoader)
-        .buildLoadData(eq(new GlideUrl(httpUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE),
-            eq(OPTIONS));
+        .buildLoadData(
+            eq(new GlideUrl(httpUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(OPTIONS));
   }
 
   @Test
@@ -52,20 +52,25 @@ public void testHandlesHttpsUris() throws MalformedURLException {
 
     assertTrue(loader.handles(httpsUri));
     verify(urlLoader)
-        .buildLoadData(eq(new GlideUrl(httpsUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE),
-            eq(OPTIONS));
+        .buildLoadData(
+            eq(new GlideUrl(httpsUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(OPTIONS));
   }
 
   // Test for https://github.com/bumptech/glide/issues/71.
   @Test
   public void testHandlesMostlyInvalidHttpUris() {
-    Uri mostlyInvalidHttpUri = Uri.parse(
-        "http://myserver_url.com:80http://myserver_url.com/webapp/images/no_image.png?size=100");
+    Uri mostlyInvalidHttpUri =
+        Uri.parse(
+            "http://myserver_url.com:80http://myserver_url.com/webapp/images/no_image.png"
+                + "?size=100");
 
     assertTrue(loader.handles(mostlyInvalidHttpUri));
     loader.buildLoadData(mostlyInvalidHttpUri, IMAGE_SIDE, IMAGE_SIDE, OPTIONS);
     verify(urlLoader)
-        .buildLoadData(eq(new GlideUrl(mostlyInvalidHttpUri.toString())), eq(IMAGE_SIDE),
-            eq(IMAGE_SIDE), eq(OPTIONS));
+        .buildLoadData(
+            eq(new GlideUrl(mostlyInvalidHttpUri.toString())),
+            eq(IMAGE_SIDE),
+            eq(IMAGE_SIDE),
+            eq(OPTIONS));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
index 78b851f22..9102937be 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
@@ -35,6 +35,5 @@ public void testThrowsIfGivenNullData() {
     new SimpleResource<>(null);
   }
 
-  private static class Anything {
-  }
+  private static class Anything {}
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
similarity index 67%
rename from library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
index d5dc77761..df1f55f12 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -9,11 +9,12 @@
 import android.app.Application;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -21,6 +22,7 @@
 
 @RunWith(JUnit4.class)
 public class UnitTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
   private Application app;
 
@@ -37,12 +39,17 @@ public void testReturnsGivenResource() {
   }
 
   @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(UnitTransformation.get(), UnitTransformation.get());
-
-    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
+  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
+    @SuppressWarnings("unchecked")
+    Transformation<Object> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other"))
+        .when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(UnitTransformation.get(), other);
+
+    keyTester
+        .addEquivalenceGroup(UnitTransformation.get(), UnitTransformation.get())
+        .addEquivalenceGroup(other)
+        .addEmptyDigestRegressionTest(UnitTransformation.get())
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
index c65b03707..f64418cad 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -17,7 +17,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapDrawableResourceTest {
   private BitmapDrawableResourceHarness harness;
 
@@ -42,8 +42,8 @@ public void testReturnsDifferentDrawableEachTime() {
 
   @Test
   public void testReturnsSizeFromGivenBitmap() {
-    assertEquals(harness.bitmap.getHeight() * harness.bitmap.getRowBytes(),
-        harness.create().getSize());
+    assertEquals(
+        harness.bitmap.getHeight() * harness.bitmap.getRowBytes(), harness.create().getSize());
   }
 
   @Test
@@ -54,10 +54,10 @@ public void testBitmapIsReturnedToPoolOnRecycle() {
   }
 
   private static class BitmapDrawableResourceHarness {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final BitmapPool bitmapPool = mock(BitmapPool.class);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
-    public BitmapDrawableResource create() {
+    BitmapDrawableResource create() {
       return new BitmapDrawableResource(
           new BitmapDrawable(RuntimeEnvironment.application.getResources(), bitmap), bitmapPool);
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
similarity index 74%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index c4227a0cc..acfae224a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -36,13 +37,14 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 @SuppressWarnings("deprecation")
 public class BitmapDrawableTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock BitmapPool bitmapPool;
-  @Mock Transformation<Bitmap> wrapped;
-  @Mock Resource<BitmapDrawable> drawableResourceToTransform;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private Transformation<Bitmap> wrapped;
+  @Mock private Resource<BitmapDrawable> drawableResourceToTransform;
 
   private BitmapDrawableTransformation transformation;
   private Bitmap bitmapToTransform;
@@ -55,7 +57,7 @@ public void setUp() {
     BitmapDrawable drawableToTransform = new BitmapDrawable(bitmapToTransform);
 
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
     transformation = new BitmapDrawableTransformation(wrapped);
   }
@@ -69,15 +71,15 @@ public void tearDown() {
   public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {
     int outWidth = 123;
     int outHeight = 456;
-    when(wrapped.transform(
-        anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
-        .thenAnswer(new Answer<Resource<Bitmap>>() {
-          @SuppressWarnings("unchecked")
-          @Override
-          public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
-            return (Resource<Bitmap>) invocation.getArguments()[1];
-          }
-        });
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
+        .thenAnswer(
+            new Answer<Resource<Bitmap>>() {
+              @SuppressWarnings("unchecked")
+              @Override
+              public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
+                return (Resource<Bitmap>) invocation.getArguments()[1];
+              }
+            });
 
     Resource<BitmapDrawable> transformed =
         transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
@@ -122,13 +124,21 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
+    doAnswer(new Util.WriteDigest("wrapped"))
+        .when(wrapped)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new BitmapDrawableTransformation(wrapped));
-
-    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
+    @SuppressWarnings("unchecked")
+    Transformation<Bitmap> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other"))
+        .when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new BitmapDrawableTransformation(other));
+
+    keyTester
+        .addEquivalenceGroup(transformation, new BitmapDrawableTransformation(wrapped))
+        .addEquivalenceGroup(new BitmapDrawableTransformation(other))
+        .addEquivalenceGroup(wrapped)
+        .addRegressionTest(
+            transformation, "adbf45b08ad6468aa147e5b2a23758ef56ab631a2b70ad52501ca358441a34f3")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
similarity index 55%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 876a2bdef..36361537e 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -6,13 +6,15 @@
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
+import android.graphics.Bitmap.CompressFormat;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import org.junit.After;
@@ -21,11 +23,10 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapEncoderTest {
   private EncoderHarness harness;
 
@@ -41,9 +42,7 @@ public void tearDown() {
 
   @Test
   public void testBitmapIsEncoded() throws IOException {
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, Shadows.shadowOf(harness.bitmap).getDescription());
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.JPEG, 90));
   }
 
   @Test
@@ -51,20 +50,15 @@ public void testBitmapIsEncodedWithGivenQuality() throws IOException {
     int quality = 7;
     harness.setQuality(quality);
 
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, String.valueOf(quality));
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.JPEG, quality));
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   public void testEncoderObeysNonNullCompressFormat() throws IOException {
     Bitmap.CompressFormat format = Bitmap.CompressFormat.WEBP;
     harness.setFormat(format);
 
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, format.toString());
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.WEBP, 90));
   }
 
   @Test
@@ -72,9 +66,7 @@ public void testEncoderEncodesJpegWithNullFormatAndBitmapWithoutAlpha() throws I
     harness.setFormat(null);
     harness.bitmap.setHasAlpha(false);
 
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, Bitmap.CompressFormat.JPEG.toString());
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.JPEG, 90));
   }
 
   @Test
@@ -82,54 +74,58 @@ public void testEncoderEncodesPngWithNullFormatAndBitmapWithAlpha() throws IOExc
     harness.setFormat(null);
     harness.bitmap.setHasAlpha(true);
 
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, Bitmap.CompressFormat.PNG.toString());
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.PNG, 90));
   }
 
   @Test
   public void testReturnsTrueFromWrite() {
-    BitmapEncoder encoder = new BitmapEncoder();
+    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);
     assertTrue(encoder.encode(harness.resource, harness.file, harness.options));
   }
 
   @Test
   public void testEncodeStrategy_alwaysReturnsTransformed() {
-    BitmapEncoder encoder = new BitmapEncoder();
+    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);
     assertEquals(EncodeStrategy.TRANSFORMED, encoder.getEncodeStrategy(harness.options));
   }
 
-  private static void assertContains(String string, String expected) {
-    assertThat(string).contains(expected);
-  }
-
   private static class EncoderHarness {
-    Resource<Bitmap> resource = mockResource();
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Options options = new Options();
-    File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    final Resource<Bitmap> resource = mockResource();
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final Options options = new Options();
+    final File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    final ArrayPool arrayPool = new LruArrayPool();
 
-    public EncoderHarness() {
+    EncoderHarness() {
       when(resource.get()).thenReturn(bitmap);
     }
 
-    public void setQuality(int quality) {
+    void setQuality(int quality) {
       options.set(BitmapEncoder.COMPRESSION_QUALITY, quality);
     }
 
-    public void setFormat(Bitmap.CompressFormat format) {
+    void setFormat(Bitmap.CompressFormat format) {
       options.set(BitmapEncoder.COMPRESSION_FORMAT, format);
     }
 
-    public String encode() throws IOException {
-      BitmapEncoder encoder = new BitmapEncoder();
+    byte[] encode() throws IOException {
+      BitmapEncoder encoder = new BitmapEncoder(arrayPool);
       encoder.encode(resource, file, options);
-      byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
-      return new String(data);
+      return ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
+    }
+
+    byte[] expectedData(CompressFormat expectedFormat, int expectedQuality) {
+      ByteArrayOutputStream os = new ByteArrayOutputStream();
+      bitmap.compress(expectedFormat, expectedQuality, os);
+      return os.toByteArray();
     }
 
-    public void tearDown() {
-      file.delete();
+    void tearDown() {
+      // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+      System.gc();
+      if (file.exists() && !file.delete()) {
+        throw new IllegalStateException("Failed to delete: " + file);
+      }
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
index cb567b21f..840b1cfb5 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -16,9 +16,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-//TODO: add a test for bitmap size using getAllocationByteSize when robolectric supports kitkat.
+// TODO: add a test for bitmap size using getAllocationByteSize when robolectric supports kitkat.
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapResourceTest {
   private int currentBuildVersion;
   private BitmapResourceHarness harness;
@@ -42,8 +42,8 @@ public void testCanGetBitmap() {
   @Test
   public void testSizeIsBasedOnDimensPreKitKat() {
     Util.setSdkVersionInt(18);
-    assertEquals(harness.bitmap.getWidth() * harness.bitmap.getHeight() * 4,
-        harness.resource.getSize());
+    assertEquals(
+        harness.bitmap.getWidth() * harness.bitmap.getHeight() * 4, harness.resource.getSize());
   }
 
   @Test
@@ -69,8 +69,8 @@ public void testThrowsIfBitmapAndBitmapPoolAreNull() {
   }
 
   private static class BitmapResourceHarness {
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final BitmapPool bitmapPool = mock(BitmapPool.class);
+    final BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
similarity index 54%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index d7d22f0c3..c70b3de2d 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -7,7 +7,7 @@
 
 import android.app.Application;
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.engine.Resource;
@@ -26,11 +26,10 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapTransformationTest {
 
-  @Mock
-  private BitmapPool bitmapPool;
+  @Mock private BitmapPool bitmapPool;
   private Application context;
 
   @Before
@@ -38,7 +37,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = RuntimeEnvironment.application;
 
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
   }
 
   @After
@@ -48,16 +47,17 @@ public void tearDown() {
 
   @Test
   public void testReturnsGivenResourceWhenBitmapNotTransformed() {
-    BitmapTransformation transformation = new BitmapTransformation() {
-      @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        return toTransform;
-      }
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+            return toTransform;
+          }
+        };
 
     Resource<Bitmap> resource = mockResource(100, 100);
     assertEquals(resource, transformation.transform(context, resource, 1, 1));
@@ -66,16 +66,17 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
   @Test
   public void testReturnsNewResourceWhenBitmapTransformed() {
     final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-    BitmapTransformation transformation = new BitmapTransformation() {
-      @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth,
-          int outHeight) {
-        return transformed;
-      }
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth, int outHeight) {
+            return transformed;
+          }
+        };
 
     Resource<Bitmap> resource = mockResource(1, 2);
     assertNotSame(resource, transformation.transform(context, resource, 100, 100));
@@ -86,70 +87,79 @@ public void testPassesGivenArgumentsToTransform() {
     final int expectedWidth = 13;
     final int expectedHeight = 148;
     final Resource<Bitmap> resource = mockResource(223, 4123);
-    BitmapTransformation transformation = new BitmapTransformation() {
-      @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        assertEquals(bitmapPool, pool);
-        assertEquals(resource.get(), toTransform);
-        assertEquals(expectedWidth, outWidth);
-        assertEquals(expectedHeight, outHeight);
-        return resource.get();
-      }
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+            assertEquals(bitmapPool, pool);
+            assertEquals(resource.get(), toTransform);
+            assertEquals(expectedWidth, outWidth);
+            assertEquals(expectedHeight, outHeight);
+            return resource.get();
+          }
+        };
 
     transformation.transform(context, resource, expectedWidth, expectedHeight);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidWidth() {
-    BitmapTransformation transformation = new BitmapTransformation() {
-
-      @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        return null;
-      }
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool bitmapPool,
+              @NonNull Bitmap toTransform,
+              int outWidth,
+              int outHeight) {
+            return null;
+          }
+        };
     transformation.transform(context, mockResource(1, 1), -1, 100);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidHeight() {
-    BitmapTransformation transformation = new BitmapTransformation() {
-
-      @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        return null;
-      }
-
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool bitmapPool,
+              @NonNull Bitmap toTransform,
+              int outWidth,
+              int outHeight) {
+            return null;
+          }
+        };
     transformation.transform(context, mockResource(1, 1), 100, -1);
   }
 
   @Test
   public void testReturnsNullIfTransformReturnsNull() {
-    BitmapTransformation transform = new BitmapTransformation() {
+    BitmapTransformation transform =
+        new BitmapTransformation() {
 
-      @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) {  }
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
 
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        return null;
-      }
-    };
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+            return null;
+          }
+        };
 
     Resource<Bitmap> resource = mockResource(100, 100);
     assertNull(transform.transform(context, resource, 100, 100));
@@ -184,19 +194,19 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
     return resource;
   }
 
-  private class SizeTrackingTransform extends BitmapTransformation {
+  private static final class SizeTrackingTransform extends BitmapTransformation {
     int givenWidth;
     int givenHeight;
 
     @Override
-    protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-        int outHeight) {
+    protected Bitmap transform(
+        @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
       givenWidth = outWidth;
       givenHeight = outHeight;
       return null;
     }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) { }
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index a421660e0..28ddbf161 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -18,27 +18,28 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 28)
 public class CenterCropTest {
-  @Mock Resource<Bitmap> resource;
-  @Mock BitmapPool pool;
-  @Mock Transformation<Bitmap> transformation;
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Resource<Bitmap> resource;
+  @Mock private BitmapPool pool;
+  @Mock private Transformation<Bitmap> transformation;
 
   private CenterCrop centerCrop;
   private int bitmapWidth;
@@ -57,7 +58,7 @@ public void setUp() {
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
     centerCrop = new CenterCrop();
   }
@@ -79,8 +80,7 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
-    Resource<Bitmap> result =
-        centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
+    Resource<Bitmap> result = centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
@@ -100,8 +100,9 @@ public void testDoesNotRecycleGivenResource() {
   }
 
   @Test
+  @Config(sdk = 19)
   public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
-    Shadows.shadowOf(bitmap).setConfig(null);
+    bitmap.setConfig(null);
 
     centerCrop.transform(context, resource, 10, 10);
 
@@ -114,8 +115,8 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarge
     int expectedWidth = 75;
     int expectedHeight = 74;
 
-    for (int[] dimens : new int[][] { new int[] { 800, 200 }, new int[] { 450, 100 },
-        new int[] { 78, 78 } }) {
+    for (int[] dimens :
+        new int[][] {new int[] {800, 200}, new int[] {450, 100}, new int[] {78, 78}}) {
       Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
       when(resource.get()).thenReturn(toTransform);
 
@@ -132,8 +133,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
     int expectedWidth = 100;
     int expectedHeight = 100;
 
-    for (int[] dimens : new int[][] { new int[] { 50, 90 }, new int[] { 150, 2 },
-        new int[] { 78, 78 } }) {
+    for (int[] dimens : new int[][] {new int[] {50, 90}, new int[] {150, 2}, new int[] {78, 78}}) {
       Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
       when(resource.get()).thenReturn(toTransform);
 
@@ -147,10 +147,14 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerCrop, new CenterCrop());
-
-    doAnswer(new Util.WriteDigest("other")).when(transformation)
+    doAnswer(new Util.WriteDigest("other"))
+        .when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(centerCrop, transformation);
+    keyTester
+        .addEquivalenceGroup(new CenterCrop(), new CenterCrop())
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new CenterCrop(), "68bd5819c42b37efbe7124bb851443a6388ee3e2e9034213da6eaa15381d3457")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
similarity index 75%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
index ebb4129a8..2a199bed8 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -19,12 +19,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -37,11 +38,14 @@
 import org.robolectric.shadows.ShadowCanvas;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
+@Config(
+    sdk = 18,
+    shadows = {CenterInsideTest.DrawNothingCanvas.class})
 public class CenterInsideTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Resource<Bitmap> resource;
-  @Mock Transformation<Bitmap> transformation;
+  @Mock private Resource<Bitmap> resource;
+  @Mock private Transformation<Bitmap> transformation;
   private CenterInside centerInside;
   private int bitmapWidth;
   private int bitmapHeight;
@@ -57,7 +61,7 @@ public void setUp() {
 
     context = RuntimeEnvironment.application;
     BitmapPool pool = new BitmapPoolAdapter();
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
     centerInside = new CenterInside();
   }
@@ -69,29 +73,25 @@ public void tearDown() {
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
-    Resource<Bitmap> result =
-            centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
+    Resource<Bitmap> result = centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testReturnsGivenResourceIfSmallerThanTarget() {
-    Resource<Bitmap> result =
-        centerInside.transform(context, resource, 150, 150);
+    Resource<Bitmap> result = centerInside.transform(context, resource, 150, 150);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testReturnsNewResourceIfLargerThanTarget() {
-    Resource<Bitmap> result =
-        centerInside.transform(context, resource, 50, 50);
+    Resource<Bitmap> result = centerInside.transform(context, resource, 50, 50);
 
     assertNotEquals(resource, result);
   }
 
-
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
     centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
@@ -108,11 +108,16 @@ public void testDoesNotRecycleGivenResource() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerInside, new CenterInside());
-
-    doAnswer(new Util.WriteDigest("other")).when(transformation)
+    doAnswer(new Util.WriteDigest("other"))
+        .when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(centerInside, transformation);
+
+    keyTester
+        .addEquivalenceGroup(new CenterInside(), new CenterInside(), centerInside)
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new CenterInside(), "acf83850a2e8e9e809c8bfb999e2aede9e932cb897a15367fac9856b96f3ba33")
+        .test();
   }
 
   @Implements(Canvas.class)
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index 740472103..088647285 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -3,6 +3,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.content.Context;
@@ -13,21 +14,23 @@
 import android.graphics.Rect;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
 public class CircleCropTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
   @Mock private BitmapPool bitmapPool;
 
   private CircleCrop circleCrop;
@@ -38,7 +41,7 @@ public void setup() {
     when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
     Context context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     circleCrop = new CircleCrop();
   }
 
@@ -85,6 +88,16 @@ public void testTransform_withNarrowRectangle() {
     assertSamePixels(expected, result);
   }
 
+  @Test
+  public void testEquals() {
+    keyTester
+        .addEquivalenceGroup(circleCrop, new CircleCrop())
+        .addEquivalenceGroup(mock(Transformation.class))
+        .addRegressionTest(
+            new CircleCrop(), "1442365bcc658f89310e39844ef4be58f4b16e52c283254e5a458020f56acb90")
+        .test();
+  }
+
   private void assertSamePixels(Bitmap expected, Bitmap actual) {
     assertEquals(expected.getWidth(), actual.getWidth());
     assertEquals(expected.getHeight(), actual.getHeight());
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
new file mode 100644
index 000000000..80fadfe0a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -0,0 +1,542 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.testutil.TestResourceUtil;
+import java.io.ByteArrayInputStream;
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.Util;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class DefaultImageHeaderParserTest {
+
+  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
+      new byte[] {
+        (byte) 0x89,
+        0x50,
+        0x4e,
+        0x47,
+        0xd,
+        0xa,
+        0x1a,
+        0xa,
+        0x0,
+        0x0,
+        0x0,
+        0xd,
+        0x49,
+        0x48,
+        0x44,
+        0x52,
+        0x0,
+        0x0,
+        0x1,
+        (byte) 0x90,
+        0x0,
+        0x0,
+        0x1,
+        0x2c,
+        0x8,
+        0x6
+      };
+
+  private ArrayPool byteArrayPool;
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruArrayPool();
+  }
+
+  @Test
+  public void testCanParsePngType() throws IOException {
+    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
+    byte[] data = new byte[] {(byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a};
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.PNG, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+          }
+        });
+  }
+
+  @Test
+  public void testCanParsePngWithAlpha() throws IOException {
+    for (int i = 3; i <= 6; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(
+          pngHeaderWithIhdrChunk,
+          new ParserTestCase() {
+            @Override
+            public void run(
+                DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+                throws IOException {
+              assertEquals(ImageType.PNG_A, parser.getType(is));
+            }
+
+            @Override
+            public void run(
+                DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+                throws IOException {
+              assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
+            }
+          });
+    }
+  }
+
+  @Test
+  public void testCanParsePngWithoutAlpha() throws IOException {
+    for (int i = 0; i < 3; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(
+          pngHeaderWithIhdrChunk,
+          new ParserTestCase() {
+            @Override
+            public void run(
+                DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+                throws IOException {
+              assertEquals(ImageType.PNG, parser.getType(is));
+            }
+
+            @Override
+            public void run(
+                DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+                throws IOException {
+              assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+            }
+          });
+    }
+  }
+
+  @Test
+  public void testCanParseJpegType() throws IOException {
+    byte[] data = new byte[] {(byte) 0xFF, (byte) 0xD8};
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.JPEG, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
+          }
+        });
+  }
+
+  @Test
+  public void testCanParseGifType() throws IOException {
+    byte[] data = new byte[] {'G', 'I', 'F'};
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.GIF, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.GIF, parser.getType(byteBuffer));
+          }
+        });
+  }
+
+  @Test
+  public void testCanParseWebpWithAlpha() throws IOException {
+    byte[] data =
+        new byte[] {
+          0x52,
+          0x49,
+          0x46,
+          0x46,
+          0x3c,
+          0x50,
+          0x00,
+          0x00,
+          0x57,
+          0x45,
+          0x42,
+          0x50,
+          0x56,
+          0x50,
+          0x38,
+          0x4c,
+          0x30,
+          0x50,
+          0x00,
+          0x00,
+          0x2f,
+          (byte) 0xef,
+          (byte) 0x80,
+          0x15,
+          0x10,
+          (byte) 0x8d,
+          0x30,
+          0x68,
+          0x1b,
+          (byte) 0xc9,
+          (byte) 0x91,
+          (byte) 0xb2
+        };
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.WEBP_A, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
+          }
+        });
+  }
+
+  @Test
+  public void testCanParseWebpWithoutAlpha() throws IOException {
+    byte[] data =
+        new byte[] {
+          0x52,
+          0x49,
+          0x46,
+          0x46,
+          0x72,
+          0x1c,
+          0x00,
+          0x00,
+          0x57,
+          0x45,
+          0x42,
+          0x50,
+          0x56,
+          0x50,
+          0x38,
+          0x20,
+          0x66,
+          0x1c,
+          0x00,
+          0x00,
+          0x30,
+          0x3c,
+          0x01,
+          (byte) 0x9d,
+          0x01,
+          0x2a,
+          0x52,
+          0x02,
+          (byte) 0x94,
+          0x03,
+          0x00,
+          (byte) 0xc7
+        };
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.WEBP, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
+          }
+        });
+  }
+
+  @Test
+  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
+    byte[] data = new byte[] {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.UNKNOWN, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+          }
+        });
+  }
+
+  // Test for #286.
+  @Test
+  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
+    byte[] data =
+        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(-1, parser.getOrientation(is, byteArrayPool));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
+          }
+        });
+  }
+
+  @Test
+  public void testReturnsUnknownForEmptyData() throws IOException {
+    runTest(
+        new byte[0],
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.UNKNOWN, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+          }
+        });
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialReads() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialReadInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialSkips() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialSkipInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  @Test
+  public void testHandlesSometimesZeroSkips() throws IOException {
+    InputStream is =
+        new ByteArrayInputStream(
+            new byte[] {(byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a});
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageType.PNG, parser.getType(new SometimesZeroSkipInputStream(is)));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data =
+        new byte[] {
+          jpegHeaderBytes.get(0),
+          jpegHeaderBytes.get(1),
+          (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+          (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
+          // SEGMENT_LENGTH
+          (byte) 0xFF,
+          (byte) 0xFF,
+        };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(
+        ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data =
+        new byte[] {
+          jpegHeaderBytes.get(0),
+          jpegHeaderBytes.get(1),
+          (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+          // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
+          (byte) 0xE5,
+          // SEGMENT_LENGTH
+          (byte) 0xFF,
+          (byte) 0xFF,
+        };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(
+        ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleButLessThanLength_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity());
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity() + 2 + 1);
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  private static ByteBuffer getExifMagicNumber() {
+    ByteBuffer jpegHeaderBytes = ByteBuffer.allocate(2);
+    jpegHeaderBytes.putShort((short) DefaultImageHeaderParser.EXIF_MAGIC_NUMBER);
+    jpegHeaderBytes.position(0);
+    return jpegHeaderBytes;
+  }
+
+  private interface ParserTestCase {
+    void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+        throws IOException;
+
+    void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+        throws IOException;
+  }
+
+  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
+    InputStream is = new ByteArrayInputStream(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    test.run(parser, is, new LruArrayPool());
+
+    ByteBuffer buffer = ByteBuffer.wrap(data);
+    parser = new DefaultImageHeaderParser();
+    test.run(parser, buffer, new LruArrayPool());
+  }
+
+  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
+    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
+    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
+    result[result.length - 1] = (byte) bitDepth;
+    return result;
+  }
+
+  private static class SometimesZeroSkipInputStream extends FilterInputStream {
+    boolean returnZeroFlag = true;
+
+    SometimesZeroSkipInputStream(InputStream in) {
+      super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      final long result;
+      if (returnZeroFlag) {
+        result = 0;
+      } else {
+        result = super.skip(byteCount);
+      }
+      returnZeroFlag = !returnZeroFlag;
+      return result;
+    }
+  }
+
+  private static class PartialSkipInputStream extends FilterInputStream {
+
+    PartialSkipInputStream(InputStream in) {
+      super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      long toActuallySkip = byteCount / 2;
+      if (byteCount == 1) {
+        toActuallySkip = 1;
+      }
+      return super.skip(toActuallySkip);
+    }
+  }
+
+  private static class PartialReadInputStream extends FilterInputStream {
+
+    PartialReadInputStream(InputStream in) {
+      super(in);
+    }
+
+    @Override
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
+      int toActuallyRead = byteCount / 2;
+      if (byteCount == 1) {
+        toActuallyRead = 1;
+      }
+      return super.read(buffer, byteOffset, toActuallyRead);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
index c6a624025..74b4b2789 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
@@ -8,7 +8,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 21)
 public class DownsampleStrategyTest {
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
new file mode 100644
index 000000000..0947720b8
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
@@ -0,0 +1,186 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.resource.SimpleResource;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class DrawableTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Transformation<Bitmap> bitmapTransformation;
+  private BitmapPool bitmapPool;
+  private DrawableTransformation transformation;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    transformation = new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true);
+    context = RuntimeEnvironment.application;
+    bitmapPool = new BitmapPoolAdapter();
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @Test
+  public void transform_withBitmapDrawable_andUnitBitmapTransformation_doesNotRecycle() {
+    when(bitmapTransformation.transform(
+            any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new ReturnGivenResource());
+
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    @SuppressWarnings("unchecked")
+    Resource<Drawable> input =
+        (Resource<Drawable>) (Resource<?>) new BitmapDrawableResource(drawable, bitmapPool);
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withBitmapDrawable_andFunctionalBitmapTransformation_doesNotRecycle() {
+    when(bitmapTransformation.transform(
+            any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(
+            new Answer<Resource<Bitmap>>() {
+              @Override
+              public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+                return BitmapResource.obtain(
+                    Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888), bitmapPool);
+              }
+            });
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    @SuppressWarnings("unchecked")
+    Resource<Drawable> input =
+        (Resource<Drawable>) (Resource<?>) new BitmapDrawableResource(drawable, bitmapPool);
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withColorDrawable_andUnitBitmapTransformation_recycles() {
+    bitmapPool = mock(BitmapPool.class);
+    Glide.tearDown();
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+    when(bitmapTransformation.transform(
+            any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new ReturnGivenResource());
+
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    final Resource<Drawable> input = new SimpleResource<Drawable>(colorDrawable);
+
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
+                assertThat(bitmap.getWidth()).isEqualTo(100);
+                assertThat(bitmap.getHeight()).isEqualTo(200);
+                return null;
+              }
+            })
+        .when(bitmapPool)
+        .put(any(Bitmap.class));
+    when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(
+            new Answer<Bitmap>() {
+              @Override
+              public Bitmap answer(InvocationOnMock invocationOnMock) throws Throwable {
+                int width = (Integer) invocationOnMock.getArguments()[0];
+                int height = (Integer) invocationOnMock.getArguments()[1];
+                Bitmap.Config config = (Bitmap.Config) invocationOnMock.getArguments()[2];
+                return Bitmap.createBitmap(width, height, config);
+              }
+            });
+
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    verify(bitmapPool).put(isA(Bitmap.class));
+  }
+
+  @Test
+  public void testEquals() {
+    BitmapTransformation otherBitmapTransformation = mock(BitmapTransformation.class);
+    doAnswer(new Util.WriteDigest("bitmapTransformation"))
+        .when(bitmapTransformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("otherBitmapTransformation"))
+        .when(otherBitmapTransformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
+
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true),
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ false))
+        .addEquivalenceGroup(bitmapTransformation)
+        .addEquivalenceGroup(otherBitmapTransformation)
+        .addEquivalenceGroup(
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ true),
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ false))
+        .addRegressionTest(
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true),
+            "eddf60c557a6315a489b8a3a19b12439a90381256289fbe9a503afa726230bd9")
+        .addRegressionTest(
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ false),
+            "40931536ed0ec97c39d4be10c44f5b69a86030ec575317f5a0f17e15a0ea9be8")
+        .test();
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<Bitmap> anyBitmapResource() {
+    return any(Resource.class);
+  }
+
+  private static final class ReturnGivenResource implements Answer<Resource<Bitmap>> {
+
+    @Override
+    public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+      @SuppressWarnings("unchecked")
+      Resource<Bitmap> input = (Resource<Bitmap>) invocationOnMock.getArguments()[1];
+      return input;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
similarity index 77%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index 65b073205..ec6c7b4ad 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -36,11 +37,14 @@
 import org.robolectric.shadows.ShadowCanvas;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { FitCenterTest.DrawNothingCanvas.class })
+@Config(
+    sdk = 18,
+    shadows = {FitCenterTest.DrawNothingCanvas.class})
 public class FitCenterTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Resource<Bitmap> resource;
-  @Mock Transformation<Bitmap> transformation;
+  @Mock private Resource<Bitmap> resource;
+  @Mock private Transformation<Bitmap> transformation;
   private FitCenter fitCenter;
   private int bitmapWidth;
   private int bitmapHeight;
@@ -56,8 +60,7 @@ public void setUp() {
 
     BitmapPool pool = new BitmapPoolAdapter();
     context = RuntimeEnvironment.application;
-    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
-
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
     fitCenter = new FitCenter();
   }
@@ -69,8 +72,7 @@ public void tearDown() {
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
-    Resource<Bitmap> result =
-        fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
+    Resource<Bitmap> result = fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
@@ -91,11 +93,15 @@ public void testDoesNotRecycleGivenResource() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(fitCenter, new FitCenter());
-
-    doAnswer(new Util.WriteDigest("other")).when(transformation)
+    doAnswer(new Util.WriteDigest("other"))
+        .when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(fitCenter, transformation);
+    keyTester
+        .addEquivalenceGroup(fitCenter, new FitCenter(), new FitCenter())
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new FitCenter(), "eda03bc6969032145110add4bfe399915897406f4ca3a1a7512d07750e60f90d")
+        .test();
   }
 
   @Implements(Canvas.class)
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigStateTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigStateTest.java
new file mode 100644
index 000000000..115993e90
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigStateTest.java
@@ -0,0 +1,228 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowBuild;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class HardwareConfigStateTest {
+
+  @Config(sdk = Build.VERSION_CODES.O)
+  @Test
+  public void
+      setHardwareConfigIfAllowed_withAllowedState_setsInPreferredConfigAndMutable_returnsFalse() {
+    HardwareConfigState state = new HardwareConfigState();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    boolean result =
+        state.setHardwareConfigIfAllowed(
+            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            options,
+            /*isHardwareConfigAllowed=*/ true,
+            /*isExifOrientationRequired=*/ false);
+
+    assertThat(result).isTrue();
+    assertThat(options.inMutable).isFalse();
+    assertThat(options.inPreferredConfig).isEqualTo(Bitmap.Config.HARDWARE);
+  }
+
+  @Config(sdk = Build.VERSION_CODES.O)
+  @Test
+  public void setHardwareConfigIfAllowed_withSmallerThanMinWidth_returnsFalse_doesNotSetValues() {
+    HardwareConfigState state = new HardwareConfigState();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inPreferredConfig = null;
+    options.inMutable = true;
+
+    boolean result =
+        state.setHardwareConfigIfAllowed(
+            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION - 1,
+            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            options,
+            /*isHardwareConfigAllowed=*/ true,
+            /*isExifOrientationRequired=*/ false);
+
+    assertThat(result).isFalse();
+    assertThat(options.inMutable).isTrue();
+    assertThat(options.inPreferredConfig).isNull();
+  }
+
+  @Config(sdk = Build.VERSION_CODES.O)
+  @Test
+  public void setHardwareConfigIfAllowed_withSmallerThanMinHeight_returnsFalse_doesNotSetValues() {
+    HardwareConfigState state = new HardwareConfigState();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inPreferredConfig = null;
+    options.inMutable = true;
+
+    boolean result =
+        state.setHardwareConfigIfAllowed(
+            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION - 1,
+            options,
+            /*isHardwareConfigAllowed=*/ true,
+            /*isExifOrientationRequired=*/ false);
+
+    assertThat(result).isFalse();
+    assertThat(options.inMutable).isTrue();
+    assertThat(options.inPreferredConfig).isNull();
+  }
+
+  @Config(sdk = Build.VERSION_CODES.O)
+  @Test
+  public void
+      setHardwareConfigIfAllowed_withHardwareConfigDisallowed_returnsFalse_doesNotSetValues() {
+    HardwareConfigState state = new HardwareConfigState();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inPreferredConfig = null;
+    options.inMutable = true;
+
+    boolean result =
+        state.setHardwareConfigIfAllowed(
+            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            options,
+            /*isHardwareConfigAllowed=*/ false,
+            /*isExifOrientationRequired=*/ false);
+
+    assertThat(result).isFalse();
+    assertThat(options.inMutable).isTrue();
+    assertThat(options.inPreferredConfig).isNull();
+  }
+
+  @Config(sdk = Build.VERSION_CODES.O)
+  @Test
+  public void
+      setHardwareConfigIfAllowed_withExifOrientationRequired_returnsFalse_doesNotSetValues() {
+    HardwareConfigState state = new HardwareConfigState();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inPreferredConfig = null;
+    options.inMutable = true;
+
+    boolean result =
+        state.setHardwareConfigIfAllowed(
+            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            options,
+            /*isHardwareConfigAllowed=*/ true,
+            /*isExifOrientationRequired=*/ true);
+
+    assertThat(result).isFalse();
+    assertThat(options.inMutable).isTrue();
+    assertThat(options.inPreferredConfig).isNull();
+  }
+
+  @Config(sdk = Build.VERSION_CODES.N_MR1)
+  @Test
+  public void setHardwareConfigIfAllowed_withOsLessThanO_returnsFalse_doesNotSetValues() {
+    HardwareConfigState state = new HardwareConfigState();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inPreferredConfig = null;
+    options.inMutable = true;
+
+    boolean result =
+        state.setHardwareConfigIfAllowed(
+            /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+            options,
+            /*isHardwareConfigAllowed=*/ true,
+            /*isExifOrientationRequired=*/ false);
+
+    assertThat(result).isFalse();
+    assertThat(options.inMutable).isTrue();
+    assertThat(options.inPreferredConfig).isNull();
+  }
+
+  @Config(sdk = Build.VERSION_CODES.O)
+  @Test
+  public void
+      setHardwareConfigIfAllowed_withDisallowedSamsungDevices_returnsFalse_doesNotSetValues() {
+    for (String model :
+        new String[] {
+          "SM-N9351", "SM-J72053", "SM-G9600", "SM-G965ab", "SM-G935.", "SM-G930", "SM-A5204"
+        }) {
+      ShadowBuild.setModel(model);
+      HardwareConfigState state = new HardwareConfigState();
+      BitmapFactory.Options options = new BitmapFactory.Options();
+      options.inPreferredConfig = null;
+      options.inMutable = true;
+
+      boolean result =
+          state.setHardwareConfigIfAllowed(
+              /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              options,
+              /*isHardwareConfigAllowed=*/ true,
+              /*isExifOrientationRequired=*/ false);
+
+      assertWithMessage("model: " + model).that(result).isFalse();
+      assertWithMessage("model: " + model).that(options.inMutable).isTrue();
+      assertWithMessage("model: " + model).that(options.inPreferredConfig).isNull();
+    }
+  }
+
+  @Config(sdk = Build.VERSION_CODES.O_MR1)
+  @Test
+  public void setHardwareConfigIfAllowed_withDisallowedSamsungDevices_OMR1_returnsTrue() {
+    for (String model :
+        new String[] {
+          "SM-N9351", "SM-J72053", "SM-G9600", "SM-G965ab", "SM-G935.", "SM-G930", "SM-A5204"
+        }) {
+      ShadowBuild.setModel(model);
+      HardwareConfigState state = new HardwareConfigState();
+      BitmapFactory.Options options = new BitmapFactory.Options();
+      options.inPreferredConfig = null;
+      options.inMutable = true;
+
+      boolean result =
+          state.setHardwareConfigIfAllowed(
+              /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              options,
+              /*isHardwareConfigAllowed=*/ true,
+              /*isExifOrientationRequired=*/ false);
+
+      assertWithMessage("model: " + model).that(result).isTrue();
+      assertWithMessage("model: " + model).that(options.inMutable).isFalse();
+      assertWithMessage("model: " + model)
+          .that(options.inPreferredConfig)
+          .isEqualTo(Bitmap.Config.HARDWARE);
+    }
+  }
+
+  @Config(sdk = Build.VERSION_CODES.O)
+  @Test
+  public void setHardwareConfigIfAllowed_withShortEmptyOrNullModelNames_returnsTrue() {
+    for (String model :
+        new String[] {null, ".", "-", "", "S", "SM", "SM-", "SM-G", "SM-G9.", "SM-G93"}) {
+      ShadowBuild.setModel(model);
+      HardwareConfigState state = new HardwareConfigState();
+      BitmapFactory.Options options = new BitmapFactory.Options();
+      options.inPreferredConfig = null;
+      options.inMutable = true;
+
+      boolean result =
+          state.setHardwareConfigIfAllowed(
+              /*targetWidth=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              /*targetHeight=*/ HardwareConfigState.MIN_HARDWARE_DIMENSION,
+              options,
+              /*isHardwareConfigAllowed=*/ true,
+              /*isExifOrientationRequired=*/ false);
+
+      assertWithMessage("model: " + model).that(result).isTrue();
+      assertWithMessage("model: " + model).that(options.inMutable).isFalse();
+      assertWithMessage("model: " + model)
+          .that(options.inPreferredConfig)
+          .isEqualTo(Bitmap.Config.HARDWARE);
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
new file mode 100644
index 000000000..76c55fed3
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
@@ -0,0 +1,87 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.engine.Initializable;
+import com.bumptech.glide.load.engine.Resource;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+@RunWith(RobolectricTestRunner.class)
+public class LazyBitmapDrawableResourceTest {
+  @Mock private Resource<Bitmap> bitmapResource;
+  private LazyBitmapDrawableResource resource;
+  private Resources resources;
+  private Bitmap bitmap;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(bitmapResource.get()).thenReturn(bitmap);
+
+    resources = RuntimeEnvironment.application.getResources();
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+  }
+
+  @Test
+  public void obtain_withNullBitmapResource_returnsNull() {
+    assertThat(LazyBitmapDrawableResource.obtain(resources, null)).isNull();
+  }
+
+  @Test
+  public void getSize_returnsSizeOfWrappedResource() {
+    when(bitmapResource.getSize()).thenReturn(100);
+    assertThat(resource.getSize()).isEqualTo(100);
+  }
+
+  @Test
+  public void recycle_callsRecycleOnWrappedResource() {
+    resource.recycle();
+    verify(bitmapResource).recycle();
+  }
+
+  @Test
+  public void recycle_doesNotRecycleWrappedBitmap() {
+    resource.recycle();
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void get_returnsDrawableContainingWrappedBitmap() {
+    BitmapDrawable drawable = resource.get();
+    assertThat(drawable.getBitmap()).isSameInstanceAs(bitmap);
+  }
+
+  @Test
+  public void initialize_withNonInitializableResource_doesNothing() {
+    resource.initialize();
+  }
+
+  @Test
+  public void initialize_withWrappedInitializableResource_callsInitializeOnWrapped() {
+    InitializableBitmapResource bitmapResource = mock(InitializableBitmapResource.class);
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+    resource.initialize();
+
+    verify(bitmapResource).initialize();
+  }
+
+  private interface InitializableBitmapResource extends Initializable, Resource<Bitmap> {
+    // Intentionally empty.
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
similarity index 98%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
index 3260f51ae..659d68116 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -19,8 +19,10 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+// Not required in tests.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class RecyclableBufferedInputStreamTest {
 
   private static final int DATA_SIZE = 30;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index ae6264663..51a65b74b 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -32,11 +32,12 @@
 import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
-    TransformationUtilsTest.AlphaShadowBitmap.class })
+@Config(
+    sdk = 28,
+    shadows = {TransformationUtilsTest.AlphaShadowBitmap.class})
 public class TransformationUtilsTest {
 
-  @Mock BitmapPool bitmapPool;
+  @Mock private BitmapPool bitmapPool;
 
   @Before
   public void setUp() {
@@ -130,8 +131,8 @@ public void testFitCenterUsesFloorInsteadOfRoundingForOutputBitmapSize() {
   @Test
   public void testFitCenterReturnsGivenBitmapIfGivenBitmapMatchesExactly() {
     Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
-    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth(),
-        toFit.getHeight());
+    Bitmap transformed =
+        TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth(), toFit.getHeight());
     assertTrue(toFit == transformed);
   }
 
@@ -154,8 +155,8 @@ public void testFitCenterReturnsGivenBitmapIfGivenBitmapHeightMatchesExactly() {
   @Test
   public void testCenterCropReturnsGivenBitmapIfGivenBitmapExactlyMatchesGivenDimensions() {
     Bitmap toCrop = Bitmap.createBitmap(200, 300, Bitmap.Config.ARGB_8888);
-    Bitmap transformed = TransformationUtils
-        .centerCrop(bitmapPool, toCrop, toCrop.getWidth(), toCrop.getHeight());
+    Bitmap transformed =
+        TransformationUtils.centerCrop(bitmapPool, toCrop, toCrop.getWidth(), toCrop.getHeight());
 
     // Robolectric incorrectly implements equals() for Bitmaps, we want the original object not
     // just an equivalent.
@@ -163,9 +164,10 @@ public void testCenterCropReturnsGivenBitmapIfGivenBitmapExactlyMatchesGivenDime
   }
 
   @Test
+  @Config(sdk = 19)
   public void testFitCenterHandlesBitmapsWithNullConfigs() {
     Bitmap toFit = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Shadows.shadowOf(toFit).setConfig(null);
+    toFit.setConfig(null);
     Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toFit, 50, 50);
     assertEquals(Bitmap.Config.ARGB_8888, transformed.getConfig());
   }
@@ -176,14 +178,14 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmap
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
     reset(bitmapPool);
-    when(bitmapPool.get(eq(50), eq(50), eq(Bitmap.Config.ARGB_8888)))
-        .thenReturn(toReuse);
+    when(bitmapPool.get(eq(50), eq(50), eq(Bitmap.Config.ARGB_8888))).thenReturn(toReuse);
 
     toReuse.setHasAlpha(false);
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform, toReuse.getWidth(),
-        toReuse.getHeight());
+    Bitmap result =
+        TransformationUtils.centerCrop(
+            bitmapPool, toTransform, toReuse.getWidth(), toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertTrue(result.hasAlpha());
@@ -191,7 +193,7 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmap
 
   @Test
   public void
-  testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
+      testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
@@ -201,8 +203,9 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmap
     toReuse.setHasAlpha(true);
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform, toReuse.getWidth(),
-        toReuse.getHeight());
+    Bitmap result =
+        TransformationUtils.centerCrop(
+            bitmapPool, toTransform, toReuse.getWidth(), toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertFalse(result.hasAlpha());
@@ -214,16 +217,18 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
 
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform,
-        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result =
+        TransformationUtils.centerCrop(
+            bitmapPool, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertTrue(result.hasAlpha());
   }
 
   @Test
+  @Config(sdk = 19)
   public void testCenterCropHandlesBitmapsWithNullConfigs() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Shadows.shadowOf(toTransform).setConfig(null);
+    toTransform.setConfig(null);
 
     Bitmap transformed = TransformationUtils.centerCrop(bitmapPool, toTransform, 50, 50);
 
@@ -236,8 +241,9 @@ public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha(
 
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform,
-        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result =
+        TransformationUtils.centerCrop(
+            bitmapPool, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertFalse(result.hasAlpha());
   }
@@ -254,8 +260,9 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
     toReuse.setHasAlpha(false);
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform, toReuse.getWidth(),
-        toReuse.getHeight());
+    Bitmap result =
+        TransformationUtils.fitCenter(
+            bitmapPool, toTransform, toReuse.getWidth(), toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertTrue(result.hasAlpha());
@@ -263,7 +270,7 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
 
   @Test
   public void
-  testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
+      testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
@@ -274,8 +281,9 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
     toReuse.setHasAlpha(true);
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform, toReuse.getWidth(),
-        toReuse.getHeight());
+    Bitmap result =
+        TransformationUtils.fitCenter(
+            bitmapPool, toTransform, toReuse.getWidth(), toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertFalse(result.hasAlpha());
@@ -287,8 +295,9 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
 
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform,
-        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result =
+        TransformationUtils.fitCenter(
+            bitmapPool, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertTrue(result.hasAlpha());
   }
@@ -299,8 +308,9 @@ public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha()
 
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform,
-        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result =
+        TransformationUtils.fitCenter(
+            bitmapPool, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertFalse(result.hasAlpha());
   }
@@ -326,20 +336,21 @@ private static void assertBitmapFitsExactlyWithinBounds(int maxSide, Bitmap bitm
 
   @Test
   public void testGetExifOrientationDegrees() {
-    assertEquals(0,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_NORMAL));
-    assertEquals(90,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSPOSE));
-    assertEquals(90,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_90));
-    assertEquals(180,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_180));
-    assertEquals(180,
+    assertEquals(
+        0, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_NORMAL));
+    assertEquals(
+        90, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSPOSE));
+    assertEquals(
+        90, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_90));
+    assertEquals(
+        180, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_180));
+    assertEquals(
+        180,
         TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_FLIP_VERTICAL));
-    assertEquals(270,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSVERSE));
-    assertEquals(270,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_270));
+    assertEquals(
+        270, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSVERSE));
+    assertEquals(
+        270, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_270));
   }
 
   @Test
@@ -369,8 +380,9 @@ public void testRotateImageExifReturnsGivenBitmapIfRotationIsUndefined() {
     Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want
     // not just an identical Bitmap, but our original Bitmap object back.
-    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
-        ExifInterface.ORIENTATION_UNDEFINED);
+    Bitmap rotated =
+        TransformationUtils.rotateImageExif(
+            bitmapPool, toRotate, ExifInterface.ORIENTATION_UNDEFINED);
     assertTrue(toRotate == rotated);
   }
 
@@ -384,27 +396,29 @@ public void testRotateImageExifReturnsGivenBitmapIfOrientationIsInvalid() {
   }
 
   @Test
+  @Config(sdk = 19)
   public void testRotateImageExifHandlesBitmapsWithNullConfigs() {
     Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Shadows.shadowOf(toRotate).setConfig(null);
-    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
-        ExifInterface.ORIENTATION_ROTATE_180);
+    toRotate.setConfig(null);
+    Bitmap rotated =
+        TransformationUtils.rotateImageExif(
+            bitmapPool, toRotate, ExifInterface.ORIENTATION_ROTATE_180);
     assertEquals(Bitmap.Config.ARGB_8888, rotated.getConfig());
   }
 
   @Test
   public void testInitializeMatrixSetsScaleIfFlipHorizontal() {
     Matrix matrix = mock(Matrix.class);
-    TransformationUtils
-        .initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_HORIZONTAL, matrix);
+    TransformationUtils.initializeMatrixForRotation(
+        ExifInterface.ORIENTATION_FLIP_HORIZONTAL, matrix);
     verify(matrix).setScale(-1, 1);
   }
 
   @Test
   public void testInitializeMatrixSetsScaleAndRotateIfFlipVertical() {
     Matrix matrix = mock(Matrix.class);
-    TransformationUtils
-        .initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_VERTICAL, matrix);
+    TransformationUtils.initializeMatrixForRotation(
+        ExifInterface.ORIENTATION_FLIP_VERTICAL, matrix);
     verify(matrix).setRotate(180);
     verify(matrix).postScale(-1, 1);
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
new file mode 100644
index 000000000..9a98a4a23
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
@@ -0,0 +1,160 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.ParcelFileDescriptor;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+import java.io.IOException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 27)
+public class VideoDecoderTest {
+  @Mock private ParcelFileDescriptor resource;
+  @Mock private VideoDecoder.MediaMetadataRetrieverFactory factory;
+  @Mock private VideoDecoder.MediaMetadataRetrieverInitializer<ParcelFileDescriptor> initializer;
+  @Mock private MediaMetadataRetriever retriever;
+  @Mock private BitmapPool bitmapPool;
+  private VideoDecoder<ParcelFileDescriptor> decoder;
+  private Options options;
+  private int initialSdkVersion;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    when(factory.build()).thenReturn(retriever);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+    options = new Options();
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
+  }
+
+  @Test
+  public void testReturnsRetrievedFrameForResource() throws IOException {
+    Util.setSdkVersionInt(19);
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION))
+        .thenReturn(expected);
+
+    Resource<Bitmap> result =
+        Preconditions.checkNotNull(decoder.decode(resource, 100, 100, options));
+
+    verify(initializer).initialize(retriever, resource);
+    assertEquals(expected, result.get());
+  }
+
+  @Test
+  public void testReleasesMediaMetadataRetriever() throws IOException {
+    Util.setSdkVersionInt(19);
+    decoder.decode(resource, 1, 2, options);
+
+    verify(retriever).release();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
+    Util.setSdkVersionInt(19);
+    options.set(VideoDecoder.TARGET_FRAME, -5L);
+    new VideoDecoder<>(bitmapPool, initializer, factory).decode(resource, 100, 100, options);
+  }
+
+  @Test
+  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
+    long frame = 5;
+    options.set(VideoDecoder.TARGET_FRAME, frame);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(frame, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void getScaledFrameAtTime() throws IOException {
+    // Anything other than NONE.
+    options.set(DownsampleStrategy.OPTION, DownsampleStrategy.AT_LEAST);
+
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH))
+        .thenReturn("100");
+    when(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT))
+        .thenReturn("100");
+    when(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION))
+        .thenReturn("0");
+    when(retriever.getScaledFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC, 100, 100))
+        .thenReturn(expected);
+
+    assertThat(decoder.decode(resource, 100, 100, options).get()).isSameInstanceAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginal_onApi27_doesNotThrow() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL, options).get())
+        .isSameInstanceAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginalWidthOnly_onApi27_doesNotThrow()
+      throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, 100, options).get())
+        .isSameInstanceAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginalHeightOnly_onApi27_doesNotThrow()
+      throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, 100, Target.SIZE_ORIGINAL, options).get())
+        .isSameInstanceAs(expected);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
index 012e4a8f9..630ffb371 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
@@ -29,5 +29,4 @@ public void testReturnsSizeOfGivenBytes() {
   public void testThrowsIfGivenNullBytes() {
     new BytesResource(null);
   }
-
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
index 6537c6d43..8b3a61724 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.resource.drawable;
 
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertNotEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -9,6 +9,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.drawable.Drawable;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import org.junit.Before;
 import org.junit.Test;
@@ -17,7 +18,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class DrawableResourceTest {
   private TestDrawable drawable;
   private DrawableResource<TestDrawable> resource;
@@ -25,21 +26,22 @@
   @Before
   public void setUp() {
     drawable = mock(TestDrawable.class);
-    resource = new DrawableResource<TestDrawable>(drawable) {
-      @Override
-      public Class<TestDrawable> getResourceClass() {
-        return TestDrawable.class;
-      }
-
-      @Override
-      public int getSize() {
-        return 0;
-      }
-
-      @Override
-      public void recycle() {
-      }
-    };
+    resource =
+        new DrawableResource<TestDrawable>(drawable) {
+          @NonNull
+          @Override
+          public Class<TestDrawable> getResourceClass() {
+            return TestDrawable.class;
+          }
+
+          @Override
+          public int getSize() {
+            return 0;
+          }
+
+          @Override
+          public void recycle() {}
+        };
   }
 
   @Test
@@ -55,15 +57,23 @@ public void testReturnsNewDrawableOnGet() {
     when(constantState.newDrawable()).thenReturn(expected);
     when(drawable.getConstantState()).thenReturn(constantState);
 
-    assertEquals(expected, resource.get());
+    assertThat(resource.get()).isEqualTo(expected);
 
     verify(drawable).getConstantState();
     verify(constantState).newDrawable();
   }
 
+  @Test
+  public void get_withNullState_returnsOriginalDrawable() {
+    when(drawable.getConstantState()).thenReturn(null);
+
+    assertThat(resource.get()).isEqualTo(drawable);
+  }
+
   @Test(expected = NullPointerException.class)
   public void testThrowsIfDrawableIsNull() {
     new DrawableResource<TestDrawable>(null) {
+      @NonNull
       @Override
       public Class<TestDrawable> getResourceClass() {
         return TestDrawable.class;
@@ -75,30 +85,20 @@ public int getSize() {
       }
 
       @Override
-      public void recycle() {
-
-      }
+      public void recycle() {}
     };
   }
 
-  /**
-   * Just to have a type to test with which is not directly Drawable
-   */
+  /** Just to have a type to test with which is not directly Drawable */
   private static class TestDrawable extends Drawable {
     @Override
-    public void draw(Canvas canvas) {
-
-    }
+    public void draw(@NonNull Canvas canvas) {}
 
     @Override
-    public void setAlpha(int alpha) {
-
-    }
+    public void setAlpha(int alpha) {}
 
     @Override
-    public void setColorFilter(ColorFilter cf) {
-
-    }
+    public void setColorFilter(ColorFilter cf) {}
 
     @Override
     public int getOpacity() {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
index b1b5f3130..5e2c76048 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
@@ -4,6 +4,7 @@
 
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 import java.io.IOException;
 import org.junit.Before;
@@ -26,7 +27,7 @@ public void setUp() {
   @Test
   public void testReturnsGivenFileAsResource() throws IOException {
     File expected = new File("testFile");
-    Resource<File> decoded = decoder.decode(expected, 1, 1, options);
+    Resource<File> decoded = Preconditions.checkNotNull(decoder.decode(expected, 1, 1, options));
 
     assertEquals(expected, decoded.get());
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index 9383a7f0c..e9a43cf79 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -33,20 +33,20 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
+@Config(sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
-  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
-  static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+  private static final byte[] GIF_HEADER = new byte[] {0x47, 0x49, 0x46};
+  private static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
   private ByteBufferGifDecoder decoder;
   private GifHeader gifHeader;
   private Options options;
 
-  @Mock BitmapPool bitmapPool;
-  @Mock GifHeaderParser parser;
-  @Mock GifDecoder gifDecoder;
-  @Mock ByteBufferGifDecoder.GifHeaderParserPool parserPool;
-  @Mock ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private GifHeaderParser parser;
+  @Mock private GifDecoder gifDecoder;
+  @Mock private ByteBufferGifDecoder.GifHeaderParserPool parserPool;
+  @Mock private ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
 
   @Before
   public void setUp() {
@@ -56,11 +56,11 @@ public void setUp() {
     when(parser.parseHeader()).thenReturn(gifHeader);
     when(parserPool.obtain(isA(ByteBuffer.class))).thenReturn(parser);
 
-    when(decoderFactory.build(isA(GifDecoder.BitmapProvider.class),
-        eq(gifHeader), isA(ByteBuffer.class), anyInt()))
+    when(decoderFactory.build(
+            isA(GifDecoder.BitmapProvider.class), eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    List<ImageHeaderParser> parsers = new ArrayList<>();
     parsers.add(new DefaultImageHeaderParser());
 
     options = new Options();
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
similarity index 96%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
index c83dd1740..b72af3910 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
@@ -13,7 +13,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class GifDrawableResourceTest {
   private GifDrawable drawable;
   private GifDrawableResource resource;
@@ -40,5 +40,4 @@ public void testStopsAndThenRecyclesDrawableWhenRecycled() {
     inOrder.verify(drawable).stop();
     inOrder.verify(drawable).recycle();
   }
-
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index f947b4cc0..c3f056327 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -14,6 +14,7 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
@@ -24,19 +25,24 @@
 import android.graphics.PorterDuffColorFilter;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
 import android.os.Build;
+import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.gif.GifDrawableTest.BitmapTrackingShadowCanvas;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
 import java.util.HashSet;
 import java.util.Set;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
@@ -48,9 +54,12 @@
 import org.robolectric.shadows.ShadowCanvas;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18,
-    shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
+@Config(
+    sdk = 18,
+    shadows = {GlideShadowLooper.class, BitmapTrackingShadowCanvas.class})
 public class GifDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+
   private GifDrawable drawable;
   private int frameHeight;
   private int frameWidth;
@@ -58,10 +67,10 @@
   private int initialSdkVersion;
 
   @Mock private Drawable.Callback cb;
-  @Mock private BitmapPool bitmapPool;
   @Mock private GifFrameLoader frameLoader;
   @Mock private Paint paint;
   @Mock private Transformation<Bitmap> transformation;
+  private Application context;
 
   private static Paint isAPaint() {
     return isA(Paint.class);
@@ -74,10 +83,11 @@ private static Rect isARect() {
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
     frameWidth = 120;
     frameHeight = 450;
     firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-    drawable = new GifDrawable(frameLoader, bitmapPool, paint);
+    drawable = new GifDrawable(frameLoader, paint);
     when(frameLoader.getWidth()).thenReturn(frameWidth);
     when(frameLoader.getHeight()).thenReturn(frameHeight);
     when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
@@ -91,13 +101,14 @@ public void tearDown() {
     Util.setSdkVersionInt(initialSdkVersion);
   }
 
+  // containsExactly doesn't need its return value checked.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
     Canvas canvas = new Canvas();
     drawable.draw(canvas);
 
-    BitmapTrackingShadowCanvas shadowCanvas =
-        (BitmapTrackingShadowCanvas) Shadow.extract(canvas);
+    BitmapTrackingShadowCanvas shadowCanvas = Shadow.extract(canvas);
     assertThat(shadowCanvas.getDrawnBitmaps()).containsExactly(firstFrame);
   }
 
@@ -335,10 +346,15 @@ public void testReturnsSizeFromFrameLoader() {
   public void testReturnsNewDrawableFromConstantState() {
     Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     drawable =
-        new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
-            transformation, 100, 100, firstFrame);
-
-    assertNotNull(drawable.getConstantState().newDrawable());
+        new GifDrawable(
+            RuntimeEnvironment.application,
+            mock(GifDecoder.class),
+            transformation,
+            100,
+            100,
+            firstFrame);
+
+    assertNotNull(Preconditions.checkNotNull(drawable.getConstantState()).newDrawable());
     assertNotNull(
         drawable.getConstantState().newDrawable(RuntimeEnvironment.application.getResources()));
   }
@@ -499,7 +515,6 @@ public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsFo
     assertTrue("drawable should be still running", drawable.isRunning());
   }
 
-
   @Test
   public void testDoesNotDrawFrameAfterRecycle() {
     Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
@@ -523,8 +538,8 @@ public void testSetsFrameTransformationOnFrameManager() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfConstructedWithNullFirstFrame() {
-    new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
-        transformation, 100, 100, null);
+    new GifDrawable(
+        RuntimeEnvironment.application, mock(GifDecoder.class), transformation, 100, 100, null);
   }
 
   @Test
@@ -549,7 +564,12 @@ public void testSetAlphaSetsAlphaOnPaint() {
   public void testSetColorFilterSetsColorFilterOnPaint() {
     ColorFilter colorFilter = new PorterDuffColorFilter(Color.RED, Mode.ADD);
     drawable.setColorFilter(colorFilter);
-    verify(paint).setColorFilter(eq(colorFilter));
+
+    // Use ArgumentCaptor instead of eq() due to b/73121412 where ShadowPorterDuffColorFilter.equals
+    // uses a method that can't be found (PorterDuffColorFilter.getColor).
+    ArgumentCaptor<ColorFilter> captor = ArgumentCaptor.forClass(ColorFilter.class);
+    verify(paint).setColorFilter(captor.capture());
+    assertThat(captor.getValue()).isSameInstanceAs(colorFilter);
   }
 
   @Test
@@ -567,6 +587,30 @@ public void testThrowsIfCreatedWithNullState() {
     new GifDrawable(null);
   }
 
+  @Test
+  public void onFrameReady_whenAttachedToDrawableCallbackButNotViewCallback_stops() {
+    TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] {drawable});
+    drawable.setCallback(topLevel);
+    topLevel.setCallback(null);
+
+    drawable.start();
+    drawable.onFrameReady();
+
+    assertThat(drawable.isRunning()).isFalse();
+  }
+
+  @Test
+  public void onFrameReady_whenAttachedtoDrawableCallbackWithViewCallbackParent_doesNotStop() {
+    TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] {drawable});
+    drawable.setCallback(topLevel);
+    topLevel.setCallback(new View(context));
+
+    drawable.start();
+    drawable.onFrameReady();
+
+    assertThat(drawable.isRunning()).isTrue();
+  }
+
   private void verifyRanLoops(int loopCount, int frameCount) {
     // 1 for invalidate in start().
     verify(cb, times(1 + loopCount * frameCount)).invalidateDrawable(eq(drawable));
@@ -576,26 +620,26 @@ private void runLoops(int loopCount, int frameCount) {
     for (int loop = 0; loop < loopCount; loop++) {
       for (int frame = 0; frame < frameCount; frame++) {
         when(frameLoader.getCurrentIndex()).thenReturn(frame);
-        assertTrue("drawable should be started before calling drawable.onFrameReady()",
+        assertTrue(
+            "drawable should be started before calling drawable.onFrameReady()",
             drawable.isRunning());
         drawable.onFrameReady();
       }
     }
   }
 
-  /**
-   * Keeps track of the set of Bitmaps drawn to the canvas.
-   */
+  /** Keeps track of the set of Bitmaps drawn to the canvas. */
   @Implements(Canvas.class)
-  public static class BitmapTrackingShadowCanvas extends ShadowCanvas {
+  public static final class BitmapTrackingShadowCanvas extends ShadowCanvas {
     private final Set<Bitmap> drawnBitmaps = new HashSet<>();
 
     @Implementation
+    @Override
     public void drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) {
       drawnBitmaps.add(bitmap);
     }
 
-    public Iterable<Bitmap> getDrawnBitmaps() {
+    private Iterable<Bitmap> getDrawnBitmaps() {
       return drawnBitmaps;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
similarity index 75%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index f73dc91a5..cbf6cea88 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -18,12 +18,13 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -33,10 +34,11 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class GifDrawableTransformationTest {
-  @Mock Transformation<Bitmap> wrapped;
-  @Mock BitmapPool bitmapPool;
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Transformation<Bitmap> wrapped;
+  @Mock private BitmapPool bitmapPool;
 
   private GifDrawableTransformation transformation;
   private Context context;
@@ -46,7 +48,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = RuntimeEnvironment.application;
 
-    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     transformation = new GifDrawableTransformation(wrapped);
   }
 
@@ -84,13 +86,24 @@ public void testSetsTransformationAsFrameTransformation() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("first")).when(wrapped)
+    doAnswer(new Util.WriteDigest("first"))
+        .when(wrapped)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped));
-
-    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
+    @SuppressWarnings("unchecked")
+    Transformation<Bitmap> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other"))
+        .when(other)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other));
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new GifDrawableTransformation(wrapped),
+            new GifDrawableTransformation(wrapped))
+        .addEquivalenceGroup(wrapped)
+        .addEquivalenceGroup(new GifDrawableTransformation(other))
+        .addRegressionTest(
+            new GifDrawableTransformation(wrapped),
+            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
similarity index 60%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index d6db3458b..80b023adf 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -16,7 +16,7 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Message;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
@@ -27,11 +27,12 @@
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
@@ -42,14 +43,15 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class GifFrameLoaderTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
 
-  @Mock GifFrameLoader.FrameCallback callback;
-  @Mock GifDecoder gifDecoder;
-  @Mock Handler handler;
-  @Mock Transformation<Bitmap> transformation;
-  @Mock RequestManager requestManager;
+  @Mock private GifFrameLoader.FrameCallback callback;
+  @Mock private GifDecoder gifDecoder;
+  @Mock private Handler handler;
+  @Mock private Transformation<Bitmap> transformation;
+  @Mock private RequestManager requestManager;
   private GifFrameLoader loader;
   private RequestBuilder<Bitmap> requestBuilder;
   private Bitmap firstFrame;
@@ -70,22 +72,20 @@ public void setUp() {
     loader = createGifFrameLoader(handler);
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
   @NonNull
   private GifFrameLoader createGifFrameLoader(Handler handler) {
     Glide glide = getGlideSingleton();
-    return new GifFrameLoader(
-        glide.getBitmapPool(),
-        requestManager,
-        gifDecoder,
-        handler,
-        requestBuilder,
-        transformation,
-        firstFrame);
+    GifFrameLoader result =
+        new GifFrameLoader(
+            glide.getBitmapPool(),
+            requestManager,
+            gifDecoder,
+            handler,
+            requestBuilder,
+            transformation,
+            firstFrame);
+    result.subscribe(callback);
+    return result;
   }
 
   private static Glide getGlideSingleton() {
@@ -95,10 +95,11 @@ private static Glide getGlideSingleton() {
   @SuppressWarnings("unchecked")
   @Test
   public void testSetFrameTransformationSetsTransformationOnRequestBuilder() {
+    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
     Transformation<Bitmap> transformation = mock(Transformation.class);
     loader.setFrameTransformation(transformation, firstFrame);
 
-    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
+    verify(requestBuilder, times(3)).apply(isA(RequestOptions.class));
   }
 
   @Test(expected = NullPointerException.class)
@@ -115,15 +116,11 @@ public void testReturnsSizeFromGifDecoderAndCurrentFrame() {
 
   @Test
   public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
-    loader.subscribe(callback);
-
     verify(requestBuilder).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingLoad() {
-    loader.subscribe(callback);
-
     InOrder order = inOrder(gifDecoder, requestBuilder);
     order.verify(gifDecoder).advance();
     order.verify(requestBuilder).apply(isA(RequestOptions.class));
@@ -147,7 +144,6 @@ public void testGetCurrentFrameReturnsCurrentBitmapAfterLoadHasCompleted() {
 
   @Test
   public void testStartDoesNotStartIfAlreadyRunning() {
-    loader.subscribe(callback);
     loader.subscribe(mock(FrameCallback.class));
 
     verify(requestBuilder, times(1)).into(aTarget());
@@ -155,14 +151,15 @@ public void testStartDoesNotStartIfAlreadyRunning() {
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
+    verify(requestBuilder, times(1)).into(aTarget());
+    loader.unsubscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, never()).into(aTarget());
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
-    loader.subscribe(callback);
     loader.unsubscribe(callback);
     loader.subscribe(callback);
 
@@ -171,7 +168,6 @@ public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
 
   @Test
   public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
-    loader.subscribe(callback);
     loader.unsubscribe(callback);
 
     loader.onFrameReady(mock(DelayTarget.class));
@@ -182,7 +178,6 @@ public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
 
   @Test
   public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
-    loader.subscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
     verify(requestBuilder, times(2)).into(aTarget());
@@ -193,10 +188,11 @@ public void testOnFrameReadyClearsPreviousFrame() {
     // Force the loader to create a real Handler.
     loader = createGifFrameLoader(null);
 
-    DelayTarget previous = mock(DelayTarget.class);
+    DelayTarget previous = newDelayTarget();
     Request previousRequest = mock(Request.class);
-    when(previous.getRequest()).thenReturn(previousRequest);
-    when(previous.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    previous.setRequest(previousRequest);
+    previous.onResourceReady(
+        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), /*transition=*/ null);
 
     DelayTarget current = mock(DelayTarget.class);
     when(current.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
@@ -211,10 +207,10 @@ public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
     // Force the loader to create a real Handler by passing null.
     loader = createGifFrameLoader(null);
 
-    DelayTarget previous = mock(DelayTarget.class);
+    DelayTarget previous = newDelayTarget();
     Request previousRequest = mock(Request.class);
-    when(previous.getRequest()).thenReturn(previousRequest);
-    when(previous.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    previous.setRequest(previousRequest);
+    previous.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null);
 
     DelayTarget current = mock(DelayTarget.class);
     when(current.getResource()).thenReturn(null);
@@ -228,8 +224,9 @@ public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
   public void testDelayTargetSendsMessageWithHandlerDelayed() {
     long targetTime = 1234;
     DelayTarget delayTarget = new DelayTarget(handler, 1, targetTime);
-    delayTarget.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
-    /*glideAnimation*/);
+    delayTarget.onResourceReady(
+        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+        /*glideAnimation*/ );
     verify(handler).sendMessageAtTime(isA(Message.class), eq(targetTime));
   }
 
@@ -247,9 +244,9 @@ public void testClearsCompletedLoadOnFrameReadyIfCleared() {
     // Force the loader to create a real Handler by passing null;
     loader = createGifFrameLoader(null);
     loader.clear();
-    DelayTarget delayTarget = mock(DelayTarget.class);
+    DelayTarget delayTarget = newDelayTarget();
     Request request = mock(Request.class);
-    when(delayTarget.getRequest()).thenReturn(request);
+    delayTarget.setRequest(request);
 
     loader.onFrameReady(delayTarget);
 
@@ -258,7 +255,7 @@ public void testClearsCompletedLoadOnFrameReadyIfCleared() {
 
   @Test
   public void
-  testDoesNotReturnResourceForCompletedFrameInGetCurrentFrameIfLoadCompletesWhileCleared() {
+      testDoesNotReturnResourceForCompletedFrameInGetCurrentFrameIfLoadCompletesWhileCleared() {
     loader.clear();
     DelayTarget delayTarget = mock(DelayTarget.class);
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
@@ -269,6 +266,99 @@ public void testClearsCompletedLoadOnFrameReadyIfCleared() {
     assertNull(loader.getCurrentFrame());
   }
 
+  @Test
+  public void onFrameReady_whenNotRunning_doesNotClearPreviouslyLoadedImage() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+    verify(requestManager, never()).clear(loaded);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_clearsPendingFrameOnClear() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+
+    loader.clear();
+    verify(requestManager).clear(loaded);
+    verify(requestManager).clear(nextFrame);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_clearsOldFrameOnStart() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+
+    loader.subscribe(callback);
+    verify(requestManager).clear(loaded);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_callsFrameReadyWithNewFrameOnStart() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(nextFrame.getResource()).thenReturn(expected);
+    loader.onFrameReady(nextFrame);
+
+    verify(callback, times(1)).onFrameReady();
+    loader.subscribe(callback);
+    verify(callback, times(2)).onFrameReady();
+    assertThat(loader.getCurrentFrame()).isEqualTo(expected);
+  }
+
+  @Test
+  public void startFromFirstFrame_withPendingFrame_clearsPendingFrame() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(nextFrame.getResource()).thenReturn(expected);
+    loader.onFrameReady(nextFrame);
+
+    loader.setNextStartFromFirstFrame();
+    verify(requestManager).clear(nextFrame);
+
+    loader.subscribe(callback);
+    verify(callback, times(1)).onFrameReady();
+  }
+
+  private DelayTarget newDelayTarget() {
+    return new DelayTarget(handler, /*index=*/ 0, /*targetTime=*/ 0);
+  }
+
   @SuppressWarnings("unchecked")
   private static Target<Bitmap> aTarget() {
     return isA(Target.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
index 18c379433..e9fa2d914 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
@@ -17,7 +18,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class GifFrameResourceDecoderTest {
   private GifDecoder gifDecoder;
   private GifFrameResourceDecoder resourceDecoder;
@@ -35,7 +36,9 @@ public void testReturnsFrameFromGifDecoder() throws IOException {
     Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(gifDecoder.getNextFrame()).thenReturn(expected);
 
-    assertEquals(expected, resourceDecoder.decode(gifDecoder, 100, 100, options).get());
+    assertEquals(
+        expected,
+        Preconditions.checkNotNull(resourceDecoder.decode(gifDecoder, 100, 100, options)).get());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index 0ab16c3de..75182fbbd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -21,12 +21,11 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class StreamGifDecoderTest {
-  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+  private static final byte[] GIF_HEADER = new byte[] {0x47, 0x49, 0x46};
 
-  @Mock
-  ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
+  @Mock private ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private StreamGifDecoder decoder;
   private Options options;
 
@@ -34,7 +33,7 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    List<ImageHeaderParser> parsers = new ArrayList<>();
     parsers.add(new DefaultImageHeaderParser());
 
     decoder = new StreamGifDecoder(parsers, byteBufferDecoder, new LruArrayPool());
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
similarity index 58%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index b4379c750..d180f6196 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -8,15 +8,16 @@
 import android.graphics.Bitmap;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Preconditions;
+import java.io.ByteArrayOutputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapBytesTranscoderTest {
   private BitmapBytesTranscoderHarness harness;
 
@@ -27,29 +28,26 @@ public void setUp() {
 
   @Test
   public void testReturnsBytesOfGivenBitmap() {
-    String transcodedDescription = harness.getTranscodedDescription();
-    assertThat(transcodedDescription).startsWith(harness.description);
+    assertThat(harness.getTranscodeResult()).isEqualTo(harness.getExpectedData());
   }
 
   @Test
   public void testUsesGivenQuality() {
     harness.quality = 66;
-    String transcodedDescription = harness.getTranscodedDescription();
-    assertThat(transcodedDescription).contains(String.valueOf(harness.quality));
+    assertThat(harness.getTranscodeResult()).isEqualTo(harness.getExpectedData());
   }
 
   @Test
   public void testUsesGivenFormat() {
     for (Bitmap.CompressFormat format : Bitmap.CompressFormat.values()) {
       harness.compressFormat = format;
-      String transcodedDescription = harness.getTranscodedDescription();
-      assertThat(transcodedDescription).contains(format.name());
+      assertThat(harness.getTranscodeResult()).isEqualTo(harness.getExpectedData());
     }
   }
 
   @Test
   public void testBitmapResourceIsRecycled() {
-    harness.getTranscodedDescription();
+    harness.getTranscodeResult();
 
     verify(harness.bitmapResource).recycle();
   }
@@ -57,21 +55,26 @@ public void testBitmapResourceIsRecycled() {
   private static class BitmapBytesTranscoderHarness {
     Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
     int quality = 100;
-    final String description = "TestDescription";
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    Resource<Bitmap> bitmapResource = mockResource();
-    Options options = new Options();
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    final Resource<Bitmap> bitmapResource = mockResource();
+    final Options options = new Options();
 
-    public BitmapBytesTranscoderHarness() {
+    BitmapBytesTranscoderHarness() {
       when(bitmapResource.get()).thenReturn(bitmap);
-      Shadows.shadowOf(bitmap).setDescription(description);
     }
 
-    public String getTranscodedDescription() {
+    byte[] getTranscodeResult() {
       BitmapBytesTranscoder transcoder = new BitmapBytesTranscoder(compressFormat, quality);
-      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource, options);
+      Resource<byte[]> bytesResource =
+          Preconditions.checkNotNull(transcoder.transcode(bitmapResource, options));
 
-      return new String(bytesResource.get());
+      return bytesResource.get();
+    }
+
+    byte[] getExpectedData() {
+      ByteArrayOutputStream os = new ByteArrayOutputStream();
+      bitmap.compress(compressFormat, quality, os);
+      return os.toByteArray();
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
index 0707a342a..795c6de09 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -2,14 +2,12 @@
 
 import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,14 +16,13 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapDrawableTranscoderTest {
   private BitmapDrawableTranscoder transcoder;
 
   @Before
   public void setUp() {
-    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources(),
-        mock(BitmapPool.class));
+    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index d1cd38b01..e57e32d9d 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,8 +31,8 @@ public void setUp() {
 
   @Test
   public void testReturnsBytesOfGivenGifDrawable() {
-    for (String fakeData : new String[] { "test", "1235asfklaw3", "@$@#" }) {
-      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes());
+    for (String fakeData : new String[] {"test", "1235asfklaw3", "@$@#"}) {
+      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes(Charset.defaultCharset()));
       when(gifDrawable.getBuffer()).thenReturn(expected);
 
       Resource<byte[]> transcoded = transcoder.transcode(resource, new Options());
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
similarity index 75%
rename from library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
index e78445533..f9407bccb 100644
--- a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
@@ -12,7 +12,7 @@
 import org.robolectric.shadows.ShadowApplication;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class DefaultConnectivityMonitorFactoryTest {
   private ConnectivityMonitorFactory factory;
 
@@ -24,15 +24,17 @@ public void setUp() {
   @Test
   public void testReturnsDefaultConnectivityMonitorWhenHasPermission() {
     ShadowApplication.getInstance().grantPermissions("android.permission.ACCESS_NETWORK_STATE");
-    ConnectivityMonitor connectivityMonitor = factory.build(RuntimeEnvironment.application,
-        mock(ConnectivityMonitor.ConnectivityListener.class));
+    ConnectivityMonitor connectivityMonitor =
+        factory.build(
+            RuntimeEnvironment.application, mock(ConnectivityMonitor.ConnectivityListener.class));
     assertThat(connectivityMonitor).isInstanceOf(DefaultConnectivityMonitor.class);
   }
 
   @Test
   public void testReturnsNullConnectivityMonitorWhenDoesNotHavePermission() {
-    ConnectivityMonitor connectivityMonitor = factory.build(RuntimeEnvironment.application,
-        mock(ConnectivityMonitor.ConnectivityListener.class));
+    ConnectivityMonitor connectivityMonitor =
+        factory.build(
+            RuntimeEnvironment.application, mock(ConnectivityMonitor.ConnectivityListener.class));
     assertThat(connectivityMonitor).isInstanceOf(NullConnectivityMonitor.class);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
similarity index 58%
rename from library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index 32fa7111b..24ed89aa8 100644
--- a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -3,7 +3,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
@@ -12,28 +11,35 @@
 import android.content.Intent;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import com.bumptech.glide.manager.DefaultConnectivityMonitorTest.PermissionConnectivityManager;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.shadows.ShadowConnectivityManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18, shadows = PermissionConnectivityManager.class)
 public class DefaultConnectivityMonitorTest {
-  private ConnectivityMonitor.ConnectivityListener listener;
+  @Mock private ConnectivityMonitor.ConnectivityListener listener;
   private DefaultConnectivityMonitor monitor;
+  private ConnectivityHarness harness;
 
   @Before
   public void setUp() {
-    listener = mock(ConnectivityMonitor.ConnectivityListener.class);
+    MockitoAnnotations.initMocks(this);
     monitor = new DefaultConnectivityMonitor(RuntimeEnvironment.application, listener);
+    harness = new ConnectivityHarness();
   }
 
   @Test
@@ -69,7 +75,6 @@ public void testHandlesUnregisteringTwiceInARow() {
 
   @Test
   public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.connect();
 
     monitor.onStart();
@@ -80,7 +85,6 @@ public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
 
   @Test
   public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.connect();
 
     monitor.onStart();
@@ -92,7 +96,6 @@ public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
 
   @Test
   public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.disconnect();
 
     monitor.onStart();
@@ -104,7 +107,6 @@ public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
 
   @Test
   public void testDoesNotNotifyListenerWhenNotRegistered() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.disconnect();
 
     monitor.onStart();
@@ -115,33 +117,82 @@ public void testDoesNotNotifyListenerWhenNotRegistered() {
     verify(listener, never()).onConnectivityChanged(anyBoolean());
   }
 
+  @Test
+  public void register_withMissingPermission_doesNotThrow() {
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+
+    monitor.onStart();
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_doesNotThrow() {
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_previouslyDisconnected_notifiesListenersConnected() {
+    harness.disconnect();
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+
+    verify(listener).onConnectivityChanged(true);
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_previouslyConnected_doesNotNotifyListeners() {
+    harness.connect();
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+
+    verify(listener, never()).onConnectivityChanged(anyBoolean());
+  }
+
   private List<BroadcastReceiver> getConnectivityReceivers() {
     Intent connectivity = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
     return ShadowApplication.getInstance().getReceiversForIntent(connectivity);
   }
 
   private static class ConnectivityHarness {
-    private final ShadowConnectivityManager shadowConnectivityManager;
+    private final PermissionConnectivityManager shadowConnectivityManager;
 
     public ConnectivityHarness() {
-      ConnectivityManager connectivityManager = (ConnectivityManager) RuntimeEnvironment.application
-          .getSystemService(Context.CONNECTIVITY_SERVICE);
-      shadowConnectivityManager = Shadows.shadowOf(connectivityManager);
+      ConnectivityManager connectivityManager =
+          (ConnectivityManager)
+              RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE);
+      shadowConnectivityManager = Shadow.extract(connectivityManager);
     }
 
-    public void disconnect() {
+    void disconnect() {
       shadowConnectivityManager.setActiveNetworkInfo(null);
     }
 
-    public void connect() {
+    void connect() {
       NetworkInfo networkInfo =
           ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.CONNECTED, 0, 0, true, true);
       shadowConnectivityManager.setActiveNetworkInfo(networkInfo);
     }
 
-    public void broadcast() {
+    void broadcast() {
       Intent connected = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
-      ShadowApplication.getInstance().sendBroadcast(connected);
+      RuntimeEnvironment.application.sendBroadcast(connected);
+    }
+  }
+
+  @Implements(ConnectivityManager.class)
+  public static final class PermissionConnectivityManager extends ShadowConnectivityManager {
+    private boolean isNetworkPermissionGranted = true;
+
+    @Implementation
+    @Override
+    public NetworkInfo getActiveNetworkInfo() {
+      if (!isNetworkPermissionGranted) {
+        throw new SecurityException();
+      }
+      return super.getActiveNetworkInfo();
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
similarity index 71%
rename from library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
rename to library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
index 570026f5d..c8865c5a7 100644
--- a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -2,25 +2,24 @@
 
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.os.Build;
 import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.view.ViewPager;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.RequiresApi;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentPagerAdapter;
+import androidx.viewpager.widget.ViewPager;
 import com.bumptech.glide.Glide;
 
-/**
- * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
- */
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+/** A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117. */
+@RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 class Issue117Activity extends FragmentActivity {
   @Override
   protected void onCreate(Bundle savedInstanceState) {
@@ -33,7 +32,7 @@ protected void onCreate(Bundle savedInstanceState) {
 
   private static class Issue117Adapter extends FragmentPagerAdapter {
 
-    public Issue117Adapter(FragmentManager fm) {
+    Issue117Adapter(FragmentManager fm) {
       super(fm);
     }
 
@@ -50,8 +49,8 @@ public int getCount() {
 
   public static class Issue117Fragment extends Fragment {
     @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container,
-        Bundle savedInstanceState) {
+    public View onCreateView(
+        @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
       return new Issue117ImageView(getActivity());
     }
   }
@@ -68,4 +67,3 @@ protected void onAttachedToWindow() {
     }
   }
 }
-
diff --git a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java b/library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
similarity index 98%
rename from library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
index df8bce1ae..93d67468d 100644
--- a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
@@ -13,7 +13,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class LifecycleTest {
 
   private ActivityFragmentLifecycle lifecycle;
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 709573fed..72d6d5805 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -7,7 +7,7 @@
 import static org.mockito.Mockito.verify;
 
 import android.app.Activity;
-import android.support.v4.app.FragmentActivity;
+import androidx.fragment.app.FragmentActivity;
 import com.bumptech.glide.RequestManager;
 import org.junit.Before;
 import org.junit.Test;
@@ -19,103 +19,112 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class RequestManagerFragmentTest {
   private static final String TAG = "tag";
   private Harness[] harnesses;
 
   @Before
   public void setUp() {
-    harnesses = new Harness[] { new RequestManagerHarness(), new SupportRequestManagerHarness() };
+    harnesses = new Harness[] {new RequestManagerHarness(), new SupportRequestManagerHarness()};
   }
 
   @Test
   public void testSupportCanSetAndGetRequestManager() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        RequestManager manager = mock(RequestManager.class);
-        harness.setRequestManager(manager);
-        assertEquals(manager, harness.getManager());
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            RequestManager manager = mock(RequestManager.class);
+            harness.setRequestManager(manager);
+            assertEquals(manager, harness.getManager());
+          }
+        });
   }
 
   @Test
   public void testReturnsLifecycle() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        assertEquals(harness.getHarnessLifecycle(), harness.getFragmentLifecycle());
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            assertEquals(harness.getHarnessLifecycle(), harness.getFragmentLifecycle());
+          }
+        });
   }
 
   @Test
   public void testDoesNotAddNullRequestManagerToLifecycleWhenSet() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.setRequestManager(null);
-        verify(harness.getHarnessLifecycle(), never()).addListener(any(LifecycleListener.class));
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.setRequestManager(null);
+            verify(harness.getHarnessLifecycle(), never())
+                .addListener(any(LifecycleListener.class));
+          }
+        });
   }
 
   @Test
   public void testCallsLifecycleStart() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.getController().start();
-
-        verify(harness.getHarnessLifecycle()).onStart();
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.getController().start();
+
+            verify(harness.getHarnessLifecycle()).onStart();
+          }
+        });
   }
 
   @Test
   public void testCallsRequestManagerStop() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.getController().start().resume().pause().stop();
-
-        verify(harness.getHarnessLifecycle()).onStop();
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.getController().start().resume().pause().stop();
+
+            verify(harness.getHarnessLifecycle()).onStop();
+          }
+        });
   }
 
   @Test
   public void testCallsRequestManagerDestroy() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.getController().start().resume().pause().stop().destroy();
-
-        verify(harness.getHarnessLifecycle()).onDestroy();
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.getController().start().resume().pause().stop().destroy();
+
+            verify(harness.getHarnessLifecycle()).onDestroy();
+          }
+        });
   }
 
   @Test
   public void testOnLowMemoryCallOnNullRequestManagerDoesNotCrash() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.onLowMemory();
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.onLowMemory();
+          }
+        });
   }
 
   @Test
   public void testOnTrimMemoryCallOnNullRequestManagerDoesNotCrash() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.onTrimMemory(100 /*level*/);
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.onTrimMemory(100 /*level*/);
+          }
+        });
   }
 
   private void runTest(TestCase testCase) {
@@ -129,7 +138,7 @@ private void runTest(TestCase testCase) {
   }
 
   private interface TestCase {
-    public void runTest(Harness harness);
+    void runTest(Harness harness);
   }
 
   private interface Harness {
@@ -145,9 +154,10 @@ private void runTest(TestCase testCase) {
 
     void onLowMemory();
 
-    void onTrimMemory(int level);
+    void onTrimMemory(@SuppressWarnings("SameParameterValue") int level);
   }
 
+  @SuppressWarnings("deprecation")
   private static class RequestManagerHarness implements Harness {
     private final ActivityController<Activity> controller;
     private final RequestManagerFragment fragment;
@@ -156,14 +166,8 @@ private void runTest(TestCase testCase) {
     public RequestManagerHarness() {
       fragment = new RequestManagerFragment(lifecycle);
       controller = Robolectric.buildActivity(Activity.class).create();
-      controller.get()
-          .getFragmentManager()
-          .beginTransaction()
-          .add(fragment, TAG)
-          .commit();
-      controller.get()
-          .getFragmentManager()
-          .executePendingTransactions();
+      controller.get().getFragmentManager().beginTransaction().add(fragment, TAG).commit();
+      controller.get().getFragmentManager().executePendingTransactions();
     }
 
     @Override
@@ -216,7 +220,8 @@ public SupportRequestManagerHarness() {
       supportFragment = new SupportRequestManagerFragment(lifecycle);
       supportController = Robolectric.buildActivity(FragmentActivity.class).create();
 
-      supportController.get()
+      supportController
+          .get()
           .getSupportFragmentManager()
           .beginTransaction()
           .add(supportFragment, TAG)
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
similarity index 69%
rename from library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index 97884942a..0d1b40e24 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -9,44 +9,56 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.os.Build;
+import android.os.Handler;
 import android.os.Looper;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
+import android.view.LayoutInflater;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
+import androidx.fragment.app.FragmentController;
+import androidx.fragment.app.FragmentHostCallback;
+import androidx.test.core.app.ApplicationProvider;
 import com.bumptech.glide.RequestManager;
-import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.BackgroundUtil.BackgroundTester;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
+@Config(sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerRetrieverTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   private static final String PARENT_TAG = "parent";
+  private Context appContext;
   private RetrieverHarness[] harnesses;
   private RequestManagerRetriever retriever;
   private int initialSdkVersion;
 
   @Before
   public void setUp() {
-    retriever = new RequestManagerRetriever(null /*factory*/);
+    appContext = ApplicationProvider.getApplicationContext();
+
+    retriever = new RequestManagerRetriever(/*factory=*/ null);
 
     harnesses =
-        new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
+        new RetrieverHarness[] {new DefaultRetrieverHarness(), new SupportRetrieverHarness()};
 
     initialSdkVersion = Build.VERSION.SDK_INT;
     Util.setSdkVersionInt(18);
@@ -111,8 +123,8 @@ public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExisti
 
   @Test
   public void testHasValidTag() {
-    assertEquals(RequestManagerRetriever.class.getPackage().getName(),
-        RequestManagerRetriever.FRAGMENT_TAG);
+    assertEquals(
+        RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.FRAGMENT_TAG);
   }
 
   @Test
@@ -130,6 +142,7 @@ public void testSupportCanGetRequestManagerFromActivity() {
     assertEquals(manager, retriever.get(fragmentActivity));
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   public void testCanGetRequestManagerFromFragment() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -153,6 +166,23 @@ public void testSupportCanGetRequestManagerFromFragment() {
     assertEquals(manager, retriever.get(fragment));
   }
 
+  @Test
+  public void testSupportCanGetRequestManagerFromFragment_nonActivityController() {
+    FragmentController controller =
+        FragmentController.createController(new NonActivityHostCallback(appContext));
+    controller.attachHost(/*fragment=*/ null);
+    controller.dispatchCreate();
+    controller.dispatchStart();
+    controller.dispatchResume();
+
+    Fragment fragment = new Fragment();
+    controller.getSupportFragmentManager().beginTransaction().add(fragment, PARENT_TAG).commit();
+    controller.getSupportFragmentManager().executePendingTransactions();
+
+    RequestManager manager = retriever.get(fragment);
+    assertEquals(manager, retriever.get(fragment));
+  }
+
   @Test
   public void testCanGetRequestManagerFromDetachedFragment() {
     helpTestCanGetRequestManagerFromDetachedFragment();
@@ -164,10 +194,15 @@ public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
     helpTestCanGetRequestManagerFromDetachedFragment();
   }
 
+  @SuppressWarnings("deprecation")
   private void helpTestCanGetRequestManagerFromDetachedFragment() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
     android.app.Fragment fragment = new android.app.Fragment();
-    activity.getFragmentManager().beginTransaction().add(fragment, PARENT_TAG).detach(fragment)
+    activity
+        .getFragmentManager()
+        .beginTransaction()
+        .add(fragment, PARENT_TAG)
+        .detach(fragment)
         .commit();
     activity.getFragmentManager().executePendingTransactions();
 
@@ -190,14 +225,19 @@ private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
     FragmentActivity activity =
         Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
     Fragment fragment = new Fragment();
-    activity.getSupportFragmentManager().beginTransaction().add(fragment, PARENT_TAG)
-        .detach(fragment).commit();
+    activity
+        .getSupportFragmentManager()
+        .beginTransaction()
+        .add(fragment, PARENT_TAG)
+        .detach(fragment)
+        .commit();
     activity.getSupportFragmentManager().executePendingTransactions();
 
     assertTrue(fragment.isDetached());
     retriever.get(fragment);
   }
 
+  @SuppressWarnings("deprecation")
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfFragmentNotAttached() {
     android.app.Fragment fragment = new android.app.Fragment();
@@ -256,40 +296,66 @@ public void testHandlesContextWrappersForActivities() {
 
   @Test
   public void testHandlesContextWrappersForApplication() {
-    ContextWrapper contextWrapper = new ContextWrapper(RuntimeEnvironment.application);
-    RequestManager requestManager = retriever.get(RuntimeEnvironment.application);
+    ContextWrapper contextWrapper = new ContextWrapper(appContext);
+    RequestManager requestManager = retriever.get(appContext);
 
     assertEquals(requestManager, retriever.get(contextWrapper));
   }
 
+  @Test
+  public void testHandlesContextWrapperWithoutApplication() throws Exception {
+    // Create a Context which is not associated with an Application instance.
+    Context baseContext =
+        appContext.createPackageContext(appContext.getPackageName(), /*flags=*/ 0);
+
+    // Sanity-check that Robolectric behaves the same as the framework.
+    assertThat(baseContext.getApplicationContext()).isNull();
+
+    // If a wrapper provides a non-null application Context, unwrapping should terminate at this
+    // wrapper so that the returned Context has a non-null #getApplicationContext.
+    Context contextWithApplicationContext =
+        new ContextWrapper(baseContext) {
+          @Override
+          public Context getApplicationContext() {
+            return this;
+          }
+        };
+
+    Context wrappedContext = new ContextWrapper(contextWithApplicationContext);
+    RequestManager requestManager = retriever.get(appContext);
+
+    assertEquals(requestManager, retriever.get(wrappedContext));
+  }
+
   @Test
   public void testReturnsNonNullManagerIfGivenApplicationContext() {
-    assertNotNull(retriever.get(RuntimeEnvironment.application));
+    assertNotNull(retriever.get(appContext));
   }
 
   @Test
   public void testApplicationRequestManagerIsNotPausedWhenRetrieved() {
-    RequestManager manager = retriever.get(RuntimeEnvironment.application);
+    RequestManager manager = retriever.get(appContext);
     assertFalse(manager.isPaused());
   }
 
   @Test
   public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
-    RequestManager manager = retriever.get(RuntimeEnvironment.application);
+    RequestManager manager = retriever.get(appContext);
     manager.pauseRequests();
-    manager = retriever.get(RuntimeEnvironment.application);
+    manager = retriever.get(appContext);
     assertTrue(manager.isPaused());
   }
 
   @Test
   public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread()
       throws InterruptedException {
-    testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() throws Exception {
-        retriever.get(RuntimeEnvironment.application);
-      }
-    });
+    testInBackground(
+        new BackgroundTester() {
+          @Override
+          public void runTest() {
+            retriever.get(appContext);
+          }
+        });
   }
 
   // See Issue #117: https://github.com/bumptech/glide/issues/117.
@@ -305,7 +371,7 @@ public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -315,8 +381,9 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     assertNotNull(retriever.get(spyActivity));
   }
 
+  @SuppressWarnings("deprecation")
   @Test
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -339,16 +406,20 @@ public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     void addFragmentWithTag(String tag, RequestManager manager);
   }
 
-  public class DefaultRetrieverHarness implements RetrieverHarness {
+  final class DefaultRetrieverHarness implements RetrieverHarness {
     private final ActivityController<Activity> controller =
         Robolectric.buildActivity(Activity.class);
     private final android.app.Fragment parent;
 
-    public DefaultRetrieverHarness() {
+    DefaultRetrieverHarness() {
       this.parent = new android.app.Fragment();
 
       controller.create();
-      controller.get().getFragmentManager().beginTransaction().add(parent, PARENT_TAG)
+      controller
+          .get()
+          .getFragmentManager()
+          .beginTransaction()
+          .add(parent, PARENT_TAG)
           .commitAllowingStateLoss();
       controller.get().getFragmentManager().executePendingTransactions();
       controller.start().resume();
@@ -366,18 +437,24 @@ public RequestManager doGet() {
 
     @Override
     public boolean hasFragmentWithTag(String tag) {
-      return null != controller
-          .get()
-          .getFragmentManager()
-          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
+      return null
+          != controller
+              .get()
+              .getFragmentManager()
+              .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public void addFragmentWithTag(String tag, RequestManager requestManager) {
       RequestManagerFragment fragment = new RequestManagerFragment();
       fragment.setRequestManager(requestManager);
-      controller.get().getFragmentManager().beginTransaction()
-          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
+      controller
+          .get()
+          .getFragmentManager()
+          .beginTransaction()
+          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
+          .commitAllowingStateLoss();
       controller.get().getFragmentManager().executePendingTransactions();
     }
   }
@@ -391,7 +468,11 @@ public SupportRetrieverHarness() {
       this.parent = new Fragment();
 
       controller.create();
-      controller.get().getSupportFragmentManager().beginTransaction().add(parent, PARENT_TAG)
+      controller
+          .get()
+          .getSupportFragmentManager()
+          .beginTransaction()
+          .add(parent, PARENT_TAG)
           .commitAllowingStateLoss();
       controller.get().getSupportFragmentManager().executePendingTransactions();
       controller.start().resume();
@@ -409,17 +490,47 @@ public RequestManager doGet() {
 
     @Override
     public boolean hasFragmentWithTag(String tag) {
-      return controller.get().getSupportFragmentManager()
-          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG) != null;
+      return controller
+              .get()
+              .getSupportFragmentManager()
+              .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG)
+          != null;
     }
 
     @Override
     public void addFragmentWithTag(String tag, RequestManager manager) {
       SupportRequestManagerFragment fragment = new SupportRequestManagerFragment();
       fragment.setRequestManager(manager);
-      controller.get().getSupportFragmentManager().beginTransaction()
-          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
+      controller
+          .get()
+          .getSupportFragmentManager()
+          .beginTransaction()
+          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
+          .commitAllowingStateLoss();
       controller.get().getSupportFragmentManager().executePendingTransactions();
     }
   }
+
+  /** Simple callback for creating an Activity-less Fragment host. */
+  private final class NonActivityHostCallback
+      extends FragmentHostCallback<RequestManagerRetrieverTest> {
+
+    private final Context context;
+
+    NonActivityHostCallback(Context context) {
+      super(context, new Handler(Looper.getMainLooper()), /*windowAnimations=*/ 0);
+      this.context = context;
+    }
+
+    @Override
+    public LayoutInflater onGetLayoutInflater() {
+      return LayoutInflater.from(context).cloneInContext(context);
+    }
+
+    @Nullable
+    @Override
+    public RequestManagerRetrieverTest onGetHost() {
+      return RequestManagerRetrieverTest.this;
+    }
+  }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
new file mode 100644
index 000000000..dbf11323e
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -0,0 +1,481 @@
+package com.bumptech.glide.manager;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.request.Request;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public class RequestTrackerTest {
+  private RequestTracker tracker;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    tracker = new RequestTracker();
+  }
+
+  @Test
+  public void clearRequests_doesNotRecycleRequests() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    tracker.clearRequests();
+
+    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withRequestPreviouslyClearedInClearRequests_doesNothing() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    tracker.clearRequests();
+    tracker.clearRemoveAndRecycle(request);
+
+    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsTrue() {
+    assertThat(tracker.clearRemoveAndRecycle(null)).isTrue();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
+    FakeRequest request = new FakeRequest();
+
+    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
+
+    assertThat(request.isCleared()).isFalse();
+    assertThat(request.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    assertThat(tracker.clearRemoveAndRecycle(request)).isTrue();
+    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isRecycled()).isTrue();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+    tracker.clearRemoveAndRecycle(request);
+    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
+
+    assertThat(request.isCleared()).isTrue();
+    assertThat(request.isRecycled()).isTrue();
+  }
+
+  @Test
+  public void clearRequests_withPreviouslyClearedRequest_doesNotClearRequestAgain() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+    tracker.clearRemoveAndRecycle(request);
+
+    tracker.clearRequests();
+
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void clearRequests_withMultipleRequests_clearsAllRequests() {
+    FakeRequest first = new FakeRequest();
+    FakeRequest second = new FakeRequest();
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.clearRequests();
+
+    assertThat(first.isCleared()).isTrue();
+    assertThat(second.isCleared()).isTrue();
+  }
+
+  @Test
+  public void pauseRequest_withRunningRequest_pausesRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsRunning();
+    tracker.addRequest(request);
+
+    tracker.pauseRequests();
+
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void pauseRequests_withCompletedRequest_doesNotClearRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    request.setIsComplete();
+    tracker.pauseRequests();
+
+    assertThat(request.isCleared()).isFalse();
+  }
+
+  @Test
+  public void runRequest_startsRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.runRequest(request);
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void runRequest_whenPaused_doesNotStartRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.pauseRequests();
+    tracker.runRequest(request);
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void runRequest_withAllRequestsPaused_doesNotStartRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.pauseAllRequests();
+    tracker.runRequest(request);
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void runRequest_afterPausingAndResuming_startsRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.pauseRequests();
+    tracker.runRequest(request);
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void pauseRequests_withFailedRequest_doesNotClearRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+    tracker.addRequest(request);
+
+    tracker.pauseRequests();
+
+    assertThat(request.isCleared()).isFalse();
+  }
+
+  @Test
+  public void resumeRequests_withRequestAddedWhilePaused_startsRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void resumeRequests_withCompletedRequest_doesNotRestartCompletedRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsComplete();
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void resumeRequests_withFailedRequest_restartsRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void addRequest_withRunningRequest_doesNotRestartRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsRunning();
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void resumeRequests_withRequestThatClearsAnotherRequest_avoidsConcurrentModifications() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).begin();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.resumeRequests();
+  }
+
+  @Test
+  public void pauseRequests_withRequestThatClearsAnother_avoidsConcurrentModifications() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    when(first.isRunning()).thenReturn(true);
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.pauseRequests();
+  }
+
+  @Test
+  public void clearRequests_withRequestThatClearsAnother_avoidsConcurrentModifications() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.clearRequests();
+  }
+
+  @Test
+  public void restartRequests_withRequestThatClearsAnother_avoidsConcurrentModifications() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.restartRequests();
+  }
+
+  @Test
+  public void restartRequests_withFailedRequest_restartsRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void restartRequests_withIncompleteRequest_restartsRequest() {
+    FakeRequest request = new FakeRequest();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  @Test
+  public void restartRequests_whenPaused_doesNotRestartRequests() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void restartRequests_withFailedRequestAddedWhilePaused_clearsFailedRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsFailed();
+
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void restartRequests_withIncompleteRequestAddedWhilePaused_doesNotRestartRequest() {
+    FakeRequest request = new FakeRequest();
+
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+    tracker.restartRequests();
+
+    assertThat(request.isRunning()).isFalse();
+  }
+
+  @Test
+  public void restartRequests_withIncompleteRequestAddedWhilePaused_clearsRequestOnRestart() {
+    FakeRequest request = new FakeRequest();
+
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+    tracker.restartRequests();
+
+    assertThat(request.isCleared()).isTrue();
+  }
+
+  @Test
+  public void testReturnsTrueFromIsPausedWhenPaused() {
+    tracker.pauseRequests();
+    assertTrue(tracker.isPaused());
+  }
+
+  @Test
+  public void testReturnsFalseFromIsPausedWhenResumed() {
+    tracker.resumeRequests();
+    assertFalse(tracker.isPaused());
+  }
+
+  @Test
+  public void testPauseAllRequests_returnsTrueFromIsPaused() {
+    tracker.pauseAllRequests();
+    assertTrue(tracker.isPaused());
+  }
+
+  @Test
+  public void resumeRequests_afterRequestIsPausedViaPauseAllRequests_resumesRequest() {
+    FakeRequest request = new FakeRequest();
+    request.setIsComplete();
+
+    tracker.addRequest(request);
+    tracker.pauseAllRequests();
+
+    assertThat(request.isCleared()).isTrue();
+
+    // reset complete status.
+    request.setIsComplete(false);
+    tracker.resumeRequests();
+
+    assertThat(request.isRunning()).isTrue();
+  }
+
+  private static final class FakeRequest implements Request {
+    private boolean isRunning;
+    private boolean isFailed;
+    private boolean isCleared;
+    private boolean isComplete;
+    private boolean isRecycled;
+
+    void setIsComplete() {
+      setIsComplete(true);
+    }
+
+    void setIsComplete(boolean isComplete) {
+      this.isComplete = isComplete;
+    }
+
+    void setIsFailed() {
+      isFailed = true;
+    }
+
+    void setIsRunning() {
+      isRunning = true;
+    }
+
+    boolean isRecycled() {
+      return isRecycled;
+    }
+
+    @Override
+    public void begin() {
+      if (isRunning) {
+        throw new IllegalStateException();
+      }
+      isRunning = true;
+    }
+
+    @Override
+    public void clear() {
+      if (isCleared) {
+        throw new IllegalStateException();
+      }
+      isRunning = false;
+      isFailed = false;
+      isCleared = true;
+    }
+
+    @Override
+    public boolean isRunning() {
+      return isRunning;
+    }
+
+    @Override
+    public boolean isComplete() {
+      return isComplete;
+    }
+
+    @Override
+    public boolean isResourceSet() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isCleared() {
+      return isCleared;
+    }
+
+    @Override
+    public boolean isFailed() {
+      return isFailed;
+    }
+
+    @Override
+    public void recycle() {
+      if (isRecycled) {
+        throw new IllegalStateException();
+      }
+      isRecycled = true;
+    }
+
+    @Override
+    public boolean isEquivalentTo(Request other) {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  private class ClearAndRemoveRequest implements Answer<Void> {
+
+    private final Request toRemove;
+
+    ClearAndRemoveRequest(Request toRemove) {
+      this.toRemove = toRemove;
+    }
+
+    @Override
+    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+      tracker.clearRemoveAndRecycle(toRemove);
+      return null;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
rename to library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index 8725e85b7..a59d2120d 100644
--- a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -9,6 +9,7 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.os.Bundle;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
@@ -22,13 +23,12 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 @SuppressWarnings("deprecation")
 public class ManifestParserTest {
   private static final String MODULE_VALUE = "GlideModule";
 
-  @Mock
-  Context context;
+  @Mock private Context context;
   private ManifestParser parser;
   private ApplicationInfo applicationInfo;
 
@@ -111,17 +111,14 @@ private void addToManifest(String key) {
     applicationInfo.metaData.putString(key, MODULE_VALUE);
   }
 
-  public static class InvalidClass {
-  }
+  private static class InvalidClass {}
 
   public static class TestModule1 implements GlideModule {
     @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
-    }
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {}
 
     @Override
-    public void registerComponents(Context context, Glide glide, Registry registry) {
-    }
+    public void registerComponents(Context context, Glide glide, Registry registry) {}
 
     @Override
     public boolean equals(Object o) {
@@ -137,12 +134,10 @@ public int hashCode() {
   public static class TestModule2 implements GlideModule {
 
     @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
-    }
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {}
 
     @Override
-    public void registerComponents(Context context, Glide glide, Registry registry) {
-    }
+    public void registerComponents(Context context, Glide glide, Registry registry) {}
 
     @Override
     public boolean equals(Object o) {
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
new file mode 100644
index 000000000..1c8602fad
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
@@ -0,0 +1,579 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class ErrorRequestCoordinatorTest {
+
+  @Mock private Request primary;
+  @Mock private Request error;
+  @Mock private RequestCoordinator parent;
+  private ErrorRequestCoordinator coordinator;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    coordinator = new ErrorRequestCoordinator(/*parent=*/ null);
+    coordinator.setRequests(primary, error);
+  }
+
+  @Test
+  public void begin_startsPrimary() {
+    coordinator.begin();
+    verify(primary).begin();
+  }
+
+  @Test
+  public void begin_whenPrimaryIsAlreadyRunning_doesNotStartPrimaryAgain() {
+    when(primary.isRunning()).thenReturn(true);
+    coordinator.begin();
+    verify(primary, never()).begin();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_clearsPrimary() {
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_doesNotClearError() {
+    coordinator.clear();
+    verify(error, never()).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_errorIsRunning_clearsError() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    coordinator.clear();
+    verify(error).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_clearsPrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenErrorIsRunning_clearsError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.clear();
+
+    verify(error).clear();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryNotRunning_returnsFalse() {
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryRunning_returnsTrue() {
+    when(primary.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorNotRunning_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorRunning_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryNotComplete_returnsFalse() {
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryComplete_returnsTrue() {
+    when(primary.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorNotComplete_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorComplete_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryNotResourceSet_returnsFalse() {
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryResourceSet_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorNotResourceSet_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorResourceSet_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryNotCancelled_returnsFalse() {
+    assertThat(coordinator.isCleared()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryCancelled_returnsTrue() {
+    when(primary.isCleared()).thenReturn(true);
+    assertThat(coordinator.isCleared()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorNotCancelled_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isCleared()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorCancelled_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isCleared()).thenReturn(true);
+    assertThat(coordinator.isCleared()).isTrue();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorNotFailed_returnsFalse() {
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_errorNotFailed_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorFailed_returnsFalse() {
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_andErrorFailed_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isTrue();
+  }
+
+  @Test
+  public void recycle_recyclesPrimaryAndError() {
+    coordinator.recycle();
+    verify(primary).recycle();
+    verify(error).recycle();
+  }
+
+  @Test
+  public void isEquivalentTo() {
+    assertThat(coordinator.isEquivalentTo(primary)).isFalse();
+
+    ErrorRequestCoordinator other = new ErrorRequestCoordinator(/*parent=*/ null);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(primary, primary);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(error, error);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    when(primary.isEquivalentTo(primary)).thenReturn(true);
+    when(error.isEquivalentTo(error)).thenReturn(true);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_andNullParent_returnsTrue() {
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andNullParent_andNotFailedPrimary_returnsFalse() {
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canSetImage(primary)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCantNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_notFailedPrimary_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCantNotify_false() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_nullParent_returnsFalse() {
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_nullParent_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentResourceNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nullParent_returnsFalse() {
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nullParent_returnsTrue() {
+    when(error.isResourceSet()).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nonNullParentNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void onRequestSuccess_nullParent_doesNotThrow() {
+    coordinator.onRequestSuccess(primary);
+  }
+
+  @Test
+  public void onRequestSuccess_nonNullParent_callsParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.onRequestSuccess(primary);
+    verify(parent).onRequestSuccess(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_beingsError() {
+    coordinator.onRequestFailed(primary);
+    verify(error).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_doesNotBeginError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.onRequestFailed(primary);
+
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_doesNotBeginError() {
+    coordinator.onRequestFailed(error);
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(primary);
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_nonNullParent_notifiesParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(error);
+
+    verify(parent).onRequestFailed(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isRunning()).thenReturn(true);
+
+    coordinator.onRequestFailed(primary);
+
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(false);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
similarity index 77%
rename from library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index 23df8a88f..67042c787 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -3,16 +3,15 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.os.Handler;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import java.util.concurrent.CancellationException;
@@ -28,22 +27,20 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class RequestFutureTargetTest {
   private int width;
   private int height;
   private RequestFutureTarget<Object> future;
   private Request request;
-  private Handler handler;
   private RequestFutureTarget.Waiter waiter;
 
   @Before
   public void setUp() {
     width = 100;
     height = 100;
-    handler = mock(Handler.class);
     waiter = mock(RequestFutureTarget.Waiter.class);
-    future = new RequestFutureTarget<>(handler, width, height, false, waiter);
+    future = new RequestFutureTarget<>(width, height, false, waiter);
     request = mock(Request.class);
     future.setRequest(request);
   }
@@ -65,7 +62,7 @@ public void testReturnsTrueFromIsDoneIfDone() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     assertTrue(future.isDone());
@@ -82,32 +79,25 @@ public void testReturnsTrueFromCancelIfNotYetDone() {
   }
 
   @Test
-  public void cancel_withMayInterruptIfRunningTrueAndNotFinishedRequest_clearsFutureOnMainThread() {
+  public void cancel_withMayInterruptIfRunningTrueAndNotFinishedRequest_clearsFuture() {
     future.cancel(true);
 
-    verify(handler).post(eq(future));
+    verify(request).clear();
   }
 
   @Test
-  public void cancel_withInterruptFalseAndNotFinishedRequest_doesNotclearFutureOnMainThread() {
+  public void cancel_withInterruptFalseAndNotFinishedRequest_doesNotClearFuture() {
     future.cancel(false);
 
-    verify(handler, never()).post(eq(future));
+    verify(request, never()).clear();
   }
 
   @Test
-  public void testDoesNotRepeatedlyClearRequestOnMainThreadIfCancelledRepeatedly() {
+  public void testDoesNotRepeatedlyClearRequestIfCancelledRepeatedly() {
     future.cancel(true);
     future.cancel(true);
 
-    verify(handler, times(1)).post(any(Runnable.class));
-  }
-
-  @Test
-  public void testClearsRequestOnRun() {
-    future.run();
-
-    verify(request).clear();
+    verify(request, times(1)).clear();
   }
 
   @Test
@@ -115,7 +105,7 @@ public void testDoesNotClearRequestIfCancelledAfterDone() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     future.cancel(true);
@@ -134,7 +124,7 @@ public void testReturnsFalseFromIsCancelledIfCancelledAfterDone() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     future.cancel(true);
@@ -153,7 +143,7 @@ public void testReturnsFalseFromCancelIfDone() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     assertFalse(future.cancel(true));
@@ -166,7 +156,7 @@ public void testReturnsResourceOnGetIfAlreadyDone()
     future.onResourceReady(
         /*resource=*/ expected,
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
 
@@ -180,11 +170,11 @@ public void testReturnsResourceOnGetWithTimeoutIfAlreadyDone()
     future.onResourceReady(
         /*resource=*/ expected,
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
 
-    assertEquals(expected, future.get(100, TimeUnit.MILLISECONDS));
+    assertEquals(expected, future.get(1, TimeUnit.MILLISECONDS));
   }
 
   @Test(expected = CancellationException.class)
@@ -231,18 +221,17 @@ public void testThrowsTimeoutExceptionOnGetIfFailedToReceiveResourceInTime()
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsExceptionIfGetCalledOnMainThread()
       throws ExecutionException, InterruptedException {
-    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future = new RequestFutureTarget<>(width, height, true, waiter);
     future.get();
   }
 
   @Test
-  public void testGetSucceedsOnMainThreadIfDone()
-      throws ExecutionException, InterruptedException {
-    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+  public void testGetSucceedsOnMainThreadIfDone() throws ExecutionException, InterruptedException {
+    future = new RequestFutureTarget<>(width, height, true, waiter);
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     future.get();
@@ -251,13 +240,16 @@ public void testGetSucceedsOnMainThreadIfDone()
   @Test(expected = InterruptedException.class)
   public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting()
       throws InterruptedException, ExecutionException {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Thread.currentThread().interrupt();
-        return null;
-      }
-    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                Thread.currentThread().interrupt();
+                return null;
+              }
+            })
+        .when(waiter)
+        .waitForTimeout(eq(future), anyLong());
 
     future.get();
   }
@@ -265,26 +257,33 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
-        return null;
-      }
-    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                future.onLoadFailed(
+                    /*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
+                return null;
+              }
+            })
+        .when(waiter)
+        .waitForTimeout(eq(future), anyLong());
     future.get();
   }
 
   @Test(expected = CancellationException.class)
   public void testThrowsCancellationExceptionIfCancelledWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.cancel(false);
-        return null;
-      }
-    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                future.cancel(false);
+                return null;
+              }
+            })
+        .when(waiter)
+        .waitForTimeout(eq(future), anyLong());
     future.get();
   }
 
@@ -311,7 +310,7 @@ public void testNotifiesAllWhenResourceReady() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     verify(waiter).notifyAll(eq(future));
@@ -335,18 +334,21 @@ public void testDoesNotNotifyAllOnSecondCancel() {
   public void testReturnsResourceIfReceivedWhileWaiting()
       throws ExecutionException, InterruptedException {
     final Object expected = new Object();
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onResourceReady(
-            /*resource=*/ expected,
-            /*model=*/ null,
-            /*target=*/future,
-            DataSource.DATA_DISK_CACHE,
-            true /*isFirstResource*/);
-        return null;
-      }
-    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                future.onResourceReady(
+                    /*resource=*/ expected,
+                    /*model=*/ null,
+                    /*target=*/ future,
+                    DataSource.DATA_DISK_CACHE,
+                    true /*isFirstResource*/);
+                return null;
+              }
+            })
+        .when(waiter)
+        .waitForTimeout(eq(future), anyLong());
     assertEquals(expected, future.get());
   }
 
@@ -364,30 +366,31 @@ public void testWaitsForeverIfNoTimeoutSet() throws InterruptedException {
 
   @Test
   public void testWaitsForGivenTimeoutMillisIfTimeoutSet() throws InterruptedException {
-    long timeout = 1234;
+    long timeout = 2;
     try {
-      future.get(1234, TimeUnit.MILLISECONDS);
+      future.get(timeout, TimeUnit.MILLISECONDS);
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     } catch (TimeoutException e) {
       // Expected.
     }
 
-    verify(waiter).waitForTimeout(eq(future), eq(timeout));
+    verify(waiter, atLeastOnce()).waitForTimeout(eq(future), eq(timeout));
   }
 
   @Test
   public void testConvertsOtherTimeUnitsToMillisForWaiter() throws InterruptedException {
-    long timeoutSeconds = 10;
+    long timeoutMicros = 1000;
     try {
-      future.get(timeoutSeconds, TimeUnit.SECONDS);
+      future.get(timeoutMicros, TimeUnit.MICROSECONDS);
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     } catch (TimeoutException e) {
       // Expected.
     }
 
-    verify(waiter).waitForTimeout(eq(future), eq(TimeUnit.SECONDS.toMillis(timeoutSeconds)));
+    verify(waiter, atLeastOnce())
+        .waitForTimeout(eq(future), eq(TimeUnit.MICROSECONDS.toMillis(timeoutMicros)));
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
new file mode 100644
index 000000000..f9b2f8b64
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -0,0 +1,632 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.MultiTransformation;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.util.Util;
+import com.google.common.testing.EqualsTester;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+@RunWith(RobolectricTestRunner.class)
+public class RequestOptionsTest {
+
+  private RequestOptions options;
+  @Mock private Transformation<Bitmap> transformation;
+  private Application app;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    options = new RequestOptions();
+
+    app = RuntimeEnvironment.application;
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_byDefault_isTrue() {
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withFitCenter_isTrue() {
+    options.fitCenter();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+    options.optionalFitCenter();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCenterInside_isTrue() {
+    options.centerInside();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+    options.optionalCenterInside();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCenterCrop_isFalse() {
+    options.centerCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalCenterCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCircleCrop_isFalse() {
+    options.circleCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.circleCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withBitmapTransformation_isFalse() {
+    options.transform(transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalTransform(transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCustomTransformation_isFalse() {
+    options.transform(Bitmap.class, transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalTransform(Bitmap.class, transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withDownsampleStrategy_isTrue() {
+    options.downsample(DownsampleStrategy.CENTER_OUTSIDE);
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleAndThenDontTransform_isTrue() {
+    options.circleCrop().dontTransform();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleAndAppliedDontTransform_isTrue() {
+    options.circleCrop();
+    options.apply(new RequestOptions().dontTransform());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withDontTransformAndAppliedNonScaleTransform_isFalse() {
+    options.fitCenter();
+    options.apply(new RequestOptions().circleCrop());
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleOnly_andAppliedWithScaleOnly_isTrue() {
+    options.circleCrop();
+    options.apply(new RequestOptions().fitCenter());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withScaleOnlyAndAppliedWithoutTransform_isTrue() {
+    options.fitCenter();
+    options.apply(new RequestOptions().dontAnimate());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleOnlyAndAppliedWithoutTransform_isFalse() {
+    options.circleCrop();
+    options.apply(new RequestOptions().dontAnimate());
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_byDefault_isFalse() {
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationSet_byDefault_isFalse() {
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_byDefault_isTrue() {
+    assertThat(options.isTransformationAllowed()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
+    RequestOptions other = new RequestOptions();
+    other.transform(Bitmap.class, transformation);
+    options.apply(other);
+    assertThat(options.isTransformationSet()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationAllowed()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testApplyingDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingTransformation_overridesDontTransform() {
+    options.dontTransform();
+    options.transform(transformation);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingOptions_withDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    RequestOptions other = new RequestOptions();
+    other.dontTransform();
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingOptions_withTransformation_overridesDontTransform() {
+    options.dontTransform();
+    RequestOptions other = new RequestOptions();
+    other.transform(transformation);
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationSet()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
+    options.dontTransform();
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
+    options.transform(transformation);
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  @SuppressWarnings({"unchecked", "varargs"})
+  public void testApplyMultiTransform() {
+    options.transform(new CircleCrop(), new CenterCrop());
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsKey(Bitmap.class);
+    assertThat(options.getTransformations().get(Bitmap.class))
+        .isInstanceOf(MultiTransformation.class);
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withoutSkipMemoryCache_isFalse() {
+    assertThat(options.isSkipMemoryCacheSet()).isFalse();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheTrue_isTrue() {
+    assertThat(options.skipMemoryCache(true).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheFalse_isTrue() {
+    assertThat(options.skipMemoryCache(false).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withoutDiskCacheStrategy_isFalse() {
+    assertThat(options.isDiskCacheStrategySet()).isFalse();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyNonDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.ALL).isDiskCacheStrategySet()).isTrue();
+  }
+
+  @Test
+  public void getPlaceholder_afterSettingPlaceholderId_returnsNul() {
+    assertThat(
+            options
+                .placeholder(new ColorDrawable(Color.RED))
+                .placeholder(android.R.drawable.star_on)
+                .getPlaceholderDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getPlaceholder_afterApplyingOptionsWithPlaceholderId_returnsNull() {
+    RequestOptions toApply = new RequestOptions().placeholder(android.R.drawable.star_on);
+
+    assertThat(
+            options
+                .placeholder(new ColorDrawable(Color.RED))
+                .apply(toApply)
+                .getPlaceholderDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getPlaceholder_afterApplyingOptionsWithPlaceholderDrawable_returnsNewDrawable() {
+    Drawable expected = new ColorDrawable(Color.GREEN);
+    RequestOptions toApply = new RequestOptions().placeholder(expected);
+
+    assertThat(
+            options
+                .placeholder(new ColorDrawable(Color.RED))
+                .apply(toApply)
+                .getPlaceholderDrawable())
+        .isEqualTo(expected);
+  }
+
+  /**
+   * Verifies that we set the flags for placeholder id correctly when applying a placeholder id via
+   * another RequestOptions.
+   */
+  @Test
+  public void placeholderIdFlag_afterApplyingIdViaOtherRequestOptions_isSet() {
+    assertThat(
+            options
+                .placeholder(new ColorDrawable(Color.RED))
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().placeholder(android.R.drawable.star_on)))
+                .getPlaceholderDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getPlaceholderId_afterSettingPlaceholderDrawable_returnsZero() {
+    assertThat(
+            options
+                .placeholder(android.R.drawable.star_on)
+                .placeholder(new ColorDrawable(Color.RED))
+                .getPlaceholderId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getPlaceholderId_afterApplyingOptionsWithPlaceholderDrawable_returnsZero() {
+    RequestOptions toApply = new RequestOptions().placeholder(new ColorDrawable(Color.RED));
+
+    assertThat(options.placeholder(android.R.drawable.star_on).apply(toApply).getPlaceholderId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getPlaceholderId_afterApplyingOptionsWithId_returnsNewId() {
+    int expectedId = android.R.drawable.star_off;
+    RequestOptions toApply = new RequestOptions().placeholder(expectedId);
+
+    assertThat(options.placeholder(android.R.drawable.star_on).apply(toApply).getPlaceholderId())
+        .isEqualTo(expectedId);
+  }
+
+  /**
+   * Verifies that we set the flags for placeholder correctly when applying a placeholder via
+   * another RequestOptions.
+   */
+  @Test
+  public void placeholderFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+            options
+                .placeholder(android.R.drawable.star_on)
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().placeholder(new ColorDrawable(Color.RED))))
+                .getPlaceholderId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getFallback_afterSettingFallbackId_returnsNull() {
+    assertThat(
+            options
+                .fallback(new ColorDrawable(Color.RED))
+                .fallback(android.R.drawable.star_on)
+                .getFallbackDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getFallback_afterApplyingOptionsWithFallbackId_returnsNull() {
+    RequestOptions toApply = new RequestOptions().fallback(android.R.drawable.star_on);
+
+    assertThat(options.fallback(new ColorDrawable(Color.RED)).apply(toApply).getFallbackDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getFallback_afterApplyingOptionsWithFallbackDrawable_returnsNewDrawable() {
+    RequestOptions toApply = new RequestOptions();
+
+    RequestOptions apply = options.fallback(new ColorDrawable(Color.RED)).apply(toApply);
+    assertThat(((ColorDrawable) apply.getFallbackDrawable()).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Verifies that we set the flags for fallback correctly when applying a fallback via another
+   * RequestOptions.
+   */
+  @Test
+  public void fallbackFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+            options
+                .fallback(android.R.drawable.star_on)
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().fallback(new ColorDrawable(Color.RED))))
+                .getFallbackId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getFallbackId_afterSettingFallbackDrawable_returnsZero() {
+    assertThat(
+            options
+                .fallback(android.R.drawable.star_on)
+                .fallback(new ColorDrawable(Color.RED))
+                .getFallbackId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getFallbackId_afterApplyingOptionsWithFallbackDrawable_returnsZero() {
+    RequestOptions toApply = new RequestOptions().fallback(new ColorDrawable(Color.RED));
+
+    assertThat(options.fallback(android.R.drawable.star_on).apply(toApply).getFallbackId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getFallbackId_afterApplyingOptionsWithFallbackId_returnsNewFallbackId() {
+    RequestOptions toApply = new RequestOptions().fallback(android.R.drawable.star_off);
+
+    assertThat(options.fallback(android.R.drawable.star_on).apply(toApply).getFallbackId())
+        .isEqualTo(android.R.drawable.star_off);
+  }
+
+  /**
+   * Verifies that we set the flags for fallback id correctly when applying a fallback id via
+   * another RequestOptions.
+   */
+  @Test
+  public void fallbackIdFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+            options
+                .fallback(new ColorDrawable(Color.RED))
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().fallback(android.R.drawable.star_on)))
+                .getFallbackDrawable())
+        .isNull();
+  }
+
+  @Test
+  public void getError_afterSettingErrorId_returnsNull() {
+    assertThat(
+            options
+                .error(new ColorDrawable(Color.RED))
+                .error(android.R.drawable.star_on)
+                .getErrorPlaceholder())
+        .isNull();
+  }
+
+  @Test
+  public void getError_afterApplyingOptionsWithErrorId_returnsNull() {
+    RequestOptions toApply = new RequestOptions().error(android.R.drawable.star_on);
+
+    assertThat(options.error(new ColorDrawable(Color.RED)).apply(toApply).getErrorPlaceholder())
+        .isNull();
+  }
+
+  @Test
+  public void getError_afterApplyingOptionsWithErrorDrawable_returnsNewErrorDrawable() {
+    Drawable expected = new ColorDrawable(Color.GREEN);
+    RequestOptions toApply = new RequestOptions().error(expected);
+
+    assertThat(options.error(new ColorDrawable(Color.RED)).apply(toApply).getErrorPlaceholder())
+        .isEqualTo(expected);
+  }
+
+  /**
+   * Verifies that we set the flags for error correctly when applying an error via another
+   * RequestOptions.
+   */
+  @Test
+  public void errorFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+            options
+                .error(android.R.drawable.star_on)
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().error(new ColorDrawable(Color.RED))))
+                .getErrorId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getErrorId_afterSettingErrorDrawable_returnsZero() {
+    assertThat(
+            options
+                .error(android.R.drawable.star_on)
+                .error(new ColorDrawable(Color.RED))
+                .getErrorId())
+        .isEqualTo(0);
+  }
+
+  @Test
+  public void getErrorId_afterApplyingOptionsWithErrorDrawable_returnsZero() {
+    RequestOptions toApply = new RequestOptions().error(new ColorDrawable(Color.RED));
+
+    assertThat(options.error(android.R.drawable.star_on).apply(toApply).getErrorId()).isEqualTo(0);
+  }
+
+  @Test
+  public void getErrorId_afterApplyingOptionsWithErrorId_returnsNewErrorId() {
+    RequestOptions toApply = new RequestOptions().error(android.R.drawable.star_off);
+
+    assertThat(options.error(android.R.drawable.star_on).apply(toApply).getErrorId())
+        .isEqualTo(android.R.drawable.star_off);
+  }
+
+  /**
+   * Verifies that we set the flags for error id correctly when applying a fallback id via another
+   * RequestOptions.
+   */
+  @Test
+  public void errorIdFlag_afterApplyingViaOtherRequestOptions_isSet() {
+    assertThat(
+            options
+                .error(new ColorDrawable(Color.RED))
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().error(android.R.drawable.star_on)))
+                .getErrorPlaceholder())
+        .isNull();
+  }
+
+  @Test
+  public void testEqualsHashCode() {
+    Drawable first = new ColorDrawable(Color.RED);
+    Drawable second = new GradientDrawable();
+    assertThat(first).isNotEqualTo(second);
+    assertThat(Util.bothNullOrEqual(first, second)).isFalse();
+    new EqualsTester()
+        .addEqualityGroup(
+            new RequestOptions().sizeMultiplier(.7f), new RequestOptions().sizeMultiplier(.7f))
+        .addEqualityGroup(new RequestOptions().sizeMultiplier(0.8f))
+        .addEqualityGroup(new RequestOptions().error(1), new RequestOptions().error(1))
+        .addEqualityGroup(new RequestOptions().error(2))
+        .addEqualityGroup(new RequestOptions().error(first), new RequestOptions().error(first))
+        .addEqualityGroup(new RequestOptions().error(second))
+        .addEqualityGroup(new RequestOptions().placeholder(1), new RequestOptions().placeholder(1))
+        .addEqualityGroup(new RequestOptions().placeholder(2))
+        .addEqualityGroup(
+            new RequestOptions().placeholder(first), new RequestOptions().placeholder(first))
+        .addEqualityGroup(new RequestOptions().placeholder(second))
+        .addEqualityGroup(new RequestOptions().fallback(1), new RequestOptions().fallback(1))
+        .addEqualityGroup(new RequestOptions().fallback(2))
+        .addEqualityGroup(
+            new RequestOptions().fallback(first), new RequestOptions().fallback(first))
+        .addEqualityGroup(new RequestOptions().fallback(second))
+        .addEqualityGroup(
+            new RequestOptions().skipMemoryCache(true), new RequestOptions().skipMemoryCache(true))
+        .addEqualityGroup(
+            new RequestOptions(),
+            new RequestOptions().skipMemoryCache(false),
+            new RequestOptions().theme(null),
+            new RequestOptions().onlyRetrieveFromCache(false),
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(false))
+        .addEqualityGroup(
+            new RequestOptions().override(100), new RequestOptions().override(100, 100))
+        .addEqualityGroup(
+            new RequestOptions().override(200), new RequestOptions().override(200, 200))
+        .addEqualityGroup(
+            new RequestOptions().override(100, 200), new RequestOptions().override(100, 200))
+        .addEqualityGroup(
+            new RequestOptions().override(200, 100), new RequestOptions().override(200, 100))
+        .addEqualityGroup(new RequestOptions().centerCrop(), new RequestOptions().centerCrop())
+        .addEqualityGroup(
+            new RequestOptions().optionalCenterCrop(), new RequestOptions().optionalCenterCrop())
+        .addEqualityGroup(new RequestOptions().fitCenter())
+        .addEqualityGroup(new RequestOptions().circleCrop())
+        .addEqualityGroup(new RequestOptions().centerInside())
+        .addEqualityGroup(
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(true),
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(true))
+        .addEqualityGroup(
+            new RequestOptions().onlyRetrieveFromCache(true),
+            new RequestOptions().onlyRetrieveFromCache(true))
+        .addEqualityGroup(
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL),
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL))
+        .addEqualityGroup(new RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE))
+        .addEqualityGroup(
+            new RequestOptions().priority(Priority.HIGH),
+            new RequestOptions().priority(Priority.HIGH))
+        .addEqualityGroup(new RequestOptions().priority(Priority.LOW))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.memory("test"), true),
+            new RequestOptions().set(Option.memory("test"), true))
+        .addEqualityGroup(new RequestOptions().set(Option.memory("test"), false))
+        .addEqualityGroup(new RequestOptions().set(Option.memory("test2"), true))
+        .addEqualityGroup(
+            new RequestOptions().decode(Integer.class), new RequestOptions().decode(Integer.class))
+        .addEqualityGroup(new RequestOptions().decode(Float.class))
+        .addEqualityGroup(
+            new RequestOptions().signature(new ObjectKey("test")),
+            new RequestOptions().signature(new ObjectKey("test")))
+        .addEqualityGroup(new RequestOptions().signature(new ObjectKey("test2")))
+        .addEqualityGroup(
+            new RequestOptions().theme(app.getTheme()), new RequestOptions().theme(app.getTheme()))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 0002b5288..e80210edf 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -20,7 +20,8 @@
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -36,29 +37,36 @@
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.util.Executors;
 import com.google.common.base.Equivalence;
 import com.google.common.testing.EquivalenceTester;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Executor;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 @SuppressWarnings("rawtypes")
 public class SingleRequestTest {
 
   private SingleRequestBuilder builder;
+  @Mock private RequestListener<List> listener1;
+  @Mock private RequestListener<List> listener2;
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
     builder = new SingleRequestBuilder();
   }
 
@@ -71,31 +79,31 @@ public void testIsNotCompleteBeforeReceivingResource() {
 
   @Test
   public void testCanHandleNullResources() {
-    SingleRequest<List> request = builder.build();
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
 
     request.onResourceReady(null, DataSource.LOCAL);
 
     assertTrue(request.isFailed());
-    verify(builder.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),
-        eq(builder.target), anyBoolean());
+    verify(listener1)
+        .onLoadFailed(isAGlideException(), isA(Number.class), eq(builder.target), anyBoolean());
   }
 
   @Test
   public void testCanHandleEmptyResources() {
-    SingleRequest<List> request = builder.build();
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
     when(builder.resource.get()).thenReturn(null);
 
     request.onResourceReady(builder.resource, DataSource.REMOTE);
 
     assertTrue(request.isFailed());
     verify(builder.engine).release(eq(builder.resource));
-    verify(builder.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean());
+    verify(listener1)
+        .onLoadFailed(isAGlideException(), any(Number.class), eq(builder.target), anyBoolean());
   }
 
   @Test
   public void testCanHandleNonConformingResources() {
-    SingleRequest<List> request = builder.build();
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
     when(((Resource) (builder.resource)).get())
         .thenReturn("Invalid mocked String, this should be a List");
 
@@ -103,8 +111,8 @@ public void testCanHandleNonConformingResources() {
 
     assertTrue(request.isFailed());
     verify(builder.engine).release(eq(builder.resource));
-    verify(builder.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean());
+    verify(listener1)
+        .onLoadFailed(isAGlideException(), any(Number.class), eq(builder.target), anyBoolean());
   }
 
   @Test
@@ -117,32 +125,6 @@ public void testIsNotFailedAfterClear() {
     assertFalse(request.isFailed());
   }
 
-  @Test
-  public void testIsPausedAfterPause() {
-    SingleRequest<List> request = builder.build();
-    request.pause();
-
-    assertTrue(request.isPaused());
-  }
-
-  @Test
-  public void testIsNotCancelledAfterPause() {
-    SingleRequest<List> request = builder.build();
-    request.pause();
-
-    assertFalse(request.isCancelled());
-  }
-
-  @Test
-  public void testIsNotPausedAfterBeginningWhilePaused() {
-    SingleRequest<List> request = builder.build();
-    request.pause();
-    request.begin();
-
-    assertFalse(request.isPaused());
-    assertTrue(request.isRunning());
-  }
-
   @Test
   public void testIsNotFailedAfterBegin() {
     SingleRequest<List> request = builder.build();
@@ -176,7 +158,15 @@ public void testIsCancelledAfterClear() {
     SingleRequest<List> request = builder.build();
     request.clear();
 
-    assertTrue(request.isCancelled());
+    assertTrue(request.isCleared());
+  }
+
+  @Test
+  public void clear_notifiesTarget() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target).onLoadCleared(anyDrawableOrNull());
   }
 
   @Test
@@ -185,24 +175,34 @@ public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
     request.clear();
     request.clear();
 
-    verify(builder.target, times(1)).onLoadCleared(any(Drawable.class));
+    verify(builder.target, times(1)).onLoadCleared(anyDrawableOrNull());
+  }
+
+  @Test
+  public void clear_doesNotNotifyTarget_ifRequestCoordinatorReturnsFalseForCanClear() {
+    when(builder.requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(false);
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target, never()).onLoadCleared(any(Drawable.class));
   }
 
   @Test
   public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
     RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-    doAnswer(new Answer() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        Request request = (Request) invocation.getArguments()[0];
-        assertFalse(request.isComplete());
-        return true;
-      }
-    }).when(requestCoordinator).canSetImage(any(Request.class));
-
-    SingleRequest<List> request = builder
-        .setRequestCoordinator(requestCoordinator)
-        .build();
+    doAnswer(
+            new Answer() {
+              @Override
+              public Object answer(InvocationOnMock invocation) {
+                Request request = (Request) invocation.getArguments()[0];
+                assertFalse(request.isComplete());
+                return true;
+              }
+            })
+        .when(requestCoordinator)
+        .canSetImage(any(Request.class));
+
+    SingleRequest<List> request = builder.setRequestCoordinator(requestCoordinator).build();
 
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
@@ -250,7 +250,8 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
   @Test
@@ -265,8 +266,7 @@ public void testIsFailedAfterNoResultAndNullException() {
   public void testEngineLoadCancelledOnCancel() {
     Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
 
-    when(builder.engine
-        .load(
+    when(builder.engine.load(
             eq(builder.glideContext),
             eq(builder.model),
             eq(builder.signature),
@@ -284,14 +284,15 @@ public void testEngineLoadCancelledOnCancel() {
             anyBoolean(),
             anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class)))
+            any(ResourceCallback.class),
+            anyExecutor()))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = builder.build();
     request.begin();
 
     request.onSizeReady(100, 100);
-    request.cancel();
+    request.clear();
 
     verify(loadStatus).cancel();
   }
@@ -312,10 +313,8 @@ public void testPlaceholderDrawableIsSet() {
 
     MockTarget target = new MockTarget();
 
-    SingleRequest<List> request = builder
-        .setPlaceholderDrawable(expected)
-        .setTarget(target)
-        .build();
+    SingleRequest<List> request =
+        builder.setPlaceholderDrawable(expected).setTarget(target).build();
     request.begin();
 
     assertThat(target.currentPlaceholder).isEqualTo(expected);
@@ -327,10 +326,7 @@ public void testErrorDrawableIsSetOnLoadFailed() {
 
     MockTarget target = new MockTarget();
 
-    SingleRequest<List> request = builder
-        .setErrorDrawable(expected)
-        .setTarget(target)
-        .build();
+    SingleRequest<List> request = builder.setErrorDrawable(expected).setTarget(target).build();
 
     request.onLoadFailed(new GlideException("test"));
 
@@ -343,11 +339,8 @@ public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
 
     MockTarget target = new MockTarget();
 
-    SingleRequest<List> request = builder
-        .setErrorDrawable(placeholder)
-        .setTarget(target)
-        .setModel(null)
-        .build();
+    SingleRequest<List> request =
+        builder.setErrorDrawable(placeholder).setTarget(target).setModel(null).build();
 
     request.begin();
 
@@ -361,19 +354,19 @@ public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
 
     MockTarget target = new MockTarget();
 
-    SingleRequest<List> request = builder
-        .setPlaceholderDrawable(placeholder)
-        .setErrorDrawable(errorPlaceholder)
-        .setTarget(target)
-        .setModel(null)
-        .build();
+    SingleRequest<List> request =
+        builder
+            .setPlaceholderDrawable(placeholder)
+            .setErrorDrawable(errorPlaceholder)
+            .setTarget(target)
+            .setModel(null)
+            .build();
 
     request.begin();
 
     assertThat(target.currentPlaceholder).isEqualTo(errorPlaceholder);
   }
 
-
   @Test
   public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
     Drawable placeholder = new ColorDrawable(Color.RED);
@@ -381,19 +374,19 @@ public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
     Drawable fallback = new ColorDrawable(Color.BLUE);
 
     MockTarget target = new MockTarget();
-    SingleRequest<List> request = builder
-        .setPlaceholderDrawable(placeholder)
-        .setErrorDrawable(errorPlaceholder)
-        .setFallbackDrawable(fallback)
-        .setTarget(target)
-        .setModel(null)
-        .build();
+    SingleRequest<List> request =
+        builder
+            .setPlaceholderDrawable(placeholder)
+            .setErrorDrawable(errorPlaceholder)
+            .setFallbackDrawable(fallback)
+            .setTarget(target)
+            .setModel(null)
+            .build();
     request.begin();
 
     assertThat(target.currentPlaceholder).isEqualTo(fallback);
   }
 
-
   @Test
   public void testIsNotRunningBeforeRunCalled() {
     assertFalse(builder.build().isRunning());
@@ -435,31 +428,39 @@ public void testIsNotRunningAfterClear() {
 
   @Test
   public void testCallsTargetOnResourceReadyIfNoRequestListener() {
-    SingleRequest<List> request = builder
-        .setRequestListener(null)
-        .build();
+    SingleRequest<List> request = builder.build();
     request.onResourceReady(builder.resource, DataSource.LOCAL);
 
     verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
   }
 
   @Test
-  public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
-    SingleRequest<List> request = builder.build();
-    when(builder.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
-            anyBoolean())).thenReturn(false);
+  public void testCallsTargetOnResourceReadyIfAllRequestListenersReturnFalse() {
+    SingleRequest<List> request =
+        builder.addRequestListener(listener1).addRequestListener(listener2).build();
+
+    when(listener1.onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean()))
+        .thenReturn(false);
+    when(listener2.onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean()))
+        .thenReturn(false);
     request.onResourceReady(builder.resource, DataSource.LOCAL);
 
     verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
   }
 
   @Test
-  public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
-    SingleRequest<List> request = builder.build();
-    when(builder.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
-            anyBoolean())).thenReturn(true);
+  public void testDoesNotCallTargetOnResourceReadyIfAnyRequestListenerReturnsTrue() {
+    SingleRequest<List> request =
+        builder.addRequestListener(listener1).addRequestListener(listener2).build();
+
+    when(listener1.onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean()))
+        .thenReturn(false);
+    when(listener1.onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean()))
+        .thenReturn(true);
     request.onResourceReady(builder.resource, DataSource.REMOTE);
 
     verify(builder.target, never()).onResourceReady(any(List.class), anyTransition());
@@ -467,19 +468,22 @@ public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
 
   @Test
   public void testCallsTargetOnExceptionIfNoRequestListener() {
-    SingleRequest<List> request = builder
-        .setRequestListener(null)
-        .build();
+    SingleRequest<List> request = builder.build();
     request.onLoadFailed(new GlideException("test"));
 
     verify(builder.target).onLoadFailed(eq(builder.errorDrawable));
   }
 
   @Test
-  public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
-    SingleRequest<List> request = builder.build();
-    when(builder.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean()))
+  public void testCallsTargetOnExceptionIfAllRequestListenersReturnFalse() {
+    SingleRequest<List> request =
+        builder.addRequestListener(listener1).addRequestListener(listener2).build();
+
+    when(listener1.onLoadFailed(
+            isAGlideException(), any(Number.class), eq(builder.target), anyBoolean()))
+        .thenReturn(false);
+    when(listener2.onLoadFailed(
+            isAGlideException(), any(Number.class), eq(builder.target), anyBoolean()))
         .thenReturn(false);
     request.onLoadFailed(new GlideException("test"));
 
@@ -487,10 +491,15 @@ public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
   }
 
   @Test
-  public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
-    SingleRequest<List> request = builder.build();
-    when(builder.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean()))
+  public void testDoesNotCallTargetOnExceptionIfAnyRequestListenerReturnsTrue() {
+    SingleRequest<List> request =
+        builder.addRequestListener(listener1).addRequestListener(listener2).build();
+
+    when(listener1.onLoadFailed(
+            isAGlideException(), any(Number.class), eq(builder.target), anyBoolean()))
+        .thenReturn(false);
+    when(listener2.onLoadFailed(
+            isAGlideException(), any(Number.class), eq(builder.target), anyBoolean()))
         .thenReturn(true);
 
     request.onLoadFailed(new GlideException("test"));
@@ -500,40 +509,39 @@ public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
 
   @Test
   public void testRequestListenerIsCalledWithResourceResult() {
-    SingleRequest<List> request = builder.build();
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
-    verify(builder.requestListener)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
-            anyBoolean());
+    verify(listener1)
+        .onResourceReady(
+            eq(builder.result), any(Number.class), isAListTarget(), isADataSource(), anyBoolean());
   }
 
   @Test
   public void testRequestListenerIsCalledWithModel() {
-    SingleRequest<List> request = builder.build();
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
-    verify(builder.requestListener)
-        .onResourceReady(any(List.class), eq(builder.model), isAListTarget(), isADataSource(),
-            anyBoolean());
+    verify(listener1)
+        .onResourceReady(
+            any(List.class), eq(builder.model), isAListTarget(), isADataSource(), anyBoolean());
   }
 
   @Test
   public void testRequestListenerIsCalledWithTarget() {
-    SingleRequest<List> request = builder.build();
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
-    verify(builder.requestListener)
-        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
-            anyBoolean());
+    verify(listener1)
+        .onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean());
   }
 
   @Test
   public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
-    final SingleRequest<List> request = builder.build();
+    final SingleRequest<List> request = builder.addRequestListener(listener1).build();
 
-    when(builder.engine
-        .load(
+    when(builder.engine.load(
             eq(builder.glideContext),
             eq(builder.model),
             eq(builder.signature),
@@ -551,67 +559,76 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class)))
-        .thenAnswer(new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            request.onResourceReady(builder.resource, DataSource.MEMORY_CACHE);
-            return null;
-          }
-        });
+            any(ResourceCallback.class),
+            anyExecutor()))
+        .thenAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) {
+                request.onResourceReady(builder.resource, DataSource.MEMORY_CACHE);
+                return null;
+              }
+            });
 
     request.begin();
     request.onSizeReady(100, 100);
-    verify(builder.requestListener)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
-            eq(DataSource.MEMORY_CACHE), anyBoolean());
+    verify(listener1)
+        .onResourceReady(
+            eq(builder.result),
+            any(Number.class),
+            isAListTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
   }
 
   @Test
   public void
-  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
-    SingleRequest<List> request = builder.build();
+      testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
     request.onSizeReady(100, 100);
     request.onResourceReady(builder.resource, DataSource.LOCAL);
 
-    verify(builder.requestListener)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
-            eq(DataSource.LOCAL), anyBoolean());
+    verify(listener1)
+        .onResourceReady(
+            eq(builder.result),
+            any(Number.class),
+            isAListTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
   }
 
   @Test
   public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
-    SingleRequest<List> request = builder
-        .setRequestCoordinator(null)
-        .build();
+    SingleRequest<List> request =
+        builder.setRequestCoordinator(null).addRequestListener(listener1).build();
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
-    verify(builder.requestListener)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
+    verify(listener1)
+        .onResourceReady(
+            eq(builder.result), any(Number.class), isAListTarget(), isADataSource(), eq(true));
   }
 
   @Test
   public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
-    SingleRequest<List> request = builder.build();
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
     when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(false);
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
-    verify(builder.requestListener)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
+    verify(listener1)
+        .onResourceReady(
+            eq(builder.result), any(Number.class), isAListTarget(), isADataSource(), eq(true));
   }
 
   @Test
   public void
-  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
-    SingleRequest<List> request = builder.build();
+      testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
+    SingleRequest<List> request = builder.addRequestListener(listener1).build();
     when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(true);
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
-    verify(builder.requestListener)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
-            isADataSource(), eq(false));
+    verify(listener1)
+        .onResourceReady(
+            eq(builder.result), any(Number.class), isAListTarget(), isADataSource(), eq(false));
   }
 
   @Test
@@ -627,10 +644,7 @@ public void testTargetIsCalledWithAnimationFromFactory() {
 
   @Test
   public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
-    SingleRequest<List> request = builder
-        .setOverrideWidth(-1)
-        .setOverrideHeight(100)
-        .build();
+    SingleRequest<List> request = builder.setOverrideWidth(-1).setOverrideHeight(100).build();
     request.begin();
 
     verify(builder.target).getSize(any(SizeReadyCallback.class));
@@ -638,10 +652,7 @@ public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
 
   @Test
   public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
-    SingleRequest<List> request = builder
-        .setOverrideWidth(100)
-        .setOverrideHeight(-1)
-        .build();
+    SingleRequest<List> request = builder.setOverrideWidth(100).setOverrideHeight(-1).build();
     request.begin();
 
     verify(builder.target).getSize(any(SizeReadyCallback.class));
@@ -649,10 +660,7 @@ public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
 
   @Test
   public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
-    SingleRequest<List> request = builder
-        .setOverrideWidth(100)
-        .setOverrideHeight(100)
-        .build();
+    SingleRequest<List> request = builder.setOverrideWidth(100).setOverrideHeight(100).build();
     request.begin();
 
     verify(builder.target, never()).getSize(any(SizeReadyCallback.class));
@@ -660,10 +668,7 @@ public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
 
   @Test
   public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
-    SingleRequest<List> request = builder
-        .setOverrideWidth(1)
-        .setOverrideHeight(2)
-        .build();
+    SingleRequest<List> request = builder.setOverrideWidth(1).setOverrideHeight(2).build();
     request.begin();
 
     verify(builder.engine)
@@ -685,14 +690,13 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
   @Test
   public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
-    SingleRequest<List> request = builder
-        .setErrorDrawable(new ColorDrawable(Color.RED))
-        .build();
+    SingleRequest<List> request = builder.setErrorDrawable(new ColorDrawable(Color.RED)).build();
     when(builder.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
     request.onLoadFailed(new GlideException("test"));
 
@@ -700,12 +704,12 @@ public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
   }
 
   @Test
-  public void testCanReRunCancelledRequests() {
-    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+  public void testCanReRunClearedRequests() {
+    doAnswer(new CallSizeReady(100, 100))
+        .when(builder.target)
         .getSize(any(SizeReadyCallback.class));
 
-    when(builder.engine
-        .load(
+    when(builder.engine.load(
             eq(builder.glideContext),
             eq(builder.model),
             eq(builder.signature),
@@ -723,12 +727,13 @@ public void testCanReRunCancelledRequests() {
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class)))
+            any(ResourceCallback.class),
+            anyExecutor()))
         .thenAnswer(new CallResourceCallback(builder.resource));
     SingleRequest<List> request = builder.build();
 
     request.begin();
-    request.cancel();
+    request.clear();
     request.begin();
 
     verify(builder.target, times(2)).onResourceReady(eq(builder.result), anyTransition());
@@ -743,9 +748,9 @@ public void testResourceOnlyReceivesOneGetOnResourceReady() {
   }
 
   @Test
-  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
+  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterClear() {
     SingleRequest<List> request = builder.build();
-    request.cancel();
+    request.clear();
     request.onSizeReady(100, 100);
 
     verify(builder.engine, never())
@@ -767,18 +772,17 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
-
   @Test
   public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
-    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+    doAnswer(new CallSizeReady(100, 100))
+        .when(builder.target)
         .getSize(any(SizeReadyCallback.class));
 
-    SingleRequest<List> request = builder
-        .setUseUnlimitedSourceGeneratorsPool(true)
-        .build();
+    SingleRequest<List> request = builder.setUseUnlimitedSourceGeneratorsPool(true).build();
     request.begin();
 
     verify(builder.engine)
@@ -800,17 +804,17 @@ public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
             eq(true),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
   @Test
   public void testCallsSourceExecutorEngineIfOptionsIsSet() {
-    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+    doAnswer(new CallSizeReady(100, 100))
+        .when(builder.target)
         .getSize(any(SizeReadyCallback.class));
 
-    SingleRequest<List> request = builder
-        .setUseUnlimitedSourceGeneratorsPool(false)
-        .build();
+    SingleRequest<List> request = builder.setUseUnlimitedSourceGeneratorsPool(false).build();
     request.begin();
 
     verify(builder.engine)
@@ -832,35 +836,33 @@ public void testCallsSourceExecutorEngineIfOptionsIsSet() {
             eq(false),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
   @Test
   // Varargs
   @SuppressWarnings("unchecked")
   public void testIsEquivalentTo() {
-    EquivalenceTester<SingleRequestBuilder> tester = EquivalenceTester
-        .of(new Equivalence<SingleRequestBuilder>() {
-          @Override
-          protected boolean doEquivalent(
-              @NonNull SingleRequestBuilder a, @NonNull SingleRequestBuilder b) {
-            return a.build().isEquivalentTo(b.build()) && b.build().isEquivalentTo(a.build());
-          }
-
-          @Override
-          protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
-            return 0;
-          }
-        });
+    EquivalenceTester<SingleRequestBuilder> tester =
+        EquivalenceTester.of(
+            new Equivalence<SingleRequestBuilder>() {
+              @Override
+              protected boolean doEquivalent(
+                  @NonNull SingleRequestBuilder a, @NonNull SingleRequestBuilder b) {
+                return a.build().isEquivalentTo(b.build()) && b.build().isEquivalentTo(a.build());
+              }
+
+              @Override
+              protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
+                return 0;
+              }
+            });
     tester
         .addEquivalenceGroup(
-            new SingleRequestBuilder(),
-            new SingleRequestBuilder(),
             // Non-null request listeners are treated as equivalent, even if they're not equal.
-            new SingleRequestBuilder().setRequestListener(mock(RequestListener.class)))
-        .addEquivalenceGroup(
-            new SingleRequestBuilder().setRequestListener(null),
-            new SingleRequestBuilder().setRequestListener(null))
+            new SingleRequestBuilder().addRequestListener(listener1),
+            new SingleRequestBuilder().addRequestListener(listener2))
         .addEquivalenceGroup(
             new SingleRequestBuilder().setOverrideHeight(500),
             new SingleRequestBuilder().setOverrideHeight(500))
@@ -868,14 +870,9 @@ protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
             new SingleRequestBuilder().setOverrideWidth(500),
             new SingleRequestBuilder().setOverrideWidth(500))
         .addEquivalenceGroup(
-            new SingleRequestBuilder().setModel(12345),
-            new SingleRequestBuilder().setModel(12345))
-        .addEquivalenceGroup(
-            new SingleRequestBuilder().setModel(null),
-            new SingleRequestBuilder().setModel(null))
+            new SingleRequestBuilder().setModel(12345), new SingleRequestBuilder().setModel(12345))
         .addEquivalenceGroup(
-            new SingleRequestBuilder().setErrorDrawable(new ColorDrawable(Color.GRAY)),
-            new SingleRequestBuilder().setErrorDrawable(new ColorDrawable(Color.GRAY)))
+            new SingleRequestBuilder().setModel(null), new SingleRequestBuilder().setModel(null))
         .addEquivalenceGroup(
             new SingleRequestBuilder().setPriority(Priority.LOW),
             new SingleRequestBuilder().setPriority(Priority.LOW))
@@ -885,29 +882,35 @@ protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
   static final class SingleRequestBuilder {
     private Engine engine = mock(Engine.class);
     private Number model = 123456;
+
     @SuppressWarnings("unchecked")
     private Target<List> target = mock(Target.class);
+
     private Resource<List> resource = mockResource();
     private RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
     private Drawable placeholderDrawable = null;
     private Drawable errorDrawable = null;
     private Drawable fallbackDrawable = null;
+
     @SuppressWarnings("unchecked")
-    private RequestListener<List> requestListener = mock(RequestListener.class);
+    private List<RequestListener<List>> requestListeners = new ArrayList<>();
+
     @SuppressWarnings("unchecked")
-    private TransitionFactory<List> transitionFactory = mock(TransitionFactory.class);
+    private final TransitionFactory<List> transitionFactory = mock(TransitionFactory.class);
+
     private int overrideWidth = -1;
     private int overrideHeight = -1;
     private List<?> result = new ArrayList<>();
-    private GlideContext glideContext = mock(GlideContext.class);
-    private Key signature = new ObjectKey(12345);
+    private final GlideContext glideContext = mock(GlideContext.class);
+    private final Key signature = new ObjectKey(12345);
     private Priority priority = Priority.HIGH;
     private boolean useUnlimitedSourceGeneratorsPool = false;
-    private Class<List> transcodeClass = List.class;
-    private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+    private final Class<List> transcodeClass = List.class;
+    private final Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
 
     SingleRequestBuilder() {
       when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(true);
       when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
       when(resource.get()).thenReturn(result);
     }
@@ -952,8 +955,8 @@ SingleRequestBuilder setFallbackDrawable(Drawable fallbackDrawable) {
       return this;
     }
 
-    SingleRequestBuilder setRequestListener(RequestListener<List> requestListener) {
-      this.requestListener = requestListener;
+    SingleRequestBuilder addRequestListener(RequestListener<List> requestListener) {
+      this.requestListeners.add(requestListener);
       return this;
     }
 
@@ -984,17 +987,18 @@ SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
     }
 
     SingleRequest<List> build() {
-      RequestOptions requestOptions = new RequestOptions()
-          .error(errorDrawable)
-          .placeholder(placeholderDrawable)
-          .fallback(fallbackDrawable)
-          .override(overrideWidth, overrideHeight)
-          .priority(priority)
-          .signature(signature)
-          .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
+      RequestOptions requestOptions =
+          new RequestOptions()
+              .error(errorDrawable)
+              .placeholder(placeholderDrawable)
+              .fallback(fallbackDrawable)
+              .override(overrideWidth, overrideHeight)
+              .priority(priority)
+              .signature(signature)
+              .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
       return SingleRequest.obtain(
-          /*context=*/glideContext,
-          /*glideContext=*/glideContext,
+          /*context=*/ glideContext,
+          /*glideContext=*/ glideContext,
           model,
           transcodeClass,
           requestOptions,
@@ -1003,13 +1007,18 @@ SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
           priority,
           target,
           /*targetListener=*/ null,
-          requestListener,
+          requestListeners,
           requestCoordinator,
           engine,
-          transitionFactory);
+          transitionFactory,
+          Executors.directExecutor());
     }
   }
 
+  private static Drawable anyDrawableOrNull() {
+    return any();
+  }
+
   // TODO do we want to move these to Util?
   @SuppressWarnings("unchecked")
   private static <T> Transition<T> mockTransition() {
@@ -1027,12 +1036,16 @@ private static GlideException isAGlideException() {
 
   @SuppressWarnings("unchecked")
   private static <T> Transition<T> anyTransition() {
-    return any(Transition.class);
+    return any();
+  }
+
+  private static Executor anyExecutor() {
+    return any(Executor.class);
   }
 
   private static class CallResourceCallback implements Answer {
 
-    private Resource resource;
+    private final Resource resource;
 
     CallResourceCallback(Resource resource) {
       this.resource = resource;
@@ -1041,9 +1054,8 @@ private static GlideException isAGlideException() {
     @Override
     public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
       ResourceCallback cb =
-          (ResourceCallback) invocationOnMock.getArguments()[
-              invocationOnMock.getArguments().length
-                  - 1];
+          (ResourceCallback)
+              invocationOnMock.getArguments()[invocationOnMock.getArguments().length - 2];
       cb.onResourceReady(resource, DataSource.REMOTE);
       return null;
     }
@@ -1051,8 +1063,8 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
   private static class CallSizeReady implements Answer {
 
-    private int width;
-    private int height;
+    private final int width;
+    private final int height;
 
     CallSizeReady(int width, int height) {
       this.width = width;
@@ -1072,58 +1084,50 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     private Drawable currentPlaceholder;
 
     @Override
-    public void onLoadCleared(Drawable placeholder) {
+    public void onLoadCleared(@Nullable Drawable placeholder) {
       currentPlaceholder = placeholder;
     }
 
     @Override
-    public void onLoadStarted(Drawable placeholder) {
+    public void onLoadStarted(@Nullable Drawable placeholder) {
       currentPlaceholder = placeholder;
-
     }
 
     @Override
-    public void onLoadFailed(Drawable errorDrawable) {
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
       currentPlaceholder = errorDrawable;
-
     }
 
     @Override
-    public void onResourceReady(List resource, Transition<? super List> transition) {
+    public void onResourceReady(
+        @NonNull List resource, @Nullable Transition<? super List> transition) {
       currentPlaceholder = null;
     }
 
-
     @Override
-    public void getSize(SizeReadyCallback cb) {
-    }
+    public void getSize(@NonNull SizeReadyCallback cb) {}
 
     @Override
-    public void removeCallback(SizeReadyCallback cb) {
+    public void removeCallback(@NonNull SizeReadyCallback cb) {
       // Do nothing.
     }
 
     @Override
-    public void setRequest(Request request) {
-    }
+    public void setRequest(@Nullable Request request) {}
 
+    @Nullable
     @Override
     public Request getRequest() {
       return null;
     }
 
     @Override
-    public void onStart() {
-    }
+    public void onStart() {}
 
     @Override
-    public void onStop() {
-
-    }
+    public void onStop() {}
 
     @Override
-    public void onDestroy() {
-
-    }
+    public void onDestroy() {}
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index cf2087c8c..dda24ef98 100644
--- a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.request;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -16,21 +16,21 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 @RunWith(JUnit4.class)
 public class ThumbnailRequestCoordinatorTest {
-  private Request full;
-  private Request thumb;
+  @Mock private Request full;
+  @Mock private Request thumb;
+  @Mock private RequestCoordinator parent;
   private ThumbnailRequestCoordinator coordinator;
-  private RequestCoordinator parent;
 
   @Before
   public void setUp() {
-    full = mock(Request.class);
-    thumb = mock(Request.class);
-    parent = mock(RequestCoordinator.class);
+    MockitoAnnotations.initMocks(this);
     coordinator = new ThumbnailRequestCoordinator();
     coordinator.setRequests(full, thumb);
   }
@@ -86,15 +86,45 @@ public void testDoesNotStartThumbOnRunIfRunning() {
   }
 
   @Test
-  public void testDoesNotStartFullIfClearedByThumb() {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocation) throws Throwable {
-        coordinator.clear();
+  public void begin_whenFullIsComplete_startsFull() {
+    when(full.isComplete()).thenReturn(true);
 
-        return null;
-      }
-    }).when(thumb).begin();
+    coordinator.begin();
+
+    verify(full).begin();
+  }
+
+  @Test
+  public void begin_whenFullIsComplete_doesNotBeginThumb() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    verify(thumb, never()).begin();
+  }
+
+  @Test
+  public void begin_whenFullIsComplete_doesNotSetRunning() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void testDoesNotStartFullIfClearedByThumb() {
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocation) throws Throwable {
+                coordinator.clear();
+
+                return null;
+              }
+            })
+        .when(thumb)
+        .begin();
 
     coordinator.begin();
 
@@ -116,19 +146,6 @@ public void testRecyclesRequestsWhenRecycled() {
     verify(full).recycle();
   }
 
-  @Test
-  public void testIsPausedWhenFullIsPaused() {
-    when(full.isPaused()).thenReturn(true);
-    assertTrue(coordinator.isPaused());
-  }
-
-  @Test
-  public void testPausesBothRequestsWhenPaused() {
-    coordinator.pause();
-    verify(full).pause();
-    verify(thumb).pause();
-  }
-
   @Test
   public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
     coordinator = new ThumbnailRequestCoordinator();
@@ -154,7 +171,7 @@ public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImag
 
   @Test
   public void
-  testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
+      testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
     when(full.isResourceSet()).thenReturn(false);
     assertTrue(coordinator.canSetImage(thumb));
   }
@@ -317,9 +334,9 @@ public void testDoesNotClearThumbOnThumbRequestComplete() {
 
   @Test
   public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
-      when(thumb.isComplete()).thenReturn(true);
-      coordinator.onRequestSuccess(full);
-      verify(thumb, never()).clear();
+    when(thumb.isComplete()).thenReturn(true);
+    coordinator.onRequestSuccess(full);
+    verify(thumb, never()).clear();
   }
 
   @Test
@@ -331,6 +348,32 @@ public void testDoesNotNotifyParentOnThumbRequestComplete() {
     verify(parent, never()).onRequestSuccess(any(Request.class));
   }
 
+  @Test
+  public void canNotifyCleared_withThumbRequest_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(thumb)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_andNullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanClear_returnsTrue() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanNotClear_returnsFalse() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    assertThat(coordinator.canNotifyCleared(full)).isFalse();
+  }
+
   @Test
   public void testIsEquivalentTo() {
     ThumbnailRequestCoordinator first = new ThumbnailRequestCoordinator();
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index 4ec3ed752..88109a480 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -22,8 +22,7 @@
 import org.robolectric.shadows.ShadowAppWidgetManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = AppWidgetTargetTest
-    .UpdateShadowAppWidgetManager.class)
+@Config(sdk = 18, shadows = AppWidgetTargetTest.UpdateShadowAppWidgetManager.class)
 public class AppWidgetTargetTest {
   private UpdateShadowAppWidgetManager shadowManager;
   private RemoteViews views;
@@ -31,8 +30,7 @@
 
   @Before
   public void setUp() {
-    shadowManager = (UpdateShadowAppWidgetManager) Shadow
-        .extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
+    shadowManager = Shadow.extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
     viewId = 1234;
     views = mock(RemoteViews.class);
   }
@@ -55,8 +53,9 @@ public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
     AppWidgetTarget target =
         new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
-    target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
-    /*glideAnimation*/);
+    target.onResourceReady(
+        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+        /*glideAnimation*/ );
 
     assertEquals(componentName, shadowManager.updatedComponentName);
     assertEquals(views, shadowManager.updatedRemoteViews);
@@ -64,7 +63,7 @@ public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
 
   @Test
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
-    int[] widgetIds = new int[] { 1 };
+    int[] widgetIds = new int[] {1};
     AppWidgetTarget target =
         new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
@@ -76,12 +75,13 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
 
   @Test
   public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
-    int[] widgetIds = new int[] { 1 };
+    int[] widgetIds = new int[] {1};
     AppWidgetTarget target =
         new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
-    target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
-    /*glideAnimation*/);
+    target.onResourceReady(
+        Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
+        /*glideAnimation*/ );
 
     assertThat(widgetIds).isEqualTo(shadowManager.updatedWidgetIds);
     assertEquals(views, shadowManager.updatedRemoteViews);
@@ -99,14 +99,14 @@ public void testThrowsWhenGivenNullContextWithComponentName() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application,
-        viewId, null /*remoteViews*/, 1 /*widgetIds*/);
+    new AppWidgetTarget(
+        RuntimeEnvironment.application, viewId, null /*remoteViews*/, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application,
-        viewId, null /*remoteViews*/, mock(ComponentName.class));
+    new AppWidgetTarget(
+        RuntimeEnvironment.application, viewId, null /*remoteViews*/, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
@@ -126,11 +126,12 @@ public void testThrowsWhenGivenNullComponentName() {
 
   @Implements(AppWidgetManager.class)
   public static class UpdateShadowAppWidgetManager extends ShadowAppWidgetManager {
-    public int[] updatedWidgetIds;
-    public RemoteViews updatedRemoteViews;
-    public ComponentName updatedComponentName;
+    int[] updatedWidgetIds;
+    RemoteViews updatedRemoteViews;
+    ComponentName updatedComponentName;
 
     @Implementation
+    @Override
     public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
       updatedWidgetIds = appWidgetIds;
       updatedRemoteViews = views;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
index 31e0bb5c6..02287f981 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
@@ -13,7 +13,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class BitmapImageViewTargetTest {
 
   private ImageView view;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
index d0967ce08..8d33eea58 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
@@ -16,7 +16,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ImageViewTargetFactoryTest {
   private ImageViewTargetFactory factory;
   private ImageView view;
@@ -37,8 +37,10 @@ public void testReturnsTargetForBitmaps() {
 
   @Test
   public void testReturnsTargetForBitmapDrawables() {
-    BitmapDrawable drawable = new BitmapDrawable(RuntimeEnvironment.application.getResources(),
-        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
+    BitmapDrawable drawable =
+        new BitmapDrawable(
+            RuntimeEnvironment.application.getResources(),
+            Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
 
     Target<BitmapDrawable> target = factory.buildTarget(view, BitmapDrawable.class);
     target.onResourceReady(drawable, null);
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
similarity index 59%
rename from library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index eeb0b1fcf..2cbd4c4ac 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -1,14 +1,18 @@
 package com.bumptech.glide.request.target;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Color;
+import android.graphics.drawable.Animatable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
@@ -16,20 +20,27 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ImageViewTargetTest {
 
+  @Mock private AnimatedDrawable animatedDrawable;
   private ImageView view;
   private TestTarget target;
   private ColorDrawable drawable;
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
     view = new ImageView(RuntimeEnvironment.application);
     target = new TestTarget(view);
     drawable = new ColorDrawable(Color.RED);
@@ -72,7 +83,8 @@ public void testSetsDrawableOnLoadCleared() {
 
   @Test
   public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
-    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked")
+    Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(any(Drawable.class), eq(target))).thenReturn(false);
     Drawable resource = new ColorDrawable(Color.GRAY);
     target.onResourceReady(resource, animation);
@@ -83,7 +95,8 @@ public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
   @Test
   public void testDoesNotSetDrawableOnViewInOnResourceReadyWhenAnimationReturnsTrue() {
     Drawable resource = new ColorDrawable(Color.RED);
-    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked")
+    Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(eq(resource), eq(target))).thenReturn(true);
     target.onResourceReady(resource, animation);
 
@@ -95,23 +108,54 @@ public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
     Drawable placeholder = new ColorDrawable(Color.BLACK);
     view.setImageDrawable(placeholder);
 
-    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked")
+    Transition<Drawable> animation = mock(Transition.class);
 
     target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
 
-    verify(animation).transition(eq(placeholder), eq(target));
+    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);
+    verify(animation).transition(drawableCaptor.capture(), eq(target));
+    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.GREEN);
+  }
+
+  @Test
+  public void onResourceReady_withAnimatableResource_startsAnimatableAfterSetResource() {
+    AnimatedDrawable drawable = mock(AnimatedDrawable.class);
+    ImageView view = mock(ImageView.class);
+    target = new TestTarget(view);
+    target.onResourceReady(drawable, /*transition=*/ null);
+
+    InOrder order = inOrder(view, drawable);
+    order.verify(view).setImageDrawable(drawable);
+    order.verify(drawable).start();
+  }
+
+  @Test
+  public void onLoadCleared_withAnimatableDrawable_stopsDrawable() {
+    target.onResourceReady(animatedDrawable, /*transition=*/ null);
+    verify(animatedDrawable).start();
+    verify(animatedDrawable, never()).stop();
+
+    target.onLoadCleared(/*placeholder=*/ null);
+
+    verify(animatedDrawable).stop();
+  }
+
+  private abstract static class AnimatedDrawable extends Drawable implements Animatable {
+    // Intentionally empty.
   }
 
-  private static class TestTarget extends ImageViewTarget<Drawable> {
+  private static final class TestTarget extends ImageViewTarget<Drawable> {
     public Drawable resource;
 
-    public TestTarget(ImageView view) {
+    TestTarget(ImageView view) {
       super(view);
     }
 
     @Override
     protected void setResource(Drawable resource) {
       this.resource = resource;
+      view.setImageDrawable(resource);
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index eae33c7e4..098d3dca8 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -22,8 +22,7 @@
 import org.robolectric.shadows.ShadowNotificationManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = NotificationTargetTest
-    .UpdateShadowNotificationManager.class)
+@Config(sdk = 18, shadows = NotificationTargetTest.UpdateShadowNotificationManager.class)
 public class NotificationTargetTest {
   private UpdateShadowNotificationManager shadowManager;
   private RemoteViews remoteViews;
@@ -35,9 +34,10 @@
 
   @Before
   public void setUp() {
-    NotificationManager notificationManager = (NotificationManager) RuntimeEnvironment.application
-        .getSystemService(Context.NOTIFICATION_SERVICE);
-    shadowManager = (UpdateShadowNotificationManager) Shadow.extract(notificationManager);
+    NotificationManager notificationManager =
+        (NotificationManager)
+            RuntimeEnvironment.application.getSystemService(Context.NOTIFICATION_SERVICE);
+    shadowManager = Shadow.extract(notificationManager);
 
     remoteViews = mock(RemoteViews.class);
     viewId = 123;
@@ -45,10 +45,16 @@ public void setUp() {
     notificationId = 456;
     notificationTag = "tag";
 
-
     target =
-        new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
-            viewId, remoteViews, notification, notificationId, notificationTag);
+        new NotificationTarget(
+            RuntimeEnvironment.application,
+            100 /*width*/,
+            100 /*height*/,
+            viewId,
+            remoteViews,
+            notification,
+            notificationId,
+            notificationTag);
   }
 
   @Test
@@ -60,8 +66,9 @@ public void testSetsBitmapOnRemoteViewsWithGivenImageIdOnResourceReady() {
 
   @Test
   public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourceReady() {
-    target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
-    /*glideAnimation*/);
+    target.onResourceReady(
+        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+        /*glideAnimation*/ );
 
     assertEquals(notificationId, shadowManager.updatedNotificationId);
     assertEquals(notificationTag, shadowManager.updatedNotificationTag);
@@ -70,23 +77,40 @@ public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourc
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new NotificationTarget(null /*context*/, 100 /*width*/, 100 /*height*/,
-        123 /*viewId*/, mock(RemoteViews.class), mock(Notification.class), 456 /*notificationId*/,
+    new NotificationTarget(
+        null /*context*/,
+        100 /*width*/,
+        100 /*height*/,
+        123 /*viewId*/,
+        mock(RemoteViews.class),
+        mock(Notification.class),
+        456 /*notificationId*/,
         "tag" /*notificationTag*/);
   }
 
-
   @Test(expected = NullPointerException.class)
   public void testThrowsIfNotificationIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
-        123 /*viewId*/, mock(RemoteViews.class), null /*notification*/, 456 /*notificationId*/,
+    new NotificationTarget(
+        RuntimeEnvironment.application,
+        100 /*width*/,
+        100 /*height*/,
+        123 /*viewId*/,
+        mock(RemoteViews.class),
+        null /*notification*/,
+        456 /*notificationId*/,
         "tag" /*notificationTag*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfRemoteViewsIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
-        123 /*viewId*/, null /*remoteViews*/, mock(Notification.class), 456 /*notificationId*/,
+    new NotificationTarget(
+        RuntimeEnvironment.application,
+        100 /*width*/,
+        100 /*height*/,
+        123 /*viewId*/,
+        null /*remoteViews*/,
+        mock(Notification.class),
+        456 /*notificationId*/,
         "tag" /*notificationTag*/);
   }
 
@@ -97,6 +121,7 @@ public void testThrowsIfRemoteViewsIsNull() {
     Notification updatedNotification;
 
     @Implementation
+    @Override
     public void notify(String notificationTag, int notificationId, Notification notification) {
       updatedNotificationTag = notificationTag;
       updatedNotificationId = notificationId;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
similarity index 94%
rename from library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
index e5e397f41..47029cd0f 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
@@ -15,10 +15,10 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class PreloadTargetTest {
 
-  @Mock RequestManager requestManager;
+  @Mock private RequestManager requestManager;
 
   @Before
   public void setUp() {
diff --git a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
index 14e1362f7..d1fa91a30 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -2,6 +2,8 @@
 
 import static org.mockito.Mockito.mock;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.request.transition.Transition;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -32,7 +34,13 @@ public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {
 
   @Test
   public void testCanBeConstructedWithoutDimensions() {
-    getTarget();
+    new SimpleTarget<Object>() {
+      @Override
+      public void onResourceReady(
+          @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+        // Do nothing.
+      }
+    };
   }
 
   @Test
@@ -45,19 +53,11 @@ public void testGetSizeDoesNotThrowWithSizeOriginal() {
     getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));
   }
 
-  private SimpleTarget<Object> getTarget() {
-    return new SimpleTarget<Object>() {
-      @Override
-      public void onResourceReady(Object resource, Transition<? super Object> transition) {
-        // Do nothing.
-      }
-    };
-  }
-
   private SimpleTarget<Object> getTarget(int width, int height) {
     return new SimpleTarget<Object>(width, height) {
       @Override
-      public void onResourceReady(Object resource, Transition<? super Object> transition) {
+      public void onResourceReady(
+          @NonNull Object resource, @Nullable Transition<? super Object> transition) {
         // Do nothing.
       }
     };
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
similarity index 61%
rename from library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index e8a603d36..8cc1c6640 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -12,17 +12,25 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.view.Display;
 import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
 import org.junit.After;
 import org.junit.Before;
@@ -37,13 +45,17 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
-import org.robolectric.shadows.ShadowDisplay;
 import org.robolectric.shadows.ShadowView;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 19, shadows = { ViewTargetTest.SizedShadowView.class,
-    ViewTargetTest.PreDrawShadowViewTreeObserver.class })
+@Config(
+    sdk = 19,
+    shadows = {
+      ViewTargetTest.SizedShadowView.class,
+      ViewTargetTest.PreDrawShadowViewTreeObserver.class
+    })
 public class ViewTargetTest {
   private View view;
   private ViewTarget<View, Object> target;
@@ -52,6 +64,7 @@
   @Mock private SizeReadyCallback cb;
   @Mock private Request request;
   private int sdkVersion;
+  private AttachStateTarget attachStateTarget;
 
   @Before
   public void setUp() {
@@ -59,6 +72,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     view = new View(RuntimeEnvironment.application);
     target = new TestViewTarget(view);
+    attachStateTarget = new AttachStateTarget(view);
 
     shadowView = Shadow.extract(view);
     shadowObserver = Shadow.extract(view.getViewTreeObserver());
@@ -80,12 +94,6 @@ public void testReturnsNullFromGetRequestIfNoRequestSet() {
     assertNull(target.getRequest());
   }
 
-  @Test(expected = IllegalArgumentException.class)
-  public void testThrowsIfViewTagIsNotRequestObject() {
-    view.setTag(new Object());
-    target.getRequest();
-  }
-
   @Test
   public void testCanSetAndRetrieveRequest() {
     target.setRequest(request);
@@ -105,10 +113,7 @@ public void testRetrievesRequestFromPreviousTargetForView() {
   @Test
   public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
     int dimens = 333;
-    shadowView
-        .setWidth(dimens)
-        .setHeight(dimens)
-        .setIsLaidOut(true);
+    shadowView.setWidth(dimens).setHeight(dimens).setIsLaidOut(true);
 
     target.getSize(cb);
 
@@ -181,9 +186,7 @@ public void getSize_withWrapContentWidthAndMatchParentHeight_usesDisplayDimenWid
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int height = 32;
-    shadowView
-        .setHeight(height)
-        .setIsLaidOut(true);
+    shadowView.setHeight(height).setIsLaidOut(true);
 
     shadowObserver.fireOnPreDrawListeners();
 
@@ -201,11 +204,8 @@ public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndDisplay
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
-
     int width = 32;
-    shadowView
-        .setWidth(width)
-        .setIsLaidOut(true);
+    shadowView.setWidth(width).setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(width, 400);
@@ -222,10 +222,7 @@ public void testMatchParentWidthAndHeight() {
 
     int width = 32;
     int height = 45;
-    shadowView
-        .setWidth(width)
-        .setHeight(height)
-        .setIsLaidOut(true);
+    shadowView.setWidth(width).setHeight(height).setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -237,10 +234,7 @@ public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
 
     int width = 12;
     int height = 32;
-    shadowView
-        .setWidth(width)
-        .setHeight(height)
-        .setIsLaidOut(true);
+    shadowView.setWidth(width).setHeight(height).setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -255,10 +249,7 @@ public void testSizeCallbacksAreCalledInOrderPreDraw() {
     }
 
     int width = 100, height = 111;
-    shadowView
-        .setWidth(width)
-        .setHeight(height)
-        .setIsLaidOut(true);
+    shadowView.setWidth(width).setHeight(height).setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     InOrder order = inOrder((Object[]) cbs);
@@ -397,10 +388,7 @@ public void testDecreasesDimensionsByViewPadding() {
 
   @Test
   public void getSize_withValidWidthAndHeight_notLaidOut_notLayoutRequested_callsSizeReady() {
-    shadowView
-        .setWidth(100)
-        .setHeight(100)
-        .setIsLaidOut(false);
+    shadowView.setWidth(100).setHeight(100).setIsLaidOut(false);
     target.getSize(cb);
 
     verify(cb).onSizeReady(100, 100);
@@ -433,10 +421,7 @@ public void getSize_withLayoutParams_emptyParams_notLaidOutOrLayoutRequested_cal
   @Test
   public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeReady() {
     Util.setSdkVersionInt(18);
-    shadowView
-        .setWidth(100)
-        .setHeight(100)
-        .requestLayout();
+    shadowView.setWidth(100).setHeight(100).requestLayout();
 
     target.getSize(cb);
 
@@ -445,10 +430,7 @@ public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeRead
 
   @Test
   public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
-    shadowView
-        .setWidth(100)
-        .setHeight(100)
-        .setIsLaidOut(true);
+    shadowView.setWidth(100).setHeight(100).setIsLaidOut(true);
 
     view.setPadding(50, 50, 50, 50);
 
@@ -460,19 +442,163 @@ public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
   private void setDisplayDimens(Integer width, Integer height) {
     WindowManager windowManager =
         (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
-    ShadowDisplay shadowDisplay = Shadows.shadowOf(windowManager.getDefaultDisplay());
+    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
     if (width != null) {
-      shadowDisplay.setWidth(width);
+      Shadows.shadowOf(display).setWidth(width);
     }
 
     if (height != null) {
-      shadowDisplay.setHeight(height);
+      Shadows.shadowOf(display).setHeight(height);
     }
   }
 
+  @Test
+  public void clearOnDetach_onDetach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    shadowView.callOnAttachedToWindow();
+  }
+
+  // This behavior isn't clearly correct, but it doesn't seem like there's any harm to clear an
+  // already cleared request, so we might as well avoid the extra check/complexity in the code.
+  @Test
+  public void clearOnDetach_onDetach_withClearedRequest_clearsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withRunningRequest_pausesRequestOnce() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_moreThanOnce_registersObserverOnce() {
+    attachStateTarget.clearOnDetach().clearOnDetach();
+
+    assertThat(shadowView.attachStateListeners).hasSize(1);
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
+    attachStateTarget.clearOnDetach().clearOnDetach().clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).clear();
+  }
+
+  // This behavior isn't clearly correct, but it doesn't seem like there's any harm to clear an
+  // already cleared request, so we might as well avoid the extra check/complexity in the code.
+  @Test
+  public void clearOnDetach_onDetach_afterLoadCleared_clearsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    shadowView.callOnAttachedToWindow();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withRunningRequest_doesNotBeginRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(false);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withClearedRequest_beginsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_afterLoadClearedAndRestarted_onAttach_beingsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_afterLoadCleared_doesNotBeingRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void onLoadStarted_withoutClearOnDetach_doesNotAddListener() {
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+
+    assertThat(shadowView.attachStateListeners).isEmpty();
+  }
+
+  // containsExactly does not need its result checked.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void onLoadCleared_withoutClearOnDetach_doesNotRemoveListeners() {
+    OnAttachStateChangeListener expected =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {}
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {}
+        };
+    shadowView.addOnAttachStateChangeListener(expected);
+
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+
+    assertThat(shadowView.attachStateListeners).containsExactly(expected);
+  }
+
   @Implements(ViewTreeObserver.class)
-  public static class PreDrawShadowViewTreeObserver {
-    private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
+  public static final class PreDrawShadowViewTreeObserver {
+    private final CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners =
+        new CopyOnWriteArrayList<>();
     private boolean isAlive = true;
 
     @SuppressWarnings("unused")
@@ -490,6 +616,7 @@ public void removeOnPreDrawListener(OnPreDrawListener listener) {
     }
 
     @Implementation
+    @SuppressWarnings("WeakerAccess")
     public boolean isAlive() {
       return isAlive;
     }
@@ -500,28 +627,32 @@ private void checkIsAlive() {
       }
     }
 
-    public void setIsAlive(boolean isAlive) {
+    void setIsAlive(@SuppressWarnings("SameParameterValue") boolean isAlive) {
       this.isAlive = isAlive;
     }
 
-    public void fireOnPreDrawListeners() {
+    void fireOnPreDrawListeners() {
       for (OnPreDrawListener listener : preDrawListeners) {
         listener.onPreDraw();
       }
     }
 
-    public List<OnPreDrawListener> getPreDrawListeners() {
+    List<OnPreDrawListener> getPreDrawListeners() {
       return preDrawListeners;
     }
   }
 
+  // Shadows require stronger access and unused values.
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess", "unused"})
   @Implements(View.class)
-  public static class SizedShadowView extends ShadowView {
+  public static final class SizedShadowView extends ShadowView {
+    @RealObject private View view;
     private int width;
     private int height;
     private LayoutParams layoutParams;
     private boolean isLaidOut;
     private boolean isLayoutRequested;
+    final Set<OnAttachStateChangeListener> attachStateListeners = new HashSet<>();
 
     public SizedShadowView setWidth(int width) {
       this.width = width;
@@ -533,17 +664,54 @@ public SizedShadowView setHeight(int height) {
       return this;
     }
 
+    @Implementation
+    public void addOnAttachStateChangeListener(OnAttachStateChangeListener listener) {
+      attachStateListeners.add(listener);
+    }
+
+    @Implementation
+    public void removeOnAttachStateChangeListener(OnAttachStateChangeListener listener) {
+      attachStateListeners.remove(listener);
+    }
+
+    @Implementation
+    public void onAttachedToWindow() {
+      for (OnAttachStateChangeListener listener : attachStateListeners) {
+        listener.onViewAttachedToWindow(view);
+      }
+    }
+
+    @Implementation
+    public void onDetachedFromWindow() {
+      for (OnAttachStateChangeListener listener : attachStateListeners) {
+        listener.onViewDetachedFromWindow(view);
+      }
+    }
+
+    @Override
+    public void callOnAttachedToWindow() {
+      super.callOnAttachedToWindow();
+    }
+
+    @Override
+    public void callOnDetachedFromWindow() {
+      super.callOnDetachedFromWindow();
+    }
+
+    @Implementation
     public SizedShadowView setLayoutParams(LayoutParams layoutParams) {
       this.layoutParams = layoutParams;
       return this;
     }
 
+    @Implementation
     public SizedShadowView setIsLaidOut(boolean isLaidOut) {
       this.isLaidOut = isLaidOut;
       return this;
     }
 
     @Implementation
+    @Override
     public void requestLayout() {
       isLayoutRequested = true;
     }
@@ -574,30 +742,49 @@ public LayoutParams getLayoutParams() {
     }
   }
 
-  private static class TestViewTarget extends ViewTarget<View, Object> {
-
-    public TestViewTarget(View view) {
+  private static final class AttachStateTarget extends ViewTarget<View, Object> {
+    AttachStateTarget(View view) {
       super(view);
     }
 
     @Override
-    public void onLoadStarted(Drawable placeholder) {
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {}
+  }
 
+  private static final class TestViewTarget extends ViewTarget<View, Object> {
+
+    TestViewTarget(View view) {
+      super(view);
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onLoadFailed(Drawable errorDrawable) {
-
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+      // Avoid calling super.
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
-
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      // Avoid calling super.
     }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onLoadCleared(Drawable placeholder) {
+    public void onLoadStarted(@Nullable Drawable placeholder) {
+      // Avoid calling super.
+    }
 
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Avoid calling super.
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
index e02f29e67..8ded2f253 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -12,7 +12,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class DrawableCrossFadeFactoryTest {
 
   private DrawableCrossFadeFactory factory;
@@ -25,19 +25,22 @@ public void setUp() {
 
   @Test
   public void testReturnsNoAnimationIfFromMemoryCache() {
-    assertEquals(NoTransition.<Drawable>get(),
+    assertEquals(
+        NoTransition.<Drawable>get(),
         factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsReturnsAnimationIfNotFromMemoryCacheAndIsFirstResource() {
-    assertNotEquals(NoTransition.<Drawable>get(),
+    assertNotEquals(
+        NoTransition.<Drawable>get(),
         factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsAnimationIfNotFromMemoryCacheAndNotIsFirstResource() {
-    assertNotEquals(NoTransition.<Drawable>get(),
+    assertNotEquals(
+        NoTransition.<Drawable>get(),
         factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 022277447..52c787f6b 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -18,7 +18,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class DrawableCrossFadeViewAnimationTest {
   private CrossFadeHarness harness;
 
@@ -63,11 +63,10 @@ public void transition_withCurrentDrawable_returnsTrue() {
 
   @SuppressWarnings("unchecked")
   private static class CrossFadeHarness {
-    Drawable current = new ColorDrawable(Color.GRAY);
-    ViewAdapter adapter = mock(ViewAdapter.class);
-    int duration = 200;
-    DrawableCrossFadeTransition animation =
+    final Drawable current = new ColorDrawable(Color.GRAY);
+    final ViewAdapter adapter = mock(ViewAdapter.class);
+    final int duration = 200;
+    final DrawableCrossFadeTransition animation =
         new DrawableCrossFadeTransition(duration, true /*isCrossFadeEnabled*/);
   }
 }
-
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
index bdfef1c41..6b03eed9a 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
@@ -18,7 +18,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ViewAnimationTest {
   private ViewTransition<Object> viewAnimation;
   private ViewAdapter adapter;
@@ -50,9 +50,13 @@ public void testAlwaysReturnsFalse() {
   @Test
   public void testStartsAnimationOnAnimate() {
     Animation animation = mock(Animation.class);
-    when(viewTransitionAnimationFactory.build(any(Context.class))).thenReturn(animation);
+    when(viewTransitionAnimationFactory.build(anyContextOrNull())).thenReturn(animation);
     viewAnimation.transition(null, adapter);
     verify(view).clearAnimation();
     verify(view).startAnimation(eq(animation));
   }
+
+  private static Context anyContextOrNull() {
+    return any();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
similarity index 97%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
index 2b50c15d8..c93233194 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
@@ -19,7 +19,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ViewPropertyAnimationTest {
   private ViewPropertyTransition.Animator animator;
   private ViewPropertyTransition<Object> animation;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
similarity index 72%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
index 831a9d047..f0e33d1d8 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
@@ -23,19 +23,19 @@ public void setUp() {
 
   @Test
   public void testReturnsNoAnimationIfFromMemoryCache() {
-    assertEquals(NoTransition.get(),
-        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
+    assertEquals(
+        NoTransition.get(), factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsNoAnimationIfNotFirstResource() {
-    assertEquals(NoTransition.get(),
-        factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
+    assertEquals(
+        NoTransition.get(), factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsAnimationIfNotFromMemoryCacheAndFirstResource() {
-    assertNotEquals(NoTransition.get(),
-        factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
+    assertNotEquals(
+        NoTransition.get(), factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
index 6f1cb4ec5..c038f04ae 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
@@ -17,10 +17,8 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
 public class ViewTransitionAnimationFactoryTest {
   private ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
   private ViewAnimationFactory<Object> factory;
@@ -33,8 +31,7 @@ public void setUp() {
 
   @Test
   public void testFactoryReturnsNoAnimationIfFromMemoryCache() {
-    Transition<Object> animation =
-        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/);
+    Transition<Object> animation = factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/);
     assertEquals(NoTransition.get(), animation);
     verify(viewTransitionAnimationFactory, never()).build(RuntimeEnvironment.application);
   }
@@ -53,7 +50,7 @@ public void testFactoryReturnsActualAnimationIfNotIsFromMemoryCacheAndIsFirstRes
         factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/);
 
     Animation animation = mock(Animation.class);
-    when(viewTransitionAnimationFactory.build(any(Context.class))).thenReturn(animation);
+    when(viewTransitionAnimationFactory.build(anyContextOrNull())).thenReturn(animation);
 
     Transition.ViewAdapter adapter = mock(Transition.ViewAdapter.class);
     View view = mock(View.class);
@@ -62,4 +59,8 @@ public void testFactoryReturnsActualAnimationIfNotIsFromMemoryCacheAndIsFirstRes
 
     verify(view).startAnimation(eq(animation));
   }
+
+  private static Context anyContextOrNull() {
+    return any();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
rename to library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 95eaca505..5d0a4cb65 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -16,21 +16,21 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ExifTest {
 
   private ArrayPool byteArrayPool;
 
-  private InputStream open(String imageName) throws IOException {
-    return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
+  private InputStream open(String imageName) {
+    return TestResourceUtil.openResource(getClass(), imageName);
   }
 
   private void assertOrientation(String filePrefix, int expectedOrientation) {
     InputStream is = null;
     try {
       is = open(filePrefix + "_" + expectedOrientation + ".jpg");
-      assertEquals(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool),
-          expectedOrientation);
+      assertEquals(
+          new DefaultImageHeaderParser().getOrientation(is, byteArrayPool), expectedOrientation);
     } catch (IOException e) {
       throw new RuntimeException(e);
     } finally {
@@ -72,11 +72,11 @@ public void testPortrait() throws IOException {
   @Test
   public void testHandlesInexactSizesInByteArrayPools() {
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
       assertOrientation("Portrait", i);
     }
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
       assertOrientation("Landscape", i);
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
new file mode 100644
index 000000000..45e747de6
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -0,0 +1,83 @@
+package com.bumptech.glide.signature;
+
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Answers;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class ApplicationVersionSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = RuntimeEnvironment.application;
+  }
+
+  @After
+  public void tearDown() {
+    ApplicationVersionSignature.reset();
+  }
+
+  @Test
+  public void testCanGetKeyForSignature() {
+    Key key = ApplicationVersionSignature.obtain(context);
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
+      throws NoSuchAlgorithmException, UnsupportedEncodingException {
+    keyTester
+        .addEquivalenceGroup(
+            ApplicationVersionSignature.obtain(context),
+            ApplicationVersionSignature.obtain(context))
+        .addEquivalenceGroup(new ObjectKey("test"))
+        .addRegressionTest(
+            ApplicationVersionSignature.obtain(context),
+            "5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9")
+        .test();
+  }
+
+  @Test
+  public void testUnresolvablePackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0))
+        .thenThrow(new NameNotFoundException("test"));
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testMissingPackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0)).thenReturn(null);
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
new file mode 100644
index 000000000..6cf1d5ebf
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.signature;
+
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class EmptySignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEquals() {
+    keyTester
+        .addEquivalenceGroup(EmptySignature.obtain(), EmptySignature.obtain())
+        .addEquivalenceGroup(mock(Key.class))
+        .addEmptyDigestRegressionTest(EmptySignature.obtain())
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
new file mode 100644
index 000000000..e2eb536d2
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MediaStoreSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void equalsHashCodeAndDigest() {
+    keyTester
+        .addEquivalenceGroup(
+            new MediaStoreSignature("first", 100, 1), new MediaStoreSignature("first", 100, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("second", 100, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("first", 200, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("first", 100, 2))
+        .addRegressionTest(
+            new MediaStoreSignature("first", 100, 1),
+            "04959925006b21081000fd10835cc376343c0e922df0bd7346897ede6f958adf")
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
new file mode 100644
index 000000000..f5656d4a0
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyTester;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ObjectKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEqualsHashCodeAndDigest() throws NoSuchAlgorithmException {
+    Object object = new Object();
+    keyTester
+        .addEquivalenceGroup(new ObjectKey(object), new ObjectKey(object))
+        .addEquivalenceGroup(new ObjectKey(new Object()))
+        .addEquivalenceGroup(new ObjectKey("test"), new ObjectKey("test"))
+        .addRegressionTest(
+            new ObjectKey("test"),
+            "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java b/library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
similarity index 69%
rename from library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
rename to library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
index 796a09240..3800e8b77 100644
--- a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.tests;
 
-public class BackgroundUtil {
-  public interface BackgroundTester {
-    public void runTest() throws Exception;
+public final class BackgroundUtil {
+
+  private BackgroundUtil() {
+    // Utility class.
   }
 
   public static void testInBackground(BackgroundTester test) throws InterruptedException {
@@ -14,11 +15,11 @@ public static void testInBackground(BackgroundTester test) throws InterruptedExc
     }
   }
 
-  private static class TestThread extends Thread {
+  private static final class TestThread extends Thread {
+    private final BackgroundTester test;
     private Exception exception;
-    private BackgroundTester test;
 
-    public TestThread(BackgroundTester test) {
+    private TestThread(BackgroundTester test) {
       this.test = test;
     }
 
@@ -32,4 +33,8 @@ public void run() {
       }
     }
   }
+
+  public interface BackgroundTester {
+    void runTest();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
rename to library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
rename to library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
index ddd9d06b8..42ba640d0 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
@@ -8,7 +8,7 @@
 /**
  * Exists only to "enable" logging for test coverage.
  *
- * TODO: when we can ignore Log.* via configuration, remove this class.
+ * <p>TODO: when we can ignore Log.* via configuration, remove this class.
  */
 @Implements(Log.class)
 public class GlideShadowLog extends ShadowLog {
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
new file mode 100644
index 000000000..760c5a152
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.tests;
+
+import static org.mockito.Mockito.mock;
+
+import android.os.Looper;
+import android.os.MessageQueue;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
+import org.robolectric.shadows.ShadowLegacyLooper;
+
+@Implements(Looper.class)
+public class GlideShadowLooper extends ShadowLegacyLooper {
+  public static MessageQueue queue = mock(MessageQueue.class);
+
+  @Implementation
+  public static MessageQueue myQueue() {
+    return queue;
+  }
+
+  @Resetter
+  @Override
+  public void reset() {
+    queue = mock(MessageQueue.class);
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
new file mode 100644
index 000000000..ef43c2ea8
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
@@ -0,0 +1,152 @@
+package com.bumptech.glide.tests;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assert_;
+import static org.junit.Assert.fail;
+
+import androidx.annotation.CheckResult;
+import androidx.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.google.common.base.Equivalence;
+import com.google.common.testing.EquivalenceTester;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+public final class KeyTester implements TestRule {
+  private static final String EMPTY_DIGEST_STRING =
+      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
+  // Use LinkedHashMap to keep iteration based on insertion order.
+  private final Map<Key, String> regressionTests = new LinkedHashMap<>();
+  private final Sha256 sha256 = new Sha256();
+  private final EquivalenceTester<Key> tester = EquivalenceTester.of(new KeyEquivalence(sha256));
+  private boolean isUsedWithoutCallingTest;
+  private boolean isUsedAsRule;
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+
+      @Override
+      public void evaluate() throws Throwable {
+        isUsedAsRule = true;
+        base.evaluate();
+        if (isUsedWithoutCallingTest) {
+          fail("You used KeyTester but failed to call test()!");
+        }
+      }
+    };
+  }
+
+  private void assertUsedAsRule() {
+    if (!isUsedAsRule) {
+      fail("You must use KeyTester as an @Rule");
+    }
+  }
+
+  @CheckResult
+  public KeyTester addEquivalenceGroup(Key first, Key... rest) {
+    assertUsedAsRule();
+    isUsedWithoutCallingTest = true;
+    tester.addEquivalenceGroup(first, rest);
+    return this;
+  }
+
+  @CheckResult
+  public KeyTester addRegressionTest(Key key, String expectedDigest) {
+    assertUsedAsRule();
+    if (EMPTY_DIGEST_STRING.equals(expectedDigest)) {
+      throw new IllegalArgumentException(
+          "Expected digest is empty, if this is intended use "
+              + "addEmptyDigestRegressionTest instead");
+    }
+    return addRegressionTestInternal(key, expectedDigest);
+  }
+
+  @CheckResult
+  public KeyTester addEmptyDigestRegressionTest(Key key) {
+    assertUsedAsRule();
+    return addRegressionTestInternal(key, EMPTY_DIGEST_STRING);
+  }
+
+  private KeyTester addRegressionTestInternal(Key key, String expectedDigest) {
+    isUsedWithoutCallingTest = true;
+    String oldValue = regressionTests.put(key, expectedDigest);
+    if (oldValue != null) {
+      throw new IllegalArgumentException(
+          "Given multiple values for: " + key + " old: " + oldValue + " new: " + expectedDigest);
+    }
+    return this;
+  }
+
+  public void test() {
+    assertUsedAsRule();
+    isUsedWithoutCallingTest = false;
+    tester.test();
+
+    assertThat(regressionTests).isNotEmpty();
+    int i = 1;
+    for (Entry<Key, String> entry : regressionTests.entrySet()) {
+      assert_()
+          .withMessage(
+              "Unexpected digest for regression test [" + i + "]: with key: " + entry.getKey())
+          .that(sha256.getStringDigest(entry.getKey()))
+          .isEqualTo(entry.getValue());
+      i++;
+    }
+  }
+
+  private static final class Sha256 {
+
+    private final MessageDigest digest;
+
+    Sha256() {
+      try {
+        digest = MessageDigest.getInstance("SHA-256");
+      } catch (NoSuchAlgorithmException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    private byte[] getDigest(Key key) {
+      try {
+        key.updateDiskCacheKey(digest);
+        return digest.digest();
+      } finally {
+        digest.reset();
+      }
+    }
+
+    String getStringDigest(Key key) {
+      return com.bumptech.glide.util.Util.sha256BytesToHex(getDigest(key));
+    }
+  }
+
+  /** Tests equals, hashcode and digest methods of {@link Key}s. */
+  private static final class KeyEquivalence extends Equivalence<Key> {
+
+    private final Sha256 sha256;
+
+    KeyEquivalence(Sha256 sha256) {
+      this.sha256 = sha256;
+    }
+
+    @Override
+    protected boolean doEquivalent(@NonNull Key a, @NonNull Key b) {
+      byte[] aDigest = sha256.getDigest(a);
+      byte[] bDigest = sha256.getDigest(b);
+      return a.equals(b) && Arrays.equals(aDigest, bDigest);
+    }
+
+    @Override
+    protected int doHash(@NonNull Key key) {
+      return key.hashCode();
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
new file mode 100644
index 000000000..97af3525b
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.tests;
+
+import com.bumptech.glide.Glide;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/** Clears out Glide's disk cache and the Glide singleton after every test method. */
+public final class TearDownGlide implements TestRule {
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          Glide.tearDown();
+        }
+      }
+    };
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/tests/Util.java
rename to library/test/src/test/java/com/bumptech/glide/tests/Util.java
index 8f80b6049..ba0cf2da8 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
@@ -27,14 +27,10 @@
 // FIXME move to testutil module
 public class Util {
 
-  public static String getExpectedClassId(Class<?> clazz) {
-    return clazz.getSimpleName() + "." + clazz.getPackage().getName();
-  }
-
   /**
-   * Gives the proper generic type to the {@link ArgumentCaptor}.
-   * Only useful when the captor's {@code T} is also a generic type.
-   * Without this it's really ugly to have a properly typed captor object.
+   * Gives the proper generic type to the {@link ArgumentCaptor}. Only useful when the captor's
+   * {@code T} is also a generic type. Without this it's really ugly to have a properly typed captor
+   * object.
    */
   @SuppressWarnings("unchecked")
   public static <T> ArgumentCaptor<T> cast(ArgumentCaptor<?> captor) {
@@ -50,8 +46,8 @@ public static Context anyContext() {
   }
 
   /**
-   * Creates a Mockito argument matcher to be used in verify.
-   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   * Creates a Mockito argument matcher to be used in verify. It returns a generic typed {@link
+   * Resource} to prevent unchecked warnings.
    */
   @SuppressWarnings("unchecked")
   public static <T> Resource<T> anyResource() {
@@ -59,8 +55,8 @@ public static Context anyContext() {
   }
 
   /**
-   * Creates a Mockito mock object.
-   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   * Creates a Mockito mock object. It returns a generic typed {@link Resource} to prevent unchecked
+   * warnings.
    */
   @SuppressWarnings("unchecked")
   public static <T> Resource<T> mockResource() {
@@ -106,8 +102,8 @@ public static void setSdkVersionInt(int version) {
     ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", version);
   }
 
-  public static class WriteDigest implements Answer<Void> {
-    private String toWrite;
+  public static final class WriteDigest implements Answer<Void> {
+    private final String toWrite;
 
     public WriteDigest(String toWrite) {
       this.toWrite = toWrite;
@@ -116,13 +112,14 @@ public WriteDigest(String toWrite) {
     @Override
     public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       MessageDigest md = (MessageDigest) invocationOnMock.getArguments()[0];
-      md.update(toWrite.getBytes());
+      md.update(toWrite.getBytes("UTF-8"));
       return null;
     }
   }
 
-  public static class ReturnsSelfAnswer implements Answer<Object> {
+  public static final class ReturnsSelfAnswer implements Answer<Object> {
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
       Object mock = invocation.getMock();
       if (invocation.getMethod().getReturnType().isInstance(mock)) {
@@ -133,9 +130,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class CallDataReady<T> implements Answer<Void> {
+  public static final class CallDataReady<T> implements Answer<Void> {
 
-    private T data;
+    private final T data;
 
     public CallDataReady(T data) {
       this.data = data;
@@ -151,7 +148,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
   }
 
-  public static class CreateBitmap implements Answer<Bitmap> {
+  public static final class CreateBitmap implements Answer<Bitmap> {
 
     @Override
     public Bitmap answer(InvocationOnMock invocation) throws Throwable {
diff --git a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
index 007e5a26b..1b8c93665 100644
--- a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
@@ -12,7 +12,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ByteBufferUtilTest {
   private static final int BUFFER_SIZE = 16384;
 
@@ -36,9 +36,7 @@ public void testFromStream_massive() throws IOException {
     testFromStream(12 * BUFFER_SIZE + 12345);
   }
 
-  /**
-   * All tests are basically the same thing but with different amounts of data.
-   */
+  /** All tests are basically the same thing but with different amounts of data. */
   private void testFromStream(int dataLength) throws IOException {
     byte[] bytes = createByteData(dataLength);
     InputStream byteStream = new ByteArrayInputStream(bytes);
diff --git a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
similarity index 94%
rename from library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
index 848321fe1..0201a7a8a 100644
--- a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -18,9 +18,9 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ContentLengthInputStreamTest {
-  @Mock InputStream wrapped;
+  @Mock private InputStream wrapped;
 
   @Before
   public void setUp() {
@@ -37,8 +37,7 @@ public void testAvailable_withZeroReadsAndValidContentLength_returnsContentLengt
   }
 
   @Test
-  public void testAvailable_withNullContentLength_returnsWrappedAvailable()
-      throws IOException {
+  public void testAvailable_withNullContentLength_returnsWrappedAvailable() throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, null /*contentLengthHeader*/);
     int expected = 1234;
     when(wrapped.available()).thenReturn(expected);
@@ -95,6 +94,7 @@ public void testRead_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOExc
     when(wrapped.read()).thenReturn(-1);
 
     try {
+      //noinspection ResultOfMethodCallIgnored
       is.read();
       fail("Failed to throw expected exception");
     } catch (IOException e) {
@@ -110,6 +110,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throws
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
 
     try {
+      //noinspection ResultOfMethodCallIgnored
       is.read(new byte[10], 0, 0);
       fail("Failed to throw expected exception");
     } catch (IOException e) {
@@ -121,6 +122,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throws
   public void testRead_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow() throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
     when(wrapped.read()).thenReturn(-1);
+    //noinspection ResultOfMethodCallIgnored
     is.read();
   }
 
@@ -129,6 +131,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow(
       throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
+    //noinspection ResultOfMethodCallIgnored
     is.read(new byte[10], 0, 0);
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
diff --git a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java b/library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
index 89cab6985..3600ab841 100644
--- a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
@@ -8,9 +8,11 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class FixedPreloadSizeProviderTest {
 
+  // containsExactly doesn't need a return value check.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testReturnsGivenSize() {
     int width = 500;
diff --git a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
similarity index 91%
rename from library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
index 5684e3c13..1d9dc4606 100644
--- a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -8,10 +8,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
 public class MarkEnforcingInputStreamTest {
   // An arbitrary number > 0.
   private static final int MARK_LIMIT = 5;
@@ -54,8 +52,8 @@ public void testReturnsEndOfStream_whenReadsSingleBytePastMarkLimit() throws IOE
 
   @Test
   public void
-  testOverridesByteCount_whenReadBufferLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
-      throws IOException {
+      testOverridesByteCount_whenReadBufferLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
+          throws IOException {
     MarkEnforcingInputStream is =
         new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
 
@@ -66,8 +64,8 @@ public void testReturnsEndOfStream_whenReadsSingleBytePastMarkLimit() throws IOE
 
   @Test
   public void
-  testReturnsEndOfStream_whenReadBufferLargerThanMarkLimit_withZeroBytesRemainingInMarkLimit()
-      throws IOException {
+      testReturnsEndOfStream_whenReadBufferLargerThanMarkLimit_withZeroBytesRemainingInMarkLimit()
+          throws IOException {
     MarkEnforcingInputStream is =
         new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
     is.mark(MARK_LIMIT);
@@ -118,8 +116,8 @@ public void testResetUnsetsLimit() throws IOException {
 
   @Test
   public void
-  testOverridesByteCount_whenSkipCountLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
-      throws IOException {
+      testOverridesByteCount_whenSkipCountLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
+          throws IOException {
     MarkEnforcingInputStream is =
         new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
     is.mark(MARK_LIMIT);
diff --git a/library/src/test/java/com/bumptech/glide/util/UtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/util/UtilTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
index 92d16e95b..a875b0591 100644
--- a/library/src/test/java/com/bumptech/glide/util/UtilTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
 import android.graphics.Bitmap;
@@ -9,7 +10,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 27)
 public class UtilTest {
 
   @Test
@@ -70,4 +71,12 @@ public void testReturnsLargestSizeForNullConfig() {
     int size = Util.getBitmapByteSize(width, height, null);
     assertEquals(width * height * 4, size);
   }
+
+  @Test
+  public void getBitmapByteSize_withRGBA_F16_returnsCorrectSize() {
+    int width = 100;
+    int height = 200;
+    assertThat(Util.getBitmapByteSize(width, height, Bitmap.Config.RGBA_F16))
+        .isEqualTo(width * height * 8);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
index 014cdaa19..1136a3c44 100644
--- a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -13,7 +13,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class ViewPreloadSizeProviderTest {
 
   private View view;
@@ -37,7 +37,7 @@ public void testReturnsValidSizeFromGetPreloadSizeAfterHasSize() {
     provider.onSizeReady(width, height);
 
     int[] size = provider.getPreloadSize(new Object(), 0, 0);
-    assertThat(size).asList().containsExactly(width, height);
+    assertThat(size).asList().containsExactly(width, height).inOrder();
   }
 
   @Test
@@ -51,7 +51,7 @@ public void testDoesNotObtainSizeFromViewOnceSizeIsSet() {
     provider.setView(view);
 
     int[] size = provider.getPreloadSize(new Object(), 0, 0);
-    assertThat(size).asList().containsExactly(width, height);
+    assertThat(size).asList().containsExactly(width, height).inOrder();
   }
 
   @Test
@@ -64,7 +64,7 @@ public void testCanObtainFixedSizeFromView() {
     provider.setView(view);
 
     int[] size = provider.getPreloadSize(new Object(), 0, 0);
-    assertThat(size).asList().containsExactly(width, height);
+    assertThat(size).asList().containsExactly(width, height).inOrder();
   }
 
   @Test
@@ -88,6 +88,6 @@ public void testCanObtainSizeFromViewWhenGivenViewInConstructor() {
     provider = new ViewPreloadSizeProvider<>(view);
 
     int[] size = provider.getPreloadSize(new Object(), 0, 0);
-    assertThat(size).asList().containsExactly(width, height);
+    assertThat(size).asList().containsExactly(width, height).inOrder();
   }
 }
diff --git a/library/test/src/test/java/opengles/GL.java b/library/test/src/test/java/opengles/GL.java
new file mode 100644
index 000000000..d5b6040c8
--- /dev/null
+++ b/library/test/src/test/java/opengles/GL.java
@@ -0,0 +1,7 @@
+package javax.microedition.khronos.opengles;
+
+/**
+ * TODO: Figure out why this is necessary and remove it. See:
+ * https://github.com/robolectric/robolectric-gradle-plugin/issues/145
+ */
+public interface GL {}
diff --git a/library/src/test/resources/issue387_rotated_jpeg.jpg b/library/test/src/test/resources/issue387_rotated_jpeg.jpg
similarity index 100%
rename from library/src/test/resources/issue387_rotated_jpeg.jpg
rename to library/test/src/test/resources/issue387_rotated_jpeg.jpg
diff --git a/library/src/test/resources/org.robolectric.Config.properties b/library/test/src/test/resources/org.robolectric.Config.properties
similarity index 100%
rename from library/src/test/resources/org.robolectric.Config.properties
rename to library/test/src/test/resources/org.robolectric.Config.properties
diff --git a/library/src/test/resources/short_exif_sample.jpg b/library/test/src/test/resources/short_exif_sample.jpg
similarity index 100%
rename from library/src/test/resources/short_exif_sample.jpg
rename to library/test/src/test/resources/short_exif_sample.jpg
diff --git a/library/src/test/resources/test.gif b/library/test/src/test/resources/test.gif
similarity index 100%
rename from library/src/test/resources/test.gif
rename to library/test/src/test/resources/test.gif
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
index e8753dd15..2b61ea495 100644
--- a/samples/contacturi/build.gradle
+++ b/samples/contacturi/build.gradle
@@ -1,14 +1,13 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation project(':library')
+    implementation "androidx.appcompat:appcompat:${ANDROID_X_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.contacturi'
diff --git a/samples/contacturi/lint.xml b/samples/contacturi/lint.xml
index ab5a637a0..a78a6dd3b 100644
--- a/samples/contacturi/lint.xml
+++ b/samples/contacturi/lint.xml
@@ -1,4 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore"/>
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
index 14dec10a2..c30d489c1 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
 
-/**
- * Ensures that Glide's generated API is created for the Contact Uri sample.
- */
+/** Ensures that Glide's generated API is created for the Contact Uri sample. */
 @GlideModule
 public class ContactUriModule extends AppGlideModule {
   // Intentionally empty.
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
index c928f9fd5..e0c96ad77 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -1,10 +1,6 @@
 package com.bumptech.glide.samples.contacturi;
 
-import static android.os.Build.VERSION;
-import static android.os.Build.VERSION_CODES;
-
 import android.Manifest;
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ContentUris;
 import android.content.Intent;
@@ -14,20 +10,21 @@
 import android.os.Bundle;
 import android.provider.ContactsContract;
 import android.provider.ContactsContract.Contacts;
-import android.support.v4.app.ActivityCompat;
-import android.support.v4.content.ContextCompat;
 import android.view.View;
 import android.widget.EditText;
 import android.widget.ImageView;
+import androidx.core.app.ActivityCompat;
+import androidx.core.content.ContextCompat;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
 
 /**
- * An activity that demonstrates loading photos using
- * {@link com.bumptech.glide.load.data.StreamLocalUriFetcher content uris} through Glide.
- * It works by making the user to choose a contact when presses a button,
- * and after he chooses a contact with photo,
- * We try to load both a high res image and thumbnail image of that contact with various Uris.
+ * An activity that demonstrates loading photos using {@link
+ * com.bumptech.glide.load.data.StreamLocalUriFetcher content uris} through Glide. It works by
+ * making the user to choose a contact when presses a button, and after he chooses a contact with
+ * photo, We try to load both a high res image and thumbnail image of that contact with various
+ * Uris.
  */
 public class MainActivity extends Activity {
   private static final int REQUEST_CONTACT = 1;
@@ -44,46 +41,51 @@ protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_main);
 
-    imageViewContact = (ImageView) findViewById(R.id.image_contact);
-    imageViewLookup = (ImageView) findViewById(R.id.image_lookup);
-    imageViewPhoto = (ImageView) findViewById(R.id.image_photo);
-    imageViewDisplayPhoto = (ImageView) findViewById(R.id.image_display_photo);
-    numberEntry = (EditText) findViewById(R.id.number_entry);
+    imageViewContact = findViewById(R.id.image_contact);
+    imageViewLookup = findViewById(R.id.image_lookup);
+    imageViewPhoto = findViewById(R.id.image_photo);
+    imageViewDisplayPhoto = findViewById(R.id.image_display_photo);
+    numberEntry = findViewById(R.id.number_entry);
     // Make sure that user gives application required permissions
-    if (ContextCompat.checkSelfPermission(
-        getApplication(),
-        Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+    if (ContextCompat.checkSelfPermission(getApplication(), Manifest.permission.READ_CONTACTS)
+        != PackageManager.PERMISSION_GRANTED) {
       // No explanation needed, we can request the permission.
-      ActivityCompat.requestPermissions(this,
-      new String[]{Manifest.permission.READ_CONTACTS},
-      READ_CONTACTS);
+      ActivityCompat.requestPermissions(
+          this, new String[] {Manifest.permission.READ_CONTACTS}, READ_CONTACTS);
     }
 
-    findViewById(R.id.button_pick_contact).setOnClickListener(new View.OnClickListener() {
-      @Override
-      public void onClick(View v) {
-        Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
-        startActivityForResult(intent, REQUEST_CONTACT);
-      }
-    });
+    findViewById(R.id.button_pick_contact)
+        .setOnClickListener(
+            new View.OnClickListener() {
+              @Override
+              public void onClick(View v) {
+                Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
+                startActivityForResult(intent, REQUEST_CONTACT);
+              }
+            });
 
-    findViewById(R.id.button_find).setOnClickListener(new View.OnClickListener() {
-      @Override
-      public void onClick(View v) {
-        Uri uri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI,
-                                       Uri.encode(numberEntry.getText().toString()));
-        GlideApp.with(MainActivity.this)
-                .load(uri)
-                .override(Target.SIZE_ORIGINAL)
-                .into(imageViewLookup);
-        }
-    });
+    findViewById(R.id.button_find)
+        .setOnClickListener(
+            new View.OnClickListener() {
+              @Override
+              public void onClick(View v) {
+                Uri uri =
+                    Uri.withAppendedPath(
+                        ContactsContract.PhoneLookup.CONTENT_FILTER_URI,
+                        Uri.encode(numberEntry.getText().toString()));
+                GlideApp.with(MainActivity.this)
+                    .load(uri)
+                    .override(Target.SIZE_ORIGINAL)
+                    .into(imageViewLookup);
+              }
+            });
   }
 
   @Override
   protected void onActivityResult(int requestCode, int resultCode, Intent data) {
     if (requestCode == REQUEST_CONTACT && resultCode == RESULT_OK) {
-      final Cursor cursor = getContentResolver().query(data.getData(), null, null, null, null);
+      Uri uri = Preconditions.checkNotNull(data.getData());
+      final Cursor cursor = getContentResolver().query(uri, null, null, null, null);
       try {
         if (cursor != null && cursor.moveToFirst()) {
           final long contactId = cursor.getLong(cursor.getColumnIndex(Contacts._ID));
@@ -99,7 +101,6 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
     super.onActivityResult(requestCode, resultCode, data);
   }
 
-  @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
   private void showContact(long id) {
     GlideRequests glideRequests = GlideApp.with(this);
     RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
@@ -113,9 +114,7 @@ private void showContact(long id) {
     Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
     glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);
 
-    if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
-      Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
-      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
-    }
+    Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
+    glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
   }
 }
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index 73b2b4e01..93b9f43bf 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -1,20 +1,19 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.volley:volley:${VOLLEY_VERSION}"
-    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "androidx.appcompat:appcompat:${ANDROID_X_VERSION}"
+    implementation "com.android.volley:volley:${VOLLEY_VERSION}"
+    implementation "androidx.recyclerview:recyclerview:${ANDROID_X_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.flickr'
diff --git a/samples/flickr/lint.xml b/samples/flickr/lint.xml
index ac292ab1a..948353b6b 100644
--- a/samples/flickr/lint.xml
+++ b/samples/flickr/lint.xml
@@ -4,4 +4,6 @@
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index 9be7824f6..191c38149 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -3,8 +3,11 @@
           package="com.bumptech.glide.samples.flickr">
 
     <uses-permission android:name="android.permission.INTERNET"/>
+    <!--
+    Allows Glide to monitor connectivity status and restart failed requests if users go from a
+    a disconnected to a connected network state.
+    -->
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
     <application
         android:label="@string/app_name"
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
new file mode 100644
index 000000000..771cc629e
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
@@ -0,0 +1,30 @@
+package com.bumptech.glide.samples.flickr;
+
+import androidx.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.samples.flickr.api.Api;
+
+/** Extension methods for the Flickr sample's generated API. */
+// Required by Glide's annotation processor.
+@SuppressWarnings({"WeakerAccess", "unused"})
+@GlideExtension
+public final class FlickrGlideExtension {
+
+  private FlickrGlideExtension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption
+  public static BaseRequestOptions<?> squareThumb(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop();
+  }
+
+  @NonNull
+  @GlideOption
+  public static BaseRequestOptions<?> squareMiniThumb(BaseRequestOptions<?> requestOptions) {
+    return requestOptions.centerCrop().override(Api.SQUARE_THUMB_SIZE);
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index 9a9be21e1..f446440bb 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -1,20 +1,30 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import java.io.InputStream;
 
-/**
- * Register {@link FlickrModelLoader} for the Flickr sample app.
- */
+/** Register {@link FlickrModelLoader} for the Flickr sample app. */
 @GlideModule
 public class FlickrGlideModule extends AppGlideModule {
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    super.applyOptions(context, builder);
+    builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_ARGB_8888));
+  }
+
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index cf7ea32c0..82415bd57 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
@@ -17,32 +18,30 @@
  * ExecutorService backing the Engine to download the image and resize it in memory before saving
  * the resized version directly to the disk cache.
  */
-public class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
+public final class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
 
-  /**
-   * The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s.
-   */
+  /** The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s. */
   public static class Factory implements ModelLoaderFactory<Photo, InputStream> {
-    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
+    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<>(500);
 
+    @NonNull
     @Override
     public ModelLoader<Photo, InputStream> build(MultiModelLoaderFactory multiFactory) {
-      return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
-          modelCache);
+      return new FlickrModelLoader(
+          multiFactory.build(GlideUrl.class, InputStream.class), modelCache);
     }
 
     @Override
-    public void teardown() {
-    }
+    public void teardown() {}
   }
 
-  public FlickrModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader,
-      ModelCache<Photo, GlideUrl> modelCache) {
+  private FlickrModelLoader(
+      ModelLoader<GlideUrl, InputStream> urlLoader, ModelCache<Photo, GlideUrl> modelCache) {
     super(urlLoader, modelCache);
   }
 
   @Override
-  public boolean handles(Photo model) {
+  public boolean handles(@NonNull Photo model) {
     return true;
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 9539d0006..b924c6660 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -4,14 +4,15 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.v4.app.Fragment;
-import android.support.v7.widget.GridLayoutManager;
-import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.Fragment;
+import androidx.recyclerview.widget.GridLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.Priority;
@@ -20,6 +21,7 @@
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.FixedPreloadSizeProvider;
+import com.bumptech.glide.util.Preconditions;
 import java.util.Collections;
 import java.util.List;
 
@@ -55,46 +57,43 @@ public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean th
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
-    Bundle args = getArguments();
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+    Bundle args = Preconditions.checkNotNull(getArguments());
     photoSize = args.getInt(IMAGE_SIZE_KEY);
     thumbnail = args.getBoolean(THUMBNAIL_KEY);
 
-    fullRequest = GlideApp.with(this)
-        .asDrawable()
-        .centerCrop();
+    fullRequest = GlideApp.with(this).asDrawable().centerCrop();
 
-    thumbnailRequest = GlideApp.with(this)
-        .asDrawable()
-        .centerCrop()
-        .override(Api.SQUARE_THUMB_SIZE);
+    thumbnailRequest =
+        GlideApp.with(this).asDrawable().centerCrop().override(Api.SQUARE_THUMB_SIZE);
 
-    preloadRequest =
-        thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
+    preloadRequest = thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
 
     final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
 
     final int gridMargin = getResources().getDimensionPixelOffset(R.dimen.grid_margin);
     int spanCount = getResources().getDisplayMetrics().widthPixels / (photoSize + (2 * gridMargin));
-    grid = (RecyclerView) result.findViewById(R.id.flickr_photo_grid);
+    grid = result.findViewById(R.id.flickr_photo_grid);
     layoutManager = new GridLayoutManager(getActivity(), spanCount);
     grid.setLayoutManager(layoutManager);
 
-    grid.addItemDecoration(new RecyclerView.ItemDecoration() {
-      @Override
-      public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
-          RecyclerView.State state) {
-        outRect.set(gridMargin, gridMargin, gridMargin, gridMargin);
-      }
-    });
-    grid.setRecyclerListener(new RecyclerView.RecyclerListener() {
-      @Override
-      public void onViewRecycled(RecyclerView.ViewHolder holder) {
-        PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
-        GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
-      }
-    });
+    grid.addItemDecoration(
+        new RecyclerView.ItemDecoration() {
+          @Override
+          public void getItemOffsets(
+              Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
+            outRect.set(gridMargin, gridMargin, gridMargin, gridMargin);
+          }
+        });
+    grid.setRecyclerListener(
+        new RecyclerView.RecyclerListener() {
+          @Override
+          public void onViewRecycled(RecyclerView.ViewHolder holder) {
+            PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
+            GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
+          }
+        });
 
     int heightCount = getResources().getDisplayMetrics().heightPixels / photoSize;
     grid.getRecycledViewPool().setMaxRecycledViews(0, spanCount * heightCount * 2);
@@ -104,8 +103,9 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
 
     FixedPreloadSizeProvider<Photo> preloadSizeProvider =
         new FixedPreloadSizeProvider<>(photoSize, photoSize);
-    RecyclerViewPreloader<Photo> preloader = new RecyclerViewPreloader<>(Glide.with(this), adapter,
-        preloadSizeProvider, args.getInt(PRELOAD_KEY));
+    RecyclerViewPreloader<Photo> preloader =
+        new RecyclerViewPreloader<>(
+            Glide.with(this), adapter, preloadSizeProvider, args.getInt(PRELOAD_KEY));
     grid.addOnScrollListener(preloader);
 
     if (currentPhotos != null) {
@@ -121,7 +121,7 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
   }
 
   @Override
-  public void onSaveInstanceState(Bundle outState) {
+  public void onSaveInstanceState(@NonNull Bundle outState) {
     super.onSaveInstanceState(outState);
     if (grid != null) {
       int index = layoutManager.findFirstVisibleItemPosition();
@@ -137,16 +137,16 @@ public void onPhotosUpdated(List<Photo> photos) {
     }
   }
 
-  private class PhotoAdapter extends RecyclerView.Adapter<PhotoViewHolder> implements
-      ListPreloader.PreloadModelProvider<Photo> {
+  private class PhotoAdapter extends RecyclerView.Adapter<PhotoViewHolder>
+      implements ListPreloader.PreloadModelProvider<Photo> {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
-    public PhotoAdapter() {
+    PhotoAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
     }
 
-    public void setPhotos(List<Photo> photos) {
+    void setPhotos(List<Photo> photos) {
       this.photos = photos;
       notifyDataSetChanged();
     }
@@ -169,17 +169,19 @@ public PhotoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
     public void onBindViewHolder(PhotoViewHolder holder, int position) {
       final Photo current = photos.get(position);
 
-      fullRequest.load(current)
+      fullRequest
+          .load(current)
           .thumbnail(thumbnail ? thumbnailRequest.load(current) : null)
           .into(holder.imageView);
 
-      holder.imageView.setOnClickListener(new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-          Intent intent = FullscreenActivity.getIntent(getActivity(), current);
-          startActivity(intent);
-        }
-      });
+      holder.imageView.setOnClickListener(
+          new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+              Intent intent = FullscreenActivity.getIntent(getActivity(), current);
+              startActivity(intent);
+            }
+          });
     }
 
     @Override
@@ -198,17 +200,17 @@ public int getItemCount() {
       return photos.subList(position, position + 1);
     }
 
-    @NonNull
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Photo item) {
       return preloadRequest.load(item);
     }
   }
 
-  private static class PhotoViewHolder extends RecyclerView.ViewHolder {
+  private static final class PhotoViewHolder extends RecyclerView.ViewHolder {
     private final ImageView imageView;
 
-    public PhotoViewHolder(View itemView) {
+    PhotoViewHolder(View itemView) {
       super(itemView);
       imageView = (ImageView) itemView;
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index e54856c2a..164275b87 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -7,15 +7,16 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.v4.app.Fragment;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.TextView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.Fragment;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
@@ -54,11 +55,11 @@ public void onPhotosUpdated(List<Photo> photos) {
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
 
-    list = (RecyclerView) result.findViewById(R.id.flickr_photo_list);
+    list = result.findViewById(R.id.flickr_photo_list);
     layoutManager = new LinearLayoutManager(getActivity());
     list.setLayoutManager(layoutManager);
     adapter = new FlickrPhotoListAdapter();
@@ -76,24 +77,24 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
     }
 
     final GlideRequests glideRequests = GlideApp.with(this);
-    fullRequest = glideRequests
-        .asDrawable()
-        .centerCrop()
-        .placeholder(new ColorDrawable(Color.GRAY));
-
-    thumbRequest = glideRequests
-        .asDrawable()
-        .diskCacheStrategy(DiskCacheStrategy.DATA)
-        .override(Api.SQUARE_THUMB_SIZE)
-        .transition(withCrossFade());
-
-    list.setRecyclerListener(new RecyclerView.RecyclerListener() {
-      @Override
-      public void onViewRecycled(RecyclerView.ViewHolder holder) {
-        PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
-        glideRequests.clear(vh.imageView);
-      }
-    });
+    fullRequest =
+        glideRequests.asDrawable().centerCrop().placeholder(new ColorDrawable(Color.GRAY));
+
+    thumbRequest =
+        glideRequests
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .override(Api.SQUARE_THUMB_SIZE)
+            .transition(withCrossFade());
+
+    list.setRecyclerListener(
+        new RecyclerView.RecyclerListener() {
+          @Override
+          public void onViewRecycled(RecyclerView.ViewHolder holder) {
+            PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
+            glideRequests.clear(vh.imageView);
+          }
+        });
 
     if (savedInstanceState != null) {
       int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
@@ -105,7 +106,7 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
   }
 
   @Override
-  public void onSaveInstanceState(Bundle outState) {
+  public void onSaveInstanceState(@NonNull Bundle outState) {
     super.onSaveInstanceState(outState);
     if (list != null) {
       int index = layoutManager.findFirstVisibleItemPosition();
@@ -116,16 +117,16 @@ public void onSaveInstanceState(Bundle outState) {
     }
   }
 
-  private class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
+  private final class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
       implements ListPreloader.PreloadModelProvider<Photo> {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
-    public FlickrPhotoListAdapter() {
+    FlickrPhotoListAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
     }
 
-    public void setPhotos(List<Photo> photos) {
+    void setPhotos(List<Photo> photos) {
       this.photos = photos;
       notifyDataSetChanged();
     }
@@ -141,17 +142,16 @@ public PhotoTitleViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
     @Override
     public void onBindViewHolder(PhotoTitleViewHolder holder, int position) {
       final Photo current = photos.get(position);
-      fullRequest.load(current)
-          .thumbnail(thumbRequest.load(current))
-          .into(holder.imageView);
-
-      holder.imageView.setOnClickListener(new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-          Intent intent = FullscreenActivity.getIntent(getActivity(), current);
-          startActivity(intent);
-        }
-      });
+      fullRequest.load(current).thumbnail(thumbRequest.load(current)).into(holder.imageView);
+
+      holder.imageView.setOnClickListener(
+          new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+              Intent intent = FullscreenActivity.getIntent(getActivity(), current);
+              startActivity(intent);
+            }
+          });
 
       holder.titleView.setText(current.getTitle());
     }
@@ -172,21 +172,21 @@ public int getItemCount() {
       return photos.subList(position, position + 1);
     }
 
-    @NonNull
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Photo item) {
       return fullRequest.thumbnail(thumbRequest.load(item)).load(item);
     }
   }
 
-  private static class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
+  private static final class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
     private final TextView titleView;
     private final ImageView imageView;
 
-    public PhotoTitleViewHolder(View itemView) {
+    PhotoTitleViewHolder(View itemView) {
       super(itemView);
-      imageView = (ImageView) itemView.findViewById(R.id.photo_view);
-      titleView = (TextView) itemView.findViewById(R.id.title_view);
+      imageView = itemView.findViewById(R.id.photo_view);
+      titleView = itemView.findViewById(R.id.title_view);
     }
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index cedac252f..b2af61ec7 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -7,11 +7,6 @@
 import android.os.HandlerThread;
 import android.os.Process;
 import android.os.StrictMode;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentManager;
-import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.view.ViewPager;
-import android.support.v7.app.AppCompatActivity;
 import android.text.TextUtils;
 import android.util.Log;
 import android.view.Menu;
@@ -20,6 +15,11 @@
 import android.view.ViewGroup;
 import android.widget.SearchView;
 import android.widget.TextView;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentPagerAdapter;
+import androidx.viewpager.widget.ViewPager;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.samples.flickr.api.Api;
@@ -47,10 +47,11 @@
   private static final Query DEFAULT_QUERY = new SearchQuery("kitten");
 
   private final QueryListener queryListener = new QueryListener();
+  private final Set<PhotoViewer> photoViewers = new HashSet<>();
+
+  private List<Photo> currentPhotos = new ArrayList<>();
   private View searching;
   private TextView searchTerm;
-  private Set<PhotoViewer> photoViewers = new HashSet<>();
-  private List<Photo> currentPhotos = new ArrayList<>();
   private View searchLoading;
   private BackgroundThumbnailFetcher backgroundThumbnailFetcher;
   private HandlerThread backgroundThread;
@@ -64,13 +65,15 @@
     LIST
   }
 
-  private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {
-    {
-      put(Page.SMALL, R.string.small);
-      put(Page.MEDIUM, R.string.medium);
-      put(Page.LIST, R.string.list);
-    }
-  };
+  private static final Map<Page, Integer> PAGE_TO_TITLE;
+
+  static {
+    Map<Page, Integer> temp = new HashMap<>();
+    temp.put(Page.SMALL, R.string.small);
+    temp.put(Page.MEDIUM, R.string.medium);
+    temp.put(Page.LIST, R.string.list);
+    PAGE_TO_TITLE = Collections.unmodifiableMap(temp);
+  }
 
   @Override
   public void onAttachFragment(Fragment fragment) {
@@ -109,16 +112,12 @@ public boolean onQueryTextChange(String newText) {
     return false;
   }
 
-  /**
-   * Called when the activity is first created.
-   */
+  /** Called when the activity is first created. */
   @Override
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
-        .detectAll()
-        .penaltyLog()
-        .build());
+    StrictMode.setThreadPolicy(
+        new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
 
     backgroundThread = new HandlerThread("BackgroundThumbnailHandlerThread");
     backgroundThread.start();
@@ -152,10 +151,11 @@ public void onCreate(Bundle savedInstanceState) {
     if (savedInstanceState == null) {
       // Weight values determined experimentally by measuring the number of incurred GCs while
       // scrolling through the various photo grids/lists.
-      GlideApp.get(this).preFillBitmapPool(
-          new PreFillType.Builder(smallGridSize).setWeight(1),
-          new PreFillType.Builder(mediumGridSize).setWeight(1),
-          new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
+      GlideApp.get(this)
+          .preFillBitmapPool(
+              new PreFillType.Builder(smallGridSize).setWeight(1),
+              new PreFillType.Builder(mediumGridSize).setWeight(1),
+              new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
     }
   }
 
@@ -248,12 +248,12 @@ public void onSearchFailed(Query query, Exception e) {
     }
   }
 
-  private class FlickrPagerAdapter extends FragmentPagerAdapter {
+  private final class FlickrPagerAdapter extends FragmentPagerAdapter {
 
     private int mLastPosition = -1;
     private Fragment mLastFragment;
 
-    public FlickrPagerAdapter(FragmentManager fm) {
+    FlickrPagerAdapter(FragmentManager fm) {
       super(fm);
     }
 
@@ -311,16 +311,17 @@ private int getPageSize(int id) {
   }
 
   private static class BackgroundThumbnailFetcher implements Runnable {
+    private final Context context;
+    private final List<Photo> photos;
+
     private boolean isCancelled;
-    private Context context;
-    private List<Photo> photos;
 
-    public BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
+    BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
       this.context = context;
       this.photos = photos;
     }
 
-    public void cancel() {
+    void cancel() {
       isCancelled = true;
     }
 
@@ -332,10 +333,11 @@ public void run() {
           return;
         }
 
-        FutureTarget<File> futureTarget = GlideApp.with(context)
-            .downloadOnly()
-            .load(photo)
-            .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
+        FutureTarget<File> futureTarget =
+            GlideApp.with(context)
+                .downloadOnly()
+                .load(photo)
+                .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
 
         try {
           futureTarget.get();
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index ba3095dc2..dc6a6010c 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -5,13 +5,11 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
 import android.widget.ImageView;
+import androidx.fragment.app.FragmentActivity;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
-/**
- * A simple activity for viewing a single photo.
- */
+/** A simple activity for viewing a single photo. */
 public class FullscreenActivity extends FragmentActivity {
   private static final String ARG_PHOTO = "photo";
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
index 19776b359..28e88ecb5 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
@@ -7,11 +7,11 @@
  * An interface for an object that displays {@link com.bumptech.glide.samples.flickr.api.Photo}
  * objects.
  */
-public interface PhotoViewer {
+interface PhotoViewer {
   /**
    * Called whenever new {@link com.bumptech.glide.samples.flickr.api.Photo}s are loaded.
    *
    * @param photos The loaded photos.
    */
-  public void onPhotosUpdated(List<Photo> photos);
+  void onPhotosUpdated(List<Photo> photos);
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
index 5988e6bf8..20f8ed87e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
-import android.support.v7.widget.AppCompatImageView;
 import android.util.AttributeSet;
 import android.widget.ImageView;
+import androidx.appcompat.widget.AppCompatImageView;
 
-/**
- * An always square {@link ImageView}.
- */
+/** An always square {@link ImageView}. */
 public final class SquareImageView extends AppCompatImageView {
 
   public SquareImageView(Context context) {
@@ -22,9 +20,10 @@ public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
   }
 
+  // We want a square view.
+  @SuppressWarnings("SuspiciousNameCombination")
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, widthMeasureSpec);
   }
 }
-
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index 4ef7f0bde..346b1b0b1 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -14,12 +14,9 @@
 import java.util.List;
 import java.util.Set;
 
-/**
- * A class for interfacing with Flickr's http API.
- */
-public class Api {
+/** A class for interfacing with Flickr's http API. */
+public final class Api {
   private static Api api;
-  private static final String TAG = "FlickrApi";
   private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
   private static final String SIGNED_API_URL =
       "https://api.flickr.com/services/rest/?method=%s&format=json&api_key=" + API_KEY;
@@ -31,20 +28,19 @@
   private static final int MAX_ITEMS_PER_PAGE = 300;
   private static final String PER_PAGE = "&per_page=" + MAX_ITEMS_PER_PAGE;
 
-  private static final SparseArray<String> EDGE_TO_SIZE_KEY = new SparseArray<String>() {
-    {
-      put(75, "s");
-      put(100, "t");
-      put(150, "q");
-      put(240, "m");
-      put(320, "n");
-      put(640, "z");
-      put(1024, "b");
-    }
-  };
-  private static final List<Integer> SORTED_SIZE_KEYS =
-      new ArrayList<>(EDGE_TO_SIZE_KEY.size());
-
+  private static final SparseArray<String> EDGE_TO_SIZE_KEY =
+      new SparseArray<String>() {
+        {
+          put(75, "s");
+          put(100, "t");
+          put(150, "q");
+          put(240, "m");
+          put(320, "n");
+          put(640, "z");
+          put(1024, "b");
+        }
+      };
+  private static final List<Integer> SORTED_SIZE_KEYS = new ArrayList<>(EDGE_TO_SIZE_KEY.size());
 
   static {
     for (int i = 0; i < EDGE_TO_SIZE_KEY.size(); i++) {
@@ -73,7 +69,9 @@ private static String getSizeKey(int width, int height) {
 
     boolean isFirstLargest = true;
     List<String> result = new ArrayList<>();
-    for (int edge : SORTED_SIZE_KEYS) {
+    int size = result.size();
+    for (int i = 0; i < size; i++) {
+      int edge = SORTED_SIZE_KEYS.get(i);
       if (largestEdge <= edge) {
         if (isFirstLargest) {
           isFirstLargest = false;
@@ -83,12 +81,11 @@ private static String getSizeKey(int width, int height) {
       }
     }
     return result;
-
   }
 
-  public static String getCacheableUrl(Photo photo) {
-    return String.format(CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(),
-        photo.getSecret());
+  static String getCacheableUrl(Photo photo) {
+    return String.format(
+        CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(), photo.getSecret());
   }
 
   public static String getPhotoURL(Photo photo, int width, int height) {
@@ -125,14 +122,12 @@ static String getRecentUrl() {
     return getUrlForMethod("flickr.photos.getRecent" + PER_PAGE);
   }
 
-  /**
-   * An interface for listening for search results from the Flickr API.
-   */
+  /** An interface for listening for search results from the Flickr API. */
   public interface QueryListener {
     /**
      * Called when a search completes successfully.
      *
-     * @param query  The query used to obtain the results.
+     * @param query The query used to obtain the results.
      * @param photos A list of images that were found for the given search term.
      */
     void onSearchCompleted(Query query, List<Photo> photos);
@@ -141,7 +136,7 @@ static String getRecentUrl() {
      * Called when a search fails.
      *
      * @param query The query we attempted to obtain results for.
-     * @param e     The exception that caused the search to fail.
+     * @param e The exception that caused the search to fail.
      */
     void onSearchFailed(Query query, Exception e);
   }
@@ -154,22 +149,23 @@ public static Api get(Context context) {
   }
 
   private final RequestQueue requestQueue;
-  private final Set<QueryListener> queryListeners = new HashSet<QueryListener>();
+  private final Set<QueryListener> queryListeners = new HashSet<>();
   private QueryResult lastQueryResult;
 
-  protected Api(Context context) {
+  private Api(Context context) {
     this.requestQueue = Volley.newRequestQueue(context.getApplicationContext());
-    QueryListener queryListener = new QueryListener() {
-      @Override
-      public void onSearchCompleted(Query query, List<Photo> photos) {
-        lastQueryResult = new QueryResult(query, photos);
-      }
-
-      @Override
-      public void onSearchFailed(Query query, Exception e) {
-        lastQueryResult = null;
-      }
-    };
+    QueryListener queryListener =
+        new QueryListener() {
+          @Override
+          public void onSearchCompleted(Query query, List<Photo> photos) {
+            lastQueryResult = new QueryResult(query, photos);
+          }
+
+          @Override
+          public void onSearchFailed(Query query, Exception e) {
+            lastQueryResult = null;
+          }
+        };
     queryListeners.add(queryListener);
   }
 
@@ -189,12 +185,13 @@ public void query(Query query) {
       return;
     }
 
-    FlickrQueryResponseListener responseListener
-        = new FlickrQueryResponseListener(new PhotoJsonStringParser(), query, queryListeners);
-    StringRequest request = new StringRequest(Request.Method.GET, query.getUrl(),
-        responseListener, responseListener);
-    request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3,
-        DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
+    FlickrQueryResponseListener responseListener =
+        new FlickrQueryResponseListener(new PhotoJsonStringParser(), query, queryListeners);
+    StringRequest request =
+        new StringRequest(Request.Method.GET, query.getUrl(), responseListener, responseListener);
+    request.setRetryPolicy(
+        new DefaultRetryPolicy(
+            DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3, DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
     requestQueue.add(request);
   }
 
@@ -202,7 +199,7 @@ public void query(Query query) {
     private final Query query;
     private final List<Photo> results;
 
-    public QueryResult(Query query, List<Photo> results) {
+    QueryResult(Query query, List<Photo> results) {
       this.query = query;
       this.results = results;
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
index 5bd75a67c..214cbefa6 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
@@ -6,17 +6,15 @@
 import java.util.List;
 import org.json.JSONException;
 
-/**
- * Handles photo list responses and errors from Flickr API calls.
- */
-final class FlickrQueryResponseListener implements Response.Listener<String>,
-    Response.ErrorListener {
+/** Handles photo list responses and errors from Flickr API calls. */
+final class FlickrQueryResponseListener
+    implements Response.Listener<String>, Response.ErrorListener {
   private final PhotoJsonStringParser parser;
   private final Query query;
   private final Collection<Api.QueryListener> listeners;
 
-  FlickrQueryResponseListener(PhotoJsonStringParser parser, Query query,
-      Collection<Api.QueryListener> listeners) {
+  FlickrQueryResponseListener(
+      PhotoJsonStringParser parser, Query query, Collection<Api.QueryListener> listeners) {
     this.parser = parser;
     this.query = query;
     this.listeners = listeners;
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index 8ff5f5b9a..99407d0a0 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -5,21 +5,20 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
-/**
- * A POJO representing a JSON object returned from Flickr's api representing a single image.
- */
+/** A POJO representing a JSON object returned from Flickr's api representing a single image. */
 public class Photo implements Parcelable {
-  public static final Creator<Photo> CREATOR = new Creator<Photo>() {
-    @Override
-    public Photo createFromParcel(Parcel parcel) {
-      return new Photo(parcel);
-    }
-
-    @Override
-    public Photo[] newArray(int i) {
-      return new Photo[i];
-    }
-  };
+  public static final Creator<Photo> CREATOR =
+      new Creator<Photo>() {
+        @Override
+        public Photo createFromParcel(Parcel parcel) {
+          return new Photo(parcel);
+        }
+
+        @Override
+        public Photo[] newArray(int i) {
+          return new Photo[i];
+        }
+      };
 
   private final String id;
   private final String owner;
@@ -29,7 +28,6 @@ public Photo createFromParcel(Parcel parcel) {
   private final String secret;
   private String partialUrl = null;
 
-
   public Photo(JSONObject jsonPhoto) throws JSONException {
     this.id = jsonPhoto.getString("id");
     this.owner = jsonPhoto.getString("owner");
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
index 2858df855..d141d72f8 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
@@ -4,17 +4,18 @@
 
 /** Query using Flickr's recent API. */
 public final class RecentQuery implements Query {
-  public static final Creator<RecentQuery> CREATOR = new Creator<RecentQuery>() {
-    @Override
-    public RecentQuery createFromParcel(Parcel source) {
-      return RECENT_QUERY;
-    }
-
-    @Override
-    public RecentQuery[] newArray(int size) {
-      return new RecentQuery[size];
-    }
-  };
+  public static final Creator<RecentQuery> CREATOR =
+      new Creator<RecentQuery>() {
+        @Override
+        public RecentQuery createFromParcel(Parcel source) {
+          return RECENT_QUERY;
+        }
+
+        @Override
+        public RecentQuery[] newArray(int size) {
+          return new RecentQuery[size];
+        }
+      };
   private static final RecentQuery RECENT_QUERY = new RecentQuery();
 
   public static RecentQuery get() {
@@ -41,5 +42,5 @@ public int describeContents() {
   }
 
   @Override
-  public void writeToParcel(Parcel dest, int flags) { }
+  public void writeToParcel(Parcel dest, int flags) {}
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
index 0d36aaf24..16efaa654 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
@@ -4,17 +4,18 @@
 
 /** Wraps a search query string. */
 public final class SearchQuery implements Query {
-  public static final Creator<SearchQuery> CREATOR = new Creator<SearchQuery>() {
-    @Override
-    public SearchQuery createFromParcel(Parcel source) {
-      return new SearchQuery(source);
-    }
-
-    @Override
-    public SearchQuery[] newArray(int size) {
-      return new SearchQuery[size];
-    }
-  };
+  public static final Creator<SearchQuery> CREATOR =
+      new Creator<SearchQuery>() {
+        @Override
+        public SearchQuery createFromParcel(Parcel source) {
+          return new SearchQuery(source);
+        }
+
+        @Override
+        public SearchQuery[] newArray(int size) {
+          return new SearchQuery[size];
+        }
+      };
 
   private final String queryString;
 
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_grid.xml b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
index dd069be64..573bf484e 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<android.support.v7.widget.RecyclerView
+<androidx.recyclerview.widget.RecyclerView
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_list.xml b/samples/flickr/src/main/res/layout/flickr_photo_list.xml
index 13723e059..f49a5efa4 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_list.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_list.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<android.support.v7.widget.RecyclerView
+<androidx.recyclerview.widget.RecyclerView
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
diff --git a/samples/flickr/src/main/res/layout/flickr_search_activity.xml b/samples/flickr/src/main/res/layout/flickr_search_activity.xml
index a4b216c7e..0a08dedde 100644
--- a/samples/flickr/src/main/res/layout/flickr_search_activity.xml
+++ b/samples/flickr/src/main/res/layout/flickr_search_activity.xml
@@ -1,18 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
 <merge xmlns:android="http://schemas.android.com/apk/res/android">
 
-    <android.support.v4.view.ViewPager
+    <androidx.viewpager.widget.ViewPager
         android:id="@+id/view_pager"
         android:layout_width="fill_parent"
         android:layout_height="fill_parent">
 
-        <android.support.v4.view.PagerTabStrip
+        <androidx.viewpager.widget.PagerTabStrip
                 android:id="@+id/pager_tab_strip"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
                 android:layout_gravity="top" />
 
-    </android.support.v4.view.ViewPager>
+    </androidx.viewpager.widget.ViewPager>
 
     <LinearLayout
         android:id="@+id/searching"
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index bc2e3fde3..223518db0 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -1,18 +1,17 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    implementation "androidx.recyclerview:recyclerview:${ANDROID_X_VERSION}"
+    implementation "androidx.fragment:fragment:${ANDROID_X_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.gallery'
diff --git a/samples/gallery/lint.xml b/samples/gallery/lint.xml
index ac292ab1a..948353b6b 100644
--- a/samples/gallery/lint.xml
+++ b/samples/gallery/lint.xml
@@ -4,4 +4,6 @@
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
index e5d4888ab..e3a5743b9 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
 
-/**
- * Ensures that Glide's generated API is created for the Gallery sample.
- */
+/** Ensures that Glide's generated API is created for the Gallery sample. */
 @GlideModule
 public final class GalleryModule extends AppGlideModule {
   // Intentionally empty.
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
index 30933931c..03d075cef 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -1,20 +1,19 @@
 package com.bumptech.glide.samples.gallery;
 
 import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.LoaderManager;
-import android.support.v4.content.Loader;
-import android.support.v7.widget.GridLayoutManager;
-import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+import androidx.loader.app.LoaderManager;
+import androidx.loader.content.Loader;
+import androidx.recyclerview.widget.GridLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import java.util.List;
 
-/**
- * Displays media store data in a recycler view.
- */
+/** Displays media store data in a recycler view. */
 public class HorizontalGalleryFragment extends Fragment
     implements LoaderManager.LoaderCallbacks<List<MediaStoreData>> {
 
@@ -27,8 +26,8 @@ public void onCreate(Bundle savedInstanceState) {
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     View result = inflater.inflate(R.layout.recycler_view, container, false);
     recyclerView = (RecyclerView) result.findViewById(R.id.recycler_view);
     GridLayoutManager layoutManager = new GridLayoutManager(getActivity(), 1);
@@ -45,11 +44,10 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
   }
 
   @Override
-  public void onLoadFinished(Loader<List<MediaStoreData>> loader,
-      List<MediaStoreData> mediaStoreData) {
+  public void onLoadFinished(
+      Loader<List<MediaStoreData>> loader, List<MediaStoreData> mediaStoreData) {
     GlideRequests glideRequests = GlideApp.with(this);
-    RecyclerAdapter adapter =
-        new RecyclerAdapter(getActivity(), mediaStoreData, glideRequests);
+    RecyclerAdapter adapter = new RecyclerAdapter(getActivity(), mediaStoreData, glideRequests);
     RecyclerViewPreloader<MediaStoreData> preloader =
         new RecyclerViewPreloader<>(glideRequests, adapter, adapter, 3);
     recyclerView.addOnScrollListener(preloader);
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index cf315b106..b8da02d4c 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -1,21 +1,20 @@
 package com.bumptech.glide.samples.gallery;
 
 import android.Manifest.permission;
-import android.annotation.TargetApi;
 import android.content.pm.PackageManager;
 import android.os.Build;
 import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.v4.app.ActivityCompat;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.content.ContextCompat;
 import android.widget.Toast;
+import androidx.annotation.NonNull;
+import androidx.annotation.RequiresApi;
+import androidx.core.app.ActivityCompat;
+import androidx.core.content.ContextCompat;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
 import com.bumptech.glide.MemoryCategory;
 
-/**
- * Displays a {@link HorizontalGalleryFragment}.
- */
+/** Displays a {@link HorizontalGalleryFragment}. */
+@RequiresApi(Build.VERSION_CODES.JELLY_BEAN)
 public class MainActivity extends FragmentActivity {
 
   private static final int REQUEST_READ_STORAGE = 0;
@@ -27,18 +26,16 @@ protected void onCreate(Bundle savedInstanceState) {
     GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
         && ContextCompat.checkSelfPermission(this, permission.READ_EXTERNAL_STORAGE)
-        != PackageManager.PERMISSION_GRANTED) {
+            != PackageManager.PERMISSION_GRANTED) {
       requestStoragePermission();
     } else {
       replaceFragment();
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
   private void requestStoragePermission() {
-     ActivityCompat.requestPermissions(this,
-        new String[]{permission.READ_EXTERNAL_STORAGE},
-        REQUEST_READ_STORAGE);
+    ActivityCompat.requestPermissions(
+        this, new String[] {permission.READ_EXTERNAL_STORAGE}, REQUEST_READ_STORAGE);
   }
 
   private void replaceFragment() {
@@ -50,21 +47,20 @@ private void replaceFragment() {
   }
 
   @Override
-  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
-      @NonNull int[] grantResults) {
+  public void onRequestPermissionsResult(
+      int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
     super.onRequestPermissionsResult(requestCode, permissions, grantResults);
     switch (requestCode) {
-      case REQUEST_READ_STORAGE: {
-        // If request is cancelled, the result arrays are empty.
-        if (grantResults.length > 0
-            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-          replaceFragment();
-        } else {
-          Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG)
-              .show();
-          requestStoragePermission();
+      case REQUEST_READ_STORAGE:
+        {
+          // If request is cancelled, the result arrays are empty.
+          if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+            replaceFragment();
+          } else {
+            Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG).show();
+            requestStoragePermission();
+          }
         }
-      }
     }
   }
 }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
index 8663eafdd..90d19706d 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
@@ -4,37 +4,42 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 
-/**
- * A data model containing data for a single media item.
- */
+/** A data model containing data for a single media item. */
 public class MediaStoreData implements Parcelable {
-  public static final Creator<MediaStoreData> CREATOR = new Creator<MediaStoreData>() {
-    @Override
-    public MediaStoreData createFromParcel(Parcel parcel) {
-      return new MediaStoreData(parcel);
-    }
+  public static final Creator<MediaStoreData> CREATOR =
+      new Creator<MediaStoreData>() {
+        @Override
+        public MediaStoreData createFromParcel(Parcel parcel) {
+          return new MediaStoreData(parcel);
+        }
 
-    @Override
-    public MediaStoreData[] newArray(int i) {
-      return new MediaStoreData[i];
-    }
-  };
+        @Override
+        public MediaStoreData[] newArray(int i) {
+          return new MediaStoreData[i];
+        }
+      };
 
   @Override
   public int describeContents() {
     return 0;
   }
 
-  public final long rowId;
-  public final Uri uri;
-  public final String mimeType;
-  public final long dateModified;
-  public final int orientation;
-  public final Type type;
-  public final long dateTaken;
+  final long rowId;
+  final Uri uri;
+  final String mimeType;
+  final long dateModified;
+  final int orientation;
+  private final Type type;
+  final long dateTaken;
 
-  public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
-      int orientation, Type type) {
+  MediaStoreData(
+      long rowId,
+      Uri uri,
+      String mimeType,
+      long dateTaken,
+      long dateModified,
+      int orientation,
+      Type type) {
     this.rowId = rowId;
     this.uri = uri;
     this.dateModified = dateModified;
@@ -44,7 +49,7 @@ public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long
     this.dateTaken = dateTaken;
   }
 
-  MediaStoreData(Parcel in) {
+  private MediaStoreData(Parcel in) {
     rowId = in.readLong();
     uri = Uri.parse(in.readString());
     mimeType = in.readString();
@@ -68,19 +73,25 @@ public void writeToParcel(Parcel parcel, int i) {
   @Override
   public String toString() {
     return "MediaStoreData{"
-        + "rowId=" + rowId
-        + ", uri=" + uri
-        + ", mimeType='" + mimeType + '\''
-        + ", dateModified=" + dateModified
-        + ", orientation=" + orientation
-        + ", type=" + type
-        + ", dateTaken=" + dateTaken
+        + "rowId="
+        + rowId
+        + ", uri="
+        + uri
+        + ", mimeType='"
+        + mimeType
+        + '\''
+        + ", dateModified="
+        + dateModified
+        + ", orientation="
+        + orientation
+        + ", type="
+        + type
+        + ", dateTaken="
+        + dateTaken
         + '}';
   }
 
-  /**
-   * The type of data.
-   */
+  /** The type of data. */
   public enum Type {
     VIDEO,
     IMAGE,
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
index efe2366d5..8123cca3d 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
@@ -5,39 +5,37 @@
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
-import android.support.v4.content.AsyncTaskLoader;
+import androidx.loader.content.AsyncTaskLoader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 
-/**
- * Loads metadata from the media store for images and videos.
- */
+/** Loads metadata from the media store for images and videos. */
 public class MediaStoreDataLoader extends AsyncTaskLoader<List<MediaStoreData>> {
   private static final String[] IMAGE_PROJECTION =
       new String[] {
-          MediaStore.Images.ImageColumns._ID,
-          MediaStore.Images.ImageColumns.DATE_TAKEN,
-          MediaStore.Images.ImageColumns.DATE_MODIFIED,
-          MediaStore.Images.ImageColumns.MIME_TYPE,
-          MediaStore.Images.ImageColumns.ORIENTATION,
+        MediaStore.Images.ImageColumns._ID,
+        MediaStore.Images.ImageColumns.DATE_TAKEN,
+        MediaStore.Images.ImageColumns.DATE_MODIFIED,
+        MediaStore.Images.ImageColumns.MIME_TYPE,
+        MediaStore.Images.ImageColumns.ORIENTATION,
       };
 
   private static final String[] VIDEO_PROJECTION =
       new String[] {
-          MediaStore.Video.VideoColumns._ID,
-          MediaStore.Video.VideoColumns.DATE_TAKEN,
-          MediaStore.Video.VideoColumns.DATE_MODIFIED,
-          MediaStore.Video.VideoColumns.MIME_TYPE,
-          "0 AS " + MediaStore.Images.ImageColumns.ORIENTATION,
+        MediaStore.Video.VideoColumns._ID,
+        MediaStore.Video.VideoColumns.DATE_TAKEN,
+        MediaStore.Video.VideoColumns.DATE_MODIFIED,
+        MediaStore.Video.VideoColumns.MIME_TYPE,
+        "0 AS " + MediaStore.Images.ImageColumns.ORIENTATION,
       };
 
   private List<MediaStoreData> cached;
   private boolean observerRegistered = false;
   private final ForceLoadContentObserver forceLoadContentObserver = new ForceLoadContentObserver();
 
-  public MediaStoreDataLoader(Context context) {
+  MediaStoreDataLoader(Context context) {
     super(context);
   }
 
@@ -83,37 +81,58 @@ protected void onAbandon() {
   public List<MediaStoreData> loadInBackground() {
     List<MediaStoreData> data = queryImages();
     data.addAll(queryVideos());
-    Collections.sort(data, new Comparator<MediaStoreData>() {
-      @Override
-      public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2) {
-        return Long.valueOf(mediaStoreData2.dateTaken).compareTo(mediaStoreData.dateTaken);
-      }
-    });
+    Collections.sort(
+        data,
+        new Comparator<MediaStoreData>() {
+          @Override
+          public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2) {
+            return Long.valueOf(mediaStoreData2.dateTaken).compareTo(mediaStoreData.dateTaken);
+          }
+        });
     return data;
   }
 
   private List<MediaStoreData> queryImages() {
-    return query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, IMAGE_PROJECTION,
-        MediaStore.Images.ImageColumns.DATE_TAKEN, MediaStore.Images.ImageColumns._ID,
-        MediaStore.Images.ImageColumns.DATE_TAKEN, MediaStore.Images.ImageColumns.DATE_MODIFIED,
-        MediaStore.Images.ImageColumns.MIME_TYPE, MediaStore.Images.ImageColumns.ORIENTATION,
+    return query(
+        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
+        IMAGE_PROJECTION,
+        MediaStore.Images.ImageColumns.DATE_TAKEN,
+        MediaStore.Images.ImageColumns._ID,
+        MediaStore.Images.ImageColumns.DATE_TAKEN,
+        MediaStore.Images.ImageColumns.DATE_MODIFIED,
+        MediaStore.Images.ImageColumns.MIME_TYPE,
+        MediaStore.Images.ImageColumns.ORIENTATION,
         MediaStoreData.Type.IMAGE);
   }
 
   private List<MediaStoreData> queryVideos() {
-    return query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, VIDEO_PROJECTION,
-        MediaStore.Video.VideoColumns.DATE_TAKEN, MediaStore.Video.VideoColumns._ID,
-        MediaStore.Video.VideoColumns.DATE_TAKEN, MediaStore.Video.VideoColumns.DATE_MODIFIED,
-        MediaStore.Video.VideoColumns.MIME_TYPE, MediaStore.Images.ImageColumns.ORIENTATION,
+    return query(
+        MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
+        VIDEO_PROJECTION,
+        MediaStore.Video.VideoColumns.DATE_TAKEN,
+        MediaStore.Video.VideoColumns._ID,
+        MediaStore.Video.VideoColumns.DATE_TAKEN,
+        MediaStore.Video.VideoColumns.DATE_MODIFIED,
+        MediaStore.Video.VideoColumns.MIME_TYPE,
+        MediaStore.Images.ImageColumns.ORIENTATION,
         MediaStoreData.Type.VIDEO);
   }
 
-  private List<MediaStoreData> query(Uri contentUri, String[] projection, String sortByCol,
-      String idCol, String dateTakenCol, String dateModifiedCol, String mimeTypeCol,
-      String orientationCol, MediaStoreData.Type type) {
+  private List<MediaStoreData> query(
+      Uri contentUri,
+      String[] projection,
+      String sortByCol,
+      String idCol,
+      String dateTakenCol,
+      String dateModifiedCol,
+      String mimeTypeCol,
+      String orientationCol,
+      MediaStoreData.Type type) {
     final List<MediaStoreData> data = new ArrayList<MediaStoreData>();
-    Cursor cursor = getContext().getContentResolver()
-        .query(contentUri, projection, null, null, sortByCol + " DESC");
+    Cursor cursor =
+        getContext()
+            .getContentResolver()
+            .query(contentUri, projection, null, null, sortByCol + " DESC");
 
     if (cursor == null) {
       return data;
@@ -133,8 +152,15 @@ public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2
         long dateModified = cursor.getLong(dateModifiedColNum);
         int orientation = cursor.getInt(orientationColNum);
 
-        data.add(new MediaStoreData(id, Uri.withAppendedPath(contentUri, Long.toString(id)),
-            mimeType, dateTaken, dateModified, orientation, type));
+        data.add(
+            new MediaStoreData(
+                id,
+                Uri.withAppendedPath(contentUri, Long.toString(id)),
+                mimeType,
+                dateTaken,
+                dateModified,
+                orientation,
+                type));
       }
     } finally {
       cursor.close();
@@ -146,10 +172,10 @@ public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2
   private void registerContentObserver() {
     if (!observerRegistered) {
       ContentResolver cr = getContext().getContentResolver();
-      cr.registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, false,
-          forceLoadContentObserver);
-      cr.registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, false,
-          forceLoadContentObserver);
+      cr.registerContentObserver(
+          MediaStore.Images.Media.EXTERNAL_CONTENT_URI, false, forceLoadContentObserver);
+      cr.registerContentObserver(
+          MediaStore.Video.Media.EXTERNAL_CONTENT_URI, false, forceLoadContentObserver);
 
       observerRegistered = true;
     }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 96897779d..7eb9e1887 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -3,8 +3,6 @@
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
-import android.support.annotation.NonNull;
-import android.support.v7.widget.RecyclerView;
 import android.view.Display;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -12,19 +10,21 @@
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.recyclerview.widget.RecyclerView;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.signature.MediaStoreSignature;
+import com.bumptech.glide.util.Preconditions;
 import java.util.Collections;
 import java.util.List;
 
-/**
- * Displays {@link com.bumptech.glide.samples.gallery.MediaStoreData} in a recycler view.
- */
+/** Displays {@link com.bumptech.glide.samples.gallery.MediaStoreData} in a recycler view. */
 class RecyclerAdapter extends RecyclerView.Adapter<RecyclerAdapter.ListViewHolder>
     implements ListPreloader.PreloadSizeProvider<MediaStoreData>,
-    ListPreloader.PreloadModelProvider<MediaStoreData> {
+        ListPreloader.PreloadModelProvider<MediaStoreData> {
 
   private final List<MediaStoreData> data;
   private final int screenWidth;
@@ -41,40 +41,39 @@
     screenWidth = getScreenWidth(context);
   }
 
+  @NonNull
   @Override
-  public ListViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
+  public ListViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) {
     LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext());
     final View view = inflater.inflate(R.layout.recycler_item, viewGroup, false);
     view.getLayoutParams().width = screenWidth;
 
     if (actualDimensions == null) {
-      view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
-        @Override
-        public boolean onPreDraw() {
-          if (actualDimensions == null) {
-            actualDimensions = new int[] { view.getWidth(), view.getHeight() };
-          }
-          view.getViewTreeObserver().removeOnPreDrawListener(this);
-          return true;
-        }
-      });
+      view.getViewTreeObserver()
+          .addOnPreDrawListener(
+              new ViewTreeObserver.OnPreDrawListener() {
+                @Override
+                public boolean onPreDraw() {
+                  if (actualDimensions == null) {
+                    actualDimensions = new int[] {view.getWidth(), view.getHeight()};
+                  }
+                  view.getViewTreeObserver().removeOnPreDrawListener(this);
+                  return true;
+                }
+              });
     }
 
     return new ListViewHolder(view);
   }
 
   @Override
-  public void onBindViewHolder(ListViewHolder viewHolder, int position) {
+  public void onBindViewHolder(@NonNull ListViewHolder viewHolder, int position) {
     MediaStoreData current = data.get(position);
 
     Key signature =
         new MediaStoreSignature(current.mimeType, current.dateModified, current.orientation);
 
-    requestBuilder
-        .clone()
-        .signature(signature)
-        .load(current.uri)
-        .into(viewHolder.image);
+    requestBuilder.clone().signature(signature).load(current.uri).into(viewHolder.image);
   }
 
   @Override
@@ -95,22 +94,23 @@ public int getItemViewType(int position) {
   @NonNull
   @Override
   public List<MediaStoreData> getPreloadItems(int position) {
-    return Collections.singletonList(data.get(position));
+    return data.isEmpty()
+        ? Collections.<MediaStoreData>emptyList()
+        : Collections.singletonList(data.get(position));
   }
 
-  @NonNull
+  @Nullable
   @Override
-  public RequestBuilder<Drawable> getPreloadRequestBuilder(MediaStoreData item) {
+  public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull MediaStoreData item) {
     MediaStoreSignature signature =
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
-    return requestBuilder
-        .clone()
-        .signature(signature)
-        .load(item.uri);
+    return requestBuilder.clone().signature(signature).load(item.uri);
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(MediaStoreData item, int adapterPosition, int perItemPosition) {
+  public int[] getPreloadSize(
+      @NonNull MediaStoreData item, int adapterPosition, int perItemPosition) {
     return actualDimensions;
   }
 
@@ -118,7 +118,7 @@ public int getItemViewType(int position) {
   @SuppressWarnings("deprecation")
   private static int getScreenWidth(Context context) {
     WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-    Display display = wm.getDefaultDisplay();
+    Display display = Preconditions.checkNotNull(wm).getDefaultDisplay();
     Point size = new Point();
     display.getSize(size);
     return size.x;
@@ -128,13 +128,13 @@ private static int getScreenWidth(Context context) {
    * ViewHolder containing views to display individual {@link
    * com.bumptech.glide.samples.gallery.MediaStoreData}.
    */
-  public static final class ListViewHolder extends RecyclerView.ViewHolder {
+  static final class ListViewHolder extends RecyclerView.ViewHolder {
 
     private final ImageView image;
 
-    public ListViewHolder(View itemView) {
+    ListViewHolder(View itemView) {
       super(itemView);
-      image = (ImageView) itemView.findViewById(R.id.image);
+      image = itemView.findViewById(R.id.image);
     }
   }
 }
diff --git a/samples/gallery/src/main/res/layout/main_activity.xml b/samples/gallery/src/main/res/layout/main_activity.xml
index 8a31cf241..26fd8b6a8 100644
--- a/samples/gallery/src/main/res/layout/main_activity.xml
+++ b/samples/gallery/src/main/res/layout/main_activity.xml
@@ -1,7 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <FrameLayout
   xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  tools:ignore="MergeRootFrame"
   android:id="@+id/fragment_container"
   android:layout_width="match_parent"
-  android:layout_height="match_parent">
-</FrameLayout>
+  android:layout_height="match_parent" />
diff --git a/samples/gallery/src/main/res/layout/recycler_view.xml b/samples/gallery/src/main/res/layout/recycler_view.xml
index 2136175aa..28400c61d 100644
--- a/samples/gallery/src/main/res/layout/recycler_view.xml
+++ b/samples/gallery/src/main/res/layout/recycler_view.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<android.support.v7.widget.RecyclerView
+<androidx.recyclerview.widget.RecyclerView
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/recycler_view"
     android:paddingBottom="20dp"
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index 9512035e5..27e418260 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -1,19 +1,18 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile 'com.google.code.gson:gson:2.8.0'
-    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    implementation 'com.google.code.gson:gson:2.8.2'
+    implementation "androidx.recyclerview:recyclerview:${ANDROID_X_VERSION}"
+    implementation "androidx.fragment:fragment:${ANDROID_X_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
diff --git a/samples/giphy/lint.xml b/samples/giphy/lint.xml
index 94bb2b69c..1b9db4caa 100644
--- a/samples/giphy/lint.xml
+++ b/samples/giphy/lint.xml
@@ -3,4 +3,6 @@
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index cff2771de..469e1295a 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -3,6 +3,11 @@
           package="com.bumptech.glide.samples.giphy">
 
     <uses-permission android:name="android.permission.INTERNET"/>
+    <!--
+    Allows Glide to monitor connectivity status and restart failed requests if users go from a
+    a disconnected to a connected network state.
+    -->
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
 
     <application
         android:allowBackup="false"
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index 921dc0db6..ac29f11d9 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -3,6 +3,7 @@
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
+import com.bumptech.glide.util.Util;
 import com.google.gson.Gson;
 import java.io.IOException;
 import java.io.InputStream;
@@ -13,15 +14,14 @@
 import java.util.Arrays;
 import java.util.HashSet;
 
-/**
- * A java wrapper for Giphy's http api based on https://github.com/Giphy/GiphyAPI.
- */
+/** A java wrapper for Giphy's http api based on https://github.com/Giphy/GiphyAPI. */
 public final class Api {
   private static volatile Api api = null;
   private static final String BETA_KEY = "dc6zaTOxFJmzC";
   private static final String BASE_URL = "https://api.giphy.com/";
-  private static final String SEARCH_PATH = "v1/gifs/search";
   private static final String TRENDING_PATH = "v1/gifs/trending";
+  private static final int LIMIT = 100;
+  private static final int OFFSET = 0;
   private final Handler bgHandler;
   private final Handler mainHandler;
   private final HashSet<Monitor> monitors = new HashSet<>();
@@ -30,18 +30,11 @@ private static String signUrl(String url) {
     return url + "&api_key=" + BETA_KEY;
   }
 
-  private static String getSearchUrl(String query, int limit, int offset) {
-    return signUrl(
-        BASE_URL + SEARCH_PATH + "?q=" + query + "&limit=" + limit + "&offset=" + offset);
+  private static String getTrendingUrl() {
+    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + LIMIT + "&offset=" + OFFSET);
   }
 
-  private static String getTrendingUrl(int limit, int offset) {
-    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + limit + "&offset=" + offset);
-  }
-
-  /**
-   * An interface for listening for search results.
-   */
+  /** An interface for listening for search results. */
   public interface Monitor {
     /**
      * Called when a search completes.
@@ -51,7 +44,7 @@ private static String getTrendingUrl(int limit, int offset) {
     void onSearchComplete(SearchResult result);
   }
 
-  public static Api get() {
+  static Api get() {
     if (api == null) {
       synchronized (Api.class) {
         if (api == null) {
@@ -70,75 +63,70 @@ private Api() {
     // Do nothing.
   }
 
-  public void addMonitor(Monitor monitor) {
+  void addMonitor(Monitor monitor) {
     monitors.add(monitor);
   }
 
-  public void removeMonitor(Monitor monitor) {
+  void removeMonitor(Monitor monitor) {
     monitors.remove(monitor);
   }
 
-  public void search(String searchTerm) {
-    String searchUrl = getSearchUrl(searchTerm, 100, 0);
-    query(searchUrl);
-  }
-
-  public void getTrending() {
-    String trendingUrl = getTrendingUrl(100, 0);
+  void getTrending() {
+    String trendingUrl = getTrendingUrl();
     query(trendingUrl);
   }
 
   private void query(final String apiUrl) {
-    bgHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        URL url;
-        try {
-          url = new URL(apiUrl);
-        } catch (MalformedURLException e) {
-          throw new RuntimeException(e);
-        }
+    bgHandler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            URL url;
+            try {
+              url = new URL(apiUrl);
+            } catch (MalformedURLException e) {
+              throw new RuntimeException(e);
+            }
 
-        HttpURLConnection urlConnection = null;
-        InputStream is = null;
-        SearchResult result = new SearchResult();
-        try {
-          urlConnection = (HttpURLConnection) url.openConnection();
-          is = urlConnection.getInputStream();
-          InputStreamReader reader = new InputStreamReader(is);
-          result = new Gson().fromJson(reader, SearchResult.class);
-        } catch (IOException e) {
-          e.printStackTrace();
-        } finally {
-          if (is != null) {
+            HttpURLConnection urlConnection = null;
+            InputStream is = null;
+            SearchResult result = new SearchResult();
             try {
-              is.close();
+              urlConnection = (HttpURLConnection) url.openConnection();
+              is = urlConnection.getInputStream();
+              InputStreamReader reader = new InputStreamReader(is);
+              result = new Gson().fromJson(reader, SearchResult.class);
             } catch (IOException e) {
-              // Do nothing.
+              e.printStackTrace();
+            } finally {
+              if (is != null) {
+                try {
+                  is.close();
+                } catch (IOException e) {
+                  // Do nothing.
+                }
+              }
+              if (urlConnection != null) {
+                urlConnection.disconnect();
+              }
             }
-          }
-          if (urlConnection != null) {
-            urlConnection.disconnect();
-          }
-        }
 
-        final SearchResult finalResult = result;
-        mainHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            for (Monitor monitor : monitors) {
-              monitor.onSearchComplete(finalResult);
-            }
+            final SearchResult finalResult = result;
+            mainHandler.post(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    for (Monitor monitor : monitors) {
+                      monitor.onSearchComplete(finalResult);
+                    }
+                  }
+                });
           }
         });
-      }
-    });
   }
 
-  /**
-   * A POJO mirroring the top level result JSON object returned from Giphy's api.
-   */
-  public static class SearchResult {
+  /** A POJO mirroring the top level result JSON object returned from Giphy's api. */
+  public static final class SearchResult {
     public GifResult[] data;
 
     @Override
@@ -149,17 +137,33 @@ public String toString() {
 
   /**
    * A POJO mirroring an individual GIF image returned from Giphy's api.
+   *
+   * <p>Implements equals and hashcode so that in memory caching will work when this object is used
+   * as a model for loading Glide's images.
    */
-  public static class GifResult {
+  public static final class GifResult {
     public String id;
-    // Page url not GIF url
-    public String url;
-    public GifUrlSet images;
+    GifUrlSet images;
+
+    @Override
+    public int hashCode() {
+      int result = id != null ? id.hashCode() : 17;
+      result = 31 * result + (images != null ? images.hashCode() : 17);
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof GifResult) {
+        GifResult other = (GifResult) obj;
+        return Util.bothNullOrEqual(id, other.id) && Util.bothNullOrEqual(images, other.images);
+      }
+      return false;
+    }
 
     @Override
     public String toString() {
-      return "GifResult{" + "id='" + id + '\'' + ", url='" + url + '\'' + ", images=" + images
-          + '}';
+      return "GifResult{" + "id='" + id + '\'' + ", images=" + images + '}';
     }
   }
 
@@ -167,15 +171,39 @@ public String toString() {
    * A POJO mirroring a JSON object with a put of urls of different sizes and dimensions returned
    * for a single image from Giphy's api.
    */
-  public static class GifUrlSet {
-    public GifImage original;
-    public GifImage fixed_width;
-    public GifImage fixed_height;
+  public static final class GifUrlSet {
+    GifImage original;
+    GifImage fixed_width;
+    GifImage fixed_height;
+
+    @Override
+    public int hashCode() {
+      int result = original != null ? original.hashCode() : 17;
+      result = 31 * result + (fixed_width != null ? fixed_width.hashCode() : 17);
+      result = 31 * result + (fixed_height != null ? fixed_height.hashCode() : 17);
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof GifUrlSet) {
+        GifUrlSet other = (GifUrlSet) obj;
+        return Util.bothNullOrEqual(original, other.original)
+            && Util.bothNullOrEqual(fixed_width, other.fixed_width)
+            && Util.bothNullOrEqual(fixed_height, other.fixed_height);
+      }
+      return false;
+    }
 
     @Override
     public String toString() {
-      return "GifUrlSet{" + "original=" + original + ", fixed_width="
-          + fixed_width + ", fixed_height=" + fixed_height
+      return "GifUrlSet{"
+          + "original="
+          + original
+          + ", fixed_width="
+          + fixed_width
+          + ", fixed_height="
+          + fixed_height
           + '}';
     }
   }
@@ -184,17 +212,32 @@ public String toString() {
    * A POJO mirroring a JSON object for an image with one particular url, size and dimension
    * returned from Giphy's api.
    */
-  public static class GifImage {
-    public String url;
-    public int width;
-    public int height;
-    public int frames;
-    public int size;
+  public static final class GifImage {
+    String url;
+    int width;
+    int height;
+
+    @Override
+    public int hashCode() {
+      int result = url != null ? url.hashCode() : 17;
+      result = 31 * result + width;
+      result = 31 * result + height;
+      return result;
+    }
 
     @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof GifImage) {
+        GifImage other = (GifImage) obj;
+        return other.width == width
+            && other.height == height
+            && Util.bothNullOrEqual(url, other.url);
+      }
+      return false;
+    }
+
     public String toString() {
-      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height
-          + ", frames=" + frames + ", size=" + size + '}';
+      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height + '}';
     }
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
index fd92665ea..05996088b 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
@@ -18,9 +18,7 @@
 import com.bumptech.glide.request.target.Target;
 import com.google.gson.Gson;
 
-/**
- * An {@link android.app.Activity} for displaying full size original GIFs.
- */
+/** An {@link android.app.Activity} for displaying full size original GIFs. */
 public class FullscreenActivity extends Activity {
   private static final String EXTRA_RESULT_JSON = "result_json";
   private GifDrawable gifDrawable;
@@ -41,48 +39,57 @@ protected void onCreate(Bundle savedInstanceState) {
 
     ImageView gifView = (ImageView) findViewById(R.id.fullscreen_gif);
 
-    gifView.setOnClickListener(new View.OnClickListener() {
-      @Override
-      public void onClick(View view) {
-        ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
-        ClipData clip = ClipData.newPlainText("giphy_url", result.images.original.url);
-        clipboard.setPrimaryClip(clip);
+    gifView.setOnClickListener(
+        new View.OnClickListener() {
+          @Override
+          public void onClick(View view) {
+            ClipboardManager clipboard =
+                (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
+            ClipData clip = ClipData.newPlainText("giphy_url", result.images.original.url);
+            clipboard.setPrimaryClip(clip);
 
-        if (gifDrawable != null) {
-          if (gifDrawable.isRunning()) {
-            gifDrawable.stop();
-          } else {
-            gifDrawable.start();
+            if (gifDrawable != null) {
+              if (gifDrawable.isRunning()) {
+                gifDrawable.stop();
+              } else {
+                gifDrawable.start();
+              }
+            }
           }
-        }
-      }
-    });
+        });
 
-    RequestBuilder<Drawable> thumbnailRequest = GlideApp.with(this)
-        .load(result)
-        .decode(Bitmap.class);
+    RequestBuilder<Drawable> thumbnailRequest =
+        GlideApp.with(this).load(result).decode(Bitmap.class);
 
     GlideApp.with(this)
         .load(result.images.original.url)
         .thumbnail(thumbnailRequest)
-        .listener(new RequestListener<Drawable>() {
-          @Override
-          public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
-              boolean isFirstResource) {
-            return false;
-          }
+        .listener(
+            new RequestListener<Drawable>() {
+              @Override
+              public boolean onLoadFailed(
+                  GlideException e,
+                  Object model,
+                  Target<Drawable> target,
+                  boolean isFirstResource) {
+                return false;
+              }
 
-          @Override
-          public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
-              DataSource dataSource, boolean isFirstResource) {
-            if (resource instanceof GifDrawable) {
-              gifDrawable = (GifDrawable) resource;
-            } else {
-              gifDrawable = null;
-            }
-            return false;
-          }
-        })
+              @Override
+              public boolean onResourceReady(
+                  Drawable resource,
+                  Object model,
+                  Target<Drawable> target,
+                  DataSource dataSource,
+                  boolean isFirstResource) {
+                if (resource instanceof GifDrawable) {
+                  gifDrawable = (GifDrawable) resource;
+                } else {
+                  gifDrawable = null;
+                }
+                return false;
+              }
+            })
         .into(gifView);
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index 5381e1f22..ada3c42c5 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -1,19 +1,19 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.content.Context;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
 import java.io.InputStream;
 
-/**
- * Configures Glide for the Giphy sample app.
- */
+/** Configures Glide for the Giphy sample app. */
 @GlideModule
 public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index 184e976ea..0d4886cb1 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -1,44 +1,29 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.text.TextUtils;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
+import com.bumptech.glide.samples.giphy.Api.GifResult;
 import java.io.InputStream;
 
 /**
  * A model loader that translates a POJO mirroring a JSON object representing a single image from
- * Giphy's api into an {@link java.io.InputStream} that can be decoded into an
- * {@link android.graphics.drawable.Drawable}.
+ * Giphy's api into an {@link java.io.InputStream} that can be decoded into an {@link
+ * android.graphics.drawable.Drawable}.
  */
-public class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
+public final class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
 
   @Override
-  public boolean handles(Api.GifResult model) {
+  public boolean handles(@NonNull Api.GifResult model) {
     return true;
   }
 
-  /**
-   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
-   */
-  public static class Factory implements ModelLoaderFactory<Api.GifResult, InputStream> {
-
-
-    @Override
-    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
-      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
-    }
-
-    @Override
-    public void teardown() {
-      // Do nothing.
-    }
-  }
-
-  public GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
+  private GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
     super(urlLoader);
   }
 
@@ -62,4 +47,18 @@ protected String getUrl(Api.GifResult model, int width, int height, Options opti
   private static int getDifference(Api.GifImage gifImage, int width, int height) {
     return Math.abs(width - gifImage.width) + Math.abs(height - gifImage.height);
   }
+
+  /** The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s. */
+  public static final class Factory implements ModelLoaderFactory<GifResult, InputStream> {
+    @NonNull
+    @Override
+    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index 5ae74d704..bf9327d94 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -7,15 +7,19 @@
 import android.content.Intent;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
+import androidx.recyclerview.widget.RecyclerView.RecyclerListener;
+import androidx.recyclerview.widget.RecyclerView.ViewHolder;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
 import java.util.Collections;
 import java.util.List;
@@ -32,26 +36,33 @@ protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_main);
 
-    ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
+    ImageView giphyLogoView = findViewById(R.id.giphy_logo_view);
 
-    GlideApp.with(this)
-        .load(R.raw.large_giphy_logo)
-        .into(giphyLogoView);
+    GlideApp.with(this).load(R.raw.large_giphy_logo).into(giphyLogoView);
 
-    RecyclerView gifList = (RecyclerView) findViewById(R.id.gif_list);
+    RecyclerView gifList = findViewById(R.id.gif_list);
     LinearLayoutManager layoutManager = new LinearLayoutManager(this);
     gifList.setLayoutManager(layoutManager);
 
-    RequestBuilder<Drawable> gifItemRequest = GlideApp.with(this)
-        .asDrawable();
+    RequestBuilder<Drawable> gifItemRequest = GlideApp.with(this).asDrawable();
 
-    ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider =
-        new ViewPreloadSizeProvider<>();
+    ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider = new ViewPreloadSizeProvider<>();
     adapter = new GifAdapter(this, gifItemRequest, preloadSizeProvider);
     gifList.setAdapter(adapter);
     RecyclerViewPreloader<Api.GifResult> preloader =
         new RecyclerViewPreloader<>(GlideApp.with(this), adapter, preloadSizeProvider, 4);
     gifList.addOnScrollListener(preloader);
+    gifList.setRecyclerListener(
+        new RecyclerListener() {
+          @Override
+          public void onViewRecycled(ViewHolder holder) {
+            // This is an optimization to reduce the memory usage of RecyclerView's recycled view
+            // pool
+            // and good practice when using Glide with RecyclerView.
+            GifViewHolder gifViewHolder = (GifViewHolder) holder;
+            GlideApp.with(MainActivity.this).clear(gifViewHolder.gifView);
+          }
+        });
   }
 
   @Override
@@ -79,12 +90,14 @@ public void onSearchComplete(Api.SearchResult result) {
     private static final Api.GifResult[] EMPTY_RESULTS = new Api.GifResult[0];
 
     private final Activity activity;
-    private RequestBuilder<Drawable> requestBuilder;
-    private ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
+    private final RequestBuilder<Drawable> requestBuilder;
+    private final ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
 
     private Api.GifResult[] results = EMPTY_RESULTS;
 
-    GifAdapter(Activity activity, RequestBuilder<Drawable> requestBuilder,
+    GifAdapter(
+        Activity activity,
+        RequestBuilder<Drawable> requestBuilder,
         ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider) {
       this.activity = activity;
       this.requestBuilder = requestBuilder;
@@ -109,21 +122,23 @@ public GifViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
     @Override
     public void onBindViewHolder(GifViewHolder holder, int position) {
       final Api.GifResult result = results[position];
-      holder.gifView.setOnClickListener(new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-          ClipboardManager clipboard =
-              (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
-          ClipData clip =
-              ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
-          clipboard.setPrimaryClip(clip);
-
-          Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
-          activity.startActivity(fullscreenIntent);
-        }
-      });
-
-      requestBuilder.load(result).into(holder.gifView);
+      holder.gifView.setOnClickListener(
+          new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+              ClipboardManager clipboard =
+                  (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+              ClipData clip = ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
+              Preconditions.checkNotNull(clipboard).setPrimaryClip(clip);
+
+              Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
+              activity.startActivity(fullscreenIntent);
+            }
+          });
+
+      // clearOnDetach let's us stop animating GifDrawables that RecyclerView hasn't yet recycled
+      // but that are currently off screen.
+      requestBuilder.load(result).into(holder.gifView).clearOnDetach();
 
       preloadSizeProvider.setView(holder.gifView);
     }
@@ -144,9 +159,9 @@ public int getItemCount() {
       return Collections.singletonList(results[position]);
     }
 
-    @NonNull
+    @Nullable
     @Override
-    public RequestBuilder<Drawable> getPreloadRequestBuilder(Api.GifResult item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Api.GifResult item) {
       return requestBuilder.load(item);
     }
   }
@@ -156,7 +171,7 @@ public int getItemCount() {
 
     GifViewHolder(View itemView) {
       super(itemView);
-      gifView = (ImageView) itemView.findViewById(R.id.gif_view);
+      gifView = itemView.findViewById(R.id.gif_view);
     }
   }
 }
diff --git a/samples/giphy/src/main/res/drawable-xxxhdpi/googlelogo_color_120x44dp.9.png b/samples/giphy/src/main/res/drawable-xxxhdpi/googlelogo_color_120x44dp.9.png
deleted file mode 100755
index 1ab50e6cf..000000000
Binary files a/samples/giphy/src/main/res/drawable-xxxhdpi/googlelogo_color_120x44dp.9.png and /dev/null differ
diff --git a/samples/giphy/src/main/res/layout/activity_main.xml b/samples/giphy/src/main/res/layout/activity_main.xml
index 332705305..cff52563d 100644
--- a/samples/giphy/src/main/res/layout/activity_main.xml
+++ b/samples/giphy/src/main/res/layout/activity_main.xml
@@ -11,7 +11,7 @@
         android:layout_height="50dp"
         android:layout_gravity="center_horizontal"
         android:contentDescription="@string/giphy_logo_description" />
-    <android.support.v7.widget.RecyclerView
+    <androidx.recyclerview.widget.RecyclerView
         android:id="@+id/gif_list"
         android:layout_height="0dp"
         android:layout_width="match_parent"
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
index df3acd658..959f2f39c 100644
--- a/samples/imgur/build.gradle
+++ b/samples/imgur/build.gradle
@@ -2,7 +2,6 @@ apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
         applicationId "com.bumptech.glide.samples.imgur"
@@ -11,7 +10,7 @@ android {
         versionCode 1
         versionName "1.0"
 
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
 
     }
     compileOptions {
@@ -21,35 +20,41 @@ android {
     buildTypes {
         release {
             minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
 }
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.google.dagger:dagger:${DAGGER_VERSION}"
+    implementation "com.google.dagger:dagger:${DAGGER_VERSION}"
     annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}"
-    compile "com.google.dagger:dagger-android:${DAGGER_VERSION}"
-    compile "com.google.dagger:dagger-android-support:${DAGGER_VERSION}"
+    implementation "com.google.dagger:dagger-android:${DAGGER_VERSION}"
+    implementation ("com.google.dagger:dagger-android-support:${DAGGER_VERSION}") {
+        exclude group: "com.android.support"
+    }
     annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}"
 
-    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
-    compile 'com.squareup.retrofit2:retrofit:2.2.0'
-    compile 'com.squareup.retrofit2:converter-gson:2.2.0'
-    compile 'com.squareup.retrofit2:adapter-rxjava:2.2.0'
+    implementation "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
+    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
+    implementation 'com.squareup.retrofit2:adapter-rxjava:2.3.0'
+
+    implementation 'io.reactivex:rxandroid:1.2.1'
+    implementation 'io.reactivex:rxjava:1.3.4'
 
-    compile 'io.reactivex:rxandroid:1.2.1'
-    compile 'io.reactivex:rxjava:1.2.9'
+    implementation "androidx.appcompat:appcompat:${ANDROID_X_VERSION}"
+    implementation "androidx.cardview:cardview:${ANDROID_X_VERSION}"
+    implementation "androidx.recyclerview:recyclerview:${ANDROID_X_VERSION}"
 
-    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}"
-    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    // Fixes a compilation warning related to dagger, see
+    // https://github.com/google/guava/issues/2721.
+    compileOnly "com.google.errorprone:error_prone_annotations:${ERROR_PRONE_VERSION}"
 }
 
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
     commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.card/.MainActivity'
 }
+
diff --git a/samples/imgur/gradle.properties b/samples/imgur/gradle.properties
new file mode 100644
index 000000000..d015431a8
--- /dev/null
+++ b/samples/imgur/gradle.properties
@@ -0,0 +1,2 @@
+android.useAndroidX=true
+android.enableJetifier=true
\ No newline at end of file
diff --git a/samples/imgur/lint.xml b/samples/imgur/lint.xml
index ac292ab1a..948353b6b 100644
--- a/samples/imgur/lint.xml
+++ b/samples/imgur/lint.xml
@@ -4,4 +4,6 @@
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore" />
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/imgur/proguard-rules.pro b/samples/imgur/proguard-rules.pro
deleted file mode 100644
index 896f865d9..000000000
--- a/samples/imgur/proguard-rules.pro
+++ /dev/null
@@ -1,25 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/judds/Library/Android/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
-#-renamesourcefileattribute SourceFile
diff --git a/samples/imgur/src/main/AndroidManifest.xml b/samples/imgur/src/main/AndroidManifest.xml
index 23f5ec718..854c9930f 100644
--- a/samples/imgur/src/main/AndroidManifest.xml
+++ b/samples/imgur/src/main/AndroidManifest.xml
@@ -2,6 +2,11 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.bumptech.glide.samples.imgur">
   <uses-permission android:name="android.permission.INTERNET" />
+  <!--
+  Allows Glide to monitor connectivity status and restart failed requests if users go from a
+  a disconnected to a connected network state.
+  -->
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <application
     android:allowBackup="false"
     android:icon="@mipmap/ic_launcher"
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
index d40c24c8c..6fd5674b2 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
@@ -4,11 +4,9 @@
 import dagger.Provides;
 import okhttp3.OkHttpClient;
 
-/**
- * The Application Dagger module for the Imgur sample.
- */
+/** The Application Dagger module for the Imgur sample. */
 @Module
-public class ApplicationModule {
+class ApplicationModule {
   @Provides
   OkHttpClient okHttpClient() {
     return new OkHttpClient();
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
index c2b788e2b..bbb5f5898 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
@@ -3,9 +3,7 @@
 import dagger.android.AndroidInjector;
 import dagger.android.support.DaggerApplication;
 
-/**
- * Runs Dagger injection in the Imgur sample.
- */
+/** Runs Dagger injection in the Imgur sample. */
 public final class ImgurApplication extends DaggerApplication {
   @Override
   protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
index 7b9d639aa..67b46f6df 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
@@ -6,15 +6,15 @@
 import dagger.android.support.AndroidSupportInjectionModule;
 import javax.inject.Singleton;
 
-/**
- * Specifies Dagger modules for {@link ImgurApplication}.
- */
+/** Specifies Dagger modules for {@link ImgurApplication}. */
 @Singleton
-@Component(modules = {
-    AndroidSupportInjectionModule.class,
-    MainActivityModule.class,
-    ApplicationModule.class,
-    ApiModule.class
-})
+@Component(
+    modules = {
+      AndroidSupportInjectionModule.class,
+      MainActivityModule.class,
+      ApplicationModule.class,
+      ApiModule.class
+    })
 public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {
+  // Empty.
 }
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
index c673ad244..3daf5319d 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
 
-/**
- * Generates a Glide API for the Imgur sample.
- */
+/** Generates a Glide API for the Imgur sample. */
 @GlideModule(glideName = "ImgurGlide")
 public class ImgurGlideModule extends AppGlideModule {
   // Intentionally Empty.
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
index 384543997..bc6c35300 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
@@ -1,17 +1,17 @@
 package com.bumptech.glide.samples.imgur;
 
 import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.v7.app.AppCompatActivity;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
-import android.support.v7.widget.RecyclerView.ViewHolder;
 import android.text.TextUtils;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.TextView;
+import androidx.annotation.NonNull;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
+import androidx.recyclerview.widget.RecyclerView.ViewHolder;
 import com.bumptech.glide.samples.imgur.api.Image;
 import dagger.android.AndroidInjection;
 import java.util.Collections;
@@ -23,12 +23,13 @@
 import rx.android.schedulers.AndroidSchedulers;
 import rx.schedulers.Schedulers;
 
-/**
- * Displays images and GIFs from Imgur in a scrollable list of cards.
- */
+/** Displays images and GIFs from Imgur in a scrollable list of cards. */
 public final class MainActivity extends AppCompatActivity {
 
-  @Inject @Named("hotViralImages") Observable<List<Image>> fetchImagesObservable;
+  @Inject
+  @Named("hotViralImages")
+  Observable<List<Image>> fetchImagesObservable;
+
   private ImgurImageAdapter adapter;
 
   @Override
@@ -47,18 +48,19 @@ protected void onCreate(Bundle savedInstanceState) {
     fetchImagesObservable
         .subscribeOn(Schedulers.newThread())
         .observeOn(AndroidSchedulers.mainThread())
-        .subscribe(new Observer<List<Image>>() {
-          @Override
-          public void onCompleted() { }
-
-          @Override
-          public void onError(Throwable e) { }
-
-          @Override
-          public void onNext(List<Image> images) {
-            adapter.setData(images);
-          }
-        });
+        .subscribe(
+            new Observer<List<Image>>() {
+              @Override
+              public void onCompleted() {}
+
+              @Override
+              public void onError(Throwable e) {}
+
+              @Override
+              public void onNext(List<Image> images) {
+                adapter.setData(images);
+              }
+            });
   }
 
   @Override
@@ -78,20 +80,17 @@ public void setData(@NonNull List<Image> images) {
 
     @Override
     public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-      return new ViewHolder(LayoutInflater.from(parent.getContext())
-          .inflate(R.layout.image_card, parent, false));
+      return new ViewHolder(
+          LayoutInflater.from(parent.getContext()).inflate(R.layout.image_card, parent, false));
     }
 
     @Override
     public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
       ViewHolder vh = (ViewHolder) holder;
       Image image = images.get(position);
-      vh.title.setText(
-          TextUtils.isEmpty(image.title) ? image.description : image.title);
+      vh.title.setText(TextUtils.isEmpty(image.title) ? image.description : image.title);
 
-      ImgurGlide.with(vh.imageView)
-          .load(image.link)
-          .into(vh.imageView);
+      ImgurGlide.with(vh.imageView).load(image.link).into(vh.imageView);
     }
 
     @Override
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
index 85b056916..7dde812bb 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
@@ -14,10 +14,7 @@
 import retrofit2.converter.gson.GsonConverterFactory;
 import rx.Observable;
 
-/**
- * Provides classes related to the Imgur API via Dagger.
- */
-@Singleton
+/** Provides classes related to the Imgur API via Dagger. */
 @Module
 public final class ApiModule {
 
@@ -28,27 +25,33 @@
     return imgurObservables.getHotViralImages(5 /*maxPages*/);
   }
 
-  @Provides ImgurObservables imgurObservables(ImgurService imgurService) {
+  @Provides
+  ImgurObservables imgurObservables(ImgurService imgurService) {
     return new ImgurObservables(imgurService);
   }
 
-  @Provides ImgurService getImgurService(Retrofit retrofit) {
+  @Provides
+  ImgurService getImgurService(Retrofit retrofit) {
     return retrofit.create(ImgurService.class);
   }
 
-  @Provides Retrofit retrofit() {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .addInterceptor(new Interceptor() {
-          @Override
-          public Response intercept(Chain chain) throws IOException {
-            return chain.proceed(
-                chain.request()
-                    .newBuilder()
-                    .addHeader("Authorization", "Client-ID " + ImgurService.CLIENT_ID)
-                    .build());
-          }
-        })
-        .build();
+  @Provides
+  Retrofit retrofit() {
+    OkHttpClient client =
+        new OkHttpClient.Builder()
+            .addInterceptor(
+                new Interceptor() {
+                  @Override
+                  public Response intercept(Chain chain) throws IOException {
+                    return chain.proceed(
+                        chain
+                            .request()
+                            .newBuilder()
+                            .addHeader("Authorization", "Client-ID " + ImgurService.CLIENT_ID)
+                            .build());
+                  }
+                })
+            .build();
     return new Retrofit.Builder()
         .client(client)
         .addConverterFactory(GsonConverterFactory.create())
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
index 6466b1527..daa309554 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
@@ -7,13 +7,11 @@
  *
  * <p>Populated automatically by GSON.
  */
-public final class Gallery {
+final class Gallery {
   public List<Image> data;
 
   @Override
   public String toString() {
-    return "Gallery{"
-        + "data=" + data
-        + '}';
+    return "Gallery{" + "data=" + data + '}';
   }
 }
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
index 3f0008234..28018b4ac 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
@@ -6,20 +6,30 @@
  * <p>Populated automatically by GSON
  */
 public final class Image {
-  public String id;
+  private String id;
   public String title;
   public String description;
   public String link;
-  public boolean is_album;
+  boolean is_album;
 
   @Override
   public String toString() {
     return "Image{"
-        + "id='" + id + '\''
-        + ", title='" + title + '\''
-        + ", description='" + description + '\''
-        + ", link='" + link + '\''
-        + ", is_album='" + is_album + '\''
+        + "id='"
+        + id
+        + '\''
+        + ", title='"
+        + title
+        + '\''
+        + ", description='"
+        + description
+        + '\''
+        + ", link='"
+        + link
+        + '\''
+        + ", is_album='"
+        + is_album
+        + '\''
         + '}';
   }
 }
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
index 26d5f034a..8b313f050 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
@@ -7,10 +7,8 @@
 import rx.functions.Func1;
 import rx.functions.Func2;
 
-/**
- * Observables for retrieving metadata from Imgur's API.
- */
-public final class ImgurObservables {
+/** Observables for retrieving metadata from Imgur's API. */
+final class ImgurObservables {
 
   private final ImgurService imgurService;
 
@@ -18,40 +16,47 @@
     this.imgurService = imgurService;
   }
 
-  public Observable<List<Image>> getHotViralImages(int maxPages) {
+  Observable<List<Image>> getHotViralImages(@SuppressWarnings("SameParameterValue") int maxPages) {
     return Observable.range(0, maxPages)
-        .flatMap(new Func1<Integer, Observable<List<Image>>>() {
-          @Override
-          public Observable<List<Image>> call(Integer integer) {
-            return imgurService.getHotViral(integer).map(new GetData()).flatMap(
-                new Func1<List<Image>, Observable<List<Image>>>() {
-                  @Override
-                  public Observable<List<Image>> call(List<Image> images) {
-                    for (Iterator<Image> iterator = images.iterator(); iterator.hasNext();) {
-                      if (iterator.next().is_album) {
-                        iterator.remove();
-                      }
-                    }
-                    return Observable.just(images);
-                  }
-                });
-          }
-        })
-        .takeWhile(new Func1<List<Image>, Boolean>() {
-          @Override
-          public Boolean call(List<Image> images) {
-            return !images.isEmpty();
-          }
-        })
-        .scan(new Func2<List<Image>, List<Image>, List<Image>>() {
-          @Override
-          public List<Image> call(List<Image> images, List<Image> images2) {
-            List<Image> result = new ArrayList<>(images.size() + images2.size());
-            result.addAll(images);
-            result.addAll(images2);
-            return result;
-          }
-        })
+        .flatMap(
+            new Func1<Integer, Observable<List<Image>>>() {
+              @Override
+              public Observable<List<Image>> call(Integer integer) {
+                return imgurService
+                    .getHotViral(integer)
+                    .map(new GetData())
+                    .flatMap(
+                        new Func1<List<Image>, Observable<List<Image>>>() {
+                          @Override
+                          public Observable<List<Image>> call(List<Image> images) {
+                            for (Iterator<Image> iterator = images.iterator();
+                                iterator.hasNext(); ) {
+                              if (iterator.next().is_album) {
+                                iterator.remove();
+                              }
+                            }
+                            return Observable.just(images);
+                          }
+                        });
+              }
+            })
+        .takeWhile(
+            new Func1<List<Image>, Boolean>() {
+              @Override
+              public Boolean call(List<Image> images) {
+                return !images.isEmpty();
+              }
+            })
+        .scan(
+            new Func2<List<Image>, List<Image>, List<Image>>() {
+              @Override
+              public List<Image> call(List<Image> images, List<Image> images2) {
+                List<Image> result = new ArrayList<>(images.size() + images2.size());
+                result.addAll(images);
+                result.addAll(images2);
+                return result;
+              }
+            })
         .cache();
   }
 
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
index ddab15062..1cc5261f0 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
@@ -4,9 +4,7 @@
 import retrofit2.http.Path;
 import rx.Observable;
 
-/**
- * Define's Imgur's API for Retrofit.
- */
+/** Define's Imgur's API for Retrofit. */
 public interface ImgurService {
   String CLIENT_ID = "36d1f6bef16370c";
 
@@ -17,21 +15,17 @@
   Observable<Gallery> getHot(@Path("sort") Sort sort, @Path("page") int page);
 
   @GET("gallery/{section}/{sort}/{page}.json")
-  Observable<Gallery> getGallery(@Path("section") Section section,
-      @Path("sort") Sort sort, @Path("page") int page);
+  Observable<Gallery> getGallery(
+      @Path("section") Section section, @Path("sort") Sort sort, @Path("page") int page);
 
-  /**
-   * Sections that Imgur's API allows us to query from.
-   */
+  /** Sections that Imgur's API allows us to query from. */
   enum Section {
     hot,
     top,
     user
   }
 
-  /**
-   * The sort order for content within a particular section.
-   */
+  /** The sort order for content within a particular section. */
   enum Sort {
     viral,
     top,
diff --git a/samples/imgur/src/main/res/layout/activity_main.xml b/samples/imgur/src/main/res/layout/activity_main.xml
index 4e7309f0a..9192dd631 100644
--- a/samples/imgur/src/main/res/layout/activity_main.xml
+++ b/samples/imgur/src/main/res/layout/activity_main.xml
@@ -4,7 +4,7 @@
   xmlns:tools="http://schemas.android.com/tools"
   tools:context="com.bumptech.glide.samples.imgur.MainActivity">
 
-  <android.support.v7.widget.RecyclerView
+  <androidx.recyclerview.widget.RecyclerView
     android:id="@+id/recycler_view"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
diff --git a/samples/imgur/src/main/res/layout/image_card.xml b/samples/imgur/src/main/res/layout/image_card.xml
index 92f2cbb76..68af24c67 100644
--- a/samples/imgur/src/main/res/layout/image_card.xml
+++ b/samples/imgur/src/main/res/layout/image_card.xml
@@ -6,7 +6,7 @@
   android:layout_height="wrap_content"
   android:padding="16dp">
 
-  <android.support.v7.widget.CardView
+  <androidx.cardview.widget.CardView
     android:id="@+id/card_view"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
@@ -31,5 +31,5 @@
         android:paddingTop="16dp"
         />
     </LinearLayout>
-  </android.support.v7.widget.CardView>
+  </androidx.cardview.widget.CardView>
 </FrameLayout>
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 433c9c4d5..9f6bf89ba 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -1,15 +1,14 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
+    implementation project(':library')
     annotationProcessor project(':annotation:compiler')
-    compile 'com.caverock:androidsvg:1.2.1'
-    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    implementation 'com.caverock:androidsvg:1.2.1'
+    implementation "androidx.fragment:fragment:${ANDROID_X_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.svg'
diff --git a/samples/svg/lint.xml b/samples/svg/lint.xml
index 94bb2b69c..bc99b5604 100644
--- a/samples/svg/lint.xml
+++ b/samples/svg/lint.xml
@@ -3,4 +3,6 @@
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+    <issue id="GradleDependency" severity="ignore"/>
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/svg/proguard-rules.pro b/samples/svg/proguard-rules.pro
deleted file mode 100644
index 95c847b91..000000000
--- a/samples/svg/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/judds/dev/adt-bundle-mac-x86_64-20131030/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
index f60b46461..ce4aab1ff 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -13,11 +13,10 @@
 import android.widget.TextView;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 
-/**
- * Displays an SVG image loaded from an android raw resource.
- */
+/** Displays an SVG image loaded from an android raw resource. */
 public class MainActivity extends Activity {
   private static final String TAG = "SVGActivity";
 
@@ -33,12 +32,13 @@ protected void onCreate(Bundle savedInstanceState) {
     imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
     imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);
 
-    requestBuilder = GlideApp.with(this)
-        .as(PictureDrawable.class)
-        .placeholder(R.drawable.image_loading)
-        .error(R.drawable.image_error)
-        .transition(withCrossFade())
-        .listener(new SvgSoftwareLayerSetter());
+    requestBuilder =
+        GlideApp.with(this)
+            .as(PictureDrawable.class)
+            .placeholder(R.drawable.image_loading)
+            .error(R.drawable.image_error)
+            .transition(withCrossFade())
+            .listener(new SvgSoftwareLayerSetter());
   }
 
   @Override
@@ -53,7 +53,7 @@ public void clearCache(View v) {
     glideRequests.clear(imageViewRes);
     glideRequests.clear(imageViewNet);
     GlideApp.get(this).clearMemory();
-    File cacheDir = Glide.getPhotoCacheDir(this);
+    File cacheDir = Preconditions.checkNotNull(Glide.getPhotoCacheDir(this));
     if (cacheDir.isDirectory()) {
       for (File child : cacheDir.listFiles()) {
         if (!child.delete()) {
@@ -85,8 +85,13 @@ private void reload() {
   }
 
   private void loadRes() {
-    Uri uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getPackageName() + "/"
-        + R.raw.android_toy_h);
+    Uri uri =
+        Uri.parse(
+            ContentResolver.SCHEME_ANDROID_RESOURCE
+                + "://"
+                + getPackageName()
+                + "/"
+                + R.raw.android_toy_h);
     requestBuilder.load(uri).into(imageViewRes);
   }
 
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
index 3fdd91ad5..215c4f743 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
@@ -1,31 +1,30 @@
 package com.bumptech.glide.samples.svg;
 
+import androidx.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.caverock.androidsvg.SVG;
 import com.caverock.androidsvg.SVGParseException;
-
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * Decodes an SVG internal representation from an {@link InputStream}.
- */
+/** Decodes an SVG internal representation from an {@link InputStream}. */
 public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     // TODO: Can we tell?
     return true;
   }
 
-  public Resource<SVG> decode(InputStream source, int width, int height, Options options)
+  public Resource<SVG> decode(
+      @NonNull InputStream source, int width, int height, @NonNull Options options)
       throws IOException {
     try {
       SVG svg = SVG.getFromInputStream(source);
-      return new SimpleResource<SVG>(svg);
+      return new SimpleResource<>(svg);
     } catch (SVGParseException ex) {
       throw new IOException("Cannot load SVG from stream", ex);
     }
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
index 4f600fdc1..f59e427cd 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
@@ -2,6 +2,8 @@
 
 import android.graphics.Picture;
 import android.graphics.drawable.PictureDrawable;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
@@ -9,16 +11,16 @@
 import com.caverock.androidsvg.SVG;
 
 /**
- * Convert the {@link SVG}'s internal representation to an Android-compatible one
- * ({@link Picture}).
+ * Convert the {@link SVG}'s internal representation to an Android-compatible one ({@link Picture}).
  */
 public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
+  @Nullable
   @Override
-  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode, Options options) {
+  public Resource<PictureDrawable> transcode(
+      @NonNull Resource<SVG> toTranscode, @NonNull Options options) {
     SVG svg = toTranscode.get();
     Picture picture = svg.renderToPicture();
     PictureDrawable drawable = new PictureDrawable(picture);
-    return new SimpleResource<PictureDrawable>(drawable);
+    return new SimpleResource<>(drawable);
   }
 }
-
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index 798d0f07f..b1c9e6390 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.graphics.drawable.PictureDrawable;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
@@ -9,14 +10,14 @@
 import com.caverock.androidsvg.SVG;
 import java.io.InputStream;
 
-/**
- * Module for the SVG sample app.
- */
+/** Module for the SVG sample app. */
 @GlideModule
 public class SvgModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Glide glide, Registry registry) {
-    registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
+    registry
+        .register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
         .append(InputStream.class, SVG.class, new SvgDecoder());
   }
 
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
index a28a21b7c..411b50d34 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
@@ -9,23 +9,27 @@
 import com.bumptech.glide.request.target.Target;
 
 /**
- * Listener which updates the {@link ImageView} to be software rendered, because
- * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
- * a hardware backed {@link android.graphics.Canvas Canvas}.
+ * Listener which updates the {@link ImageView} to be software rendered, because {@link
+ * com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on a
+ * hardware backed {@link android.graphics.Canvas Canvas}.
  */
 public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {
 
   @Override
-  public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawable> target,
-      boolean isFirstResource) {
+  public boolean onLoadFailed(
+      GlideException e, Object model, Target<PictureDrawable> target, boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
     view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
     return false;
   }
 
   @Override
-  public boolean onResourceReady(PictureDrawable resource, Object model,
-      Target<PictureDrawable> target, DataSource dataSource, boolean isFirstResource) {
+  public boolean onResourceReady(
+      PictureDrawable resource,
+      Object model,
+      Target<PictureDrawable> target,
+      DataSource dataSource,
+      boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
     view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
     return false;
diff --git a/samples/svg/src/main/res/layout/activity_main.xml b/samples/svg/src/main/res/layout/activity_main.xml
index 704faa1f9..bff58690a 100644
--- a/samples/svg/src/main/res/layout/activity_main.xml
+++ b/samples/svg/src/main/res/layout/activity_main.xml
@@ -16,7 +16,7 @@
         android:onClick="clearCache"
         android:clickable="true"
         android:text="@string/hello_world"
-        />
+        android:focusable="true"/>
 
     <Button
         android:id="@+id/button"
diff --git a/scripts/android-wait-for-emulator.sh b/scripts/android-wait-for-emulator.sh
new file mode 100755
index 000000000..aa6345d8b
--- /dev/null
+++ b/scripts/android-wait-for-emulator.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+# Originally written by Ralf Kistner <ralf@embarkmobile.com>, but placed in the public domain
+
+set +e
+
+bootanim=""
+failcounter=0
+timeout_in_sec=360
+
+until [[ "$bootanim" =~ "stopped" ]]; do
+  bootanim=`adb -e shell getprop init.svc.bootanim 2>&1 &`
+  if [[ "$bootanim" =~ "device not found" || "$bootanim" =~ "device offline"
+    || "$bootanim" =~ "running" ]]; then
+    let "failcounter += 1"
+    echo "Waiting for emulator to start"
+    if [[ $failcounter -gt timeout_in_sec ]]; then
+      echo "Timeout ($timeout_in_sec seconds) reached; failed to start emulator"
+      exit 1
+    fi
+  fi
+  sleep 1
+done
+
+echo "Emulator is ready"
diff --git a/scripts/install_firebase.sh b/scripts/install_firebase.sh
new file mode 100755
index 000000000..594d16e87
--- /dev/null
+++ b/scripts/install_firebase.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+set -e
+
+openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d
+
+wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+echo "y" | ./google-cloud-sdk/bin/gcloud components update beta
+./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json
diff --git a/scripts/regenerate_resources.sh b/scripts/regenerate_resources.sh
new file mode 100755
index 000000000..4536c8da9
--- /dev/null
+++ b/scripts/regenerate_resources.sh
@@ -0,0 +1,76 @@
+#!/usr/bin/env bash
+#
+# Generates or regenerates canonical resources for Glide's emulator tests with the cooperation
+# of the BitmapRegressionTester class.
+#
+# Usage:
+# ./scripts/regenerate_resources.sh <com.bumptech.glide.instrumentation.class_name>
+#
+# The class name is optional. If not specified all tests will be run (including those that
+# do not generate resources).
+
+# The signal file that tells BitmapRegressionTester to generate the resource files.
+REGENERATE_FILE_NAME="regenerate"
+# The name of the subfolder on the sdcard where resources are stored on the device/emulator.
+DIRECTORY_NAME="test_files"
+# The full path to a place where the app is able to write resources and we're able to read them.
+DIRECTORY="/sdcard/DCIM/${DIRECTORY_NAME}"
+
+set -e
+
+if [ "$#" -eq 1 ]; then
+  test_restriction="-Pandroid.testInstrumentationRunnerArguments.class=${1}"
+fi
+
+exec 3>&1
+exec 4>&2
+if !(($VERBOSE)); then
+  exec 1>/dev/null
+  exec 2>/dev/null
+fi
+
+echo "Setting up environment..."  1>&3 2>&4
+adb devices | grep -v "List of devices" | grep device \
+  || echo "No devices found, try starting an emulator" 1>&3 2>&4
+
+adb root || true 
+# In case there are any old artifacts from an old or failed test, clean them up.
+adb shell rm -r $DIRECTORY || true
+# Create the signal file.
+# On some emulators touch fails if the directory isn't created first.
+adb shell mkdir /sdcard/DCIM || true
+adb shell mkdir $DIRECTORY || true
+# This actually has to work, previous steps may fail if the directories already exist.
+adb shell touch "${DIRECTORY}/${REGENERATE_FILE_NAME}"
+
+# On APIs > 22 we need to grant the appropriate runtime permissions so our test APK can write
+# resource files to the public sdcard. Cache and internal cache directories aren't consistently
+# available across all versions of Android. So far this is the best cross SDK solution I've 
+# found
+sdk_version=`adb shell getprop ro.build.version.sdk`
+sdk_version=`echo $sdk_version | tr -d '\r'`
+if [[ $sdk_version -gt 22 ]]; then
+  echo "Installing apks and granting runtime permissions..." 1>&3 2>&4
+  ./gradlew :instrumentation:installDebug :instrumentation:installDebugAndroidTest 
+  adb shell pm grant com.bumptech.glide.instrumentation android.permission.WRITE_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation android.permission.READ_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation.test android.permission.WRITE_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation.test android.permission.READ_EXTERNAL_STORAGE
+fi
+
+echo "Generating updated resource files..." 1>&3 2>&4
+./gradlew :instrumentation:connectedDebugAndroidTest $test_restriction --parallel || true 
+
+echo "Copying updated resource files to res directory..." 1>&3 2>&4
+adb pull $DIRECTORY
+rm "${DIRECTORY_NAME}/${REGENERATE_FILE_NAME}" 
+cp $DIRECTORY_NAME/raw/* instrumentation/src/main/res/raw 
+rm -rf $DIRECTORY_NAME
+adb shell rm -r $DIRECTORY
+ 
+echo "Verifying all tests pass..." 1>&3 2>&4
+
+./gradlew :instrumentation:clean
+./gradlew :instrumentation:connectedDebugAndroidTest $test_restriction --parallel
+
+echo "Complete!" 1>&3 2>&4
diff --git a/scripts/release_checks.sh b/scripts/release_checks.sh
new file mode 100755
index 000000000..e25412f51
--- /dev/null
+++ b/scripts/release_checks.sh
@@ -0,0 +1,87 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$#" -ne 1 ]; then
+  echo "Usage: ./release_checks.sh <major.minor.patch[-SNAPSHOT]>"
+  exit 1
+fi
+
+if [[ $(git status -uno --porcelain) ]]; then
+  echo "One or more changes, commit or revert first."
+  git status -uno --porcelain
+  exit 1
+fi
+if [[ $(git rev-list master...bump/master --count) -ne 0 ]]; then
+  echo "Bump and master are not up to date"
+  git rev-list master...bump/master --pretty
+  exit 1
+fi
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; then
+  echo "Origin and master are not up to date"
+  git rev-list master...origin/master --pretty
+  exit 1
+fi
+if [[ $(git ls-files --exclude-standard --others) ]]; then
+  echo "Untracked files, aborting"
+  exit 1
+fi
+
+version=$1
+echo "Setting version to $version"
+echo -n "Is this a correct? (y/n)? "
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Updating gradle.properties..."
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+sed -i '' "s/VERSION_NAME=.*/VERSION_NAME=${version}/g" gradle.properties
+sed -i '' "s/VERSION_MAJOR=.*/VERSION_MAJOR=$(echo $version | cut -d '.' -f 1)/" gradle.properties
+sed -i '' "s/VERSION_MINOR=.*/VERSION_MINOR=$(echo $version | cut -d '.' -f 2)/" gradle.properties
+sed -i '' "s/VERSION_PATCH=.*/VERSION_PATCH=$(echo $version | cut -d '.' -f 3 | sed 's/-.*//')/" gradle.properties
+
+git diff
+
+echo "Updated gradle.properties, is this correct? (y/n)?"
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Committing..."
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+version_tag="v${version}"
+git add gradle.properties
+git commit -m "Bump version to ${version}"
+if [[ $version != *"SNAPSHOT"* ]]; then
+  echo "Found release version, adding tag, building and uploading"
+  git tag $version_tag
+
+  echo "Building... and uploading"
+  ./gradlew clean build --parallel
+  ./gradlew uploadArchives 
+
+  echo "Upload complete, please verify the output and upload the jars to the GitHub release."
+fi
+
+echo -n "Ready to push, continue? (y/n)? "
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Pushing commits"
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+git push origin master
+git push bump master
+if [[ $version != *"SNAPSHOT"* ]]; then
+  echo "Found release version, pushing tags"
+  git push origin $version_tag
+  git push bump $version_tag
+fi
+
diff --git a/scripts/run_instrumentation_tests.sh b/scripts/run_instrumentation_tests.sh
new file mode 100755
index 000000000..412690a8a
--- /dev/null
+++ b/scripts/run_instrumentation_tests.sh
@@ -0,0 +1,20 @@
+#!/usr/bin/env bash
+# Runs instrumentation tests on firebase. Must be run locally, not on travis.
+#
+# Usage: 
+# ./scripts/run_instrumentation_test.sh
+
+./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel
+
+apk_dir=instrumentation/build/outputs/apk
+gcloud firebase test android run \
+  --type instrumentation \
+  --app $apk_dir/instrumentation-debug.apk \
+  --test $apk_dir/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+  --device model=Nexus6P,version=25,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=23,locale=en,orientation=portrait \
+  --device model=Nexus6,version=22,locale=en,orientation=portrait \
+  --device model=Nexus5,version=19,locale=en,orientation=portrait \
+  --project android-glide \
+  --no-auto-google-login \
diff --git a/scripts/run_sample_robo_tests.sh b/scripts/run_sample_robo_tests.sh
new file mode 100755
index 000000000..d7c9cc23d
--- /dev/null
+++ b/scripts/run_sample_robo_tests.sh
@@ -0,0 +1,44 @@
+#!/usr/bin/env bash
+# Runs Firebases' robo tests (monkeyrunner) on Glide's sample apps
+#
+# Usage: 
+# ./scripts/run_sample_robo_tests.sh
+
+set -e
+
+./gradlew :samples:flickr:build \
+  :samples:giphy:build \
+  :samples:contacturi:build \
+  :samples:gallery:build \
+  :samples:imgur:build \
+  :samples:svg:build \
+  --parallel
+
+declare -a samples=("flickr" 
+                "giphy" 
+                "contacturi"
+                "gallery"
+                "imgur"
+                "svg")
+pids=()
+
+for sample in "${samples[@]}"
+do
+  sample_dir="samples/${sample}/build/outputs/apk/"
+  sample_apk="${sample_dir}/${sample}-debug.apk"
+  gcloud firebase test android run \
+    --type robo \
+    --app $sample_apk \
+    --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+    --project android-glide \
+    --no-auto-google-login &
+  pids+=("$!")
+done
+
+for current in "${pids[@]}"
+do
+  wait $current
+done
+       
+
+
diff --git a/scripts/split_by_sdk.sh b/scripts/split_by_sdk.sh
new file mode 100755
index 000000000..8e700ba8a
--- /dev/null
+++ b/scripts/split_by_sdk.sh
@@ -0,0 +1,169 @@
+#!/usr/bin/env bash
+#
+# Loops through all Android API levels that Glide supports (and that 
+# functioning emulators exist for) and runs a particular emulator test file
+# to generate canonical assets. If assets start to fail on a particular sdk
+# level, the test file is updated with the new API level to split on and 
+# assets for that particular api level are added to the test resources 
+# directory.
+#
+# Usage:
+#   ./scripts/split_by_sdk.sh [--abis x86,armeabi-v7a] [--apis 16,17] \
+#      [-v/--verbose] [--tests com.bumptech.glide.TestName1,com.bumptech.glide.TestName2]
+#
+# apis: The Android SDK version(s) you want to run against.
+# abis: The Android CPU types you want to run against
+# v/verbose: Enable verbose logging.
+
+POSITIONAL=()
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    --tests)
+    test_classes_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --apis)
+    apis_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --abis)
+    abis_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -v|--verbose)
+    verbose="1"
+    shift # past argument
+    ;;
+    *)    # unknown option
+    POSITIONAL+=("$1") # save it in an array for later
+    shift # past argument
+    ;;
+esac
+done
+set -- "${POSITIONAL[@]}" # restore positional parameters
+
+if [ -z "$test_classes_string" ]; then
+  test_classes_string=`grep -rwl instrumentation/src/androidTest -e RegressionTest \
+    | grep -v "/test/" \
+    | grep -v ".bak" \
+    | tr '\n' ',' \
+    | sed 's/instrumentation\/src\/androidTest\/java\///g' \
+    | sed 's/\//\./g' \
+    | sed 's/\.java//g' \
+    | sed 's/,*$//g'` 
+fi
+
+if [ -z "$apis_string" ]; then
+  declare -a apis=(
+                  "16" 
+                  #"17" API 17 emulator seems to have trouble starting and I haven't yet found a case where behaviors changed at that API level.
+                  "18"
+                  "19"
+                  # "20" Android Wear, missing x86 emulators.
+                  "21"
+                  "22"
+                  "23"
+                  "24"
+                  "25"
+                  "26")
+else 
+  IFS=',' read -ra apis <<< "$apis_string"
+fi
+
+if [ -z "$abis_string" ]; then
+  declare -a abis=(
+  "x86"
+  "armeabi-v7a"
+  )
+else 
+  IFS=',' read -ra abis <<< "$abis_string"
+fi
+
+IFS=',' read -ra test_classes <<< "$test_classes_string"
+for test_class in "${test_classes[@]}"
+do
+  test_path=`echo $test_class | sed 's/\./\//g' | sed -e 's/^/instrumentation\/src\/androidTest\/java\//' | sed -e 's/$/\.java/'`
+  if [ ! -f "${test_path}" ]; then
+    echo "Missing test $test_class at expected path: $test_path"
+    exit 1
+  fi
+done
+
+if (($verbose)); then
+  printf "tests: "
+  printf '%s,' "${test_classes[@]}"
+  printf "\nabis:"
+  printf '%s,' "${abis[@]}"
+  printf "\napis:"
+  printf '%s,' "${apis[@]}"
+  printf "\n"
+fi
+
+adb devices | grep -v "List of devices" | grep device > /dev/null 2>&1 \
+  && \
+  { \
+    echo "Emulators are already running, kill them before running this script: "; \
+    echo "e.g.: adb -s emulator-5554 emu kill"; \
+    adb devices; \
+    exit 1; \
+  }
+
+exec 3>&1
+exec 4>&2
+if !(($verbose)); then
+  exec 1>/dev/null
+  exec 2>/dev/null
+fi
+
+for abi in "${abis[@]}"
+do
+  if [ "${abi}" == "armeabi-v7a" ]; then
+    emulator_type="default"
+    emulator_script=$ANDROID_HOME/emulator/emulator
+  else 
+    emulator_type="google_apis"
+    emulator_script=$ANDROID_HOME/tools/emulator
+  fi
+
+  for api in "${apis[@]}"
+  do
+    if [ "${abi}" == "armeabi-v7a" ] && [ "${api}" -gt 22 ]; then
+      echo "armeabi-v7a emulators beyond API 22 are unreliable, ignoring ${api}"
+      continue
+    fi
+
+    echo "Checking on API ${api} and ${abi}" 1>&3 2>&4
+    target="system-images;android-${api};${emulator_type};${abi}"
+    sdkmanager --install $target
+    avdmanager create avd --force -n test -k $target --device "Nexus 5X" -c 2000M 
+    QEMU_AUDIO_DRV=none $emulator_script -avd test -no-window &
+    pid=$!
+    ./scripts/android-wait-for-emulator.sh
+    for test_class in "${test_classes[@]}"
+    do
+      test_path=`echo $test_class | sed 's/\./\//g' | sed -e 's/^/instrumentation\/src\/androidTest\/java\//' | sed -e 's/$/\.java/'`
+      ./gradlew :instrumentation:connectedCheck \
+        -Pandroid.testInstrumentationRunnerArguments.class=$test_class
+      if [ $? -ne 0 ]; then
+        echo "Tests for API ${api} failed, updating SplitBySdk and generating resources..." 1>&3 2>&4
+        if [ -z $(grep "@SplitBySdk" $test_path | grep "${api}") ]; then
+          sed -i.bak s/@SplitBySdk\(\{/@SplitBySdk\(\{$api,/ $test_path
+          rm "${test_path}.bak"
+        fi
+        ./scripts/regenerate_resources.sh $test_class #|| { echo "Tests still fail with new resources, aborting";  exit 1; }
+      fi
+    done
+    adb -s emulator-5554 emu kill
+    sleep 1
+    kill -9 $pid
+    pkill emulator64-crash-service
+    pkill emulator-crash-service
+    echo "Finished API ${api}" 1>&3 2>&4
+  done
+done
diff --git a/scripts/travis_after_success.sh b/scripts/travis_after_success.sh
index b7bc17471..d9c2a3042 100755
--- a/scripts/travis_after_success.sh
+++ b/scripts/travis_after_success.sh
@@ -4,5 +4,4 @@ set -e
 
 if [ "$COMPONENT" == "unit" ]; then
   ./scripts/travis_sonatype_publish.sh
-  ./gradlew jacocoTestReport coveralls
 fi
diff --git a/scripts/travis_before_script.sh b/scripts/travis_before_script.sh
index 14048c2d7..e45e901af 100755
--- a/scripts/travis_before_script.sh
+++ b/scripts/travis_before_script.sh
@@ -1,10 +1,7 @@
 #!/usr/bin/env bash
+# Copies our debug.keystore file to its expected location to avoid a bug
+# where the Android build system seems to occasionally fail to generate it.
 
 set -e
 
-if [ "$COMPONENT" == "instrumentation" ]; then
-  echo "Starting emulator for $COMPONENT tests"
-  ./scripts/travis_create_emulator.sh &
-
-fi
-
+cp debug.keystore ~/.android/debug.keystore
diff --git a/scripts/travis_create_emulator.sh b/scripts/travis_create_emulator.sh
index fd39b3264..997ffcdcc 100755
--- a/scripts/travis_create_emulator.sh
+++ b/scripts/travis_create_emulator.sh
@@ -2,9 +2,10 @@
 
 set -e
 
-echo y | android --silent update sdk --no-ui --all --filter android-$ANDROID_TARGET
-echo y | android --silent update sdk --no-ui --all --filter sys-img-armeabi-v7a-android-$ANDROID_TARGET
-echo no | android create avd --force -n test -t android-$ANDROID_TARGET --abi armeabi-v7a
-QEMU_AUDIO_DRV=none emulator -engine classic -avd test -no-window &
+target="system-images;android-${ANDROID_TARGET};default;armeabi-v7a"
+echo y | sdkmanager --update
+echo y | sdkmanager --install $target
+avdmanager create avd --force -n test -k $target --device "Nexus 4" -c 2048M
+QEMU_AUDIO_DRV=none $ANDROID_HOME/emulator/emulator -avd test -no-window -memory 2048 &
 
 exit 0
diff --git a/scripts/travis_firebase.sh b/scripts/travis_firebase.sh
index 1f38666a7..e405462a5 100755
--- a/scripts/travis_firebase.sh
+++ b/scripts/travis_firebase.sh
@@ -2,23 +2,31 @@
 
 set -e
 
-./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel &
-pid=$!
-
-openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d
-
-wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
-tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
-echo "y" | ./google-cloud-sdk/bin/gcloud components update beta
-./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json
+if [ ! "$firebase_enabled" == "true" ]; then
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+fi
 
+./gradlew :instrumentation:assembleDebug \
+  :instrumentation:assembleDebugAndroidTest \
+  --parallel \
+  -PDISABLE_ERROR_PRONE &
+pid=$!
+./scripts/install_firebase.sh
 wait $pid
 
 apk_dir=instrumentation/build/outputs/apk
 ./google-cloud-sdk/bin/gcloud firebase test android run \
   --type instrumentation \
-  --app $apk_dir/instrumentation-debug.apk \
-  --test $apk_dir/instrumentation-debug-androidTest.apk \
-  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+  --app $apk_dir/debug/instrumentation-debug.apk \
+  --test $apk_dir/androidTest/debug/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=27,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=25,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=24,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=23,locale=en,orientation=portrait \
+  --device model=Nexus6,version=22,locale=en,orientation=portrait \
+  --device model=Nexus5,version=21,locale=en,orientation=portrait \
+  --device model=Nexus5,version=19,locale=en,orientation=portrait \
   --project android-glide \
   --no-auto-google-login \
diff --git a/scripts/travis_instrumentation.sh b/scripts/travis_instrumentation.sh
index 929dde0cd..d365034bf 100755
--- a/scripts/travis_instrumentation.sh
+++ b/scripts/travis_instrumentation.sh
@@ -2,10 +2,16 @@
 
 set -e
 
-./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel
+echo "Starting emulator for $COMPONENT tests"
+./scripts/travis_create_emulator.sh &
+
+./gradlew :instrumentation:assembleDebug \
+  :instrumentation:assembleDebugAndroidTest \
+  --parallel \
+  -PDISABLE_ERROR_PRONE
 
 echo "Waiting for emulator..."
 android-wait-for-emulator
 
-./gradlew :instrumentation:connectedDebugAndroidTest
+for i in {1..3}; do ./gradlew :instrumentation:connectedDebugAndroidTest && break; done
 
diff --git a/scripts/travis_samples.sh b/scripts/travis_samples.sh
index 4ab3f1451..45fe59827 100755
--- a/scripts/travis_samples.sh
+++ b/scripts/travis_samples.sh
@@ -8,4 +8,46 @@ set -e
   :samples:gallery:build \
   :samples:imgur:build \
   :samples:svg:build \
-  --parallel
+  --parallel \
+  -PERROR_PRONE="false" &
+pid=$!
+
+if [ ! "$firebase_enabled" == "true" ]; then
+  wait $pid
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+else
+  ./scripts/install_firebase.sh
+  wait $pid
+fi
+
+
+declare -a samples=("flickr"
+                "giphy"
+                "contacturi"
+                "gallery"
+                "imgur"
+                "svg")
+pids=()
+
+for sample in "${samples[@]}"
+do
+  sample_dir="samples/${sample}/build/outputs/apk/debug"
+  sample_apk="${sample_dir}/${sample}-debug.apk"
+  ./google-cloud-sdk/bin/gcloud firebase test android run \
+    --type robo \
+    --app $sample_apk \
+    --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+    --project android-glide \
+    --no-auto-google-login \
+    --timeout 5m \
+    &
+  pids+=("$!")
+done
+
+for current in "${pids[@]}"
+do
+  wait $current
+done
+
+
diff --git a/scripts/travis_script.sh b/scripts/travis_script.sh
index 7c810b219..ab103e875 100755
--- a/scripts/travis_script.sh
+++ b/scripts/travis_script.sh
@@ -2,6 +2,13 @@
 
 set -e
 
+if [ -z ${encrypted_ad2664a1c4dd_key+x} ] || [ -z ${encrypted_ad2664a1c4dd_iv+x} ] || [ -z ${GCLOUD_FILE} ]; then
+  export firebase_enabled="false"
+else
+  export firebase_enabled="true"
+fi
+
+
 if [ "$COMPONENT" == "unit" ]; then
   ./scripts/travis_unit.sh
 elif [ "$COMPONENT" == "instrumentation" ]; then
diff --git a/scripts/travis_unit.sh b/scripts/travis_unit.sh
index bc2f576d3..4bc16323b 100755
--- a/scripts/travis_unit.sh
+++ b/scripts/travis_unit.sh
@@ -9,4 +9,5 @@ set -e
   -x :samples:gallery:build \
   -x :samples:imgur:build \
   -x :samples:svg:build \
-  -x testReleaseUnitTest --parallel
+  --parallel
+./gradlew :instrumentation:assembleAndroidTest
diff --git a/scripts/update_javadocs.sh b/scripts/update_javadocs.sh
index a8646613b..95238183c 100755
--- a/scripts/update_javadocs.sh
+++ b/scripts/update_javadocs.sh
@@ -1,54 +1,61 @@
 #!/bin/bash
+#
+# Usage: ./scripts/update_javadocs.sh
+#
+# The version name is pulled automatically from gradle.properties.
 set -e
 set -o pipefail
 
 TEMP_DIR="/tmp/tmp_glide_javadoc"
 JAVADOC_GH_PAGES_DIR="javadocs"
 
-if [[ -z "$1" ]]; 
-then
-  echo "You must supply a target version"
-  echo "Usage ./scripts/update_javadocs.sh <400>"
-  exit 1
-fi
+major_version=$(fgrep VERSION_MAJOR gradle.properties | cut -d '=' -f 2)
+minor_version=$(fgrep VERSION_MINOR gradle.properties | cut -d '=' -f 2)
+version="${major_version}${minor_version}0"
+
+echo "Updating javadocs for ${version}"
 
 if [[ $(git status -uno --porcelain) ]];
-then 
+then
   echo "One or more changes, commit or revert first."
   git status -uno --porcelain
   exit 1
 fi
 
 if [ -e "$JAVADOC_GH_PAGES_DIR" ];
-then 
+then
   echo "javadocs directory exists locally, remove first."
   exit 1
 fi
 
-if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; 
-then 
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]];
+then
   echo "Origin and master are not up to date"
   git rev-list master...origin/master --pretty
   exit 1
 fi
-if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]]; 
-then 
+if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]];
+then
   echo "Origin and gh-pages are not up to date"
   git rev-list gh-pages...origin/gh-pages --pretty
   exit 1
 fi
 
 git checkout master
-GIT_COMMIT_SHA="$(git rev-parse HEAD)"   
-./gradlew clean releaseJavadocJar javadoc
+GIT_COMMIT_SHA="$(git rev-parse HEAD)"
+./gradlew clean debugJavadocJar javadoc
 rm -rf $TEMP_DIR
 cp -r glide/build/docs/javadoc $TEMP_DIR
+
+# Add the favicon to the javadocs pages.
+find $TEMP_DIR -name '*.html' -exec sed -i '' -e 's#<head>#<head><link rel="apple-touch-icon" sizes="180x180" href="/glide/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/glide/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/glide/favicon-16x16.png"><link rel="manifest" href="/glide/manifest.json">#' {} \;
+
 git checkout gh-pages
-rm -rf "${JAVADOC_GH_PAGES_DIR}/${1}"
-cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$1
+rm -rf "${JAVADOC_GH_PAGES_DIR}/${version}"
+cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$version
 rm -rf $TEMP_DIR
-git add "${JAVADOC_GH_PAGES_DIR}/$1" 
-git commit -m "Update javadocs for version $1" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
-echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${1} and committed"
+git add "${JAVADOC_GH_PAGES_DIR}/$version"
+git commit -m "Update javadocs for version $version" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
+echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${version} and committed"
 git log -1 --pretty=%B
 echo "Ready to push"
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index c690a364a..57ce5dbb2 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -15,10 +15,12 @@
  *
  *
  * Based on: https://github.com/mcxiaoke/gradle-mvn-push/blob/master/gradle-mvn-push.gradle.
- * Local test with (..._REPOSITORY_URL properties must be full paths):
- * gradlew clean buildArchives uploadArchives --stacktrace --info -PSNAPSHOT_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-snapshot -PRELEASE_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-release
- * For faster runs add: -x check
- * 
+ *
+ * To install in a local maven repo:
+ * 1. In the project you want to test (not Glide), add mavenLocal() to the repositories list.
+ * 2. In Glide, run: ./gradlew uploadArchives -PLOCAL
+ *
+ * For faster runs add: -x check when building Glide.
  */
 
 apply plugin: 'maven'
@@ -27,17 +29,24 @@ apply plugin: 'signing'
 version = VERSION_NAME
 group = GROUP
 
+static def localMavenRepo() {
+    'file://' + new File(System.getProperty('user.home'), '.m2/repository').absolutePath
+}
+
+@SuppressWarnings("GrMethodMayBeStatic")
 def isReleaseBuild() {
-    return VERSION_NAME.contains("SNAPSHOT") == false
+    return !VERSION_NAME.contains("SNAPSHOT")
 }
 
 def getReleaseRepositoryUrl() {
-    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+    return hasProperty('LOCAL') ? localMavenRepo()
+            : hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
             : 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
 }
 
 def getSnapshotRepositoryUrl() {
-    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+    return hasProperty('LOCAL') ? localMavenRepo()
+            : hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
             : 'https://oss.sonatype.org/content/repositories/snapshots/'
 }
 
@@ -50,6 +59,7 @@ def getRepositoryPassword() {
 }
 
 afterEvaluate { project ->
+    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
     // To avoid uploading the default empty jar artifact in the project root directory, we use a custom
     // configuration to specify which artifacts we want to upload.
     uploadArchives {
@@ -73,9 +83,40 @@ afterEvaluate { project ->
                     authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
                 }
 
+                pom.whenConfigured { pom ->
+                    pom.packaging = POM_PACKAGING
+                }
+
+                // Dependencies are only automatically included by the release plugin if the release
+                // variant is built. Since we've disabled the release variant to improve build
+                // times, we need to add the dependencies to the pom file explicitly.
+                if (isAndroidProject) {
+                    pom.withXml {
+                        def dependenciesNode = asNode().appendNode('dependencies')
+
+                        project.configurations.implementation.allDependencies.each {
+                            def groupId = it.group
+                            def artifactId = it.name
+                            // If we specify an artifact id that differs from the project name, it won't
+                            // match. To avoid that, we look up the artifact id (and group) by property
+                            // for any project dependencies.
+                            // TODO: there must be a neater way to do this.
+                            if (it instanceof ProjectDependency) {
+                                def properties = it.getDependencyProject().getProperties()
+                                groupId = properties.get("GROUP")
+                                artifactId = properties.get("POM_ARTIFACT_ID")
+                            }
+                            def dependencyNode = dependenciesNode.appendNode('dependency')
+                            dependencyNode.appendNode('groupId', groupId)
+                            dependencyNode.appendNode('artifactId', artifactId)
+                            dependencyNode.appendNode('version', it.version)
+                            dependencyNode.appendNode('scope', 'compile')
+                        }
+                    }
+                }
+
                 pom.project {
                     name = POM_NAME
-                    packaging = POM_PACKAGING
                     description = POM_DESCRIPTION
                     url = POM_URL
 
@@ -115,32 +156,31 @@ afterEvaluate { project ->
         sign configurations.archives
     }
 
-    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
 
     if (isAndroidProject) {
-        def releaseVariants = project.android.libraryVariants.findAll {
-            it.buildType.name.equalsIgnoreCase('release')
+        def variants = project.android.libraryVariants.findAll {
+            it.buildType.name.equalsIgnoreCase('debug')
         }
 
         def getAndroidSdkDirectory = project.android.sdkDirectory
 
         def getAndroidJar = "${getAndroidSdkDirectory}/platforms/${project.android.compileSdkVersion}/android.jar"
 
-        task androidJavadocs(type: Javadoc, dependsOn: assembleRelease) {
-            source = releaseVariants.collect { it.javaCompile.source }
+        task androidJavadocs(type: Javadoc, dependsOn: assembleDebug) {
+            source = variants.collect { it.getJavaCompileProvider().get().source }
             classpath = files(
                     getAndroidJar,
-                    releaseVariants.collect { it.javaCompile.classpath.files },
-                    project.file("build/intermediates/classes/release")
+                    project.file("build/intermediates/classes/debug")
             )
-
+            doFirst {
+                classpath += files(variants.collect { it.javaCompile.classpath.files })
+            }
             options {
                 links("http://docs.oracle.com/javase/7/docs/api/")
                 linksOffline("http://d.android.com/reference",
                         "${getAndroidSdkDirectory}/docs/reference")
             }
 
-            exclude '**/BuildConfig.java'
             exclude '**/R.java'
         }
 
@@ -161,10 +201,9 @@ afterEvaluate { project ->
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
-        task androidLibraryJar(type: Jar, dependsOn: compileReleaseJavaWithJavac /* == variant.javaCompile */) {
-            from compileReleaseJavaWithJavac.destinationDir
+        task androidLibraryJar(type: Jar, dependsOn: compileDebugJavaWithJavac /* == variant.javaCompile */) {
+            from compileDebugJavaWithJavac.destinationDir
             exclude '**/R.class'
-            exclude '**/BuildConfig.class'
             exclude '**/R$*.class'
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
@@ -173,6 +212,11 @@ afterEvaluate { project ->
             archives androidLibraryJar
             archives androidSourcesJar
             archives androidJavadocsJar
+            // This is unnecessary with a release variant because by default the release variant
+            // includes the release aar in archives. Since we've disabled our release variants and
+            // want to include an aar, we need to manually specify the task that produces the aar
+            // here.
+            archives project.tasks.bundleDebugAar
         }
     } else if (project.plugins.hasPlugin('java')) {
         task sourcesJar(type: Jar, dependsOn: classes) {
@@ -191,5 +235,5 @@ afterEvaluate { project ->
         }
     }
     logger.info("Published artifacts in ${configurations.archives}:")
-    configurations.archives.artifacts.files.files.each { logger.info("\t$it"); }
+    configurations.archives.artifacts.files.files.each { logger.info("\t$it") }
 }
diff --git a/settings.gradle b/settings.gradle
index 7ba0b29f7..360b59b47 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,10 +1,15 @@
 exec {
     commandLine "git", "submodule", "update", "--init", "--recursive"
+    ignoreExitValue true
 }
 include ':library'
+include ':library:pmd'
+include ':library:findbugs'
+include ':library:test'
 include ':instrumentation'
 include ':annotation'
 include ':annotation:compiler'
+include ':annotation:compiler:test'
 include ':glide'
 include ':third_party:gif_decoder'
 include ':third_party:disklrucache'
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
index 54f7cbaf9..2f50bad44 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
@@ -2,9 +2,7 @@
 
 import java.io.InputStream;
 
-/**
- * Test only utility for opening resources in androidTest/resources.
- */
+/** Test only utility for opening resources in androidTest/resources. */
 public final class TestResourceUtil {
   private TestResourceUtil() {
     // Utility class
@@ -14,8 +12,8 @@ private TestResourceUtil() {
    * Returns an InputStream for the given test class and sub-path.
    *
    * @param testClass A Junit test class.
-   * @param subPath   The sub-path under androidTest/resources where the desired resource is
-   *                  located. Should not be prefixed with a '/'
+   * @param subPath The sub-path under androidTest/resources where the desired resource is located.
+   *     Should not be prefixed with a '/'
    */
   public static InputStream openResource(Class<?> testClass, String subPath) {
     return testClass.getResourceAsStream("/" + subPath);
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
index 9c93de9e5..e34237aa4 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -6,9 +6,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * Shared utility classes for tests.
- */
+/** Shared utility classes for tests. */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class TestUtil {
   private TestUtil() {
     // Utility class.
diff --git a/third_party/disklrucache b/third_party/disklrucache
deleted file mode 160000
index 273f119c6..000000000
--- a/third_party/disklrucache
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 273f119c607eb55da0627ebb4a0c1b0d1a15b2dc
diff --git a/third_party/disklrucache/.gitignore b/third_party/disklrucache/.gitignore
new file mode 100644
index 000000000..5bbf7d56f
--- /dev/null
+++ b/third_party/disklrucache/.gitignore
@@ -0,0 +1,23 @@
+#Eclipse
+.project
+.classpath
+.settings
+.checkstyle
+
+#IntelliJ IDEA
+.idea
+*.iml
+*.ipr
+*.iws
+
+#Maven
+target
+release.properties
+pom.xml.*
+
+#OSX
+.DS_Store
+
+#gradle
+build/**
+.gradle/**
diff --git a/third_party/disklrucache/CHANGELOG.md b/third_party/disklrucache/CHANGELOG.md
new file mode 100644
index 000000000..50a43e8c1
--- /dev/null
+++ b/third_party/disklrucache/CHANGELOG.md
@@ -0,0 +1,67 @@
+Change Log
+==========
+
+Version 2.0.2 *(2013-06-18)*
+----------------------------
+
+ * Fix: Prevent exception trying to delete a non-existent file.
+
+
+Version 2.0.1 *(2013-04-27)*
+----------------------------
+
+ * Fix: Do not throw runtime exceptions for racy file I/O.
+ * Fix: Synchronize calls to `isClosed`.
+
+
+Version 2.0.0 *(2013-04-13)*
+----------------------------
+
+The package name is now `com.jakewharton.disklrucache`.
+
+ * New: Automatically flush the cache when an edit is completed.
+ * Fix: Ensure file handles are not held when a file is not found.
+ * Fix: Correct journal rebuilds on Windows.
+ * Fix: Ensure file writer uses the appropriate encoding.
+
+
+Version 1.3.1 *(2013-01-02)*
+----------------------------
+
+ * Fix: Correct logic around detecting whether a journal rebuild is required.
+   *(Thanks Jonathan Gerbaud)*
+
+
+Version 1.3.0 *(2012-12-24)*
+----------------------------
+
+ * Re-allow dash in cache key (now `[a-z0-9_-]{1,64}`).
+ * New: `getLength` method on `Snapshot`. *(Thanks Edward Dale)*
+ * Performance improvements reading journal lines.
+
+
+Version 1.2.1 *(2012-10-08)*
+----------------------------
+
+ * Fix: Ensure library references Java 5-compatible version of
+   `Arrays.copyOfRange`. *(Thanks Edward Dale)*
+
+
+Version 1.2.0 *(2012-09-30)*
+----------------------------
+
+ * New API for cache size adjustment.
+ * Keys are now enforced to match `[a-z0-9_]{1,64}` *(Thanks Brian Langel)*
+ * Fix: Cache will gracefully recover if directory is deleted at runtime.
+
+
+Version 1.1.0 *(2012-01-07)*
+----------------------------
+
+ * New API for editing an existing snapshot. *(Thanks Jesse Wilson)*
+
+
+Version 1.0.0 *(2012-01-04)*
+----------------------------
+
+Initial version.
diff --git a/third_party/disklrucache/LICENSE b/third_party/disklrucache/LICENSE
new file mode 100644
index 000000000..add20f0c7
--- /dev/null
+++ b/third_party/disklrucache/LICENSE
@@ -0,0 +1,14 @@
+Copyright 2012 Jake Wharton
+Copyright 2011 The Android Open Source Project
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/third_party/disklrucache/LICENSE.txt b/third_party/disklrucache/LICENSE.txt
new file mode 100644
index 000000000..53b48b6b6
--- /dev/null
+++ b/third_party/disklrucache/LICENSE.txt
@@ -0,0 +1,203 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2012 Jake Wharton
+   Copyright 2011 The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/third_party/disklrucache/README.md b/third_party/disklrucache/README.md
new file mode 100644
index 000000000..5f27ca267
--- /dev/null
+++ b/third_party/disklrucache/README.md
@@ -0,0 +1,63 @@
+Disk LRU Cache
+==============
+
+A cache that uses a bounded amount of space on a filesystem. Each cache entry
+has a string key and a fixed number of values. Each key must match the regex
+`[a-z0-9_-]{1,64}`.  Values are byte sequences, accessible as streams or files.
+Each value must be between `0` and `Integer.MAX_VALUE` bytes in length.
+
+The cache stores its data in a directory on the filesystem. This directory must
+be exclusive to the cache; the cache may delete or overwrite files from its
+directory. It is an error for multiple processes to use the same cache
+directory at the same time.
+
+This cache limits the number of bytes that it will store on the filesystem.
+When the number of stored bytes exceeds the limit, the cache will remove
+entries in the background until the limit is satisfied. The limit is not
+strict: the cache may temporarily exceed it while waiting for files to be
+deleted. The limit does not include filesystem overhead or the cache journal so
+space-sensitive applications should set a conservative limit.
+
+Clients call `edit` to create or update the values of an entry. An entry may
+have only one editor at one time; if a value is not available to be edited then
+`edit` will return null.
+
+ *  When an entry is being **created** it is necessary to supply a full set of
+    values; the empty value should be used as a placeholder if necessary.
+ *  When an entry is being **edited**, it is not necessary to supply data for
+    every value; values default to their previous value.
+
+Every `edit` call must be matched by a call to `Editor.commit` or
+`Editor.abort`. Committing is atomic: a read observes the full set of values as
+they were before or after the commit, but never a mix of values.
+
+Clients call `get` to read a snapshot of an entry. The read will observe the
+value at the time that `get` was called. Updates and removals after the call do
+not impact ongoing reads.
+
+This class is tolerant of some I/O errors. If files are missing from the
+filesystem, the corresponding entries will be dropped from the cache. If an
+error occurs while writing a cache value, the edit will fail silently. Callers
+should handle other problems by catching `IOException` and responding
+appropriately.
+
+*Note: This implementation specifically targets Android compatibility.*
+
+License
+=======
+
+    Copyright 2012 Jake Wharton
+    Copyright 2011 The Android Open Source Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
diff --git a/third_party/disklrucache/README.third_party b/third_party/disklrucache/README.third_party
new file mode 100644
index 000000000..88189ae35
--- /dev/null
+++ b/third_party/disklrucache/README.third_party
@@ -0,0 +1,10 @@
+URL: https://github.com/JakeWharton/DiskLruCache/tarball/7a1ecbd38d2ad0873fb843e911d60235b7434acb
+Version: 7a1ecbd38d2ad0873fb843e911d60235b7434acb
+License: Apache 2.0
+License File: LICENSE
+
+Description:
+Java implementation of a Disk-based LRU cache which specifically targets Android compatibility.
+
+Local Modifications:
+Exposed File objects directly to gets, removed key validation, removed test sources.
diff --git a/third_party/disklrucache/build.gradle b/third_party/disklrucache/build.gradle
new file mode 100644
index 000000000..ed83bde23
--- /dev/null
+++ b/third_party/disklrucache/build.gradle
@@ -0,0 +1,40 @@
+apply plugin: 'com.android.library'
+
+repositories {
+  jcenter()
+}
+
+checkstyle {
+    toolVersion = "6.6"
+}
+
+checkstyle {
+    configFile = new File(projectDir, 'checkstyle.xml')
+}
+
+dependencies {
+    def junitVersion = hasProperty('JUNIT_VERSION') ? JUNIT_VERSION : '4.11';
+    testImplementation "junit:junit:${junitVersion}"
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionName VERSION_NAME as String
+        consumerProguardFiles 'proguard-rules.txt'
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+def uploaderScript = "${rootProject.projectDir}/scripts/upload.gradle"
+if (file(uploaderScript).exists()) {
+	apply from: uploaderScript
+}
diff --git a/third_party/disklrucache/checkstyle.xml b/third_party/disklrucache/checkstyle.xml
new file mode 100644
index 000000000..3f1f67704
--- /dev/null
+++ b/third_party/disklrucache/checkstyle.xml
@@ -0,0 +1,130 @@
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<module name="Checker">
+    <module name="FileLength"/>
+    <module name="FileTabCharacter"/>
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf" />
+    </module>
+
+    <!-- Trailing spaces -->
+    <module name="RegexpSingleline">
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module>
+
+    <!-- Space after 'for' and 'if' -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*(for|if)\b[^ ]"/>
+        <property name="message" value="Space needed before opening parenthesis."/>
+    </module>
+
+    <!-- For each spacing -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+        <property name="message" value="Space needed around ':' character."/>
+    </module>
+
+    <module name="TreeWalker">
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <!--module name="JavadocMethod"/-->
+        <!--module name="JavadocType"/-->
+        <!--module name="JavadocVariable"/-->
+        <module name="JavadocStyle"/>
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <!--<module name="ConstantName"/>-->
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/>
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <module name="AvoidStarImport"/>
+        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport"/>
+        <module name="UnusedImports"/>
+
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <module name="LineLength">
+            <property name="max" value="100"/>
+        </module>
+        <module name="MethodLength"/>
+        <module name="ParameterNumber"/>
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <module name="GenericWhitespace"/>
+        <!--<module name="EmptyForIteratorPad"/>-->
+        <module name="MethodParamPad"/>
+        <!--<module name="NoWhitespaceAfter"/>-->
+        <!--<module name="NoWhitespaceBefore"/>-->
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <module name="TypecastParenPad"/>
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround"/>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <module name="ModifierOrder"/>
+        <module name="RedundantModifier"/>
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <module name="AvoidNestedBlocks"/>
+        <!--module name="EmptyBlock"/-->
+        <module name="LeftCurly"/>
+        <!--<module name="NeedBraces"/>-->
+        <module name="RightCurly"/>
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--module name="AvoidInlineConditionals"/-->
+        <module name="CovariantEquals"/>
+        <module name="EmptyStatement"/>
+        <!--<module name="EqualsAvoidNull"/>-->
+        <module name="EqualsHashCode"/>
+        <!--module name="HiddenField"/-->
+        <module name="IllegalInstantiation"/>
+        <!--module name="InnerAssignment"/-->
+        <!--module name="MagicNumber"/-->
+        <!--module name="MissingSwitchDefault"/-->
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--module name="DesignForExtension"/-->
+        <!--<module name="FinalClass"/>-->
+        <module name="HideUtilityClassConstructor"/>
+        <module name="InterfaceIsType"/>
+        <!--module name="VisibilityModifier"/-->
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <module name="ArrayTypeStyle"/>
+        <!--module name="FinalParameters"/-->
+        <!--module name="TodoComment"/-->
+        <module name="UpperEll"/>
+    </module>
+</module>
diff --git a/third_party/disklrucache/gradle.properties b/third_party/disklrucache/gradle.properties
new file mode 100644
index 000000000..db29a2519
--- /dev/null
+++ b/third_party/disklrucache/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Disk LRU Cache Library
+POM_ARTIFACT_ID=disklrucache
+POM_PACKAGING=jar
+POM_DESCRIPTION=A cache that uses a bounded amount of space on a filesystem. Based on Jake Wharton's tailored for Glide.
diff --git a/third_party/disklrucache/src/main/AndroidManifest.xml b/third_party/disklrucache/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..20eaad4e7
--- /dev/null
+++ b/third_party/disklrucache/src/main/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.disklrucache">
+
+    <application/>
+</manifest>
diff --git a/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/DiskLruCache.java b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/DiskLruCache.java
new file mode 100644
index 000000000..2ca2e8bff
--- /dev/null
+++ b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/DiskLruCache.java
@@ -0,0 +1,942 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import android.annotation.TargetApi;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.StrictMode;
+import java.io.BufferedWriter;
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A cache that uses a bounded amount of space on a filesystem. Each cache
+ * entry has a string key and a fixed number of values. Each key must match
+ * the regex <strong>[a-z0-9_-]{1,120}</strong>. Values are byte sequences,
+ * accessible as streams or files. Each value must be between {@code 0} and
+ * {@code Integer.MAX_VALUE} bytes in length.
+ *
+ * <p>The cache stores its data in a directory on the filesystem. This
+ * directory must be exclusive to the cache; the cache may delete or overwrite
+ * files from its directory. It is an error for multiple processes to use the
+ * same cache directory at the same time.
+ *
+ * <p>This cache limits the number of bytes that it will store on the
+ * filesystem. When the number of stored bytes exceeds the limit, the cache will
+ * remove entries in the background until the limit is satisfied. The limit is
+ * not strict: the cache may temporarily exceed it while waiting for files to be
+ * deleted. The limit does not include filesystem overhead or the cache
+ * journal so space-sensitive applications should set a conservative limit.
+ *
+ * <p>Clients call {@link #edit} to create or update the values of an entry. An
+ * entry may have only one editor at one time; if a value is not available to be
+ * edited then {@link #edit} will return null.
+ * <ul>
+ * <li>When an entry is being <strong>created</strong> it is necessary to
+ * supply a full set of values; the empty value should be used as a
+ * placeholder if necessary.
+ * <li>When an entry is being <strong>edited</strong>, it is not necessary
+ * to supply data for every value; values default to their previous
+ * value.
+ * </ul>
+ * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
+ * or {@link Editor#abort}. Committing is atomic: a read observes the full set
+ * of values as they were before or after the commit, but never a mix of values.
+ *
+ * <p>Clients call {@link #get} to read a snapshot of an entry. The read will
+ * observe the value at the time that {@link #get} was called. Updates and
+ * removals after the call do not impact ongoing reads.
+ *
+ * <p>This class is tolerant of some I/O errors. If files are missing from the
+ * filesystem, the corresponding entries will be dropped from the cache. If
+ * an error occurs while writing a cache value, the edit will fail silently.
+ * Callers should handle other problems by catching {@code IOException} and
+ * responding appropriately.
+ */
+public final class DiskLruCache implements Closeable {
+  static final String JOURNAL_FILE = "journal";
+  static final String JOURNAL_FILE_TEMP = "journal.tmp";
+  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
+  static final String MAGIC = "libcore.io.DiskLruCache";
+  static final String VERSION_1 = "1";
+  static final long ANY_SEQUENCE_NUMBER = -1;
+  private static final String CLEAN = "CLEAN";
+  private static final String DIRTY = "DIRTY";
+  private static final String REMOVE = "REMOVE";
+  private static final String READ = "READ";
+
+    /*
+     * This cache uses a journal file named "journal". A typical journal file
+     * looks like this:
+     *     libcore.io.DiskLruCache
+     *     1
+     *     100
+     *     2
+     *
+     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
+     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
+     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
+     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
+     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
+     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
+     *     READ 335c4c6028171cfddfbaae1a9c313c52
+     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
+     *
+     * The first five lines of the journal form its header. They are the
+     * constant string "libcore.io.DiskLruCache", the disk cache's version,
+     * the application's version, the value count, and a blank line.
+     *
+     * Each of the subsequent lines in the file is a record of the state of a
+     * cache entry. Each line contains space-separated values: a state, a key,
+     * and optional state-specific values.
+     *   o DIRTY lines track that an entry is actively being created or updated.
+     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
+     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
+     *     temporary files may need to be deleted.
+     *   o CLEAN lines track a cache entry that has been successfully published
+     *     and may be read. A publish line is followed by the lengths of each of
+     *     its values.
+     *   o READ lines track accesses for LRU.
+     *   o REMOVE lines track entries that have been deleted.
+     *
+     * The journal file is appended to as cache operations occur. The journal may
+     * occasionally be compacted by dropping redundant lines. A temporary file named
+     * "journal.tmp" will be used during compaction; that file should be deleted if
+     * it exists when the cache is opened.
+     */
+
+  private final File directory;
+  private final File journalFile;
+  private final File journalFileTmp;
+  private final File journalFileBackup;
+  private final int appVersion;
+  private long maxSize;
+  private final int valueCount;
+  private long size = 0;
+  private Writer journalWriter;
+  private final LinkedHashMap<String, Entry> lruEntries =
+      new LinkedHashMap<String, Entry>(0, 0.75f, true);
+  private int redundantOpCount;
+
+  /**
+   * To differentiate between old and current snapshots, each entry is given
+   * a sequence number each time an edit is committed. A snapshot is stale if
+   * its sequence number is not equal to its entry's sequence number.
+   */
+  private long nextSequenceNumber = 0;
+
+  /** This cache uses a single background thread to evict entries. */
+  final ThreadPoolExecutor executorService =
+      new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
+          new DiskLruCacheThreadFactory());
+  private final Callable<Void> cleanupCallable = new Callable<Void>() {
+    public Void call() throws Exception {
+      synchronized (DiskLruCache.this) {
+        if (journalWriter == null) {
+          return null; // Closed.
+        }
+        trimToSize();
+        if (journalRebuildRequired()) {
+          rebuildJournal();
+          redundantOpCount = 0;
+        }
+      }
+      return null;
+    }
+  };
+
+  private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {
+    this.directory = directory;
+    this.appVersion = appVersion;
+    this.journalFile = new File(directory, JOURNAL_FILE);
+    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
+    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
+    this.valueCount = valueCount;
+    this.maxSize = maxSize;
+  }
+
+  /**
+   * Opens the cache in {@code directory}, creating a cache if none exists
+   * there.
+   *
+   * @param directory a writable directory
+   * @param valueCount the number of values per cache entry. Must be positive.
+   * @param maxSize the maximum number of bytes this cache should use to store
+   * @throws IOException if reading or writing the cache directory fails
+   */
+  public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)
+      throws IOException {
+    if (maxSize <= 0) {
+      throw new IllegalArgumentException("maxSize <= 0");
+    }
+    if (valueCount <= 0) {
+      throw new IllegalArgumentException("valueCount <= 0");
+    }
+
+    // If a bkp file exists, use it instead.
+    File backupFile = new File(directory, JOURNAL_FILE_BACKUP);
+    if (backupFile.exists()) {
+      File journalFile = new File(directory, JOURNAL_FILE);
+      // If journal file also exists just delete backup file.
+      if (journalFile.exists()) {
+        backupFile.delete();
+      } else {
+        renameTo(backupFile, journalFile, false);
+      }
+    }
+
+    // Prefer to pick up where we left off.
+    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
+    if (cache.journalFile.exists()) {
+      try {
+        cache.readJournal();
+        cache.processJournal();
+        return cache;
+      } catch (IOException journalIsCorrupt) {
+        System.out
+            .println("DiskLruCache "
+                + directory
+                + " is corrupt: "
+                + journalIsCorrupt.getMessage()
+                + ", removing");
+        cache.delete();
+      }
+    }
+
+    // Create a new empty cache.
+    directory.mkdirs();
+    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
+    cache.rebuildJournal();
+    return cache;
+  }
+
+  private void readJournal() throws IOException {
+    StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);
+    try {
+      String magic = reader.readLine();
+      String version = reader.readLine();
+      String appVersionString = reader.readLine();
+      String valueCountString = reader.readLine();
+      String blank = reader.readLine();
+      if (!MAGIC.equals(magic)
+          || !VERSION_1.equals(version)
+          || !Integer.toString(appVersion).equals(appVersionString)
+          || !Integer.toString(valueCount).equals(valueCountString)
+          || !"".equals(blank)) {
+        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
+            + valueCountString + ", " + blank + "]");
+      }
+
+      int lineCount = 0;
+      while (true) {
+        try {
+          readJournalLine(reader.readLine());
+          lineCount++;
+        } catch (EOFException endOfJournal) {
+          break;
+        }
+      }
+      redundantOpCount = lineCount - lruEntries.size();
+
+      // If we ended on a truncated line, rebuild the journal before appending to it.
+      if (reader.hasUnterminatedLine()) {
+        rebuildJournal();
+      } else {
+        journalWriter = new BufferedWriter(new OutputStreamWriter(
+            new FileOutputStream(journalFile, true), Util.US_ASCII));
+      }
+    } finally {
+      Util.closeQuietly(reader);
+    }
+  }
+
+  private void readJournalLine(String line) throws IOException {
+    int firstSpace = line.indexOf(' ');
+    if (firstSpace == -1) {
+      throw new IOException("unexpected journal line: " + line);
+    }
+
+    int keyBegin = firstSpace + 1;
+    int secondSpace = line.indexOf(' ', keyBegin);
+    final String key;
+    if (secondSpace == -1) {
+      key = line.substring(keyBegin);
+      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
+        lruEntries.remove(key);
+        return;
+      }
+    } else {
+      key = line.substring(keyBegin, secondSpace);
+    }
+
+    Entry entry = lruEntries.get(key);
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    }
+
+    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
+      String[] parts = line.substring(secondSpace + 1).split(" ");
+      entry.readable = true;
+      entry.currentEditor = null;
+      entry.setLengths(parts);
+    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
+      entry.currentEditor = new Editor(entry);
+    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
+      // This work was already done by calling lruEntries.get().
+    } else {
+      throw new IOException("unexpected journal line: " + line);
+    }
+  }
+
+  /**
+   * Computes the initial size and collects garbage as a part of opening the
+   * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+   */
+  private void processJournal() throws IOException {
+    deleteIfExists(journalFileTmp);
+    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
+      Entry entry = i.next();
+      if (entry.currentEditor == null) {
+        for (int t = 0; t < valueCount; t++) {
+          size += entry.lengths[t];
+        }
+      } else {
+        entry.currentEditor = null;
+        for (int t = 0; t < valueCount; t++) {
+          deleteIfExists(entry.getCleanFile(t));
+          deleteIfExists(entry.getDirtyFile(t));
+        }
+        i.remove();
+      }
+    }
+  }
+
+  /**
+   * Creates a new journal that omits redundant information. This replaces the
+   * current journal if it exists.
+   */
+  private synchronized void rebuildJournal() throws IOException {
+    if (journalWriter != null) {
+      closeWriter(journalWriter);
+    }
+
+    Writer writer = new BufferedWriter(
+        new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII));
+    try {
+      writer.write(MAGIC);
+      writer.write("\n");
+      writer.write(VERSION_1);
+      writer.write("\n");
+      writer.write(Integer.toString(appVersion));
+      writer.write("\n");
+      writer.write(Integer.toString(valueCount));
+      writer.write("\n");
+      writer.write("\n");
+
+      for (Entry entry : lruEntries.values()) {
+        if (entry.currentEditor != null) {
+          writer.write(DIRTY + ' ' + entry.key + '\n');
+        } else {
+          writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+        }
+      }
+    } finally {
+      closeWriter(writer);
+    }
+
+    if (journalFile.exists()) {
+      renameTo(journalFile, journalFileBackup, true);
+    }
+    renameTo(journalFileTmp, journalFile, false);
+    journalFileBackup.delete();
+
+    journalWriter = new BufferedWriter(
+        new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));
+  }
+
+  private static void deleteIfExists(File file) throws IOException {
+    if (file.exists() && !file.delete()) {
+      throw new IOException();
+    }
+  }
+
+  private static void renameTo(File from, File to, boolean deleteDestination) throws IOException {
+    if (deleteDestination) {
+      deleteIfExists(to);
+    }
+    if (!from.renameTo(to)) {
+      throw new IOException();
+    }
+  }
+
+  /**
+   * Returns a snapshot of the entry named {@code key}, or null if it doesn't
+   * exist is not currently readable. If a value is returned, it is moved to
+   * the head of the LRU queue.
+   */
+  public synchronized Value get(String key) throws IOException {
+    checkNotClosed();
+    Entry entry = lruEntries.get(key);
+    if (entry == null) {
+      return null;
+    }
+
+    if (!entry.readable) {
+      return null;
+    }
+
+    for (File file : entry.cleanFiles) {
+        // A file must have been deleted manually!
+        if (!file.exists()) {
+            return null;
+        }
+    }
+
+    redundantOpCount++;
+    journalWriter.append(READ);
+    journalWriter.append(' ');
+    journalWriter.append(key);
+    journalWriter.append('\n');
+    if (journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+
+    return new Value(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths);
+  }
+
+  /**
+   * Returns an editor for the entry named {@code key}, or null if another
+   * edit is in progress.
+   */
+  public Editor edit(String key) throws IOException {
+    return edit(key, ANY_SEQUENCE_NUMBER);
+  }
+
+  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+    checkNotClosed();
+    Entry entry = lruEntries.get(key);
+    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
+        || entry.sequenceNumber != expectedSequenceNumber)) {
+      return null; // Value is stale.
+    }
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    } else if (entry.currentEditor != null) {
+      return null; // Another edit is in progress.
+    }
+
+    Editor editor = new Editor(entry);
+    entry.currentEditor = editor;
+
+    // Flush the journal before creating files to prevent file leaks.
+    journalWriter.append(DIRTY);
+    journalWriter.append(' ');
+    journalWriter.append(key);
+    journalWriter.append('\n');
+    flushWriter(journalWriter);
+    return editor;
+  }
+
+  /** Returns the directory where this cache stores its data. */
+  public File getDirectory() {
+    return directory;
+  }
+
+  /**
+   * Returns the maximum number of bytes that this cache should use to store
+   * its data.
+   */
+  public synchronized long getMaxSize() {
+    return maxSize;
+  }
+
+  /**
+   * Changes the maximum number of bytes the cache can store and queues a job
+   * to trim the existing store, if necessary.
+   */
+  public synchronized void setMaxSize(long maxSize) {
+    this.maxSize = maxSize;
+    executorService.submit(cleanupCallable);
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in
+   * this cache. This may be greater than the max size if a background
+   * deletion is pending.
+   */
+  public synchronized long size() {
+    return size;
+  }
+
+  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+    Entry entry = editor.entry;
+    if (entry.currentEditor != editor) {
+      throw new IllegalStateException();
+    }
+
+    // If this edit is creating the entry for the first time, every index must have a value.
+    if (success && !entry.readable) {
+      for (int i = 0; i < valueCount; i++) {
+        if (!editor.written[i]) {
+          editor.abort();
+          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
+        }
+        if (!entry.getDirtyFile(i).exists()) {
+          editor.abort();
+          return;
+        }
+      }
+    }
+
+    for (int i = 0; i < valueCount; i++) {
+      File dirty = entry.getDirtyFile(i);
+      if (success) {
+        if (dirty.exists()) {
+          File clean = entry.getCleanFile(i);
+          dirty.renameTo(clean);
+          long oldLength = entry.lengths[i];
+          long newLength = clean.length();
+          entry.lengths[i] = newLength;
+          size = size - oldLength + newLength;
+        }
+      } else {
+        deleteIfExists(dirty);
+      }
+    }
+
+    redundantOpCount++;
+    entry.currentEditor = null;
+    if (entry.readable | success) {
+      entry.readable = true;
+      journalWriter.append(CLEAN);
+      journalWriter.append(' ');
+      journalWriter.append(entry.key);
+      journalWriter.append(entry.getLengths());
+      journalWriter.append('\n');
+
+      if (success) {
+        entry.sequenceNumber = nextSequenceNumber++;
+      }
+    } else {
+      lruEntries.remove(entry.key);
+      journalWriter.append(REMOVE);
+      journalWriter.append(' ');
+      journalWriter.append(entry.key);
+      journalWriter.append('\n');
+    }
+    flushWriter(journalWriter);
+
+    if (size > maxSize || journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+  }
+
+  /**
+   * We only rebuild the journal when it will halve the size of the journal
+   * and eliminate at least 2000 ops.
+   */
+  private boolean journalRebuildRequired() {
+    final int redundantOpCompactThreshold = 2000;
+    return redundantOpCount >= redundantOpCompactThreshold //
+        && redundantOpCount >= lruEntries.size();
+  }
+
+  /**
+   * Drops the entry for {@code key} if it exists and can be removed. Entries
+   * actively being edited cannot be removed.
+   *
+   * @return true if an entry was removed.
+   */
+  public synchronized boolean remove(String key) throws IOException {
+    checkNotClosed();
+    Entry entry = lruEntries.get(key);
+    if (entry == null || entry.currentEditor != null) {
+      return false;
+    }
+
+    for (int i = 0; i < valueCount; i++) {
+      File file = entry.getCleanFile(i);
+      if (file.exists() && !file.delete()) {
+        throw new IOException("failed to delete " + file);
+      }
+      size -= entry.lengths[i];
+      entry.lengths[i] = 0;
+    }
+
+    redundantOpCount++;
+    journalWriter.append(REMOVE);
+    journalWriter.append(' ');
+    journalWriter.append(key);
+    journalWriter.append('\n');
+
+    lruEntries.remove(key);
+
+    if (journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+
+    return true;
+  }
+
+  /** Returns true if this cache has been closed. */
+  public synchronized boolean isClosed() {
+    return journalWriter == null;
+  }
+
+  private void checkNotClosed() {
+    if (journalWriter == null) {
+      throw new IllegalStateException("cache is closed");
+    }
+  }
+
+  /** Force buffered operations to the filesystem. */
+  public synchronized void flush() throws IOException {
+    checkNotClosed();
+    trimToSize();
+    flushWriter(journalWriter);
+  }
+
+  /** Closes this cache. Stored values will remain on the filesystem. */
+  public synchronized void close() throws IOException {
+    if (journalWriter == null) {
+      return; // Already closed.
+    }
+    for (Entry entry : new ArrayList<Entry>(lruEntries.values())) {
+      if (entry.currentEditor != null) {
+        entry.currentEditor.abort();
+      }
+    }
+    trimToSize();
+    closeWriter(journalWriter);
+    journalWriter = null;
+  }
+
+  private void trimToSize() throws IOException {
+    while (size > maxSize) {
+      Map.Entry<String, Entry> toEvict = lruEntries.entrySet().iterator().next();
+      remove(toEvict.getKey());
+    }
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete
+   * all files in the cache directory including files that weren't created by
+   * the cache.
+   */
+  public void delete() throws IOException {
+    close();
+    Util.deleteContents(directory);
+  }
+
+  private static String inputStreamToString(InputStream in) throws IOException {
+    return Util.readFully(new InputStreamReader(in, Util.UTF_8));
+  }
+
+  /**
+   * Closes the writer while whitelisting with StrictMode if necessary.
+   *
+   * <p>Analogous to b/71520172.
+   */
+  @TargetApi(VERSION_CODES.O)
+  private static void closeWriter(Writer writer) throws IOException {
+    // If API is less than 26, we don't need to whitelist with StrictMode.
+    if (VERSION.SDK_INT < VERSION_CODES.O) {
+      writer.close();
+      return;
+    }
+
+    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+    StrictMode.ThreadPolicy unbufferedIoPolicy =
+        new StrictMode.ThreadPolicy.Builder(oldPolicy).permitUnbufferedIo().build();
+    StrictMode.setThreadPolicy(unbufferedIoPolicy);
+    try {
+      writer.close();
+    } finally {
+      StrictMode.setThreadPolicy(oldPolicy);
+    }
+  }
+
+  /**
+   * Flushes the writer while whitelisting with StrictMode if necessary.
+   *
+   * <p>See b/71520172.
+   */
+  @TargetApi(VERSION_CODES.O)
+  private static void flushWriter(Writer writer) throws IOException {
+    // If API is less than 26, we don't need to whitelist with StrictMode.
+    if (VERSION.SDK_INT < VERSION_CODES.O) {
+      writer.flush();
+      return;
+    }
+
+    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+    StrictMode.ThreadPolicy unbufferedIoPolicy =
+        new StrictMode.ThreadPolicy.Builder(oldPolicy).permitUnbufferedIo().build();
+    StrictMode.setThreadPolicy(unbufferedIoPolicy);
+    try {
+      writer.flush();
+    } finally {
+      StrictMode.setThreadPolicy(oldPolicy);
+    }
+  }
+
+  /** A snapshot of the values for an entry. */
+  public final class Value {
+    private final String key;
+    private final long sequenceNumber;
+    private final long[] lengths;
+    private final File[] files;
+
+      private Value(String key, long sequenceNumber, File[] files, long[] lengths) {
+      this.key = key;
+      this.sequenceNumber = sequenceNumber;
+      this.files = files;
+      this.lengths = lengths;
+    }
+
+    /**
+     * Returns an editor for this snapshot's entry, or null if either the
+     * entry has changed since this snapshot was created or if another edit
+     * is in progress.
+     */
+    public Editor edit() throws IOException {
+      return DiskLruCache.this.edit(key, sequenceNumber);
+    }
+
+    public File getFile(int index) {
+        return files[index];
+    }
+
+    /** Returns the string value for {@code index}. */
+    public String getString(int index) throws IOException {
+      InputStream is = new FileInputStream(files[index]);
+      return inputStreamToString(is);
+    }
+
+    /** Returns the byte length of the value for {@code index}. */
+    public long getLength(int index) {
+      return lengths[index];
+    }
+  }
+
+  /** Edits the values for an entry. */
+  public final class Editor {
+    private final Entry entry;
+    private final boolean[] written;
+    private boolean committed;
+
+    private Editor(Entry entry) {
+      this.entry = entry;
+      this.written = (entry.readable) ? null : new boolean[valueCount];
+    }
+
+    /**
+     * Returns an unbuffered input stream to read the last committed value,
+     * or null if no value has been committed.
+     */
+    private InputStream newInputStream(int index) throws IOException {
+      synchronized (DiskLruCache.this) {
+        if (entry.currentEditor != this) {
+          throw new IllegalStateException();
+        }
+        if (!entry.readable) {
+          return null;
+        }
+        try {
+          return new FileInputStream(entry.getCleanFile(index));
+        } catch (FileNotFoundException e) {
+          return null;
+        }
+      }
+    }
+
+    /**
+     * Returns the last committed value as a string, or null if no value
+     * has been committed.
+     */
+    public String getString(int index) throws IOException {
+      InputStream in = newInputStream(index);
+      return in != null ? inputStreamToString(in) : null;
+    }
+
+    public File getFile(int index) throws IOException {
+      synchronized (DiskLruCache.this) {
+        if (entry.currentEditor != this) {
+            throw new IllegalStateException();
+        }
+        if (!entry.readable) {
+            written[index] = true;
+        }
+        File dirtyFile = entry.getDirtyFile(index);
+        if (!directory.exists()) {
+            directory.mkdirs();
+        }
+        return dirtyFile;
+      }
+    }
+
+    /** Sets the value at {@code index} to {@code value}. */
+    public void set(int index, String value) throws IOException {
+      Writer writer = null;
+      try {
+        OutputStream os = new FileOutputStream(getFile(index));
+        writer = new OutputStreamWriter(os, Util.UTF_8);
+        writer.write(value);
+      } finally {
+        Util.closeQuietly(writer);
+      }
+    }
+
+    /**
+     * Commits this edit so it is visible to readers.  This releases the
+     * edit lock so another edit may be started on the same key.
+     */
+    public void commit() throws IOException {
+      // The object using this Editor must catch and handle any errors
+      // during the write. If there is an error and they call commit
+      // anyway, we will assume whatever they managed to write was valid.
+      // Normally they should call abort.
+      completeEdit(this, true);
+      committed = true;
+    }
+
+    /**
+     * Aborts this edit. This releases the edit lock so another edit may be
+     * started on the same key.
+     */
+    public void abort() throws IOException {
+      completeEdit(this, false);
+    }
+
+    public void abortUnlessCommitted() {
+      if (!committed) {
+        try {
+          abort();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+  }
+
+  private final class Entry {
+    private final String key;
+
+    /** Lengths of this entry's files. */
+    private final long[] lengths;
+
+    /** Memoized File objects for this entry to avoid char[] allocations. */
+    File[] cleanFiles;
+    File[] dirtyFiles;
+
+    /** True if this entry has ever been published. */
+    private boolean readable;
+
+    /** The ongoing edit or null if this entry is not being edited. */
+    private Editor currentEditor;
+
+    /** The sequence number of the most recently committed edit to this entry. */
+    private long sequenceNumber;
+
+    private Entry(String key) {
+      this.key = key;
+      this.lengths = new long[valueCount];
+      cleanFiles = new File[valueCount];
+      dirtyFiles = new File[valueCount];
+
+      // The names are repetitive so re-use the same builder to avoid allocations.
+      StringBuilder fileBuilder = new StringBuilder(key).append('.');
+      int truncateTo = fileBuilder.length();
+      for (int i = 0; i < valueCount; i++) {
+          fileBuilder.append(i);
+          cleanFiles[i] = new File(directory, fileBuilder.toString());
+          fileBuilder.append(".tmp");
+          dirtyFiles[i] = new File(directory, fileBuilder.toString());
+          fileBuilder.setLength(truncateTo);
+      }
+    }
+
+    public String getLengths() throws IOException {
+      StringBuilder result = new StringBuilder();
+      for (long size : lengths) {
+        result.append(' ').append(size);
+      }
+      return result.toString();
+    }
+
+    /** Set lengths using decimal numbers like "10123". */
+    private void setLengths(String[] strings) throws IOException {
+      if (strings.length != valueCount) {
+        throw invalidLengths(strings);
+      }
+
+      try {
+        for (int i = 0; i < strings.length; i++) {
+          lengths[i] = Long.parseLong(strings[i]);
+        }
+      } catch (NumberFormatException e) {
+        throw invalidLengths(strings);
+      }
+    }
+
+    private IOException invalidLengths(String[] strings) throws IOException {
+      throw new IOException("unexpected journal line: " + java.util.Arrays.toString(strings));
+    }
+
+    public File getCleanFile(int i) {
+      return cleanFiles[i];
+    }
+
+    public File getDirtyFile(int i) {
+      return dirtyFiles[i];
+    }
+  }
+
+  /**
+   * A {@link java.util.concurrent.ThreadFactory} that builds a thread with a specific thread name
+   * and with minimum priority.
+   */
+  private static final class DiskLruCacheThreadFactory implements ThreadFactory {
+    @Override
+    public synchronized Thread newThread(Runnable runnable) {
+      Thread result = new Thread(runnable, "glide-disk-lru-cache-thread");
+      result.setPriority(Thread.MIN_PRIORITY);
+      return result;
+    }
+  }
+}
diff --git a/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/StrictLineReader.java b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/StrictLineReader.java
new file mode 100644
index 000000000..11135db04
--- /dev/null
+++ b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/StrictLineReader.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+
+/**
+ * Buffers input from an {@link InputStream} for reading lines.
+ *
+ * <p>This class is used for buffered reading of lines. For purposes of this class, a line ends
+ * with "\n" or "\r\n". End of input is reported by throwing {@code EOFException}. Unterminated
+ * line at end of input is invalid and will be ignored, the caller may use {@code
+ * hasUnterminatedLine()} to detect it after catching the {@code EOFException}.
+ *
+ * <p>This class is intended for reading input that strictly consists of lines, such as line-based
+ * cache entries or cache journal. Unlike the {@link java.io.BufferedReader} which in conjunction
+ * with {@link java.io.InputStreamReader} provides similar functionality, this class uses different
+ * end-of-input reporting and a more restrictive definition of a line.
+ *
+ * <p>This class supports only charsets that encode '\r' and '\n' as a single byte with value 13
+ * and 10, respectively, and the representation of no other character contains these values.
+ * We currently check in constructor that the charset is one of US-ASCII, UTF-8 and ISO-8859-1.
+ * The default charset is US_ASCII.
+ */
+class StrictLineReader implements Closeable {
+  private static final byte CR = (byte) '\r';
+  private static final byte LF = (byte) '\n';
+
+  private final InputStream in;
+  private final Charset charset;
+
+  /*
+   * Buffered data is stored in {@code buf}. As long as no exception occurs, 0 <= pos <= end
+   * and the data in the range [pos, end) is buffered for reading. At end of input, if there is
+   * an unterminated line, we set end == -1, otherwise end == pos. If the underlying
+   * {@code InputStream} throws an {@code IOException}, end may remain as either pos or -1.
+   */
+  private byte[] buf;
+  private int pos;
+  private int end;
+
+  /**
+   * Constructs a new {@code LineReader} with the specified charset and the default capacity.
+   *
+   * @param in the {@code InputStream} to read data from.
+   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
+   * supported.
+   * @throws NullPointerException if {@code in} or {@code charset} is null.
+   * @throws IllegalArgumentException if the specified charset is not supported.
+   */
+  public StrictLineReader(InputStream in, Charset charset) {
+    this(in, 8192, charset);
+  }
+
+  /**
+   * Constructs a new {@code LineReader} with the specified capacity and charset.
+   *
+   * @param in the {@code InputStream} to read data from.
+   * @param capacity the capacity of the buffer.
+   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
+   * supported.
+   * @throws NullPointerException if {@code in} or {@code charset} is null.
+   * @throws IllegalArgumentException if {@code capacity} is negative or zero
+   * or the specified charset is not supported.
+   */
+  public StrictLineReader(InputStream in, int capacity, Charset charset) {
+    if (in == null || charset == null) {
+      throw new NullPointerException();
+    }
+    if (capacity < 0) {
+      throw new IllegalArgumentException("capacity <= 0");
+    }
+    if (!(charset.equals(Util.US_ASCII))) {
+      throw new IllegalArgumentException("Unsupported encoding");
+    }
+
+    this.in = in;
+    this.charset = charset;
+    buf = new byte[capacity];
+  }
+
+  /**
+   * Closes the reader by closing the underlying {@code InputStream} and
+   * marking this reader as closed.
+   *
+   * @throws IOException for errors when closing the underlying {@code InputStream}.
+   */
+  public void close() throws IOException {
+    synchronized (in) {
+      if (buf != null) {
+        buf = null;
+        in.close();
+      }
+    }
+  }
+
+  /**
+   * Reads the next line. A line ends with {@code "\n"} or {@code "\r\n"},
+   * this end of line marker is not included in the result.
+   *
+   * @return the next line from the input.
+   * @throws IOException for underlying {@code InputStream} errors.
+   * @throws EOFException for the end of source stream.
+   */
+  public String readLine() throws IOException {
+    synchronized (in) {
+      if (buf == null) {
+        throw new IOException("LineReader is closed");
+      }
+
+      // Read more data if we are at the end of the buffered data.
+      // Though it's an error to read after an exception, we will let {@code fillBuf()}
+      // throw again if that happens; thus we need to handle end == -1 as well as end == pos.
+      if (pos >= end) {
+        fillBuf();
+      }
+      // Try to find LF in the buffered data and return the line if successful.
+      for (int i = pos; i != end; ++i) {
+        if (buf[i] == LF) {
+          int lineEnd = (i != pos && buf[i - 1] == CR) ? i - 1 : i;
+          String res = new String(buf, pos, lineEnd - pos, charset.name());
+          pos = i + 1;
+          return res;
+        }
+      }
+
+      // Let's anticipate up to 80 characters on top of those already read.
+      ByteArrayOutputStream out = new ByteArrayOutputStream(end - pos + 80) {
+        @Override
+        public String toString() {
+          int length = (count > 0 && buf[count - 1] == CR) ? count - 1 : count;
+          try {
+            return new String(buf, 0, length, charset.name());
+          } catch (UnsupportedEncodingException e) {
+            throw new AssertionError(e); // Since we control the charset this will never happen.
+          }
+        }
+      };
+
+      while (true) {
+        out.write(buf, pos, end - pos);
+        // Mark unterminated line in case fillBuf throws EOFException or IOException.
+        end = -1;
+        fillBuf();
+        // Try to find LF in the buffered data and return the line if successful.
+        for (int i = pos; i != end; ++i) {
+          if (buf[i] == LF) {
+            if (i != pos) {
+              out.write(buf, pos, i - pos);
+            }
+            pos = i + 1;
+            return out.toString();
+          }
+        }
+      }
+    }
+  }
+
+  public boolean hasUnterminatedLine() {
+    return end == -1;
+  }
+
+  /**
+   * Reads new input data into the buffer. Call only with pos == end or end == -1,
+   * depending on the desired outcome if the function throws.
+   */
+  private void fillBuf() throws IOException {
+    int result = in.read(buf, 0, buf.length);
+    if (result == -1) {
+      throw new EOFException();
+    }
+    pos = 0;
+    end = result;
+  }
+}
+
diff --git a/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/Util.java b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/Util.java
new file mode 100644
index 000000000..0260c6362
--- /dev/null
+++ b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/Util.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.nio.charset.Charset;
+
+/** Junk drawer of utility methods. */
+final class Util {
+  static final Charset US_ASCII = Charset.forName("US-ASCII");
+  static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private Util() {
+  }
+
+  static String readFully(Reader reader) throws IOException {
+    try {
+      StringWriter writer = new StringWriter();
+      char[] buffer = new char[1024];
+      int count;
+      while ((count = reader.read(buffer)) != -1) {
+        writer.write(buffer, 0, count);
+      }
+      return writer.toString();
+    } finally {
+      reader.close();
+    }
+  }
+
+  /**
+   * Deletes the contents of {@code dir}. Throws an IOException if any file
+   * could not be deleted, or if {@code dir} is not a readable directory.
+   */
+  static void deleteContents(File dir) throws IOException {
+    File[] files = dir.listFiles();
+    if (files == null) {
+      throw new IOException("not a readable directory: " + dir);
+    }
+    for (File file : files) {
+      if (file.isDirectory()) {
+        deleteContents(file);
+      }
+      if (!file.delete()) {
+        throw new IOException("failed to delete file: " + file);
+      }
+    }
+  }
+
+  static void closeQuietly(/*Auto*/Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+}
diff --git a/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/DiskLruCacheTest.java b/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/DiskLruCacheTest.java
new file mode 100644
index 000000000..f3db6e2b5
--- /dev/null
+++ b/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/DiskLruCacheTest.java
@@ -0,0 +1,966 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import static com.bumptech.glide.disklrucache.DiskLruCache.JOURNAL_FILE;
+import static com.bumptech.glide.disklrucache.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static com.bumptech.glide.disklrucache.DiskLruCache.MAGIC;
+import static com.bumptech.glide.disklrucache.DiskLruCache.VERSION_1;
+import static com.google.common.truth.Fact.simpleFact;
+import static com.google.common.truth.Truth.assertThat;
+import static org.hamcrest.core.IsNot.not;
+import static org.junit.Assume.assumeThat;
+
+import com.google.common.truth.ComparableSubject;
+import com.google.common.truth.FailureMetadata;
+import com.google.common.truth.Subject;
+import com.google.common.truth.Truth;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import org.hamcrest.core.StringStartsWith;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class DiskLruCacheTest {
+  private final int appVersion = 100;
+  private File cacheDir;
+  private File journalFile;
+  private File journalBkpFile;
+  private DiskLruCache cache;
+
+  @Rule public TemporaryFolder tempDir = new TemporaryFolder();
+
+  @BeforeClass
+  public static void setUpClass() {
+    assumeThat(System.getProperty("os.name"), not(StringStartsWith.startsWith("Windows")));
+  }
+
+  @Before public void setUp() throws Exception {
+    cacheDir = tempDir.newFolder("DiskLruCacheTest");
+    journalFile = new File(cacheDir, JOURNAL_FILE);
+    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
+    for (File file : cacheDir.listFiles()) {
+      file.delete();
+    }
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+  }
+
+  @After public void tearDown() throws Exception {
+    cache.close();
+  }
+
+  @Test public void emptyCache() throws Exception {
+    cache.close();
+    assertJournalEquals();
+  }
+
+  @Test public void writeAndReadEntry() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    assertThat(creator.getString(0)).isNull();
+    assertThat(creator.getString(1)).isNull();
+    creator.commit();
+
+    DiskLruCache.Value value = cache.get("k1");
+    assertThat(value.getString(0)).isEqualTo("ABC");
+    assertThat(value.getLength(0)).isEqualTo(3);
+    assertThat(value.getString(1)).isEqualTo("DE");
+    assertThat(value.getLength(1)).isEqualTo(2);
+  }
+
+  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+    cache.close();
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    DiskLruCache.Value value = cache.get("k1");
+    assertThat(value.getString(0)).isEqualTo("A");
+    assertThat(value.getLength(0)).isEqualTo(1);
+    assertThat(value.getString(1)).isEqualTo("B");
+    assertThat(value.getLength(1)).isEqualTo(1);
+  }
+
+  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+
+    // Simulate a dirty close of 'cache' by opening the cache directory again.
+    DiskLruCache cache2 = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    DiskLruCache.Value value = cache2.get("k1");
+    assertThat(value.getString(0)).isEqualTo("A");
+    assertThat(value.getLength(0)).isEqualTo(1);
+    assertThat(value.getString(1)).isEqualTo("B");
+    assertThat(value.getLength(1)).isEqualTo(1);
+    cache2.close();
+  }
+
+  @Test public void journalWithEditAndPublish() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    creator.set(0, "AB");
+    creator.set(1, "C");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
+  }
+
+  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    creator.set(0, "AB");
+    creator.set(1, "C");
+    creator.abort();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
+    cache.edit("k1");
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertThat(cache.get("k1")).isNull();
+    creator.set(0, "A");
+    creator.set(1, "BC");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
+  }
+
+  @Test public void journalWithEditAndPublishAndRead() throws Exception {
+    DiskLruCache.Editor k1Creator = cache.edit("k1");
+    k1Creator.set(0, "AB");
+    k1Creator.set(1, "C");
+    k1Creator.commit();
+    DiskLruCache.Editor k2Creator = cache.edit("k2");
+    k2Creator.set(0, "DEF");
+    k2Creator.set(1, "G");
+    k2Creator.commit();
+    DiskLruCache.Value k1Value = cache.get("k1");
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
+  }
+
+  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "A");
+    editor.set(1, "B");
+    editor.commit();
+    assertInoperable(editor);
+  }
+
+  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "A");
+    editor.set(1, "B");
+    editor.abort();
+    assertInoperable(editor);
+  }
+
+  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "ABC");
+    editor.set(1, "B");
+    editor.commit();
+    File k1 = getCleanFile("k1", 0);
+    assertThat(readFile(k1)).isEqualTo("ABC");
+    cache.remove("k1");
+    assertThat(k1.exists()).isFalse();
+  }
+
+  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
+    cache.close();
+    File cleanFile0 = getCleanFile("k1", 0);
+    File cleanFile1 = getCleanFile("k1", 1);
+    File dirtyFile0 = getDirtyFile("k1", 0);
+    File dirtyFile1 = getDirtyFile("k1", 1);
+    writeFile(cleanFile0, "A");
+    writeFile(cleanFile1, "B");
+    writeFile(dirtyFile0, "C");
+    writeFile(dirtyFile1, "D");
+    createJournal("CLEAN k1 1 1", "DIRTY   k1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertThat(cleanFile0.exists()).isFalse();
+    assertThat(cleanFile1.exists()).isFalse();
+    assertThat(dirtyFile0.exists()).isFalse();
+    assertThat(dirtyFile1.exists()).isFalse();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "0", "100", "2", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "101", "2", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "1", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1", "BOGUS");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 0000x001 1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
+    cache.close();
+    writeFile(getCleanFile("k1", 0), "A");
+    writeFile(getCleanFile("k1", 1), "B");
+    Writer writer = new FileWriter(journalFile);
+    writer.write(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
+    writer.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertThat(cache.get("k1")).isNull();
+
+    // The journal is not corrupt when editing after a truncated line.
+    set("k1", "C", "D");
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertValue("k1", "C", "D");
+  }
+
+  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1 1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void nullKeyThrows() throws Exception {
+    try {
+      cache.edit(null);
+      Assert.fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(1, "A");
+    try {
+      creator.commit();
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    assertThat(getCleanFile("k1", 0).exists()).isFalse();
+    assertThat(getCleanFile("k1", 1).exists()).isFalse();
+    assertThat(getDirtyFile("k1", 0).exists()).isFalse();
+    assertThat(getDirtyFile("k1", 1).exists()).isFalse();
+    assertThat(cache.get("k1")).isNull();
+
+    DiskLruCache.Editor creator2 = cache.edit("k1");
+    creator2.set(0, "B");
+    creator2.set(1, "C");
+    creator2.commit();
+  }
+
+  @Test public void revertWithTooFewValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(1, "A");
+    creator.abort();
+    assertThat(getCleanFile("k1", 0).exists()).isFalse();
+    assertThat(getCleanFile("k1", 1).exists()).isFalse();
+    assertThat(getDirtyFile("k1", 0).exists()).isFalse();
+    assertThat(getDirtyFile("k1", 1).exists()).isFalse();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+
+    DiskLruCache.Editor updater = cache.edit("k1");
+    updater.set(0, "C");
+    updater.commit();
+
+    DiskLruCache.Value value = cache.get("k1");
+    assertThat(value.getString(0)).isEqualTo("C");
+    assertThat(value.getLength(0)).isEqualTo(1);
+    assertThat(value.getString(1)).isEqualTo("B");
+    assertThat(value.getLength(1)).isEqualTo(1);
+  }
+
+  @Test public void growMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    cache.setMaxSize(20);
+    set("c", "c", "c"); // size 12
+    assertThat(cache.size()).isEqualTo(12);
+  }
+
+  @Test public void shrinkMaxSizeEvicts() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 20);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    set("c", "c", "c"); // size 12
+    cache.setMaxSize(10);
+    cache.executorService.shutdown();
+    cache.executorService.awaitTermination(500, TimeUnit.MILLISECONDS);
+    assertThat(cache.size()).isEqualTo(8 /* 12 - 4 */);
+  }
+
+  @Test public void evictOnInsert() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    assertThat(cache.size()).isEqualTo(10);
+
+    // Cause the size to grow to 12 should evict 'A'.
+    set("c", "c", "c");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(8);
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+
+    // Causing the size to grow to 10 should evict nothing.
+    set("d", "d", "d");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(10);
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+    assertValue("d", "d", "d");
+
+    // Causing the size to grow to 18 should evict 'B' and 'C'.
+    set("e", "eeee", "eeee");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(10);
+    assertAbsent("a");
+    assertAbsent("b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "eeee", "eeee");
+  }
+
+  @Test public void evictOnUpdate() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("a", "a", "aa"); // size 3
+    set("b", "b", "bb"); // size 3
+    set("c", "c", "cc"); // size 3
+    assertThat(cache.size()).isEqualTo(9);
+
+    // Causing the size to grow to 11 should evict 'A'.
+    set("b", "b", "bbbb");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(8);
+    assertAbsent("a");
+    assertValue("b", "b", "bbbb");
+    assertValue("c", "c", "cc");
+  }
+
+  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    cache.get("b"); // 'B' is now least recently used.
+
+    // Causing the size to grow to 12 should evict 'A'.
+    set("f", "f", "f");
+    // Causing the size to grow to 12 should evict 'C'.
+    set("g", "g", "g");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(10);
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+  }
+
+  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    set("f", "f", "f");
+    cache.get("b"); // 'B' is now least recently used.
+    assertThat(cache.size()).isEqualTo(12);
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("g", "g", "g");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(10);
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+    assertValue("g", "g", "g");
+  }
+
+  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aaaaa", "aaaaaa"); // size=11
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aaaaaaaaaaa", "a"); // size=12
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
+    try {
+      DiskLruCache.open(cacheDir, appVersion, 2, 0);
+      Assert.fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
+    try {
+      DiskLruCache.open(cacheDir, appVersion, 0, 10);
+      Assert.fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void removeAbsentElement() throws Exception {
+    cache.remove("a");
+  }
+
+  @Test public void readingTheSameFileMultipleTimes() throws Exception {
+    set("a", "a", "b");
+    DiskLruCache.Value value = cache.get("a");
+    assertThat(value.getFile(0)).isSameInstanceAs(value.getFile(0));
+  }
+
+  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break; // Test passed!
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      set("a", "a", "a");
+      set("b", "b", "b");
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break;
+      }
+      lastJournalLength = journalLength;
+    }
+
+    // Sanity check that a rebuilt journal behaves normally.
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+      cache.close();
+      cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break; // Test passed!
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      set("a", "a", "a");
+      set("b", "b", "b");
+      cache.close();
+      cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break;
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  @Test public void restoreBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    creator.commit();
+    cache.close();
+
+    assertThat(journalFile.renameTo(journalBkpFile)).isTrue();
+    assertThat(journalFile.exists()).isFalse();
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+
+    DiskLruCache.Value value = cache.get("k1");
+    assertThat(value.getString(0)).isEqualTo("ABC");
+    assertThat(value.getLength(0)).isEqualTo(3);
+    assertThat(value.getString(1)).isEqualTo("DE");
+    assertThat(value.getLength(1)).isEqualTo(2);
+
+    assertThat(journalBkpFile.exists()).isFalse();
+    assertThat(journalFile.exists()).isTrue();
+  }
+
+  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    creator.commit();
+    cache.flush();
+
+    Files.copy(journalFile.toPath(), journalBkpFile.toPath());
+
+    creator = cache.edit("k2");
+    creator.set(0, "F");
+    creator.set(1, "GH");
+    creator.commit();
+    cache.close();
+
+    assertThat(journalFile.exists()).isTrue();
+    assertThat(journalBkpFile.exists()).isTrue();
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+
+    DiskLruCache.Value valueA = cache.get("k1");
+    assertThat(valueA.getString(0)).isEqualTo("ABC");
+    assertThat(valueA.getLength(0)).isEqualTo(3);
+    assertThat(valueA.getString(1)).isEqualTo("DE");
+    assertThat(valueA.getLength(1)).isEqualTo(2);
+
+    DiskLruCache.Value valueB = cache.get("k2");
+    assertThat(valueB.getString(0)).isEqualTo("F");
+    assertThat(valueB.getLength(0)).isEqualTo(1);
+    assertThat(valueB.getString(1)).isEqualTo("GH");
+    assertThat(valueB.getLength(1)).isEqualTo(2);
+
+    assertThat(journalBkpFile.exists()).isFalse();
+    assertThat(journalFile.exists()).isTrue();
+  }
+
+  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
+    cache.close();
+    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
+    cache = DiskLruCache.open(dir, appVersion, 2, Integer.MAX_VALUE);
+    set("a", "a", "a");
+    assertThat(new File(dir, "a.0").exists()).isTrue();
+    assertThat(new File(dir, "a.1").exists()).isTrue();
+    assertThat(new File(dir, "journal").exists()).isTrue();
+  }
+
+  @Test public void fileDeletedExternally() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 1).delete();
+    assertThat(cache.get("a")).isNull();
+  }
+
+  @Test public void editSameVersion() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Value value = cache.get("a");
+    DiskLruCache.Editor editor = value.edit();
+    editor.set(1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeAborted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Value value = cache.get("a");
+    DiskLruCache.Editor toAbort = value.edit();
+    toAbort.set(0, "b");
+    toAbort.abort();
+    DiskLruCache.Editor editor = value.edit();
+    editor.set(1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Value value = cache.get("a");
+    DiskLruCache.Editor toAbort = value.edit();
+    toAbort.set(0, "b");
+    toAbort.commit();
+    assertThat(value.edit()).isNull();
+  }
+
+  @Test public void editSinceEvicted() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Value value = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    cache.flush();
+    assertThat(value.edit()).isNull();
+  }
+
+  @Test public void editSinceEvictedAndRecreated() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Value value = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    set("a", "a", "aaaa"); // size 5; will evict 'B'
+    cache.flush();
+    assertThat(value.edit()).isNull();
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesWrite() throws Exception {
+    deleteDirectory(cacheDir);
+    set("a", "a", "a");
+    assertValue("a", "a", "a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesEdit() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    deleteDirectory(cacheDir);
+    a.set(1, "a2");
+    a.commit();
+  }
+
+  @Test public void removeHandlesMissingFile() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 0).delete();
+    cache.remove("a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    a.set(0, "a1");
+    deleteDirectory(cacheDir);
+    a.set(1, "a2");
+    a.commit();
+    assertThat(cache.get("a")).isNull();
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesRead() throws Exception {
+    deleteDirectory(cacheDir);
+    assertThat(cache.get("a")).isNull();
+  }
+
+  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
+    List<String> expectedLines = new ArrayList<String>();
+    expectedLines.add(MAGIC);
+    expectedLines.add(VERSION_1);
+    expectedLines.add("100");
+    expectedLines.add("2");
+    expectedLines.add("");
+    expectedLines.addAll(Arrays.asList(expectedBodyLines));
+    assertThat(readJournalLines()).isEqualTo(expectedLines);
+  }
+
+  private void createJournal(String... bodyLines) throws Exception {
+    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
+  }
+
+  private void createJournalWithHeader(String magic, String version, String appVersion,
+      String valueCount, String blank, String... bodyLines) throws Exception {
+    Writer writer = new FileWriter(journalFile);
+    writer.write(magic + "\n");
+    writer.write(version + "\n");
+    writer.write(appVersion + "\n");
+    writer.write(valueCount + "\n");
+    writer.write(blank + "\n");
+    for (String line : bodyLines) {
+      writer.write(line);
+      writer.write('\n');
+    }
+    writer.close();
+  }
+
+  private List<String> readJournalLines() throws Exception {
+    List<String> result = new ArrayList<String>();
+    BufferedReader reader = new BufferedReader(new FileReader(journalFile));
+    String line;
+    while ((line = reader.readLine()) != null) {
+      result.add(line);
+    }
+    reader.close();
+    return result;
+  }
+
+  private File getCleanFile(String key, int index) {
+    return new File(cacheDir, key + "." + index);
+  }
+
+  private File getDirtyFile(String key, int index) {
+    return new File(cacheDir, key + "." + index + ".tmp");
+  }
+
+  private static String readFile(File file) throws Exception {
+    Reader reader = new FileReader(file);
+    StringWriter writer = new StringWriter();
+    char[] buffer = new char[1024];
+    int count;
+    while ((count = reader.read(buffer)) != -1) {
+      writer.write(buffer, 0, count);
+    }
+    reader.close();
+    return writer.toString();
+  }
+
+  public static void writeFile(File file, String content) throws Exception {
+    FileWriter writer = new FileWriter(file);
+    writer.write(content);
+    writer.close();
+  }
+
+  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
+    try {
+      editor.getString(0);
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.set(0, "A");
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.getFile(0);
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.commit();
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.abort();
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  private void generateSomeGarbageFiles() throws Exception {
+    File dir1 = new File(cacheDir, "dir1");
+    File dir2 = new File(dir1, "dir2");
+    writeFile(getCleanFile("g1", 0), "A");
+    writeFile(getCleanFile("g1", 1), "B");
+    writeFile(getCleanFile("g2", 0), "C");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(new File(cacheDir, "otherFile0"), "E");
+    dir1.mkdir();
+    dir2.mkdir();
+    writeFile(new File(dir2, "otherFile1"), "F");
+  }
+
+  private void assertGarbageFilesAllDeleted() throws Exception {
+    FileSubject.assertThat(getCleanFile("g1", 0)).doesNotExist();
+    FileSubject.assertThat(getCleanFile("g1", 1)).doesNotExist();
+    FileSubject.assertThat(getCleanFile("g2", 0)).doesNotExist();
+    FileSubject.assertThat(getCleanFile("g2", 1)).doesNotExist();
+    FileSubject.assertThat(new File(cacheDir, "otherFile0")).doesNotExist();
+    FileSubject.assertThat(new File(cacheDir, "dir1")).doesNotExist();
+  }
+
+  private void set(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Editor editor = cache.edit(key);
+    editor.set(0, value0);
+    editor.set(1, value1);
+    editor.commit();
+  }
+
+  private void assertAbsent(String key) throws Exception {
+    DiskLruCache.Value value = cache.get(key);
+    if (value != null) {
+      Assert.fail();
+    }
+    FileSubject.assertThat(getCleanFile(key, 0)).doesNotExist();
+    FileSubject.assertThat(getCleanFile(key, 1)).doesNotExist();
+    FileSubject.assertThat(getDirtyFile(key, 0)).doesNotExist();
+    FileSubject.assertThat(getDirtyFile(key, 1)).doesNotExist();
+  }
+
+  private void assertValue(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Value value = cache.get(key);
+    assertThat(value.getString(0)).isEqualTo(value0);
+    assertThat(value.getLength(0)).isEqualTo(value0.length());
+    assertThat(value.getString(1)).isEqualTo(value1);
+    assertThat(value.getLength(1)).isEqualTo(value1.length());
+    FileSubject.assertThat(getCleanFile(key, 0)).exists();
+    FileSubject.assertThat(getCleanFile(key, 1)).exists();
+  }
+
+  private static void deleteDirectory(File file) {
+    if (file.isDirectory()) {
+      File[] children = file.listFiles();
+      if (children != null && children.length > 0) {
+        for (File child : children) {
+          deleteDirectory(child);
+        }
+      }
+    }
+    assertThat(!file.exists() || file.delete()).isTrue();
+  }
+
+  // TODO(b/134664588): Remove after go/truth-subject-lsc
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  static final class FileSubject extends ComparableSubject {
+    private static final Subject.Factory<FileSubject, File> FACTORY =
+        new Subject.Factory<FileSubject, File>() {
+          @Override
+          public FileSubject createSubject(FailureMetadata metadata, File actual) {
+            return new FileSubject(metadata, actual);
+          }
+        };
+    private final File actual;
+
+    static FileSubject assertThat(File file) {
+      return Truth.assertAbout(FACTORY).that(file);
+    }
+
+    protected FileSubject(FailureMetadata metadata, File actual) {
+      super(metadata, actual);
+      this.actual = actual;
+    }
+
+    public void doesNotExist() {
+      if (actual.exists()) {
+        failWithActual(simpleFact("expected to not exist"));
+      }
+    }
+
+    public void exists() {
+      if (!actual.exists()) {
+        failWithActual(simpleFact("expected to exist"));
+      }
+    }
+  }
+}
diff --git a/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/StrictLineReaderTest.java b/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/StrictLineReaderTest.java
new file mode 100644
index 000000000..8e1bb63b3
--- /dev/null
+++ b/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/StrictLineReaderTest.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.ByteArrayInputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(JUnit4.class)
+public class StrictLineReaderTest {
+  @Test public void lineReaderConsistencyWithReadAsciiLine() {
+    try {
+      // Testing with LineReader buffer capacity 32 to check some corner cases.
+      StrictLineReader lineReader =
+          new StrictLineReader(createTestInputStream(), 32, Util.US_ASCII);
+      InputStream refStream = createTestInputStream();
+      while (true) {
+        try {
+          String refLine = readAsciiLine(refStream);
+          try {
+            String line = lineReader.readLine();
+            if (!refLine.equals(line)) {
+              Assert.fail("line (\"" + line + "\") differs from expected (\"" + refLine + "\").");
+            }
+          } catch (EOFException eof) {
+            Assert.fail("line reader threw EOFException too early.");
+          }
+        } catch (EOFException refEof) {
+          try {
+            lineReader.readLine();
+            Assert.fail("line reader didn't throw the expected EOFException.");
+          } catch (EOFException expected) {
+            break;
+          }
+        }
+      }
+      refStream.close();
+      lineReader.close();
+    } catch (IOException ioe) {
+      Assert.fail("Unexpected IOException " + ioe.toString());
+    }
+  }
+
+  /* XXX From libcore.io.Streams */
+  private static String readAsciiLine(InputStream in) throws IOException {
+    // TODO: support UTF-8 here instead
+
+    StringBuilder result = new StringBuilder(80);
+    while (true) {
+      int c = in.read();
+      if (c == -1) {
+        throw new EOFException();
+      } else if (c == '\n') {
+        break;
+      }
+
+      result.append((char) c);
+    }
+    int length = result.length();
+    if (length > 0 && result.charAt(length - 1) == '\r') {
+      result.setLength(length - 1);
+    }
+    return result.toString();
+  }
+
+  private static InputStream createTestInputStream() {
+    return new ByteArrayInputStream((""
+        // Each source lines below should represent 32 bytes, until the next comment.
+        + "12 byte line\n18 byte line......\n"
+        + "pad\nline spanning two 32-byte bu"
+        + "ffers\npad......................\n"
+        + "pad\nline spanning three 32-byte "
+        + "buffers and ending with LF at th"
+        + "e end of a 32 byte buffer......\n"
+        + "pad\nLine ending with CRLF split"
+        + " at the end of a 32-byte buffer\r"
+        + "\npad...........................\n"
+        // End of 32-byte lines.
+        + "line ending with CRLF\r\n"
+        + "this is a long line with embedded CR \r ending with CRLF and having more than "
+        + "32 characters\r\n"
+        + "unterminated line - should be dropped").getBytes());
+  }
+}
+
diff --git a/third_party/exif_orientation_examples/.gitignore b/third_party/exif_orientation_examples/.gitignore
new file mode 100644
index 000000000..f39f9657c
--- /dev/null
+++ b/third_party/exif_orientation_examples/.gitignore
@@ -0,0 +1,6 @@
+/.ruby-gemset
+/.ruby-version
+/generator/Gemfile.lock
+/Landscape.jpg
+/Portrait.jpg
+/sources
diff --git a/third_party/exif_orientation_examples/LICENSE b/third_party/exif_orientation_examples/LICENSE
new file mode 100644
index 000000000..978ee2ae8
--- /dev/null
+++ b/third_party/exif_orientation_examples/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2010 Dave Perrett, http://recursive-design.com/
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
\ No newline at end of file
diff --git a/third_party/exif_orientation_examples/Landscape_1.jpg b/third_party/exif_orientation_examples/Landscape_1.jpg
new file mode 100644
index 000000000..fda188236
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_1.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_2.jpg b/third_party/exif_orientation_examples/Landscape_2.jpg
new file mode 100644
index 000000000..d2605f81b
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_2.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_3.jpg b/third_party/exif_orientation_examples/Landscape_3.jpg
new file mode 100644
index 000000000..f50805234
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_3.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_4.jpg b/third_party/exif_orientation_examples/Landscape_4.jpg
new file mode 100644
index 000000000..d73dee8fd
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_4.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_5.jpg b/third_party/exif_orientation_examples/Landscape_5.jpg
new file mode 100644
index 000000000..975d85883
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_5.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_6.jpg b/third_party/exif_orientation_examples/Landscape_6.jpg
new file mode 100644
index 000000000..b579b7f9a
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_6.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_7.jpg b/third_party/exif_orientation_examples/Landscape_7.jpg
new file mode 100644
index 000000000..b1e919cfd
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_7.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_8.jpg b/third_party/exif_orientation_examples/Landscape_8.jpg
new file mode 100644
index 000000000..c381db10e
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_8.jpg differ
diff --git a/third_party/exif_orientation_examples/Makefile b/third_party/exif_orientation_examples/Makefile
new file mode 100644
index 000000000..c5fc2e0e4
--- /dev/null
+++ b/third_party/exif_orientation_examples/Makefile
@@ -0,0 +1,11 @@
+all: portrait landscape
+
+portrait:
+	curl --location https://source.unsplash.com/random/1200x1600 --output ./Portrait.jpg
+	bash -c "cd generator && ./generate.rb ../Portrait.jpg"
+	rm -f ./Portrait.jpg
+
+landscape:
+	curl --location https://source.unsplash.com/random/1600x1200 --output ./Landscape.jpg
+	bash -c "cd generator && ./generate.rb ../Landscape.jpg"
+	rm -f ./Landscape.jpg
diff --git a/third_party/exif_orientation_examples/Portrait_1.jpg b/third_party/exif_orientation_examples/Portrait_1.jpg
new file mode 100644
index 000000000..dcb57c537
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_1.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_2.jpg b/third_party/exif_orientation_examples/Portrait_2.jpg
new file mode 100644
index 000000000..8c3adf7af
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_2.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_3.jpg b/third_party/exif_orientation_examples/Portrait_3.jpg
new file mode 100644
index 000000000..5a5544f23
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_3.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_4.jpg b/third_party/exif_orientation_examples/Portrait_4.jpg
new file mode 100644
index 000000000..9eb2a6a1e
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_4.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_5.jpg b/third_party/exif_orientation_examples/Portrait_5.jpg
new file mode 100644
index 000000000..905169aa7
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_5.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_6.jpg b/third_party/exif_orientation_examples/Portrait_6.jpg
new file mode 100644
index 000000000..8fc576e06
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_6.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_7.jpg b/third_party/exif_orientation_examples/Portrait_7.jpg
new file mode 100644
index 000000000..cfa04d66e
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_7.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_8.jpg b/third_party/exif_orientation_examples/Portrait_8.jpg
new file mode 100644
index 000000000..b2a50d6eb
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_8.jpg differ
diff --git a/third_party/exif_orientation_examples/README.markdown b/third_party/exif_orientation_examples/README.markdown
new file mode 100644
index 000000000..61c0b8595
--- /dev/null
+++ b/third_party/exif_orientation_examples/README.markdown
@@ -0,0 +1,82 @@
+EXIF Orientation-flag example images
+====================================
+
+Example images using each of the EXIF orientation flags (1-to-8), in both landscape and portrait orientations.
+
+[See here](http://www.daveperrett.com/articles/2012/07/28/exif-orientation-handling-is-a-ghetto/) for more information.
+
+
+Generating your own images
+--------------------------
+
+If you would like to generate test images based on your own photos, you can use the `generate.rb` script included in the `generator` folder.
+
+The instructions below assume you are running on OSX - if not, you will need to install the Ghostscript fonts (`brew install gs`) some other way.
+
+To install the dependencies:
+
+```
+> brew install gs
+> cd generator
+> gem install bundler
+> bundle install
+```
+
+To generate test images:
+
+```
+> cd generator
+> ./generate path/to/image.jpg
+```
+
+This will create images `image_1.jpg` through to `image_8.jpg`.
+
+
+Re-generating sample images
+---------------------------
+
+Simply run `make` to regenerate the included sample images. This will download random portrait and landscape orientation images from [unsplash.com](https://unsplash.com/) and generate sample images for each of them.
+
+Generating these images depends on having the generator dependencies installed - see the *Generating your own images* section for instructions on installing dependencies.
+
+
+Credits
+-------
+
+* The sample landscape image is by [Pierre Bouillot](https://unsplash.com/photos/v15iOM6pWgI).
+* The sample portrait image is by [John Salvino](https://unsplash.com/photos/1PPpwrTNkJI).
+
+
+Change history
+--------------
+
+* **Version 2.0.0 (2017-08-05)** : Add a script to generate example images from the command line.
+* **Version 1.0.2 (2017-03-06)** : Remove Apple Copyrighted ICC profile from orientations 2-8 (thanks @mans0954!).
+* **Version 1.0.1 (2013-03-10)** : Add MIT license and some contact details.
+* **Version 1.0.0 (2012-07-28)** : 1.0 release.
+
+
+Contributing
+------------
+
+Once you've made your commits:
+
+1. [Fork](http://help.github.com/fork-a-repo/) exif-orientation-examples
+2. Create a topic branch - `git checkout -b my_branch`
+3. Push to your branch - `git push origin my_branch`
+4. Create a [Pull Request](http://help.github.com/pull-requests/) from your branch
+5. That's it!
+
+
+Author
+------
+
+Dave Perrett :: hello@daveperrett.com :: [@daveperrett](http://twitter.com/daveperrett)
+
+
+Copyright
+---------
+
+These images are licensed under the [MIT License](http://opensource.org/licenses/MIT).
+
+Copyright (c) 2010 Dave Perrett. See [License](https://github.com/recurser/exif-orientation-examples/blob/master/LICENSE) for details.
diff --git a/third_party/exif_orientation_examples/README.third_party b/third_party/exif_orientation_examples/README.third_party
new file mode 100644
index 000000000..e27da7562
--- /dev/null
+++ b/third_party/exif_orientation_examples/README.third_party
@@ -0,0 +1,10 @@
+URL: https://github.com/recurser/exif-orientation-examples/tree/d06cd11258b98b24b3cd8d391ee5bf4961a80853
+Version: d06cd11258b98b24b3cd8d391ee5bf4961a80853
+License: MIT
+License File: LICENSE
+
+Description:
+Sample images with all of the supported exif orientations.
+ 
+Local Modifications:
+None
diff --git a/third_party/exif_orientation_examples/VERSION b/third_party/exif_orientation_examples/VERSION
new file mode 100644
index 000000000..227cea215
--- /dev/null
+++ b/third_party/exif_orientation_examples/VERSION
@@ -0,0 +1 @@
+2.0.0
diff --git a/third_party/exif_orientation_examples/generator/Gemfile b/third_party/exif_orientation_examples/generator/Gemfile
new file mode 100644
index 000000000..65e8f880b
--- /dev/null
+++ b/third_party/exif_orientation_examples/generator/Gemfile
@@ -0,0 +1,4 @@
+source 'https://rubygems.org'
+ruby '2.4.1'
+
+gem 'rmagick'
diff --git a/third_party/exif_orientation_examples/generator/generate.rb b/third_party/exif_orientation_examples/generator/generate.rb
new file mode 100755
index 000000000..4df576670
--- /dev/null
+++ b/third_party/exif_orientation_examples/generator/generate.rb
@@ -0,0 +1,135 @@
+#!/usr/bin/env ruby
+
+# Make sure to 'brew install gs' before running this.
+
+require 'RMagick'
+require 'tempfile'
+
+if ARGV.length != 1
+  abort "Usage: #{$PROGRAM_NAME} /path/to/image"
+end
+
+# Make sure the file exists.
+source = ARGV[0]
+abort "Error: File '#{source}' not found" unless File.exist?(source) && File.file?(source)
+
+# Copy it to the temp directory.
+path = Tempfile.new('to-convert').path
+FileUtils.cp source, path
+
+# Make sure it's an image.
+image = begin
+  Magick::Image::read(path).first
+rescue Magick::ImageMagickError
+  abort "Error: File '#{source}' does not appear to be an image."
+end
+
+# Make sure exiftool and convert are available.
+abort 'Error: The exiftool command does not appear to be available' if `which exiftool` == ''
+abort 'Error: The convert command does not appear to be available' if `which convert` == ''
+abort 'Error: the input file must be a JPEG' unless image.format == 'JPEG'
+
+# Decide where we'll put the output.
+dest_folder    = File.dirname(source)
+dest_file_base = File.basename(source, '.*')
+dest_extention = File.extname(source)
+
+# Strip all exif data.
+`exiftool -all= #{path}`
+
+# Strip color profile info.
+FileUtils.cp path, "#{path}.convert"
+`convert #{path}.convert +profile "*" #{path}`
+FileUtils.rm_f "#{path}.convert"
+
+# Decide on a suitable font size.
+dimension = [image.rows, image.columns].max
+font_size = dimension / 20
+
+# Add top / right / bottom / left text.
+text              = Magick::Draw.new
+text.font_family  = 'helvetica'
+text.pointsize    = font_size
+text.fill         = 'white'
+text.stroke       = 'black'
+text.stroke_width = 1
+edge_padding      = font_size / 4
+
+text.annotate(image, 0, 0, 0, edge_padding, 'top') do
+  self.gravity = Magick::NorthGravity
+end
+
+text.annotate(image, 0, 0, 0, edge_padding, 'bottom') do
+  self.gravity = Magick::SouthGravity
+end
+
+text.annotate(image, 0, 0, edge_padding, 0, 'right') do
+  self.gravity = Magick::EastGravity
+end
+
+text.annotate(image, 0, 0, edge_padding, 0, 'left') do
+  self.gravity = Magick::WestGravity
+end
+
+transformations = [
+  {
+    exif_tag:         1,
+    rotation_degrees: 0,
+    flop:             false,
+  },
+  {
+    exif_tag:         2,
+    rotation_degrees: 0,
+    flop:             true,
+  },
+
+  {
+    exif_tag:         3,
+    rotation_degrees: 180,
+    flop:             false,
+  },
+  {
+    exif_tag:         4,
+    rotation_degrees: 180,
+    flop:             true,
+  },
+  {
+    exif_tag:         5,
+    rotation_degrees: -90,
+    flop:             true,
+  },
+  {
+    exif_tag:         6,
+    rotation_degrees: -90,
+    flop:             false,
+  },
+  {
+    exif_tag:         7,
+    rotation_degrees: 90,
+    flop:             true,
+  },
+  {
+    exif_tag:         8,
+    rotation_degrees: 90,
+    flop:             false,
+  },
+]
+
+transformations.each do |t|
+  tmp_image = image.dup
+
+  # Add centered text displaying the orientation tag number.
+  text.annotate(tmp_image, 0, 0, 0, 0, t[:exif_tag].to_s) do
+    self.gravity   = Magick::CenterGravity
+    text.pointsize = font_size * 2
+  end
+
+  # Rotate and transform the image.
+  tmp_image.flop! if t[:flop]
+  tmp_image.rotate! t[:rotation_degrees] if t[:rotation_degrees] != 0
+  out_path = File.join(dest_folder, "#{dest_file_base}_#{t[:exif_tag]}#{dest_extention}")
+  tmp_image.write(out_path)
+
+  # Set the EXIF Orientation tag.
+  `exiftool -overwrite_original -orientation=#{t[:exif_tag]} -n #{out_path}`
+end
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index a19bcda5f..7208174ab 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -1,19 +1,18 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    implementation "androidx.annotation:annotation:${ANDROID_X_VERSION}"
 
-    testCompile project(':testutil')
-    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation project(':testutil')
+    testImplementation "androidx.annotation:annotation:${ANDROID_X_VERSION}"
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
diff --git a/third_party/gif_decoder/src/main/AndroidManifest.xml b/third_party/gif_decoder/src/main/AndroidManifest.xml
index bafd13c3b..9bdfa020a 100644
--- a/third_party/gif_decoder/src/main/AndroidManifest.xml
+++ b/third_party/gif_decoder/src/main/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide.gifdecoder">
+<manifest
+  package="com.bumptech.glide.gifdecoder">
 
     <application/>
 </manifest>
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index 24d965aef..460df9238 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.gifdecoder;
 
 import android.graphics.Bitmap;
-import android.support.annotation.IntDef;
-import android.support.annotation.NonNull;
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import java.io.InputStream;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -34,7 +35,7 @@
    * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
    * from constantly allocating {@link android.graphics.Bitmap}s for every frame.
    */
-  public interface BitmapProvider {
+  interface BitmapProvider {
     /**
      * Returns an {@link Bitmap} with exactly the given dimensions and config.
      *
@@ -44,40 +45,43 @@
      *               android.graphics.Bitmap}.
      */
     @NonNull
-    Bitmap obtain(int width, int height, Bitmap.Config config);
+    Bitmap obtain(int width, int height, @NonNull Bitmap.Config config);
 
     /**
      * Releases the given Bitmap back to the pool.
      */
-    void release(Bitmap bitmap);
+    void release(@NonNull Bitmap bitmap);
 
     /**
      * Returns a byte array used for decoding and generating the frame bitmap.
      *
      * @param size the size of the byte array to obtain
      */
+    @NonNull
     byte[] obtainByteArray(int size);
 
     /**
      * Releases the given byte array back to the pool.
      */
-    void release(byte[] bytes);
+    void release(@NonNull byte[] bytes);
 
     /**
      * Returns an int array used for decoding/generating the frame bitmaps.
      */
+    @NonNull
     int[] obtainIntArray(int size);
 
     /**
      * Release the given array back to the pool.
      */
-    void release(int[] array);
+    void release(@NonNull int[] array);
   }
 
   int getWidth();
 
   int getHeight();
 
+  @NonNull
   ByteBuffer getData();
 
   /**
@@ -189,6 +193,7 @@
    *
    * @return Bitmap representation of frame.
    */
+  @Nullable
   Bitmap getNextFrame();
 
   /**
@@ -198,15 +203,15 @@
    * @return read status code (0 = no errors).
    */
   @GifDecodeStatus
-  int read(InputStream is, int contentLength);
+  int read(@Nullable InputStream is, int contentLength);
 
   void clear();
 
-  void setData(GifHeader header, byte[] data);
+  void setData(@NonNull GifHeader header, @NonNull byte[] data);
 
-  void setData(GifHeader header, ByteBuffer buffer);
+  void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer);
 
-  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);
+  void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer, int sampleSize);
 
   /**
    * Reads GIF image from byte array.
@@ -215,7 +220,7 @@
    * @return read status code (0 = no errors).
    */
   @GifDecodeStatus
-  int read(byte[] data);
+  int read(@Nullable byte[] data);
 
 
   /**
@@ -233,5 +238,5 @@
    * {@link android.graphics.Bitmap.Config#ARGB_8888} will be used anyway to support the
    * transparency.
    */
-  void setDefaultBitmapFormat(Bitmap.Config format);
+  void setDefaultBitmapConfig(@NonNull Bitmap.Config format);
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
index 0a26cb756..fcb24eb17 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.gifdecoder;
 
-import android.support.annotation.ColorInt;
-import android.support.annotation.IntDef;
+import androidx.annotation.ColorInt;
+import androidx.annotation.IntDef;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -16,26 +16,26 @@
    * <p><b>GIF89a</b>: <i>No disposal specified.
    * The decoder is not required to take any action.</i></p>
    */
-  public static final int DISPOSAL_UNSPECIFIED = 0;
+  static final int DISPOSAL_UNSPECIFIED = 0;
   /**
    * GIF Disposal Method meaning leave canvas from previous frame.
    * <p><b>GIF89a</b>: <i>Do not dispose.
    * The graphic is to be left in place.</i></p>
    */
-  public static final int DISPOSAL_NONE = 1;
+  static final int DISPOSAL_NONE = 1;
   /**
    * GIF Disposal Method meaning clear canvas to background color.
    * <p><b>GIF89a</b>: <i>Restore to background color.
    * The area used by the graphic must be restored to the background color.</i></p>
    */
-  public static final int DISPOSAL_BACKGROUND = 2;
+  static final int DISPOSAL_BACKGROUND = 2;
   /**
    * GIF Disposal Method meaning clear canvas to frame before last.
    * <p><b>GIF89a</b>: <i>Restore to previous.
    * The decoder is required to restore the area overwritten by the graphic
    * with what was there prior to rendering the graphic.</i></p>
    */
-  public static final int DISPOSAL_PREVIOUS = 3;
+  static final int DISPOSAL_PREVIOUS = 3;
 
   /**
    * <p><b>GIF89a</b>:
@@ -49,7 +49,7 @@
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(value = {DISPOSAL_UNSPECIFIED, DISPOSAL_NONE, DISPOSAL_BACKGROUND, DISPOSAL_PREVIOUS})
-  @interface GifDisposalMethod {
+  private @interface GifDisposalMethod {
   }
 
   int ix, iy, iw, ih;
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index d43f7cca7..7569e78ca 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.gifdecoder;
 
-import android.support.annotation.ColorInt;
+import androidx.annotation.ColorInt;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -26,7 +26,7 @@
   int frameCount = 0;
 
   GifFrame currentFrame;
-  List<GifFrame> frames = new ArrayList<>();
+  final List<GifFrame> frames = new ArrayList<>();
   /** Logical screen size: Full image width. */
   int width;
   /** Logical screen size: Full image height. */
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 05662c04e..0a38c2d21 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -4,6 +4,8 @@
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.util.Log;
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
@@ -17,7 +19,7 @@
  * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeaderParser {
-  public static final String TAG = "GifHeaderParser";
+  private static final String TAG = "GifHeaderParser";
 
   private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
 
@@ -35,7 +37,6 @@
 
   // Graphic Control Extension packed field masks
 
-  private static final int GCE_MASK_RESERVED_BITS = 0b11100000;
   /**
    * Mask (bits 4-2) to extract Disposal Method of the current frame.
    *
@@ -46,7 +47,6 @@
    * Shift so the Disposal Method extracted from the packed value is on the least significant bit.
    */
   private static final int GCE_DISPOSAL_METHOD_SHIFT = 2;
-  private static final int GCE_MASK_USER_INPUT_FLAG = 0b00000010;
   /**
    * Mask (bit 0) to extract Transparent Color Flag of the current frame.
    * <p><b>GIF89a</b>: <i>Indicates whether a transparency index is given
@@ -76,8 +76,6 @@
    * </ul>
    */
   private static final int DESCRIPTOR_MASK_INTERLACE_FLAG = 0b01000000;
-  private static final int DESCRIPTOR_MASK_SORT_FLAG = 0b00100000;
-  private static final int DESCRIPTOR_MASK_RESERVED = 0b00011000;
   /**
    * Mask (bits 2-0) to extract Size of the Local Color Table of the current image.
    * <p><b>GIF89a</b>: <i>If the Local Color Table Flag is set to 1, the value in this
@@ -100,8 +98,6 @@
    * </ul>
    */
   private static final int LSD_MASK_GCT_FLAG = 0b10000000;
-  private static final int LSD_MASK_COLOR_RESOLUTION = 0b01110000;
-  private static final int LSD_MASK_SORT_FLAG = 0b00001000;
   /**
    * Mask (bits 2-0) to extract Size of the Global Color Table of the current image.
    * <p><b>GIF89a</b>: <i>If the Global Color Table Flag is set to 1, the value in this
@@ -128,7 +124,7 @@
   private GifHeader header;
   private int blockSize = 0;
 
-  public GifHeaderParser setData(ByteBuffer data) {
+  public GifHeaderParser setData(@NonNull ByteBuffer data) {
     reset();
     rawData = data.asReadOnlyBuffer();
     rawData.position(0);
@@ -136,7 +132,7 @@ public GifHeaderParser setData(ByteBuffer data) {
     return this;
   }
 
-  public GifHeaderParser setData(byte[] data) {
+  public GifHeaderParser setData(@Nullable byte[] data) {
     if (data != null) {
       setData(ByteBuffer.wrap(data));
     } else {
@@ -158,6 +154,7 @@ private void reset() {
     blockSize = 0;
   }
 
+  @NonNull
   public GifHeader parseHeader() {
     if (rawData == null) {
       throw new IllegalStateException("You must call setData() before parseHeader()");
@@ -225,11 +222,11 @@ private void readContents(int maxFrames) {
               break;
             case LABEL_APPLICATION_EXTENSION:
               readBlock();
-              String app = "";
+              StringBuilder app = new StringBuilder();
               for (int i = 0; i < 11; i++) {
-                app += (char) block[i];
+                app.append((char) block[i]);
               }
-              if (app.equals("NETSCAPE2.0")) {
+              if (app.toString().equals("NETSCAPE2.0")) {
                 readNetscapeExt();
               } else {
                 // Don't care.
@@ -366,11 +363,11 @@ private void readNetscapeExt() {
    * Reads GIF file header information.
    */
   private void readHeader() {
-    String id = "";
+    StringBuilder id = new StringBuilder();
     for (int i = 0; i < 6; i++) {
-      id += (char) read();
+      id.append((char) read());
     }
-    if (!id.startsWith("GIF")) {
+    if (!id.toString().startsWith("GIF")) {
       header.status = STATUS_FORMAT_ERROR;
       return;
     }
@@ -414,6 +411,7 @@ private void readLSD() {
    * @param nColors int number of colors to read.
    * @return int array containing 256 colors (packed ARGB with full alpha).
    */
+  @Nullable
   private int[] readColorTable(int nColors) {
     int nBytes = 3 * nColors;
     int[] tab = null;
@@ -467,10 +465,8 @@ private void skip() {
 
   /**
    * Reads next variable length block from input.
-   *
-   * @return number of bytes stored in "buffer"
    */
-  private int readBlock() {
+  private void readBlock() {
     blockSize = read();
     int n = 0;
     if (blockSize > 0) {
@@ -490,7 +486,6 @@ private int readBlock() {
         header.status = STATUS_FORMAT_ERROR;
       }
     }
-    return n;
   }
 
   /**
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
index 1c5eacf7d..a90011618 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -30,9 +30,9 @@
 
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
-import android.support.annotation.ColorInt;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import androidx.annotation.ColorInt;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.util.Log;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -87,21 +87,14 @@
   @ColorInt
   private final int[] pct = new int[256];
 
+  private final GifDecoder.BitmapProvider bitmapProvider;
+
   /** Raw GIF data from input source. */
   private ByteBuffer rawData;
 
   /** Raw data read working array. */
   private byte[] block;
 
-  private static final int WORK_BUFFER_SIZE = 16 * 1024;
-  /**
-   * Temporary buffer for block reading.
-   * Reads 16k chunks from the native buffer for processing, to greatly reduce JNI overhead.
-   */
-  @Nullable private byte[] workBuffer;
-  private int workBufferSize = 0;
-  private int workBufferPosition = 0;
-
   private GifHeaderParser parser;
 
   // LZW decoder working arrays.
@@ -114,7 +107,6 @@
 
   private int framePointer;
   private GifHeader header;
-  private GifDecoder.BitmapProvider bitmapProvider;
   private Bitmap previousImage;
   private boolean savePrevious;
   @GifDecodeStatus
@@ -122,24 +114,27 @@
   private int sampleSize;
   private int downsampledHeight;
   private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
+  @Nullable
+  private Boolean isFirstFrameTransparent;
   @NonNull
   private Bitmap.Config bitmapConfig = Config.ARGB_8888;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+      @NonNull GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
     this(provider, gifHeader, rawData, 1 /*sampleSize*/);
   }
 
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      @NonNull GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
       int sampleSize) {
     this(provider);
     setData(gifHeader, rawData, sampleSize);
   }
 
   public StandardGifDecoder(
-      GifDecoder.BitmapProvider provider) {
+      @NonNull GifDecoder.BitmapProvider provider) {
     this.bitmapProvider = provider;
     header = new GifHeader();
   }
@@ -154,6 +149,7 @@ public int getHeight() {
     return header.height;
   }
 
+  @NonNull
   @Override
   public ByteBuffer getData() {
     return rawData;
@@ -232,6 +228,7 @@ public int getByteSize() {
     return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
   }
 
+  @Nullable
   @Override
   public synchronized Bitmap getNextFrame() {
     if (header.frameCount <= 0 || framePointer < 0) {
@@ -251,6 +248,10 @@ public synchronized Bitmap getNextFrame() {
     }
     status = STATUS_OK;
 
+    if (block == null) {
+      block = bitmapProvider.obtainByteArray(255);
+    }
+
     GifFrame currentFrame = header.frames.get(framePointer);
     GifFrame previousFrame = null;
     int previousIndex = framePointer - 1;
@@ -277,6 +278,13 @@ public synchronized Bitmap getNextFrame() {
       act = pct;
       // Set transparent color if specified.
       act[currentFrame.transIndex] = COLOR_TRANSPARENT_BLACK;
+
+      if (currentFrame.dispose == DISPOSAL_BACKGROUND && framePointer == 0) {
+        // TODO: We should check and see if all individual pixels are replaced. If they are, the
+        // first frame isn't actually transparent. For now, it's simpler and safer to assume
+        // drawing a transparent background means the GIF contains transparency.
+        isFirstFrameTransparent = true;
+      }
     }
 
     // Transfer pixel data to image.
@@ -284,7 +292,7 @@ public synchronized Bitmap getNextFrame() {
   }
 
   @Override
-  public int read(InputStream is, int contentLength) {
+  public int read(@Nullable InputStream is, int contentLength) {
     if (is != null) {
       try {
         int capacity = (contentLength > 0) ? (contentLength + 4 * 1024) : 16 * 1024;
@@ -329,27 +337,25 @@ public void clear() {
     }
     previousImage = null;
     rawData = null;
-    isFirstFrameTransparent = false;
+    isFirstFrameTransparent = null;
     if (block != null) {
       bitmapProvider.release(block);
     }
-    if (workBuffer != null) {
-      bitmapProvider.release(workBuffer);
-    }
   }
 
   @Override
-  public synchronized void setData(GifHeader header, byte[] data) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull byte[] data) {
     setData(header, ByteBuffer.wrap(data));
   }
 
   @Override
-  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer) {
     setData(header, buffer, 1);
   }
 
   @Override
-  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
+  public synchronized void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer,
+      int sampleSize) {
     if (sampleSize <= 0) {
       throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
     }
@@ -357,7 +363,6 @@ public synchronized void setData(GifHeader header, ByteBuffer buffer, int sample
     sampleSize = Integer.highestOneBit(sampleSize);
     this.status = STATUS_OK;
     this.header = header;
-    isFirstFrameTransparent = false;
     framePointer = INITIAL_FRAME_POINTER;
     // Initialize the raw data buffer.
     rawData = buffer.asReadOnlyBuffer();
@@ -382,6 +387,7 @@ public synchronized void setData(GifHeader header, ByteBuffer buffer, int sample
     mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);
   }
 
+  @NonNull
   private GifHeaderParser getHeaderParser() {
     if (parser == null) {
       parser = new GifHeaderParser();
@@ -391,7 +397,7 @@ private GifHeaderParser getHeaderParser() {
 
   @Override
   @GifDecodeStatus
-  public synchronized int read(byte[] data) {
+  public synchronized int read(@Nullable byte[] data) {
     this.header = getHeaderParser().setData(data).parseHeader();
     if (data != null) {
       setData(header, data);
@@ -401,7 +407,7 @@ public synchronized int read(byte[] data) {
   }
 
   @Override
-  public void setDefaultBitmapFormat(Bitmap.Config config) {
+  public void setDefaultBitmapConfig(@NonNull Bitmap.Config config) {
     if (config != Bitmap.Config.ARGB_8888 && config != Bitmap.Config.RGB_565) {
       throw new IllegalArgumentException("Unsupported format: " + config
           + ", must be one of " + Bitmap.Config.ARGB_8888 + " or " + Bitmap.Config.RGB_565);
@@ -418,8 +424,20 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     // Final location of blended pixels.
     final int[] dest = mainScratch;
 
-    // clear all pixels when meet first frame
+    // clear all pixels when meet first frame and drop prev image from last loop
     if (previousFrame == null) {
+      if (previousImage != null) {
+        bitmapProvider.release(previousImage);
+      }
+      previousImage = null;
+      Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
+    }
+
+    // clear all pixels when dispose is 3 but previousImage is null.
+    // When DISPOSAL_PREVIOUS and previousImage didn't be set, new frame should draw on
+    // a empty image
+    if (previousFrame != null && previousFrame.dispose == DISPOSAL_PREVIOUS
+            && previousImage == null) {
       Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
     }
 
@@ -435,11 +453,6 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
           if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {
             c = COLOR_TRANSPARENT_BLACK;
           }
-        } else if (framePointer == 0) {
-          // TODO: We should check and see if all individual pixels are replaced. If they are, the
-          // first frame isn't actually transparent. For now, it's simpler and safer to assume
-          // drawing a transparent background means the GIF contains transparency.
-          isFirstFrameTransparent = true;
         }
         // The area used by the graphic must be restored to the background color.
         int downsampledIH = previousFrame.ih / sampleSize;
@@ -464,6 +477,77 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     // Decode pixels for this frame into the global pixels[] scratch.
     decodeBitmapData(currentFrame);
 
+    if (currentFrame.interlace || sampleSize != 1) {
+      copyCopyIntoScratchRobust(currentFrame);
+    } else {
+      copyIntoScratchFast(currentFrame);
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  private void copyIntoScratchFast(GifFrame currentFrame) {
+    int[] dest = mainScratch;
+    int downsampledIH = currentFrame.ih;
+    int downsampledIY = currentFrame.iy;
+    int downsampledIW = currentFrame.iw;
+    int downsampledIX = currentFrame.ix;
+    // Copy each source line to the appropriate place in the destination.
+    boolean isFirstFrame = framePointer == 0;
+    int width = this.downsampledWidth;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    byte transparentColorIndex = -1;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i + downsampledIY;
+      int k = line * width;
+      // Start of line in dest.
+      int dx = k + downsampledIX;
+      // End of dest line.
+      int dlim = dx + downsampledIW;
+      if (k + width < dlim) {
+        // Past dest edge.
+        dlim = k + width;
+      }
+      // Start of line in source.
+      int sx = i * currentFrame.iw;
+
+      while (dx < dlim) {
+        byte byteCurrentColorIndex = mainPixels[sx];
+        int currentColorIndex = ((int) byteCurrentColorIndex) & MASK_INT_LOWEST_BYTE;
+        if (currentColorIndex != transparentColorIndex) {
+          int color = act[currentColorIndex];
+          if (color != COLOR_TRANSPARENT_BLACK) {
+            dest[dx] = color;
+          } else {
+            transparentColorIndex = byteCurrentColorIndex;
+          }
+        }
+        ++sx;
+        ++dx;
+      }
+    }
+
+    isFirstFrameTransparent =
+        (isFirstFrameTransparent != null && isFirstFrameTransparent)
+            || (isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1);
+  }
+
+  private void copyCopyIntoScratchRobust(GifFrame currentFrame) {
+    int[] dest = mainScratch;
     int downsampledIH = currentFrame.ih / sampleSize;
     int downsampledIY = currentFrame.iy / sampleSize;
     int downsampledIW = currentFrame.iw / sampleSize;
@@ -473,6 +557,13 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     int inc = 8;
     int iline = 0;
     boolean isFirstFrame = framePointer == 0;
+    int sampleSize = this.sampleSize;
+    int downsampledWidth = this.downsampledWidth;
+    int downsampledHeight = this.downsampledHeight;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    @Nullable
+    Boolean isFirstFrameTransparent = this.isFirstFrameTransparent;
     for (int i = 0; i < downsampledIH; i++) {
       int line = i;
       if (currentFrame.interlace) {
@@ -498,6 +589,7 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
         iline += inc;
       }
       line += downsampledIY;
+      boolean isNotDownsampling = sampleSize == 1;
       if (line < downsampledHeight) {
         int k = line * downsampledWidth;
         // Start of line in dest.
@@ -510,43 +602,43 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
         }
         // Start of line in source.
         int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          @ColorInt int averageColor;
-          if (sampleSize == 1) {
+        if (isNotDownsampling) {
+          int averageColor;
+          while (dx < dlim) {
             int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;
             averageColor = act[currentColorIndex];
-          } else {
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && isFirstFrameTransparent == null) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
+          }
+        } else {
+          int averageColor;
+          int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+          while (dx < dlim) {
+            // Map color and insert in destination.
             // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the
             // current color index above, even with a sample size of 1.
             averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && isFirstFrameTransparent == null) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
           }
-          if (averageColor != COLOR_TRANSPARENT_BLACK) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
         }
       }
     }
 
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
+    if (this.isFirstFrameTransparent == null) {
+      this.isFirstFrameTransparent = isFirstFrameTransparent == null
+          ? false : isFirstFrameTransparent;
     }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
   }
 
   @ColorInt
@@ -600,8 +692,6 @@ private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPix
    * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
    */
   private void decodeBitmapData(GifFrame frame) {
-    workBufferSize = 0;
-    workBufferPosition = 0;
     if (frame != null) {
       // Jump to the frame start position.
       rawData.position(frame.bufferFrameStart);
@@ -615,15 +705,19 @@ private void decodeBitmapData(GifFrame frame) {
       // Allocate new pixel array.
       mainPixels = bitmapProvider.obtainByteArray(npix);
     }
+    byte[] mainPixels = this.mainPixels;
     if (prefix == null) {
       prefix = new short[MAX_STACK_SIZE];
     }
+    short[] prefix = this.prefix;
     if (suffix == null) {
       suffix = new byte[MAX_STACK_SIZE];
     }
+    byte[] suffix = this.suffix;
     if (pixelStack == null) {
       pixelStack = new byte[MAX_STACK_SIZE + 1];
     }
+    byte[] pixelStack = this.pixelStack;
 
     // Initialize GIF data stream decoder.
     dataSize = readByte();
@@ -633,18 +727,18 @@ private void decodeBitmapData(GifFrame frame) {
     oldCode = NULL_CODE;
     codeSize = dataSize + 1;
     codeMask = (1 << codeSize) - 1;
+
     for (code = 0; code < clear; code++) {
       // XXX ArrayIndexOutOfBoundsException.
       prefix[code] = 0;
       suffix[code] = (byte) code;
     }
-
+    byte[] block = this.block;
     // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
+    i = datum = bits = count = first = top = pi = bi = 0;
+    while (i < npix) {
+      // Read a new data block.
       if (count == 0) {
-        // Read a new data block.
         count = readBlock();
         if (count <= 0) {
           status = STATUS_PARTIAL_DECODE;
@@ -655,8 +749,8 @@ private void decodeBitmapData(GifFrame frame) {
 
       datum += (((int) block[bi]) & MASK_INT_LOWEST_BYTE) << bits;
       bits += 8;
-      bi++;
-      count--;
+      ++bi;
+      --count;
 
       while (bits >= codeSize) {
         // Get the next code.
@@ -672,87 +766,65 @@ private void decodeBitmapData(GifFrame frame) {
           available = clear + 2;
           oldCode = NULL_CODE;
           continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-
-        if (code == endOfInformation) {
+        } else if (code == endOfInformation) {
           break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
+        } else if (oldCode == NULL_CODE) {
+          mainPixels[pi] = suffix[code];
+          ++pi;
+          ++i;
           oldCode = code;
           first = code;
           continue;
         }
+
         inCode = code;
         if (code >= available) {
-          pixelStack[top++] = (byte) first;
+          pixelStack[top] = (byte) first;
+          ++top;
           code = oldCode;
         }
+
         while (code >= clear) {
-          pixelStack[top++] = suffix[code];
+          pixelStack[top] = suffix[code];
+          ++top;
           code = prefix[code];
         }
         first = ((int) suffix[code]) & MASK_INT_LOWEST_BYTE;
-        pixelStack[top++] = (byte) first;
+
+        mainPixels[pi] = (byte) first;
+        ++pi;
+        ++i;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi] = pixelStack[--top];
+          ++pi;
+          ++i;
+        }
 
         // Add a new string to the string table.
         if (available < MAX_STACK_SIZE) {
           prefix[available] = (short) oldCode;
           suffix[available] = (byte) first;
-          available++;
+          ++available;
           if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
+            ++codeSize;
             codeMask += available;
           }
         }
         oldCode = inCode;
-
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
       }
     }
 
     // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = COLOR_TRANSPARENT_BLACK;
-    }
-  }
-
-  /**
-   * Reads the next chunk for the intermediate work buffer.
-   */
-  private void readChunkIfNeeded() {
-    if (workBufferSize > workBufferPosition) {
-      return;
-    }
-    if (workBuffer == null) {
-      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
-    }
-    workBufferPosition = 0;
-    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
-    rawData.get(workBuffer, 0, workBufferSize);
+    Arrays.fill(mainPixels, pi, npix, (byte) COLOR_TRANSPARENT_BLACK);
   }
 
   /**
    * Reads a single byte from the input stream.
    */
   private int readByte() {
-    try {
-      readChunkIfNeeded();
-      return workBuffer[workBufferPosition++] & MASK_INT_LOWEST_BYTE;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-      return 0;
-    }
+    return rawData.get() & MASK_INT_LOWEST_BYTE;
   }
 
   /**
@@ -762,37 +834,15 @@ private int readByte() {
    */
   private int readBlock() {
     int blockSize = readByte();
-    if (blockSize > 0) {
-      try {
-        if (block == null) {
-          block = bitmapProvider.obtainByteArray(255);
-        }
-        final int remaining = workBufferSize - workBufferPosition;
-        if (remaining >= blockSize) {
-          // Block can be read from the current work buffer.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
-          workBufferPosition += blockSize;
-        } else if (rawData.remaining() + remaining >= blockSize) {
-          // Block can be read in two passes.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
-          workBufferPosition = workBufferSize;
-          readChunkIfNeeded();
-          final int secondHalfRemaining = blockSize - remaining;
-          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
-          workBufferPosition += secondHalfRemaining;
-        } else {
-          status = STATUS_FORMAT_ERROR;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
+    if (blockSize <= 0) {
+      return blockSize;
     }
+    rawData.get(block, 0, Math.min(blockSize, rawData.remaining()));
     return blockSize;
   }
 
   private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
+    Bitmap.Config config = isFirstFrameTransparent == null || isFirstFrameTransparent
         ? Bitmap.Config.ARGB_8888 : bitmapConfig;
     Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
     result.setHasAlpha(true);
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 13a581303..5f16febb5 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -6,7 +6,7 @@
 import static org.robolectric.Shadows.shadowOf;
 
 import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
+import androidx.annotation.NonNull;
 import com.bumptech.glide.testutil.TestUtil;
 import java.io.IOException;
 import java.util.Arrays;
@@ -20,11 +20,9 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowBitmap;
 
-/**
- * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
- */
+/** Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(sdk = 18)
 public class GifDecoderTest {
 
   private MockProvider provider;
@@ -34,6 +32,21 @@ public void setUp() {
     provider = new MockProvider();
   }
 
+  @Test
+  public void testCorrectPixelsDecoded() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "white_black_row.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap bitmap = decoder.getNextFrame();
+    assertNotNull(bitmap);
+    assertEquals(bitmap.getPixel(2, 0), bitmap.getPixel(0, 0));
+    assertEquals(bitmap.getPixel(3, 0), bitmap.getPixel(1, 0));
+  }
+
   @Test
   public void testCanDecodeFramesFromTestGif() throws IOException {
     byte[] data = TestUtil.resourceToBytes(getClass(), "partial_gif_decode.gif");
@@ -197,27 +210,29 @@ public Bitmap obtain(int width, int height, Bitmap.Config config) {
     }
 
     @Override
-    public void release(Bitmap bitmap) {
+    public void release(@NonNull Bitmap bitmap) {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public byte[] obtainByteArray(int size) {
       return new byte[size];
     }
 
     @Override
-    public void release(byte[] bytes) {
+    public void release(@NonNull byte[] bytes) {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public int[] obtainIntArray(int size) {
       return new int[size];
     }
 
     @Override
-    public void release(int[] array) {
+    public void release(@NonNull int[] array) {
       // Do Nothing
     }
 
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index 55dfa41a4..8fc2efa9e 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -122,7 +122,7 @@ public void testCanReadImageDescriptorWithoutGraphicalExtension() {
     final int lzwMinCodeSize = 2;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
     GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
@@ -140,7 +140,7 @@ private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH
             + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
@@ -204,7 +204,7 @@ public void testSetsFrameLocalColorTableToNullIfNoColorTable() {
     final int lzwMinCodeSize = 2;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
     GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
@@ -224,7 +224,7 @@ public void testSetsFrameLocalColorTableIfHasColorTable() {
     final int numColors = 4;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize) + GifBytesTestUtil.getColorTableLength(numColors))
+            .getImageDataSize() + GifBytesTestUtil.getColorTableLength(numColors))
         .order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, true /*hasLct*/, numColors);
@@ -248,7 +248,7 @@ public void testCanParseMultipleFrames() {
     final int expectedFrames = 3;
 
     final int frameSize = GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-        .getImageDataSize(lzwMinCodeSize);
+        .getImageDataSize();
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + expectedFrames * frameSize)
             .order(ByteOrder.LITTLE_ENDIAN);
@@ -272,7 +272,7 @@ public void testIsAnimatedMultipleFrames() {
 
     final int frameSize =
         GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+            + GifBytesTestUtil.getImageDataSize();
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
             .order(ByteOrder.LITTLE_ENDIAN);
@@ -293,7 +293,7 @@ public void testIsNotAnimatedOneFrame() {
 
     final int frameSize =
         GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+            + GifBytesTestUtil.getImageDataSize();
 
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
index 7a32733a6..4752afc3c 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
@@ -17,7 +17,7 @@ public static int getColorTableLength(int numColors) {
     return 3 * numColors;
   }
 
-  public static int getImageDataSize(int lzwMinCodeSize) {
+  public static int getImageDataSize() {
     // TODO: fill this out.
     return 4;
   }
@@ -78,7 +78,7 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
     // Version - 89a.
     out.put((byte) 0x38).put((byte) 0x39).put((byte) 0x61);
 
-    /** LSD (Logical Screen Descriptor) **/
+    /* LSD (Logical Screen Descriptor) **/
     // Width.
     out.putShort((short) width);
     // Height.
@@ -89,7 +89,7 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
     // Color resolution - next three bits.
     byte colorResolution = 1 << 5;
     // Sort flag - next bit;
-    byte sortFlag = 0 << 4;
+    byte sortFlag = 0;
     // exponent of size of color table, size = 2^(1 + exponent) - least significant 3 bits.
     byte size = (byte) gctSize;
 
diff --git a/third_party/gif_decoder/src/test/resources/white_black_row.gif b/third_party/gif_decoder/src/test/resources/white_black_row.gif
new file mode 100644
index 000000000..ca7f1cb96
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/white_black_row.gif differ
diff --git a/third_party/gif_encoder/src/main/AndroidManifest.xml b/third_party/gif_encoder/src/main/AndroidManifest.xml
index 77f17b142..0b4b09c39 100644
--- a/third_party/gif_encoder/src/main/AndroidManifest.xml
+++ b/third_party/gif_encoder/src/main/AndroidManifest.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide.gifencoder">
+<manifest
+  package="com.bumptech.glide.gifencoder">
   <application />
 </manifest>
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index 7bb25acab..e4e381c9e 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -4,6 +4,8 @@
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import android.util.Log;
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
@@ -152,7 +154,7 @@ public void setTransparent(int color) {
      *          BufferedImage containing frame to write.
      * @return true if successful.
      */
-    public boolean addFrame(Bitmap im) {
+    public boolean addFrame(@Nullable Bitmap im) {
         return addFrame(im, 0, 0);
     }
 
@@ -175,7 +177,7 @@ public boolean addFrame(Bitmap im) {
      *          the Logical Screen.
      * @return true if successful.
      */
-    public boolean addFrame(Bitmap im, int x, int y) {
+    public boolean addFrame(@Nullable Bitmap im, int x, int y) {
         if ((im == null) || !started) {
             return false;
         }
@@ -318,7 +320,7 @@ private void setFrameSize(int w, int h) {
      *          OutputStream on which GIF images are written.
      * @return false if initial write failed.
      */
-    public boolean start(OutputStream os) {
+    public boolean start(@Nullable OutputStream os) {
         if (os == null)
             return false;
         boolean ok = true;
@@ -339,8 +341,8 @@ public boolean start(OutputStream os) {
      *          String containing output file name.
      * @return false if open or initial write failed.
      */
-    public boolean start(String file) {
-        boolean ok = true;
+    public boolean start(@NonNull String file) {
+        boolean ok;
         try {
             out = new BufferedOutputStream(new FileOutputStream(file));
             ok = start(out);
