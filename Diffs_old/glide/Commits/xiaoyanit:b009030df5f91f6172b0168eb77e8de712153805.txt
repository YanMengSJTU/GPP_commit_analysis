diff --git a/.gitignore b/.gitignore
index d8563abe9..6a64b1779 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,37 +1,42 @@
-.gradle
-build
-*.iws
-doc/**
-bin/**
-library/bin/*
-library/gen/*
-library/.gradle
-library/.settings
-library/target
-library/install_dependencies/maven-android-sdk-deployer
-.idea/libraries
-.idea/workspace.xml
-.idea/tasks.xml
-.idea/gradle.xml
-.idea/dictionaries
-.idea/dataSources.ids
-.idea/datasources.xml
-library/.idea
-samples/**/.idea
+# Android
+local.properties
+*.keystore
 *.DS_Store
-*.swp
-*.swo
 proguard-project.txt
-samples/flickr/gen
-samples/flickr/out
-samples/flickr/bin
-samples/flickr/target
-integration/volley/target/**
-**local.properties
-*.keystore
-.settings
-/library/.classpath
-/library/.project
+
+# Gradle
+**/.gradle
+**/.settings
+**/build
+
+# gh-pages
+doc/**
+_site/*
+_pages/*
 docs/**/*
-**/out/**
-**/gen-external-apklibs/**
+
+# Vim
+*.swp
+*.swo
+
+# Intellij 
+*.ipr
+*.iml
+*.iws
+**/.idea/.name
+**/.idea/compiler.xml
+**/.idea/copyright/profiles_settings.xml
+**/.idea/encodings.xml
+**/.idea/misc.xml
+**/.idea/modules.xml
+**/.idea/scopes/scope_settings.xml
+**/.idea/vcs.xml
+**/.idea/libraries
+**/.idea/workspace.xml
+**/.idea/tasks.xml
+**/.idea/gradle.xml
+**/.idea/dictionaries
+**/.idea/dataSources.ids
+**/.idea/datasources.xml
+**/.idea/uiDesigner.xml
+**/.idea/runConfigurations.xml
diff --git a/.gitmodules b/.gitmodules
index 2a0e578c9..525eef67a 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -7,3 +7,6 @@
 [submodule "library/src/androidTest/resources/exif-orientation-examples"]
 	path = library/src/androidTest/resources/exif-orientation-examples
 	url = https://github.com/recurser/exif-orientation-examples.git
+[submodule "library/src/test/resources/exif-orientation-examples"]
+	path = library/src/test/resources/exif-orientation-examples
+	url = https://github.com/recurser/exif-orientation-examples
diff --git a/.idea/.name b/.idea/.name
deleted file mode 100644
index 325497f4e..000000000
--- a/.idea/.name
+++ /dev/null
@@ -1 +0,0 @@
-glide-parent
\ No newline at end of file
diff --git a/.idea/androidDexCompiler.xml b/.idea/androidDexCompiler.xml
deleted file mode 100644
index d87fc2258..000000000
--- a/.idea/androidDexCompiler.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="AndroidDexCompilerConfiguration">
-    <option name="MAX_HEAP_SIZE" value="1024" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/checkstyle-idea.xml b/.idea/checkstyle-idea.xml
deleted file mode 100644
index f103cb3c7..000000000
--- a/.idea/checkstyle-idea.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="CheckStyle-IDEA">
-    <option name="configuration">
-      <map>
-        <entry key="active-configuration" value="LOCAL_FILE:$PRJ_DIR$/checkstyle.xml:Glide checkstyle" />
-        <entry key="check-nonjava-files" value="false" />
-        <entry key="check-test-classes" value="false" />
-        <entry key="location-0" value="CLASSPATH:/sun_checks.xml:The default CheckStyle rules" />
-        <entry key="location-1" value="LOCAL_FILE:$PRJ_DIR$/checkstyle.xml:Glide checkstyle" />
-        <entry key="property-1.checkStyleConfigDir" value="$PROJECT_DIR$" />
-        <entry key="suppress-errors" value="false" />
-        <entry key="thirdparty-classpath" value="" />
-      </map>
-    </option>
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index 39889475f..536c52938 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -3,14 +3,22 @@
   <component name="ProjectCodeStyleSettingsManager">
     <option name="PER_PROJECT_SETTINGS">
       <value>
+        <option name="OTHER_INDENT_OPTIONS">
+          <value>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+            <option name="USE_TAB_CHARACTER" value="false" />
+            <option name="SMART_TABS" value="false" />
+            <option name="LABEL_INDENT_SIZE" value="0" />
+            <option name="LABEL_INDENT_ABSOLUTE" value="false" />
+            <option name="USE_RELATIVE_INDENTS" value="false" />
+          </value>
+        </option>
         <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
         <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
-        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
-          <value />
-        </option>
         <option name="IMPORT_LAYOUT_TABLE">
           <value>
-            <package name="com.google" withSubpackages="true" static="true" />
             <package name="" withSubpackages="true" static="true" />
             <emptyLine />
             <package name="com.google" withSubpackages="true" static="false" />
@@ -183,8 +191,6 @@
             <emptyLine />
             <package name="org" withSubpackages="true" static="false" />
             <emptyLine />
-            <package name="oz" withSubpackages="true" static="false" />
-            <emptyLine />
             <package name="penn2dg" withSubpackages="true" static="false" />
             <emptyLine />
             <package name="pennconverter" withSubpackages="true" static="false" />
@@ -205,8 +211,6 @@
             <emptyLine />
             <package name="simple" withSubpackages="true" static="false" />
             <emptyLine />
-            <package name="social" withSubpackages="true" static="false" />
-            <emptyLine />
             <package name="soot" withSubpackages="true" static="false" />
             <emptyLine />
             <package name="sqlj" withSubpackages="true" static="false" />
@@ -248,27 +252,72 @@
             <package name="javax" withSubpackages="true" static="false" />
             <emptyLine />
             <package name="" withSubpackages="true" static="false" />
+            <emptyLine />
+            <emptyLine />
           </value>
         </option>
-        <option name="WRAP_WHEN_TYPING_REACHES_RIGHT_MARGIN" value="true" />
-        <AndroidXmlCodeStyleSettings>
-          <option name="USE_CUSTOM_SETTINGS" value="true" />
-        </AndroidXmlCodeStyleSettings>
+        <option name="RIGHT_MARGIN" value="100" />
+        <option name="JD_P_AT_EMPTY_LINES" value="false" />
+        <option name="JD_KEEP_EMPTY_PARAMETER" value="false" />
+        <option name="JD_KEEP_EMPTY_EXCEPTION" value="false" />
+        <option name="JD_KEEP_EMPTY_RETURN" value="false" />
+        <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
+        <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+        <option name="BLANK_LINES_AFTER_CLASS_HEADER" value="1" />
+        <option name="ALIGN_MULTILINE_PARAMETERS_IN_CALLS" value="true" />
+        <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="true" />
+        <option name="ALIGN_MULTILINE_ASSIGNMENT" value="true" />
+        <option name="ALIGN_MULTILINE_TERNARY_OPERATION" value="true" />
+        <option name="ALIGN_MULTILINE_THROWS_LIST" value="true" />
+        <option name="ALIGN_MULTILINE_EXTENDS_LIST" value="true" />
+        <option name="ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION" value="true" />
+        <option name="ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION" value="true" />
+        <option name="CALL_PARAMETERS_WRAP" value="1" />
+        <option name="METHOD_PARAMETERS_WRAP" value="1" />
+        <option name="EXTENDS_LIST_WRAP" value="1" />
+        <option name="THROWS_LIST_WRAP" value="1" />
+        <option name="EXTENDS_KEYWORD_WRAP" value="1" />
+        <option name="THROWS_KEYWORD_WRAP" value="1" />
+        <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+        <option name="BINARY_OPERATION_WRAP" value="1" />
+        <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+        <option name="TERNARY_OPERATION_WRAP" value="1" />
+        <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+        <option name="FOR_STATEMENT_WRAP" value="1" />
+        <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+        <option name="ASSIGNMENT_WRAP" value="5" />
+        <option name="WRAP_COMMENTS" value="true" />
+        <option name="IF_BRACE_FORCE" value="3" />
+        <option name="DOWHILE_BRACE_FORCE" value="3" />
+        <option name="WHILE_BRACE_FORCE" value="3" />
+        <option name="FOR_BRACE_FORCE" value="3" />
         <XML>
           <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
         </XML>
+        <ADDITIONAL_INDENT_OPTIONS fileType="haml">
+          <option name="INDENT_SIZE" value="2" />
+        </ADDITIONAL_INDENT_OPTIONS>
+        <ADDITIONAL_INDENT_OPTIONS fileType="java">
+          <option name="INDENT_SIZE" value="2" />
+          <option name="CONTINUATION_INDENT_SIZE" value="4" />
+          <option name="TAB_SIZE" value="8" />
+        </ADDITIONAL_INDENT_OPTIONS>
+        <ADDITIONAL_INDENT_OPTIONS fileType="js">
+          <option name="CONTINUATION_INDENT_SIZE" value="4" />
+        </ADDITIONAL_INDENT_OPTIONS>
+        <ADDITIONAL_INDENT_OPTIONS fileType="sass">
+          <option name="INDENT_SIZE" value="2" />
+        </ADDITIONAL_INDENT_OPTIONS>
+        <ADDITIONAL_INDENT_OPTIONS fileType="yml">
+          <option name="INDENT_SIZE" value="2" />
+        </ADDITIONAL_INDENT_OPTIONS>
         <codeStyleSettings language="JAVA">
           <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
-          <option name="ALIGN_MULTILINE_FOR" value="false" />
-        </codeStyleSettings>
-        <codeStyleSettings language="XML">
-          <option name="FORCE_REARRANGE_MODE" value="1" />
           <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
             <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
           </indentOptions>
-          <arrangement>
-            <rules />
-          </arrangement>
         </codeStyleSettings>
       </value>
     </option>
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
deleted file mode 100644
index 9a8b7e5c4..000000000
--- a/.idea/compiler.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="CompilerConfiguration">
-    <option name="DEFAULT_COMPILER" value="Javac" />
-    <resourceExtensions />
-    <wildcardResourcePatterns>
-      <entry name="!?*.java" />
-      <entry name="!?*.form" />
-      <entry name="!?*.class" />
-      <entry name="!?*.groovy" />
-      <entry name="!?*.scala" />
-      <entry name="!?*.flex" />
-      <entry name="!?*.kt" />
-      <entry name="!?*.clj" />
-    </wildcardResourcePatterns>
-    <annotationProcessing>
-      <profile default="true" name="Default" enabled="false">
-        <processorPath useClasspath="true" />
-      </profile>
-    </annotationProcessing>
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/copyright/profiles_settings.xml b/.idea/copyright/profiles_settings.xml
deleted file mode 100644
index e7bedf337..000000000
--- a/.idea/copyright/profiles_settings.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<component name="CopyrightManager">
-  <settings default="" />
-</component>
\ No newline at end of file
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
deleted file mode 100644
index e206d70d8..000000000
--- a/.idea/encodings.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="Encoding" useUTFGuessing="true" native2AsciiForPropertiesFiles="false" />
-</project>
-
diff --git a/.idea/groovyc.xml b/.idea/groovyc.xml
deleted file mode 100644
index 7d42f3ab1..000000000
--- a/.idea/groovyc.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="GroovyCompilerProjectConfiguration">
-    <option name="heapSize" value="2048" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
deleted file mode 100644
index 79365f371..000000000
--- a/.idea/inspectionProfiles/Project_Default.xml
+++ /dev/null
@@ -1,14 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <profile version="1.0" is_locked="false">
-    <option name="myName" value="Project Default" />
-    <option name="myLocal" value="false" />
-    <inspection_tool class="AndroidLintGradleDependency" enabled="false" level="WARNING" enabled_by_default="false" />
-    <inspection_tool class="CheckStyle-IDEA" enabled="true" level="ERROR" enabled_by_default="true" />
-    <inspection_tool class="LoggerInitializedWithForeignClass" enabled="false" level="WARNING" enabled_by_default="false">
-      <option name="loggerClassName" value="org.apache.log4j.Logger,org.slf4j.LoggerFactory,org.apache.commons.logging.LogFactory,java.util.logging.Logger" />
-      <option name="loggerFactoryMethodName" value="getLogger,getLogger,getLog,getLogger" />
-    </inspection_tool>
-    <inspection_tool class="OnDemandImport" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="SamePackageImport" enabled="true" level="WARNING" enabled_by_default="true" />
-  </profile>
-</component>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
deleted file mode 100644
index 3b312839b..000000000
--- a/.idea/inspectionProfiles/profiles_settings.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <settings>
-    <option name="PROJECT_PROFILE" value="Project Default" />
-    <option name="USE_PROJECT_PROFILE" value="true" />
-    <version value="1.0" />
-  </settings>
-</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
deleted file mode 100644
index 19736e2de..000000000
--- a/.idea/misc.xml
+++ /dev/null
@@ -1,162 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="CompilerConfiguration">
-    <option name="DEFAULT_COMPILER" />
-    <resourceExtensions />
-    <wildcardResourcePatterns>
-      <entry name="!?*.java" />
-      <entry name="!?*.form" />
-      <entry name="!?*.class" />
-      <entry name="!?*.groovy" />
-      <entry name="!?*.scala" />
-      <entry name="!?*.flex" />
-      <entry name="!?*.kt" />
-      <entry name="!?*.clj" />
-    </wildcardResourcePatterns>
-    <annotationProcessing>
-      <profile default="true" name="Default" enabled="false">
-        <processorPath useClasspath="true" />
-      </profile>
-    </annotationProcessing>
-  </component>
-  <component name="CopyrightManager" default="" />
-  <component name="DaemonCodeAnalyzer">
-    <disable_hints />
-  </component>
-  <component name="DependencyValidationManager">
-    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
-  </component>
-  <component name="Encoding" useUTFGuessing="true" native2AsciiForPropertiesFiles="false" />
-  <component name="EntryPointsManager">
-    <entry_points version="2.0" />
-  </component>
-  <component name="FrameworkDetectionExcludesConfiguration">
-    <file type="web" url="file://$PROJECT_DIR$" />
-  </component>
-  <component name="GradleLocalSettings">
-    <option name="modificationStamps">
-      <map>
-        <entry key="$PROJECT_DIR$" value="19825412166063" />
-      </map>
-    </option>
-  </component>
-  <component name="IdProvider" IDEtalkID="E5D7B560A0002A20C790AA32CD25F711" />
-  <component name="ProjectLevelVcsManager" settingsEditedManually="false">
-    <OptionsSetting value="true" id="Add" />
-    <OptionsSetting value="true" id="Remove" />
-    <OptionsSetting value="true" id="Checkout" />
-    <OptionsSetting value="true" id="Update" />
-    <OptionsSetting value="true" id="Status" />
-    <OptionsSetting value="true" id="Edit" />
-    <ConfirmationsSetting value="0" id="Add" />
-    <ConfirmationsSetting value="0" id="Remove" />
-  </component>
-  <component name="ProjectModuleManager">
-    <modules />
-  </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_6" assert-keyword="true" jdk-15="true" project-jdk-name="1.6" project-jdk-type="JavaSDK">
-    <output url="file://$PROJECT_DIR$/build/classes" />
-  </component>
-  <component name="PropertiesComponent">
-    <property name="GoToClass.includeLibraries" value="false" />
-    <property name="GoToClass.toSaveIncludeLibraries" value="false" />
-    <property name="GoToFile.includeJavaFiles" value="false" />
-    <property name="MemberChooser.sorted" value="false" />
-    <property name="MemberChooser.showClasses" value="true" />
-    <property name="MemberChooser.copyJavadoc" value="false" />
-  </component>
-  <component name="RunManager">
-    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
-      <module name="" />
-      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
-      <option name="PROGRAM_PARAMETERS" />
-      <method />
-    </configuration>
-    <configuration default="true" type="Remote" factoryName="Remote">
-      <option name="USE_SOCKET_TRANSPORT" value="true" />
-      <option name="SERVER_MODE" value="false" />
-      <option name="SHMEM_ADDRESS" value="javadebug" />
-      <option name="HOST" value="localhost" />
-      <option name="PORT" value="5005" />
-      <method />
-    </configuration>
-    <configuration default="true" type="Applet" factoryName="Applet">
-      <module name="" />
-      <option name="MAIN_CLASS_NAME" />
-      <option name="HTML_FILE_NAME" />
-      <option name="HTML_USED" value="false" />
-      <option name="WIDTH" value="400" />
-      <option name="HEIGHT" value="300" />
-      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
-      <option name="VM_PARAMETERS" />
-      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-      <option name="ALTERNATIVE_JRE_PATH" />
-      <method />
-    </configuration>
-    <configuration default="true" type="TestNG" factoryName="TestNG">
-      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-      <module name="" />
-      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-      <option name="ALTERNATIVE_JRE_PATH" />
-      <option name="SUITE_NAME" />
-      <option name="PACKAGE_NAME" />
-      <option name="MAIN_CLASS_NAME" />
-      <option name="METHOD_NAME" />
-      <option name="GROUP_NAME" />
-      <option name="TEST_OBJECT" value="CLASS" />
-      <option name="VM_PARAMETERS" value="-ea" />
-      <option name="PARAMETERS" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-      <option name="OUTPUT_DIRECTORY" />
-      <option name="ANNOTATION_TYPE" />
-      <option name="ENV_VARIABLES" />
-      <option name="PASS_PARENT_ENVS" value="true" />
-      <option name="TEST_SEARCH_SCOPE">
-        <value defaultName="singleModule" />
-      </option>
-      <option name="USE_DEFAULT_REPORTERS" value="false" />
-      <option name="PROPERTIES_FILE" />
-      <envs />
-      <properties />
-      <listeners />
-      <method />
-    </configuration>
-    <configuration default="true" type="Application" factoryName="Application">
-      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-      <option name="MAIN_CLASS_NAME" />
-      <option name="VM_PARAMETERS" />
-      <option name="PROGRAM_PARAMETERS" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
-      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-      <option name="ALTERNATIVE_JRE_PATH" />
-      <option name="ENABLE_SWING_INSPECTOR" value="false" />
-      <option name="ENV_VARIABLES" />
-      <option name="PASS_PARENT_ENVS" value="true" />
-      <module name="" />
-      <envs />
-      <method />
-    </configuration>
-    <configuration default="true" type="JUnit" factoryName="JUnit">
-      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
-      <module name="" />
-      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
-      <option name="ALTERNATIVE_JRE_PATH" />
-      <option name="PACKAGE_NAME" />
-      <option name="MAIN_CLASS_NAME" />
-      <option name="METHOD_NAME" />
-      <option name="TEST_OBJECT" value="class" />
-      <option name="VM_PARAMETERS" value="-ea" />
-      <option name="PARAMETERS" />
-      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
-      <option name="ENV_VARIABLES" />
-      <option name="PASS_PARENT_ENVS" value="true" />
-      <option name="TEST_SEARCH_SCOPE">
-        <value defaultName="singleModule" />
-      </option>
-      <envs />
-      <patterns />
-      <method />
-    </configuration>
-    <list size="0" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
deleted file mode 100644
index adda73dd2..000000000
--- a/.idea/modules.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/third_party/disklrucache/disklrucache.iml" filepath="$PROJECT_DIR$/third_party/disklrucache/disklrucache.iml" />
-      <module fileurl="file://$PROJECT_DIR$/samples/flickr/flickr.iml" filepath="$PROJECT_DIR$/samples/flickr/flickr.iml" />
-      <module fileurl="file://$PROJECT_DIR$/third_party/gif_decoder/gif_decoder.iml" filepath="$PROJECT_DIR$/third_party/gif_decoder/gif_decoder.iml" />
-      <module fileurl="file://$PROJECT_DIR$/third_party/gif_encoder/gif_encoder.iml" filepath="$PROJECT_DIR$/third_party/gif_encoder/gif_encoder.iml" />
-      <module fileurl="file://$PROJECT_DIR$/samples/giphy/giphy.iml" filepath="$PROJECT_DIR$/samples/giphy/giphy.iml" />
-      <module fileurl="file://$PROJECT_DIR$/glide/glide.iml" filepath="$PROJECT_DIR$/glide/glide.iml" />
-      <module fileurl="file://$PROJECT_DIR$/glide-parent.iml" filepath="$PROJECT_DIR$/glide-parent.iml" />
-      <module fileurl="file://$PROJECT_DIR$/integration/integration.iml" filepath="$PROJECT_DIR$/integration/integration.iml" />
-      <module fileurl="file://$PROJECT_DIR$/library/library.iml" filepath="$PROJECT_DIR$/library/library.iml" />
-      <module fileurl="file://$PROJECT_DIR$/integration/okhttp/okhttp.iml" filepath="$PROJECT_DIR$/integration/okhttp/okhttp.iml" />
-      <module fileurl="file://$PROJECT_DIR$/samples/samples.iml" filepath="$PROJECT_DIR$/samples/samples.iml" />
-      <module fileurl="file://$PROJECT_DIR$/samples/svg/svg.iml" filepath="$PROJECT_DIR$/samples/svg/svg.iml" />
-      <module fileurl="file://$PROJECT_DIR$/testutil/testutil.iml" filepath="$PROJECT_DIR$/testutil/testutil.iml" />
-      <module fileurl="file://$PROJECT_DIR$/third_party/third_party.iml" filepath="$PROJECT_DIR$/third_party/third_party.iml" />
-      <module fileurl="file://$PROJECT_DIR$/integration/volley/volley.iml" filepath="$PROJECT_DIR$/integration/volley/volley.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/scopes/scope_settings.xml b/.idea/scopes/scope_settings.xml
deleted file mode 100644
index 922003b84..000000000
--- a/.idea/scopes/scope_settings.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<component name="DependencyValidationManager">
-  <state>
-    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
-  </state>
-</component>
\ No newline at end of file
diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
deleted file mode 100644
index 3b0002030..000000000
--- a/.idea/uiDesigner.xml
+++ /dev/null
@@ -1,125 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="Palette2">
-    <group name="Swing">
-      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
-      </item>
-      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
-      </item>
-      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
-        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
-        <initial-values>
-          <property name="text" value="Button" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="RadioButton" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="CheckBox" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="Label" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
-          <preferred-size width="200" height="200" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
-          <preferred-size width="200" height="200" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
-      </item>
-      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
-          <preferred-size width="-1" height="20" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
-      </item>
-      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
-      </item>
-    </group>
-  </component>
-</project>
-
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
deleted file mode 100644
index 8bb10b539..000000000
--- a/.idea/vcs.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="VcsDirectoryMappings">
-    <mapping directory="" vcs="" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index c1a2a27c1..d7e468055 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,12 +1,29 @@
 language: android
 android:
   components:
-  - build-tools-19.1.0
-  licenses: 
+  - tools
+  - platform-tools
+  - build-tools-22.0.1
+  - android-22
+  - extra-android-m2repository
+  - extra-android-support
+
+  licenses:
   - 'android-sdk-license.*'
 
+jdk:
+  - openjdk7
+  - oraclejdk7
+
+sudo: false
+
 script: 'travis_retry ./gradlew build --parallel'
 
 after_success:
 - scripts/travis-sonatype-publish.sh
 - ./gradlew jacocoTestReport coveralls
+
+cache:
+  directories:
+    - $HOME/.gradle/caches
+
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 000000000..950f16a66
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,54 @@
+# Contributing
+Contributions of all types are welcome.
+We use GitHub as our bug and feature tracker both for code and for other aspects of the library (documentation, the wiki, etc.).
+
+
+## Asking Questions
+The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on freenode.org][3].
+
+
+## Filing issues
+When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed.
+Similarly if you support a particular feature request, feel free to let us know by commenting on the issue.
+
+To file a new issue, please use our issue template and fill out the template as much as possible (remove irrelevant parts).
+
+<pre>**Glide Version/Integration library (if any)**:
+**Device/Android Version**:
+**Issue details/Repro steps/Use case background**:
+
+**Glide load line**:
+```java
+Glide.with(...).....load(...).....into(...);
+```
+
+**Layout XML**:
+```xml
+&lt;...Layout&gt;
+    &lt;ImageView android:scaleType="..." ... /&gt;
+&lt;/..Layout&gt;
+```
+
+**Stack trace / LogCat**:
+```ruby
+paste stack trace here
+```
+</pre>
+
+You can save [this as a bookmark or just click it][1] to create a new issue.
+The more information you can provide, the more likely we are to be able help.
+
+
+## Contributing code
+Pull requests are welcome for all parts of the codebase, especially the integration libraries.
+You can find instructions on building the project in [README.md][5].
+Our code style is defined in Intellij project files in the repo and also by our Checkstyle config.
+If you'd like to submit code, but can't get the style checks to pass, feel free to put up your pull request anyway and we can help you fix the style issues.
+If you'd like to contribute code, you will need to sign [Google's individual contributor license agreement][4] which will be asked when you create the PR by [googlebot](https://github.com/googlebot) should you forget it.
+
+
+[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60
+[2]: https://groups.google.com/forum/#!forum/glidelibrary
+[3]: http://webchat.freenode.net/?channels=glide-library
+[4]: https://developers.google.com/open-source/cla/individual
+[5]: /bumptech/glide
\ No newline at end of file
diff --git a/README.md b/README.md
index 28030094b..ee8b287f7 100644
--- a/README.md
+++ b/README.md
@@ -3,13 +3,13 @@ Glide
 
 [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
 
-Glide is a fast and efficient open source media management framework for Android that wraps media decoding, memory and
-disk caching, and resource pooling into a simple and easy to use interface.
+Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
+decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.
 
 ![](static/glide_logo.png)
 
-Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible api
-that allows developers to plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based
+Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible API
+that allows developers to plug in to almost any network stack. By default Glide uses a custom `HttpUrlConnection` based
 stack, but also includes utility libraries plug in to Google's Volley project or Square's OkHttp library instead.
 
 Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is
@@ -21,13 +21,13 @@ You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
 
-```groovy
+```gradle
 repositories {
-  mavenCentral()
+    mavenCentral()
 }
 
 dependencies {
-    compile 'com.github.bumptech.glide:glide:3.4.+'
+    compile 'com.github.bumptech.glide:glide:3.6.1'
     compile 'com.android.support:support-v4:19.1.0'
 }
 ```
@@ -36,43 +36,51 @@ Or Maven:
 
 ```xml
 <dependency>
-  <groupId>com.github.bumptech.glide</groupId>
-  <artifactId>glide</artifactId>
-  <version>3.4.0</version>
-  <type>aar</type>
+    <groupId>com.github.bumptech.glide</groupId>
+    <artifactId>glide</artifactId>
+    <version>3.6.1</version>
 </dependency>
 <dependency>
-  <groupId>com.google.android</groupId>
-  <artifactId>support-v4</artifactId>
-  <version>r7</version>
+    <groupId>com.google.android</groupId>
+    <artifactId>support-v4</artifactId>
+    <version>r7</version>
 </dependency>
 ```
 
+Proguard
+--------
+Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:
+
+```pro
+-keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
+    **[] $VALUES;
+    public *;
+}
+```
+
 How do I use Glide?
 -------------------
 Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [javadocs][3].
 
 Simple use cases will look something like this:
 
-```Java
-
+```java
 // For a simple view:
 @Override
 public void onCreate(Bundle savedInstanceState) {
     ...
-
     ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
-    Glide.with(this).load("http://goo.gl/h8qOq7").into(imageView);
+    Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
-// For a list:
+// For a simple image list:
 @Override
 public View getView(int position, View recycled, ViewGroup container) {
     final ImageView myImageView;
     if (recycled == null) {
-        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view,
-                container, false);
+        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
     } else {
         myImageView = (ImageView) recycled;
     }
@@ -91,152 +99,79 @@ public View getView(int position, View recycled, ViewGroup container) {
 
 ```
 
-Volley
--------
-Volley is now an optional dependency that can be included via a utility library. To use Volley to fetch media over
-http/https:
-
-With Gradle:
-
-```groovy
-dependencies {
-    compile 'com.github.bumptech.glide:volley-integration:1.1.+'
-    compile 'com.mcxiaoke.volley:library:1.0.+'
-}
-```
-
-Or with Maven:
+OkHttp and Volley
+-----------------
+Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies.
+The integration libraries are available via Maven or the [releases page][1].
 
-```xml
-<dependency>
-    <groupId>com.github.bumptech.glide</groupId>
-    <artifactId>volley-integration</artifactId>
-    <version>1.1.0</version>
-    <type>jar</type>
-</dependency>
-<dependency>
-    <groupId>com.mcxiaoke.volley</groupId>
-    <artifactId>library</artifactId>
-    <version>1.0.5</version>
-    <type>aar</type>
-</dependency>
-```
-
-Then in your Activity or Application, register the Volley based model loader:
-```java
-public void onCreate() {
-  Glide.get(this).register(GlideUrl.class, InputStream.class,
-        new VolleyUrlLoader.Factory(yourRequestQueue));
-  ...
-}
-```
-
-After the call to register any requests using http or https will go through Volley.
-
-OkHttp
-------
-In addition to Volley, Glide also includes support for fetching media using OkHttp. To use OkHttp to fetch media over
-http/https:
-
-With Gradle:
-
-```groovy
-dependencies {
-    compile 'com.github.bumptech.glide:okhttp-integration:1.1.+'
-    compile 'com.squareup.okhttp:okhttp:2.0.+'
-}
-```
-
-Or with Maven:
-
-```xml
-<dependency>
-    <groupId>com.github.bumptech.glide</groupId>
-    <artifactId>okhttp-integration</artifactId>
-    <version>1.1.0</version>
-    <type>jar</type>
-</dependency>
-<dependency>
-    <groupId>com.squareup.okhttp</groupId>
-    <artifactId>okhttp</artifactId>
-    <version>2.0.0</version>
-    <type>jar</type>
-</dependency>
-```
-
-Then in your Activity or Application, register the OkHttp based model loader:
-```java
-public void onCreate() {
-  Glide.get(this).register(GlideUrl.class, InputStream.class,
-        new OkHttpUrlLoader.Factory(yourOkHttpClient));
-  ...
-}
-```
+For instructions on including either the OkHttp or the Volley integration libraries, see the [Integration Libraries][12] wiki page.
 
 Android SDK Version
 -------------------
-Glide requires a minimum sdk version of 10.
+Glide requires a minimum SDK version of 10.
 
 License
 -------
-BSD, part MIT and Apache 2.0. See LICENSE file for details.
+BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details.
 
 Status
 ------
-Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera
-app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!
+[*Version 3*][14] is a stable public release used in multiple open source projects at Google including in the Android Camera
+app and in the 2014 Google IO app. *Version 4* is currently under development on the `master` branch.
+Comments/bugs/questions/pull requests welcome!
 
 Build
-------
+-----
 Building Glide with gradle is fairly straight forward:
 
-```
-git clone git@github.com:bumptech/glide.git
+```shell
+git clone git@github.com:bumptech/glide.git # use https://github.com/bumptech/glide.git if "Permission Denied"
 cd glide
 git submodule init && git submodule update
 ./gradlew jar
 ```
 
-Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment
+**Note**: Make sure your *Android SDK* has the *Android Support Repository* installed, and that your `$ANDROID_HOME` environment
 variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line.
 
 Samples
 -------
-Follow the steps in the 'Build' section to setup the project and then:
+Follow the steps in the [Build](#build) section to setup the project and then:
 
-```
+```shell
 ./gradlew :samples:flickr:run
 ./gradlew :samples:giphy:run
 ./gradlew :samples:svg:run
 ```
+You may also find precompiled APKs on the [releases page][1].
 
 Development
 -----------
-Follow the steps in the 'Build' section to setup the project and then edit the files however you wish.
+Follow the steps in the [Build](#build) section to setup the project and then edit the files however you wish.
 [Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
 To open the project in Intellij 14:
 
-1. Go to File.
-2. Click on 'Open...'
+1. Go to *File* menu or the *Welcome Screen*
+2. Click on *Open...*
 3. Navigate to Glide's root directory.
-4. Select glide-parent.iml
+4. Select `build.gradle`
 
 Getting Help
 ------------
 To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or
-anything else, join or email [Glide's discussion group][6].
+anything else, join or email [Glide's discussion group][6], or join our IRC channel: [irc.freenode.net#glide-library][13].
 
 Contributing
 ------------
-Before submitting pull requests, contributors must sign Google's [individual contribution license agreement][7].
+Before submitting pull requests, contributors must sign Google's [individual contributor license agreement][7].
 
 Thanks
 ------
-* The Android team and Jake Wharton for the [disk cache implementation][8] Glide's disk cache is based on.
-* Dave Smith for the [gif decoder gist][9] Glide's gif decoder is based on.
-* Chris Banes for his [gradle-mvn-push][10] script.
-* Corey Hall for Glide's [amazing logo][11].
+* The **Android team** and **Jake Wharton** for the [disk cache implementation][8] Glide's disk cache is based on.
+* **Dave Smith** for the [gif decoder gist][9] Glide's gif decoder is based on.
+* **Chris Banes** for his [gradle-mvn-push][10] script.
+* **Corey Hall** for Glide's [amazing logo][11].
 * Everyone who has contributed code and reported issues!
 
 Author
@@ -251,10 +186,15 @@ This is not an official Google product.
 [2]: https://github.com/bumptech/glide/wiki
 [3]: http://bumptech.github.io/glide/javadocs/latest/index.html
 [4]: https://www.jetbrains.com/idea/download/
-[5]: https://github.com/bumptech/glide/issues/new
+[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
 [7]: https://developers.google.com/open-source/cla/individual
 [8]: https://github.com/JakeWharton/DiskLruCache
 [9]: https://gist.github.com/devunwired/4479231
 [10]: https://github.com/chrisbanes/gradle-mvn-push
-[11]: static/glide_logo.png
\ No newline at end of file
+[11]: static/glide_logo.png
+[12]: https://github.com/bumptech/glide/wiki/Integration-Libraries
+[13]: http://webchat.freenode.net/?channels=glide-library
+[14]: https://github.com/bumptech/glide/tree/3.0
+[15]: https://github.com/bumptech/glide/tree/master
+[16]: https://github.com/bumptech/glide/blob/master/LICENSE
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index bf2e160a6..ab3a44b96 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,22 +1,48 @@
 buildscript {
     repositories {
         jcenter()
+        maven {
+            url "https://oss.sonatype.org/content/repositories/snapshots"
+        }
     }
 
     dependencies {
-        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}"
         classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
         classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
+        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}"
+    }
+}
+
+// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html.
+if (JavaVersion.current().isJava8Compatible()) {
+    allprojects {
+        tasks.withType(Javadoc) {
+            options.addStringOption('Xdoclint:none', '-quiet')
+        }
+    }
+}
+
+subprojects {
+    tasks.withType(JavaCompile) {
+        sourceCompatibility = 1.7
+        targetCompatibility = 1.7
     }
 }
 
 subprojects { project ->
     repositories {
         jcenter()
+        maven {
+            url "https://oss.sonatype.org/content/repositories/snapshots"
+        }
     }
 
     apply plugin: 'checkstyle'
 
+    checkstyle {
+        toolVersion = "6.6"
+    }
+
     checkstyle {
         configFile = new File(rootDir, 'checkstyle.xml')
         configProperties.checkStyleConfigDir = rootProject.rootDir
@@ -47,5 +73,5 @@ subprojects { project ->
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.1'
+    gradleVersion = '2.2.1'
 }
diff --git a/checkstyle.xml b/checkstyle.xml
index 34735f1b1..a3c9878b7 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -14,6 +14,9 @@
         <property name="message" value="Line has trailing spaces."/>
     </module>
 
+    <!-- Ensure trailling newline for compatibility -->
+    <module name="NewlineAtEndOfFile" />
+
     <!-- Space after 'for' and 'if' -->
     <module name="RegexpSingleline">
         <property name="format" value="^\s*(for|if)\b[^ ]"/>
@@ -91,6 +94,7 @@
         <module name="ImportOrder">
           <!-- Checks for out of order import statements. -->
 
+          <property name="sortStaticImportsAlphabetically" value="true"/>
            <property name="severity" value="error"/>
            <property name="groups" value="com.google,*,java,javax"/>
            <!-- This ensures that static imports go first. -->
@@ -141,16 +145,13 @@
         <module name="NoClone" />
         <module name="NoFinalizer" />
         <module name="OneStatementPerLine" />
-        <module name="RedundantThrows" >
-            <property name="suppressLoadErrors" value="true" />
-        </module>
         <module name="IllegalInstantiation"/>
         <module name="SimplifyBooleanExpression" />
         <module name="SimplifyBooleanReturn" />
         <module name="StringLiteralEquality" />
         <module name="UnnecessaryParentheses" />
         <module name="LineLength">
-            <property name="max" value="120" />
+            <property name="max" value="100" />
         </module>
 
         <!-- Checks for class design. -->
diff --git a/checkstyle_suppressions.xml b/checkstyle_suppressions.xml
index 1d8da750b..9faf18dc8 100644
--- a/checkstyle_suppressions.xml
+++ b/checkstyle_suppressions.xml
@@ -5,8 +5,8 @@
     "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">
 
 <suppressions>
-    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]library[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
     <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>
-    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />
+    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />
 </suppressions>
 
diff --git a/glide-parent.iml b/glide-parent.iml
deleted file mode 100644
index 12cf9da6b..000000000
--- a/glide-parent.iml
+++ /dev/null
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" value="$MODULE_DIR$/build" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/glide-parent/glide-parent-glide-parent.iml b/glide-parent/glide-parent-glide-parent.iml
deleted file mode 100644
index 9f3c1ba2d..000000000
--- a/glide-parent/glide-parent-glide-parent.iml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-      <excludeFolder url="file://$MODULE_DIR$/build" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
-
diff --git a/glide/build.gradle b/glide/build.gradle
index 410a1df7c..cee746200 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -13,7 +13,7 @@ def getAndroidCompileSdkVersion() {
 }
 
 def getInternalAndroidProjects() {
-    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }
+    [':third_party:gif_decoder', ':library'].collect { project(it) }
 }
 def getInternalJavaProjects() {
     [':third_party:disklrucache'].collect { project(it) }
@@ -66,16 +66,16 @@ def getAndroidJar() {
 
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
-    }
+    } as Javadoc
 
     def cleanJavadocTask = task("clean${variantName.capitalize()}Javadoc", type: Delete) {
         delete javadocTask.destinationDir
-    }
+    } as Task
     clean.dependsOn(cleanJavadocTask)
 
     def javadocJarTask = task("${variantName}JavadocJar", type: Jar) {
       from javadocTask.destinationDir
-    }
+    } as Task
     javadocJarTask.dependsOn(javadocTask)
 }
 
@@ -91,7 +91,7 @@ jar {
 }
 
 getAllInternalProjects().each { project ->
-    jar.dependsOn(project.build)
+    jar.dependsOn(project.tasks.build)
 }
 
 artifacts {
@@ -103,4 +103,4 @@ artifacts {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
\ No newline at end of file
+apply from: "$rootProject.projectDir/scripts/upload.gradle"
diff --git a/glide/glide-glide.iml b/glide/glide-glide.iml
deleted file mode 100644
index 28bde5c8d..000000000
--- a/glide/glide-glide.iml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.3.0a-SNAPSHOT" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/classes/main" />
-    <output-test url="file://$MODULE_DIR$/build/classes/test" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-      <excludeFolder url="file://$MODULE_DIR$/build" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
-
diff --git a/glide/glide.iml b/glide/glide.iml
deleted file mode 100644
index 456f3ac01..000000000
--- a/glide/glide.iml
+++ /dev/null
@@ -1,30 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":glide" />
-      </configuration>
-    </facet>
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/classes/main" />
-    <output-test url="file://$MODULE_DIR$/build/classes/test" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-      <excludeFolder url="file://$MODULE_DIR$/build" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index 0b3b2fe86..135e9ea28 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,8 +1,12 @@
-VERSION_NAME=3.5.0-SNAPSHOT
-VERSION_MAJOR=3
-VERSION_MINOR=5
+org.gradle.daemon=true
+org.gradle.configureondemand=true
+org.gradle.parallel=true
+
+VERSION_NAME=4.0.0-SNAPSHOT
+VERSION_MAJOR=4
+VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=8
+VERSION_CODE=12
 GROUP=com.github.bumptech.glide
 
 POM_DESCRIPTION=A fast and efficient image loading library for Android focused on smooth scrolling.
@@ -14,21 +18,25 @@ POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
 
-SUPPORT_V4_VERSION=19.1.0
-SUPPORT_V7_VERSION=19.1.0
-VOLLEY_VERSION=1.0.7
-OK_HTTP_VERSION=2.0.0
-ANDROID_GRADLE_VERSION=0.13.3
+SUPPORT_V4_VERSION=22.2.0
+SUPPORT_V7_VERSION=22.2.0
+VOLLEY_VERSION=1.0.16
+OK_HTTP_VERSION=2.3.0
+# TODO: use this in library/build.gradle.
+ANDROID_GRADLE_VERSION=1.2.3
+
+ROBOLECTRIC_GRADLE_VERSION=1.1.0
+COVERALLS_GRADLE_VERSION=2.4.0
+JUNIT_VERSION=4.12
+MOCKITO_VERSION=1.10.19
+ROBOLECTRIC_VERSION=3.0-rc3
+MOCKWEBSERVER_VERSION=2.3.0
+TRUTH_VERSION=0.26
 
-ROBOLECTRIC_GRADLE_VERSION=0.12.0
-COVERALLS_GRADLE_VERSION=2.0.1
-JUNIT_VERSION=4.11
-MOCKITO_VERSION=1.9.5
-ROBOLECTRIC_VERSION=2.4
-MOCKWEBSERVER_VERSION=1.6.0
-TRUTH_VERSION=0.24
+FINDBUGS_VERSION=3.0.0
+JACOCO_VERSION=0.7.1.201405082137
 
-COMPILE_SDK_VERSION=19
-BUILD_TOOLS_VERSION=19.1.0
-TARGET_SDK_VERSION=19
+COMPILE_SDK_VERSION=22
+BUILD_TOOLS_VERSION=22.0.1
+TARGET_SDK_VERSION=22
 MIN_SDK_VERSION=10
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 3d0dee6e8..c97a8bdb9 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 53a7b2a77..25f7d42d7 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Fri Sep 19 07:33:32 PDT 2014
+#Wed May 20 08:28:58 PDT 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.1-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/integration/build.gradle b/integration/build.gradle
index d3f14bd15..5467b8ace 100644
--- a/integration/build.gradle
+++ b/integration/build.gradle
@@ -1,7 +1,8 @@
 evaluationDependsOnChildren()
 
+import com.android.build.gradle.api.BaseVariant
 subprojects {
-    android.libraryVariants.all { variant ->
+    android.libraryVariants.all { BaseVariant variant ->
         def jarTask = project.tasks.create(name: "jar${variant.name.capitalize()}", type: Jar) {
             from variant.javaCompile.destinationDir
             exclude "**/R.class"
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
new file mode 100644
index 000000000..603500c46
--- /dev/null
+++ b/integration/gifencoder/build.gradle
@@ -0,0 +1,43 @@
+apply plugin: 'com.android.library'
+apply plugin: 'org.robolectric'
+
+repositories {
+    mavenCentral()
+}
+
+dependencies {
+    compile project(':glide')
+
+    testCompile project(":testutil")
+    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    sourceSets {
+        main {
+            java.srcDirs = ['src/main/java', '../../third_party/gif_encoder/src/main/java']
+        }
+    }
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionCode = VERSION_CODE as int
+        versionName = VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+apply from: "$rootProject.projectDir/scripts/upload.gradle"
diff --git a/integration/gifencoder/gradle.properties b/integration/gifencoder/gradle.properties
new file mode 100644
index 000000000..15bd7b334
--- /dev/null
+++ b/integration/gifencoder/gradle.properties
@@ -0,0 +1,15 @@
+POM_NAME=Glide GifEncoder Integration
+POM_ARTIFACT_ID=gifencoder-integration
+POM_PACKAGING=aar
+
+VERSION_NAME=2.0.0-SNAPSHOT
+VERSION_MAJOR=2
+VERSION_MINOR=0
+VERSION_PATCH=0
+VERSION_CODE=8
+
+POM_DESCRIPTION=An integration library allowing users to re-encode or create animated GIFs
+
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-integration
diff --git a/integration/gifencoder/lint.xml b/integration/gifencoder/lint.xml
new file mode 100644
index 000000000..8b0842417
--- /dev/null
+++ b/integration/gifencoder/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore"/>
+    <!-- See https://github.com/square/okio/issues/58 -->
+    <issue id="InvalidPackage" severity="ignore">
+        <ignore regexp="okio-1.0.0.jar"/>
+    </issue>
+</lint>
diff --git a/integration/gifencoder/src/main/AndroidManifest.xml b/integration/gifencoder/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..eeb7b37c5
--- /dev/null
+++ b/integration/gifencoder/src/main/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.integration.gifencoder">
+
+    <application>
+    </application>
+</manifest>
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
new file mode 100644
index 000000000..f3ca40290
--- /dev/null
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -0,0 +1,210 @@
+package com.bumptech.glide.integration.gifencoder;
+
+import android.graphics.Bitmap;
+import android.util.Log;
+
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.gifdecoder.GifHeader;
+import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.UnitTransformation;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.load.resource.gif.GifBitmapProvider;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.util.ByteBufferUtil;
+import com.bumptech.glide.util.LogTime;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * An {@link com.bumptech.glide.load.ResourceEncoder} that can write
+ * {@link com.bumptech.glide.load.resource.gif.GifDrawable} to cache.
+ */
+public class ReEncodingGifResourceEncoder implements ResourceEncoder<GifDrawable> {
+
+  private static final String KEY_ENCODE_TRANSFORMATION =
+      "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";
+   /**
+   * A boolean option that, if set to <code>true</code>, causes the fully transformed
+   * GIF to be written to cache.
+   *
+   * <p> Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
+   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs. </p>
+   *
+   * <p> Defaults to <code>false</code>. </p>
+   */
+  public static final Option<Boolean> ENCODE_TRANSFORMATION =
+      Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {
+        @Override
+        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {
+          if (value) {
+            messageDigest.update(keyBytes);
+          }
+        }
+      });
+
+  private static final Factory FACTORY = new Factory();
+  private static final String TAG = "GifEncoder";
+  private final GifDecoder.BitmapProvider provider;
+  private final BitmapPool bitmapPool;
+  private final Factory factory;
+
+  public ReEncodingGifResourceEncoder(BitmapPool bitmapPool) {
+    this(bitmapPool, FACTORY);
+  }
+
+  // Visible for testing.
+  ReEncodingGifResourceEncoder(BitmapPool bitmapPool, Factory factory) {
+    this.bitmapPool = bitmapPool;
+    provider = new GifBitmapProvider(bitmapPool);
+    this.factory = factory;
+  }
+
+  @Override
+  public EncodeStrategy getEncodeStrategy(Options options) {
+    Boolean encodeTransformation = options.get(ENCODE_TRANSFORMATION);
+    return encodeTransformation != null && encodeTransformation
+        ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;
+  }
+
+  @Override
+  public boolean encode(Resource<GifDrawable> resource, File file, Options options) {
+    GifDrawable drawable = resource.get();
+    Transformation<Bitmap> transformation = drawable.getFrameTransformation();
+    boolean isTransformed = !(transformation instanceof UnitTransformation);
+    if (isTransformed && options.get(ENCODE_TRANSFORMATION)) {
+      return encodeTransformedToFile(drawable, file);
+    } else {
+      return writeDataDirect(drawable.getBuffer(), file);
+    }
+  }
+
+  private boolean encodeTransformedToFile(GifDrawable drawable, File file) {
+    long startTime = LogTime.getLogTime();
+    OutputStream os = null;
+    boolean success = false;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(file));
+      success = encodeTransformedToStream(drawable, os);
+      os.close();
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to encode GIF", e);
+      }
+    } finally {
+      if (os != null) {
+        try {
+          os.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+
+    }
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Re-encoded gif with " + drawable.getFrameCount() + " frames and "
+          + drawable.getBuffer().limit() + " bytes in " + LogTime.getElapsedMillis(startTime)
+          + " ms");
+    }
+
+    return success;
+  }
+
+  private boolean encodeTransformedToStream(GifDrawable drawable, OutputStream os) {
+    Transformation<Bitmap> transformation = drawable.getFrameTransformation();
+    GifDecoder decoder = decodeHeaders(drawable.getBuffer());
+    AnimatedGifEncoder encoder = factory.buildEncoder();
+    if (!encoder.start(os)) {
+      return false;
+    }
+
+    for (int i = 0; i < decoder.getFrameCount(); i++) {
+      Bitmap currentFrame = decoder.getNextFrame();
+      Resource<Bitmap> transformedResource =
+          getTransformedFrame(currentFrame, transformation, drawable);
+      try {
+        if (!encoder.addFrame(transformedResource.get())) {
+          return false;
+        }
+        int currentFrameIndex = decoder.getCurrentFrameIndex();
+        int delay = decoder.getDelay(currentFrameIndex);
+        encoder.setDelay(delay);
+
+        decoder.advance();
+      } finally {
+        transformedResource.recycle();
+      }
+    }
+
+    return encoder.finish();
+  }
+
+  private boolean writeDataDirect(ByteBuffer data, File file) {
+    try {
+      ByteBufferUtil.toFile(data, file);
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to write gif data", e);
+      }
+      return false;
+    }
+    return true;
+  }
+
+  private GifDecoder decodeHeaders(ByteBuffer data) {
+    GifHeaderParser parser = factory.buildParser();
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+
+    GifDecoder decoder = factory.buildDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+
+    return decoder;
+  }
+
+  private Resource<Bitmap> getTransformedFrame(Bitmap currentFrame,
+      Transformation<Bitmap> transformation, GifDrawable drawable) {
+    // TODO: what if current frame is null?
+    Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
+    Resource<Bitmap> transformedResource = transformation
+        .transform(bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
+    if (!bitmapResource.equals(transformedResource)) {
+      bitmapResource.recycle();
+    }
+    return transformedResource;
+  }
+
+  // Visible for testing.
+  static class Factory {
+
+    public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
+      return new GifDecoder(bitmapProvider);
+    }
+
+    public GifHeaderParser buildParser() {
+      return new GifHeaderParser();
+    }
+
+    public AnimatedGifEncoder buildEncoder() {
+      return new AnimatedGifEncoder();
+    }
+
+    public Resource<Bitmap> buildFrameResource(Bitmap bitmap, BitmapPool bitmapPool) {
+      return new BitmapResource(bitmap, bitmapPool);
+    }
+  }
+}
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
new file mode 100644
index 000000000..0f9ade749
--- /dev/null
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -0,0 +1,335 @@
+package com.bumptech.glide.integration.gifencoder;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.gifdecoder.GifHeader;
+import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.UnitTransformation;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.util.ByteBufferUtil;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ReEncodingGifResourceEncoderTest {
+  @Mock Resource<GifDrawable> resource;
+  @Mock GifDecoder decoder;
+  @Mock GifHeaderParser parser;
+  @Mock AnimatedGifEncoder gifEncoder;
+  @Mock Resource<Bitmap> frameResource;
+  @Mock GifDrawable gifDrawable;
+  @Mock Transformation<Bitmap> frameTransformation;
+  @Mock Resource<Bitmap> transformedResource;
+
+  private ReEncodingGifResourceEncoder encoder;
+  private Options options;
+  private File file;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
+    when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
+    when(factory.buildParser()).thenReturn(parser);
+    when(factory.buildEncoder()).thenReturn(gifEncoder);
+    when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class)))
+        .thenReturn(frameResource);
+
+    when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt()))
+        .thenReturn(frameResource);
+
+    when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
+    when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.allocate(0));
+
+    when(resource.get()).thenReturn(gifDrawable);
+
+    encoder = new ReEncodingGifResourceEncoder(mock(BitmapPool.class), factory);
+    options = new Options();
+    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, true);
+
+    file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+  }
+
+  @After
+  public void tearDown() {
+    if (file.exists() && !file.delete()) {
+      throw new RuntimeException("Failed to delete file");
+    }
+  }
+
+  @Test
+  public void testEncodeStrategy_withEncodeTransformationTrue_returnsTransformed() {
+    assertThat(encoder.getEncodeStrategy(options)).isEqualTo(EncodeStrategy.TRANSFORMED);
+  }
+
+  @Test
+  public void testEncodeStrategy_withEncodeTransformationUnSet_returnsSource() {
+    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, null);
+    assertThat(encoder.getEncodeStrategy(options)).isEqualTo(EncodeStrategy.SOURCE);
+  }
+
+  @Test
+  public void testEncodeStrategy_withEncodeTransformationFalse_returnsSource() {
+    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
+    assertThat(encoder.getEncodeStrategy(options)).isEqualTo(EncodeStrategy.SOURCE);
+  }
+
+  @Test
+  public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
+      throws IOException {
+    // Most likely an instance of http://stackoverflow.com/q/991489/253468
+    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
+    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
+    String expected = "testString";
+    byte[] data = expected.getBytes("UTF-8");
+    when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(data));
+
+    assertTrue(encoder.encode(resource, file, options));
+    assertThat(getEncodedData()).isEqualTo(expected);
+  }
+
+  @Test
+  public void testEncode_WithEncodeTransformationFalse_whenOsThrows_returnsFalse()
+      throws IOException {
+
+    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
+    byte[] data = "testString".getBytes("UTF-8");
+    when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(data));
+
+    assertThat(file.mkdirs()).isTrue();
+
+    assertFalse(encoder.encode(resource, file, options));
+  }
+
+  @Test
+  public void testReturnsFalseIfEncoderFailsToStart() {
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(false);
+    assertFalse(encoder.encode(resource, file, options));
+  }
+
+  @Test
+  public void testSetsDataOnParserBeforeParsingHeader() {
+    ByteBuffer data = ByteBuffer.allocate(1);
+    when(gifDrawable.getBuffer()).thenReturn(data);
+
+    GifHeader header = mock(GifHeader.class);
+    when(parser.parseHeader()).thenReturn(header);
+
+    encoder.encode(resource, file, options);
+
+    InOrder order = inOrder(parser, decoder);
+    order.verify(parser).setData(eq(data));
+    order.verify(parser).parseHeader();
+    order.verify(decoder).setData(header, data);
+  }
+
+  @Test
+  public void testAdvancesDecoderBeforeAttemptingToGetFirstFrame() {
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+    when(decoder.getFrameCount()).thenReturn(1);
+    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+
+    encoder.encode(resource, file, options);
+
+    InOrder order = inOrder(decoder);
+    order.verify(decoder).advance();
+    order.verify(decoder).getNextFrame();
+  }
+
+  @Test
+  public void testSetsDelayOnEncoderAfterAddingFrame() {
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+    when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(true);
+
+    when(decoder.getFrameCount()).thenReturn(1);
+    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
+    int expectedIndex = 34;
+    when(decoder.getCurrentFrameIndex()).thenReturn(expectedIndex);
+    int expectedDelay = 5000;
+    when(decoder.getDelay(eq(expectedIndex))).thenReturn(expectedDelay);
+
+    encoder.encode(resource, file, options);
+
+    InOrder order = inOrder(gifEncoder, decoder);
+    order.verify(decoder).advance();
+    order.verify(gifEncoder).addFrame(any(Bitmap.class));
+    order.verify(gifEncoder).setDelay(eq(expectedDelay));
+    order.verify(decoder).advance();
+  }
+
+  @Test
+  public void testWritesSingleFrameToEncoderAndReturnsTrueIfEncoderFinishes() {
+    Bitmap frame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(frameResource.get()).thenReturn(frame);
+
+    when(decoder.getFrameCount()).thenReturn(1);
+    when(decoder.getNextFrame()).thenReturn(frame);
+
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+    when(gifEncoder.addFrame(eq(frame))).thenReturn(true);
+    when(gifEncoder.finish()).thenReturn(true);
+
+    assertTrue(encoder.encode(resource, file, options));
+    verify(gifEncoder).addFrame(eq(frame));
+  }
+
+  @Test
+  public void testReturnsFalseIfAddingFrameFails() {
+    when(decoder.getFrameCount()).thenReturn(1);
+    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+    when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(false);
+
+    assertFalse(encoder.encode(resource, file, options));
+  }
+
+  @Test
+  public void testReturnsFalseIfFinishingFails() {
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+    when(gifEncoder.finish()).thenReturn(false);
+
+    assertFalse(encoder.encode(resource, file, options));
+  }
+
+  @Test
+  public void testWritesTransformedBitmaps() {
+    final Bitmap frame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(decoder.getFrameCount()).thenReturn(1);
+    when(decoder.getNextFrame()).thenReturn(frame);
+
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+
+    int expectedWidth = 123;
+    int expectedHeight = 456;
+    when(gifDrawable.getIntrinsicWidth()).thenReturn(expectedWidth);
+    when(gifDrawable.getIntrinsicHeight()).thenReturn(expectedHeight);
+
+    Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
+    when(transformedResource.get()).thenReturn(transformedFrame);
+    when(frameTransformation.transform(eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
+        .thenReturn(transformedResource);
+    when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
+
+    encoder.encode(resource, file, options);
+
+    verify(gifEncoder).addFrame(eq(transformedFrame));
+  }
+
+  @Test
+  public void testRecyclesFrameResourceBeforeWritingIfTransformedResourceIsDifferent() {
+    when(decoder.getFrameCount()).thenReturn(1);
+    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+        .thenReturn(transformedResource);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(transformedResource.get()).thenReturn(expected);
+
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+
+    encoder.encode(resource, file, options);
+
+    InOrder order = inOrder(frameResource, gifEncoder);
+    order.verify(frameResource).recycle();
+    order.verify(gifEncoder).addFrame(eq(expected));
+  }
+
+  @Test
+  public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDifferent() {
+    when(decoder.getFrameCount()).thenReturn(1);
+    Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
+    when(transformedResource.get()).thenReturn(expected);
+    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+        .thenReturn(transformedResource);
+
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+
+    encoder.encode(resource, file, options);
+
+    InOrder order = inOrder(transformedResource, gifEncoder);
+    order.verify(gifEncoder).addFrame(eq(expected));
+    order.verify(transformedResource).recycle();
+  }
+
+  @Test
+  public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed() {
+    when(decoder.getFrameCount()).thenReturn(1);
+    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+        .thenReturn(frameResource);
+    Bitmap expected = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
+    when(frameResource.get()).thenReturn(expected);
+
+    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
+
+    encoder.encode(resource, file, options);
+
+    InOrder order = inOrder(frameResource, gifEncoder);
+    order.verify(gifEncoder).addFrame(eq(expected));
+    order.verify(frameResource).recycle();
+  }
+
+  @Test
+  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
+      throws IOException {
+    // Most likely an instance of http://stackoverflow.com/q/991489/253468
+    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
+    when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
+    String expected = "expected";
+    when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
+
+    encoder.encode(resource, file, options);
+
+    assertThat(getEncodedData()).isEqualTo(expected);
+
+    verify(gifEncoder, never()).start(any(OutputStream.class));
+    verify(parser, never()).setData(any(byte[].class));
+    verify(parser, never()).parseHeader();
+  }
+
+  private String getEncodedData() {
+    try {
+      return new String(ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file)));
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/integration/integration.iml b/integration/integration.iml
deleted file mode 100644
index b6a88a5d8..000000000
--- a/integration/integration.iml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":integration" />
-      </configuration>
-    </facet>
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-      <excludeFolder url="file://$MODULE_DIR$/build" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
-
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index d516652c4..c70aad959 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -12,15 +12,19 @@ dependencies {
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
-        applicationId 'com.bumptech.glide.integration.okhttp'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode = VERSION_CODE
-        versionName = VERSION_NAME
+        versionCode VERSION_CODE as int
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
     }
 }
 
diff --git a/integration/okhttp/gradle.properties b/integration/okhttp/gradle.properties
index db834d769..636a1a822 100644
--- a/integration/okhttp/gradle.properties
+++ b/integration/okhttp/gradle.properties
@@ -2,11 +2,11 @@ POM_NAME=Glide OkHttp Integration
 POM_ARTIFACT_ID=okhttp-integration
 POM_PACKAGING=aar
 
-VERSION_NAME=1.2.0-SNAPSHOT
-VERSION_MAJOR=1
-VERSION_MINOR=2
+VERSION_NAME=2.0.0-SNAPSHOT
+VERSION_MAJOR=2
+VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=4
+VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library to use OkHttp to fetch data over http/https in Glide
 
diff --git a/integration/okhttp/lint.xml b/integration/okhttp/lint.xml
index 7f925db16..8b0842417 100644
--- a/integration/okhttp/lint.xml
+++ b/integration/okhttp/lint.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
-    <issue id="AllowBackup" severity="ignore" />
+    <issue id="AllowBackup" severity="ignore"/>
     <!-- See https://github.com/square/okio/issues/58 -->
-    <issue id="InvalidPackage" severity="ignore" >
-      <ignore regexp="okio-1.0.0.jar" />
+    <issue id="InvalidPackage" severity="ignore">
+        <ignore regexp="okio-1.0.0.jar"/>
     </issue>
 </lint>
diff --git a/integration/okhttp/okhttp.iml b/integration/okhttp/okhttp.iml
deleted file mode 100644
index 5cb0747c3..000000000
--- a/integration/okhttp/okhttp.iml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="1.2.0-SNAPSHOT" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":integration:okhttp" />
-      </configuration>
-    </facet>
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="SELECTED_BUILD_VARIANT" value="debug" />
-        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
-        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
-        <option name="ALLOW_USER_CONFIGURATION" value="false" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
-        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
-        <option name="LIBRARY_PROJECT" value="true" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
-      <excludeFolder url="file://$MODULE_DIR$/build/docs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
-      <excludeFolder url="file://$MODULE_DIR$/build/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
-      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" exported="" name="okio-1.0.0" level="project" />
-    <orderEntry type="library" exported="" name="okhttp-2.0.0" level="project" />
-    <orderEntry type="module" module-name="glide" exported="" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/integration/okhttp/src/main/AndroidManifest.xml b/integration/okhttp/src/main/AndroidManifest.xml
index 53b73913d..c11d7167d 100644
--- a/integration/okhttp/src/main/AndroidManifest.xml
+++ b/integration/okhttp/src/main/AndroidManifest.xml
@@ -1,5 +1,9 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.bumptech.glide.integration.okhttp">
-    <application />
+          package="com.bumptech.glide.integration.okhttp">
 
+    <application>
+        <meta-data
+            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule"
+            android:value="GlideModule"/>
+    </application>
 </manifest>
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
new file mode 100644
index 000000000..738e9602d
--- /dev/null
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -0,0 +1,31 @@
+package com.bumptech.glide.integration.okhttp;
+
+import android.content.Context;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.GlideModule;
+
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
+ * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p> If you're using gradle, you can include this module simply by depending on the aar, the
+ * module will be merged in by manifest merger. For other build systems or for more more
+ * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ */
+public class OkHttpGlideModule implements GlideModule {
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index f361c1ea1..1985ca24a 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -1,62 +1,99 @@
 package com.bumptech.glide.integration.okhttp;
 
+import android.util.Log;
+
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.ContentLengthInputStream;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.Map;
 
 /**
  * Fetches an {@link InputStream} using the okhttp library.
  */
 public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
-    private final OkHttpClient client;
-    private final GlideUrl url;
-    private volatile Request request;
-    private InputStream stream;
-
-    public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
-        this.client = client;
-        this.url = url;
-    }
+  private static final String TAG = "OkHttpFetcher";
+  private final OkHttpClient client;
+  private final GlideUrl url;
+  private InputStream stream;
+  private ResponseBody responseBody;
+
+  public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
+    this.client = client;
+    this.url = url;
+  }
 
-    @Override
-    public InputStream loadData(Priority priority) throws Exception {
-        request = new Request.Builder()
-                .url(url.toString())
-                .build();
-
-        stream = client.newCall(request)
-                .execute()
-                .body()
-                .byteStream();
-        return stream;
+  @Override
+  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
+    boolean isUserAgentSet = false;
+    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
+      String key = headerEntry.getKey();
+      requestBuilder.addHeader(key, headerEntry.getValue());
     }
+    Request request = requestBuilder.build();
 
-    @Override
-    public void cleanup() {
-        if (stream == null) {
-            return;
+    client.newCall(request).enqueue(new com.squareup.okhttp.Callback() {
+      @Override
+      public void onFailure(Request request, IOException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp failed to obtain result", e);
         }
-        try {
-            stream.close();
-        } catch (IOException e) {
-            // Ignored
+        callback.onLoadFailed(e);
+      }
+
+      @Override
+      public void onResponse(Response response) throws IOException {
+        if (response.isSuccessful()) {
+          long contentLength = response.body().contentLength();
+          responseBody = response.body();
+          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
         }
-    }
+        callback.onDataReady(stream);
+      }
+    });
+  }
 
-    @Override
-    public String getId() {
-        return url.toString();
+  @Override
+  public void cleanup() {
+    try {
+      if (stream != null) {
+        stream.close();
+      }
+    } catch (IOException e) {
+      // Ignored
     }
-
-    @Override
-    public void cancel() {
-        if (request != null) {
-            client.cancel(request);
-        }
+    if (responseBody != null) {
+      try {
+        responseBody.close();
+      } catch (IOException e) {
+        // Ignored.
+      }
     }
+  }
+
+  @Override
+  public void cancel() {
+    // TODO: call cancel on the client when this method is called on a background thread. See #257
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
+
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.REMOTE;
+  }
 }
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index eb35139b4..05c0fe683 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -2,11 +2,11 @@
 
 import android.content.Context;
 
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.squareup.okhttp.OkHttpClient;
 
 import java.io.InputStream;
@@ -16,57 +16,64 @@
  */
 public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
-    /**
-     * The default factory for {@link OkHttpUrlLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
-        private static volatile OkHttpClient internalClient;
-        private OkHttpClient client;
+  private final OkHttpClient client;
 
-        private static OkHttpClient getInternalClient() {
-            if (internalClient == null) {
-                synchronized (Factory.class) {
-                    if (internalClient == null) {
-                        internalClient = new OkHttpClient();
-                    }
-                }
-            }
-            return internalClient;
-        }
+  public OkHttpUrlLoader(OkHttpClient client) {
+    this.client = client;
+  }
 
-        /**
-         * Constructor for a new Factory that runs requests using a static singleton client.
-         */
-        public Factory() {
-            this(getInternalClient());
-        }
+  @Override
+  public boolean handles(GlideUrl url) {
+    return true;
+  }
 
-        /**
-         * Constructor for a new Factory that runs requests using given client.
-         */
-        public Factory(OkHttpClient client) {
-            this.client = client;
-        }
+  @Override
+  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
+      Options options) {
+    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
+  }
 
-        @Override
-        public ModelLoader<GlideUrl, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new OkHttpUrlLoader(client);
-        }
+  /**
+   * The default factory for {@link OkHttpUrlLoader}s.
+   */
+  public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
+    private static volatile OkHttpClient internalClient;
+    private OkHttpClient client;
 
-        @Override
-        public void teardown() {
-            // Do nothing, this instance doesn't own the client.
+    private static OkHttpClient getInternalClient() {
+      if (internalClient == null) {
+        synchronized (Factory.class) {
+          if (internalClient == null) {
+            internalClient = new OkHttpClient();
+          }
         }
+      }
+      return internalClient;
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using a static singleton client.
+     */
+    public Factory() {
+      this(getInternalClient());
     }
 
-    private final OkHttpClient client;
+    /**
+     * Constructor for a new Factory that runs requests using given client.
+     */
+    public Factory(OkHttpClient client) {
+      this.client = client;
+    }
 
-    public OkHttpUrlLoader(OkHttpClient client) {
-        this.client = client;
+    @Override
+    public ModelLoader<GlideUrl, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new OkHttpUrlLoader(client);
     }
 
     @Override
-    public DataFetcher<InputStream> getResourceFetcher(GlideUrl model, int width, int height) {
-        return new OkHttpStreamFetcher(client, model);
+    public void teardown() {
+      // Do nothing, this instance doesn't own the client.
     }
+  }
 }
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
new file mode 100644
index 000000000..854dcefdd
--- /dev/null
+++ b/integration/recyclerview/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'com.android.library'
+
+repositories {
+    mavenCentral()
+}
+
+dependencies {
+    compile project(':glide')
+    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionCode VERSION_CODE as int
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+apply from: "$rootProject.projectDir/scripts/upload.gradle"
diff --git a/integration/recyclerview/gradle.properties b/integration/recyclerview/gradle.properties
new file mode 100644
index 000000000..06c3c48dc
--- /dev/null
+++ b/integration/recyclerview/gradle.properties
@@ -0,0 +1,15 @@
+POM_NAME=Glide RecyclerView Integration
+POM_ARTIFACT_ID=recyclerview-integration
+POM_PACKAGING=aar
+
+VERSION_NAME=2.0.0-SNAPSHOT
+VERSION_MAJOR=2
+VERSION_MINOR=0
+VERSION_PATCH=0
+VERSION_CODE=8
+
+POM_DESCRIPTION=An integration library to display images in RecyclerView.
+
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-integration
diff --git a/integration/recyclerview/lint.xml b/integration/recyclerview/lint.xml
new file mode 100644
index 000000000..ff7e5955c
--- /dev/null
+++ b/integration/recyclerview/lint.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore"/>
+</lint>
diff --git a/integration/recyclerview/src/main/AndroidManifest.xml b/integration/recyclerview/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..0d880314c
--- /dev/null
+++ b/integration/recyclerview/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.integration.recyclerview">
+    <application />
+</manifest>
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
new file mode 100644
index 000000000..a3fd25880
--- /dev/null
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.integration.recyclerview;
+
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.widget.AbsListView;
+import android.widget.ListView;
+
+/**
+ * Converts {@link android.support.v7.widget.RecyclerView.OnScrollListener} events to
+ * {@link AbsListView} scroll events.
+ *
+ * <p>Requires that the the recycler view be using a {@link LinearLayoutManager} subclass.
+ */
+public final class RecyclerToListViewScrollListener extends RecyclerView.OnScrollListener {
+  public static final int UNKNOWN_SCROLL_STATE = Integer.MIN_VALUE;
+  private final AbsListView.OnScrollListener scrollListener;
+  private int lastFirstVisible = -1;
+  private int lastVisibleCount = -1;
+  private int lastItemCount = -1;
+
+  public RecyclerToListViewScrollListener(AbsListView.OnScrollListener scrollListener) {
+    this.scrollListener = scrollListener;
+  }
+
+  @Override
+  public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
+    int listViewState;
+    switch (newState) {
+      case RecyclerView.SCROLL_STATE_DRAGGING:
+        listViewState = ListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL;
+        break;
+      case RecyclerView.SCROLL_STATE_IDLE:
+        listViewState = ListView.OnScrollListener.SCROLL_STATE_IDLE;
+        break;
+      case RecyclerView.SCROLL_STATE_SETTLING:
+        listViewState = ListView.OnScrollListener.SCROLL_STATE_FLING;
+        break;
+      default:
+        listViewState = UNKNOWN_SCROLL_STATE;
+    }
+
+    scrollListener.onScrollStateChanged(null /*view*/, listViewState);
+  }
+
+  @Override
+  public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+    LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();
+
+    int firstVisible = layoutManager.findFirstVisibleItemPosition();
+    int visibleCount = Math.abs(firstVisible - layoutManager.findLastVisibleItemPosition());
+    int itemCount = recyclerView.getAdapter().getItemCount();
+
+    if (firstVisible != lastFirstVisible || visibleCount != lastVisibleCount
+        || itemCount != lastItemCount) {
+      scrollListener.onScroll(null, firstVisible, visibleCount, itemCount);
+      lastFirstVisible = firstVisible;
+      lastVisibleCount = visibleCount;
+      lastItemCount = itemCount;
+    }
+  }
+}
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
new file mode 100644
index 000000000..6e062e393
--- /dev/null
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.integration.recyclerview;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v7.widget.RecyclerView;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.ListPreloader;
+import com.bumptech.glide.ListPreloader.PreloadModelProvider;
+import com.bumptech.glide.ListPreloader.PreloadSizeProvider;
+import com.bumptech.glide.RequestManager;
+
+/**
+ * Loads a few resources ahead in the direction of scrolling in any {@link RecyclerView} so that
+ * images are in the memory cache just before the corresponding view in created in the list. Gives
+ * the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and
+ * cache size.
+ *
+ * <p> Must be added as a listener to the {@link RecyclerView} using
+ * {@link RecyclerView#addOnScrollListener(RecyclerView.OnScrollListener)}, or have its
+ * corresponding methods called from another
+ * {@link android.support.v7.widget.RecyclerView.OnScrollListener} to function. </p>
+ *
+ * <p> This class only works with {@link android.support.v7.widget.LinearLayoutManager} and
+ * subclasses of {@link android.support.v7.widget.LinearLayoutManager}. </p>
+ *
+ * @param <T> The type of the model being displayed in the {@link RecyclerView}.
+ */
+@SuppressWarnings("unused")
+public final class RecyclerViewPreloader<T> extends RecyclerView.OnScrollListener {
+
+  private final RecyclerToListViewScrollListener recyclerScrollListener;
+
+  /**
+   * Helper constructor that accepts an {@link Activity}.
+   */
+  public RecyclerViewPreloader(Activity activity,
+      PreloadModelProvider<T> preloadModelProvider,
+      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+    this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link FragmentActivity}.
+   */
+  public RecyclerViewPreloader(FragmentActivity fragmentActivity,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link Fragment}.
+   */
+  public RecyclerViewPreloader(Fragment fragment,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
+   */
+  public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+  /**
+   * Constructor that accepts interfaces for providing the dimensions of images to preload, the list
+   * of models to preload for a given position, and the request to use to load images.
+   *
+   * @param preloadModelProvider     Provides models to load and requests capable of loading them.
+   * @param preloadDimensionProvider Provides the dimensions of images to load.
+   * @param maxPreload               Maximum number of items to preload.
+   */
+  public RecyclerViewPreloader(RequestManager requestManager,
+      PreloadModelProvider<T> preloadModelProvider,
+      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+
+    ListPreloader<T> listPreloader = new ListPreloader<>(requestManager, preloadModelProvider,
+        preloadDimensionProvider, maxPreload);
+    recyclerScrollListener = new RecyclerToListViewScrollListener(listPreloader);
+  }
+
+  @Override
+  public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+    recyclerScrollListener.onScrolled(recyclerView, dx, dy);
+  }
+}
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index db8779976..9656d8389 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,34 +1,37 @@
 apply plugin: 'com.android.library'
-apply plugin: 'robolectric'
+apply plugin: 'org.robolectric'
 
 repositories {
-  mavenCentral()
+    mavenCentral()
 }
 
 dependencies {
     compile project(':glide')
     compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
 
-    androidTestCompile project(":testutil")
-    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    androidTestCompile "junit:junit:${JUNIT_VERSION}"
-    androidTestCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    androidTestCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    // TODO: increase this to 2.0.+ when we compile against Java 7.
-    androidTestCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile project(":testutil")
+    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
-        applicationId 'com.bumptech.glide.integration.volley'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode = VERSION_CODE
-        versionName = VERSION_NAME
+        versionCode VERSION_CODE as int
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
     }
 }
 
diff --git a/integration/volley/gradle.properties b/integration/volley/gradle.properties
index 2f3689b8b..0fad11225 100644
--- a/integration/volley/gradle.properties
+++ b/integration/volley/gradle.properties
@@ -2,11 +2,11 @@ POM_NAME=Glide Volley Integration
 POM_ARTIFACT_ID=volley-integration
 POM_PACKAGING=aar
 
-VERSION_NAME=1.2.0-SNAPSHOT
-VERSION_MAJOR=1
-VERSION_MINOR=2
+VERSION_NAME=2.0.0-SNAPSHOT
+VERSION_MAJOR=2
+VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=4
+VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library to use Volley to fetch data over http/https in Glide
 
diff --git a/integration/volley/lint.xml b/integration/volley/lint.xml
index d9d6c9fff..ff7e5955c 100644
--- a/integration/volley/lint.xml
+++ b/integration/volley/lint.xml
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
-    <issue id="AllowBackup" severity="ignore" />
+    <issue id="AllowBackup" severity="ignore"/>
 </lint>
diff --git a/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
deleted file mode 100644
index 9ecd32f7c..000000000
--- a/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ /dev/null
@@ -1,213 +0,0 @@
-package com.bumptech.glide.integration.volley;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-import android.os.SystemClock;
-
-import com.android.volley.NoConnectionError;
-import com.android.volley.RequestQueue;
-import com.android.volley.ServerError;
-import com.android.volley.VolleyError;
-import com.android.volley.toolbox.Volley;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.testutil.TestUtil;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowSystemClock;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.ProtocolException;
-import java.net.URL;
-import java.util.concurrent.ExecutionException;
-
-/**
- * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server responses.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = VolleyStreamFetcherServerTest.FakeSystemClock.class)
-public class VolleyStreamFetcherServerTest {
-    private static final String DEFAULT_PATH = "/fakepath";
-
-    private MockWebServer mockWebServer;
-    private RequestQueue requestQueue;
-
-    @Before
-    public void setUp() throws IOException {
-        requestQueue = Volley.newRequestQueue(Robolectric.application);
-        mockWebServer = new MockWebServer();
-        mockWebServer.play();
-    }
-
-    @After
-    public void tearDown() throws IOException {
-        mockWebServer.shutdown();
-        requestQueue.stop();
-    }
-
-    @Test
-    public void testReturnsInputStreamOnStatusOk() throws Exception {
-        String expected = "fakedata";
-        mockWebServer.enqueue(new MockResponse()
-                .setBody(expected)
-                .setResponseCode(200));
-        DataFetcher<InputStream> fetcher = getFetcher();
-        InputStream is = fetcher.loadData(Priority.HIGH);
-        assertEquals(expected, TestUtil.isToString(is));
-    }
-
-    @Test
-    public void testHandlesRedirect301s() throws Exception {
-        String expected = "fakedata";
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(301)
-            .setHeader("Location", mockWebServer.getUrl("/redirect")));
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(200)
-            .setBody(expected));
-        InputStream is = getFetcher().loadData(Priority.LOW);
-        assertEquals(expected, TestUtil.isToString(is));
-    }
-
-    @Test
-    public void testHandlesRedirect302s() throws Exception {
-        String expected = "fakedata";
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(302)
-            .setHeader("Location", mockWebServer.getUrl("/redirect")));
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(200)
-            .setBody(expected));
-        InputStream is = getFetcher().loadData(Priority.LOW);
-        assertEquals(expected, TestUtil.isToString(is));
-    }
-
-    @Test
-    public void testHandlesUpToFiveRedirects() throws Exception {
-        int numRedirects = 4;
-        String expected = "redirectedData";
-        String redirectBase = "/redirect";
-        for (int i = 0; i < numRedirects; i++) {
-            mockWebServer.enqueue(new MockResponse()
-                    .setResponseCode(301)
-                    .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
-        }
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(200).setBody(expected));
-
-        InputStream is = getFetcher().loadData(Priority.NORMAL);
-        assertEquals(expected, TestUtil.isToString(is));
-
-        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
-        for (int i = 0; i < numRedirects; i++) {
-            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
-        }
-    }
-
-    @Test
-    public void testThrowsIfRedirectLocationIsEmpty() throws Exception {
-        for (int i = 0; i < 2; i++) {
-            mockWebServer.enqueue(new MockResponse().setResponseCode(301));
-        }
-
-        try {
-            getFetcher().loadData(Priority.NORMAL);
-            fail("Didn't get expected IOException");
-        } catch (ExecutionException e) {
-            assertThat(e.getCause()).isInstanceOf(VolleyError.class);
-        }
-    }
-
-    @Test
-    public void testThrowsIfStatusCodeIsNegativeOne() throws Exception {
-        mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
-        try {
-            getFetcher().loadData(Priority.LOW);
-            fail("Failed to get expected exception");
-        } catch (ExecutionException e) {
-            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
-        }
-    }
-
-    @Test
-    public void testThrowsAfterTooManyRedirects() throws Exception {
-        for (int i = 0; i < 20; i++) {
-            mockWebServer.enqueue(new MockResponse()
-                    .setResponseCode(301)
-                    .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
-        }
-        try {
-            getFetcher().loadData(Priority.NORMAL);
-            fail("Failed to get expected exception");
-        } catch (ExecutionException e) {
-            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
-            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);
-        }
-    }
-
-
-    @Test
-    public void testThrowsIfStatusCodeIs500() throws Exception {
-        mockWebServer.enqueue(new MockResponse().setResponseCode(500).setBody("error"));
-        try {
-            getFetcher().loadData(Priority.NORMAL);
-            fail("Failed to get expected exception");
-        } catch (ExecutionException e) {
-            assertThat(e.getCause()).isInstanceOf(ServerError.class);
-        }
-    }
-
-    @Test
-    public void testThrowsIfStatusCodeIs400() throws Exception {
-        mockWebServer.enqueue(new MockResponse().setResponseCode(400).setBody("error"));
-        try {
-            getFetcher().loadData(Priority.LOW);
-            fail("Failed to get expected exception");
-        } catch (ExecutionException e) {
-            assertThat(e.getCause()).isInstanceOf(ServerError.class);
-        }
-    }
-
-    private DataFetcher<InputStream> getFetcher() {
-        URL url = mockWebServer.getUrl(DEFAULT_PATH);
-        VolleyRequestFuture<InputStream> requestFuture = new VolleyRequestFuture<InputStream>() {
-            @Override
-            public InputStream get() throws InterruptedException, ExecutionException {
-                for (int i = 0; i < 251 && !isDone(); i++) {
-                    Thread.sleep(10);
-                    Robolectric.runUiThreadTasks();
-                }
-                if (!isDone()) {
-                    fail("Failed to get response from Volley in time");
-                }
-                return super.get();
-            }
-        };
-        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString()), requestFuture);
-    }
-
-    /** A shadow clock that doesn't rely on running on an Android thread with a Looper. */
-    @Implements(SystemClock.class)
-    public static class FakeSystemClock extends ShadowSystemClock {
-
-        @Implementation
-        public static long elapsedRealtime() {
-            // The default is to return something using the main looper, which doesn't exist on Volley's threads.
-            return System.currentTimeMillis();
-        }
-    }
-}
diff --git a/integration/volley/src/main/AndroidManifest.xml b/integration/volley/src/main/AndroidManifest.xml
index c2d679aab..af744318a 100644
--- a/integration/volley/src/main/AndroidManifest.xml
+++ b/integration/volley/src/main/AndroidManifest.xml
@@ -1,5 +1,10 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.bumptech.glide.integration.volley">
-  <application />
+
+    <application>
+        <meta-data
+            android:name="com.bumptech.glide.integration.volley.VolleyGlideModule"
+            android:value="GlideModule"/>
+    </application>
 </manifest>
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
new file mode 100644
index 000000000..85f2b5add
--- /dev/null
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -0,0 +1,31 @@
+package com.bumptech.glide.integration.volley;
+
+import android.content.Context;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.GlideModule;
+
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
+ * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p> If you're using gradle, you can include this module simply by depending on the aar, the
+ * module will be merged in by manifest merger. For other build systems or for more more
+ * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ */
+public class VolleyGlideModule implements GlideModule {
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
+  }
+}
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
new file mode 100644
index 000000000..837efdc8a
--- /dev/null
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.integration.volley;
+
+import com.android.volley.Request;
+import com.android.volley.Request.Priority;
+import com.bumptech.glide.load.data.DataFetcher.DataCallback;
+
+import java.io.InputStream;
+import java.util.Map;
+
+/**
+ * Used to construct a custom Volley request, such as for authentication header decoration.
+ */
+public interface VolleyRequestFactory {
+
+  /**
+   * Returns a Volley request for the given image url. The given future should be put as a
+   * listener or called when the request completes.
+   */
+
+  Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
+      Priority priority, Map<String, String> headers);
+
+}
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
index 854f189e9..b1cd97f05 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
@@ -54,109 +54,111 @@
  *
  * @param <T> The type of parsed response this future expects.
  */
-public class VolleyRequestFuture<T> implements Future<T>, Response.Listener<T>, Response.ErrorListener {
-    private Request<?> mRequest;
-    private boolean mResultReceived = false;
-    private T mResult;
-    private VolleyError mException;
-    private boolean mIsCancelled = false;
-
-    public static <E> VolleyRequestFuture<E> newFuture() {
-        return new VolleyRequestFuture<E>();
+public class VolleyRequestFuture<T> implements Future<T>,
+    Response.Listener<T>,
+    Response.ErrorListener {
+  private Request<?> mRequest;
+  private boolean mResultReceived = false;
+  private T mResult;
+  private VolleyError mException;
+  private boolean mIsCancelled = false;
+
+  public static <E> VolleyRequestFuture<E> newFuture() {
+    return new VolleyRequestFuture<E>();
+  }
+
+  public synchronized void setRequest(Request<?> request) {
+    mRequest = request;
+    if (mIsCancelled && mRequest != null) {
+      mRequest.cancel();
     }
+  }
 
-    public synchronized void setRequest(Request<?> request) {
-        mRequest = request;
-        if (mIsCancelled && mRequest != null) {
-            mRequest.cancel();
-        }
+  @Override
+  public synchronized boolean cancel(boolean mayInterruptIfRunning) {
+    if (isDone()) {
+      return false;
     }
-
-    @Override
-    public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-        if (isDone()) {
-            return false;
-        }
-        mIsCancelled = true;
-        if (mRequest != null) {
-            mRequest.cancel();
-        }
-        notifyAll();
-
-        return true;
+    mIsCancelled = true;
+    if (mRequest != null) {
+      mRequest.cancel();
     }
+    notifyAll();
 
-    @Override
-    public T get() throws InterruptedException, ExecutionException {
-        try {
-            return doGet(null);
-        } catch (TimeoutException e) {
-            throw new AssertionError(e);
-        }
-    }
+    return true;
+  }
 
-    @Override
-    public T get(long timeout, TimeUnit unit)
-            throws InterruptedException, ExecutionException, TimeoutException {
-        return doGet(TimeUnit.MILLISECONDS.convert(timeout, unit));
+  @Override
+  public T get() throws InterruptedException, ExecutionException {
+    try {
+      return doGet(null);
+    } catch (TimeoutException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Override
+  public T get(long timeout, TimeUnit unit)
+      throws InterruptedException, ExecutionException, TimeoutException {
+    return doGet(TimeUnit.MILLISECONDS.convert(timeout, unit));
+  }
+
+  private synchronized T doGet(Long timeoutMs)
+      throws InterruptedException, ExecutionException, TimeoutException {
+    if (mException != null) {
+      throw new ExecutionException(mException);
     }
 
-    private synchronized T doGet(Long timeoutMs)
-            throws InterruptedException, ExecutionException, TimeoutException {
-        if (mException != null) {
-            throw new ExecutionException(mException);
-        }
-
-        if (mResultReceived) {
-            return mResult;
-        }
-
-        if (isCancelled()) {
-            throw new CancellationException();
-        }
-
-        if (timeoutMs == null) {
-            wait(0);
-        } else if (timeoutMs > 0) {
-            wait(timeoutMs);
-        }
-
-        if (mException != null) {
-            throw new ExecutionException(mException);
-        }
-
-        if (isCancelled()) {
-            throw new CancellationException();
-        }
-
-        if (!mResultReceived) {
-            throw new TimeoutException();
-        }
+    if (mResultReceived) {
+      return mResult;
+    }
 
-        return mResult;
+    if (isCancelled()) {
+      throw new CancellationException();
     }
 
-    @Override
-    public boolean isCancelled() {
-        return mIsCancelled;
+    if (timeoutMs == null) {
+      wait(0);
+    } else if (timeoutMs > 0) {
+      wait(timeoutMs);
     }
 
-    @Override
-    public synchronized boolean isDone() {
-        return mResultReceived || mException != null || isCancelled();
+    if (mException != null) {
+      throw new ExecutionException(mException);
     }
 
-    @Override
-    public synchronized void onResponse(T response) {
-        mResultReceived = true;
-        mResult = response;
-        notifyAll();
+    if (isCancelled()) {
+      throw new CancellationException();
     }
 
-    @Override
-    public synchronized void onErrorResponse(VolleyError error) {
-        mException = error;
-        notifyAll();
+    if (!mResultReceived) {
+      throw new TimeoutException();
     }
+
+    return mResult;
+  }
+
+  @Override
+  public boolean isCancelled() {
+    return mIsCancelled;
+  }
+
+  @Override
+  public synchronized boolean isDone() {
+    return mResultReceived || mException != null || isCancelled();
+  }
+
+  @Override
+  public synchronized void onResponse(T response) {
+    mResultReceived = true;
+    mResult = response;
+    notifyAll();
+  }
+
+  @Override
+  public synchronized void onErrorResponse(VolleyError error) {
+    mException = error;
+    notifyAll();
+  }
 }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index ee3f5cb78..02e517cc0 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -1,106 +1,146 @@
 package com.bumptech.glide.integration.volley;
 
+import android.util.Log;
+
+import com.android.volley.AuthFailureError;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
 import com.android.volley.Response;
+import com.android.volley.VolleyError;
 import com.android.volley.toolbox.HttpHeaderParser;
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
+import java.util.Collections;
+import java.util.Map;
 
 /**
  * A DataFetcher backed by volley for fetching images via http.
  */
 public class VolleyStreamFetcher implements DataFetcher<InputStream> {
-    private final RequestQueue requestQueue;
-    private final GlideUrl url;
-    private VolleyRequestFuture<InputStream> requestFuture;
-
-    @SuppressWarnings("unused")
-    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
-        this(requestQueue, url,  null);
+  private static final String TAG = "VolleyStreamFetcher";
+  public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
+    @Override
+    public Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
+        Request.Priority priority, Map<String, String> headers) {
+      return new GlideRequest(url, callback, priority, headers);
     }
-
-    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
-            VolleyRequestFuture<InputStream> requestFuture) {
-        this.requestQueue = requestQueue;
-        this.url = url;
-        this.requestFuture = requestFuture;
-        if (requestFuture == null) {
-            this.requestFuture = VolleyRequestFuture.newFuture();
-        }
+  };
+
+  private final RequestQueue requestQueue;
+  private final VolleyRequestFactory requestFactory;
+  private final GlideUrl url;
+  private volatile Request<byte[]> request;
+
+  @SuppressWarnings("unused")
+  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
+    this(requestQueue, url, DEFAULT_REQUEST_FACTORY);
+  }
+
+  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
+      VolleyRequestFactory requestFactory) {
+    this.requestQueue = requestQueue;
+    this.url = url;
+    this.requestFactory = requestFactory;
+  }
+
+  @Override
+  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+    request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),
+        url.getHeaders());
+    requestQueue.add(request);
+  }
+
+  @Override
+  public void cleanup() {
+    // Do nothing.
+  }
+
+  @Override
+  public void cancel() {
+    Request<byte[]> local = request;
+    if (local != null) {
+      local.cancel();
+    }
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
+
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.REMOTE;
+  }
+
+  private static Request.Priority glideToVolleyPriority(Priority priority) {
+    switch (priority) {
+      case LOW:
+        return Request.Priority.LOW;
+      case HIGH:
+        return Request.Priority.HIGH;
+      case IMMEDIATE:
+        return Request.Priority.IMMEDIATE;
+      default:
+        return Request.Priority.NORMAL;
+    }
+  }
+
+  /**
+   * Default {@link com.android.volley.Request} implementation for Glide that recives errors and
+   * results on volley's background thread.
+   */
+  public static class GlideRequest extends Request<byte[]> {
+    private final DataCallback<? super InputStream> callback;
+    private final Priority priority;
+    private final Map<String, String> headers;
+
+    public GlideRequest(String url, DataCallback<? super InputStream> callback, Priority priority) {
+      this(url, callback, priority, Collections.<String, String>emptyMap());
     }
 
-    @Override
-    public InputStream loadData(Priority priority) throws Exception {
-        // Make sure the string url safely encodes non ascii characters.
-        String stringUrl = url.toURL().toString();
-        GlideRequest request = new GlideRequest(stringUrl, requestFuture, glideToVolleyPriority(priority));
-
-        requestFuture.setRequest(requestQueue.add(request));
-
-        return requestFuture.get();
+    public GlideRequest(String url, DataCallback<? super InputStream> callback, Priority priority,
+        Map<String, String> headers) {
+      super(Method.GET, url, null);
+      this.callback = callback;
+      this.priority = priority;
+      this.headers = headers;
     }
 
     @Override
-    public void cleanup() {
-        // Do nothing.
+    public Map<String, String> getHeaders() throws AuthFailureError {
+      return headers;
     }
 
     @Override
-    public String getId() {
-        return url.toString();
+    public Priority getPriority() {
+      return priority;
     }
 
     @Override
-    public void cancel() {
-        VolleyRequestFuture<InputStream> localFuture = requestFuture;
-        if (localFuture != null) {
-            localFuture.cancel(true);
-        }
+    protected VolleyError parseNetworkError(VolleyError volleyError) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Volley failed to retrieve response", volleyError);
+      }
+      callback.onLoadFailed(volleyError);
+      return super.parseNetworkError(volleyError);
     }
 
-    private static Request.Priority glideToVolleyPriority(Priority priority) {
-        switch (priority) {
-            case LOW:
-                return Request.Priority.LOW;
-            case HIGH:
-                return Request.Priority.HIGH;
-            case IMMEDIATE:
-                return Request.Priority.IMMEDIATE;
-            default:
-                return Request.Priority.NORMAL;
-
-        }
+    @Override
+    protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
+      callback.onDataReady(new ByteArrayInputStream(response.data));
+      return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
     }
 
-    private static class GlideRequest extends Request<byte[]> {
-        private final VolleyRequestFuture<InputStream> future;
-        private Priority priority;
-
-        public GlideRequest(String url, VolleyRequestFuture<InputStream> future, Priority priority) {
-            super(Method.GET, url, future);
-            this.future = future;
-            this.priority = priority;
-        }
-
-        @Override
-        public Priority getPriority() {
-            return priority;
-        }
-
-        @Override
-        protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
-            return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
-        }
-
-        @Override
-        protected void deliverResponse(byte[] response) {
-            future.onResponse(new ByteArrayInputStream(response));
-        }
+    @Override
+    protected void deliverResponse(byte[] response) {
+      // Do nothing.
     }
+  }
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index 686cb21a0..a07ef442e 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -4,70 +4,94 @@
 
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 
 import java.io.InputStream;
 
 /**
- *  A simple model loader for fetching media over http/https using Volley.
+ * A simple model loader for fetching media over http/https using Volley.
  */
 public class VolleyUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
-    /**
-     * The default factory for {@link VolleyUrlLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
-        private static RequestQueue internalQueue;
-        private RequestQueue requestQueue;
-
-        private static RequestQueue getInternalQueue(Context context) {
-            if (internalQueue == null) {
-                synchronized (Factory.class) {
-                    if (internalQueue == null) {
-                        internalQueue = Volley.newRequestQueue(context);
-                    }
-                }
-            }
-            return internalQueue;
-        }
+  private final RequestQueue requestQueue;
+  private final VolleyRequestFactory requestFactory;
 
-        /**
-         * Constructor for a new Factory that runs requests using a static singleton request queue.
-         */
-        public Factory(Context context) {
-            this(getInternalQueue(context));
-        }
+  public VolleyUrlLoader(RequestQueue requestQueue) {
+    this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
+  }
 
-        /**
-         * Constructor for a new Factory that runs requests using the given {@link RequestQueue}.
-         */
-        public Factory(RequestQueue requestQueue) {
-            this.requestQueue = requestQueue;
-        }
+  public VolleyUrlLoader(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
+    this.requestQueue = requestQueue;
+    this.requestFactory = requestFactory;
+  }
 
-        @Override
-        public ModelLoader<GlideUrl, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new VolleyUrlLoader(requestQueue);
-        }
+  @Override
+  public boolean handles(GlideUrl url) {
+    return true;
+  }
 
-        @Override
-        public void teardown() {
-            // Do nothing, this instance doesn't own the request queue.
-        }
-    }
+  @Override
+  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,
+      Options options) {
+    return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));
+  }
+
+  /**
+   * The default factory for {@link VolleyUrlLoader}s.
+   */
+  public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
+    private static volatile RequestQueue internalQueue;
 
+    private final VolleyRequestFactory requestFactory;
     private final RequestQueue requestQueue;
 
-    public VolleyUrlLoader(RequestQueue requestQueue) {
-        this.requestQueue = requestQueue;
+    /**
+     * Constructor for a new Factory that runs requests using a static singleton request queue.
+     */
+    public Factory(Context context) {
+      this(getInternalQueue(context));
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using the given {@link RequestQueue}.
+     */
+    public Factory(RequestQueue requestQueue) {
+      this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
+    }
+
+    /**
+     * Constructor for a new Factory with a custom Volley request factory that runs requests using
+     * the given {@link RequestQueue}.
+     */
+    public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
+      this.requestFactory = requestFactory;
+      this.requestQueue = requestQueue;
     }
 
     @Override
-    public DataFetcher<InputStream> getResourceFetcher(GlideUrl url, int width, int height) {
-        return new VolleyStreamFetcher(requestQueue, url, new VolleyRequestFuture<InputStream>());
+    public ModelLoader<GlideUrl, InputStream> build(Context context,
+        MultiModelLoaderFactory factory) {
+      return new VolleyUrlLoader(requestQueue, requestFactory);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+
+    private static RequestQueue getInternalQueue(Context context) {
+      if (internalQueue == null) {
+        synchronized (Factory.class) {
+          if (internalQueue == null) {
+            internalQueue = Volley.newRequestQueue(context);
+          }
+        }
+      }
+      return internalQueue;
     }
+  }
 }
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
new file mode 100644
index 000000000..0f72af7b5
--- /dev/null
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -0,0 +1,237 @@
+package com.bumptech.glide.integration.volley;
+
+import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.os.SystemClock;
+
+import com.android.volley.RequestQueue;
+import com.android.volley.VolleyError;
+import com.android.volley.toolbox.Volley;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.Headers;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowSystemClock;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server
+ * responses.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18,
+    shadows = VolleyStreamFetcherServerTest.FakeSystemClock.class)
+public class VolleyStreamFetcherServerTest {
+  private static final String DEFAULT_PATH = "/fakepath";
+
+  @Mock VolleyRequestFactory requestFactory;
+  @Mock DataFetcher.DataCallback<InputStream> callback;
+
+  private MockWebServer mockWebServer;
+  private RequestQueue requestQueue;
+  private ArgumentCaptor<InputStream> streamCaptor;
+  private CountDownLatch waitForResponseLatch;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+
+    waitForResponseLatch = new CountDownLatch(1);
+    doAnswer(new CountDown()).when(callback).onDataReady(any(InputStream.class));
+    doAnswer(new CountDown()).when(callback).onLoadFailed(any(Exception.class));
+    requestQueue = Volley.newRequestQueue(RuntimeEnvironment.application);
+    mockWebServer = new MockWebServer();
+    mockWebServer.start();
+
+    streamCaptor = ArgumentCaptor.forClass(InputStream.class);
+  }
+
+  @After
+  public void tearDown() throws IOException {
+    mockWebServer.shutdown();
+    requestQueue.stop();
+  }
+
+  @Test
+  public void testReturnsInputStreamOnStatusOk() throws Exception {
+    String expected = "fakedata";
+    mockWebServer.enqueue(new MockResponse().setBody(expected).setResponseCode(200));
+    DataFetcher<InputStream> fetcher = getFetcher();
+    fetcher.loadData(Priority.HIGH, callback);
+    waitForResponseLatch.await();
+    verify(callback).onDataReady(streamCaptor.capture());
+    assertStreamOf(expected, streamCaptor.getValue());
+  }
+
+  @Test
+  public void testHandlesRedirect301s() throws Exception {
+    String expected = "fakedata";
+    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
+        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
+    getFetcher().loadData(Priority.LOW, callback);
+    waitForResponseLatch.await();
+    verify(callback).onDataReady(streamCaptor.capture());
+    assertStreamOf(expected, streamCaptor.getValue());
+  }
+
+  @Test
+  public void testHandlesRedirect302s() throws Exception {
+    String expected = "fakedata";
+    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
+        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
+    getFetcher().loadData(Priority.LOW, callback);
+    waitForResponseLatch.await();
+    verify(callback).onDataReady(streamCaptor.capture());
+    assertStreamOf(expected, streamCaptor.getValue());
+  }
+
+  @Test
+  public void testHandlesUpToFiveRedirects() throws Exception {
+    int numRedirects = 4;
+    String expected = "redirectedData";
+    String redirectBase = "/redirect";
+    for (int i = 0; i < numRedirects; i++) {
+      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
+          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+    }
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
+
+    getFetcher().loadData(Priority.NORMAL, callback);
+    waitForResponseLatch.await();
+    verify(callback).onDataReady(streamCaptor.capture());
+    assertStreamOf(expected, streamCaptor.getValue());
+
+    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
+    for (int i = 0; i < numRedirects; i++) {
+      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
+    }
+  }
+
+  @Test
+  public void testCallsLoadFailedIfRedirectLocationIsEmpty() throws Exception {
+    for (int i = 0; i < 2; i++) {
+      mockWebServer.enqueue(new MockResponse().setResponseCode(301));
+    }
+
+    getFetcher().loadData(Priority.NORMAL, callback);
+    waitForResponseLatch.await();
+    verify(callback).onLoadFailed(isA(VolleyError.class));
+  }
+
+  @Test
+  public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
+    getFetcher().loadData(Priority.LOW, callback);
+    waitForResponseLatch.await();
+    verify(callback).onLoadFailed(isA(VolleyError.class));
+  }
+
+  @Test
+  public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
+          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+    }
+    getFetcher().loadData(Priority.NORMAL, callback);
+    waitForResponseLatch.await();
+    verify(callback).onLoadFailed(isA(VolleyError.class));
+  }
+
+  @Test
+  public void testCallsLoadFailedIfStatusCodeIs500() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(500).setBody("error"));
+    getFetcher().loadData(Priority.NORMAL, callback);
+    waitForResponseLatch.await();
+    verify(callback).onLoadFailed(isA(VolleyError.class));
+  }
+
+  @Test
+  public void testCallsLoadFailedIfStatusCodeIs400() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(400).setBody("error"));
+    getFetcher().loadData(Priority.LOW, callback);
+    waitForResponseLatch.await();
+    verify(callback).onLoadFailed(isA(VolleyError.class));
+  }
+
+  @Test
+  public void testAppliesHeadersInGlideUrl() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
+    String headerField = "field";
+    String headerValue = "value";
+    Map<String, String> headersMap = new HashMap<>();
+    headersMap.put(headerField, headerValue);
+    Headers headers = mock(Headers.class);
+    when(headers.getHeaders()).thenReturn(headersMap);
+
+    getFetcher(headers).loadData(Priority.HIGH, callback);
+    waitForResponseLatch.await();
+
+    assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
+  }
+
+  private DataFetcher<InputStream> getFetcher() {
+    return getFetcher(Headers.DEFAULT);
+  }
+
+  private DataFetcher<InputStream> getFetcher(Headers headers) {
+    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
+  }
+
+  private class CountDown implements Answer<Void> {
+
+    @Override
+    public Void answer(InvocationOnMock invocation) throws Throwable {
+      waitForResponseLatch.countDown();
+      return null;
+    }
+  }
+
+  /**
+   * A shadow clock that doesn't rely on running on an Android thread with a Looper.
+   */
+  @Implements(SystemClock.class)
+  public static class FakeSystemClock extends ShadowSystemClock {
+
+    // Used by Shadow.
+    @SuppressWarnings("unused")
+    @Implementation
+    public static long elapsedRealtime() {
+      // The default is to return something using the main looper, which doesn't exist on
+      // Volley's threads.
+      return System.currentTimeMillis();
+    }
+  }
+}
diff --git a/integration/volley/volley.iml b/integration/volley/volley.iml
deleted file mode 100644
index c6d8f6e2c..000000000
--- a/integration/volley/volley.iml
+++ /dev/null
@@ -1,118 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":integration:volley" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="1.2.0-SNAPSHOT" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":integration:volley" />
-      </configuration>
-    </facet>
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="SELECTED_BUILD_VARIANT" value="debug" />
-        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
-        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
-        <option name="ALLOW_USER_CONFIGURATION" value="false" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
-        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
-        <option name="LIBRARY_PROJECT" value="true" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
-      <excludeFolder url="file://$MODULE_DIR$/build/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/docs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
-      <excludeFolder url="file://$MODULE_DIR$/build/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-report" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-results" />
-      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" exported="" scope="TEST" name="commons-codec-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-2.4" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="mockwebserver-1.6.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="okhttp-1.6.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="objenesis-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="robolectric-2.4" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="vtd-xml-2.11" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-commons-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-core-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="junit-4.11" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-tree-5.0.1" level="project" />
-    <orderEntry type="library" exported="" name="library-1.0.7" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-analysis-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="truth-0.24" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="mockito-all-1.9.5" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="ant-launcher-1.8.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="guava-17.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-util-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="bcprov-jdk15on-1.48" level="project" />
-    <orderEntry type="module" module-name="testutil" exported="" />
-    <orderEntry type="module" module-name="glide" exported="" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/library/build.gradle b/library/build.gradle
index a965b7d8c..d456240ad 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,5 +1,5 @@
 apply plugin: 'com.android.library'
-apply plugin: 'robolectric'
+apply plugin: 'org.robolectric'
 apply plugin: 'maven'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
@@ -7,10 +7,10 @@ apply plugin: 'jacoco'
 apply plugin: 'com.github.kt3k.coveralls'
 
 findbugs {
-    toolVersion = "2.0.3"
+    toolVersion = FINDBUGS_VERSION
 }
 jacoco {
-    toolVersion = "0.7.1.201405082137"
+    toolVersion = JACOCO_VERSION
 }
 coveralls {
     jacocoReportPath = 'build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml'
@@ -18,32 +18,34 @@ coveralls {
 
 dependencies {
     compile project(':third_party:gif_decoder')
-    compile project(':third_party:gif_encoder')
     compile project(':third_party:disklrucache')
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 
-    androidTestCompile project(':testutil')
-    androidTestCompile 'com.google.guava:guava-testlib:18.0'
-    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    androidTestCompile "junit:junit:${JUNIT_VERSION}"
-    androidTestCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    androidTestCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    // TODO: increase this to 2.0.+ when we compile against Java 7.
-    androidTestCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile project(':testutil')
+    testCompile 'com.google.guava:guava-testlib:18.0'
+    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+}
+
+android.testOptions.unitTests.all {
+    // configure max heap size of the test JVM
+    maxHeapSize = '2048m'
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
-        applicationId 'com.bumptech.glide'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode = VERSION_CODE
-        versionName = VERSION_NAME
+        versionCode VERSION_CODE as int
+        versionName VERSION_NAME as String
     }
 
     buildTypes {
@@ -51,6 +53,11 @@ android {
             testCoverageEnabled = true
         }
     }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
 }
 
 afterEvaluate {
@@ -61,7 +68,7 @@ afterEvaluate {
 
         classes = fileTree('build/intermediates/classes/debug/')
         source = fileTree('src/main/java')
-        classpath = files(project.configurations.compile.asPath)
+        classpath = project.configurations.compile
 
         effort = 'max'
 
@@ -73,13 +80,10 @@ afterEvaluate {
         }
     }
 
-    findbugsTestDebug {
-        enabled = false
-    }
-
     check.dependsOn('findbugs')
 
     task pmd(type: Pmd) {
+        targetJdk = TargetJdk.VERSION_1_7
 
         description 'Run pmd'
         group 'verification'
@@ -96,13 +100,9 @@ afterEvaluate {
         }
     }
 
-    pmdTestDebug {
-        enabled = false
-    }
-
     check.dependsOn('pmd')
 
-    task jacocoTestReport(type:JacocoReport, dependsOn: testDebug) {
+    task jacocoTestReport(type: JacocoReport, dependsOn: testDebug) {
         def coverageSourceDirs = ['src/main/java']
         group = "Reporting"
         description = "Generate Jacoco coverage reports"
@@ -115,7 +115,7 @@ afterEvaluate {
                            '**/Manifest*.*',
                            '**/BitmapRequestBuilder.class',
                            '**/DrawableRequestBuilder.class',
-                           '**/GifRequestBuilder.class', ]
+                           '**/GifRequestBuilder.class',]
         )
 
         additionalSourceDirs = files(coverageSourceDirs)
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index eff7240f7..f929a391d 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -9,27 +9,31 @@
 
     <!-- BytesResource is the wrapper that is given control of the data. -->
     <Match>
-      <Class name="com.bumptech.glide.load.resource.bytes.BytesResource" />
-      <Method name="get" />
-      <Bug pattern="EI_EXPOSE_REP" />
+        <Class name="com.bumptech.glide.load.resource.bytes.BytesResource"/>
+        <Method name="get"/>
+        <Bug pattern="EI_EXPOSE_REP"/>
     </Match>
 
     <!-- We would rather expose the internal bytes than box or copy them. -->
     <Match>
-      <Class name="com.bumptech.glide.load.resource.bytes.BytesResource" />
-      <Bug pattern="EI_EXPOSE_REP2" />
+        <Class name="com.bumptech.glide.load.resource.bytes.BytesResource"/>
+        <Bug pattern="EI_EXPOSE_REP2"/>
     </Match>
 
-    <!-- Byte array fetcher just wraps a byte array to return an InputStream, data is not mutated. -->
+    <!-- RecyclableBufferedInputStream safely re-uses pooled byte arrays -->
     <Match>
-      <Class name="com.bumptech.glide.load.data.ByteArrayFetcher" />
-      <Bug pattern="EI_EXPOSE_REP2" />
+        <Class name="com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream"/>
+        <Bug pattern="EI_EXPOSE_REP2"/>
     </Match>
 
-    <!-- RecyclableBufferedInputStream safely re-uses pooled byte arrays -->
+    <!-- DecodeJob tasks are ordered, but equivalent ordering does not imply equality -->
+    <Match>
+        <Class name="com.bumptech.glide.load.engine.DecodeJob" />
+        <Bug pattern="EQ_COMPARETO_USE_OBJECT_EQUALS" />
+    </Match>
     <Match>
-      <Class name="com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream" />
-      <Bug pattern="EI_EXPOSE_REP2" />
+       <Class name="com.bumptech.glide.load.engine.GlideException$IndentedPrintStream" />
+       <Bug pattern="DM_DEFAULT_ENCODING" />
     </Match>
 
 </FindBugsFilter>
diff --git a/library/library.iml b/library/library.iml
deleted file mode 100644
index d1471e49c..000000000
--- a/library/library.iml
+++ /dev/null
@@ -1,121 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":library" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":library" />
-      </configuration>
-    </facet>
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="SELECTED_BUILD_VARIANT" value="debug" />
-        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
-        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
-        <option name="ALLOW_USER_CONFIGURATION" value="false" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
-        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
-        <option name="LIBRARY_PROJECT" value="true" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
-      <excludeFolder url="file://$MODULE_DIR$/build/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
-      <excludeFolder url="file://$MODULE_DIR$/build/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-report" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-results" />
-      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="objenesis-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="guava-18.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="truth-0.24" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-2.4" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="jsr305-1.3.9" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="commons-codec-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="mockwebserver-1.6.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="okhttp-1.6.0" level="project" />
-    <orderEntry type="library" exported="" name="support-v4-19.1.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="robolectric-2.4" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="guava-testlib-18.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-commons-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="vtd-xml-2.11" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-core-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-tree-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="junit-4.11" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-analysis-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="mockito-all-1.9.5" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="ant-launcher-1.8.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-util-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="bcprov-jdk15on-1.48" level="project" />
-    <orderEntry type="module" module-name="gif_decoder" exported="" />
-    <orderEntry type="module" module-name="testutil" exported="" />
-    <orderEntry type="module" module-name="disklrucache" exported="" />
-    <orderEntry type="module" module-name="gif_encoder" exported="" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/library/lint.xml b/library/lint.xml
index d9d6c9fff..ff7e5955c 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
-    <issue id="AllowBackup" severity="ignore" />
+    <issue id="AllowBackup" severity="ignore"/>
 </lint>
diff --git a/library/pmd-ruleset.xml b/library/pmd-ruleset.xml
index 94220cb69..01bb11a73 100644
--- a/library/pmd-ruleset.xml
+++ b/library/pmd-ruleset.xml
@@ -1,31 +1,38 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
-<ruleset name="PMD.rul" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
-
-  <description>This ruleset was created from PMD.rul</description>
-
-  <rule ref="rulesets/java/basic.xml" >
-    <exclude name="AvoidBranchingStatementAsLastInLoop" />
-  </rule>
-  <rule ref="rulesets/java/braces.xml" />
-  <rule ref="rulesets/java/strings.xml" />
-  <rule ref="rulesets/java/unusedcode.xml" />
-
-  <rule ref="rulesets/java/design.xml" >
-    <exclude name="ConfusingTernary" />
-    <exclude name="EmptyMethodInAbstractClassShouldBeAbstract" />
-    <exclude name="AvoidSynchronizedAtMethodLevel" />
-
-    <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
-    <exclude name="NonThreadSafeSingleton" />
-
-    <!-- TODO: Fix these -->
-    <exclude name="AvoidReassigningParameters" />
-    <exclude name="GodClass" />
-  </rule>
-
-  <rule ref="rulesets/java/empty.xml/EmptyCatchBlock" message="Commented blocks are ok">
-    <properties>
-      <property name="allowCommentedBlocks" value="true" />
-    </properties>
-  </rule>
+<ruleset name="PMD.rul" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
+
+    <description>This ruleset was created from PMD.rul</description>
+
+    <rule ref="rulesets/java/basic.xml">
+        <exclude name="AvoidBranchingStatementAsLastInLoop"/>
+    </rule>
+    <rule ref="rulesets/java/braces.xml"/>
+    <rule ref="rulesets/java/strings.xml">
+        <!-- TODO: This warns about annotations, apparently fixed in a later version. -->
+        <exclude name="AvoidDuplicateLiterals"/>
+    </rule>
+    <rule ref="rulesets/java/unusedcode.xml"/>
+
+    <rule ref="rulesets/java/design.xml">
+        <exclude name="ConfusingTernary"/>
+        <exclude name="EmptyMethodInAbstractClassShouldBeAbstract"/>
+        <exclude name="AvoidSynchronizedAtMethodLevel"/>
+
+        <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
+        <exclude name="NonThreadSafeSingleton"/>
+
+        <!-- TODO: Fix these -->
+        <exclude name="AvoidReassigningParameters"/>
+        <exclude name="GodClass"/>
+    </rule>
+
+    <rule ref="rulesets/java/empty.xml/EmptyCatchBlock" message="Commented blocks are ok">
+        <properties>
+            <property name="allowCommentedBlocks" value="true"/>
+        </properties>
+    </rule>
+
+
 </ruleset>
diff --git a/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java
deleted file mode 100644
index f972fd54e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package com.bumptech.glide;
-
-import static com.bumptech.glide.tests.Util.arg;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.tests.GlideShadowLooper;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
-public class BitmapTypeRequestTest {
-    private RequestManager.OptionsApplier optionsApplier;
-    private BitmapTypeRequest request;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        optionsApplier = mock(RequestManager.OptionsApplier.class);
-        when(optionsApplier.apply(any(GenericRequestBuilder.class))).thenAnswer(arg(0));
-        Glide glide = mock(Glide.class);
-        when(glide.buildTranscoder(any(Class.class), any(Class.class))).thenReturn(mock(ResourceTranscoder.class));
-        when(glide.buildDataProvider(any(Class.class), any(Class.class))).thenReturn(mock(DataLoadProvider.class));
-
-        GenericRequestBuilder original = new GenericRequestBuilder(Robolectric.application, Object.class,
-                mock(LoadProvider.class), null, glide, null, null);
-        request = new BitmapTypeRequest(original, mock(ModelLoader.class), mock(ModelLoader.class), optionsApplier);
-    }
-
-    @After
-    public void tearDown() {
-        Glide.tearDown();
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsOnToBytes() {
-        BitmapRequestBuilder builder = request.toBytes();
-        verify(optionsApplier).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsOnToBytesWithArgs() {
-        BitmapRequestBuilder builder = request.toBytes(Bitmap.CompressFormat.PNG, 2);
-        verify(optionsApplier).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsOnTranscode() {
-        ResourceTranscoder<Bitmap, Object> transcoder = mock(ResourceTranscoder.class);
-        BitmapRequestBuilder builder = request.transcode(transcoder, Object.class);
-        verify(optionsApplier).apply(eq(builder));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java
deleted file mode 100644
index 491907a8b..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.bumptech.glide;
-
-import static com.bumptech.glide.tests.Util.arg;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.tests.GlideShadowLooper;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
-public class DrawableTypeRequestTest {
-    private DrawableTypeRequest<String> request;
-    private RequestManager.OptionsApplier optionsApplier;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        optionsApplier = mock(RequestManager.OptionsApplier.class);
-        when(optionsApplier.apply(any(GenericRequestBuilder.class))).thenAnswer(arg(0));
-        request = new DrawableTypeRequest<String>(String.class, mock(ModelLoader.class),
-                mock(ModelLoader.class), Robolectric.application, Glide.get(Robolectric.application),
-                mock(RequestTracker.class), mock(Lifecycle.class), optionsApplier);
-    }
-
-    @After
-    public void tearDown() {
-        Glide.tearDown();
-    }
-
-    @Test
-    public void testDefaultOptionsAreAppliedOnAsBitmap() {
-        BitmapTypeRequest<String> builder = request.asBitmap();
-        verify(optionsApplier).apply(eq(builder));
-    }
-
-    @Test
-    public void testDefaultOptionsAreAppliedOnAsGif() {
-        GifTypeRequest<String> builder = request.asGif();
-        verify(optionsApplier).apply(eq(builder));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java
deleted file mode 100644
index 5de866ddf..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java
+++ /dev/null
@@ -1,166 +0,0 @@
-package com.bumptech.glide;
-
-import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.widget.ImageView;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.request.Request;
-import com.bumptech.glide.request.animation.GlideAnimationFactory;
-import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.tests.BackgroundUtil;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@SuppressWarnings("unchecked")
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GenericRequestBuilderTest {
-    private RequestTracker requestTracker;
-
-    @Before
-    public void setUp() {
-        requestTracker = mock(RequestTracker.class);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfContextIsNull() {
-        new GenericRequestBuilder(null, Object.class, mock(LoadProvider.class), Object.class, mock(Glide.class),
-                requestTracker, mock(Lifecycle.class));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfNonNullModelAndNullLoadProvider() {
-        new GenericRequestBuilder(Robolectric.application, Object.class, null, Object.class, mock(Glide.class),
-                requestTracker, mock(Lifecycle.class));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenGlideAnimationFactoryIsNull() {
-        getNullModelRequest().animate((GlideAnimationFactory) null);
-    }
-
-    @Test(expected =  IllegalArgumentException.class)
-    public void testThrowsWhenOverrideWidthLessThanZero() {
-        getNullModelRequest().override(-1, 100);
-    }
-
-    @Test(expected =  IllegalArgumentException.class)
-    public void testThrowsWhenOverrideWidthEqualToZero() {
-        getNullModelRequest().override(0, 100);
-    }
-
-    @Test(expected =  IllegalArgumentException.class)
-    public void testThrowsWhenOverrideHeightLessThanZero() {
-        getNullModelRequest().override(100, -5);
-    }
-
-    @Test(expected =  IllegalArgumentException.class)
-    public void testThrowsWhenOverrideHeightEqualToZero() {
-        getNullModelRequest().override(100, 0);
-    }
-
-    @Test
-    public void testDoesNotThrowWhenModelAndLoaderNull() {
-        new GenericRequestBuilder(Robolectric.application, null, null, Object.class, mock(Glide.class), requestTracker,
-                mock(Lifecycle.class));
-    }
-
-    @Test
-    public void testDoesNotThrowWithNullModelWhenDecoderSet() {
-        getNullModelRequest().decoder(mock(ResourceDecoder.class));
-    }
-
-    @Test
-    public void testDoesNotThrowWithNullModelWhenCacheDecoderSet() {
-        getNullModelRequest().cacheDecoder(mock(ResourceDecoder.class));
-    }
-
-    @Test
-    public void testDoesNotThrowWithNullModelWhenEncoderSet() {
-        getNullModelRequest().encoder(mock(ResourceEncoder.class));
-    }
-
-    @Test
-    public void testDoesNotThrowWithNullModelWhenDiskCacheStrategySet() {
-        getNullModelRequest().diskCacheStrategy(DiskCacheStrategy.ALL);
-    }
-
-    @Test
-    public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
-        getNullModelRequest().into(mock(Target.class));
-    }
-
-    @Test
-    public void testAddsNewRequestToRequestTracker() {
-        getNullModelRequest().into(mock(Target.class));
-        verify(requestTracker).runRequest(any(Request.class));
-    }
-
-    @Test
-    public void testRemovesPreviousRequestFromRequestTracker() {
-        Request previous = mock(Request.class);
-        Target target = mock(Target.class);
-        when(target.getRequest()).thenReturn(previous);
-
-        getNullModelRequest().into(target);
-
-        verify(requestTracker).removeRequest(eq(previous));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenNullTarget() {
-        getNullModelRequest().into((Target) null);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenNullView() {
-        getNullModelRequest().into((ImageView) null);
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
-        final ImageView imageView = new ImageView(Robolectric.application);
-        testInBackground(new BackgroundUtil.BackgroundTester() {
-            @Override
-            public void runTest() throws Exception {
-                getNullModelRequest().into(imageView);
-
-            }
-        });
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
-        final Target target = mock(Target.class);
-        testInBackground(new BackgroundUtil.BackgroundTester() {
-            @Override
-            public void runTest() throws Exception {
-                getNullModelRequest().into(target);
-            }
-        });
-    }
-
-    private GenericRequestBuilder getNullModelRequest() {
-        Glide glide = mock(Glide.class);
-        when(glide.buildImageViewTarget(any(ImageView.class), any(Class.class))).thenReturn(
-                mock(Target.class));
-        return new GenericRequestBuilder(Robolectric.application, null, null, Object.class, glide, requestTracker,
-                mock(Lifecycle.class)).load(null);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java
deleted file mode 100644
index 5c023dc09..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package com.bumptech.glide;
-
-import static com.bumptech.glide.tests.Util.arg;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.tests.GlideShadowLooper;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
-public class GenericTranscodeRequestTest {
-    private RequestManager.OptionsApplier optionsApplier;
-    private GenericTranscodeRequest<String, Object, Object> request;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        optionsApplier = mock(RequestManager.OptionsApplier.class);
-        when(optionsApplier.apply(any(GenericRequestBuilder.class))).thenAnswer(arg(0));
-        request = new GenericTranscodeRequest<String, Object, Object>(Robolectric.application,
-                Glide.get(Robolectric.application), String.class, mock(ModelLoader.class), Object.class,
-                Object.class, mock(RequestTracker.class), mock(Lifecycle.class), optionsApplier);
-    }
-
-    @After
-    public void tearDown() {
-        Glide.tearDown();
-    }
-
-    @Test
-    public void testTranscodeAppliesDefaultOptions() {
-        ResourceTranscoder<Object, Object> transcoder = mock(ResourceTranscoder.class);
-        GenericRequestBuilder<String, Object, Object, Object> builder = request.transcode(transcoder, Object.class);
-        verify(optionsApplier).apply(eq(builder));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java
deleted file mode 100644
index 2a0725cd6..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package com.bumptech.glide;
-
-import static com.bumptech.glide.tests.Util.arg;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.tests.GlideShadowLooper;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
-public class GifTypeRequestTest {
-    private RequestManager.OptionsApplier optionsApplier;
-    private GifTypeRequest<String> request;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        optionsApplier = mock(RequestManager.OptionsApplier.class);
-        when(optionsApplier.apply(any(GenericRequestBuilder.class))).thenAnswer(arg(0));
-
-        Glide glide = mock(Glide.class);
-        when(glide.buildTranscoder(any(Class.class), any(Class.class))).thenReturn(mock(ResourceTranscoder.class));
-        when(glide.buildDataProvider(any(Class.class), any(Class.class))).thenReturn(mock(DataLoadProvider.class));
-
-        GenericRequestBuilder original = new GenericRequestBuilder(Robolectric.application, String.class,
-                mock(LoadProvider.class), null, glide, null, null);
-        request = new GifTypeRequest<String>(original, mock(ModelLoader.class), optionsApplier);
-    }
-
-    @After
-    public void tearDown() {
-        Glide.tearDown();
-    }
-
-    @Test
-    public void testTranscodeAppliesDefaultOptions() {
-        ResourceTranscoder<GifDrawable, GifDrawable> transcoder = mock(ResourceTranscoder.class);
-        GenericRequestBuilder<String, InputStream, GifDrawable, GifDrawable> builder = request.transcode(transcoder,
-                GifDrawable.class);
-        verify(optionsApplier).apply(eq(builder));
-    }
-
-    @Test
-    public void testToBytesApplesDefaultOptions() {
-        GenericRequestBuilder<String, InputStream, GifDrawable, byte[]> builder = request.toBytes();
-        verify(optionsApplier).apply(eq(builder));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/GlideTest.java b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java
deleted file mode 100644
index 999ea0a49..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/GlideTest.java
+++ /dev/null
@@ -1,873 +0,0 @@
-package com.bumptech.glide;
-
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.notNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.res.AssetFileDescriptor;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import android.media.MediaMetadataRetriever;
-import android.net.Uri;
-import android.os.Handler;
-import android.os.ParcelFileDescriptor;
-import android.view.ViewGroup;
-import android.widget.ImageView;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.cache.DiskCache;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.stream.StreamModelLoader;
-import com.bumptech.glide.load.resource.bitmap.BitmapResource;
-import com.bumptech.glide.load.resource.bytes.BytesResource;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.request.Request;
-import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.animation.GlideAnimation;
-import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.tests.GlideShadowLooper;
-import com.bumptech.glide.testutil.TestResourceUtil;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.annotation.Resetter;
-import org.robolectric.shadows.ShadowBitmap;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.UUID;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
-
-/**
- * Tests for the {@link Glide} interface and singleton.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { GlideTest.ShadowFileDescriptorContentResolver.class,
-        GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class })
-public class GlideTest {
-    private Target target = null;
-    private ImageView imageView;
-    private RequestManager requestManager;
-
-    @Before
-    public void setUp() throws Exception {
-        Glide.tearDown();
-        // Ensure that target's size ready callback will be called synchronously.
-        target = mock(Target.class);
-        imageView = new ImageView(Robolectric.application);
-        imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
-        doAnswer(new CallCallback()).when(target).getSize(any(SizeReadyCallback.class));
-
-        Handler bgHandler = mock(Handler.class);
-        when(bgHandler.post(any(Runnable.class))).thenAnswer(new Answer<Boolean>() {
-            @Override
-            public Boolean answer(InvocationOnMock invocation) throws Throwable {
-                Runnable runnable = (Runnable) invocation.getArguments()[0];
-                runnable.run();
-                return true;
-            }
-        });
-
-        // Run all tasks on the main thread so they complete synchronously.
-        ExecutorService service = mock(ExecutorService.class);
-        when(service.submit(any(Runnable.class))).thenAnswer(new Answer<Future<?>>() {
-            @Override
-            public Future<?> answer(InvocationOnMock invocation) throws Throwable {
-                Runnable runnable = (Runnable) invocation.getArguments()[0];
-                runnable.run();
-                return mock(Future.class);
-            }
-        });
-
-        Glide.setup(new GlideBuilder(Robolectric.application)
-                .setMemoryCache(mock(MemoryCache.class))
-                .setDiskCache(mock(DiskCache.class))
-                .setResizeService(service)
-                .setDiskCacheService(service));
-        DataFetcher<InputStream> mockStreamFetcher = mock(DataFetcher.class);
-        when(mockStreamFetcher.getId()).thenReturn("fakeId");
-        when(mockStreamFetcher.loadData(any(Priority.class))).thenReturn(new ByteArrayInputStream(new byte[0]));
-        ModelLoader<GlideUrl, InputStream> mockUrlLoader = mock(ModelLoader.class);
-        when(mockUrlLoader.getResourceFetcher(any(GlideUrl.class), anyInt(), anyInt())).thenReturn(mockStreamFetcher);
-        ModelLoaderFactory<GlideUrl, InputStream> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-        when(mockUrlLoaderFactory.build(any(Context.class), any(GenericLoaderFactory.class)))
-                .thenReturn(mockUrlLoader);
-
-        Glide.get(getContext()).register(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);
-        Lifecycle lifecycle = mock(Lifecycle.class);
-        requestManager = new RequestManager(getContext(), lifecycle);
-        requestManager.resumeRequests();
-    }
-
-    @After
-    public void tearDown() {
-        Glide.tearDown();
-    }
-
-    @Test
-    public void testCanSetMemoryCategory() {
-        MemoryCache memoryCache = mock(MemoryCache.class);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-
-        MemoryCategory memoryCategory = MemoryCategory.NORMAL;
-        Glide glide = new GlideBuilder(getContext())
-                .setMemoryCache(memoryCache)
-                .setBitmapPool(bitmapPool)
-                .createGlide();
-        glide.setMemoryCategory(memoryCategory);
-
-        verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
-        verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
-    }
-
-    @Test
-    public void testClearMemory() {
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        MemoryCache memoryCache = mock(MemoryCache.class);
-
-        Glide glide = new GlideBuilder(getContext())
-                .setBitmapPool(bitmapPool)
-                .setMemoryCache(memoryCache)
-                .createGlide();
-
-        glide.clearMemory();
-
-        verify(bitmapPool).clearMemory();
-        verify(memoryCache).clearMemory();
-    }
-
-    @Test
-    public void testTrimMemory() {
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        MemoryCache memoryCache = mock(MemoryCache.class);
-
-        Glide glide = new GlideBuilder(getContext())
-                .setBitmapPool(bitmapPool)
-                .setMemoryCache(memoryCache)
-                .createGlide();
-
-        final int level = 123;
-
-        glide.trimMemory(level);
-
-        verify(bitmapPool).trimMemory(eq(level));
-        verify(memoryCache).trimMemory(eq(level));
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void testGenericLoader() throws Exception {
-        File expected = new File("test");
-
-        Target<File> target = mock(Target.class);
-        doAnswer(new CallCallback()).when(target).getSize(any(SizeReadyCallback.class));
-
-        GlideUrl glideUrl =  mock(GlideUrl.class);
-        DataFetcher<File> dataFetcher = mock(DataFetcher.class);
-        when(dataFetcher.loadData(any(Priority.class))).thenReturn(expected);
-        when(dataFetcher.getId()).thenReturn("id");
-        ModelLoader<GlideUrl, File> modelLoader = mock(ModelLoader.class);
-        when(modelLoader.getResourceFetcher(eq(glideUrl), anyInt(), anyInt()))
-                .thenReturn(dataFetcher);
-
-        Resource<File> expectedResource = mock(Resource.class);
-        when(expectedResource.get()).thenReturn(expected);
-        ResourceDecoder<File, File> sourceDecoder = mock(ResourceDecoder.class);
-        when(sourceDecoder.decode(eq(expected), anyInt(), anyInt())).thenReturn(expectedResource);
-        when(sourceDecoder.getId()).thenReturn("sourceDecoderId");
-        ResourceDecoder<File, File> cacheDecoder = mock(ResourceDecoder.class);
-        when(cacheDecoder.getId()).thenReturn("cacheDecoderId");
-        ResourceEncoder<File> encoder = mock(ResourceEncoder.class);
-        when(encoder.getId()).thenReturn("encoderId");
-        Encoder<File> sourceEncoder = mock(Encoder.class);
-        when(sourceEncoder.getId()).thenReturn("sourceEncoderId");
-
-        requestManager
-                .using(modelLoader, File.class)
-                .load(glideUrl)
-                .as(File.class)
-                .decoder(sourceDecoder)
-                .cacheDecoder(cacheDecoder)
-                .encoder(encoder)
-                .sourceEncoder(sourceEncoder)
-                .into(target);
-
-        verify(target).onResourceReady(eq(expected), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testFileDefaultLoaderWithInputStream() throws Exception {
-        registerFailFactory(File.class, ParcelFileDescriptor.class);
-        runTestFileDefaultLoader();
-    }
-
-    @Test
-    public void testFileDefaultLoaderWithFileDescriptor() throws Exception {
-        registerFailFactory(File.class, InputStream.class);
-        runTestFileDefaultLoader();
-    }
-
-    @Test
-    public void testFileDefaultLoader() {
-        runTestFileDefaultLoader();
-    }
-
-    private void runTestFileDefaultLoader() {
-        File file = new File("fake");
-        mockUri(Uri.fromFile(file));
-
-        requestManager.load(file).into(target);
-        requestManager.load(file).into(imageView);
-
-        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));
-        verify(target).setRequest((Request) notNull());
-
-        assertNotNull(imageView.getDrawable());
-    }
-
-    @Test
-    public void testUrlDefaultLoader() throws MalformedURLException {
-        URL url = new URL("http://www.google.com");
-
-        requestManager.load(url).into(target);
-        requestManager.load(url).into(imageView);
-
-        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));
-        verify(target).setRequest((Request) notNull());
-
-        assertNotNull(imageView.getDrawable());
-    }
-
-    @Test
-    public void testAsBitmapOption() {
-        Uri uri = Uri.parse("content://something/else");
-        mockUri(uri);
-
-        requestManager.load(uri).asBitmap().into(target);
-
-        verify(target).onResourceReady(any(Bitmap.class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testTranscodeOption() {
-        Uri uri = Uri.parse("content://something/else");
-        mockUri(uri);
-        final byte[] bytes = new byte[0];
-
-        ResourceTranscoder<Bitmap, byte[]> transcoder = mock(ResourceTranscoder.class);
-        when(transcoder.getId()).thenReturn("bytes");
-        when(transcoder.transcode(any(Resource.class))).thenReturn(new BytesResource(bytes));
-
-        requestManager
-                .load(uri)
-                .asBitmap()
-                .transcode(transcoder, byte[].class)
-                .into(target);
-
-        verify(target).onResourceReady(eq(bytes), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testToBytesOption() {
-        Uri uri = Uri.parse("content://something/else");
-        mockUri(uri);
-
-        requestManager.load(uri).asBitmap().toBytes().into(target);
-
-        verify(target).onResourceReady(any(byte[].class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testUriDefaultLoaderWithInputStream() throws Exception {
-        registerFailFactory(Uri.class, ParcelFileDescriptor.class);
-        runTestUriDefaultLoader();
-    }
-
-    @Test
-    public void testUriDefaultLoaderWithFileDescriptor() throws Exception {
-        registerFailFactory(Uri.class, InputStream.class);
-        runTestUriDefaultLoader();
-    }
-
-    @Test
-    public void testUriDefaultLoader() {
-        runTestUriDefaultLoader();
-    }
-
-    private void runTestUriDefaultLoader() {
-        Uri uri = Uri.parse("content://test/something");
-        mockUri(uri);
-
-        requestManager.load(uri).into(target);
-        requestManager.load(uri).into(imageView);
-
-        verify(target).onResourceReady(anyObject(), any(GlideAnimation.class));
-        verify(target).setRequest((Request) notNull());
-
-        assertNotNull(imageView.getDrawable());
-    }
-
-    @Test
-    public void testStringDefaultLoaderWithUrl() {
-        runTestStringDefaultLoader("http://www.google.com");
-    }
-
-    @Test
-    public void testFileStringDefaultLoaderWithInputStream() throws Exception {
-        registerFailFactory(String.class, ParcelFileDescriptor.class);
-        runTestFileStringDefaultLoader();
-    }
-
-    @Test
-    public void testFileStringDefaultLoaderWithFileDescriptor() throws Exception {
-        registerFailFactory(String.class, ParcelFileDescriptor.class);
-        runTestFileStringDefaultLoader();
-    }
-
-    @Test
-    public void testFileStringDefaultLoader() {
-        runTestFileStringDefaultLoader();
-    }
-
-    private void runTestFileStringDefaultLoader() {
-        String path = "/some/random/path";
-        mockUri(Uri.fromFile(new File(path)));
-        runTestStringDefaultLoader(path);
-    }
-
-    @Test
-    public void testUriStringDefaultLoaderWithInputStream() throws Exception {
-        registerFailFactory(String.class, ParcelFileDescriptor.class);
-        runTestUriStringDefaultLoader();
-    }
-
-    @Test
-    public void testUriStringDefaultLoaderWithFileDescriptor() throws Exception {
-        registerFailFactory(String.class, InputStream.class);
-        runTestUriStringDefaultLoader();
-    }
-
-    @Test
-    public void testUriStringDefaultLoader() {
-        runTestUriStringDefaultLoader();
-    }
-
-    private void runTestUriStringDefaultLoader() {
-        String stringUri = "content://some/random/uri";
-        mockUri(Uri.parse(stringUri));
-        runTestStringDefaultLoader(stringUri);
-    }
-
-    private void runTestStringDefaultLoader(String string) {
-        requestManager
-                .load(string)
-                .listener(new RequestListener<String, GlideDrawable>() {
-                    @Override
-                    public boolean onException(Exception e, String model, Target target, boolean isFirstResource) {
-                        if (!(e instanceof IOException)) {
-                            throw new RuntimeException(e);
-                        }
-                        return false;
-                    }
-
-                    @Override
-                    public boolean onResourceReady(GlideDrawable resource, String model, Target target,
-                            boolean isFromMemoryCache,
-                            boolean isFirstResource) {
-                        return false;
-                    }
-                })
-                .into(target);
-        requestManager.load(string).into(imageView);
-
-        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));
-        verify(target).setRequest((Request) notNull());
-
-        assertNotNull(imageView.getDrawable());
-    }
-
-    @Test
-    public void testIntegerDefaultLoaderWithInputStream() throws Exception {
-        registerFailFactory(Integer.class, ParcelFileDescriptor.class);
-        runTestIntegerDefaultLoader();
-    }
-
-    @Test
-    public void testIntegerDefaultLoaderWithFileDescriptor() throws Exception {
-        registerFailFactory(Integer.class, InputStream.class);
-        runTestIntegerDefaultLoader();
-    }
-
-    @Test
-    public void testIntegerDefaultLoader() {
-        runTestIntegerDefaultLoader();
-    }
-
-    private void runTestIntegerDefaultLoader() {
-        int integer = android.R.drawable.star_on;
-        mockUri("android.resource://" + "android" + "/drawable/star_on");
-
-        requestManager.load(integer).into(target);
-        requestManager.load(integer).into(imageView);
-
-        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));
-        verify(target).setRequest((Request) notNull());
-
-        assertNotNull(imageView.getDrawable());
-    }
-
-    @Test
-    public void testByteArrayDefaultLoader() {
-        byte[] bytes = new byte[10];
-        requestManager.load(bytes).into(target);
-        requestManager.load(bytes).into(imageView);
-
-        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));
-        verify(target).setRequest((Request) notNull());
-
-        assertNotNull(imageView.getDrawable());
-    }
-
-    @Test
-    public void testByteArrayWithIdDefaultLoader() {
-        byte[] bytes = new byte[10];
-        String id = "test";
-
-        requestManager.load(bytes, id).into(target);
-        requestManager.load(bytes, id).into(imageView);
-
-        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));
-        verify(target).setRequest((Request) notNull());
-
-        assertNotNull(imageView.getDrawable());
-    }
-
-    @Test(expected = Exception.class)
-    public void testUnregisteredModelThrowsException() {
-        Float unregistered = 0.5f;
-        requestManager.load(unregistered).into(target);
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void testUnregisteredModelWithGivenLoaderDoesNotThrow() {
-        Float unregistered = 0.5f;
-        StreamModelLoader<Float> mockLoader = mockStreamModelLoader(Float.class);
-        requestManager
-                .using(mockLoader)
-                .load(unregistered)
-                .into(target);
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void testNonDefaultModelWithRegisteredFactoryDoesNotThrow() {
-        registerMockStreamModelLoader(Float.class);
-
-        requestManager.load(0.5f).into(target);
-    }
-
-    @Test
-    public void testReceivesGif() throws IOException {
-        String fakeUri = "content://fake";
-        InputStream testGifData = openResource("test.gif");
-        mockUri(Uri.parse(fakeUri), testGifData);
-
-        requestManager
-                .load(fakeUri)
-                .asGif()
-                .into(target);
-
-        verify(target).onResourceReady(any(GifDrawable.class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testReceivesGifBytes() throws IOException {
-        String fakeUri = "content://fake";
-        InputStream testGifData = openResource("test.gif");
-        mockUri(Uri.parse(fakeUri), testGifData);
-
-        requestManager
-                .load(fakeUri)
-                .asGif()
-                .toBytes()
-                .into(target);
-
-        verify(target).onResourceReady(any(byte[].class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testReceivesBitmapBytes() {
-        String fakeUri = "content://fake";
-        mockUri(fakeUri);
-        requestManager
-                .load(fakeUri)
-                .asBitmap()
-                .toBytes()
-                .into(target);
-
-        verify(target).onResourceReady(any(byte[].class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testReceivesTranscodedData() {
-        String fakeUri = "content://fake";
-        mockUri(fakeUri);
-        final Bitmap expected = Bitmap.createBitmap(1234, 6432, Bitmap.Config.ALPHA_8);
-        requestManager
-                .load(fakeUri)
-                .asBitmap()
-                .transcode(new ResourceTranscoder<Bitmap, Bitmap>() {
-                    @Override
-                    public Resource<Bitmap> transcode(Resource<Bitmap> toTranscode) {
-                        return new BitmapResource(expected, mock(BitmapPool.class));
-                    }
-
-                    @Override
-                    public String getId() {
-                        return "id";
-                    }
-                }, Bitmap.class)
-                .into(target);
-
-        verify(target).onResourceReady(eq(expected), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testReceivesThumbnails() {
-        String full = mockUri("content://full");
-        String thumb = mockUri("content://thumb");
-        requestManager
-                .load(full)
-                .thumbnail(requestManager
-                        .load(thumb))
-                .into(target);
-
-        verify(target, times(2)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testReceivesRecursiveThumbnails() {
-        requestManager
-                .load(mockUri("content://first"))
-                .thumbnail(requestManager
-                        .load(mockUri("content://second"))
-                        .thumbnail(requestManager
-                                .load(mockUri("content://third"))
-                                .thumbnail(requestManager
-                                        .load(mockUri("content://fourth"))
-                                )
-                        )
-                )
-                .into(target);
-        verify(target, times(4)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testReceivesRecursiveThumbnailWithPercentage() {
-        requestManager
-                .load(mockUri("content://first"))
-                .thumbnail(requestManager
-                        .load(mockUri("content://second"))
-                        .thumbnail(0.5f)
-                )
-                .into(target);
-        verify(target, times(3)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testNullModelInGenericImageLoadDoesNotThrow() {
-        requestManager.load((Double) null).into(target);
-    }
-
-    @Test
-    public void testNullModelInGenericVideoLoadDoesNotThrow() {
-        requestManager.load((Float) null).into(target);
-    }
-
-    @Test
-    public void testNullModelInGenericLoadDoesNotThrow() {
-        requestManager.load((Double) null).into(target);
-    }
-
-    @Test
-    public void testNullModelDoesNotThrow() {
-        String nullString = null;
-
-        Drawable drawable = new ColorDrawable(Color.RED);
-        requestManager
-                .load(nullString)
-                .placeholder(drawable)
-                .into(target);
-
-        verify(target).onLoadFailed(any(Exception.class), eq(drawable));
-    }
-
-    @Test
-    public void testNullModelPrefersErrorDrawable() {
-        String nullString = null;
-
-        Drawable placeholder = new ColorDrawable(Color.GREEN);
-        Drawable error = new ColorDrawable(Color.RED);
-
-        requestManager
-                .load(nullString)
-                .placeholder(placeholder)
-                .error(error)
-                .into(target);
-
-        verify(target).onLoadFailed(any(Exception.class), eq(error));
-    }
-
-    @Test
-    public void testNullModelWithModelLoaderDoesNotThrow() {
-        String nullString = null;
-        Drawable drawable = new ColorDrawable(Color.RED);
-        StreamModelLoader<String> modelLoader = mock(StreamModelLoader.class);
-        requestManager
-                .using(modelLoader)
-                .load(nullString)
-                .placeholder(drawable)
-                .into(target);
-
-        verify(target).onLoadFailed(any(Exception.class), eq(drawable));
-    }
-
-    @Test
-    public void testByteData() {
-        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };
-        requestManager.load(data).into(target);
-    }
-
-    @Test
-    public void testClone() throws IOException {
-        GlideDrawable firstResult = mock(GlideDrawable.class);
-        Resource<GlideDrawable> firstResource = mock(Resource.class);
-        when(firstResource.get()).thenReturn(firstResult);
-        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);
-        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);
-        when(firstTranscoder.getId()).thenReturn("transcoder1");
-
-        GlideDrawable secondResult = mock(GlideDrawable.class);
-        Resource<GlideDrawable> secondResource = mock(Resource.class);
-        when(secondResource.get()).thenReturn(secondResult);
-        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);
-        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);
-        when(secondTranscoder.getId()).thenReturn("transcoder2");
-
-        DrawableRequestBuilder<String> firstRequest = requestManager.from(String.class).transcoder(firstTranscoder)
-                .override(100, 100);
-        DrawableRequestBuilder<String> secondRequest = firstRequest.clone().transcoder(secondTranscoder);
-
-        Target firstTarget = mock(Target.class);
-        Target secondTarget = mock(Target.class);
-
-        String fakeUri = mockUri("content://fakeUri");
-
-        firstRequest.load(fakeUri).into(firstTarget);
-        verify(firstTarget).onResourceReady(eq(firstResult), any(GlideAnimation.class));
-
-        secondRequest.load(fakeUri).into(secondTarget);
-        verify(secondTarget).onResourceReady(eq(secondResult), any(GlideAnimation.class));
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource) throws Exception {
-        DataFetcher<Z> failFetcher = mock(DataFetcher.class);
-        when(failFetcher.loadData(any(Priority.class))).thenThrow(new IOException("test"));
-        when(failFetcher.getId()).thenReturn("fakeId");
-        ModelLoader<T, Z> failLoader = mock(ModelLoader.class);
-        when(failLoader.getResourceFetcher(any(failModel), anyInt(), anyInt())).thenReturn(failFetcher);
-        ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
-        when(failFactory.build(any(Context.class), any(GenericLoaderFactory.class))).thenReturn(failLoader);
-
-        Glide.get(getContext()).register(failModel, failResource, failFactory);
-    }
-
-    private String mockUri(String uriString) {
-        return mockUri(Uri.parse(uriString), null);
-    }
-
-    private String mockUri(Uri uri) {
-        return mockUri(uri, null);
-    }
-
-    private String mockUri(Uri uri, InputStream is) {
-        if (is == null) {
-            is = new ByteArrayInputStream(new byte[0]);
-        }
-        ContentResolver contentResolver = Robolectric.application.getContentResolver();
-        ShadowFileDescriptorContentResolver shadowContentResolver = Robolectric.shadowOf_(contentResolver);
-        shadowContentResolver.registerInputStream(uri, is);
-
-        AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
-        ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
-        when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
-
-        shadowContentResolver.registerAssetFileDescriptor(uri, assetFileDescriptor);
-        return uri.toString();
-    }
-
-    private Context getContext() {
-        return Robolectric.application;
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
-        StreamModelLoader<T> modelLoader = mockStreamModelLoader(modelClass);
-        ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
-        when(modelLoaderFactory.build(any(Context.class), any(GenericLoaderFactory.class)))
-                .thenReturn(modelLoader);
-
-        Glide.get(Robolectric.application).register(modelClass, InputStream.class, modelLoaderFactory);
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T> StreamModelLoader<T> mockStreamModelLoader(final Class<T> modelClass) {
-        StreamModelLoader<T> modelLoader = mock(StreamModelLoader.class);
-        DataFetcher<InputStream> fetcher = mock(DataFetcher.class);
-        try {
-            when(fetcher.loadData(any(Priority.class))).thenReturn(new ByteArrayInputStream(new byte[0]));
-        } catch (Exception e) {
-            // Do nothing.
-        }
-        when(fetcher.getId()).thenReturn(UUID.randomUUID().toString());
-        when(modelLoader.getResourceFetcher(any(modelClass), anyInt(), anyInt()))
-                .thenReturn(fetcher);
-
-        return modelLoader;
-    }
-
-
-    private InputStream openResource(String imageName) throws IOException {
-        return TestResourceUtil.openResource(getClass(), imageName);
-    }
-
-    private static class CallCallback implements Answer<Void> {
-        private int width;
-        private int height;
-
-        public CallCallback() {
-            this(100, 100);
-        }
-
-        public CallCallback(int width, int height) {
-            this.width = width;
-            this.height = height;
-        }
-
-        @Override
-        public Void answer(InvocationOnMock invocation) throws Throwable {
-            SizeReadyCallback cb = (SizeReadyCallback) invocation.getArguments()[0];
-            cb.onSizeReady(width, height);
-            return null;
-        }
-    }
-
-    // TODO: Extending ShadowContentResolver results in exceptions because of some state issues where we seem to get
-    // one content resolver shadow in one part of the test and a different one in a different part of the test. Each
-    // one ends up with different registered uris, which causes tests to fail. We shouldn't need to do this, but
-    // using static maps seems to fix the issue.
-    @Implements(value = ContentResolver.class)
-    public static class ShadowFileDescriptorContentResolver {
-        private static final Map<Uri, AssetFileDescriptor> URI_TO_FILE_DESCRIPTOR =
-                new HashMap<Uri, AssetFileDescriptor>();
-        private static final Map<Uri, InputStream> URI_TO_INPUT_STREAMS = new HashMap<Uri, InputStream>();
-
-        public void registerInputStream(Uri uri, InputStream inputStream) {
-            URI_TO_INPUT_STREAMS.put(uri, inputStream);
-        }
-
-        public void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
-            URI_TO_FILE_DESCRIPTOR.put(uri, assetFileDescriptor);
-        }
-
-        @Implementation
-        public InputStream openInputStream(Uri uri) {
-            if (!URI_TO_INPUT_STREAMS.containsKey(uri)) {
-                throw new IllegalArgumentException("You must first register an InputStream for uri: " + uri);
-            }
-            return URI_TO_INPUT_STREAMS.get(uri);
-        }
-
-        @Implementation
-        public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String type) {
-            if (!URI_TO_FILE_DESCRIPTOR.containsKey(uri)) {
-                throw new IllegalArgumentException("You must first register an AssetFileDescriptor for uri: " + uri);
-            }
-            return URI_TO_FILE_DESCRIPTOR.get(uri);
-        }
-
-        @Resetter
-        public static void reset() {
-            URI_TO_INPUT_STREAMS.clear();
-            URI_TO_FILE_DESCRIPTOR.clear();
-        }
-    }
-
-    @Implements(Bitmap.class)
-    public static class MutableShadowBitmap extends ShadowBitmap {
-
-        @Implementation
-        public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
-            Bitmap bitmap = ShadowBitmap.createBitmap(width, height, config);
-            Robolectric.shadowOf(bitmap).setMutable(true);
-            return bitmap;
-        }
-    }
-
-    @Implements(MediaMetadataRetriever.class)
-    public static class ShadowMediaMetadataRetriever {
-
-        @Implementation
-        @SuppressWarnings("unused")
-        public Bitmap getFrameAtTime() {
-            Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-            Robolectric.shadowOf(bitmap).appendDescription(" from MediaMetadataRetriever");
-            return bitmap;
-        }
-    }
-}
-
diff --git a/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java
deleted file mode 100644
index cf02f881a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java
+++ /dev/null
@@ -1,369 +0,0 @@
-package com.bumptech.glide;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.Target;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.verification.VerificationMode;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ListPreloaderTest {
-
-    @Mock
-    private BitmapRequestBuilder request;
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test
-    public void testGetItemsIsCalledIncreasing() {
-        final AtomicBoolean called = new AtomicBoolean(false);
-        final AtomicInteger calledCount = new AtomicInteger();
-
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                called.set(true);
-                final int count = calledCount.getAndIncrement();
-                assertEquals(11 + count, position);
-                return super.getPreloadItems(position);
-            }
-        };
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-        preloader.onScroll(null, 1, 10, 30);
-        assertEquals(10, calledCount.get());
-    }
-
-    @Test
-    public void testGetItemsIsCalledInOrderIncreasing() {
-        final int toPreload = 10;
-        final List<Object> objects = new ArrayList<Object>();
-        for (int i = 0; i < toPreload; i++) {
-            objects.add(new Integer(i));
-        }
-
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-
-            public int expectedPosition;
-
-            @Override
-            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-                return new int[]{10, 10};
-            }
-
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                return objects.subList(position - 11, position + 1 - 11);
-            }
-
-            @Override
-            public BitmapRequestBuilder getPreloadRequestBuilder(Object item) {
-                assertEquals(objects.get(expectedPosition), item);
-                expectedPosition++;
-                return mock(BitmapRequestBuilder.class);
-            }
-        };
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter,
-                toPreload);
-        preloader.onScroll(null, 1, 10, 20);
-    }
-
-    @Test
-    public void testGetItemsIsCalledDecreasing() {
-        final AtomicBoolean called = new AtomicBoolean(false);
-        final AtomicInteger calledCount = new AtomicInteger();
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                // Ignore the preload caused from us starting at the end
-                if (position >= 40) {
-                    return Collections.emptyList();
-                }
-                final int count = calledCount.getAndIncrement();
-                called.set(true);
-                assertEquals(28 - count, position);
-                return super.getPreloadItems(position);
-            }
-        };
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-        preloader.onScroll(null, 30, 10, 40);
-        preloader.onScroll(null, 29, 10, 40);
-        assertTrue(called.get());
-    }
-
-    @Test
-    public void testGetItemsIsCalledInOrderDecreasing() {
-        final int toPreload = 10;
-        final List<Object> objects = new ArrayList<Object>();
-        for (int i = 0; i < toPreload; i++) {
-            objects.add(new Object());
-        }
-
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            int expectedPosition = toPreload - 1;
-
-            @Override
-            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-                return new int[]{10, 10};
-            }
-
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                if (position == 40) {
-                    return null;
-                }
-                return objects.subList(position, position + 1);
-            }
-
-            @Override
-            public BitmapRequestBuilder getPreloadRequestBuilder(Object item) {
-                assertEquals(objects.get(expectedPosition), item);
-                expectedPosition--;
-                return mock(BitmapRequestBuilder.class);
-            }
-        };
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, toPreload);
-        preloader.onScroll(null, 30, 10, 10);
-        preloader.onScroll(null, 29, 10, 10);
-    }
-
-    @Test
-    public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
-        final AtomicBoolean called = new AtomicBoolean(false);
-        final AtomicInteger calledCount = new AtomicInteger();
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                called.set(true);
-                final int count = calledCount.getAndIncrement();
-                assertEquals(26 + count, position);
-                return super.getPreloadItems(position);
-            }
-        };
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-        preloader.onScroll(null, 16, 10, 30);
-        assertTrue(called.get());
-    }
-
-    @Test
-    public void testGetItemsIsNeverCalledWithStartLessThanZero() {
-        final AtomicBoolean called = new AtomicBoolean(false);
-        final AtomicInteger calledCount = new AtomicInteger();
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                if (position >= 17) {
-                    return Collections.emptyList();
-                }
-                called.set(true);
-                final int count = calledCount.getAndIncrement();
-                assertEquals(5 - count, position);
-                return super.getPreloadItems(position);
-            }
-        };
-
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-        preloader.onScroll(null, 7, 10, 30);
-        preloader.onScroll(null, 6, 10, 30);
-        assertTrue(called.get());
-    }
-
-    @Test
-    public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
-        final AtomicInteger called = new AtomicInteger();
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                final int current = called.getAndIncrement();
-                assertEquals(11 + current, position);
-                return super.getPreloadItems(position);
-            }
-        };
-
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-        preloader.onScroll(null, 1, 10, 30);
-        preloader.onScroll(null, 4, 10, 30);
-
-        assertEquals(13, called.get());
-    }
-
-    @Test
-    public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
-        final AtomicInteger called = new AtomicInteger();
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                if (position >= 20) {
-                    return Collections.emptyList();
-                }
-                final int current = called.getAndIncrement();
-                assertEquals(19 - current, position);
-                return super.getPreloadItems(position);
-            }
-        };
-
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-        preloader.onScroll(null, 21, 10, 30);
-        preloader.onScroll(null, 20, 10, 30);
-        preloader.onScroll(null, 17, 10, 30);
-        assertEquals(13, called.get());
-    }
-
-    @Test
-    public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException {
-        final List<Object> objects = new ArrayList<Object>();
-        objects.add(new Object());
-        objects.add(new Object());
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            public int expectedPosition = (1 + 10) * 2;
-
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                return objects;
-            }
-
-            @Override
-            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-                assertEquals(expectedPosition / 2, adapterPostion);
-                assertEquals(expectedPosition % 2, itemPosition);
-                expectedPosition++;
-                return itemPosition == 0 ? new int[]{10, 11} : new int[]{20, 21};
-            }
-
-            @Override
-            public GenericRequestBuilder getPreloadRequestBuilder(Object item) {
-                return request;
-            }
-        };
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-        Iterable<Integer> expected = Arrays.asList(10, 11, 20, 21, 10, 11, 20, 21);
-
-        preloader.onScroll(null, 1, 10, 1 + 10 + 2);
-
-        List<Integer> allValues = getTagetsSizes(request, times(4));
-        assertEquals(expected, allValues);
-    }
-
-    @Test
-    public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException {
-        final List<Object> objects = new ArrayList<Object>();
-        objects.add(new Object());
-        objects.add(new Object());
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            int expectedPosition = objects.size() * 2 - 1;
-
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                return objects;
-            }
-
-            @Override
-            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-                assertEquals(expectedPosition / 2, adapterPostion);
-                assertEquals(expectedPosition % 2, itemPosition);
-                expectedPosition--;
-                return itemPosition == 0 ? new int[]{10, 11} : new int[]{20, 21};
-            }
-
-            @Override
-            public GenericRequestBuilder getPreloadRequestBuilder(Object item) {
-                return request;
-            }
-        };
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-        Iterable<Integer> expected = Arrays.asList(20, 21, 10, 11, 20, 21, 10, 11);
-
-        preloader.onScroll(null, 3, 2, 3 + 2);
-        preloader.onScroll(null, 2, 2, 3 + 2);
-
-        List<Integer> allValues = getTagetsSizes(request, times(4));
-        assertEquals(expected, allValues);
-    }
-
-    private List<Integer> getTagetsSizes(BitmapRequestBuilder requestBuilder, VerificationMode callVerificationMode) {
-        ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
-        ArgumentCaptor<Target> targetArgumentCaptor = ArgumentCaptor.forClass(Target.class);
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        VerificationMode mode = atLeastOnce();
-        verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
-        for (Target target : targetArgumentCaptor.getAllValues()) {
-            target.getSize(cb);
-        }
-        verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
-        return integerArgumentCaptor.getAllValues();
-    }
-
-    @Test
-    public void testItemsArePreloadedWithGlide() {
-        final List<Object> objects = new ArrayList<Object>();
-        objects.add(new Object());
-        objects.add(new Object());
-        final HashSet<Object> loadedObjects = new HashSet<Object>();
-        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-            @Override
-            public List<Object> getPreloadItems(int position) {
-                return objects.subList(position - 11, position - 10);
-            }
-
-            @Override
-            public GenericRequestBuilder getPreloadRequestBuilder(Object item) {
-                loadedObjects.add(item);
-                return super.getPreloadRequestBuilder(item);
-            }
-        };
-        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
-
-        preloader.onScroll(null, 1, 10, 13);
-        assertThat(loadedObjects).containsAllIn(objects);
-    }
-
-    private static class ListPreloaderAdapter implements ListPreloader.PreloadModelProvider<Object>,
-            ListPreloader.PreloadSizeProvider<Object> {
-
-        public ListPreloaderAdapter() {
-        }
-
-        @Override
-        public List<Object> getPreloadItems(int position) {
-            ArrayList<Object> result = new ArrayList<Object>(1);
-            Collections.fill(result, new Object());
-            return result;
-        }
-
-        @Override
-        public GenericRequestBuilder getPreloadRequestBuilder(Object item) {
-            return mock(BitmapRequestBuilder.class);
-        }
-
-        @Override
-        public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-            return new int[]{100, 100};
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
deleted file mode 100644
index cef39a30e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
+++ /dev/null
@@ -1,278 +0,0 @@
-package com.bumptech.glide;
-
-import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.net.Uri;
-
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.file_descriptor.FileDescriptorModelLoader;
-import com.bumptech.glide.load.model.stream.StreamByteArrayLoader;
-import com.bumptech.glide.load.model.stream.StreamModelLoader;
-import com.bumptech.glide.manager.ConnectivityMonitor;
-import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
-import com.bumptech.glide.manager.ConnectivityMonitorFactory;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.tests.BackgroundUtil;
-import com.bumptech.glide.tests.GlideShadowLooper;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
-public class RequestManagerTest {
-    private RequestManager manager;
-    private ConnectivityMonitor connectivityMonitor;
-    private RequestTracker requestTracker;
-    private ConnectivityListener connectivityListener;
-    private RequestManager.DefaultOptions options;
-    private Lifecycle lifecycle = mock(Lifecycle.class);
-
-    @Before
-    public void setUp() {
-        connectivityMonitor = mock(ConnectivityMonitor.class);
-        ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
-        when(factory.build(any(Context.class), any(ConnectivityMonitor.ConnectivityListener.class)))
-                .thenAnswer(new Answer<ConnectivityMonitor>() {
-                    @Override
-                    public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
-                        connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
-                        return connectivityMonitor;
-                    }
-                });
-        requestTracker = mock(RequestTracker.class);
-        manager = new RequestManager(Robolectric.application, lifecycle, requestTracker, factory);
-        options = mock(RequestManager.DefaultOptions.class);
-        manager.setDefaultOptions(options);
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsWhenUsingGenericModelLoaderAndDataClass() {
-        Float model = 1f;
-        ModelLoader<Float, InputStream> modelLoader = mock(ModelLoader.class);
-        GenericTranscodeRequest<Float, InputStream, Bitmap> builder = manager.using(modelLoader, InputStream.class)
-                .load(model)
-                .as(Bitmap.class);
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsWhenUsingImageStreamModelLoader() {
-        String model = "fake";
-        StreamModelLoader<String> modelLoader = mock(StreamModelLoader.class);
-        DrawableTypeRequest<String> builder = manager.using(modelLoader)
-                .load(model);
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsWhenUsingByteArrayLoader() {
-        byte[] model = new byte[] { 1, 4, 65, 2};
-        StreamByteArrayLoader loader = mock(StreamByteArrayLoader.class);
-        DrawableTypeRequest<byte[]> builder = manager.using(loader)
-                .load(model);
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsWhenUsingVideoFileDescriptorModelLoader() {
-        String model = "fake";
-        FileDescriptorModelLoader<String> modelLoader = mock(FileDescriptorModelLoader.class);
-        DrawableTypeRequest<String> builder = manager.using(modelLoader)
-                .load(model);
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadString() {
-        String model = "fake";
-        DrawableTypeRequest<String> builder = manager.load(model);
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadUri() {
-        Uri uri = Uri.EMPTY;
-        DrawableTypeRequest<Uri> builder = manager.load(uri);
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadMediaStoreUri() {
-        Uri uri = Uri.EMPTY;
-        DrawableTypeRequest<Uri> builder = manager.loadFromMediaStore(uri, "image/jpeg", 123L, 0);
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadResourceId() {
-        int id = 123;
-        DrawableTypeRequest<Integer> builder = manager.load(id);
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadGenericFromImage() {
-        ModelLoaderFactory<Double, InputStream> factory = mock(ModelLoaderFactory.class);
-        when(factory.build(any(Context.class), any(GenericLoaderFactory.class))).thenReturn(mock(ModelLoader.class));
-        Glide.get(Robolectric.application).register(Double.class, InputStream.class, factory);
-        Double model = 2.2;
-        DrawableTypeRequest<Double> builder = manager.load(model);
-
-        verify(options).apply(eq(builder));
-        Glide.get(Robolectric.application).unregister(Double.class, InputStream.class);
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadUrl() throws MalformedURLException {
-        URL url = new URL("http://www.google.com");
-        DrawableTypeRequest<URL> builder = manager.load(url);
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadFromImageByteWithId() {
-        byte[] model = new byte[] { 1, 2, 4 };
-        DrawableTypeRequest<byte[]> builder = manager.load(model, "fakeId");
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadFromImageBytes() {
-        byte[] model = new byte[] { 5, 9, 23 };
-        DrawableTypeRequest<byte[]> builder = manager.load(model);
-
-        verify(options).apply(eq(builder));
-    }
-
-    @Test
-    public void testAppliesDefaultOptionsToLoadGenericFromVideo() {
-        ModelLoaderFactory<Float, InputStream> factory = mock(ModelLoaderFactory.class);
-        when(factory.build(any(Context.class), any(GenericLoaderFactory.class))).thenReturn(mock(ModelLoader.class));
-        Glide.get(Robolectric.application).register(Float.class, InputStream.class, factory);
-        Float model = 23.2f;
-        DrawableTypeRequest<Float> builder = manager.load(model);
-
-        verify(options).apply(eq(builder));
-        Glide.get(Robolectric.application).unregister(Float.class, InputStream.class);
-    }
-
-    @Test
-    public void testPauseRequestsPausesRequests() {
-        manager.pauseRequests();
-
-        verify(requestTracker).pauseRequests();
-    }
-
-    @Test
-    public void testResumeRequestsResumesRequests() {
-        manager.resumeRequests();
-
-        verify(requestTracker).resumeRequests();
-    }
-
-    @Test
-    public void testPausesRequestsOnStop() {
-        manager.onStart();
-        manager.onStop();
-
-        verify(requestTracker).pauseRequests();
-    }
-
-    @Test
-    public void testResumesRequestsOnStart() {
-        manager.onStart();
-
-        verify(requestTracker).resumeRequests();
-    }
-
-    @Test
-    public void testClearsRequestsOnDestroy() {
-        manager.onDestroy();
-
-        verify(requestTracker).clearRequests();
-    }
-
-    @Test
-    public void testAddsConnectivityMonitorToLifecycleWhenConstructed() {
-        verify(lifecycle).addListener(eq(connectivityMonitor));
-    }
-
-    @Test
-    public void testAddsSelfToLifecycleWhenConstructed() {
-        verify(lifecycle).addListener(eq(manager));
-    }
-
-    @Test
-    public void testRestartsRequestOnConnected() {
-        connectivityListener.onConnectivityChanged(true);
-
-        verify(requestTracker).restartRequests();
-    }
-
-    @Test
-    public void testDoesNotRestartRequestsOnDisconnected() {
-        connectivityListener.onConnectivityChanged(false);
-
-        verify(requestTracker, never()).restartRequests();
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testThrowsIfResumeCalledOnBackgroundThread() throws InterruptedException {
-        testInBackground(new BackgroundUtil.BackgroundTester() {
-            @Override
-            public void runTest() throws Exception {
-                manager.resumeRequests();
-            }
-        });
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testThrowsIfPauseCalledOnBackgroundThread() throws InterruptedException {
-        testInBackground(new BackgroundUtil.BackgroundTester() {
-            @Override
-            public void runTest() throws Exception {
-                manager.pauseRequests();
-            }
-        });
-    }
-
-    @Test
-    public void testDelegatesIsPausedToRequestTracker() {
-        when(requestTracker.isPaused()).thenReturn(true);
-        assertTrue(manager.isPaused());
-        when(requestTracker.isPaused()).thenReturn(false);
-        assertFalse(manager.isPaused());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java
deleted file mode 100644
index 9f263be41..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ /dev/null
@@ -1,141 +0,0 @@
-package com.bumptech.glide.load;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.util.ArrayList;
-
-@RunWith(JUnit4.class)
-public class MultiTransformationTest {
-    @Test
-    public void testReturnsConcatenatedTransformationIds() {
-        String firstId = "firstId";
-        Transformation first = mock(Transformation.class);
-        when(first.getId()).thenReturn(firstId);
-        String secondId = "secondId";
-        Transformation second = mock(Transformation.class);
-        when(second.getId()).thenReturn(secondId);
-        String thirdId = "thirdId";
-        Transformation third = mock(Transformation.class);
-        when(third.getId()).thenReturn(thirdId);
-
-        MultiTransformation transformation = new MultiTransformation(first, second, third);
-
-        final String expected = firstId + secondId + thirdId;
-        assertEquals(expected, transformation.getId());
-
-        ArrayList<Transformation> transformations = new ArrayList<Transformation>();
-        transformations.add(first);
-        transformations.add(second);
-        transformations.add(third);
-
-        transformation = new MultiTransformation(transformations);
-
-        assertEquals(expected, transformation.getId());
-    }
-
-    @Test
-    public void testAppliesTransformationsInOrder() {
-        final int width = 584;
-        final int height = 768;
-
-        Resource initial = mock(Resource.class);
-
-        Resource firstTransformed = mock(Resource.class);
-        Transformation first = mock(Transformation.class);
-        when(first.transform(eq(initial), eq(width), eq(height))).thenReturn(firstTransformed);
-
-        Resource secondTransformed = mock(Resource.class);
-        Transformation second = mock(Transformation.class);
-        when(second.transform(eq(firstTransformed), eq(width), eq(height))).thenReturn(secondTransformed);
-
-        MultiTransformation transformation = new MultiTransformation(first, second);
-
-        assertEquals(secondTransformed, transformation.transform(initial, width, height));
-    }
-
-    @Test
-    public void testInitialResourceIsNotRecycled() {
-        Resource initial = mock(Resource.class);
-
-        Resource transformed = mock(Resource.class);
-        Transformation first = mock(Transformation.class);
-        when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(transformed);
-
-        MultiTransformation transformation = new MultiTransformation(first);
-
-        transformation.transform(initial, 123, 456);
-
-        verify(initial, never()).recycle();
-    }
-
-    @Test
-    public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformations() {
-        Resource initial = mock(Resource.class);
-        Transformation first = mock(Transformation.class);
-        when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-        Transformation second = mock(Transformation.class);
-        when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-
-        MultiTransformation transformation = new MultiTransformation(first, second);
-        transformation.transform(initial, 1111, 2222);
-
-        verify(initial, never()).recycle();
-    }
-
-    @Test
-    public void testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
-        Resource initial = mock(Resource.class);
-        Transformation first = mock(Transformation.class);
-        when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-        Transformation second = mock(Transformation.class);
-        when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(mock(Resource.class));
-
-        MultiTransformation transformation = new MultiTransformation(first, second);
-        transformation.transform(initial, 1, 2);
-
-        verify(initial, never()).recycle();
-    }
-
-    @Test
-    public void testFinalResourceIsNotRecycled() {
-        Resource transformed = mock(Resource.class);
-        Transformation first = mock(Transformation.class);
-        when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(transformed);
-
-        MultiTransformation transformation = new MultiTransformation(first);
-
-        transformation.transform(mock(Resource.class), 111, 222);
-
-        verify(transformed, never()).recycle();
-    }
-
-    @Test
-    public void testIntermediateResourcesAreRecycled() {
-        Resource firstTransformed = mock(Resource.class);
-        Transformation first = mock(Transformation.class);
-        when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
-
-        Resource secondTransformed = mock(Resource.class);
-        Transformation second = mock(Transformation.class);
-        when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(secondTransformed);
-
-        MultiTransformation transformation = new MultiTransformation(first, second);
-
-        transformation.transform(mock(Resource.class), 233, 454);
-
-        verify(firstTransformed).recycle();
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
deleted file mode 100644
index 159c8f96e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.res.AssetFileDescriptor;
-import android.content.res.AssetManager;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.Priority;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class FileDescriptorAssetPathFetcherTest {
-    private FileDescriptorAssetPathFetcher fetcher;
-    private ParcelFileDescriptor expected;
-    private String assetPath;
-
-    @Before
-    public void setUp() throws IOException {
-        AssetManager assetManager = mock(AssetManager.class);
-        assetPath = "/some/asset/path";
-        fetcher = new FileDescriptorAssetPathFetcher(assetManager, assetPath);
-        expected = mock(ParcelFileDescriptor.class);
-        AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
-        when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(expected);
-        when(assetManager.openFd(eq(assetPath))).thenReturn(assetFileDescriptor);
-    }
-
-    @Test
-    public void testOpensInputStreamForPathWithAssetManager() throws Exception {
-        assertEquals(expected, fetcher.loadData(Priority.NORMAL));
-    }
-
-    @Test
-    public void testClosesOpenedInputStreamOnCleanup() throws Exception {
-        fetcher.loadData(Priority.NORMAL);
-        fetcher.cleanup();
-
-        verify(expected).close();
-    }
-
-    @Test
-    public void testReturnsAssetPathAsId() {
-        assertEquals(assetPath, fetcher.getId());
-    }
-
-    @Test
-    public void testDoesNothingOnCleanupIfNoDataLoaded() throws IOException {
-        fetcher.cleanup();
-        verify(expected, never()).close();
-    }
-
-    @Test
-    public void testDoesNothingOnCancel() throws Exception {
-        fetcher.loadData(Priority.NORMAL);
-        fetcher.cancel();
-        verify(expected, never()).close();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
deleted file mode 100644
index e3cb79395..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ /dev/null
@@ -1,217 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.testutil.TestUtil;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.SocketTimeoutException;
-import java.net.URL;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Tests {@link com.bumptech.glide.load.data.HttpUrlFetcher} against server responses. Tests for behavior
- * (connection/disconnection/options) should go in {@link com.bumptech.glide.load.data.HttpUrlFetcherTest}, response
- * handling should go here.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class HttpUrlFetcherServerTest {
-    private static final String DEFAULT_PATH = "/fakepath";
-
-    private MockWebServer mockWebServer;
-    private boolean defaultFollowRedirects;
-
-    @Before
-    public void setUp() throws IOException {
-        defaultFollowRedirects = HttpURLConnection.getFollowRedirects();
-        HttpURLConnection.setFollowRedirects(false);
-        mockWebServer = new MockWebServer();
-        mockWebServer.play();
-    }
-
-    @After
-    public void tearDown() throws IOException {
-        HttpURLConnection.setFollowRedirects(defaultFollowRedirects);
-        mockWebServer.shutdown();
-    }
-
-    @Test
-    public void testReturnsInputStreamOnStatusOk() throws Exception {
-        String expected = "fakedata";
-        mockWebServer.enqueue(new MockResponse()
-                .setBody(expected)
-                .setResponseCode(200));
-        HttpUrlFetcher fetcher = getFetcher();
-        InputStream is = fetcher.loadData(Priority.HIGH);
-        assertEquals(expected, TestUtil.isToString(is));
-    }
-
-    @Test
-    public void testHandlesRedirect301s() throws Exception {
-        String expected = "fakedata";
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(301)
-            .setHeader("Location", mockWebServer.getUrl("/redirect")));
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(200)
-            .setBody(expected));
-        InputStream is = getFetcher().loadData(Priority.LOW);
-        assertEquals(expected, TestUtil.isToString(is));
-    }
-
-    @Test
-    public void testHandlesRedirect302s() throws Exception {
-        String expected = "fakedata";
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(302)
-            .setHeader("Location", mockWebServer.getUrl("/redirect")));
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(200)
-            .setBody(expected));
-        InputStream is = getFetcher().loadData(Priority.LOW);
-        assertEquals(expected, TestUtil.isToString(is));
-    }
-
-    @Test
-    public void testHandlesRelativeRedirects() throws Exception {
-        String expected = "fakedata";
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(301)
-            .setHeader("Location", "/redirect"));
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(200)
-            .setBody(expected));
-        InputStream is = getFetcher().loadData(Priority.NORMAL);
-        assertEquals(expected, TestUtil.isToString(is));
-
-        mockWebServer.takeRequest();
-        RecordedRequest second = mockWebServer.takeRequest();
-        assertThat(second.getPath()).endsWith("/redirect");
-    }
-
-    @Test
-    public void testHandlesUpToFiveRedirects() throws Exception {
-        int numRedirects = 4;
-        String expected = "redirectedData";
-        String redirectBase = "/redirect";
-        for (int i = 0; i < numRedirects; i++) {
-            mockWebServer.enqueue(new MockResponse()
-                    .setResponseCode(301)
-                    .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
-        }
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(200).setBody(expected));
-
-        InputStream is = getFetcher().loadData(Priority.NORMAL);
-        assertEquals(expected, TestUtil.isToString(is));
-
-        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
-        for (int i = 0; i < numRedirects; i++) {
-            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
-        }
-    }
-
-    @Test
-    public void testThrowsOnRedirectLoops() throws Exception {
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(301).setHeader("Location", mockWebServer.getUrl("/redirect")));
-        mockWebServer.enqueue(new MockResponse()
-            .setResponseCode(301).setHeader("Location", mockWebServer.getUrl("/redirect")));
-
-        try {
-            getFetcher().loadData(Priority.IMMEDIATE);
-            fail("Didn't get expected IOException");
-        } catch (SocketTimeoutException e) {
-            fail("Didn't expect SocketTimeoutException");
-        } catch (IOException e) {
-            // Expected.
-        }
-    }
-
-    @Test
-    public void testThrowsIfRedirectLocationIsNotPresent() throws Exception {
-        mockWebServer.enqueue(new MockResponse().setResponseCode(301));
-
-        try {
-            getFetcher().loadData(Priority.NORMAL);
-            fail("Didn't get expected IOException");
-        } catch (IOException e) {
-            // Expected.
-        }
-    }
-
-    @Test
-    public void testThrowsIfRedirectLocationIsPresentAndEmpty() throws Exception {
-        mockWebServer.enqueue(new MockResponse()
-                .setResponseCode(301).setHeader("Location", ""));
-
-        try {
-            getFetcher().loadData(Priority.NORMAL);
-            fail("Didn't get expected IOException");
-        } catch (IOException e) {
-            // Expected.
-        }
-    }
-
-    @Test(expected = IOException.class)
-    public void testThrowsIfStatusCodeIsNegativeOne() throws Exception {
-        mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
-        getFetcher().loadData(Priority.LOW);
-    }
-
-    @Test(expected = IOException.class)
-    public void testThrowsAfterTooManyRedirects() throws Exception {
-        for (int i = 0; i < 10; i++) {
-            mockWebServer.enqueue(new MockResponse()
-                    .setResponseCode(301)
-                    .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
-        }
-        getFetcher().loadData(Priority.NORMAL);
-    }
-
-    @Test(expected = IOException.class)
-    public void testThrowsIfStatusCodeIs500() throws Exception {
-        mockWebServer.enqueue(new MockResponse().setResponseCode(500));
-        getFetcher().loadData(Priority.NORMAL);
-    }
-
-    @Test(expected = IOException.class)
-    public void testThrowsIfStatusCodeIs400() throws Exception {
-        mockWebServer.enqueue(new MockResponse().setResponseCode(400));
-        getFetcher().loadData(Priority.LOW);
-    }
-
-    @Test(expected = SocketTimeoutException.class)
-    public void testSetsReadTimeout() throws Exception {
-        MockWebServer mockWebServer = new MockWebServer();
-        mockWebServer.enqueue(new MockResponse().setBody("test").throttleBody(1, 2501, TimeUnit.SECONDS));
-        mockWebServer.play();
-        try {
-            getFetcher().loadData(Priority.HIGH);
-        } finally {
-            mockWebServer.shutdown();
-        }
-    }
-
-    private HttpUrlFetcher getFetcher() {
-        URL url = mockWebServer.getUrl(DEFAULT_PATH);
-        return new HttpUrlFetcher(new GlideUrl(url));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
deleted file mode 100644
index 7fda563c5..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.model.GlideUrl;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.InOrder;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
-@RunWith(JUnit4.class)
-public class HttpUrlFetcherTest {
-    private HttpURLConnection urlConnection;
-    private HttpUrlFetcher fetcher;
-    private GlideUrl glideUrl;
-    private InputStream stream;
-
-    @Before
-    public void setUp() throws IOException {
-        urlConnection =  mock(HttpURLConnection.class);
-        URL url = new URL("http://www.google.com");
-        HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory = mock(HttpUrlFetcher.HttpUrlConnectionFactory.class);
-        when(connectionFactory.build(eq(url))).thenReturn(urlConnection);
-
-        glideUrl = mock(GlideUrl.class);
-        when(glideUrl.toURL()).thenReturn(url);
-        fetcher = new HttpUrlFetcher(glideUrl, connectionFactory);
-        stream = mock(InputStream.class);
-        when(urlConnection.getInputStream()).thenReturn(stream);
-        when(urlConnection.getResponseCode()).thenReturn(200);
-    }
-
-    @Test
-    public void testReturnsModelAsString() {
-        final String expected = "fakeId";
-        when(glideUrl.toString()).thenReturn(expected);
-        assertEquals(expected, fetcher.getId());
-    }
-
-    @Test
-    public void testSetsReadTimeout() throws Exception {
-        fetcher.loadData(Priority.HIGH);
-        verify(urlConnection).setReadTimeout(eq(2500));
-    }
-
-    @Test
-    public void testSetsConnectTimeout() throws Exception {
-        fetcher.loadData(Priority.IMMEDIATE);
-        verify(urlConnection).setConnectTimeout(eq(2500));
-    }
-
-    @Test
-    public void testReturnsNullIfCancelledBeforeConnects() throws Exception {
-        InputStream notExpected = new ByteArrayInputStream(new byte[0]);
-        when(urlConnection.getInputStream()).thenReturn(notExpected);
-
-        fetcher.cancel();
-        assertNull(fetcher.loadData(Priority.LOW));
-    }
-
-    @Test
-    public void testDisconnectsUrlOnCleanup() throws Exception {
-        fetcher.loadData(Priority.HIGH);
-        fetcher.cleanup();
-
-        verify(urlConnection).disconnect();
-    }
-
-    @Test
-    public void testDoesNotThrowIfCleanupCalledBeforeStarted() {
-        fetcher.cleanup();
-    }
-
-    @Test
-    public void testDoesNotThrowIfCancelCalledBeforeStart() {
-        fetcher.cancel();
-    }
-
-    @Test
-    public void testCancelDoesNotDisconnectIfAlreadyConnected() throws Exception {
-        fetcher.loadData(Priority.HIGH);
-        fetcher.cancel();
-
-        verify(urlConnection, never()).disconnect();
-    }
-
-    @Test
-    public void testClosesStreamInCleanupIfNotNull() throws Exception {
-        fetcher.loadData(Priority.HIGH);
-        fetcher.cleanup();
-
-        verify(stream).close();
-    }
-
-    @Test
-    public void testClosesStreamBeforeDisconnectingConnection() throws Exception {
-        fetcher.loadData(Priority.NORMAL);
-        fetcher.cleanup();
-
-        InOrder order = inOrder(stream, urlConnection);
-        order.verify(stream).close();
-        order.verify(urlConnection).disconnect();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
deleted file mode 100644
index e5555cb2b..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.net.Uri;
-
-import com.bumptech.glide.Priority;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.Closeable;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class LocalUriFetcherTest {
-    private TestLocalUriFetcher fetcher;
-
-    @Before
-    public void setUp() {
-        fetcher = new TestLocalUriFetcher(Robolectric.application, Uri.parse("content://empty"));
-    }
-
-    @Test
-    public void testClosesDataOnCleanup() throws Exception {
-        Closeable closeable = fetcher.loadData(Priority.NORMAL);
-        fetcher.cleanup();
-
-        verify(closeable).close();
-    }
-
-    @Test
-    public void testDoesNotCloseNullData() throws IOException {
-        fetcher.cleanup();
-
-        verify(fetcher.closeable, never()).close();
-    }
-
-    @Test
-    public void testHandlesExceptionOnClose() throws Exception {
-        Closeable closeable = fetcher.loadData(Priority.NORMAL);
-
-        doThrow(new IOException("Test")).when(closeable).close();
-        fetcher.cleanup();
-        verify(closeable).close();
-    }
-
-    private static class TestLocalUriFetcher extends LocalUriFetcher<Closeable> {
-        final Closeable closeable = mock(Closeable.class);
-        public TestLocalUriFetcher(Context context, Uri uri) {
-            super(context, uri);
-        }
-
-        @Override
-        protected Closeable loadResource(Uri uri, ContentResolver contentResolver) throws FileNotFoundException {
-            return closeable;
-        }
-
-        @Override
-        protected void close(Closeable data) throws IOException {
-            data.close();
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java
deleted file mode 100644
index 325f3fc4c..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java
+++ /dev/null
@@ -1,117 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.net.Uri;
-import android.provider.MediaStore;
-
-import com.bumptech.glide.Priority;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class MediaStoreThumbFetcherTest {
-    private Harness harness;
-
-    @Before
-    public void setUp() {
-        harness = new Harness();
-    }
-
-    @Test
-    public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
-        InputStream expected = new ByteArrayInputStream(new byte[0]);
-
-        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(expected);
-
-        InputStream result = harness.get().loadData(Priority.LOW);
-        assertEquals(expected, result);
-    }
-
-    @Test
-    public void testReturnsInputStreamFromDefaultFetcherIfStreamFromThumbnailOpenerIsNull() throws Exception {
-        InputStream expected = new ByteArrayInputStream(new byte[0]);
-
-        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
-        when(harness.defaultFetcher.loadData(any(Priority.class))).thenReturn(expected);
-
-        assertEquals(expected, harness.get().loadData(Priority.HIGH));
-    }
-
-    @Test
-    public void testReturnsInputStreamFromDefaultFetcherIfFactoryReturnsNull() throws Exception {
-        InputStream expected = new ByteArrayInputStream(new byte[0]);
-
-        when(harness.factory.build(any(Uri.class), anyInt(), anyInt())).thenReturn(null);
-        when(harness.defaultFetcher.loadData(any(Priority.class))).thenReturn(expected);
-
-        assertEquals(expected, harness.get().loadData(Priority.IMMEDIATE));
-    }
-
-    @Test
-    public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
-        InputStream expected = mock(InputStream.class);
-
-        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(expected);
-
-        MediaStoreThumbFetcher fetcher = harness.get();
-        fetcher.loadData(Priority.HIGH);
-
-        fetcher.cleanup();
-        verify(expected).close();
-    }
-
-    @Test
-    public void testCallsCleanupOnDefaultFetcherOnCleanup() {
-        harness.get().cleanup();
-        verify(harness.defaultFetcher).cleanup();
-    }
-
-    @Test
-    public void testDoesNotThrowIfCleanupWithNullInputStream() {
-        harness.get().cleanup();
-    }
-
-    @Test
-    public void testContainsAllRelevantPartsInId() {
-        String id = harness.get().getId();
-        assertThat(id).contains(harness.uri.toString());
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class Harness {
-        Uri uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
-        DataFetcher<InputStream> defaultFetcher = mock(DataFetcher.class);
-        int width = 123;
-        int height = 222;
-
-        MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory factory = mock(
-                MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory.class);
-        MediaStoreThumbFetcher.ThumbnailStreamOpener
-                thumbnailFetcher = mock(MediaStoreThumbFetcher.ThumbnailStreamOpener.class);
-
-        public Harness() {
-            when(factory.build(eq(uri), eq(width), eq(height))).thenReturn(thumbnailFetcher);
-        }
-
-        public MediaStoreThumbFetcher get() {
-            return new MediaStoreThumbFetcher(Robolectric.application, uri, defaultFetcher, width, height, factory);
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
deleted file mode 100644
index cf768eb65..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.res.AssetManager;
-
-import com.bumptech.glide.Priority;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class StreamAssetPathFetcherTest {
-    private StreamAssetPathFetcher fetcher;
-    private InputStream expected;
-    private String assetPath;
-
-    @Before
-    public void setUp() throws IOException {
-        AssetManager assetManager = mock(AssetManager.class);
-        assetPath = "/some/asset/path";
-        fetcher = new StreamAssetPathFetcher(assetManager, assetPath);
-        expected = mock(InputStream.class);
-        when(assetManager.open(eq(assetPath))).thenReturn(expected);
-    }
-
-    @Test
-    public void testOpensInputStreamForPathWithAssetManager() throws Exception {
-        assertEquals(expected, fetcher.loadData(Priority.NORMAL));
-    }
-
-    @Test
-    public void testClosesOpenedInputStreamOnCleanup() throws Exception {
-        fetcher.loadData(Priority.NORMAL);
-        fetcher.cleanup();
-
-        verify(expected).close();
-    }
-
-    @Test
-    public void testReturnsAssetPathAsId() {
-        assertEquals(assetPath, fetcher.getId());
-    }
-
-    @Test
-    public void testDoesNothingOnCleanupIfNoDataLoaded() throws IOException {
-        fetcher.cleanup();
-        verify(expected, never()).close();
-    }
-
-    @Test
-    public void testDoesNothingOnCancel() throws Exception {
-        fetcher.loadData(Priority.NORMAL);
-        fetcher.cancel();
-        verify(expected, never()).close();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerFactoryTest.java
deleted file mode 100644
index 200b1fcf5..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerFactoryTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-import android.net.Uri;
-import android.provider.MediaStore;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ThumbnailStreamOpenerFactoryTest {
-    private MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory factory;
-    private Uri uri;
-
-    @Before
-    public void setUp() {
-        factory = new MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory();
-        uri = Uri.withAppendedPath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, "123");
-    }
-
-    @Test
-    public void testFactoryReturnsNullIfWidthTooLarge() {
-        MediaStoreThumbFetcher.ThumbnailStreamOpener fetcher = factory.build(uri, 10000, 1);
-        assertNull(fetcher);
-    }
-
-    @Test
-    public void testFactoryReturnsNullIfHeightTooLarge() {
-        MediaStoreThumbFetcher.ThumbnailStreamOpener fetcher = factory.build(uri, 1, 10000);
-        assertNull(fetcher);
-    }
-
-    @Test
-    public void testFactoryReturnsNullForNonMediaStoreUri() {
-        MediaStoreThumbFetcher.ThumbnailStreamOpener fetcher = factory.build(Uri.EMPTY, 1, 1);
-        assertNull(fetcher);
-    }
-
-    @Test
-    public void testFactoryReturnsImageFetcherForImageUri() {
-        MediaStoreThumbFetcher.ThumbnailStreamOpener fetcher = factory.build(uri, 1, 1);
-        assertNotNull(fetcher);
-    }
-
-    @Test
-    public void testFactoryReturnsVideoFetcherForVideoUri() {
-        uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
-        MediaStoreThumbFetcher.ThumbnailStreamOpener fetcher = factory.build(uri, 1, 1);
-        assertNotNull(fetcher);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java
deleted file mode 100644
index 2ddadbd9a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java
+++ /dev/null
@@ -1,127 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.database.MatrixCursor;
-import android.net.Uri;
-import android.provider.MediaStore;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.tester.android.database.SimpleTestCursor;
-import org.robolectric.tester.android.database.TestCursor;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ThumbnailStreamOpenerTest {
-    private Harness harness;
-
-    @Before
-    public void setUp() {
-        harness = new Harness();
-    }
-
-    @Test
-    public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
-        when(harness.query.query(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
-        assertNull(harness.get()
-                .open(Robolectric.application, harness.uri));
-    }
-
-    @Test
-    public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
-        when(harness.query.query(eq(Robolectric.application), eq(harness.uri))).thenReturn(
-                new MatrixCursor(new String[1]));
-        assertNull(harness.get()
-                .open(Robolectric.application, harness.uri));
-    }
-
-    @Test
-    public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
-        MatrixCursor cursor = new MatrixCursor(new String[1]);
-        cursor.addRow(new Object[]{ "" });
-        when(harness.query.query(eq(Robolectric.application), eq(harness.uri))).thenReturn(cursor);
-        assertNull(harness.get()
-                .open(Robolectric.application, harness.uri));
-    }
-
-    @Test
-    public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
-        when(harness.service.get(anyString())).thenReturn(harness.file);
-        when(harness.service.exists(eq(harness.file))).thenReturn(false);
-        assertNull(harness.get().open(Robolectric.application, harness.uri));
-    }
-
-    @Test
-    public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
-        when(harness.service.get(anyString())).thenReturn(harness.file);
-        when(harness.service.length(eq(harness.file))).thenReturn(0L);
-        assertNull(harness.get().open(Robolectric.application, harness.uri));
-    }
-
-    @Test
-    public void testClosesCursor() throws FileNotFoundException {
-        harness.get().open(Robolectric.application, harness.uri);
-        assertTrue(harness.cursor.isClosed());
-    }
-
-    @Test
-    public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundException {
-        InputStream expected = new ByteArrayInputStream(new byte[0]);
-        Robolectric.shadowOf(Robolectric.application.getContentResolver()).registerInputStream(harness.uri, expected);
-        assertEquals(expected, harness.get().open(Robolectric.application, harness.uri));
-    }
-
-    @Test
-    public void testVideoQueryReturnsVideoCursor() {
-        Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
-        MediaStoreThumbFetcher.VideoThumbnailQuery query = new MediaStoreThumbFetcher.VideoThumbnailQuery();
-        TestCursor testCursor = new SimpleTestCursor();
-        Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
-        assertEquals(testCursor, query.query(Robolectric.application, harness.uri));
-    }
-
-    @Test
-    public void testImageQueryReturnsImageCurosr() {
-        Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
-        MediaStoreThumbFetcher.ImageThumbnailQuery query = new MediaStoreThumbFetcher.ImageThumbnailQuery();
-        TestCursor testCursor = new SimpleTestCursor();
-        Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
-        assertEquals(testCursor, query.query(Robolectric.application, harness.uri));
-    }
-
-    private static class Harness {
-        MatrixCursor cursor = new MatrixCursor(new String[1]);
-        File file = new File("fake/uri");
-        Uri uri = Uri.fromFile(file);
-        MediaStoreThumbFetcher.ThumbnailQuery query = mock(MediaStoreThumbFetcher.ThumbnailQuery.class);
-        MediaStoreThumbFetcher.FileService service = mock(MediaStoreThumbFetcher.FileService.class);
-
-        public Harness() {
-            cursor.addRow(new String[] { file.getAbsolutePath() });
-            when(query.query(eq(Robolectric.application), eq(uri))).thenReturn(cursor);
-            when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
-            when(service.exists(eq(file))).thenReturn(true);
-            when(service.length(eq(file))).thenReturn(1L);
-        }
-
-        public MediaStoreThumbFetcher.ThumbnailStreamOpener get() {
-            return new MediaStoreThumbFetcher.ThumbnailStreamOpener(service, query);
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java
deleted file mode 100644
index fb51d33a1..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.data.resource;
-
-import static org.junit.Assert.assertEquals;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.data.ByteArrayFetcher;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.InputStream;
-
-@RunWith(JUnit4.class)
-public class ByteArrayFetcherTest {
-
-    @Test
-    public void testReturnsStreamWithBytes() throws Exception {
-        byte[] bytes = new byte[10];
-        for (int i = 0; i < bytes.length; i++) {
-            bytes[i] = (byte) i;
-        }
-
-        ByteArrayFetcher fetcher = new ByteArrayFetcher(bytes, "testId");
-        InputStream is = fetcher.loadData(Priority.NORMAL);
-
-        int read = 0;
-        byte current;
-        while ((current = (byte) is.read()) != -1) {
-            assertEquals(bytes[read], current);
-            read++;
-        }
-        assertEquals(bytes.length, read);
-    }
-
-    @Test
-    public void testReturnsGivenId() {
-        String expected = "fakeId";
-        ByteArrayFetcher fetcher = new ByteArrayFetcher(new byte[0], expected);
-        assertEquals(expected, fetcher.getId());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
deleted file mode 100644
index 8ce7a540c..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package com.bumptech.glide.load.data.resource;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.res.AssetFileDescriptor;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
-import com.bumptech.glide.tests.ContentResolverShadow;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { ContentResolverShadow.class })
-public class FileDescriptorLocalUriFetcherTest {
-
-    @Test
-    public void testLoadsFileDescriptor() throws Exception {
-        final Context context = Robolectric.application;
-        final Uri uri = Uri.parse("file://nothing");
-
-        ContentResolver contentResolver = context.getContentResolver();
-        ContentResolverShadow shadow = Robolectric.shadowOf_(contentResolver);
-
-        AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
-        ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
-        when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
-        shadow.registerFileDescriptor(uri, assetFileDescriptor);
-
-        FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
-        ParcelFileDescriptor descriptor = fetcher.loadData(Priority.NORMAL);
-
-        assertEquals(parcelFileDescriptor, descriptor);
-    }
-
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
deleted file mode 100644
index 150607b3f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package com.bumptech.glide.load.data.resource;
-
-import static org.junit.Assert.assertNotNull;
-
-import android.content.Context;
-import android.graphics.BitmapFactory;
-import android.net.Uri;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.data.StreamLocalUriFetcher;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class StreamLocalUriFetcherTest {
-
-    @Test
-    public void testLoadsInputStream() throws Exception {
-        final Context context = Robolectric.application;
-        Uri uri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-        StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
-        InputStream is = fetcher.loadData(Priority.NORMAL);
-        assertNotNull(is);
-        assertNotNull(BitmapFactory.decodeStream(is));
-        is.close();
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java
deleted file mode 100644
index aac4e5d2f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.cache.DiskCache;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.File;
-import java.io.IOException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class CacheLoaderTest {
-    private DiskCache diskCache;
-    private CacheLoader cacheLoader;
-    private Key key;
-    private ResourceDecoder<File, Object> decoder;
-    private Resource<Object> expected;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        diskCache = mock(DiskCache.class);
-        cacheLoader = new CacheLoader(diskCache);
-        key = mock(Key.class);
-        decoder = mock(ResourceDecoder.class);
-        expected =  mock(Resource.class);
-    }
-
-    @Test
-    public void testCacheDecoderIsCalledIfInCache() throws IOException {
-        File result = new File("test");
-        when(diskCache.get(eq(key))).thenReturn(result);
-
-        int width = 100;
-        int height = 101;
-        cacheLoader.load(key, decoder, width, height);
-
-        verify(decoder).decode(eq(result), eq(width), eq(height));
-    }
-
-    @Test
-    public void testReturnsDecodedResourceIfInCache() throws IOException {
-        int width = 50;
-        int height = 75;
-        File file = new File("test");
-        when(diskCache.get(eq(key))).thenReturn(file);
-        when(decoder.decode(eq(file), eq(width), eq(height))).thenReturn(expected);
-
-        assertEquals(expected, cacheLoader.load(key, decoder, width, height));
-    }
-
-    @Test
-    public void testReturnsNullIfNotInCache() {
-        assertNull(cacheLoader.load(key, decoder, 100, 100));
-    }
-
-    @Test
-    public void testDiskCacheEntryIsDeletedIfCacheDecoderThrows() throws IOException {
-        when(diskCache.get(eq(key))).thenReturn(new File("test"));
-        when(decoder.decode(any(File.class), anyInt(), anyInt())).thenThrow(new IOException("Test"));
-
-        cacheLoader.load(key, decoder, 100, 100);
-
-        verify(diskCache).delete(eq(key));
-    }
-
-    @Test
-    public void testDiskCacheEntryIsDeletedIfDiskCacheContainsIdAndCacheDecoderReturnsNull() throws IOException {
-        when(diskCache.get(eq(key))).thenReturn(new File("test"));
-        when(decoder.decode(any(File.class), anyInt(), anyInt())).thenReturn(null);
-
-        cacheLoader.load(key, decoder, 100, 101);
-
-        verify(diskCache).delete(eq(key));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java
deleted file mode 100644
index 3f4ccb9f2..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java
+++ /dev/null
@@ -1,634 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.engine.cache.DiskCache;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.List;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class DecodeJobTest {
-
-    private Harness harness;
-
-    @Before
-    public void setUp() throws FileNotFoundException {
-        harness = new Harness();
-    }
-
-    private void mockCacheToReturnResultResource() throws IOException {
-        File cacheFile = new File("fake");
-        when(harness.diskCache.get(eq(harness.key))).thenReturn(cacheFile);
-        when(harness.cacheDecoder.decode(eq(cacheFile), eq(harness.width), eq(harness.height)))
-                .thenReturn(harness.resource);
-    }
-
-    /** decodeResultFromCache **/
-
-    @Test
-    public void testDiskCacheIsCheckedForResultWhenCacheStrategyIncludesResult() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.ALL, DiskCacheStrategy.RESULT)) {
-            harness = new Harness(strategy);
-
-            mockCacheToReturnResultResource();
-
-            assertEquals("diskCacheStrategy: " + strategy, harness.resource, harness.getJob().decodeResultFromCache());
-        }
-    }
-
-    @Test
-    public void testDiskCacheIsNotCheckedForResultWhenCacheStrategyDoesNotIncludeResult() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.NONE, DiskCacheStrategy.SOURCE)) {
-            harness = new Harness(strategy);
-
-            harness.getJob().decodeResultFromCache();
-
-            verify(harness.diskCache, never()).get(eq(harness.key));
-        }
-    }
-
-    @Test
-    public void testDecodeResultFromCacheReturnsNullIfDiskCacheStrategyDoesNotIncludeResult() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.NONE, DiskCacheStrategy.SOURCE)) {
-            harness = new Harness(strategy);
-            mockCacheToReturnResultResource();
-
-            assertNull(harness.getJob().decodeResultFromCache());
-        }
-    }
-
-    @Test
-    public void testResultDecodedFromCacheIsTranscodedIfDecodeSucceeds() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        mockCacheToReturnResultResource();
-        Resource<Object> transcoded = mock(Resource.class);
-        when(harness.transcoder.transcode(eq(harness.resource))).thenReturn(transcoded);
-
-        assertEquals(transcoded, harness.getJob().decodeResultFromCache());
-    }
-
-    @Test
-    public void testResultDecodedFromCacheIsNotRecycledIfTranscoded() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        mockCacheToReturnResultResource();
-        Resource<Object> transcoded = mock(Resource.class);
-        when(harness.transcoder.transcode(eq(harness.resource))).thenReturn(transcoded);
-
-        harness.getJob().decodeResultFromCache();
-
-        verify(harness.resource, never()).recycle();
-    }
-
-    @Test
-    public void testDecodeResultFromCacheReturnsNullIfDiskCacheReturnsNull() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.diskCache.get(eq(harness.key))).thenReturn(null);
-
-        assertNull(harness.getJob().decodeResultFromCache());
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testDecodeResultFromCacheThrowsIfCacheDecoderThrows() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.diskCache.get(eq(harness.key))).thenReturn(new File("Fake"));
-        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt()))
-                .thenThrow(new RuntimeException("test"));
-
-        assertNull(harness.getJob().decodeResultFromCache());
-
-        verify(harness.cacheDecoder).decode(any(File.class), anyInt(), anyInt());
-    }
-
-    @Test
-    public void testEntryIsDeletedFromCacheIfCacheDecoderThrowsButResultIsInCache() throws IOException {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.diskCache.get(eq(harness.key))).thenReturn(new File("fake"));
-        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt())).thenThrow(new RuntimeException("test"));
-
-        try {
-            harness.getJob().decodeResultFromCache();
-            fail("Failed to get expected exception");
-        } catch (Exception exception) {
-            // Expected.
-        }
-
-        verify(harness.diskCache).delete(eq(harness.key));
-    }
-
-    @Test
-    public void testDecodeResultFromCacheReturnsNullIfCacheDecoderReturnsNull() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.diskCache.get(eq(harness.key))).thenReturn(new File("fake"));
-        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt())).thenReturn(null);
-
-        assertNull(harness.getJob().decodeResultFromCache());
-    }
-
-    @Test
-    public void testEntryIsDeletedFromCacheIfCacheDecoderReturnsNullButResultIsInCache() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.diskCache.get(eq(harness.key))).thenReturn(new File("fake"));
-        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt())).thenReturn(null);
-
-        harness.getJob().decodeResultFromCache();
-        verify(harness.diskCache).delete(eq(harness.key));
-    }
-
-    @Test
-    public void testDecodeResultFromCacheReturnsNullIfTranscoderReturnsNull() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        mockCacheToReturnResultResource();
-        when(harness.transcoder.transcode(any(Resource.class))).thenReturn(null);
-
-        assertNull(harness.getJob().decodeResultFromCache());
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testDecodeResultFromCacheThrowsIfTranscoderThrows() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        mockCacheToReturnResultResource();
-        when(harness.transcoder.transcode(any(Resource.class))).thenThrow(new RuntimeException("test"));
-
-        assertNull(harness.getJob().decodeResultFromCache());
-
-        verify(harness.transcoder).transcode(any(Resource.class));
-    }
-
-    /** decodeSourceFromCache **/
-
-    private void mockCacheToReturnSourceResource() throws IOException {
-        File file = new File("Test");
-        when(harness.diskCache.get(eq(harness.originalKey))).thenReturn(file);
-        when(harness.cacheDecoder.decode(eq(file), eq(harness.width), eq(harness.height)))
-                .thenReturn(harness.resource);
-    }
-
-    @Test
-    public void testDecodeSourceFromCacheReturnsNullIfCacheStrategyDoesNotCacheSource() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.NONE, DiskCacheStrategy.RESULT)) {
-            harness = new Harness(strategy);
-
-            mockCacheToReturnSourceResource();
-
-            assertNull(harness.getJob().decodeSourceFromCache());
-        }
-    }
-
-    @Test
-    public void testDiskCacheIsCheckedForSourceWhenCacheStrategyIncludesResult() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.ALL, DiskCacheStrategy.SOURCE)) {
-            harness = new Harness(strategy);
-
-            mockCacheToReturnSourceResource();
-
-            assertEquals(harness.resource, harness.getJob().decodeSourceFromCache());
-        }
-    }
-
-    @Test
-    public void testResourceFetcherIsNotCalledIfSourceIsCached() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.ALL, DiskCacheStrategy.SOURCE)) {
-            harness = new Harness(strategy);
-
-            mockCacheToReturnSourceResource();
-            harness.getJob().decodeSourceFromCache();
-
-            verify(harness.dataFetcher, never()).loadData(any(Priority.class));
-        }
-    }
-
-    @Test
-    public void testOriginalResourceIsTransformedTranscodedAndReturnedIfSourceIsCached() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.ALL, DiskCacheStrategy.SOURCE)) {
-            harness = new Harness(strategy);
-
-            mockCacheToReturnSourceResource();
-            Resource<Object> transformed = mock(Resource.class);
-            when(harness.transformation.transform(eq(harness.resource), eq(harness.width), eq(harness.height)))
-                    .thenReturn(transformed);
-            Resource<Object> transcoded = mock(Resource.class);
-            when(harness.transcoder.transcode(eq(transformed))).thenReturn(transcoded);
-
-            assertEquals(transcoded, harness.getJob().decodeSourceFromCache());
-        }
-    }
-
-    @Test
-    public void testOriginalResourceIsRecycledIfDifferentThanTransformedResource() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.ALL, DiskCacheStrategy.SOURCE)) {
-            harness = new Harness(strategy);
-
-            mockCacheToReturnSourceResource();
-            Resource<Object> transformed = mock(Resource.class);
-            when(harness.transformation.transform(eq(harness.resource), eq(harness.width), eq(harness.height)))
-                    .thenReturn(transformed);
-
-            harness.getJob().decodeSourceFromCache();
-            verify(harness.resource).recycle();
-        }
-    }
-
-    @Test
-    public void testOriginalResourceIsNotRecycledIfSameAsTransformedResource() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.ALL, DiskCacheStrategy.SOURCE)) {
-            harness = new Harness(strategy);
-
-            mockCacheToReturnSourceResource();
-            when(harness.transformation.transform(eq(harness.resource), eq(harness.width), eq(harness.height)))
-                    .thenReturn(harness.resource);
-
-            harness.getJob().decodeSourceFromCache();
-
-            verify(harness.resource, never()).recycle();
-        }
-    }
-
-    @Test
-    public void testTransformedResourceIsWrittenToCacheIfSourceIsCachedAndStrategyCachesResult() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-
-        mockCacheToReturnSourceResource();
-        Resource<Object> transformed = mock(Resource.class);
-        when(harness.transformation.transform(eq(harness.resource), anyInt(), anyInt())).thenReturn(transformed);
-        doAnswer(new CallWriter()).when(harness.diskCache).put(eq(harness.key), any(DiskCache.Writer.class));
-
-        harness.getJob().decodeSourceFromCache();
-
-        verify(harness.resultEncoder).encode(eq(transformed), any(OutputStream.class));
-    }
-
-    @Test
-    public void testTransformedResourceIsNotWrittenToCacheIfSourceIsCachedAndStrategyDoesNotCacheResult()
-            throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
-
-        mockCacheToReturnSourceResource();
-        harness.getJob().decodeSourceFromCache();
-
-        verify(harness.diskCache, never()).put(eq(harness.key), any(DiskCache.Writer.class));
-    }
-
-    @Test
-    public void testSourceIsDeletedFromCacheIfCacheDecodeFails() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        when(harness.diskCache.get(eq(harness.originalKey))).thenReturn(new File("fake"));
-        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt())).thenReturn(null);
-
-        assertNull(harness.getJob().decodeSourceFromCache());
-
-        verify(harness.diskCache).delete(eq(harness.originalKey));
-    }
-
-    @Test
-    public void testSourceIsDeletedFromCacheIfCacheDecoderThrows() throws IOException {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        when(harness.diskCache.get(eq(harness.originalKey))).thenReturn(new File("test"));
-        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt())).thenThrow(new RuntimeException("test"));
-
-        try {
-            harness.getJob().decodeSourceFromCache();
-            fail("Failed to get expected exception");
-        } catch (Exception e) {
-            // Expected.
-        }
-        verify(harness.diskCache).delete(eq(harness.originalKey));
-    }
-
-    @Test
-    public void testReturnsNullIfSourceCacheDecodeOfCachedSourceReturnsNull() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        when(harness.diskCache.get(eq(harness.originalKey))).thenReturn(new File("test"));
-        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt())).thenReturn(null);
-
-        assertNull(harness.getJob().decodeSourceFromCache());
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testThrowsIfCacheDecodeOfCachedSourceThrows() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        when(harness.diskCache.get(eq(harness.originalKey))).thenReturn(new File("test"));
-        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt())).thenThrow(new RuntimeException("test"));
-
-        harness.getJob().decodeSourceFromCache();
-    }
-
-    @Test
-    public void testReturnsNullIfTransformationOfResourceDecodedFromCachedSourceReturnsNull() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        mockCacheToReturnSourceResource();
-        when(harness.transformation.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(null);
-
-        assertNull(harness.getJob().decodeSourceFromCache());
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testThrowsIfTransformationOfResourceDecodedFromCachedSourceThrows() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        mockCacheToReturnSourceResource();
-        when(harness.transformation.transform(any(Resource.class), anyInt(), anyInt()))
-                .thenThrow(new RuntimeException("test"));
-
-        harness.getJob().decodeSourceFromCache();
-    }
-
-    @Test
-    public void testReturnsNullIfTranscoderOfResourceDecodedFromCachedSourceReturnsNull() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        mockCacheToReturnSourceResource();
-        when(harness.transcoder.transcode(any(Resource.class))).thenReturn(null);
-
-        assertNull(harness.getJob().decodeSourceFromCache());
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testThrowsIfTranscoderOfResourceDecodedFromCachedSourceThrows() throws Exception {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        mockCacheToReturnSourceResource();
-        when(harness.transcoder.transcode(any(Resource.class))).thenThrow(new RuntimeException("test"));
-
-        harness.getJob().decodeSourceFromCache();
-    }
-
-    /** decodeFromSource **/
-
-    private void mockSourceToReturnResource() throws Exception {
-        // For NONE/RESULT
-        Object data = new Object();
-        when(harness.dataFetcher.loadData(eq(harness.priority))).thenReturn(data);
-        when(harness.sourceDecoder.decode(eq(data), eq(harness.width), eq(harness.height)))
-                .thenReturn(harness.resource);
-
-        // For ALL/SOURCE
-        File cachedSource = new File("source");
-        when(harness.diskCache.get(eq(harness.originalKey))).thenReturn(cachedSource);
-        when(harness.cacheDecoder.decode(eq(cachedSource), eq(harness.width), eq(harness.height)))
-                .thenReturn(harness.resource);
-    }
-
-    @Test
-    public void testDecodeFromSourceDecodesTransformsAndTranscodesDataFromDataFetcher() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.values())) {
-            harness = new Harness(strategy);
-            mockSourceToReturnResource();
-
-            Resource<Object> transformed = mock(Resource.class);
-            when(harness.transformation.transform(eq(harness.resource), eq(harness.width), eq(harness.height)))
-                    .thenReturn(transformed);
-            Resource<Object> transcoded = mock(Resource.class);
-            when(harness.transcoder.transcode(eq(transformed))).thenReturn(transcoded);
-
-            assertEquals(transcoded, harness.getJob().decodeFromSource());
-        }
-    }
-
-    @Test
-    public void testSourceDataIsWrittenToCacheIfCacheStrategyCachesSource() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.SOURCE, DiskCacheStrategy.ALL)) {
-            harness = new Harness(strategy);
-            Object data = new Object();
-            when(harness.dataFetcher.loadData(eq(harness.priority))).thenReturn(data);
-
-            doAnswer(new CallWriter()).when(harness.diskCache)
-                    .put(eq(harness.originalKey), any(DiskCache.Writer.class));
-
-            harness.getJob().decodeFromSource();
-
-            verify(harness.sourceEncoder).encode(eq(data), any(OutputStream.class));
-        }
-    }
-
-    @Test
-    public void testSourceDataIsNotWrittenToCacheIfCacheStrategyDoesNotCacheSource() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.NONE, DiskCacheStrategy.RESULT)) {
-            harness = new Harness(strategy);
-            mockSourceToReturnResource();
-
-            harness.getJob().decodeFromSource();
-
-            verify(harness.diskCache, never()).put(eq(harness.originalKey), any(DiskCache.Writer.class));
-        }
-    }
-
-    @Test
-    public void testTransformedResourceDecodedFromSourceIsWrittenToCacheIfCacheStrategyCachesResult() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.ALL, DiskCacheStrategy.RESULT)) {
-            harness = new Harness(strategy);
-
-            mockSourceToReturnResource();
-            Resource<Object> transformed = mock(Resource.class);
-            when(harness.transformation.transform(eq(harness.resource), eq(harness.width), eq(harness.height)))
-                    .thenReturn(transformed);
-            doAnswer(new CallWriter()).when(harness.diskCache).put(eq(harness.key), any(DiskCache.Writer.class));
-
-            harness.getJob().decodeFromSource();
-
-            verify(harness.resultEncoder).encode(eq(transformed), any(OutputStream.class));
-        }
-    }
-
-    @Test
-    public void testTransformedResultResourceIsNotWrittenToCacheIfCacheStrategyDoesNotCacheResult() throws Exception {
-        for (DiskCacheStrategy strategy : list(DiskCacheStrategy.NONE, DiskCacheStrategy.SOURCE)) {
-            harness = new Harness(strategy);
-            mockSourceToReturnResource();
-            Resource<Object> transformed = mock(Resource.class);
-            when(harness.transformation.transform(eq(harness.resource), eq(harness.width), eq(harness.height)))
-                    .thenReturn(transformed);
-
-            harness.getJob().decodeFromSource();
-
-            verify(harness.diskCache, never()).put(eq(harness.key), any(DiskCache.Writer.class));
-        }
-    }
-
-    @Test
-    public void testResourceDecodedFromSourceDataIsRecycledIfDifferentThanTransformed() throws Exception {
-        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
-            harness = new Harness(strategy);
-            mockSourceToReturnResource();
-            Resource<Object> transformed = mock(Resource.class);
-            when(harness.transformation.transform(eq(harness.resource), eq(harness.width), eq(harness.height)))
-                    .thenReturn(transformed);
-
-            harness.getJob().decodeFromSource();
-
-            verify(harness.resource).recycle();
-        }
-    }
-
-    @Test
-    public void testResourceDecodedFromSourceDataIsNotRecycledIfSameAsTransformed() throws Exception {
-         for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
-            harness = new Harness(strategy);
-            mockSourceToReturnResource();
-            when(harness.transformation.transform(eq(harness.resource), eq(harness.width), eq(harness.height)))
-                    .thenReturn(harness.resource);
-
-            harness.getJob().decodeFromSource();
-
-            verify(harness.resource, never()).recycle();
-        }
-    }
-
-    @Test
-    public void testFetcherIsCleanedUp() throws Exception {
-        harness.getJob().decodeFromSource();
-
-        verify(harness.dataFetcher).cleanup();
-    }
-
-    @Test
-    public void testFetcherIsCleanedUpIfDecodeThrows() throws Exception {
-        when(harness.dataFetcher.loadData(any(Priority.class))).thenReturn(new Object());
-        when(harness.sourceDecoder.decode(anyObject(), anyInt(), anyInt())).thenThrow(new IOException("test"));
-
-        try {
-            harness.getJob().decodeFromSource();
-            fail("Failed to get expected exception");
-        } catch (IOException e) {
-            // Expected.`
-        }
-
-        verify(harness.dataFetcher).cleanup();
-    }
-
-    @Test
-    public void testFetcherIsCleanedUpIfFetcherThrows() throws Exception {
-        when(harness.dataFetcher.loadData(any(Priority.class))).thenThrow(new IOException("test"));
-
-        try {
-            harness.getJob().decodeFromSource();
-            fail("Failed to get expected exception");
-        } catch (IOException e) {
-            // Expected.
-        }
-
-        verify(harness.dataFetcher).cleanup();
-    }
-
-    @Test
-    public void testReturnsNullFromDecodeSourceIfDecoderReturnsNull() throws Exception {
-        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
-            harness = new Harness(strategy);
-            mockSourceToReturnResource();
-            when(harness.sourceDecoder.decode(any(Object.class), anyInt(), anyInt())).thenReturn(null);
-            when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt())).thenReturn(null);
-
-            assertNull(harness.getJob().decodeFromSource());
-        }
-    }
-
-    @Test
-    public void testReturnsNullFromDecodeSourceIfTransformationReturnsNull() throws Exception {
-        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
-            harness = new Harness(strategy);
-            mockSourceToReturnResource();
-            when(harness.transformation.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(null);
-
-            assertNull(harness.getJob().decodeFromSource());
-        }
-    }
-
-    @Test
-    public void testReturnsNullFromDecodeSourceIfTranscoderReturnsNull() throws Exception {
-        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
-            harness = new Harness(strategy);
-            mockSourceToReturnResource();
-            when(harness.transcoder.transcode(any(Resource.class))).thenReturn(null);
-
-            assertNull(harness.getJob().decodeFromSource());
-        }
-    }
-
-    private static <T> List<T> list(T... items) {
-        return Arrays.asList(items);
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class Harness {
-        EngineKey key = mock(EngineKey.class);
-        Key originalKey = mock(Key.class);
-        int width = 100;
-        int height = 200;
-        DataFetcher<Object> dataFetcher = mock(DataFetcher.class);
-        DataLoadProvider<Object, Object> loadProvider = mock(DataLoadProvider.class);
-        Transformation<Object> transformation = mock(Transformation.class);
-        ResourceTranscoder<Object, Object> transcoder = mock(ResourceTranscoder.class);
-        DiskCache diskCache = mock(DiskCache.class);
-        Priority priority = Priority.IMMEDIATE;
-
-        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
-        Resource<Object> resource = mock(Resource.class);
-        ResourceEncoder<Object> resultEncoder = mock(ResourceEncoder.class);
-        ResourceDecoder<Object, Object> sourceDecoder = mock(ResourceDecoder.class);
-        Encoder<Object> sourceEncoder = mock(Encoder.class);
-        DecodeJob.FileOpener fileOpener = mock(DecodeJob.FileOpener.class);
-
-        DiskCacheStrategy diskCacheStrategy;
-
-        public Harness() throws FileNotFoundException {
-            this(DiskCacheStrategy.RESULT);
-        }
-
-        public Harness(DiskCacheStrategy diskCacheStrategy) throws FileNotFoundException {
-            this.diskCacheStrategy = diskCacheStrategy;
-            when(fileOpener.open(any(File.class))).thenReturn(mock(OutputStream.class));
-            when(key.getOriginalKey()).thenReturn(originalKey);
-            when(transcoder.transcode(eq(resource))).thenReturn(resource);
-            when(transformation.transform(eq(resource), eq(width), eq(height))).thenReturn(resource);
-            when(loadProvider.getCacheDecoder()).thenReturn(cacheDecoder);
-            when(loadProvider.getEncoder()).thenReturn(resultEncoder);
-            when(loadProvider.getSourceDecoder()).thenReturn(sourceDecoder);
-            when(loadProvider.getSourceEncoder()).thenReturn(sourceEncoder);
-        }
-
-        public DecodeJob<Object, Object, Object> getJob() {
-            return new DecodeJob<Object, Object, Object>(key, width, height, dataFetcher, loadProvider, transformation,
-                    transcoder, diskCache, diskCacheStrategy, priority, fileOpener);
-        }
-    }
-
-    private static class CallWriter implements Answer<Void> {
-
-        @Override
-        public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-            DiskCache.Writer writer = (DiskCache.Writer) invocationOnMock.getArguments()[1];
-            writer.write(new File("test"));
-            return null;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java
deleted file mode 100644
index eb9dec3c3..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ /dev/null
@@ -1,498 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.os.Handler;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.request.ResourceCallback;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLooper;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class EngineJobTest {
-    private EngineJobHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new EngineJobHarness();
-    }
-
-    @Test
-    public void testOnResourceReadyPassedToCallbacks() throws Exception {
-        harness.getJob().onResourceReady(harness.resource);
-
-        Robolectric.runUiThreadTasks();
-        verify(harness.cb).onResourceReady(eq(harness.engineResource));
-    }
-
-    @Test
-    public void testListenerNotifiedJobCompleteOnOnResourceReady() {
-        harness.getJob().onResourceReady(harness.resource);
-
-        Robolectric.runUiThreadTasks();
-
-        verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));
-    }
-
-     @Test
-    public void testNotifiesAllCallbacksOnReady() {
-         MultiCbHarness harness = new MultiCbHarness();
-        harness.job.onResourceReady(harness.resource);
-        for (ResourceCallback cb : harness.cbs) {
-            verify(cb).onResourceReady(eq(harness.engineResource));
-        }
-    }
-
-    @Test
-    public void testNotifiesAllCallbacksOnException() {
-        for (Exception exception : list(new RuntimeException("test"), null)) {
-            MultiCbHarness harness = new MultiCbHarness();
-            harness.job.onException(exception);
-            for (ResourceCallback cb : harness.cbs) {
-                verify(cb).onException(eq(exception));
-            }
-        }
-    }
-
-    @Test
-    public void testAcquiresResourceOncePerCallback() {
-        MultiCbHarness harness = new MultiCbHarness();
-        harness.job.onResourceReady(harness.resource);
-
-        // Acquired once and then released while notifying.
-        InOrder order = inOrder(harness.engineResource);
-        order.verify(harness.engineResource, times(harness.numCbs + 1)).acquire();
-        order.verify(harness.engineResource, times(1)).release();
-    }
-
-    @Test
-    public void testListenerNotifiedJobCompleteOnException() {
-        for (Exception exception : list(new Exception("test"), null)) {
-            harness = new EngineJobHarness();
-            harness.getJob().onException(exception);
-
-            Robolectric.runUiThreadTasks();
-            verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
-        }
-    }
-
-    @Test
-    public void testResourceIsCacheableWhenIsCacheableOnReady() {
-        harness.isCacheable = true;
-        harness.getJob().onResourceReady(harness.resource);
-
-        Robolectric.runUiThreadTasks();
-        verify(harness.factory).build(any(Resource.class), eq(harness.isCacheable));
-    }
-
-    @Test
-    public void testResourceIsCacheableWhenNotIsCacheableOnReady() {
-        harness.isCacheable = false;
-        harness.getJob().onResourceReady(harness.resource);
-
-        Robolectric.runUiThreadTasks();
-        verify(harness.factory).build(any(Resource.class), eq(harness.isCacheable));
-    }
-
-    @Test
-    public void testListenerNotifiedOfCancelOnCancel() {
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.cancel();
-
-        verify(harness.listener).onEngineJobCancelled(eq(job), eq(harness.key));
-    }
-
-    @Test
-    public void testOnResourceReadyNotDeliveredAfterCancel() {
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.cancel();
-
-        job.onResourceReady(harness.resource);
-
-        Robolectric.runUiThreadTasks();
-        verify(harness.cb, never()).onResourceReady(eq(harness.resource));
-    }
-
-    @Test
-    public void testOnExceptionNotDeliveredAfterCancel() {
-        for (Exception exception : list(new RuntimeException("test"), null)) {
-            harness = new EngineJobHarness();
-            EngineJob job = harness.getJob();
-            job.start(harness.engineRunnable);
-            job.cancel();
-
-            job.onException(exception);
-
-            Robolectric.runUiThreadTasks();
-            verify(harness.cb, never()).onException(any(Exception.class));
-        }
-    }
-
-    @Test
-    public void testRemovingAllCallbacksCancelsRunner() {
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.removeCallback(harness.cb);
-
-        assertTrue(job.isCancelled());
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void removingSomeCallbacksDoesNotCancelRunner() {
-        EngineJob job = harness.getJob();
-        job.addCallback(mock(ResourceCallback.class));
-        job.removeCallback(harness.cb);
-
-        assertFalse(job.isCancelled());
-    }
-
-    @Test
-    public void testResourceIsAcquiredOncePerConsumerAndOnceForCache() {
-        harness.getJob().onResourceReady(harness.resource);
-
-        // Once while notifying and once for single callback.
-        verify(harness.engineResource, times(2)).acquire();
-    }
-
-    @Test
-    public void testDoesNotNotifyCancelledIfCompletesBeforeCancel() {
-        EngineJob job = harness.getJob();
-        job.onResourceReady(harness.resource);
-        job.cancel();
-
-        verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));
-    }
-
-    @Test
-    public void testDoesNotNotifyCancelledIfAlreadyCancelled() {
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.cancel();
-        job.cancel();
-
-        verify(harness.listener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));
-    }
-
-    @Test
-    public void testDoesNotNotifyCancelledIfReceivedException() {
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.onException(new Exception());
-        job.cancel();
-
-        verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
-        verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
-    }
-
-    @Test
-    public void testReleasesResourceIfCancelledOnReady() {
-        ShadowLooper shadowLooper = Robolectric.shadowOf(harness.mainHandler.getLooper());
-        shadowLooper.pause();
-
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.onResourceReady(harness.resource);
-        job.cancel();
-        shadowLooper.runOneTask();
-
-        verify(harness.resource).recycle();
-    }
-
-    @Test
-    public void testDoesNotAcquireOnceForMemoryCacheIfNotCacheable() {
-        harness.isCacheable = false;
-        harness.getJob().onResourceReady(harness.resource);
-
-        verify(harness.engineResource, times(2)).acquire();
-    }
-
-    @Test
-    public void testNotifiesNewCallbackOfResourceIfCallbackIsAddedDuringOnResourceReady() {
-        final EngineJob job = harness.getJob();
-        final ResourceCallback existingCallback = mock(ResourceCallback.class);
-        final ResourceCallback newCallback = mock(ResourceCallback.class);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                job.addCallback(newCallback);
-                return null;
-            }
-        }).when(existingCallback).onResourceReady(any(Resource.class));
-
-        job.addCallback(existingCallback);
-        job.onResourceReady(harness.resource);
-
-        verify(newCallback).onResourceReady(eq(harness.engineResource));
-    }
-
-    @Test
-    public void testNotifiesNewCallbackOfExceptionIfCallbackIsAddedDuringOnException() {
-        for (Exception exception : list(new RuntimeException("test"), null)) {
-            harness = new EngineJobHarness();
-            final EngineJob job = harness.getJob();
-            final ResourceCallback existingCallback = mock(ResourceCallback.class);
-            final ResourceCallback newCallback = mock(ResourceCallback.class);
-
-            doAnswer(new Answer() {
-                @Override
-                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                    job.addCallback(newCallback);
-                    return null;
-                }
-            }).when(existingCallback).onException(any(Exception.class));
-
-            job.addCallback(existingCallback);
-            job.onException(exception);
-
-            verify(newCallback).onException(eq(exception));
-        }
-    }
-
-    @Test
-    public void testRemovingCallbackDuringOnResourceReadyIsIgnoredIfCallbackHasAlreadyBeenCalled() {
-        final EngineJob job = harness.getJob();
-        final ResourceCallback cb = mock(ResourceCallback.class);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                job.removeCallback(cb);
-                return null;
-            }
-        }).when(cb).onResourceReady(any(Resource.class));
-
-        job.addCallback(cb);
-        job.onResourceReady(harness.resource);
-
-        verify(cb, times(1)).onResourceReady(any(Resource.class));
-    }
-
-    @Test
-    public void testRemovingCallbackDuringOnExceptionIsIgnoredIfCallbackHasAlreadyBeenCalled() {
-        for (Exception exception : list(new RuntimeException("test"), null)) {
-            harness = new EngineJobHarness();
-            final EngineJob job = harness.getJob();
-            final ResourceCallback cb = mock(ResourceCallback.class);
-
-            doAnswer(new Answer() {
-                @Override
-                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                    job.removeCallback(cb);
-                    return null;
-                }
-            }).when(cb).onException(any(Exception.class));
-
-            job.addCallback(cb);
-            job.onException(exception);
-
-            verify(cb, times(1)).onException(any(Exception.class));
-        }
-    }
-
-    @Test
-    public void testRemovingCallbackDuringOnResourceReadyPreventsCallbackFromBeingCalledIfNotYetCalled() {
-        final EngineJob job = harness.getJob();
-        final ResourceCallback notYetCalled = mock(ResourceCallback.class);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                job.removeCallback(notYetCalled);
-                return null;
-            }
-        }).when(harness.cb).onResourceReady(any(Resource.class));
-
-        job.addCallback(notYetCalled);
-
-        job.onResourceReady(harness.resource);
-
-        verify(notYetCalled, never()).onResourceReady(any(Resource.class));
-    }
-
-    @Test
-    public void testRemovingCallbackDuringOnResourceReadyPreventsResourceFromBeingAcquiredForCallback() {
-        final EngineJob job = harness.getJob();
-        final ResourceCallback notYetCalled = mock(ResourceCallback.class);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                job.removeCallback(notYetCalled);
-                return null;
-            }
-        }).when(harness.cb).onResourceReady(any(Resource.class));
-
-        job.addCallback(notYetCalled);
-
-        job.onResourceReady(harness.resource);
-
-        // Once for notifying, once for called.
-        verify(harness.engineResource, times(2)).acquire();
-    }
-
-    @Test
-    public void testRemovingCallbackDuringOnExceptionPreventsCallbackFromBeingCalledIfNotYetCalled() {
-        for (Exception exception : list(new RuntimeException("test"), null)) {
-            harness = new EngineJobHarness();
-            final EngineJob job = harness.getJob();
-            final ResourceCallback called = mock(ResourceCallback.class);
-            final ResourceCallback notYetCalled = mock(ResourceCallback.class);
-
-            doAnswer(new Answer() {
-                @Override
-                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                    job.removeCallback(notYetCalled);
-                    return null;
-                }
-            }).when(called).onException(any(Exception.class));
-
-            job.addCallback(called);
-            job.addCallback(notYetCalled);
-            job.onException(exception);
-
-            verify(notYetCalled, never()).onResourceReady(any(Resource.class));
-        }
-    }
-
-    @Test
-    public void testRemovingCallbackAfterLoadFailsWithNullExceptionDoesNotCancelJob() {
-        EngineJob job = harness.getJob();
-
-        job.onException(null);
-        job.removeCallback(harness.cb);
-        verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
-    }
-
-    @Test
-    public void testCancelsFutureFromDiskCacheServiceIfCancelledAfterStartButBeforeSourceSubmit() {
-        Future future = mock(Future.class);
-        when(harness.diskCacheService.submit(eq(harness.engineRunnable))).thenReturn(future);
-
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.cancel();
-
-        verify(future).cancel(eq(true));
-    }
-
-    @Test
-    public void testCancelsFutureFromSourceServiceIfCancelledAfterSourceSubmit() {
-        Future future = mock(Future.class);
-        when(harness.sourceService.submit(eq(harness.engineRunnable))).thenReturn(future);
-
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.submitForSource(harness.engineRunnable);
-        job.cancel();
-
-        verify(future).cancel(eq(true));
-    }
-
-    @Test
-    public void testCancelsEngineRunnableOnCancel() {
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-        job.cancel();
-
-        verify(harness.engineRunnable).cancel();
-    }
-
-    @Test
-    public void testSubmitsRunnableToSourceServiceOnSubmitForSource() {
-        EngineJob job = harness.getJob();
-        job.submitForSource(harness.engineRunnable);
-
-        verify(harness.sourceService).submit(eq(harness.engineRunnable));
-    }
-
-    @Test
-    public void testSubimtsRunnableToDiskCacheServiceOnStart() {
-        EngineJob job = harness.getJob();
-        job.start(harness.engineRunnable);
-
-        verify(harness.diskCacheService).submit(eq(harness.engineRunnable));
-    }
-
-    private static <T> List<T> list(T... items) {
-        return Arrays.asList(items);
-    }
-
-    private static class MultiCbHarness {
-        Key key = mock(Key.class);
-        Resource<Object> resource = mock(Resource.class);
-        EngineResource<Object> engineResource = mock(EngineResource.class);
-        EngineJobListener listener = mock(EngineJobListener.class);
-        boolean isCacheable = true;
-        int numCbs = 10;
-        List<ResourceCallback> cbs = new ArrayList<ResourceCallback>();
-        EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-        EngineJob job;
-        ExecutorService diskCacheService = mock(ExecutorService.class);
-        ExecutorService sourceService = mock(ExecutorService.class);
-
-        public MultiCbHarness() {
-            when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-            job = new EngineJob(key, diskCacheService, sourceService, isCacheable, listener, factory);
-            for (int i = 0; i < numCbs; i++) {
-                cbs.add(mock(ResourceCallback.class));
-            }
-            for (ResourceCallback cb : cbs) {
-                job.addCallback(cb);
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class EngineJobHarness {
-        EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-        Key key = mock(Key.class);
-        Handler mainHandler = new Handler();
-        ResourceCallback cb = mock(ResourceCallback.class);
-        Resource<Object> resource = mock(Resource.class);
-        EngineResource<Object> engineResource = mock(EngineResource.class);
-        EngineJobListener listener = mock(EngineJobListener.class);
-        ExecutorService diskCacheService = mock(ExecutorService.class);
-        ExecutorService sourceService = mock(ExecutorService.class);
-        boolean isCacheable = true;
-        EngineRunnable engineRunnable = mock(EngineRunnable.class);
-
-        public EngineJob getJob() {
-            when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-            EngineJob result = new EngineJob(key, diskCacheService, sourceService, isCacheable, listener, factory);
-            result.addCallback(cb);
-            return result;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java
deleted file mode 100644
index a9a13f6e5..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ /dev/null
@@ -1,248 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-/**
- * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object) equals}
- * and SHA-1 disk cache key are different on any difference in ID or existence of a certain workflow part.
- * Also checking whether the equals method is symmetric.
- */
-@RunWith(JUnit4.class)
-public class EngineKeyTest {
-    private Harness harness;
-
-    @Before
-    public void setUp() {
-        harness = new Harness();
-    }
-
-    private static class Harness {
-        String id = "testId";
-        int width = 1;
-        int height = 2;
-        ResourceDecoder cacheDecoder = mock(ResourceDecoder.class);
-        ResourceDecoder decoder = mock(ResourceDecoder.class);
-        Transformation transformation = mock(Transformation.class);
-        ResourceEncoder encoder = mock(ResourceEncoder.class);
-        ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
-        Encoder sourceEncoder = mock(Encoder.class);
-        Key signature = mock(Key.class);
-
-        public Harness() {
-            when(cacheDecoder.getId()).thenReturn("cacheDecoder");
-            when(decoder.getId()).thenReturn("decoder");
-            when(transformation.getId()).thenReturn("transformation");
-            when(encoder.getId()).thenReturn("encoder");
-            when(transcoder.getId()).thenReturn("transcoder");
-            when(sourceEncoder.getId()).thenReturn("sourceEncoder");
-        }
-
-        public EngineKey build() {
-            return new EngineKey(id, signature, width, height, cacheDecoder, decoder, transformation, encoder,
-                    transcoder, sourceEncoder);
-        }
-    }
-
-    @Test
-    public void testIsIdenticalWithSameArguments() {
-        assertEquals(harness.build(), harness.build());
-    }
-
-    @Test
-    public void testDiffersIfIdDiffers() throws Exception {
-        EngineKey first = harness.build();
-        harness.id = harness.id + "2";
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfHeightDiffers() throws Exception {
-        EngineKey first = harness.build();
-        harness.height += 1;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfWidthDiffers() throws Exception {
-        EngineKey first = harness.build();
-        harness.width += 1;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfTransformationDiffers() throws Exception {
-        String id = "transformation";
-        when(harness.transformation.getId()).thenReturn(id);
-        EngineKey first = harness.build();
-        harness.transformation = mock(Transformation.class);
-        when(harness.transformation.getId()).thenReturn(id + "2");
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfTransformationMissing() throws Exception {
-        EngineKey first = harness.build();
-        harness.transformation = null;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfCacheDecoderDiffers() throws Exception {
-        String id = "cacheDecoder";
-        when(harness.cacheDecoder.getId()).thenReturn(id);
-        EngineKey first = harness.build();
-        harness.cacheDecoder = mock(ResourceDecoder.class);
-        when(harness.cacheDecoder.getId()).thenReturn(id + "2");
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfCacheDecoderMissing() throws Exception {
-        EngineKey first = harness.build();
-        harness.cacheDecoder = null;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfDecoderDiffers() throws Exception {
-        String id = "decoder";
-        when(harness.decoder.getId()).thenReturn(id);
-        EngineKey first = harness.build();
-        harness.decoder = mock(ResourceDecoder.class);
-        when(harness.decoder.getId()).thenReturn(id + "2");
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfDecoderMissing() throws Exception {
-        EngineKey first = harness.build();
-        harness.decoder = null;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfEncoderDiffers() throws Exception {
-        String id = "encoder";
-        when(harness.encoder.getId()).thenReturn(id);
-        EngineKey first = harness.build();
-        harness.encoder = mock(ResourceEncoder.class);
-        when(harness.encoder.getId()).thenReturn(id + "2");
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfEncoderMissing() throws Exception {
-        EngineKey first = harness.build();
-        harness.encoder = null;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersWhenTranscoderDiffers() throws Exception {
-        String id = "transcoder";
-        when(harness.transcoder.getId()).thenReturn(id);
-        EngineKey first = harness.build();
-        harness.transcoder = mock(ResourceTranscoder.class);
-        when(harness.transcoder.getId()).thenReturn(id + "2");
-        EngineKey second = harness.build();
-
-        // The transcoder doesn't affect the cached data,
-        // so we don't expect the key digests to updated differently even though the transcoder id isn't the same.
-        KeyAssertions.assertDifferent(first, second, false);
-        KeyAssertions.assertDifferent(second, first, false);
-    }
-
-    @Test
-    public void testDiffersIfTranscoderMissing() throws Exception {
-        EngineKey first = harness.build();
-        harness.transcoder = null;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second, false);
-        KeyAssertions.assertDifferent(second, first, false);
-    }
-
-    @Test
-    public void testDiffersWhenSourceEncoderDiffers() throws Exception {
-        String id = "sourceEncoder";
-        when(harness.sourceEncoder.getId()).thenReturn(id);
-        EngineKey first = harness.build();
-        harness.sourceEncoder = mock(Encoder.class);
-        when(harness.sourceEncoder.getId()).thenReturn(id + "2");
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfSourceEncoderMissing() throws Exception {
-        EngineKey first = harness.build();
-        harness.sourceEncoder = null;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfSignatureDiffers() throws UnsupportedEncodingException, NoSuchAlgorithmException {
-        EngineKey first = harness.build();
-        Key signature = mock(Key.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                MessageDigest digest = (MessageDigest) invocationOnMock.getArguments()[0];
-                digest.update("signature".getBytes("UTF-8"));
-                return null;
-            }
-        }).when(signature).updateDiskCacheKey(any(MessageDigest.class));
-        harness.signature = signature;
-        EngineKey second = harness.build();
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java
deleted file mode 100644
index 465001f5a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ /dev/null
@@ -1,154 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.Key;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class EngineResourceTest {
-    private EngineResource<Object> engineResource;
-    private EngineResource.ResourceListener listener;
-    private Key cacheKey = mock(Key.class);
-    private Resource<Object> resource;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        resource = mock(Resource.class);
-        engineResource = new EngineResource<Object>(resource, true /*isCacheable*/);
-        listener = mock(EngineResource.ResourceListener.class);
-        engineResource.setResourceListener(cacheKey, listener);
-    }
-
-    @Test
-    public void testCanAcquireAndRelease() {
-        engineResource.acquire();
-        engineResource.release();
-
-        verify(listener).onResourceReleased(cacheKey, engineResource);
-    }
-
-    @Test
-    public void testCanAcquireMultipleTimesAndRelease() {
-        engineResource.acquire();
-        engineResource.acquire();
-        engineResource.release();
-        engineResource.release();
-
-        verify(listener).onResourceReleased(eq(cacheKey), eq(engineResource));
-    }
-
-    @Test
-    public void testDelegatesGetToWrappedResource() {
-        Object expected = new Object();
-        when(resource.get()).thenReturn(expected);
-        assertEquals(expected, engineResource.get());
-    }
-
-    @Test
-    public void testDelegatesGetSizeToWrappedResource() {
-        int expectedSize = 1234;
-        when(resource.getSize()).thenReturn(expectedSize);
-        assertEquals(expectedSize, engineResource.getSize());
-    }
-
-    @Test
-    public void testRecyclesWrappedResourceWhenRecycled() {
-        engineResource.acquire();
-        engineResource.release();
-        engineResource.recycle();
-        verify(resource).recycle();
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testThrowsIfRecycledTwice() {
-        engineResource.recycle();
-        engineResource.recycle();
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testThrowsIfReleasedBeforeAcquired() {
-        engineResource.release();
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testThrowsIfRecycledWhileAcquired() {
-        engineResource.acquire();
-        engineResource.recycle();
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testThrowsIfAcquiredAfterRecycled() {
-        engineResource.recycle();
-        engineResource.acquire();
-    }
-
-    @Test
-    public void testThrowsIfAcquiredOnBackgroundThread() throws InterruptedException {
-        Thread otherThread = new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    engineResource.acquire();
-                } catch (IllegalThreadStateException e) {
-                    return;
-                }
-                fail("Failed to receive expected IllegalThreadStateException");
-            }
-        });
-        otherThread.start();
-        otherThread.join();
-    }
-
-    @Test
-    public void testThrowsIfReleasedOnBackgroundThread() throws InterruptedException {
-        engineResource.acquire();
-        Thread otherThread = new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                     engineResource.release();
-                } catch (IllegalThreadStateException e) {
-                    return;
-                }
-                fail("Failed to receive expected IllegalThreadStateException");
-            }
-        });
-        otherThread.start();
-        otherThread.join();
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testThrowsIfReleasedMoreThanAcquired() {
-        engineResource.acquire();
-        engineResource.release();
-        engineResource.release();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfWrappedResourceIsNull() {
-        new EngineResource<Object>(null, false);
-    }
-
-    @Test
-    public void testCanSetAndGetIsCacheable() {
-        engineResource = new EngineResource<Object>(mock(Resource.class), true);
-        assertTrue(engineResource.isCacheable());
-        engineResource = new EngineResource<Object>(mock(Resource.class), false);
-        assertFalse(engineResource.isCacheable());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineRunnableTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineRunnableTest.java
deleted file mode 100644
index 31f0bae1f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineRunnableTest.java
+++ /dev/null
@@ -1,231 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.request.ResourceCallback;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class EngineRunnableTest {
-
-    private EngineRunnable.EngineRunnableManager manager;
-    private DecodeJob job;
-    private Priority priority;
-    private EngineRunnable runnable;
-    private ResourceCallback callback;
-
-    @Before
-    public void setUp() {
-        manager = mock(EngineRunnable.EngineRunnableManager.class);
-        job = mock(DecodeJob.class);
-        priority = Priority.LOW;
-        runnable = new EngineRunnable(manager, job, priority);
-    }
-
-    @Test
-    public void testReturnsGivenPriority() {
-        assertEquals(priority.ordinal(), runnable.getPriority());
-    }
-
-    @Test
-    public void testNotifiesManagerOfResultIfDecodeJobDecodesFromCache() throws Exception {
-        Resource expected = mock(Resource.class);
-        when(job.decodeResultFromCache()).thenReturn(expected);
-
-        runnable.run();
-
-        verify(manager).onResourceReady(eq(expected));
-    }
-
-    @Test
-    public void testDoesNotNotifyManagerOfFailureIfDecodeJobReturnsNullFromCache() throws Exception {
-        when(job.decodeResultFromCache()).thenReturn(null);
-
-        runnable.run();
-
-        verify(manager, never()).onException(any(Exception.class));
-    }
-
-    @Test
-    public void testDoesNotNotifyManagerOfFailureIfDecodeJobThrowsExceptionFromCache() throws Exception {
-        when(job.decodeResultFromCache()).thenThrow(new RuntimeException("test"));
-
-        runnable.run();
-
-        verify(manager, never()).onException(any(Exception.class));
-    }
-
-    @Test
-    public void testNotifiesManagerOfResultIfDecodeJobDecodesFromSourceCache() throws Exception {
-        Resource expected = mock(Resource.class);
-        when(job.decodeSourceFromCache()).thenReturn(expected);
-
-        runnable.run();
-
-        verify(manager).onResourceReady(eq(expected));
-    }
-
-    @Test
-    public void testNotifiesManagerOfResultIfDecodeJobThrowsGettingResultFromCacheButDecodesFromSourceCache()
-            throws Exception {
-        when(job.decodeResultFromCache()).thenThrow(new RuntimeException("test"));
-        Resource expected = mock(Resource.class);
-        when(job.decodeSourceFromCache()).thenReturn(expected);
-
-        runnable.run();
-
-        verify(manager).onResourceReady(eq(expected));
-    }
-
-    @Test
-    public void testDoesNotNotifyManagerOfFailureIfDecodeJobReturnsNullFromSourceAndResultCache() {
-        runnable.run();
-
-        verify(manager, never()).onException(any(Exception.class));
-    }
-
-    @Test
-    public void testDoesNotNotifyManagerOfFailureIfDecodeJobThrowsFromSourceAndResultCache() throws Exception {
-        when(job.decodeResultFromCache()).thenThrow(new RuntimeException("test"));
-        when(job.decodeSourceFromCache()).thenThrow(new RuntimeException("test"));
-
-        runnable.run();
-
-        verify(manager, never()).onException(any(Exception.class));
-    }
-
-    @Test
-    public void testSubmitsForSourceIfDecodeJobReturnsNullFromSourceAndResultCache() {
-        runnable.run();
-
-        verify(manager).submitForSource(eq(runnable));
-    }
-
-    @Test
-    public void testSubmitsForSourceIfDecodeJobThrowsFromSourceAndResultCache() throws Exception {
-        when(job.decodeResultFromCache()).thenThrow(new RuntimeException("test"));
-        when(job.decodeSourceFromCache()).thenThrow(new RuntimeException("test"));
-
-        runnable.run();
-
-        verify(manager).submitForSource(eq(runnable));
-    }
-
-    @Test
-    public void testNotifiesManagerOfFailureIfJobReturnsNullDecodingFromSource() {
-        runnable.run();
-        runnable.run();
-
-        verify(manager).onException((Exception) isNull());
-    }
-
-    @Test
-    public void testNotifiesManagerOfFailureIfJobThrowsDecodingFromSource() throws Exception {
-        runnable.run();
-
-        Exception expected = new RuntimeException("test");
-        when(job.decodeFromSource()).thenThrow(expected);
-        runnable.run();
-
-        verify(manager).onException(eq(expected));
-    }
-
-    @Test
-    public void testNotifiesManagerOfResultIfDecodeFromSourceSucceeds() throws Exception {
-        runnable.run();
-
-        Resource expected = mock(Resource.class);
-        when(job.decodeFromSource()).thenReturn(expected);
-        runnable.run();
-
-        verify(manager).onResourceReady(eq(expected));
-    }
-
-    @Test
-    public void testDoesNotDecodeFromCacheIfCancelled() throws Exception {
-        runnable.cancel();
-        runnable.run();
-
-        verify(job, never()).decodeResultFromCache();
-        verify(job, never()).decodeSourceFromCache();
-    }
-
-    @Test
-    public void testDoesNotDecodeFromSourceIfCancelled() throws Exception {
-        runnable.run();
-        runnable.cancel();
-        runnable.run();
-
-        verify(job, never()).decodeFromSource();
-    }
-
-    @Test
-    public void testDoesNotRequestSubmitIfCancelled() {
-        runnable.cancel();
-        runnable.run();
-
-        verify(manager, never()).submitForSource(eq(runnable));
-    }
-
-    @Test
-    public void testDoesNotNotifyManagerOfFailureIfCancelled() throws Exception {
-        runnable.run();
-        when(job.decodeFromSource()).thenAnswer(new Answer<Object>() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                runnable.cancel();
-                throw new RuntimeException("test");
-            }
-        });
-        runnable.run();
-
-        verify(manager, never()).onException(any(Exception.class));
-    }
-
-    @Test
-    public void testDoesNotNotifyManagerOfSuccessIfCancelled() throws Exception {
-        runnable.run();
-        when(job.decodeFromSource()).thenAnswer(new Answer<Object>() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                runnable.cancel();
-                return mock(Resource.class);
-            }
-        });
-        runnable.run();
-
-        verify(manager, never()).onResourceReady(any(Resource.class));
-    }
-
-    @Test
-    public void testRecyclesResourceIfAvailableWhenCancelled() throws Exception {
-        final Resource resource = mock(Resource.class);
-        runnable.run();
-        when(job.decodeFromSource()).thenAnswer(new Answer<Object>() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                runnable.cancel();
-                return resource;
-            }
-        });
-        runnable.run();
-
-        verify(resource).recycle();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java
deleted file mode 100644
index af18d7c82..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java
+++ /dev/null
@@ -1,501 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.engine.cache.DiskCache;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.request.ResourceCallback;
-import com.bumptech.glide.tests.BackgroundUtil;
-import com.bumptech.glide.tests.GlideShadowLooper;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.File;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.ExecutorService;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { GlideShadowLooper.class })
-public class EngineTest {
-    private static final String ID = "asdf";
-    private EngineTestHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new EngineTestHarness();
-    }
-
-    @Test
-    public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
-        harness.doLoad();
-
-        verify(harness.job).start(any(EngineRunnable.class));
-    }
-
-    @Test
-    public void testCallbackIsAddedToNewEngineJobWithNoExistingLoad() {
-        harness.doLoad();
-
-        verify(harness.job).addCallback(eq(harness.cb));
-    }
-
-    @Test
-    public void testLoadStatusIsReturnedForNewLoad() {
-        assertNotNull(harness.doLoad());
-    }
-
-    @Test
-    public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
-        Engine.LoadStatus loadStatus = harness.doLoad();
-        loadStatus.cancel();
-
-        verify(harness.job).removeCallback(eq(harness.cb));
-    }
-
-    @Test
-    public void testNewRunnerIsAddedToRunnersMap() {
-        harness.doLoad();
-
-        assertThat(harness.jobs).containsKey(harness.cacheKey);
-    }
-
-    @Test
-    public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
-        harness.doLoad();
-        harness.doLoad();
-
-        verify(harness.job, times(1)).start(any(EngineRunnable.class));
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
-        harness.doLoad();
-
-        ResourceCallback newCallback = mock(ResourceCallback.class);
-        harness.cb = newCallback;
-        harness.doLoad();
-
-        verify(harness.job).addCallback(eq(newCallback));
-    }
-
-    @Test
-    public void testLoadStatusIsReturnedForExistingJob() {
-        harness.doLoad();
-        Engine.LoadStatus loadStatus = harness.doLoad();
-
-        assertNotNull(loadStatus);
-    }
-
-    @Test
-    public void testResourceIsReturnedFromActiveResourcesIfPresent() {
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-        harness.doLoad();
-
-        verify(harness.cb).onResourceReady(eq(harness.resource));
-    }
-
-    @Test
-    public void testResourceIsNotReturnedFromActiveResourcesIfRefIsCleared() {
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-        harness.doLoad();
-
-        verify(harness.cb, never()).onResourceReady(isNull(Resource.class));
-    }
-
-    @Test
-    public void testKeyIsRemovedFromActiveResourcesIfRefIsCleared() {
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-        harness.doLoad();
-
-        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-    }
-
-    @Test
-    public void testResourceIsAcquiredIfReturnedFromActiveResources() {
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-        harness.doLoad();
-
-        verify(harness.resource).acquire();
-    }
-
-    @Test
-    public void testNewLoadIsNotStartedIfResourceIsActive() {
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-        harness.doLoad();
-
-        verify(harness.job, never()).start(any(EngineRunnable.class));
-    }
-
-    @Test
-    public void testNullLoadStatusIsReturnedIfResourceIsActive() {
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-        assertNull(harness.doLoad());
-    }
-
-    @Test
-    public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-        EngineResource other = mock(EngineResource.class);
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
-
-        harness.doLoad();
-
-        verify(harness.cb).onResourceReady(eq(harness.resource));
-        verify(harness.cb, never()).onResourceReady(eq(other));
-    }
-
-    @Test
-    public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-        harness.isMemoryCacheable = false;
-        harness.doLoad();
-
-        verify(harness.resource, never()).acquire();
-        verify(harness.job).start(any(EngineRunnable.class));
-    }
-
-    @Test
-    public void testCacheIsCheckedIfMemoryCacheable() {
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-        harness.doLoad();
-
-        verify(harness.cb).onResourceReady(eq(harness.resource));
-    }
-
-    @Test
-    public void testCacheIsNotCheckedIfNotMemoryCacheable() {
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-        harness.isMemoryCacheable = false;
-        harness.doLoad();
-
-        verify(harness.job).start(any(EngineRunnable.class));
-    }
-
-    @Test
-    public void testResourceIsReturnedFromCacheIfPresent() {
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-        harness.doLoad();
-
-        verify(harness.cb).onResourceReady(eq(harness.resource));
-    }
-
-    @Test
-    public void testHandlesNonEngineResourcesFromCacheIfPresent() {
-        final Object expected = new Object();
-        Resource fromCache = mock(Resource.class);
-        when(fromCache.get()).thenReturn(expected);
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Resource resource = (Resource) invocationOnMock.getArguments()[0];
-                assertEquals(expected, resource.get());
-                return null;
-            }
-        }).when(harness.cb).onResourceReady(any(Resource.class));
-
-        harness.doLoad();
-
-        verify(harness.cb).onResourceReady(any(Resource.class));
-    }
-
-    @Test
-    public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-        harness.doLoad();
-
-        assertEquals(harness.resource, harness.activeResources.get(harness.cacheKey)
-                .get());
-    }
-
-    @Test
-    public void testResourceIsAcquiredIfReturnedFromCache() {
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-        harness.doLoad();
-
-        verify(harness.resource).acquire();
-    }
-
-    @Test
-    public void testNewLoadIsNotStartedIfResourceIsCached() {
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
-
-        harness.doLoad();
-
-        verify(harness.job, never()).start(any(EngineRunnable.class));
-    }
-
-    @Test
-    public void testNullLoadStatusIsReturnedForCachedResource() {
-        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
-
-        Engine.LoadStatus loadStatus = harness.doLoad();
-        assertNull(loadStatus);
-    }
-
-    @Test
-    public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
-        harness.doLoad();
-
-        harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-        assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
-    }
-
-    @Test
-    public void testEngineIsSetAsResourceListenerOnJobComplete() {
-        harness.doLoad();
-
-        harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-        verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.engine));
-    }
-
-    @Test
-    public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
-        harness.doLoad();
-
-        harness.engine.onEngineJobComplete(harness.cacheKey, null);
-    }
-
-    @Test
-    public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
-        when(harness.resource.isCacheable()).thenReturn(true);
-        harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-        WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
-        assertEquals(harness.resource, resourceRef.get());
-    }
-
-    @Test
-    public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
-        harness.engine.onEngineJobComplete(harness.cacheKey, null);
-        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-    }
-
-    @Test
-    public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
-        when(harness.resource.isCacheable()).thenReturn(false);
-        harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-    }
-
-    @Test
-    public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
-        harness.doLoad();
-
-        harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);
-
-        assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
-    }
-
-    @Test
-    public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
-        harness.doLoad();
-
-        harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
-
-        assertEquals(harness.job, harness.jobs.get(harness.cacheKey));
-    }
-
-    @Test
-    public void testResourceIsAddedToCacheOnReleased() {
-        final Object expected = new Object();
-        when(harness.resource.isCacheable()).thenReturn(true);
-        when(harness.resource.get()).thenReturn(expected);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
-                assertEquals(expected, resource.get());
-                return null;
-            }
-        }).when(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
-
-        harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-
-        verify(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
-    }
-
-    @Test
-    public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
-        when(harness.resource.isCacheable()).thenReturn(false);
-        harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-        verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
-    }
-
-    @Test
-    public void testResourceIsRecycledIfNotCacheableWhenReleased() {
-        when(harness.resource.isCacheable()).thenReturn(false);
-        harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-        verify(harness.resourceRecycler).recycle(eq(harness.resource));
-    }
-
-    @Test
-    public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
-        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-        harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-    }
-
-    @Test
-    public void testEngineAddedAsListenerToMemoryCache() {
-        verify(harness.cache).setResourceRemovedListener(eq(harness.engine));
-    }
-
-    @Test
-    public void testResourceIsRecycledWhenRemovedFromCache() {
-        harness.engine.onResourceRemoved(harness.resource);
-        verify(harness.resourceRecycler).recycle(eq(harness.resource));
-    }
-
-    @Test
-    public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
-        harness.doLoad();
-
-        assertThat(harness.jobs).containsEntry(harness.cacheKey, harness.job);
-    }
-
-    @Test
-    public void testKeyFactoryIsGivenNecessaryArguments() {
-        harness.doLoad();
-
-        verify(harness.keyFactory).buildKey(eq(ID), eq(harness.signature), eq(harness.width), eq(harness.height),
-                eq(harness.cacheDecoder), eq(harness.decoder), eq(harness.transformation), eq(harness.encoder),
-                eq(harness.transcoder), eq(harness.sourceEncoder));
-    }
-
-    @Test
-    public void testFactoryIsGivenNecessaryArguments() {
-        harness.doLoad();
-
-        verify(harness.engineJobFactory).build(eq(harness.cacheKey), eq(harness.isMemoryCacheable));
-    }
-
-    @Test
-    public void testReleaseReleasesEngineResource() {
-        EngineResource<Object> engineResource = mock(EngineResource.class);
-        harness.engine.release(engineResource);
-        verify(engineResource).release();
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfAskedToReleaseNonEngineResource() {
-        harness.engine.release(mock(Resource.class));
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
-        BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
-            @Override
-            public void runTest() throws Exception {
-                harness.doLoad();
-            }
-        });
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class EngineTestHarness {
-        EngineKey cacheKey = mock(EngineKey.class);
-        EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
-        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
-        DataFetcher<Object> fetcher = mock(DataFetcher.class);
-        ResourceDecoder<Object, Object> decoder = mock(ResourceDecoder.class);
-        ResourceEncoder<Object> encoder = mock(ResourceEncoder.class);
-        ResourceTranscoder<Object, Object> transcoder = mock(ResourceTranscoder.class);
-        Priority priority = Priority.NORMAL;
-        ResourceCallback cb = mock(ResourceCallback.class);
-        EngineResource resource = mock(EngineResource.class);
-        Map<Key, EngineJob> jobs = new HashMap<Key, EngineJob>();
-        Transformation transformation = mock(Transformation.class);
-        Map<Key, WeakReference<EngineResource<?>>> activeResources =
-                new HashMap<Key, WeakReference<EngineResource<?>>>();
-        Encoder<Object> sourceEncoder = mock(Encoder.class);
-        DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
-        Key signature = mock(Key.class);
-
-        int width = 100;
-        int height = 100;
-
-        MemoryCache cache = mock(MemoryCache.class);
-        EngineJob job;
-        Engine engine;
-        boolean isMemoryCacheable = true;
-        Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
-        DataLoadProvider<Object, Object> loadProvider = mock(DataLoadProvider.class);
-        ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
-
-        public EngineTestHarness() {
-            when(loadProvider.getCacheDecoder()).thenReturn(cacheDecoder);
-            when(loadProvider.getSourceEncoder()).thenReturn(sourceEncoder);
-            when(loadProvider.getEncoder()).thenReturn(encoder);
-            when(loadProvider.getSourceDecoder()).thenReturn(decoder);
-
-            when(keyFactory.buildKey(anyString(), any(Key.class), anyInt(), anyInt(), any(ResourceDecoder.class),
-                    any(ResourceDecoder.class), any(Transformation.class), any(ResourceEncoder.class),
-                    any(ResourceTranscoder.class), any(Encoder.class))).thenReturn(cacheKey);
-            when(fetcher.getId()).thenReturn(ID);
-
-            job = mock(EngineJob.class);
-
-            engine = new Engine(cache, mock(DiskCache.class), mock(ExecutorService.class),
-                    mock(ExecutorService.class), jobs, keyFactory, activeResources, engineJobFactory, resourceRecycler);
-
-        }
-
-        public Engine.LoadStatus doLoad() {
-            when(engineJobFactory.build(eq(cacheKey), eq(isMemoryCacheable))).thenReturn(job);
-            return engine.load(signature, width, height, fetcher, loadProvider, transformation, transcoder, priority,
-                    isMemoryCacheable, diskCacheStrategy, cb);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/OriginalKeyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/OriginalKeyTest.java
deleted file mode 100644
index 1d7ac4dbd..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/OriginalKeyTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class OriginalKeyTest {
-
-    @Test
-    public void testDiffersIfIdDiffers() throws UnsupportedEncodingException, NoSuchAlgorithmException {
-        Key signature = mock(Key.class);
-        OriginalKey first = new OriginalKey("first", signature);
-        OriginalKey second = new OriginalKey("second", signature);
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testDiffersIfSignatureDiffers() throws UnsupportedEncodingException, NoSuchAlgorithmException {
-        Key firstSignature = mock(Key.class);
-        doAnswer(new WriteDigest("firstSignature")).when(firstSignature).updateDiskCacheKey(any(MessageDigest.class));
-        Key secondSignature = mock(Key.class);
-        doAnswer(new WriteDigest("secondSignature")).when(secondSignature).updateDiskCacheKey(any(MessageDigest.class));
-
-        OriginalKey first = new OriginalKey("key", firstSignature);
-        OriginalKey second = new OriginalKey("key", secondSignature);
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testSameIfIdAndSignatureAreTheSame() throws UnsupportedEncodingException, NoSuchAlgorithmException {
-        Key signature = mock(Key.class);
-        OriginalKey first = new OriginalKey("key", signature);
-        OriginalKey second = new OriginalKey("key", signature);
-
-        KeyAssertions.assertSame(first, second);
-    }
-
-    private static class WriteDigest implements Answer<Void> {
-        private String toWrite;
-
-        public WriteDigest(String toWrite) {
-            this.toWrite = toWrite;
-        }
-
-        @Override
-        public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-            MessageDigest md = (MessageDigest) invocationOnMock.getArguments()[0];
-            md.update(toWrite.getBytes());
-            return null;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
deleted file mode 100644
index 15ae73647..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-import android.os.Looper;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ResourceRecyclerTest {
-
-    private ResourceRecycler recycler;
-
-    @Before
-    public void setUp() {
-        recycler = new ResourceRecycler();
-    }
-
-    @Test
-    public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
-        Resource resource = mock(Resource.class);
-        Robolectric.shadowOf(Looper.getMainLooper()).pause();
-        recycler.recycle(resource);
-        verify(resource).recycle();
-    }
-
-    @Test
-    public void testDoesNotRecycleChildResourceSynchronously() {
-        Resource parent = mock(Resource.class);
-        final Resource child = mock(Resource.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                recycler.recycle(child);
-                return null;
-            }
-        }).when(parent).recycle();
-
-        Robolectric.shadowOf(Looper.getMainLooper()).pause();
-
-        recycler.recycle(parent);
-
-        verify(parent).recycle();
-        verify(child, never()).recycle();
-
-        Robolectric.shadowOf(Looper.getMainLooper()).runOneTask();
-
-        verify(child).recycle();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
deleted file mode 100644
index 946778efc..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import com.google.common.testing.EqualsTester;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.AttributeStrategy.Key;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class AttributeStrategyKeyTest {
-
-    private AttributeStrategy.KeyPool keyPool;
-
-    @Before
-    public void setUp() {
-        keyPool = mock(AttributeStrategy.KeyPool.class);
-    }
-
-    @Test
-    public void testEquality() {
-        Key first = new Key(keyPool);
-        first.init(100, 100, Bitmap.Config.ARGB_4444);
-        Key second = new Key(keyPool);
-        second.init(100, 100, Bitmap.Config.ARGB_4444);
-
-        Key third = new Key(keyPool);
-        third.init(200, 100, Bitmap.Config.ARGB_4444);
-
-        Key fourth = new Key(keyPool);
-        fourth.init(100, 200, Bitmap.Config.ARGB_4444);
-
-        Key fifth = new Key(keyPool);
-        fifth.init(100, 100, Bitmap.Config.RGB_565);
-
-        new EqualsTester()
-                .addEqualityGroup(first, second)
-                .addEqualityGroup(third)
-                .addEqualityGroup(fourth)
-                .addEqualityGroup(fifth)
-                .testEquals();
-    }
-
-    @Test
-    public void testReturnsSelfToPoolOnOffer() {
-        Key key = new Key(keyPool);
-        key.offer();
-
-        verify(keyPool).offer(eq(key));
-    }
-
-    @Test
-    public void testInitSetsAttributes() {
-        Key key = new Key(keyPool);
-        key.init(100, 100, Bitmap.Config.ARGB_4444);
-
-        Key other = new Key(keyPool);
-        other.init(200, 200, Bitmap.Config.RGB_565);
-
-        assertNotEquals(key, other);
-
-        key.init(200, 200, Bitmap.Config.RGB_565);
-
-        assertEquals(key, other);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
deleted file mode 100644
index 7f5ec1f86..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
-import android.graphics.Bitmap;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowBitmap;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class AttributeStrategyTest {
-
-    private AttributeStrategy strategy;
-
-    @Before
-    public void setUp() throws Exception {
-        strategy = new AttributeStrategy();
-    }
-
-    @Test
-    public void testIGetNullIfNoMatchingBitmapExists() {
-        assertNull(strategy.get(100, 100, Bitmap.Config.ARGB_8888));
-    }
-
-    @Test
-    public void testICanAddAndGetABitmapOfTheSameSizeAndDimensions() {
-        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        strategy.put(bitmap);
-        assertEquals(bitmap, strategy.get(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888));
-    }
-
-    @Test
-    public void testICantGetABitmapOfTheSameDimensionsButDifferentConfigs() {
-        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        strategy.put(bitmap);
-        assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
-    }
-
-    @Test
-    public void testICantGetABitmapOfTheSameDimensionsAndSizeButDifferentConfigs() {
-        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-        strategy.put(bitmap);
-        assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
-    }
-
-    @Test
-    public void testICantGetABitmapOfDifferentWidths() {
-        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        strategy.put(bitmap);
-        assertNull(strategy.get(99, 100, Bitmap.Config.ARGB_8888));
-    }
-
-    @Test
-    public void testICantGetABitmapOfDifferentHeights() {
-        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        strategy.put(bitmap);
-        assertNull(strategy.get(100, 99, Bitmap.Config.ARGB_8888));
-    }
-
-    @Test
-    public void testICantGetABitmapOfDifferentDimensionsButTheSameSize() {
-        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        strategy.put(bitmap);
-        assertNull(strategy.get(50, 200, Bitmap.Config.ARGB_8888));
-    }
-
-    @Test
-    public void testMultipleBitmapsOfDifferentAttributesCanBeAddedAtOnce() {
-        Bitmap first = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-        Bitmap second = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        Bitmap third = ShadowBitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);
-
-        strategy.put(first);
-        strategy.put(second);
-        strategy.put(third);
-
-        assertEquals(first, strategy.get(100, 100, Bitmap.Config.RGB_565));
-        assertEquals(second, strategy.get(100, 100, Bitmap.Config.ARGB_8888));
-        assertEquals(third, strategy.get(120, 120, Bitmap.Config.RGB_565));
-    }
-
-    @Test
-    public void testLeastRecentlyUsedAttributeSetIsRemovedFirst() {
-        final Bitmap leastRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-        final Bitmap other = ShadowBitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);
-        final Bitmap mostRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        strategy.get(100, 100, Bitmap.Config.ALPHA_8);
-        strategy.get(1000, 1000, Bitmap.Config.RGB_565);
-        strategy.get(100, 100, Bitmap.Config.ARGB_8888);
-
-        strategy.put(other);
-        strategy.put(leastRecentlyUsed);
-        strategy.put(mostRecentlyUsed);
-
-        Bitmap removed = strategy.removeLast();
-        assertEquals("Expected=" + strategy.logBitmap(leastRecentlyUsed) + " got=" + strategy.logBitmap(removed),
-                leastRecentlyUsed, removed);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
deleted file mode 100644
index 49345f9f1..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ /dev/null
@@ -1,240 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static com.google.common.truth.Truth.assertThat;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowBitmap;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class LruBitmapPoolTest {
-    private static final int MAX_SIZE = 10;
-    private MockStrategy strategy;
-    private LruBitmapPool pool;
-
-    @Before
-    public void setUp() throws Exception {
-        strategy = new MockStrategy();
-        pool = new LruBitmapPool(MAX_SIZE, strategy);
-    }
-
-    @Test
-    public void testICanAddAndGetABitmap() {
-        fillPool(pool, 1);
-        pool.put(createMutableBitmap());
-        assertNotNull(pool.get(100, 100, Bitmap.Config.ARGB_8888));
-    }
-
-    @Test
-    public void testImmutableBitmapsAreNotAdded() {
-        Bitmap bitmap = createMutableBitmap();
-        Robolectric.shadowOf(bitmap).setMutable(false);
-        pool.put(bitmap);
-        assertThat(strategy.bitmaps).isEmpty();
-    }
-
-    @Test
-    public void testItIsSizeLimited() {
-        fillPool(pool, MAX_SIZE + 2);
-        assertEquals(2, strategy.numRemoves);
-    }
-
-    @Test
-    public void testBitmapLargerThanPoolIsNotAdded() {
-        strategy = new MockStrategy() {
-            @Override
-            public int getSize(Bitmap bitmap) {
-                return 4;
-            }
-        };
-        pool = new LruBitmapPool(3, strategy);
-        pool.put(createMutableBitmap());
-        assertEquals(0, strategy.numRemoves);
-        assertEquals(0, strategy.numPuts);
-    }
-
-    @Test
-    public void testClearMemoryRemovesAllBitmaps() {
-        fillPool(pool, MAX_SIZE);
-        pool.clearMemory();
-
-        assertEquals(MAX_SIZE, strategy.numRemoves);
-    }
-
-    @Test
-    public void testEvictedBitmapsAreRecycled() {
-        fillPool(pool, MAX_SIZE);
-        List<Bitmap> bitmaps = new ArrayList<Bitmap>(MAX_SIZE);
-        for (Bitmap b : strategy.bitmaps) {
-            bitmaps.add(b);
-        }
-
-        pool.clearMemory();
-
-        for (Bitmap b : bitmaps) {
-            assertTrue(b.isRecycled());
-        }
-    }
-
-    @Test
-    public void testTrimMemoryBackgroundOrLessRemovesHalfOfBitmaps() {
-        testTrimMemory(MAX_SIZE, TRIM_MEMORY_BACKGROUND, MAX_SIZE / 2);
-    }
-
-    @Test
-    public void testTrimMemoryBackgroundOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
-        testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_BACKGROUND, 0);
-    }
-
-    @Test
-    public void testTrimMemoryModerateOrGreaterRemovesAllBitmaps() {
-        for (int trimLevel : new int[] { TRIM_MEMORY_MODERATE, TRIM_MEMORY_COMPLETE }) {
-            testTrimMemory(MAX_SIZE, trimLevel, MAX_SIZE);
-        }
-    }
-
-    @Test
-    public void testPassesArgb888ToStrategyAsConfigForRequestsWithNullConfigsOnGet() {
-        LruPoolStrategy strategy = mock(LruPoolStrategy.class);
-        LruBitmapPool pool = new LruBitmapPool(100, strategy);
-
-        Bitmap expected = createMutableBitmap();
-        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);
-        Bitmap result = pool.get(100, 100, null);
-
-        assertEquals(expected, result);
-    }
-
-    @Test
-    public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetDirty() {
-        LruPoolStrategy strategy = mock(LruPoolStrategy.class);
-        LruBitmapPool pool = new LruBitmapPool(100, strategy);
-
-        Bitmap expected = createMutableBitmap();
-        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);
-        Bitmap result = pool.getDirty(100, 100, null);
-
-        assertEquals(expected, result);
-    }
-
-    private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
-        MockStrategy strategy = new MockStrategy();
-        LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy);
-        fillPool(pool, fillSize);
-        pool.trimMemory(trimLevel);
-        assertEquals("Failed level=" + trimLevel, expectedSize, strategy.numRemoves);
-    }
-
-    @Test
-    public void testCanIncreaseSizeDynamically() {
-        int sizeMultiplier = 2;
-        pool.setSizeMultiplier(2);
-        fillPool(pool, MAX_SIZE * sizeMultiplier);
-
-        assertEquals(0, strategy.numRemoves);
-    }
-
-    @Test
-    public void testCanDecreaseSizeDynamically() {
-        fillPool(pool, MAX_SIZE);
-        assertEquals(0, strategy.numRemoves);
-
-        float sizeMultiplier = 0.5f;
-        pool.setSizeMultiplier(sizeMultiplier);
-
-        assertEquals(Math.round(MAX_SIZE * sizeMultiplier), strategy.numRemoves);
-    }
-
-    @Test
-    public void testCanResetSizeDynamically() {
-        int sizeMultiplier = 2;
-        pool.setSizeMultiplier(sizeMultiplier);
-        fillPool(pool, MAX_SIZE * sizeMultiplier);
-
-        pool.setSizeMultiplier(1);
-
-        assertEquals(Math.round(MAX_SIZE * sizeMultiplier) - MAX_SIZE, strategy.numRemoves);
-    }
-
-    @Test
-    public void testCanGetCurrentMaxSize() {
-        assertEquals(MAX_SIZE, pool.getMaxSize());
-    }
-
-    @Test
-    public void testMaxSizeChangesAfterSizeMultiplier() {
-        pool.setSizeMultiplier(2);
-        assertEquals(2 * MAX_SIZE, pool.getMaxSize());
-    }
-
-    private void fillPool(LruBitmapPool pool, int fillCount) {
-        for (int i = 0; i < fillCount; i++) {
-            pool.put(createMutableBitmap());
-        }
-    }
-
-    private Bitmap createMutableBitmap() {
-        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        Robolectric.shadowOf(bitmap).setMutable(true);
-        return bitmap;
-    }
-
-    private static class MockStrategy implements LruPoolStrategy {
-        private LinkedList<Bitmap> bitmaps = new LinkedList<Bitmap>();
-        private int numRemoves;
-        private int numPuts;
-
-        @Override
-        public void put(Bitmap bitmap) {
-            numPuts++;
-            bitmaps.add(bitmap);
-        }
-
-        @Override
-        public Bitmap get(int width, int height, Bitmap.Config config) {
-            return bitmaps.removeLast();
-        }
-
-        @Override
-        public Bitmap removeLast() {
-            numRemoves++;
-            return bitmaps.removeLast();
-        }
-
-        @Override
-        public String logBitmap(Bitmap bitmap) {
-            return null;
-        }
-
-        @Override
-        public String logBitmap(int width, int height, Bitmap.Config config) {
-            return null;
-        }
-
-        @Override
-        public int getSize(Bitmap bitmap) {
-            return 1;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
deleted file mode 100644
index 2e3839284..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import com.google.common.testing.EqualsTester;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.SizeStrategy.Key;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class SizeStrategyKeyTest {
-
-    private SizeStrategy.KeyPool keyPool;
-
-    @Before
-    public void setUp() {
-        keyPool = mock(SizeStrategy.KeyPool.class);
-    }
-
-    @Test
-    public void testEquality() {
-        Key first = new Key(keyPool);
-        first.init(100);
-        Key second = new Key(keyPool);
-        second.init(100);
-        Key third = new Key(keyPool);
-        third.init(50);
-
-        new EqualsTester()
-                .addEqualityGroup(first, second)
-                .addEqualityGroup(third)
-                .testEquals();
-    }
-
-    @Test
-    public void testReturnsSelfToPoolOnOffer() {
-        Key key = new Key(keyPool);
-        key.offer();
-
-        verify(keyPool).offer(eq(key));
-    }
-
-    @Test
-    public void testInitSetsSize() {
-        Key key = new Key(keyPool);
-        key.init(100);
-
-        Key other = new Key(keyPool);
-        other.init(200);
-
-        assertNotEquals(key, other);
-
-        key.init(200);
-
-        assertEquals(key, other);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
deleted file mode 100644
index 4e8e89eb9..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ /dev/null
@@ -1,127 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class DiskLruCacheWrapperTest {
-    private DiskLruCacheWrapper cache;
-    private byte[] data;
-    private StringKey key;
-
-    @Before
-    public void setUp() {
-        File dir = Robolectric.application.getCacheDir();
-        cache = new DiskLruCacheWrapper(dir, 10 * 1024 * 1024);
-        key = new StringKey("test" + Math.random());
-        data = new byte[] { 1, 2, 3, 4, 5, 6 };
-    }
-
-    @Test
-    public void testCanInsertAndGet() throws IOException {
-        cache.put(key, new DiskCache.Writer() {
-            @Override
-            public boolean write(File file) {
-                try {
-                    Util.writeFile(file, data);
-                } catch (IOException e) {
-                    fail(e.toString());
-                }
-                return true;
-            }
-        });
-
-        byte[] received = Util.readFile(cache.get(key), data.length);
-
-        assertArrayEquals(data, received);
-    }
-
-    @Test
-    public void testDoesNotCommitIfWriterReturnsFalse() {
-        cache.put(key, new DiskCache.Writer() {
-            @Override
-            public boolean write(File file) {
-                return false;
-            }
-        });
-
-        assertNull(cache.get(key));
-    }
-
-    @Test
-    public void testDoesNotCommitIfWriterWritesButReturnsFalse() {
-        cache.put(key, new DiskCache.Writer() {
-            @Override
-            public boolean write(File file) {
-                try {
-                    Util.writeFile(file, data);
-                } catch (IOException e) {
-                    fail(e.toString());
-                }
-                return false;
-            }
-        });
-
-        assertNull(cache.get(key));
-    }
-
-    @Test
-    public void testEditIsAbortedIfWriterThrows() throws IOException {
-        try {
-            cache.put(key, new DiskCache.Writer() {
-                @Override
-                public boolean write(File file) {
-                    throw new RuntimeException("test");
-                }
-            });
-        } catch (RuntimeException e) {
-            // Expected.
-        }
-
-        cache.put(key, new DiskCache.Writer() {
-            @Override
-            public boolean write(File file) {
-                try {
-                    Util.writeFile(file, data);
-                } catch (IOException e) {
-                    fail(e.toString());
-                }
-                return true;
-            }
-        });
-
-        byte[] received = Util.readFile(cache.get(key), data.length);
-
-        assertArrayEquals(data, received);
-    }
-
-    private static class StringKey implements Key {
-        private final String key;
-
-        public StringKey(String key) {
-            this.key = key;
-        }
-
-        @Override
-        public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-            messageDigest.update(key.getBytes());
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/KeyGeneratorTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/KeyGeneratorTest.java
deleted file mode 100644
index 1f763b927..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/KeyGeneratorTest.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static org.junit.Assert.assertTrue;
-
-import com.bumptech.glide.load.Key;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-@RunWith(JUnit4.class)
-public class KeyGeneratorTest {
-    private SafeKeyGenerator keyGenerator;
-    private int nextId;
-
-    @Before
-    public void setUp() throws Exception {
-        nextId = 0;
-        keyGenerator = new SafeKeyGenerator();
-    }
-
-    @Test
-    public void testKeysAreValidForDiskCache() {
-        final Pattern diskCacheRegex = Pattern.compile("[a-z0-9_-]{64}");
-        for (int i = 0; i < 1000; i++) {
-            String key = getRandomKeyFromGenerator();
-            Matcher matcher = diskCacheRegex.matcher(key);
-            assertTrue(key, matcher.matches());
-        }
-    }
-
-    private String getRandomKeyFromGenerator() {
-        return keyGenerator.getSafeKey(new MockKey(getNextId()));
-    }
-
-    private String getNextId() {
-        return String.valueOf(nextId++);
-    }
-
-    private static class MockKey implements Key {
-        private String id;
-
-        public MockKey(String id) {
-            this.id = id;
-        }
-
-        @Override
-        public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-            messageDigest.update(id.getBytes(STRING_CHARSET_NAME));
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
deleted file mode 100644
index dd5428a7e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ /dev/null
@@ -1,352 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.util.LruCache;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class LruCacheTest {
-    // 1MB
-    private static final int SIZE = 2;
-    private LruCache<String, Object> cache;
-    private CacheListener listener;
-    private String currentKey;
-
-    @Before
-    public void setUp() throws Exception {
-        currentKey = "";
-        listener = mock(CacheListener.class);
-        cache = new TestLruCache(SIZE, listener);
-        when(listener.getSize(anyObject())).thenReturn(1);
-    }
-
-    @Test
-    public void testCanAddAndRetrieveItem() {
-        String key = getKey();
-        Object object = new Object();
-
-        cache.put(key, object);
-
-        assertEquals(object, cache.get(key));
-    }
-
-    @Test
-    public void testCanPutNullItemWithoutChangingSize() {
-        String key = getKey();
-        cache.put(key, null);
-
-        for (int i = 0; i < SIZE; i++) {
-            cache.put(getKey(), new Object());
-        }
-
-        verify(listener, never()).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testReplacingNonNullItemWithNullItemDecreasesSize() {
-        String key = getKey();
-        cache.put(key, new Object());
-        cache.put(key, null);
-
-        for (int i = 0; i < SIZE; i++) {
-            cache.put(getKey(), new Object());
-        }
-
-        verify(listener, never()).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testReplacingNullItemWIthNullItemIncreasesSize() {
-        String key = getKey();
-        cache.put(key, null);
-        cache.put(key, new Object());
-
-        for (int i = 0; i < SIZE; i++) {
-            cache.put(getKey(), new Object());
-        }
-
-        verify(listener).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testReplacingNonNullItemWithNonNullItemUpdatesSize() {
-        String key = getKey();
-        cache.put(key, new Object());
-        cache.put(key, new Object());
-
-        for (int i = 0; i < SIZE; i++) {
-            cache.put(getKey(), new Object());
-        }
-
-        verify(listener).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testCacheContainsAddedBitmap() {
-        final String key = getKey();
-        cache.put(key, new Object());
-        assertTrue(cache.contains(key));
-    }
-
-    @Test
-    public void testEmptyCacheDoesNotContainKey() {
-        assertFalse(cache.contains(getKey()));
-    }
-
-    @Test
-    public void testItIsSizeLimited() {
-        for (int i = 0; i < SIZE; i++) {
-            cache.put(getKey(), new Object());
-        }
-        verify(listener, never()).onItemRemoved(anyObject());
-        cache.put(getKey(), new Object());
-        verify(listener).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testLeastRecentlyAddKeyEvictedFirstIfGetsAreEqual() {
-        Object first = new Object();
-        cache.put(getKey(), first);
-        cache.put(getKey(), new Object());
-        cache.put(getKey(), new Object());
-
-        verify(listener).onItemRemoved(eq(first));
-        verify(listener, times(1)).onItemRemoved(any(Object.class));
-    }
-
-    @Test
-    public void testLeastRecentlyUsedKeyEvictedFirst() {
-        String mostRecentlyUsedKey = getKey();
-        Object mostRecentlyUsedObject = new Object();
-        String leastRecentlyUsedKey = getKey();
-        Object leastRecentlyUsedObject = new Object();
-
-        cache.put(mostRecentlyUsedKey, mostRecentlyUsedObject);
-        cache.put(leastRecentlyUsedKey, leastRecentlyUsedObject);
-
-        cache.get(mostRecentlyUsedKey);
-        cache.put(getKey(), new Object());
-
-        verify(listener).onItemRemoved(eq(leastRecentlyUsedObject));
-        verify(listener, times(1)).onItemRemoved(any(Object.class));
-    }
-
-    @Test
-    public void testItemLargerThanCacheIsImmediatelyEvicted() {
-        Object tooLarge = new Object();
-        when(listener.getSize(eq(tooLarge))).thenReturn(SIZE + 1);
-        cache.put(getKey(), tooLarge);
-
-        verify(listener).onItemRemoved(eq(tooLarge));
-    }
-
-    @Test
-    public void testItemLargerThanCacheDoesNotCauseAdditionalEvictions() {
-        cache.put(getKey(), new Object());
-
-        Object tooLarge = new Object();
-        when(listener.getSize(eq(tooLarge))).thenReturn(SIZE + 1);
-
-        cache.put(getKey(), tooLarge);
-
-        verify(listener, times(1)).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testClearMemoryRemovesAllItems() {
-        String first = getKey();
-        String second = getKey();
-        cache.put(first, new Object());
-        cache.put(second, new Object());
-
-        cache.clearMemory();
-
-        assertFalse(cache.contains(first));
-        assertFalse(cache.contains(second));
-    }
-
-    @Test
-    public void testCanPutSameItemMultipleTimes() {
-        String key = getKey();
-        Object value = new Object();
-        for (int i = 0; i < SIZE * 2; i++) {
-            cache.put(key, value);
-        }
-
-        verify(listener, never()).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testCanIncreaseSizeDynamically() {
-        int sizeMultiplier = 2;
-        cache.setSizeMultiplier(sizeMultiplier);
-        for (int i = 0; i < SIZE * sizeMultiplier; i++) {
-            cache.put(getKey(), new Object());
-        }
-
-        verify(listener, never()).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testCanDecreaseSizeDynamically() {
-        for (int i = 0; i < SIZE; i++) {
-            cache.put(getKey(), new Object());
-        }
-        verify(listener, never()).onItemRemoved(anyObject());
-
-        cache.setSizeMultiplier(0.5f);
-
-        verify(listener).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testCanResetSizeDynamically() {
-        int sizeMultiplier = 2;
-        cache.setSizeMultiplier(sizeMultiplier);
-        for (int i = 0; i < SIZE * sizeMultiplier; i++) {
-            cache.put(getKey(), new Object());
-        }
-
-        cache.setSizeMultiplier(1);
-
-        verify(listener, times(sizeMultiplier)).onItemRemoved(anyObject());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfMultiplierLessThanZero() {
-        cache.setSizeMultiplier(-1);
-    }
-
-    @Test
-    public void testCanHandleZeroAsMultiplier() {
-        for (int i = 0; i < SIZE; i++) {
-            cache.put(getKey(), new Object());
-        }
-        cache.setSizeMultiplier(0);
-
-        verify(listener, times(SIZE)).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testCanRemoveKeys() {
-        String key = getKey();
-        Object value = new Object();
-        cache.put(key, value);
-        cache.remove(key);
-
-        assertNull(cache.get(key));
-        assertFalse(cache.contains(key));
-    }
-
-    @Test
-    public void testDecreasesSizeWhenRemovesKey() {
-        String key = getKey();
-        Object value = new Object();
-        cache.put(key, value);
-        for (int i = 0; i < SIZE - 1; i++) {
-            cache.put(key, value);
-        }
-        cache.remove(key);
-        cache.put(key, value);
-
-        verify(listener, never()).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testDoesNotCallListenerWhenRemovesKey() {
-        String key = getKey();
-        cache.put(key, new Object());
-        cache.remove(key);
-
-        verify(listener, never()).onItemRemoved(anyObject());
-    }
-
-    @Test
-    public void testGetMaxSizeReturnsCurrentMaxSizeOfCache() {
-        assertEquals(SIZE, cache.getMaxSize());
-    }
-
-    @Test
-    public void testGetMaxSizeChangesIfMaxSizeChanges() {
-        int multiplier = 2;
-        cache.setSizeMultiplier(multiplier);
-
-        assertEquals(SIZE * multiplier, cache.getMaxSize());
-    }
-
-    @Test
-    public void getCurrentSizeReturnsZeroForEmptyCache() {
-        assertEquals(0, cache.getCurrentSize());
-    }
-
-    @Test
-    public void testGetCurrentSizeIncreasesAsSizeIncreases() {
-        cache.put(getKey(), new Object());
-        assertEquals(1, cache.getCurrentSize());
-        cache.put(getKey(), new Object());
-        assertEquals(2, cache.getCurrentSize());
-    }
-
-    @Test
-    public void testGetCurrentSizeDoesNotChangeWhenSizeMultiplierChangesIfNoItemsAreEvicted() {
-        cache.put(getKey(), new Object());
-        assertEquals(1, cache.getCurrentSize());
-        cache.setSizeMultiplier(2);
-        assertEquals(1, cache.getCurrentSize());
-    }
-
-    @Test
-    public void testGetCurrentSizeChangesIfItemsAreEvictedWhenSizeMultiplierChanges() {
-        for (int i = 0; i < SIZE; i++) {
-            cache.put(getKey(), new Object());
-        }
-        assertEquals(SIZE, cache.getCurrentSize());
-        cache.setSizeMultiplier(0.5f);
-        assertEquals(SIZE / 2, cache.getCurrentSize());
-    }
-
-    private String getKey() {
-        currentKey += "1";
-        return currentKey;
-    }
-
-    private interface CacheListener {
-        public void onItemRemoved(Object item);
-        public int getSize(Object item);
-    }
-
-    private static class TestLruCache extends LruCache<String, Object> {
-        private final CacheListener listener;
-
-        public TestLruCache(int size, CacheListener listener) {
-            super(size);
-            this.listener = listener;
-        }
-
-        @Override
-        protected void onItemEvicted(String key, Object item) {
-            listener.onItemRemoved(item);
-        }
-
-        @Override
-        protected int getSize(Object item) {
-            return listener.getSize(item);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
deleted file mode 100644
index 9a40b9616..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.ComponentCallbacks2;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-
-@RunWith(JUnit4.class)
-public class LruResourceCacheTest {
-    private static class TrimClearMemoryCacheHarness {
-        LruResourceCache resourceCache = new LruResourceCache(100);
-        Resource first = mock(Resource.class);
-        Resource second = mock(Resource.class);
-
-        ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-        public TrimClearMemoryCacheHarness() {
-            when(first.getSize()).thenReturn(50);
-            when(second.getSize()).thenReturn(50);
-            resourceCache.put(new MockKey(), first);
-            resourceCache.put(new MockKey(), second);
-            resourceCache.setResourceRemovedListener(listener);
-        }
-    }
-
-    @Test
-    public void testTrimMemoryModerate() {
-        TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-        harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
-
-        verify(harness.listener).onResourceRemoved(eq(harness.first));
-        verify(harness.listener).onResourceRemoved(eq(harness.second));
-    }
-
-    @Test
-    public void testTrimMemoryComplete() {
-        TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-        harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
-
-        verify(harness.listener).onResourceRemoved(harness.first);
-        verify(harness.listener).onResourceRemoved(harness.second);
-    }
-
-    @Test
-    public void testTrimMemoryBackground() {
-        TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-        harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
-
-        verify(harness.listener).onResourceRemoved(harness.first);
-        verify(harness.listener, never()).onResourceRemoved(harness.second);
-    }
-
-    @Test
-    public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
-        LruResourceCache resourceCache = new LruResourceCache(100);
-        Resource resource = mock(Resource.class);
-        when(resource.getSize()).thenReturn(200);
-
-        ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-        resourceCache.setResourceRemovedListener(listener);
-        resourceCache.put(new MockKey(), resource);
-
-        verify(listener).onResourceRemoved(eq(resource));
-    }
-
-    @Test
-    public void testSizeIsBasedOnResource() {
-        LruResourceCache resourceCache = new LruResourceCache(100);
-        Resource first = getResource(50);
-        MockKey firstKey = new MockKey();
-        resourceCache.put(firstKey, first);
-        Resource second = getResource(50);
-        MockKey secondKey = new MockKey();
-        resourceCache.put(secondKey, second);
-
-        assertTrue(resourceCache.contains(firstKey));
-        assertTrue(resourceCache.contains(secondKey));
-
-        Resource third = getResource(50);
-        MockKey thirdKey = new MockKey();
-        resourceCache.put(thirdKey, third);
-
-        assertFalse(resourceCache.contains(firstKey));
-        assertTrue(resourceCache.contains(secondKey));
-        assertTrue(resourceCache.contains(thirdKey));
-    }
-
-    private Resource getResource(int size) {
-        Resource resource = mock(Resource.class);
-        when(resource.getSize()).thenReturn(size);
-        return resource;
-    }
-
-    private static class MockKey implements Key {
-        @Override
-        public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-            messageDigest.update(toString().getBytes("UTF-8"));
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
deleted file mode 100644
index 932da8047..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ /dev/null
@@ -1,138 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import com.google.common.collect.Range;
-
-import android.app.ActivityManager;
-import android.content.Context;
-import android.os.Build;
-
-import com.bumptech.glide.tests.Util;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class MemorySizeCalculatorTest {
-    private MemorySizeHarness harness;
-    private int initialSdkVersion;
-
-    @Before
-    public void setUp() {
-        initialSdkVersion = Build.VERSION.SDK_INT;
-        harness = new MemorySizeHarness();
-    }
-
-    @After
-    public void tearDown() {
-        Util.setSdkVersionInt(initialSdkVersion);
-    }
-
-
-    @Test
-    public void testDefaultMemoryCacheSizeIsTwiceScreenSize() {
-        Robolectric.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());
-
-        int memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
-
-        assertEquals(harness.getScreenSize() * harness.memoryCacheScreens , memoryCacheSize);
-    }
-
-    @Test
-    public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
-        final int memoryClassBytes = Math.round(harness.getScreenSize() * harness.memoryCacheScreens
-                * harness.sizeMultiplier);
-
-        Robolectric.shadowOf(harness.activityManager).setMemoryClass(memoryClassBytes / (1024 * 1024));
-
-        int memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
-
-        assertThat((float) memoryCacheSize).isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
-    }
-
-    @Test
-    public void testDefaultBitmapPoolSizeIsThreeTimesScreenSize() {
-        Robolectric.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());
-
-        int bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
-
-        assertEquals(harness.getScreenSize() * harness.bitmapPoolScreens, bitmapPoolSize);
-    }
-
-    @Test
-    public void testDefaultBitmapPoolSizeIsLimitedByMemoryClass() {
-        final int memoryClassBytes = Math.round(harness.getScreenSize() * harness.bitmapPoolScreens
-                * harness.sizeMultiplier);
-
-        Robolectric.shadowOf(harness.activityManager).setMemoryClass(memoryClassBytes / (1024 * 1024));
-
-        int bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
-
-        assertThat((float) bitmapPoolSize).isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
-    }
-
-    @Test
-    public void testCumulativePoolAndMemoryCacheSizeAreLimitedByMemoryClass() {
-        final int memoryClassBytes = Math.round(harness.getScreenSize()
-                * (harness.bitmapPoolScreens + harness.memoryCacheScreens) * harness.sizeMultiplier);
-        Robolectric.shadowOf(harness.activityManager).setMemoryClass(memoryClassBytes / (1024 * 1024));
-
-        int memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
-        int bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
-
-        assertThat((float) memoryCacheSize + bitmapPoolSize).isIn(
-                Range.atMost(memoryClassBytes * harness.sizeMultiplier));
-    }
-
-    @Test
-    public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices() {
-        Robolectric.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass() / 2);
-        final int normalMemoryCacheSize = harness.getCalculator().getMemoryCacheSize();
-        final int normalBitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
-
-        Util.setSdkVersionInt(10);
-
-        final int smallMemoryCacheSize = harness.getCalculator().getMemoryCacheSize();
-        final int smallBitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
-
-        assertThat(smallMemoryCacheSize).isLessThan(normalMemoryCacheSize);
-        assertThat(smallBitmapPoolSize).isLessThan(normalBitmapPoolSize);
-    }
-
-    private int getLargeEnoughMemoryClass() {
-        // Memory class is in mb, not bytes!
-        return Math.round(harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens)
-                * (1f / harness.sizeMultiplier) / (1024 * 1024));
-    }
-
-    private static class MemorySizeHarness {
-        int pixelSize = 500;
-        int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
-        int memoryCacheScreens = MemorySizeCalculator.MEMORY_CACHE_TARGET_SCREENS;
-        int bitmapPoolScreens = MemorySizeCalculator.BITMAP_POOL_TARGET_SCREENS;
-        float sizeMultiplier = MemorySizeCalculator.MAX_SIZE_MULTIPLIER;
-        ActivityManager activityManager =
-                (ActivityManager) Robolectric.application.getSystemService(Context.ACTIVITY_SERVICE);
-        MemorySizeCalculator.ScreenDimensions screenDimensions = mock(MemorySizeCalculator.ScreenDimensions.class);
-
-        public MemorySizeCalculator getCalculator() {
-            when(screenDimensions.getWidthPixels()).thenReturn(pixelSize);
-            when(screenDimensions.getHeightPixels()).thenReturn(pixelSize);
-            return new MemorySizeCalculator(activityManager, screenDimensions);
-        }
-
-        public int getScreenSize() {
-            return pixelSize * pixelSize * bytesPerPixel;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutorTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutorTest.java
deleted file mode 100644
index a26b905e0..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutorTest.java
+++ /dev/null
@@ -1,145 +0,0 @@
-package com.bumptech.glide.load.engine.executor;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-
-import com.google.common.testing.EqualsTester;
-
-import com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor.LoadTask;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class FifoPriorityThreadPoolExecutorTest {
-
-    @Test
-    public void testLoadsAreExecutedInOrder() throws InterruptedException {
-        final int numPrioritiesToTest = 5;
-        final List<Integer> resultPriorities = Collections.synchronizedList(new ArrayList<Integer>());
-        FifoPriorityThreadPoolExecutor executor = new FifoPriorityThreadPoolExecutor(1);
-        for (int i = 5; i > 0; i--) {
-            executor.submit(new MockRunnable(i, new MockRunnable.OnRun() {
-                @Override
-                public void onRun(int priority) {
-                    resultPriorities.add(priority);
-                }
-            }));
-        }
-
-        executor.awaitTermination(200, TimeUnit.MILLISECONDS);
-
-        assertThat(resultPriorities).hasSize(numPrioritiesToTest);
-
-        // Since no jobs are queued, the first item added will be run immediately, regardless of priority.
-        assertEquals(numPrioritiesToTest, resultPriorities.get(0).intValue());
-
-        for (int i = 1; i < numPrioritiesToTest; i++) {
-            assertEquals(i, resultPriorities.get(i).intValue());
-        }
-    }
-
-    @Test
-    public void testLoadsWithSamePriorityAreExecutedInSubmitOrder() throws InterruptedException {
-        final int numItemsToTest = 10;
-        final List<Integer> executionOrder = new ArrayList<Integer>();
-        final List<Integer> executedOrder = Collections.synchronizedList(new ArrayList<Integer>());
-        FifoPriorityThreadPoolExecutor executor = new FifoPriorityThreadPoolExecutor(1);
-        for (int i = 0; i < numItemsToTest; i++) {
-            executionOrder.add(i);
-        }
-        for (int i = 0; i < numItemsToTest; i++) {
-            final int finalI = i;
-            executor.submit(new MockRunnable(0, new MockRunnable.OnRun() {
-                final int position = finalI;
-                @Override
-                public void onRun(int priority) {
-                    executedOrder.add(position);
-                }
-            }));
-        }
-        executor.awaitTermination(200, TimeUnit.MILLISECONDS);
-
-        assertThat(executedOrder).containsAllIn(executionOrder).inOrder();
-    }
-
-    @Test
-    public void testLoadTaskEquality() {
-        new EqualsTester()
-                .addEqualityGroup(
-                        new LoadTask<Object>(new MockRunnable(10), new Object(), 1),
-                        new LoadTask<Object>(new MockRunnable(10), new Object(), 1))
-                .addEqualityGroup(
-                        new LoadTask<Object>(new MockRunnable(5), new Object(), 1)
-                )
-                .addEqualityGroup(
-                        new LoadTask<Object>(new MockRunnable(10), new Object(), 3)
-                )
-                .testEquals();
-    }
-
-    @Test
-    public void testLoadTaskCompareToPrefersHigherPriority() {
-        LoadTask<Object> first = new LoadTask<Object>(new MockRunnable(10), new Object(), 10);
-        LoadTask<Object> second = new LoadTask<Object>(new MockRunnable(0), new Object(), 10);
-
-        assertTrue(first.compareTo(second) > 0);
-        assertTrue(second.compareTo(first) < 0);
-    }
-
-    @Test
-    public void testLoadTaskCompareToFallsBackToOrderIfPriorityIsEqual() {
-        LoadTask<Object> first = new LoadTask<Object>(new MockRunnable(0), new Object(), 2);
-        LoadTask<Object> second = new LoadTask<Object>(new MockRunnable(0), new Object(), 1);
-
-        assertTrue(first.compareTo(second) > 0);
-        assertTrue(second.compareTo(first) < 0);
-    }
-
-    @Test
-    public void testLoadTaskCompareToReturnsZeroIfPriorityAndOrderAreEqual() {
-        LoadTask<Object> first = new LoadTask<Object>(new MockRunnable(0), new Object(), 1);
-        LoadTask<Object> second = new LoadTask<Object>(new MockRunnable(0), new Object(), 1);
-
-        assertEquals(0, first.compareTo(second));
-        assertEquals(0, second.compareTo(first));
-    }
-
-    private static class MockRunnable implements Runnable, Prioritized {
-        private final int priority;
-        private final OnRun onRun;
-
-        public interface OnRun {
-            public void onRun(int priority);
-        }
-
-        public MockRunnable(int priority) {
-            this(priority, mock(OnRun.class));
-        }
-
-        public MockRunnable(int priority, OnRun onRun) {
-            this.priority = priority;
-            this.onRun = onRun;
-        }
-
-        @Override
-        public int getPriority() {
-            return priority;
-        }
-
-        @Override
-        public void run() {
-            onRun.onRun(priority);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
deleted file mode 100644
index 8b42ca182..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ /dev/null
@@ -1,335 +0,0 @@
-package com.bumptech.glide.load.engine.prefill;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertNotEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.os.Handler;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.load.resource.bitmap.BitmapResource;
-import com.bumptech.glide.util.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BitmapPreFillRunnerTest {
-    private BitmapPreFillRunner.Clock clock;
-    private BitmapPool pool;
-    private MemoryCache cache;
-    private List<Bitmap> addedBitmaps = new ArrayList<Bitmap>();
-    private Handler mainHandler;
-
-    @Before
-    public void setUp() {
-        clock = mock(BitmapPreFillRunner.Clock.class);
-
-        pool = mock(BitmapPool.class);
-        when(pool.put(any(Bitmap.class))).thenAnswer(new AddBitmapPoolAnswer(addedBitmaps));
-        cache = mock(MemoryCache.class);
-        when(cache.put(any(Key.class), any(Resource.class))).thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));
-        mainHandler = mock(Handler.class);
-    }
-
-    private BitmapPreFillRunner getHandler(Map<PreFillType, Integer> allocationOrder) {
-        return new BitmapPreFillRunner(pool, cache, new PreFillQueue(allocationOrder), clock, mainHandler);
-    }
-
-    @Test
-    public void testAllocatesABitmapPerSizeInAllocationOrder() {
-        PreFillType size = new PreFillType.Builder(100)
-                .setConfig(Bitmap.Config.ARGB_8888)
-                .build();
-        final int toAdd = 3;
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, toAdd);
-        BitmapPreFillRunner handler = getHandler(allocationOrder);
-        handler.run();
-
-        Bitmap expected = Bitmap.createBitmap(size.getWidth(), size.getHeight(), size.getConfig());
-        assertThat(addedBitmaps).containsExactly(expected, expected, expected);
-    }
-
-    @Test
-    public void testAllocatesBitmapsInOrderGivenByAllocationOrder() {
-        PreFillType smallWidth = new PreFillType.Builder(50, 100)
-                .setConfig(Bitmap.Config.ARGB_8888)
-                .build();
-        PreFillType smallHeight = new PreFillType.Builder(100, 50)
-                .setConfig(Bitmap.Config.RGB_565)
-                .build();
-
-        PreFillType[] expectedOrder = new PreFillType[] {
-                smallWidth,
-                smallHeight,
-                smallWidth,
-                smallHeight,
-        };
-
-        HashMap<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(smallWidth, 2);
-        allocationOrder.put(smallHeight, 2);
-        BitmapPreFillRunner handler = getHandler(allocationOrder);
-        handler.run();
-
-        Bitmap[] expectedBitmaps = new Bitmap[expectedOrder.length];
-        for (int i = 0; i < expectedBitmaps.length; i++) {
-            PreFillType current = expectedOrder[i];
-            expectedBitmaps[i] = Bitmap.createBitmap(current.getWidth(), current.getHeight(), current.getConfig());
-        }
-
-        Bitmap current = addedBitmaps.get(0);
-        for (int i = 1; i < addedBitmaps.size(); i++) {
-            assertNotEquals(current, addedBitmaps.get(i));
-            current = addedBitmaps.get(i);
-        }
-
-        assertThat(addedBitmaps).hasSize(4);
-    }
-
-    @Test
-    public void testStopsAllocatingBitmapsUntilNextIdleCallIfAllocationsTakeLongerThanLimit() {
-        PreFillType size = new PreFillType.Builder(1)
-                .setConfig(Bitmap.Config.ARGB_8888)
-                .build();
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, 3);
-        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
-        BitmapPreFillRunner handler = getHandler(allocationOrder);
-        handler.run();
-
-        assertThat(addedBitmaps).hasSize(1);
-
-        handler.run();
-
-        assertThat(addedBitmaps).hasSize(3);
-    }
-
-    @Test
-    public void testPreFillHandlerDoesNotPostIfHasNoBitmapsToAllocate() {
-        BitmapPreFillRunner handler = getHandler(new HashMap<PreFillType, Integer>());
-        handler.run();
-        verify(mainHandler, never()).postDelayed(any(Runnable.class), anyInt());
-    }
-
-    @Test
-    public void testPreFillHandlerPostsIfHasBitmapsToAllocateAfterRunning() {
-        PreFillType size = new PreFillType.Builder(1)
-                .setConfig(Bitmap.Config.ARGB_8888)
-                .build();
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, 2);
-        BitmapPreFillRunner handler = getHandler(allocationOrder);
-        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
-
-        handler.run();
-        verify(mainHandler).postDelayed(eq(handler), anyLong());
-    }
-
-    @Test
-    public void testPreFillHandlerPostsWithBackoffIfHasBitmapsToAllocateAfterRunning() {
-        PreFillType size = new PreFillType.Builder(1)
-                .setConfig(Bitmap.Config.ARGB_8888)
-                .build();
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, 100);
-
-        BitmapPreFillRunner handler = getHandler(allocationOrder);
-        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
-
-        handler.run();
-        verify(mainHandler).postDelayed(eq(handler), eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS));
-
-        when(clock.now()).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS).thenReturn(
-                BitmapPreFillRunner.MAX_DURATION_MS
-                        + BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO);
-
-        handler.run();
-
-        verify(mainHandler).postDelayed(eq(handler),
-                eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO));
-
-        when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
-        handler.run();
-        when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
-        handler.run();
-        when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
-        handler.run();
-        when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
-        handler.run();
-
-        verify(mainHandler, atLeastOnce()).postDelayed(eq(handler), eq(BitmapPreFillRunner.MAX_BACKOFF_MS));
-    }
-
-    @Test
-    public void testPreFillHandlerDoesNotPostIfHasBitmapsButIsCancelled() {
-        PreFillType size = new PreFillType.Builder(1)
-                .setConfig(Bitmap.Config.ARGB_8888)
-                .build();
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, 2);
-
-        BitmapPreFillRunner handler = getHandler(allocationOrder);
-        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
-        handler.cancel();
-        handler.run();
-
-        verify(mainHandler, never()).postDelayed(any(Runnable.class), anyLong());
-    }
-
-    @Test
-    public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));
-
-        PreFillType size = new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
-                .setConfig(bitmap.getConfig())
-                .build();
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, 1);
-
-        getHandler(allocationOrder).run();
-
-        verify(cache).put(any(Key.class), any(Resource.class));
-        verify(pool, never()).put(any(Bitmap.class));
-        assertThat(addedBitmaps).containsExactly(bitmap);
-    }
-
-    @Test
-    public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(cache.getMaxSize()).thenReturn(0);
-
-        PreFillType size = new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
-                .setConfig(bitmap.getConfig())
-                .build();
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, 1);
-
-        getHandler(allocationOrder).run();
-
-        verify(cache, never()).put(any(Key.class), any(Resource.class));
-        verify(pool).put(eq(bitmap));
-        assertThat(addedBitmaps).containsExactly(bitmap);
-    }
-
-    @Test
-    public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);
-
-        PreFillType size = new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
-                .setConfig(bitmap.getConfig())
-                .build();
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, 1);
-
-        getHandler(allocationOrder).run();
-
-        verify(cache, never()).put(any(Key.class), any(Resource.class));
-        verify(pool).put(eq(bitmap));
-        assertThat(addedBitmaps).containsExactly(bitmap);
-    }
-
-    @Test
-    public void testDoesAGetFromPoolBeforeAddingForEachSize() {
-        Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-        PreFillType firstSize = new PreFillType.Builder(first.getWidth(), first.getHeight())
-                .setConfig(first.getConfig())
-                .build();
-
-        Bitmap second = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
-        PreFillType secondSize = new PreFillType.Builder(second.getWidth(), second.getHeight())
-                .setConfig(second.getConfig())
-                .build();
-
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(firstSize, 1);
-        allocationOrder.put(secondSize, 1);
-
-        getHandler(allocationOrder).run();
-
-        InOrder firstOrder = inOrder(pool);
-        firstOrder.verify(pool).get(eq(first.getWidth()), eq(first.getHeight()), eq(first.getConfig()));
-        firstOrder.verify(pool).put(eq(first));
-
-        InOrder secondOrder = inOrder(pool);
-        secondOrder.verify(pool).get(eq(second.getWidth()), eq(second.getHeight()), eq(second.getConfig()));
-        secondOrder.verify(pool).put(eq(second));
-    }
-
-    @Test
-    public void testDoesNotGetMoreThanOncePerSize() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-        PreFillType size = new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
-                .setConfig(bitmap.getConfig())
-                .build();
-
-        final int numBitmaps = 5;
-        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
-        allocationOrder.put(size, numBitmaps);
-
-        getHandler(allocationOrder).run();
-
-        InOrder order = inOrder(pool);
-        order.verify(pool).get(eq(bitmap.getWidth()), eq(bitmap.getHeight()), eq(bitmap.getConfig()));
-        order.verify(pool, times(numBitmaps)).put(eq(bitmap));
-    }
-
-    private static class AddBitmapPoolAnswer implements Answer<Boolean> {
-        private List<Bitmap> bitmaps;
-
-        public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
-            this.bitmaps = bitmaps;
-        }
-
-        @Override
-        public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
-            Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
-            bitmaps.add(bitmap);
-            return null;
-        }
-    }
-
-    private static class AddBitmapCacheAnswer implements Answer<Resource<?>> {
-        private List<Bitmap> bitmaps;
-
-        public AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
-            this.bitmaps = bitmaps;
-        }
-
-        @Override
-        public Resource<?> answer(InvocationOnMock invocationOnMock) throws Throwable {
-            BitmapResource resource = (BitmapResource) invocationOnMock.getArguments()[1];
-            bitmaps.add(resource.get());
-            return null;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
deleted file mode 100644
index c502d13e9..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ /dev/null
@@ -1,314 +0,0 @@
-package com.bumptech.glide.load.engine.prefill;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.google.common.collect.Range;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.util.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.List;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BitmapPreFillerTest {
-    private static final int DEFAULT_BITMAP_WIDTH = 100;
-    private static final int DEFAULT_BITMAP_HEIGHT = 50;
-
-    private static final int BITMAPS_IN_POOL = 10;
-    private static final int BITMAPS_IN_CACHE = 10;
-
-    private final Bitmap.Config defaultBitmapConfig = PreFillType.DEFAULT_CONFIG;
-    private final Bitmap defaultBitmap =
-            Bitmap.createBitmap(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT, defaultBitmapConfig);
-    private final int defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
-    private final int poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
-    private final int cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
-
-    private BitmapPool pool;
-    private BitmapPreFiller bitmapPreFiller;
-    private MemoryCache cache;
-
-    @Before
-    public void setUp() {
-        pool = mock(BitmapPool.class);
-        when(pool.getMaxSize()).thenReturn(poolSize);
-        cache = mock(MemoryCache.class);
-        when(cache.getMaxSize()).thenReturn(cacheSize);
-
-        bitmapPreFiller = new BitmapPreFiller(cache, pool, DecodeFormat.DEFAULT);
-    }
-
-    @Test
-    public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillType[] {
-                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-                                .setConfig(defaultBitmapConfig)
-                                .build()
-                }
-        );
-
-        assertEquals(BITMAPS_IN_POOL + BITMAPS_IN_CACHE, allocationOrder.getSize());
-    }
-
-    @Test
-    public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
-        PreFillType[] sizes = new PreFillType[] {
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-                        .setConfig(defaultBitmapConfig)
-                        .build(),
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-                        .setConfig(defaultBitmapConfig)
-                        .build(),
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-                        .setConfig(defaultBitmapConfig)
-                        .build(),
-        };
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(sizes);
-
-        int byteSize = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillType current = allocationOrder.remove();
-            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-        }
-
-        int expectedSize = 0;
-        int maxSize = poolSize + cacheSize;
-        for (PreFillType current : sizes) {
-            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-            expectedSize += currentSize * (maxSize / (3 * currentSize));
-        }
-
-        assertEquals(expectedSize, byteSize);
-    }
-
-    @Test
-    public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillType[]{
-                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-                                .setConfig(defaultBitmapConfig)
-                                .build(),
-                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-                                .setConfig(defaultBitmapConfig)
-                                .build(),
-                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-                                .setConfig(defaultBitmapConfig)
-                                .build()
-                }
-        );
-
-        int byteSize = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillType current = allocationOrder.remove();
-            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-        }
-
-        assertThat(byteSize).isIn(Range.atMost(poolSize + cacheSize));
-    }
-
-    @Test
-    public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillType[]{
-                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-                                .setConfig(defaultBitmapConfig)
-                                .setWeight(4)
-                                .build(),
-                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-                                .setConfig(defaultBitmapConfig)
-                                .build(),
-                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
-                                .setConfig(defaultBitmapConfig)
-                                .setWeight(3)
-                                .build()
-                }
-        );
-
-        int byteSize = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillType current = allocationOrder.remove();
-            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-        }
-
-        assertThat(byteSize).isIn(Range.atMost(poolSize + cacheSize));
-    }
-
-    @Test
-    public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillType[] {
-                    new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-                            .setConfig(defaultBitmapConfig)
-                            .build()
-                }
-        );
-
-        while (!allocationOrder.isEmpty()) {
-            PreFillType size = allocationOrder.remove();
-            assertEquals(DEFAULT_BITMAP_WIDTH, size.getWidth());
-            assertEquals(DEFAULT_BITMAP_HEIGHT, size.getHeight());
-            assertEquals(defaultBitmapConfig, size.getConfig());
-        }
-    }
-
-    @Test
-    public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
-        PreFillType smallWidth = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-                .setConfig(defaultBitmapConfig)
-                .build();
-        PreFillType smallHeight =
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-                        .setConfig(defaultBitmapConfig)
-                        .build();
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillType[] { smallWidth, smallHeight, }
-        );
-
-        int numSmallWidth = 0, numSmallHeight = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillType current = allocationOrder.remove();
-            if (smallWidth.equals(current)) {
-                numSmallWidth++;
-            } else if (smallHeight.equals(current)) {
-                numSmallHeight++;
-            } else {
-                fail("Unexpected size, size: " + current);
-            }
-        }
-
-        assertEquals(numSmallWidth, numSmallHeight);
-    }
-
-    @Test
-    public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualWeights() {
-        PreFillType smallWidth =
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-                        .setConfig(defaultBitmapConfig)
-                        .build();
-        PreFillType normal =
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-                        .setConfig(defaultBitmapConfig)
-                        .build();
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillType[] { smallWidth, normal }
-        );
-
-        int numSmallWidth = 0, numNormal = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillType current = allocationOrder.remove();
-            if (smallWidth.equals(current)) {
-                numSmallWidth++;
-            } else if (normal.equals(current)) {
-                numNormal++;
-            } else {
-                fail("Unexpected size, size: " + current);
-            }
-        }
-
-        assertEquals(2 * numNormal, numSmallWidth);
-    }
-
-    @Test
-    public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequalWeights() {
-        PreFillType doubleWeight =
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-                        .setConfig(defaultBitmapConfig)
-                        .setWeight(2)
-                        .build();
-        PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-                .setConfig(defaultBitmapConfig)
-                .build();
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillType[] { doubleWeight, normal }
-        );
-
-        int numDoubleWeight = 0, numNormal = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillType current = allocationOrder.remove();
-            if (doubleWeight.equals(current)) {
-                numDoubleWeight++;
-            } else if (normal.equals(current)) {
-                numNormal++;
-            } else {
-                fail("Unexpected size, size: " + current);
-            }
-        }
-
-        assertEquals(2 * numNormal, numDoubleWeight);
-    }
-
-    @Test
-    public void testAllocationOrderRoundRobinsDifferentSizes() {
-        when(pool.getMaxSize()).thenReturn(defaultBitmapSize);
-        when(cache.getMaxSize()).thenReturn(defaultBitmapSize);
-        PreFillType smallWidth =
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-                        .setConfig(defaultBitmapConfig)
-                        .build();
-        PreFillType smallHeight =
-                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-                        .setConfig(defaultBitmapConfig)
-                        .build();
-
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillType[] { smallWidth, smallHeight, }
-        );
-
-        List<PreFillType> attributes = new ArrayList<PreFillType>();
-        while (!allocationOrder.isEmpty()) {
-            attributes.add(allocationOrder.remove());
-        }
-
-        // Either width, height, width, height or height, width, height, width.
-        try {
-            assertThat(attributes).containsExactly(smallWidth, smallHeight, smallWidth, smallHeight).inOrder();
-        } catch (AssertionError e) {
-            assertThat(attributes).containsExactly(smallHeight, smallWidth, smallHeight, smallWidth).inOrder();
-        }
-    }
-
-    @Test
-    public void testSetsConfigOnBuildersToDefaultIfNotSet() {
-        PreFillType.Builder builder = mock(PreFillType.Builder.class);
-        when(builder.build()).thenReturn(new PreFillType.Builder(100).setConfig(Bitmap.Config.RGB_565).build());
-
-        bitmapPreFiller.preFill(builder);
-
-        InOrder order = inOrder(builder);
-        order.verify(builder).setConfig(Bitmap.Config.RGB_565);
-        order.verify(builder).build();
-    }
-
-    @Test
-    public void testDoesNotSetConfigOnBuildersIfConfigIsAlreadySet() {
-        PreFillType.Builder builder = mock(PreFillType.Builder.class);
-
-        when(builder.getConfig()).thenReturn(Bitmap.Config.ARGB_4444);
-        when(builder.build()).thenReturn(new PreFillType.Builder(100).setConfig(Bitmap.Config.ARGB_4444).build());
-        bitmapPreFiller.preFill(builder);
-
-        verify(builder, never()).setConfig(any(Bitmap.Config.class));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
deleted file mode 100644
index 68a2a7798..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package com.bumptech.glide.load.engine.prefill;
-
-import static org.junit.Assert.assertEquals;
-
-import com.google.common.testing.EqualsTester;
-
-import android.graphics.Bitmap;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class PreFillTypeTest {
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfSizeIsZero() {
-        new PreFillType.Builder(0);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfWidthIsZero() {
-        new PreFillType.Builder(0, 100);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfHeightIsZero() {
-        new PreFillType.Builder(100, 0);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfWeightIsZero() {
-        new PreFillType.Builder(100).setWeight(0);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testConstructorThrowsIfConfigIsNull() {
-        new PreFillType(100, 100, null, 1);
-    }
-
-    @Test
-    public void testGetWidthReturnsGivenWidth() {
-        int width = 500;
-        assertEquals(width, new PreFillType(width, 100, Bitmap.Config.ARGB_4444, 1).getWidth());
-    }
-
-    @Test
-    public void testGetHeightReturnsGivenHeight() {
-        int height = 123;
-        assertEquals(height, new PreFillType(100, height, Bitmap.Config.ARGB_4444, 1).getHeight());
-    }
-
-    @Test
-    public void testGetConfigReturnsGivenConfig() {
-        Bitmap.Config config = Bitmap.Config.ARGB_8888;
-        assertEquals(config, new PreFillType(100, 100, config, 1).getConfig());
-    }
-
-    @Test
-    public void testGetWeightReturnsGivenWeight() {
-        int weight = 400;
-        assertEquals(weight, new PreFillType(100, 100, Bitmap.Config.ARGB_4444, weight).getWeight());
-    }
-
-    @Test
-    public void testEquality() {
-        new EqualsTester()
-                .addEqualityGroup(
-                        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1),
-                        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1))
-                .addEqualityGroup(
-                        new PreFillType(200, 100, Bitmap.Config.ARGB_4444, 1)
-                )
-                .addEqualityGroup(
-                        new PreFillType(100, 200, Bitmap.Config.ARGB_4444, 1)
-                )
-                .addEqualityGroup(
-                        new PreFillType(100, 100, Bitmap.Config.ARGB_8888, 1)
-                )
-                .addEqualityGroup(
-                        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 2)
-                )
-                .testEquals();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java
deleted file mode 100644
index e59511fdc..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GlideUrlTest {
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenURLIsNull() {
-        new GlideUrl((URL) null);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenStringUrlIsNull() {
-        new GlideUrl((String) null);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenStringURLIsEmpty() {
-        new GlideUrl("");
-    }
-
-    @Test
-    public void testCanCompareGlideUrlsCreatedWithDifferentTypes() throws MalformedURLException {
-        String stringUrl = "http://www.google.com";
-        URL url = new URL(stringUrl);
-
-        assertEquals(new GlideUrl(stringUrl), new GlideUrl(url));
-    }
-
-    @Test
-    public void testCanCompareHashcodeOfGlideUrlsCreatedWithDifferentTypes() throws MalformedURLException {
-        String stringUrl = "http://nytimes.com";
-        URL url = new URL(stringUrl);
-
-        assertEquals(new GlideUrl(stringUrl).hashCode(), new GlideUrl(url).hashCode());
-    }
-
-    @Test
-    public void testProducesEquivalentUrlFromString() throws MalformedURLException {
-        String stringUrl = "http://www.google.com";
-        GlideUrl glideUrl = new GlideUrl(stringUrl);
-
-        URL url = glideUrl.toURL();
-        assertEquals(stringUrl, url.toString());
-    }
-
-    @Test
-    public void testProducesEquivalentStringFromURL() throws MalformedURLException {
-        String expected = "http://www.washingtonpost.com";
-        URL url = new URL(expected);
-        GlideUrl glideUrl = new GlideUrl(url);
-
-        assertEquals(expected, glideUrl.toString());
-    }
-
-    @Test
-    public void testIssue133() throws MalformedURLException {
-        // u00e0=à
-        final String original =  "http://www.commitstrip.com/wp-content/uploads/2014/07/"
-                + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";
-
-        final String escaped = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
-                + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";
-
-        GlideUrl glideUrlFromString = new GlideUrl(original);
-        assertEquals(escaped, glideUrlFromString.toURL().toString());
-
-        GlideUrl glideUrlFromEscapedString = new GlideUrl(escaped);
-        assertEquals(escaped, glideUrlFromEscapedString.toURL().toString());
-
-        GlideUrl glideUrlFromUrl = new GlideUrl(new URL(original));
-        assertEquals(escaped, glideUrlFromUrl.toURL().toString());
-
-        GlideUrl glideUrlFromEscapedUrl = new GlideUrl(new URL(escaped));
-        assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java
deleted file mode 100644
index bf846be10..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java
+++ /dev/null
@@ -1,270 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.data.DataFetcher;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ImageVideoModelLoaderTest {
-    private ImageVideoLoaderHarness harness;
-
-    @Before
-    public void setUp() {
-        harness =  new ImageVideoLoaderHarness();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfStreamLoaderAndFileDescriptorLoaderAreNull() {
-        harness.streamModelLoader = null;
-        harness.fileDescriptorModelLoader = null;
-
-        harness.getLoader();
-    }
-
-    @Test
-    public void testIdIsStreamOrFetcherId() {
-        Object model = new Object();
-        String expected = "stream";
-        when(harness.streamFetcher.getId()).thenReturn(expected);
-        when(harness.fileDescriptorFetcher.getId()).thenReturn(expected);
-
-        String id = harness.getLoader().getResourceFetcher(model, 1, 2).getId();
-
-        assertEquals(expected, id);
-    }
-
-    @Test
-    public void testReturnsFileDescriptorIdIfStreamFetcherNull() {
-        Object model = new Object();
-        String expected = "fakeId";
-        when(harness.fileDescriptorFetcher.getId()).thenReturn(expected);
-        harness.streamModelLoader = null;
-
-        String id = harness.getLoader().getResourceFetcher(model, 1, 2).getId();
-
-        assertEquals(expected, id);
-    }
-
-    @Test
-    public void testReturnsStreamFetcherIdIfFileDescriptorFetcherNull() {
-        Object model = new Object();
-        String expected = "fakeId";
-        when(harness.streamFetcher.getId()).thenReturn(expected);
-        harness.fileDescriptorModelLoader = null;
-
-        String id = harness.getLoader().getResourceFetcher(model, 1, 2).getId();
-
-        assertEquals(expected, id);
-    }
-
-    @Test
-    public void testReturnsImageVideoWrapperWithFetchers() throws Exception {
-        InputStream stream = new ByteArrayInputStream(new byte[0]);
-        ParcelFileDescriptor fileDescriptor = mock(ParcelFileDescriptor.class);
-
-        when(harness.streamFetcher.loadData(any(Priority.class))).thenReturn(stream);
-        when(harness.streamModelLoader
-                .getResourceFetcher(any(Uri.class), anyInt(), anyInt()))
-                .thenReturn(harness.streamFetcher);
-        when(harness.fileDescriptorFetcher.loadData(any(Priority.class))).thenReturn(fileDescriptor);
-        when(harness.fileDescriptorModelLoader
-                .getResourceFetcher(any(Uri.class), anyInt(), anyInt()))
-                .thenReturn(harness.fileDescriptorFetcher);
-
-        ImageVideoWrapper wrapper = harness.getLoader()
-                .getResourceFetcher(new Object(), 100, 100)
-                .loadData(Priority.LOW);
-
-        assertEquals(stream, wrapper.getStream());
-        assertEquals(fileDescriptor, wrapper.getFileDescriptor());
-    }
-
-    @Test
-    public void testHandlesNullStreamModelLoaderInGetResourceFetcher() {
-        harness.streamModelLoader = null;
-
-        assertNotNull(harness.getLoader().getResourceFetcher(new Object(), 100, 100));
-    }
-
-    @Test
-    public void testHandlesNullFileDescriptorModelLoaderInGetResourceFetcher() {
-        harness.fileDescriptorFetcher = null;
-
-        assertNotNull(harness.getLoader().getResourceFetcher(new Object(), 100, 100));
-    }
-
-    @Test
-    public void testFetcherHandlesNullStreamFetcherInCleanup() {
-        harness.streamFetcher = null;
-
-        harness.getFetcher().cleanup();
-    }
-
-    @Test
-    public void testFetcherHandlesNullStreamFetcherInCancel() {
-        harness.streamFetcher = null;
-
-        harness.getFetcher().cancel();
-    }
-
-    @Test
-    public void testFetcherHandlesNullStreamFetcherInLoadResource() throws Exception {
-        harness.streamFetcher = null;
-
-        assertNotNull(harness.getFetcher().loadData(Priority.NORMAL));
-    }
-
-    @Test
-    public void testFetcherHandlesNullFileDescriptorFetcherInCleanup() {
-        harness.fileDescriptorFetcher = null;
-
-        harness.getFetcher().cleanup();
-    }
-
-    @Test
-    public void testFetcherHandlesNullFileDescriptorInCancel() {
-        harness.fileDescriptorFetcher = null;
-
-        harness.getFetcher().cancel();
-    }
-
-    @Test
-    public void testFetcherHandlesNullFileDesciprtorInLoadResource() throws Exception {
-        harness.fileDescriptorFetcher = null;
-
-        assertNotNull(harness.getFetcher().loadData(Priority.NORMAL));
-    }
-
-    @Test
-    public void testFetcherHandlesExceptionInStreamFetcher() throws Exception {
-        when(harness.streamFetcher.loadData(any(Priority.class)))
-                .thenThrow(new IOException("test"));
-
-        assertNotNull(harness.getFetcher().loadData(Priority.NORMAL));
-    }
-
-    @Test
-    public void testFetcherHandlesExceptionInFileDescriptorFetcher() throws Exception {
-        when(harness.streamFetcher.loadData(any(Priority.class)))
-                .thenReturn(new ByteArrayInputStream(new byte[0]));
-        when(harness.fileDescriptorFetcher
-                .loadData(any(Priority.class)))
-                .thenThrow(new IOException("test"));
-
-        assertNotNull(harness.getFetcher().loadData(Priority.LOW));
-    }
-
-    @Test
-    public void testReturnsNullFetcherIfBothStreamAndFileDescriptorLoadersReturnNullFetchers() throws Exception {
-        when(harness.streamModelLoader.getResourceFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);
-        when(harness.fileDescriptorModelLoader.getResourceFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);
-
-        assertNull(harness.getLoader().getResourceFetcher(new Object(), 100, 100));
-    }
-
-    @Test
-    public void testReturnsNullFetcherIfStreamModelLoaderIsNullAndFileModelLoaderReturnsNullFetcher() throws Exception {
-        harness.streamModelLoader = null;
-        when(harness.fileDescriptorModelLoader.getResourceFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);
-
-        assertNull(harness.getLoader().getResourceFetcher(new Object(), 100, 100));
-    }
-
-    @Test
-    public void testReturnsNullFetcherIfFileDescriptorModelLoaderIsNullAndStreamModelLoaderReturnsNullFetcher()
-            throws Exception {
-        harness.fileDescriptorModelLoader = null;
-        when(harness.streamModelLoader.getResourceFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);
-
-        assertNull(harness.getLoader().getResourceFetcher(new Object(), 100, 100));
-    }
-
-    @Test(expected = IOException.class)
-    public void testFetcherThrowsIfBothFileDescriptorAndStreamFetchersThrows() throws Exception {
-        when(harness.fileDescriptorFetcher.loadData(any(Priority.class)))
-                .thenThrow(new IOException("test"));
-        when(harness.streamFetcher.loadData(any(Priority.class)))
-                .thenThrow(new IOException("test"));
-
-        harness.getFetcher().loadData(Priority.LOW);
-    }
-
-    @Test(expected = IOException.class)
-    public void testFetcherThrowsIfStreamFetcherIsNullAndFileDescriptorThrows() throws Exception {
-        harness.streamFetcher = null;
-        when(harness.fileDescriptorFetcher.loadData(any(Priority.class)))
-                .thenThrow(new IOException("test"));
-
-        harness.getFetcher().loadData(Priority.LOW);
-    }
-
-    @Test(expected = IOException.class)
-    public void testFetcherThrowsIfFileDescriptorFetcherIsNullAndStreamLoaderThrows() throws Exception {
-        harness.fileDescriptorFetcher = null;
-        when(harness.streamFetcher.loadData(any(Priority.class)))
-                .thenThrow(new IOException("test"));
-
-        harness.getFetcher().loadData(Priority.LOW);
-    }
-
-    @Test
-    public void testReturnsDifferentIdsForDifferentObjects() {
-        Object first = new Object();
-        String firstStreamId = "firstStream";
-        when(harness.streamFetcher.getId()).thenReturn(firstStreamId);
-
-        String firstId = harness.getLoader().getResourceFetcher(first, 1, 2).getId();
-        assertEquals(firstStreamId, firstId);
-
-        Object second = new Object();
-        String secondFileDescriptorId = "secondStream";
-        when(harness.streamFetcher.getId()).thenReturn(secondFileDescriptorId);
-
-        String secondId = harness.getLoader().getResourceFetcher(second, 1, 2).getId();
-        assertEquals(secondFileDescriptorId, secondId);
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class ImageVideoLoaderHarness {
-        ModelLoader<Object, InputStream> streamModelLoader = mock(ModelLoader.class);
-        ModelLoader<Object, ParcelFileDescriptor> fileDescriptorModelLoader = mock(ModelLoader.class);
-        DataFetcher<InputStream> streamFetcher = mock(DataFetcher.class);
-        DataFetcher<ParcelFileDescriptor> fileDescriptorFetcher = mock(DataFetcher.class);
-
-        public ImageVideoLoaderHarness() {
-            when(streamModelLoader.getResourceFetcher(anyObject(), anyInt(), anyInt())).thenReturn(streamFetcher);
-            when(fileDescriptorModelLoader.getResourceFetcher(anyObject(), anyInt(), anyInt()))
-                    .thenReturn(fileDescriptorFetcher);
-        }
-
-        private ImageVideoModelLoader<Object> getLoader() {
-            return new ImageVideoModelLoader<Object>(streamModelLoader, fileDescriptorModelLoader);
-        }
-
-        private ImageVideoModelLoader.ImageVideoFetcher getFetcher() {
-            return new ImageVideoModelLoader.ImageVideoFetcher(streamFetcher, fileDescriptorFetcher);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoderTest.java
deleted file mode 100644
index 8ec4828c3..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoderTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.Encoder;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileDescriptor;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ImageVideoWrapperEncoderTest {
-    private Encoder<InputStream> streamEncoder;
-    private Encoder<ParcelFileDescriptor> fileDescriptorEncoder;
-    private ImageVideoWrapperEncoder encoder;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        streamEncoder = mock(Encoder.class);
-        fileDescriptorEncoder = mock(Encoder.class);
-        encoder = new ImageVideoWrapperEncoder(streamEncoder, fileDescriptorEncoder);
-    }
-
-    @Test
-    public void testReturnsIdOfStreamAndFileDescriptorEncoders() {
-        String streamId = "streamId";
-        when(streamEncoder.getId()).thenReturn(streamId);
-        String fileId = "fileId";
-        when(fileDescriptorEncoder.getId()).thenReturn(fileId);
-
-        String id = encoder.getId();
-
-        assertThat(id).contains(streamId);
-        assertThat(id).contains(fileId);
-    }
-
-    @Test
-    public void testEncodesWithStreamEncoderIfInputStreamIsNotNull() {
-        InputStream expected = new ByteArrayInputStream(new byte[2]);
-        ImageVideoWrapper data = mock(ImageVideoWrapper.class);
-        when(data.getStream()).thenReturn(expected);
-
-        OutputStream os = new ByteArrayOutputStream();
-        when(streamEncoder.encode(eq(expected), eq(os))).thenReturn(true);
-        assertTrue(encoder.encode(data, os));
-
-        verify(streamEncoder).encode(eq(expected), eq(os));
-    }
-
-    @Test
-    public void testEncodesWithFileDescriptorEncoderIfFileDescriptorIsNotNullAndStreamIs() throws IOException {
-        ParcelFileDescriptor expected = ParcelFileDescriptor.dup(FileDescriptor.err);
-        ImageVideoWrapper data = mock(ImageVideoWrapper.class);
-        when(data.getStream()).thenReturn(null);
-        when(data.getFileDescriptor()).thenReturn(expected);
-
-        OutputStream os = new ByteArrayOutputStream();
-        when(fileDescriptorEncoder.encode(eq(expected), eq(os))).thenReturn(true);
-        assertTrue(encoder.encode(data, os));
-
-        verify(fileDescriptorEncoder).encode(eq(expected), eq(os));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/ModelCacheTest.java
deleted file mode 100644
index f9d461d07..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/ModelCacheTest.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import static org.junit.Assert.assertEquals;
-
-import com.google.common.testing.EqualsTester;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ModelCacheTest {
-
-    private ModelCache<Object, Object> cache;
-
-    @Before
-    public void setUp() {
-        cache = new ModelCache<Object, Object>(10);
-    }
-
-    @Test
-    public void testModelKeyEquivalence() {
-        new EqualsTester()
-                .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 200), ModelCache.ModelKey.get(14f, 100, 200))
-                .addEqualityGroup(ModelCache.ModelKey.get(13f, 100, 200))
-                .addEqualityGroup(ModelCache.ModelKey.get(14f, 200, 200))
-                .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 300))
-                .testEquals();
-    }
-
-    @Test
-    public void testCanSetAndGetModel() {
-        Object model = new Object();
-        int width = 10;
-        int height = 20;
-        Object result = new Object();
-        cache.put(model, width, height, result);
-        assertEquals(result, cache.get(model, width, height));
-    }
-
-    @Test
-    public void testCanSetAndGetMultipleResultsWithDifferentDimensionsForSameObject() {
-        Object model = new Object();
-        int firstWidth = 10, firstHeight = 20;
-        Object firstResult = new Object();
-        int secondWidth = 30, secondHeight = 40;
-        Object secondResult = new Object();
-
-        cache.put(model, firstWidth, firstHeight, firstResult);
-        cache.put(model, secondWidth, secondHeight, secondResult);
-
-        assertEquals(firstResult, cache.get(model, firstWidth, firstHeight));
-        assertEquals(secondResult, cache.get(model, secondWidth, secondHeight));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/StreamEncoderTest.java
deleted file mode 100644
index 67b1964eb..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class StreamEncoderTest {
-    private StreamEncoder encoder;
-
-    @Before
-    public void setUp() {
-        encoder = new StreamEncoder();
-    }
-
-    @Test
-    public void testReturnsEmptyId() {
-        assertEquals("", encoder.getId());
-    }
-
-    @Test
-    public void testWritesDataFromInputStreamToOutputStream() {
-        String fakeData = "SomeRandomFakeData";
-        ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes());
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        encoder.encode(is, os);
-
-        assertEquals(fakeData, new String(os.toByteArray()));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
deleted file mode 100644
index 43bc966f1..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
+++ /dev/null
@@ -1,136 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.load.model.ModelCache;
-import com.bumptech.glide.load.model.ModelLoader;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BaseGlideUrlLoaderTest {
-
-    private ModelCache<Object, GlideUrl> modelCache;
-    private ModelLoader<GlideUrl, InputStream> wrapped;
-    private TestLoader urlLoader;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        modelCache = mock(ModelCache.class);
-        wrapped = mock(ModelLoader.class);
-        urlLoader = new TestLoader(wrapped, modelCache);
-    }
-
-    @Test
-    public void testReturnsNullIfUrlIsNull() {
-        urlLoader.resultUrl = null;
-        assertNull(urlLoader.getResourceFetcher(new Object(), 100, 100));
-    }
-
-    @Test
-    public void testReturnsNullIfUrlIsEmpty() {
-        urlLoader.resultUrl = "    ";
-        assertNull(urlLoader.getResourceFetcher(new Object(), 100, 100));
-    }
-
-    @Test
-    public void testReturnsUrlFromCacheIfPresent() {
-        Object model = new Object();
-        int width = 100;
-        int height = 200;
-        GlideUrl expectedUrl = mock(GlideUrl.class);
-        when(modelCache.get(eq(model), eq(width), eq(height))).thenReturn(expectedUrl);
-        DataFetcher<InputStream> expectedFetcher = mock(DataFetcher.class);
-
-        when(wrapped.getResourceFetcher(eq(expectedUrl), eq(width), eq(height))).thenReturn(expectedFetcher);
-
-        assertEquals(expectedFetcher, urlLoader.getResourceFetcher(model, width, height));
-    }
-
-    @Test
-    public void testBuildsNewUrlIfNotPresentInCache() {
-        int width = 10;
-        int height = 11;
-
-        urlLoader.resultUrl = "fakeUrl";
-        final DataFetcher<InputStream> expected = mock(DataFetcher.class);
-        when(wrapped.getResourceFetcher(any(GlideUrl.class), eq(width), eq(height))).thenAnswer(
-                new Answer<DataFetcher<InputStream>>() {
-                    @Override
-                    public DataFetcher<InputStream> answer(InvocationOnMock invocationOnMock) throws Throwable {
-                        GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
-                        assertEquals(urlLoader.resultUrl, glideUrl.toString());
-                        return expected;
-
-                    }
-                });
-        assertEquals(expected, urlLoader.getResourceFetcher(new Object(), width, height));
-    }
-
-    @Test
-    public void testAddsNewUrlToCacheIfNotPresentInCache() {
-        urlLoader.resultUrl = "fakeUrl";
-        Object model = new Object();
-        int width = 400;
-        int height = 500;
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
-                assertEquals(urlLoader.resultUrl, glideUrl.toString());
-                return null;
-            }
-        }).when(modelCache).put(eq(model), eq(width), eq(height), any(GlideUrl.class));
-
-        urlLoader.getResourceFetcher(model, width, height);
-
-        verify(modelCache).put(eq(model), eq(width), eq(height), any(GlideUrl.class));
-    }
-
-    @Test
-    public void testDoesNotInteractWithModelCacheIfNull() {
-        TestLoader urlLoader = new TestLoader(wrapped, null);
-        urlLoader.resultUrl = "fakeUrl";
-
-        int width = 456;
-        int height = 789;
-
-        DataFetcher<InputStream> expected = mock(DataFetcher.class);
-        when(wrapped.getResourceFetcher(any(GlideUrl.class), eq(width), eq(height))).thenReturn(expected);
-
-        assertEquals(expected, urlLoader.getResourceFetcher(new Object(), width, height));
-    }
-
-    private class TestLoader extends BaseGlideUrlLoader<Object> {
-        public String resultUrl;
-
-        public TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader, ModelCache<Object, GlideUrl> modelCache) {
-            super(concreteLoader, modelCache);
-        }
-
-        @Override
-        protected String getUrl(Object model, int width, int height) {
-            return resultUrl;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoaderTest.java
deleted file mode 100644
index 9a6502cf2..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoaderTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.data.HttpUrlFetcher;
-import com.bumptech.glide.load.model.GlideUrl;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.InputStream;
-
-@RunWith(JUnit4.class)
-public class HttpUrlGlideUrlLoaderTest {
-    private HttpUrlGlideUrlLoader loader;
-    private GlideUrl model;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        loader = new HttpUrlGlideUrlLoader();
-        model = mock(GlideUrl.class);
-    }
-    @Test
-    public void testReturnsValidFetcher() {
-        DataFetcher<InputStream> result = loader.getResourceFetcher(model, 100, 100);
-        assertThat(result).isInstanceOf(HttpUrlFetcher.class);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoaderTest.java
deleted file mode 100644
index 90bfe6c52..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoaderTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import android.net.Uri;
-
-import com.bumptech.glide.load.model.ModelLoader;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class MediaStoreStreamLoaderTest {
-
-    @Test
-    public void testRetrievesFetcherFromWrappedUriLoader() {
-        Uri uri = Uri.parse("content://fake");
-        int width = 123;
-        int height = 456;
-        String mimeType = "video/";
-        ModelLoader<Uri, InputStream> wrapped = mock(ModelLoader.class);
-        MediaStoreStreamLoader loader = new MediaStoreStreamLoader(Robolectric.application, wrapped);
-
-        loader.getResourceFetcher(uri, width, height);
-        verify(wrapped).getResourceFetcher(eq(uri), eq(width), eq(height));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java
deleted file mode 100644
index 178514464..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.net.Uri;
-
-import com.bumptech.glide.load.model.ModelLoader;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.InputStream;
-
-/**
- * Tests for the {@link StreamResourceLoader} class.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ResourceLoaderTest {
-
-    @Test
-    public void testCanHandleId() {
-        ModelLoader<Uri, InputStream> streamUriLoader = mock(ModelLoader.class);
-        when(streamUriLoader.getResourceFetcher(any(Uri.class), anyInt(), anyInt())).thenReturn(null);
-
-        int id = android.R.drawable.star_off;
-
-        StreamResourceLoader resourceLoader = new StreamResourceLoader(Robolectric.application, streamUriLoader);
-        resourceLoader.getResourceFetcher(id, 0, 0);
-
-        Uri contentUri = Uri.parse("android.resource://android/drawable/star_off");
-        verify(streamUriLoader, atLeastOnce()).getResourceFetcher(eq(contentUri), anyInt(), anyInt());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoaderTest.java
deleted file mode 100644
index ef7119043..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoaderTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
-import com.bumptech.glide.load.data.DataFetcher;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.InputStream;
-
-@RunWith(JUnit4.class)
-public class StreamByteArrayLoaderTest {
-
-    @Test
-    public void testCanHandleByteArray() {
-        StreamByteArrayLoader loader = new StreamByteArrayLoader();
-
-        byte[] data = new byte[10];
-        DataFetcher<InputStream> fetcher = loader.getResourceFetcher(data, -1, -1);
-        assertNotNull(fetcher);
-    }
-
-    @Test
-    public void testFetcherReturnsGivenId() {
-        String id = "testId";
-        StreamByteArrayLoader loader = new StreamByteArrayLoader(id);
-
-        assertEquals(id, loader.getResourceFetcher(new byte[0], 1, 1).getId());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java
deleted file mode 100644
index 64eda71c4..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import android.net.Uri;
-
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Tests for the {@link StreamStringLoader} class.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class StringLoaderTest {
-    // Not a magic number, just an arbitrary non zero value.
-    private static final int IMAGE_SIDE = 100;
-
-    private StreamStringLoader stringLoader;
-    private ModelLoader<Uri, InputStream> uriLoader;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() throws Exception {
-        uriLoader = mock(ModelLoader.class);
-        stringLoader = new StreamStringLoader(uriLoader);
-    }
-
-    @Test
-    public void testHandlesPaths() throws IOException {
-        // TODO on windows it will fail with schema being the drive letter (C:\... -> C)
-        assumeTrue(!Util.isWindows());
-        File f = Robolectric.application.getCacheDir();
-        stringLoader.getResourceFetcher(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE);
-
-        verify(uriLoader).getResourceFetcher(eq(Uri.fromFile(f)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-
-    @Test
-    public void testCanHandleComplexFilePaths() {
-        assumeTrue(!Util.isWindows());
-        String testPath = "/storage/emulated/0/DCIM/Camera/IMG_20140520_100001:nopm:.jpg,mimeType=image/jpeg,"
-                + "2448x3264,orientation=0,date=Tue";
-        stringLoader.getResourceFetcher(testPath, IMAGE_SIDE, IMAGE_SIDE);
-
-        Uri expected = Uri.fromFile(new File(testPath));
-        verify(uriLoader).getResourceFetcher(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-
-    @Test
-    public void testHandlesFileUris() throws IOException {
-        File f = Robolectric.application.getCacheDir();
-        stringLoader.getResourceFetcher(Uri.fromFile(f)
-                .toString(), IMAGE_SIDE, IMAGE_SIDE);
-
-        verify(uriLoader).getResourceFetcher(eq(Uri.fromFile(f)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-
-    @Test
-    public void testHandlesResourceUris() throws IOException {
-        Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-        stringLoader.getResourceFetcher(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE);
-
-        verify(uriLoader).getResourceFetcher(eq(resourceUri), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-
-    @Test
-    public void testHandlesHttp() {
-        String url = "http://www.google.com";
-        stringLoader.getResourceFetcher(url, IMAGE_SIDE, IMAGE_SIDE);
-
-        verify(uriLoader).getResourceFetcher(eq(Uri.parse(url)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-
-    @Test
-    public void testHandlesHttps() {
-        String url = "https://www.google.com";
-        stringLoader.getResourceFetcher(url, IMAGE_SIDE, IMAGE_SIDE);
-
-        verify(uriLoader).getResourceFetcher(eq(Uri.parse(url)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-
-    @Test
-    public void testHandlesContent() {
-        String content = "content://com.bumptech.glide";
-        stringLoader.getResourceFetcher(content, IMAGE_SIDE, IMAGE_SIDE);
-
-        verify(uriLoader).getResourceFetcher(eq(Uri.parse(content)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java
deleted file mode 100644
index 6abdf322a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.UriLoader;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-
-/**
- * Tests for the {@link StreamUriLoader} class.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class UriLoaderTest {
-    // Not a magic number, just arbitrary non zero.
-    private static final int IMAGE_SIDE = 120;
-
-    private UriLoader loader;
-    private DataFetcher<InputStream> localUriFetcher;
-    private ModelLoader<GlideUrl, InputStream> urlLoader;
-    private DataFetcher<InputStream> assetUriFetcher;
-
-    @SuppressWarnings("uncecked")
-    @Before
-    public void setUp() throws Exception {
-        urlLoader = mock(ModelLoader.class);
-        localUriFetcher = mock(DataFetcher.class);
-        assetUriFetcher = mock(DataFetcher.class);
-
-        loader = new UriLoader<InputStream>(Robolectric.application, urlLoader) {
-            @Override
-            protected DataFetcher<InputStream> getLocalUriFetcher(Context context, Uri uri) {
-                return localUriFetcher;
-            }
-
-            @Override
-            protected DataFetcher<InputStream> getAssetPathFetcher(Context context, String path) {
-                return assetUriFetcher;
-            }
-        };
-    }
-
-    @Test
-    public void testHandlesFileUris() throws IOException {
-        Uri fileUri = Uri.fromFile(new File("f"));
-        DataFetcher dataFetcher = loader.getResourceFetcher(fileUri, IMAGE_SIDE, IMAGE_SIDE);
-        assertEquals(localUriFetcher, dataFetcher);
-    }
-
-    @Test
-    public void testHandlesResourceUris() throws IOException {
-        Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-        DataFetcher dataFetcher = loader.getResourceFetcher(resourceUri, IMAGE_SIDE, IMAGE_SIDE);
-        assertEquals(localUriFetcher, dataFetcher);
-    }
-
-    @Test
-    public void testHandlesContentUris() {
-        Uri contentUri = Uri.parse("content://com.bumptech.glide");
-        DataFetcher dataFetcher = loader.getResourceFetcher(contentUri, IMAGE_SIDE, IMAGE_SIDE);
-        assertEquals(localUriFetcher, dataFetcher);
-    }
-
-    @Test
-    public void testHandlesAssetUris() {
-        Uri assetUri = Uri.parse("file:///android_asset/assetName");
-        DataFetcher fetcher = loader.getResourceFetcher(assetUri, IMAGE_SIDE, IMAGE_SIDE);
-        assertEquals(assetUriFetcher, fetcher);
-    }
-
-    @Test
-    public void testHandlesHttpUris() throws MalformedURLException {
-        Uri httpUri = Uri.parse("http://www.google.com");
-        loader.getResourceFetcher(httpUri, IMAGE_SIDE, IMAGE_SIDE);
-
-        verify(urlLoader).getResourceFetcher(eq(new GlideUrl(httpUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-
-    @Test
-    public void testHandlesHttpsUris() throws MalformedURLException {
-        Uri httpsUri = Uri.parse("https://www.google.com");
-        loader.getResourceFetcher(httpsUri, IMAGE_SIDE, IMAGE_SIDE);
-
-        verify(urlLoader).getResourceFetcher(eq(new GlideUrl(httpsUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
-    }
-
-    // Test for https://github.com/bumptech/glide/issues/71.
-    @Test
-    public void testHandlesMostlyInvalidHttpUris() {
-        Uri mostlyInvalidHttpUri =
-                Uri.parse("http://myserver_url.com:80http://myserver_url.com/webapp/images/no_image.png?size=100");
-
-        loader.getResourceFetcher(mostlyInvalidHttpUri, IMAGE_SIDE, IMAGE_SIDE);
-        verify(urlLoader).getResourceFetcher(eq(new GlideUrl(mostlyInvalidHttpUri.toString())), eq(IMAGE_SIDE),
-                eq(IMAGE_SIDE));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/NullDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/NullDecoderTest.java
deleted file mode 100644
index 0621fd178..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/NullDecoderTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package com.bumptech.glide.load.resource;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
-@RunWith(JUnit4.class)
-public class NullDecoderTest {
-    private NullDecoder decoder;
-
-    @Before
-    public void setUp() {
-        decoder = new NullDecoder();
-    }
-
-    //TODO: do we really want an empty id here?
-    @Test
-    public void testHasValidId() {
-        assertEquals("", decoder.getId());
-    }
-
-    @Test
-    public void testReturnsNull() throws IOException {
-        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/NullResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/NullResourceEncoderTest.java
deleted file mode 100644
index fa19bf32d..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/NullResourceEncoderTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.load.resource;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.ByteArrayOutputStream;
-
-@RunWith(JUnit4.class)
-public class NullResourceEncoderTest {
-
-    @Test
-    public void testEncode() throws Exception {
-        NullResourceEncoder nullResourceEncoder = new NullResourceEncoder();
-        Resource resource = mock(Resource.class);
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-
-        nullResourceEncoder.encode(resource, os);
-
-        assertEquals(0, os.toByteArray().length);
-    }
-
-    @Test
-    public void testReturnsFalseFromEncode() {
-        NullResourceEncoder nullResourceEncoder = new NullResourceEncoder();
-
-        assertFalse(nullResourceEncoder.encode(mock(Resource.class), new ByteArrayOutputStream()));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
deleted file mode 100644
index ea001a5c2..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.bumptech.glide.load.resource;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class SimpleResourceTest {
-    private Anything object;
-    private SimpleResource resource;
-
-    @Before
-    public void setUp() {
-        object = new Anything();
-        resource = new SimpleResource(object);
-    }
-
-    @Test
-    public void testReturnsGivenObject() {
-        assertEquals(object, resource.get());
-    }
-
-    @Test
-    public void testReturnsGivenObjectMultipleTimes() {
-        assertEquals(object, resource.get());
-        assertEquals(object, resource.get());
-        assertEquals(object, resource.get());
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfGivenNullData() {
-        new SimpleResource<Object>(null);
-    }
-
-    private static class Anything { }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
deleted file mode 100644
index d0cb9f4f1..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.bumptech.glide.load.resource;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class UnitTransformationTest {
-
-    @Test
-    public void testReturnsGivenResource() {
-        Resource resource = mock(Resource.class);
-        UnitTransformation transformation = UnitTransformation.get();
-        assertEquals(resource, transformation.transform(resource, 10, 10));
-    }
-
-    @Test
-    public void testHasEmptyId() {
-        assertEquals("", UnitTransformation.get().getId());
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
deleted file mode 100644
index e849807b5..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BitmapDrawableResourceTest {
-    private BitmapDrawableResourceHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new BitmapDrawableResourceHarness();
-    }
-
-    @Test
-    public void testReturnsGivenBitmapFromGet() {
-        assertEquals(harness.bitmap, harness.create().get().getBitmap());
-    }
-
-
-    @Test
-    public void testReturnsDifferentDrawableEachTime() {
-        BitmapDrawableResource resource = harness.create();
-        BitmapDrawable first = resource.get();
-        BitmapDrawable second = resource.get();
-
-        assertNotSame(first, second);
-    }
-
-    @Test
-    public void testReturnsSizeFromGivenBitmap() {
-        assertEquals(harness.bitmap.getHeight() * harness.bitmap.getRowBytes(), harness.create().getSize());
-    }
-
-    @Test
-    public void testBitmapIsReturnedToPoolOnRecycle() {
-        harness.create().recycle();
-
-        verify(harness.bitmapPool).put(eq(harness.bitmap));
-    }
-
-    private static class BitmapDrawableResourceHarness {
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        public BitmapDrawableResource create() {
-            return new BitmapDrawableResource(new BitmapDrawable(Robolectric.application.getResources(), bitmap),
-                    bitmapPool);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
deleted file mode 100644
index 6d9f3e29b..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.bumptech.glide.tests.Util.assertClassHasValidId;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-import java.io.ByteArrayOutputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { BitmapEncoderTest.AlphaShadowBitmap.class })
-public class BitmapEncoderTest {
-    private EncoderHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new EncoderHarness();
-    }
-
-    @Test
-    public void testBitmapIsEncoded() {
-        String fakeBytes = harness.encode();
-
-        assertContains(fakeBytes, Robolectric.shadowOf(harness.bitmap)
-                .getDescription());
-    }
-
-    @Test
-    public void testBitmapIsEncodedWithGivenQuality() {
-        harness.quality = 7;
-
-        String fakeBytes = harness.encode();
-
-        assertContains(fakeBytes, String.valueOf(harness.quality));
-    }
-
-    @Test
-    public void testEncoderObeysNonNullCompressFormat() {
-        harness.compressFormat = Bitmap.CompressFormat.WEBP;
-
-        String fakeBytes = harness.encode();
-
-        assertContains(fakeBytes, harness.compressFormat.toString());
-    }
-
-    @Test
-    public void testEncoderEncodesJpegWithNullFormatAndBitmapWithoutAlpha() {
-        harness.compressFormat = null;
-        harness.bitmap.setHasAlpha(false);
-
-        String fakeBytes = harness.encode();
-
-        assertContains(fakeBytes, Bitmap.CompressFormat.JPEG.toString());
-    }
-
-    @Test
-    public void testEncoderEncodesPngWithNullFormatAndBitmapWithAlpha() {
-        harness.compressFormat = null;
-        harness.bitmap.setHasAlpha(true);
-
-        String fakeBytes = harness.encode();
-
-        assertContains(fakeBytes, Bitmap.CompressFormat.PNG.toString());
-    }
-
-    @Test
-    public void testReturnsTrueFromWrite() {
-        BitmapEncoder encoder = new BitmapEncoder(harness.compressFormat, harness.quality);
-        assertTrue(encoder.encode(harness.resource, harness.os));
-    }
-
-    @Test
-    public void testReturnsValidId() {
-        assertClassHasValidId(BitmapEncoder.class,
-                new BitmapEncoder(harness.compressFormat, harness.quality).getId());
-    }
-
-    private static void assertContains(String string, String expected) {
-        assertThat(string).contains(expected);
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class EncoderHarness {
-        Bitmap.CompressFormat compressFormat = null;
-        Resource<Bitmap> resource = mock(Resource.class);
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        int quality = 100;
-
-        public EncoderHarness() {
-            when(resource.get()).thenReturn(bitmap);
-        }
-
-        public String encode() {
-            BitmapEncoder encoder = new BitmapEncoder(compressFormat, quality);
-            encoder.encode(resource, os);
-            return new String(os.toByteArray());
-        }
-    }
-
-    @Implements(Bitmap.class)
-    public static class AlphaShadowBitmap extends ShadowBitmap {
-        private boolean hasAlpha;
-
-        @SuppressWarnings("unused")
-        @Implementation
-        public void setHasAlpha(boolean hasAlpha) {
-            this.hasAlpha = hasAlpha;
-        }
-
-        @SuppressWarnings("unused")
-        @Implementation
-        public boolean hasAlpha() {
-            return hasAlpha;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
deleted file mode 100644
index 54bcf2a38..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.os.Build;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-//TODO: add a test for bitmap size using getAllocationByteSize when robolectric supports kitkat.
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BitmapResourceTest {
-    private int currentBuildVersion;
-    private BitmapResourceHarness harness;
-
-    @Before
-    public void setUp() {
-        currentBuildVersion = Build.VERSION.SDK_INT;
-        harness = new BitmapResourceHarness();
-    }
-
-    @After
-    public void tearDown() {
-        Util.setSdkVersionInt(currentBuildVersion);
-    }
-
-    @Test
-    public void testCanGetBitmap() {
-        assertEquals(harness.bitmap, harness.resource.get());
-    }
-
-    @Test
-    public void testSizeIsBasedOnDimensPreKitKat() {
-        Util.setSdkVersionInt(18);
-        assertEquals(harness.bitmap.getWidth() * harness.bitmap.getHeight() * 4, harness.resource.getSize());
-    }
-
-    @Test
-    public void testPutsBitmapInPoolOnRecycle() {
-        harness.resource.recycle();
-
-        verify(harness.bitmapPool).put(eq(harness.bitmap));
-    }
-
-    @Test
-    public void testBitmapIsNotRecycledIfAcceptedByPool() {
-        when(harness.bitmapPool.put(eq(harness.bitmap))).thenReturn(true);
-
-        harness.resource.recycle();
-
-        assertFalse(harness.bitmap.isRecycled());
-    }
-
-    @Test
-    public void testRecyclesBitmapIfRejectedByPool() {
-        when(harness.bitmapPool.put(eq(harness.bitmap))).thenReturn(false);
-
-        harness.resource.recycle();
-
-        assertTrue(harness.bitmap.isRecycled());
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfBitmapIsNull() {
-        new BitmapResource(null, mock(BitmapPool.class));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfBitmapPoolIsNull() {
-        new BitmapResource(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565), null);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfBitmapAndBitmapPoolAreNull() {
-        new BitmapResource(null, null);
-    }
-
-    private static class BitmapResourceHarness {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
deleted file mode 100644
index 7ee9161f6..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ /dev/null
@@ -1,152 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BitmapTransformationTest {
-
-    private BitmapPool bitmapPool;
-
-    @Before
-    public void setUp() {
-        bitmapPool = mock(BitmapPool.class);
-    }
-
-    @Test
-    public void testReturnsGivenResourceWhenBitmapNotTransformed() {
-        BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
-            @Override
-            protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-                return toTransform;
-            }
-
-            @Override
-            public String getId() {
-                return null;
-            }
-        };
-
-        Resource<Bitmap> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
-        assertEquals(resource, transformation.transform(resource, 1, 1));
-    }
-
-    @Test
-    public void testReturnsNewResourceWhenBitmapTransformed() {
-        final Bitmap toTransform = Bitmap.createBitmap(1, 2, Bitmap.Config.RGB_565);
-        final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-        BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
-            @Override
-            protected Bitmap transform(BitmapPool pool, Bitmap bitmap, int outWidth, int outHeight) {
-                return transformed;
-            }
-
-            @Override
-            public String getId() {
-                return null;
-            }
-        };
-
-        Resource<Bitmap> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(toTransform);
-
-        assertNotSame(resource, transformation.transform(resource, 100, 100));
-    }
-
-    @Test
-    public void testPassesGivenArgumentsToTransform() {
-        final int expectedWidth = 13;
-        final int expectedHeight = 148;
-        final Bitmap expected = Bitmap.createBitmap(223, 4123, Bitmap.Config.RGB_565);
-        BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
-            @Override
-            protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-                assertEquals(bitmapPool, pool);
-                assertEquals(expected, toTransform);
-                assertEquals(expectedWidth, outWidth);
-                assertEquals(expectedHeight, outHeight);
-                return expected;
-            }
-
-            @Override
-            public String getId() {
-                return null;
-            }
-        };
-        Resource<Bitmap> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(expected);
-        transformation.transform(resource, expectedWidth, expectedHeight);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenInvalidWidth() {
-        BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
-
-            @Override
-            protected Bitmap transform(BitmapPool bitmapPool, Bitmap toTransform, int outWidth, int outHeight) {
-                return null;
-            }
-
-            @Override
-            public String getId() {
-                return null;
-            }
-
-        };
-        transformation.transform(mock(Resource.class), -1, 100);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenInvalidHeight() {
-        BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
-
-            @Override
-            protected Bitmap transform(BitmapPool bitmapPool, Bitmap toTransform, int outWidth, int outHeight) {
-                return null;
-            }
-
-            @Override
-            public String getId() {
-                return null;
-            }
-
-        };
-        transformation.transform(mock(Resource.class), 100, -1);
-    }
-
-    @Test
-    public void testReturnsNullIfTransformReturnsNull() {
-        BitmapTransformation transform = new BitmapTransformation(bitmapPool) {
-
-            @Override
-            public String getId() {
-                return null;
-            }
-
-            @Override
-            protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-                return null;
-            }
-        };
-
-        Resource<Bitmap> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
-        assertNull(transform.transform(resource, 100, 100));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
deleted file mode 100644
index 2b5c03fc8..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ /dev/null
@@ -1,141 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class CenterCropTest {
-    private CenterCropHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new CenterCropHarness();
-    }
-
-    @Test
-    public void testDoesNotPutNullBitmapAcquiredFromPool() {
-        when(harness.pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(null);
-
-        harness.centerCrop.transform(harness.resource, 100, 100);
-
-        verify(harness.pool, never()).put(any(Bitmap.class));
-    }
-
-    @Test
-    public void testReturnsGivenResourceIfMatchesSizeExactly() {
-        Resource<Bitmap> result = harness.centerCrop.transform(harness.resource, harness.bitmapWidth,
-                harness.bitmapHeight);
-
-        assertEquals(harness.resource, result);
-    }
-
-    @Test
-    public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-        harness.centerCrop.transform(harness.resource, harness.bitmapWidth,
-                harness.bitmapHeight);
-
-        verify(harness.resource, never()).recycle();
-    }
-
-    @Test
-    public void testDoesPutNonNullBitmapAcquiredFromPoolWhenUnused() {
-        Bitmap fromPool = Bitmap.createBitmap(harness.bitmapWidth, harness.bitmapHeight, Bitmap.Config.ARGB_8888);
-        when(harness.pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
-                .thenReturn(fromPool);
-
-        harness.centerCrop.transform(harness.resource, harness.bitmapWidth, harness.bitmapHeight);
-
-        verify(harness.pool).put(eq(fromPool));
-    }
-
-    @Test
-    public void testDoesNotRecycleGivenResource() {
-        harness.centerCrop.transform(harness.resource, 50, 50);
-
-        verify(harness.resource, never()).recycle();
-    }
-
-    @Test
-    public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
-        Robolectric.shadowOf(harness.bitmap).setConfig(null);
-
-        harness.centerCrop.transform(harness.resource, 10, 10);
-
-        verify(harness.pool).get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888));
-        verify(harness.pool, never()).get(anyInt(), anyInt(), (Bitmap.Config) isNull());
-    }
-
-    @Test
-    public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarget() {
-        int expectedWidth = 75;
-        int expectedHeight = 74;
-
-        Resource<Bitmap> resource = mock(Resource.class);
-        for (int[] dimens : new int[][] { new int[] { 800, 200}, new int[] { 450, 100 }, new int[] { 78, 78 }}) {
-            Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
-            when(resource.get()).thenReturn(toTransform);
-
-            Resource<Bitmap> result = harness.centerCrop.transform(resource, expectedWidth, expectedHeight);
-            Bitmap transformed = result.get();
-            assertEquals(expectedWidth, transformed.getWidth());
-            assertEquals(expectedHeight, transformed.getHeight());
-        }
-    }
-
-    @Test
-    public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarget() {
-        int expectedWidth = 100;
-        int expectedHeight = 100;
-
-        Resource<Bitmap> resource = mock(Resource.class);
-        for (int[] dimens : new int[][] { new int[] { 50, 90}, new int[] { 150, 2 }, new int[] { 78, 78 }}) {
-            Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
-            when(resource.get()).thenReturn(toTransform);
-
-            Resource<Bitmap> result = harness.centerCrop.transform(resource, expectedWidth, expectedHeight);
-            Bitmap transformed = result.get();
-            assertEquals(expectedWidth, transformed.getWidth());
-            assertEquals(expectedHeight, transformed.getHeight());
-        }
-    }
-
-    @Test
-    public void testHasValidId() {
-        Util.assertClassHasValidId(CenterCrop.class, harness.centerCrop.getId());
-    }
-
-    private static class CenterCropHarness {
-        int bitmapWidth = 100;
-        int bitmapHeight = 100;
-        Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
-        BitmapResource resource = mock(BitmapResource.class);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        CenterCrop centerCrop = new CenterCrop(pool);
-
-        public CenterCropHarness() {
-            when(resource.get()).thenReturn(bitmap);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
deleted file mode 100644
index 3347531ab..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class DownsamplerTest {
-    private File tempFile;
-
-    @Before
-    public void setUp() throws Exception {
-        File cacheDir = Robolectric.application.getCacheDir();
-        cacheDir.mkdir();
-        tempFile = new File(cacheDir, "temp");
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        tempFile.delete();
-    }
-
-    @Test
-    public void testAlwaysArgb8888() throws FileNotFoundException {
-        Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-        compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-        Downsampler downsampler = Downsampler.AT_LEAST;
-        InputStream is = new FileInputStream(tempFile);
-        try {
-            Bitmap result = downsampler.decode(is, mock(BitmapPool.class), 100, 100, DecodeFormat.ALWAYS_ARGB_8888);
-            assertEquals(Bitmap.Config.ARGB_8888, result.getConfig());
-        } finally {
-            try {
-                is.close();
-            } catch (IOException e) {
-                // Do nothing.
-            }
-        }
-    }
-
-    @Test
-    public void testPreferRgb565() throws FileNotFoundException {
-        Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-        Downsampler downsampler = Downsampler.AT_LEAST;
-        InputStream is = new FileInputStream(tempFile);
-        try {
-            Bitmap result = downsampler.decode(is, mock(BitmapPool.class), 100, 100, DecodeFormat.PREFER_RGB_565);
-            assertEquals(Bitmap.Config.RGB_565, result.getConfig());
-        } finally {
-            try {
-                is.close();
-            } catch (IOException e) {
-                // Do nothing.
-            }
-        }
-    }
-
-    private void compressBitmap(Bitmap bitmap, Bitmap.CompressFormat compressFormat) throws FileNotFoundException {
-        OutputStream os = null;
-        try {
-            os = new BufferedOutputStream(new FileOutputStream(tempFile));
-            bitmap.compress(compressFormat, 100, os);
-        } finally {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (IOException e) {
-                    // Do nothing.
-                }
-            }
-        }
-
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoderTest.java
deleted file mode 100644
index 07cd5490a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoderTest.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class FileDescriptorBitmapDecoderTest {
-
-    private FileDescriptorBitmapDecoder decoder;
-    private BitmapPool bitmapPool;
-    private VideoBitmapDecoder videoDecoder;
-    private DecodeFormat decodeFormat;
-
-    @Before
-    public void setUp() {
-        bitmapPool = mock(BitmapPool.class);
-        videoDecoder = mock(VideoBitmapDecoder.class);
-        decodeFormat = DecodeFormat.DEFAULT;
-        decoder = new FileDescriptorBitmapDecoder(videoDecoder, bitmapPool, decodeFormat);
-    }
-
-    @Test
-    public void testHasValidId() {
-        assertEquals("FileDescriptorBitmapDecoder.com.bumptech.glide.load.data.bitmap", decoder.getId());
-    }
-
-    @Test
-    public void testReturnsBitmapFromWrappedDecoderAsResource() throws IOException {
-        ParcelFileDescriptor source = mock(ParcelFileDescriptor.class);
-        int width = 100;
-        int height = 200;
-        Bitmap expected = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_4444);
-        when(videoDecoder.decode(eq(source), eq(bitmapPool), eq(width), eq(height), eq(decodeFormat)))
-                .thenReturn(expected);
-
-        Resource<Bitmap> bitmapResource = decoder.decode(source, width, height);
-
-        assertEquals(expected, bitmapResource.get());
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
deleted file mode 100644
index 555817553..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class FitCenterTest {
-    private FitCenterHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new FitCenterHarness();
-    }
-
-    @Test
-    public void testDoesNotPutNullBitmapAcquiredFromPool() {
-        when(harness.pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(null);
-
-        harness.fitCenter.transform(harness.resource, 100, 100);
-
-        verify(harness.pool, never()).put(any(Bitmap.class));
-    }
-
-    @Test
-    public void testReturnsGivenResourceIfMatchesSizeExactly() {
-        Resource<Bitmap> result = harness.fitCenter.transform(harness.resource, harness.bitmapWidth,
-                harness.bitmapHeight);
-
-        assertEquals(harness.resource, result);
-    }
-
-    @Test
-    public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-        harness.fitCenter.transform(harness.resource, harness.bitmapWidth,
-                harness.bitmapHeight);
-
-        verify(harness.resource, never()).recycle();
-    }
-
-    @Test
-    public void testDoesNotRecycleGivenResource() {
-        harness.fitCenter.transform(harness.resource, 50, 50);
-
-        verify(harness.resource, never()).recycle();
-    }
-
-    @Test
-    public void testHasValidId() {
-        Util.assertClassHasValidId(FitCenter.class, harness.fitCenter.getId());
-    }
-
-
-    private static class FitCenterHarness {
-        int bitmapWidth = 100;
-        int bitmapHeight = 100;
-        Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
-        BitmapResource resource = mock(BitmapResource.class);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        FitCenter fitCenter = new FitCenter(pool);
-
-        public FitCenterHarness() {
-            when(resource.get()).thenReturn(bitmap);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResourceTest.java
deleted file mode 100644
index f5bd0705e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResourceTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GlideBitmapDrawableResourceTest {
-    private GlideBitmapDrawableResourceHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new GlideBitmapDrawableResourceHarness();
-    }
-
-    @Test
-    public void testReturnsGivenBitmapFromGet() {
-        assertEquals(harness.bitmap, harness.create().get().getBitmap());
-    }
-
-    @Test
-    public void testReturnsGivenDrawableOnFirstGet() {
-        GlideBitmapDrawableResource resource = harness.create();
-        assertEquals(harness.drawable, resource.get());
-    }
-
-    @Test
-    public void testReturnsDifferentDrawableEachTime() {
-        GlideBitmapDrawableResource resource = harness.create();
-        GlideBitmapDrawable first = resource.get();
-        GlideBitmapDrawable second = resource.get();
-
-        assertNotSame(first, second);
-    }
-
-    @Test
-    public void testReturnsSizeFromGivenBitmap() {
-        assertEquals(harness.bitmap.getHeight() * harness.bitmap.getRowBytes(), harness.create().getSize());
-    }
-
-    @Test
-    public void testBitmapIsReturnedToPoolOnRecycle() {
-        harness.create().recycle();
-
-        verify(harness.bitmapPool).put(eq(harness.bitmap));
-    }
-
-    private static class GlideBitmapDrawableResourceHarness {
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        GlideBitmapDrawable drawable = new GlideBitmapDrawable(Robolectric.application.getResources(),  bitmap);
-
-        public GlideBitmapDrawableResource create() {
-            return new GlideBitmapDrawableResource(drawable, bitmapPool);
-        }
-    }
-
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableTest.java
deleted file mode 100644
index 6f51023af..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableTest.java
+++ /dev/null
@@ -1,165 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.ColorFilter;
-import android.graphics.LightingColorFilter;
-import android.graphics.Paint;
-import android.graphics.PixelFormat;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GlideBitmapDrawableTest {
-
-    private Bitmap bitmap;
-    private GlideBitmapDrawable drawable;
-
-    @Before
-    public void setUp() {
-        bitmap = Bitmap.createBitmap(123, 456, Bitmap.Config.ARGB_8888);
-        drawable = new GlideBitmapDrawable(Robolectric.application.getResources(), bitmap);
-    }
-
-    @Test
-    public void testReturnsWidthOfGivenBitmap() {
-        assertEquals(bitmap.getWidth(), drawable.getIntrinsicWidth());
-    }
-
-    @Test
-    public void testReturnsHeightOfGivenBitmap() {
-        assertEquals(bitmap.getHeight(), drawable.getIntrinsicHeight());
-    }
-
-    @Test
-    public void testReturnsNotAnimated() {
-        assertFalse(drawable.isAnimated());
-    }
-
-    @Test
-    public void testReturnsNotRunning() {
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testReturnsOpacityOpaqueIfBitmapDoesNotHaveAlpha() {
-        bitmap.setHasAlpha(false);
-        drawable.setAlpha(255);
-        assertEquals(PixelFormat.OPAQUE, drawable.getOpacity());
-    }
-
-    @Test
-    public void testReturnsOpacityTranslucentIfAlphaIsSet() {
-        bitmap.setHasAlpha(false);
-        drawable.setAlpha(100);
-        assertEquals(PixelFormat.TRANSLUCENT, drawable.getOpacity());
-    }
-
-    @Test
-    public void testReturnsNonNullConstantState() {
-        assertNotNull(drawable.getConstantState());
-    }
-
-    @Test
-    public void testConstantStateReturnsNewGlideBitmapDrawable() {
-        Drawable newDrawable = drawable.getConstantState().newDrawable();
-        assertThat(newDrawable).isInstanceOf(GlideBitmapDrawable.class);
-    }
-
-    @Test
-    public void testDrawableReturnedByConstantStateWrapsSameBitmap() {
-        GlideBitmapDrawable newDrawable = (GlideBitmapDrawable) drawable.getConstantState().newDrawable();
-        assertEquals(drawable.getBitmap(), newDrawable.getBitmap());
-    }
-
-    @Test
-    public void testMutatedDrawableIsGlideBitmapDrawable() {
-        Drawable newDrawable = drawable.mutate();
-        assertThat(newDrawable).isInstanceOf(GlideBitmapDrawable.class);
-    }
-
-    @Test
-    public void testMutatedDrawableWrapsSameBitmap() {
-        GlideBitmapDrawable mutated = (GlideBitmapDrawable) drawable.mutate();
-        assertEquals(drawable.getBitmap(), mutated.getBitmap());
-    }
-
-    @Test
-    public void testRetainsSameBoundsAcrossMutation() {
-        Rect bounds = new Rect(0, 0, 100, 100);
-        drawable.setBounds(bounds);
-        drawable.onBoundsChange(bounds);
-        Canvas canvas = mock(Canvas.class);
-        drawable.draw(canvas);
-
-        Drawable mutated = drawable.mutate();
-        mutated.draw(canvas);
-
-        assertEquals(bounds, mutated.getBounds());
-        verify(canvas, times(2)).drawBitmap(eq(bitmap), isNull(Rect.class), eq(bounds), any(Paint.class));
-    }
-
-    @Test
-    public void testMutatedDrawableUsesNewPaint() {
-        drawable.setAlpha(1);
-        Drawable newDrawable = drawable.getConstantState().newDrawable();
-        Drawable mutated = drawable.mutate();
-        mutated.setAlpha(100);
-
-        Canvas canvas = mock(Canvas.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                Paint paint = (Paint) invocation.getArguments()[3];
-                assertEquals(1, paint.getAlpha());
-                return null;
-            }
-        }).when(canvas).drawBitmap(any(Bitmap.class), any(Rect.class), any(Rect.class), any(Paint.class));
-        newDrawable.draw(canvas);
-        verify(canvas).drawBitmap(eq(bitmap), any(Rect.class), any(Rect.class), any(Paint.class));
-    }
-
-    @Test
-    public void testMutatedDrawableUsesNewColorFilter() {
-        final ColorFilter originalColorFilter = new LightingColorFilter(1, 1);
-        drawable.setColorFilter(originalColorFilter);
-        Drawable newDrawable = drawable.getConstantState().newDrawable();
-        Drawable mutated = drawable.mutate();
-        ColorFilter newColorFilter = new LightingColorFilter(2, 2);
-        mutated.setColorFilter(newColorFilter);
-
-        Canvas canvas = mock(Canvas.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                Paint paint = (Paint) invocation.getArguments()[3];
-                assertEquals(originalColorFilter, paint.getColorFilter());
-                return null;
-            }
-        }).when(canvas).drawBitmap(any(Bitmap.class), any(Rect.class), any(Rect.class), any(Paint.class));
-        newDrawable.draw(canvas);
-        verify(canvas).drawBitmap(eq(bitmap), any(Rect.class), any(Rect.class), any(Paint.class));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
deleted file mode 100644
index a37a458f1..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(JUnit4.class)
-public class ImageHeaderParserTest {
-
-    private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK = new byte[] {(byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a,
-            0xa, 0x0, 0x0, 0x0, 0xd, 0x49, 0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8,
-            0x6 };
-
-    @Test
-    public void testCanParsePngType() throws IOException {
-        // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
-        InputStream is = new ByteArrayInputStream(new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
-        ImageHeaderParser parser = new ImageHeaderParser(is);
-        assertEquals(ImageType.PNG, parser.getType());
-    }
-
-    @Test
-    public void testCanParsePngWithAlpha() throws IOException {
-        for (int i = 3; i <= 6; i++) {
-            byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-            InputStream is = new ByteArrayInputStream(pngHeaderWithIhdrChunk);
-            ImageHeaderParser parser = new ImageHeaderParser(is);
-            assertEquals(ImageType.PNG_A, parser.getType());
-        }
-    }
-
-    @Test
-    public void testCanParsePngWithoutAlpha() throws IOException {
-        for (int i = 0; i < 3; i++) {
-            byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-            InputStream is = new ByteArrayInputStream(pngHeaderWithIhdrChunk);
-            ImageHeaderParser parser = new ImageHeaderParser(is);
-            assertEquals(ImageType.PNG, parser.getType());
-        }
-    }
-
-    @Test
-    public void testCanParseJpegType() throws IOException {
-        InputStream is = new ByteArrayInputStream(new byte[] { (byte) 0xFF, (byte) 0xD8 });
-        ImageHeaderParser parser = new ImageHeaderParser(is);
-        assertEquals(ImageType.JPEG, parser.getType());
-    }
-
-    @Test
-    public void testCanParseGifType() throws IOException {
-        InputStream is = new ByteArrayInputStream(new byte[] { 'G', 'I', 'F' });
-        ImageHeaderParser parser = new ImageHeaderParser(is);
-        assertEquals(ImageType.GIF, parser.getType());
-    }
-
-    @Test
-    public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
-        InputStream is = new ByteArrayInputStream(new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 });
-        ImageHeaderParser parser = new ImageHeaderParser(is);
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-
-    }
-
-    private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
-        byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
-        System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
-        result[result.length - 1] = (byte) bitDepth;
-        return result;
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoderTest.java
deleted file mode 100644
index 99d28a941..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoderTest.java
+++ /dev/null
@@ -1,112 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ImageVideoBitmapDecoderTest {
-    private ImageVideoDecoderHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new ImageVideoDecoderHarness();
-    }
-
-    @Test
-    public void testDecodesWithStreamDecoderFirst() throws IOException {
-        when(harness.streamDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(harness.result);
-        when(harness.wrapper.getStream()).thenReturn(new ByteArrayInputStream(new byte[0]));
-
-        Resource<Bitmap> decoded = harness.decoder.decode(harness.wrapper, 100, 100);
-
-        assertEquals(harness.result, decoded);
-    }
-
-    @Test
-    public void testDecodesWithFileDecoderIfStreamFails() throws IOException {
-        when(harness.streamDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(null);
-        when(harness.wrapper.getFileDescriptor()).thenReturn(mock(ParcelFileDescriptor.class));
-        when(harness.fileDescriptorDecoder.decode(any(ParcelFileDescriptor.class), anyInt(), anyInt()))
-                .thenReturn(harness.result);
-
-        Resource<Bitmap> decoded = harness.decoder.decode(harness.wrapper, 100, 100);
-
-        assertEquals(harness.result, decoded);
-    }
-    @Test
-    public void testDecodesWithFileDecoderIfStreamThrows() throws IOException {
-        when(harness.streamDecoder.decode(any(InputStream.class), anyInt(), anyInt()))
-                .thenThrow(new RuntimeException("test"));
-        when(harness.wrapper.getFileDescriptor()).thenReturn(mock(ParcelFileDescriptor.class));
-        when(harness.fileDescriptorDecoder.decode(any(ParcelFileDescriptor.class), anyInt(), anyInt()))
-                .thenReturn(harness.result);
-
-        Resource<Bitmap> decoded = harness.decoder.decode(harness.wrapper, 100, 100);
-
-        assertEquals(harness.result, decoded);
-    }
-
-    @Test
-    public void testReturnsValidId() {
-        Util.assertClassHasValidId(ImageVideoBitmapDecoder.class, harness.decoder.getId());
-    }
-
-    @Test
-    public void testDoesNotTryToDecodeNullStream() throws IOException {
-        when(harness.wrapper.getStream()).thenReturn(null);
-        when(harness.wrapper.getFileDescriptor()).thenReturn(mock(ParcelFileDescriptor.class));
-        when(harness.fileDescriptorDecoder.decode(any(ParcelFileDescriptor.class), anyInt(), anyInt()))
-                .thenReturn(harness.result);
-
-        assertEquals(harness.result, harness.decoder.decode(harness.wrapper, 100, 100));
-        verify(harness.streamDecoder, never()).decode(any(InputStream.class), anyInt(), anyInt());
-    }
-
-    @Test
-    public void testDoesNotTryToDecodeNullFileDescriptor() throws IOException {
-        when(harness.wrapper.getStream()).thenReturn(null);
-        when(harness.wrapper.getFileDescriptor()).thenReturn(null);
-
-        harness.decoder.decode(harness.wrapper, 100, 102);
-
-        verify(harness.fileDescriptorDecoder, never()).decode(any(ParcelFileDescriptor.class), anyInt(), anyInt());
-    }
-
-    @Test
-    public void testHasValidId() {
-        Util.assertClassHasValidId(ImageVideoBitmapDecoder.class, harness.decoder.getId());
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class ImageVideoDecoderHarness {
-        Resource<Bitmap> result = mock(Resource.class);
-        ResourceDecoder<InputStream, Bitmap> streamDecoder = mock(ResourceDecoder.class);
-        ResourceDecoder<ParcelFileDescriptor, Bitmap> fileDescriptorDecoder = mock(ResourceDecoder.class);
-        ImageVideoBitmapDecoder decoder = new ImageVideoBitmapDecoder(streamDecoder, fileDescriptorDecoder);
-        ImageVideoWrapper wrapper = mock(ImageVideoWrapper.class);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
deleted file mode 100644
index 999e835f4..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
+++ /dev/null
@@ -1,293 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-
-@RunWith(JUnit4.class)
-public class RecyclableBufferedInputStreamTest {
-
-    private static final int DATA_SIZE = 30;
-    private static final int BUFFER_SIZE = 10;
-
-    private RecyclableBufferedInputStream stream;
-    private byte[] data;
-
-    @Before
-    public void setUp() {
-        data = new byte[DATA_SIZE];
-        for (int i = 0; i < DATA_SIZE; i++) {
-            data[i] = (byte) i;
-        }
-        InputStream wrapped = new ByteArrayInputStream(data);
-        stream = new RecyclableBufferedInputStream(wrapped, new byte[BUFFER_SIZE]);
-    }
-
-    @Test
-    public void testReturnsTrueForMarkSupported() {
-        assertTrue(stream.markSupported());
-    }
-
-    @Test
-    public void testCanReadIndividualBytes() throws IOException {
-        for (int i = 0; i < data.length; i++) {
-            assertEquals(i, stream.read());
-        }
-        assertEquals(-1, stream.read());
-    }
-
-    @Test
-    public void testCanReadBytesInBulkLargerThanBufferSize() throws IOException {
-        byte[] buffer = new byte[DATA_SIZE];
-        assertEquals(DATA_SIZE, stream.read(buffer, 0, DATA_SIZE));
-        for (int i = 0; i < DATA_SIZE; i++) {
-            assertEquals(i, buffer[i]);
-        }
-    }
-
-    @Test
-    public void testCanReadBytesInBulkSmallerThanBufferSize() throws IOException {
-        int toRead = BUFFER_SIZE / 2;
-        byte[] buffer = new byte[toRead];
-        assertEquals(toRead, stream.read(buffer, 0, toRead));
-        for (int i = 0; i < toRead; i++) {
-            assertEquals(i, buffer[i]);
-        }
-    }
-
-    @Test
-    public void testReadingZeroBytesIntoBufferReadsZeroBytes() throws IOException {
-        // Make sure the next value is not 0.
-        stream.read();
-        byte[] buffer = new byte[BUFFER_SIZE];
-        assertEquals(0, stream.read(buffer, 0, 0));
-
-        for (int i = 0; i < BUFFER_SIZE; i++) {
-            assertEquals(0, buffer[i]);
-        }
-    }
-
-    @Test
-    public void testCanReadIntoBufferLargerThanDataSize() throws IOException {
-        int toRead = DATA_SIZE * 2;
-        byte[] buffer = new byte[toRead];
-        assertEquals(DATA_SIZE, stream.read(buffer, 0, toRead));
-        for (int i = 0; i < DATA_SIZE; i++) {
-            assertEquals(i, buffer[i]);
-        }
-        for (int i = DATA_SIZE; i < toRead; i++) {
-            assertEquals(0, buffer[i]);
-        }
-    }
-
-    @Test
-    public void testCanReadBytesInBulkWithLimit() throws IOException {
-        int toRead = BUFFER_SIZE / 2;
-        byte[] buffer = new byte[BUFFER_SIZE];
-        assertEquals(toRead, stream.read(buffer, 0, toRead));
-
-        // 0, 1, 2, 3, 4, 0, 0, 0, 0, 0
-        for (int i = 0; i < toRead; i++) {
-            assertEquals(i, buffer[i]);
-        }
-        for (int i = toRead; i < BUFFER_SIZE; i++) {
-            assertEquals(0, buffer[i]);
-        }
-    }
-
-    @Test
-    public void testCanReadBytesInBulkWithOffset() throws IOException {
-        int toRead = BUFFER_SIZE / 2;
-        byte[] buffer = new byte[BUFFER_SIZE];
-        assertEquals(toRead, stream.read(buffer, BUFFER_SIZE - toRead, toRead));
-        // 0, 0, 0, 0, 0, 0, 1, 2, 3, 4
-        for (int i = 0; i < toRead; i++) {
-            assertEquals(0, buffer[i]);
-        }
-        for (int i = toRead; i < BUFFER_SIZE; i++) {
-            assertEquals(i - toRead, buffer[i]);
-        }
-    }
-
-    @Test
-    public void testCanReadBytesInBulkWhenSomeButNotAllBytesAreInBuffer() throws IOException {
-        stream.read();
-        byte[] buffer = new byte[BUFFER_SIZE];
-        assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
-        for (int i = 1; i < BUFFER_SIZE + 1; i++) {
-            assertEquals(i, buffer[i - 1]);
-        }
-    }
-
-    @Test
-    public void testCanSkipBytes() throws IOException {
-        int toSkip = data.length / 2;
-        assertEquals(toSkip, stream.skip(toSkip));
-        for (int i = toSkip; i < data.length; i++) {
-            assertEquals(i, stream.read());
-        }
-        assertEquals(-1, stream.read());
-    }
-
-    @Test
-    public void testSkipReturnsZeroIfSkipByteCountIsZero() throws IOException {
-        assertEquals(0, stream.skip(0));
-        assertEquals(0, stream.read());
-    }
-
-    @Test
-    public void testSkipReturnsZeroIfSkipByteCountIsNegative() throws IOException {
-        assertEquals(0, stream.skip(-13));
-        assertEquals(0, stream.read());
-    }
-
-    @Test
-    public void testCloseClosesWrappedStream() throws IOException {
-        InputStream wrapped = mock(InputStream.class);
-        stream = new RecyclableBufferedInputStream(wrapped, new byte[1]);
-        stream.close();
-        verify(wrapped).close();
-    }
-
-    @Test
-    public void testCanSafelyBeClosedMultipleTimes() throws IOException {
-        InputStream wrapped = mock(InputStream.class);
-        stream = new RecyclableBufferedInputStream(wrapped, new byte[1]);
-        stream.close();
-        stream.close();
-        stream.close();
-
-        verify(wrapped, times(1)).close();
-    }
-
-    @Test
-    public void testCanMarkAndReset() throws IOException {
-        byte[] buffer = new byte[BUFFER_SIZE];
-        stream.mark(BUFFER_SIZE);
-        assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
-        for (int i = 0; i < BUFFER_SIZE; i++) {
-            assertEquals(i, buffer[i]);
-        }
-        Arrays.fill(buffer, (byte) 0);
-        stream.reset();
-
-        assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
-        for (int i = 0; i < BUFFER_SIZE; i++) {
-            assertEquals(i, buffer[i]);
-        }
-    }
-
-    @Test
-    public void testCanResetRepeatedlyAfterMarking() throws IOException {
-        byte[] buffer = new byte[BUFFER_SIZE];
-        stream.mark(BUFFER_SIZE);
-        for (int repeat = 0; repeat < 10; repeat++) {
-            assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
-            for (int i = 0; i < BUFFER_SIZE; i++) {
-                assertEquals(i, buffer[i]);
-            }
-            stream.reset();
-        }
-    }
-
-    @Test
-    public void testCanMarkInMiddleOfBufferAndStillReadUpToBufferLengthBeforeResetting() throws IOException {
-        int markPos = BUFFER_SIZE / 2;
-        for (int i = 0; i < markPos; i++) {
-            stream.read();
-        }
-        stream.mark(BUFFER_SIZE);
-
-        for (int i = 0; i < BUFFER_SIZE; i++) {
-            stream.read();
-        }
-
-        stream.reset();
-        assertEquals(markPos, stream.read());
-    }
-
-    @Test
-    public void testAvailableReturnsWrappedAvailableIfNoBytesRead() throws IOException {
-        assertEquals(DATA_SIZE, stream.available());
-    }
-
-    @Test
-    public void testAvailableIncludesDataInBufferAndWrappedAvailableIfBytesRead() throws IOException {
-        stream.read();
-        assertEquals(DATA_SIZE - 1, stream.available());
-    }
-
-    @Test(expected = IOException.class)
-    public void testCloseThrowsIfWrappedStreamThrowsOnClose() throws IOException {
-        InputStream wrapped = mock(InputStream.class);
-        doThrow(new IOException()).when(wrapped).close();
-        stream = new RecyclableBufferedInputStream(wrapped, new byte[1]);
-        stream.close();
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenBufferIsNull() {
-        new RecyclableBufferedInputStream(mock(InputStream.class), null);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenBufferHasZeroSize() {
-        new RecyclableBufferedInputStream(mock(InputStream.class), new byte[0]);
-    }
-
-    @Test(expected = IOException.class)
-    public void testAvailableThrowsIfStreamIsClosed() throws IOException {
-        stream.close();
-        stream.available();
-    }
-
-    @Test(expected = IOException.class)
-    public void testReadThrowsIfStreamIsClosed() throws IOException {
-        stream.close();
-        stream.read();
-    }
-
-    @Test(expected = IOException.class)
-    public void testReadBulkThrowsIfStreamIsClosed() throws IOException {
-        stream.close();
-        stream.read(new byte[1], 0, 1);
-    }
-
-    @Test(expected = IOException.class)
-    public void testResetThrowsIfStreamIsClosed() throws IOException {
-        stream.close();
-        stream.reset();
-    }
-
-    @Test(expected = IOException.class)
-    public void testSkipThrowsIfStreamIsClosed() throws IOException {
-        stream.close();
-        stream.skip(10);
-    }
-
-    @Test(expected = RecyclableBufferedInputStream.InvalidMarkException.class)
-    public void testResetThrowsIfMarkNotSet() throws IOException {
-        stream.reset();
-    }
-
-    @Test(expected = RecyclableBufferedInputStream.InvalidMarkException.class)
-    public void testResetThrowsIfMarkIsInvalid() throws IOException {
-        stream.mark(1);
-        stream.read(new byte[BUFFER_SIZE], 0, BUFFER_SIZE);
-        stream.read();
-        stream.reset();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java
deleted file mode 100644
index a6a9d4d3a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class StreamBitmapDecoderTest {
-    private DecoderHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new DecoderHarness();
-    }
-
-    @Test
-    public void testNonNullResourceIsReturned() {
-        when(harness.downsampler.decode(eq(harness.source), eq(harness.bitmapPool), eq(harness.width),
-                eq(harness.height), eq(harness.decodeFormat))).thenReturn(harness.result);
-        assertNotNull(harness.decode());
-    }
-
-    @Test
-    public void testNullResourceIsReturnedForNullBitmap() {
-        when(harness.downsampler.decode(eq(harness.source), eq(harness.bitmapPool), eq(harness.width),
-                eq(harness.height), eq(harness.decodeFormat))).thenReturn(null);
-        assertNull(harness.decode());
-    }
-
-    @Test
-    public void testHasValidId() {
-        String downsamplerId = "downsamplerId";
-        when(harness.downsampler.getId()).thenReturn(downsamplerId);
-
-        String actualId = harness.decoder.getId();
-        assertThat(actualId).contains(downsamplerId);
-        assertThat(actualId).contains(harness.decodeFormat.toString());
-        assertThat(actualId).contains(Util.getExpectedClassId(StreamBitmapDecoder.class));
-    }
-
-    private static class DecoderHarness {
-        Downsampler downsampler = mock(Downsampler.class);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        DecodeFormat decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;
-        InputStream source = new ByteArrayInputStream(new byte[0]);
-        int width = 100;
-        int height = 100;
-        Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-        StreamBitmapDecoder decoder = new StreamBitmapDecoder(downsampler, bitmapPool, decodeFormat);
-
-        public DecoderHarness() {
-        }
-
-        public Resource decode() {
-            return decoder.decode(source, width, height);
-        }
-
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
deleted file mode 100644
index a73988b7c..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ /dev/null
@@ -1,389 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.google.common.collect.Range;
-
-import android.graphics.Bitmap;
-import android.graphics.Matrix;
-import android.media.ExifInterface;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { TransformationUtilsTest.AlphaShadowBitmap.class })
-public class TransformationUtilsTest {
-
-    @Test
-    public void testFitCenterWithWideBitmap() {
-        final int maxSide = 500;
-
-        Bitmap wide = Bitmap.createBitmap(2000, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(wide, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(wide, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithSmallWideBitmap() {
-        final int maxSide = 500;
-
-        Bitmap smallWide = Bitmap.createBitmap(400, 40, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(smallWide, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(smallWide, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithTallBitmap() {
-        final int maxSide = 500;
-
-        Bitmap tall = Bitmap.createBitmap(65, 3000, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(tall, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(tall, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithSmallTallBitmap() {
-        final int maxSide = 500;
-
-        Bitmap smallTall = Bitmap.createBitmap(10, 400, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(smallTall, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(smallTall, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithSquareBitmap() {
-        final int maxSide = 500;
-
-        Bitmap square = Bitmap.createBitmap(600, 600, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(square, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(square, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithTooSmallSquareBitmap() {
-        final int maxSide = 500;
-
-        Bitmap smallSquare = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(smallSquare, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(smallSquare, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    // Test for Issue #195.
-    @Test
-    public void testFitCenterUsesFloorInsteadOfRoundingForOutputBitmapSize() {
-        Bitmap toTransform = Bitmap.createBitmap(1230, 1640, Bitmap.Config.RGB_565);
-
-        Bitmap transformed = TransformationUtils.fitCenter(toTransform, mock(BitmapPool.class), 1075, 1366);
-
-        assertEquals(1024, transformed.getWidth());
-        assertEquals(1366, transformed.getHeight());
-    }
-
-    @Test
-    public void testFitCenterReturnsGivenBitmapIfGivenBitmapMatchesExactly() {
-        Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
-        Bitmap transformed = TransformationUtils.fitCenter(toFit, null, toFit.getWidth(), toFit.getHeight());
-        assertTrue(toFit == transformed);
-    }
-
-    @Test
-    public void testFitCenterReturnsGivenBitmapIfGivenBitmapWidthMatchesExactly() {
-        Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
-        Bitmap transformed = TransformationUtils.fitCenter(toFit, null, toFit.getWidth(), toFit.getHeight() * 2);
-        assertTrue(toFit == transformed);
-    }
-
-    @Test
-    public void testFitCenterReturnsGivenBitmapIfGivenBitmapHeightMatchesExactly() {
-        Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
-        Bitmap transformed = TransformationUtils.fitCenter(toFit, null, toFit.getWidth() * 2, toFit.getHeight());
-        assertTrue(toFit == transformed);
-    }
-
-    @Test
-    public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-
-        toReuse.setHasAlpha(false);
-        toTransform.setHasAlpha(true);
-
-        Bitmap result = TransformationUtils.centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());
-
-        assertEquals(toReuse, result);
-        assertTrue(result.hasAlpha());
-    }
-
-    @Test
-    public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-
-        toReuse.setHasAlpha(true);
-        toTransform.setHasAlpha(false);
-
-        Bitmap result = TransformationUtils.centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());
-
-        assertEquals(toReuse, result);
-        assertFalse(result.hasAlpha());
-    }
-
-    @Test
-    public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        toTransform.setHasAlpha(true);
-
-        Bitmap result = TransformationUtils.centerCrop(null, toTransform, toTransform.getWidth() / 2,
-                toTransform.getHeight() / 2);
-
-        assertTrue(result.hasAlpha());
-    }
-
-    @Test
-    public void testSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        toTransform.setHasAlpha(false);
-
-        Bitmap result = TransformationUtils.centerCrop(null, toTransform, toTransform.getWidth() / 2,
-                toTransform.getHeight() / 2);
-
-        assertFalse(result.hasAlpha());
-    }
-
-    @Test
-    public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
-                .thenReturn(toReuse);
-
-        toReuse.setHasAlpha(false);
-        toTransform.setHasAlpha(true);
-
-        Bitmap result = TransformationUtils.fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());
-
-        assertEquals(toReuse, result);
-        assertTrue(result.hasAlpha());
-    }
-
-    @Test
-    public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
-                .thenReturn(toReuse);
-
-        toReuse.setHasAlpha(true);
-        toTransform.setHasAlpha(false);
-
-        Bitmap result = TransformationUtils.fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());
-
-        assertEquals(toReuse, result);
-        assertFalse(result.hasAlpha());
-    }
-
-    @Test
-    public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        toTransform.setHasAlpha(true);
-
-        Bitmap result = TransformationUtils.fitCenter(toTransform, pool, toTransform.getWidth() / 2,
-                toTransform.getHeight() / 2);
-
-        assertTrue(result.hasAlpha());
-    }
-
-    @Test
-    public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        toTransform.setHasAlpha(false);
-
-        Bitmap result = TransformationUtils.fitCenter(toTransform, pool, toTransform.getWidth() / 2,
-                toTransform.getHeight() / 2);
-
-        assertFalse(result.hasAlpha());
-    }
-
-    private static void assertHasOriginalAspectRatio(Bitmap original, Bitmap transformed) {
-        double originalAspectRatio = (double) original.getWidth() / (double) original.getHeight();
-        double transformedAspectRatio = (double) transformed.getWidth() / (double) transformed.getHeight();
-
-        assertThat(transformedAspectRatio).isIn(Range.open(originalAspectRatio - 0.05f, originalAspectRatio + 0.05f));
-    }
-
-    private static void assertBitmapFitsExactlyWithinBounds(int maxSide, Bitmap bitmap) {
-        final int width = bitmap.getWidth();
-        final int height = bitmap.getHeight();
-
-        assertThat(width).isIn(Range.atMost(maxSide));
-        assertThat(height).isIn(Range.atMost(maxSide));
-
-        assertTrue("one side must match maxSide", width == maxSide || height == maxSide);
-    }
-
-    @Test
-    public void testGetExifOrientationDegrees() {
-        assertEquals(0, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_NORMAL));
-        assertEquals(90, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSPOSE));
-        assertEquals(90, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_90));
-        assertEquals(180, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_180));
-        assertEquals(180, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_FLIP_VERTICAL));
-        assertEquals(270, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSVERSE));
-        assertEquals(270, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_270));
-    }
-
-    @Test
-    public void testRotateImage() {
-        Bitmap toRotate = Bitmap.createBitmap(2, 2, Bitmap.Config.ARGB_8888);
-
-        Bitmap zero = TransformationUtils.rotateImage(toRotate, 0);
-        assertTrue(toRotate == zero);
-
-        Bitmap ninety = TransformationUtils.rotateImage(toRotate, 90);
-        assertTrue(Robolectric.shadowOf(ninety).getDescription().contains("rotate=90.0"));
-        assertEquals(toRotate.getWidth(), toRotate.getHeight());
-    }
-
-    @Test
-    public void testRotateImageExifReturnsGivenBitmapIfRotationIsNormal() {
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        Bitmap toRotate = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
-        // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want not just an
-        // identical Bitmap, but our original Bitmap object back.
-        Bitmap rotated = TransformationUtils.rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_NORMAL);
-        assertTrue(toRotate == rotated);
-    }
-
-    @Test
-    public void testRotateImageExifReturnsGivenBitmapIfRotationIsUndefined() {
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-        // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want not just an
-        // identical Bitmap, but our original Bitmap object back.
-        Bitmap rotated = TransformationUtils.rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_UNDEFINED);
-        assertTrue(toRotate == rotated);
-    }
-
-    @Test
-    public void testRotateImageExifReturnsGivenBitmapIfOrientationIsInvalid() {
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        Bitmap toRotate = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
-        // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want not just an
-        // identical Bitmap, but our original Bitmap object back.
-        Bitmap rotated = TransformationUtils.rotateImageExif(toRotate, bitmapPool, -1);
-        assertTrue(toRotate == rotated);
-    }
-
-    @Test
-    public void testRotateImageExifHandlesEmptyBitmapPool() {
-        Bitmap toRotate = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_4444);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        assertNotNull(TransformationUtils.rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_ROTATE_90));
-    }
-
-    @Test
-    public void testInitializeMatrixSetsScaleIfFlipHorizontal() {
-        Matrix matrix = mock(Matrix.class);
-        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_HORIZONTAL, matrix);
-        verify(matrix).setScale(-1, 1);
-    }
-
-    @Test
-    public void testInitializeMatrixSetsScaleAndRotateIfFlipVertical() {
-        Matrix matrix = mock(Matrix.class);
-        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_VERTICAL, matrix);
-        verify(matrix).setRotate(180);
-        verify(matrix).postScale(-1, 1);
-    }
-
-    @Test
-    public void testInitializeMatrixSetsScaleAndRotateIfTranspose() {
-        Matrix matrix = mock(Matrix.class);
-        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_TRANSPOSE, matrix);
-        verify(matrix).setRotate(90);
-        verify(matrix).postScale(-1, 1);
-    }
-
-    @Test
-    public void testInitializeMatrixSetsScaleAndRotateIfTransverse() {
-        Matrix matrix = mock(Matrix.class);
-        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_TRANSVERSE, matrix);
-        verify(matrix).setRotate(-90);
-        verify(matrix).postScale(-1, 1);
-    }
-
-    @Test
-    public void testInitializeMatrixSetsRotateOnRotation() {
-        Matrix matrix = mock(Matrix.class);
-        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_90, matrix);
-        verify(matrix).setRotate(90);
-        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_180, matrix);
-        verify(matrix).setRotate(180);
-        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_270, matrix);
-        verify(matrix).setRotate(-90);
-    }
-
-    @Implements(Bitmap.class)
-    public static class AlphaShadowBitmap extends ShadowBitmap {
-
-        private boolean hasAlpha;
-
-        @Implementation
-        public void setHasAlpha(boolean hasAlpha) {
-            this.hasAlpha = hasAlpha;
-        }
-
-        @Implementation
-        public boolean hasAlpha() {
-            return hasAlpha;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
deleted file mode 100644
index d927aa390..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.FileDescriptor;
-import java.io.IOException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class VideoBitmapDecoderTest {
-    private BitmapPool bitmapPool;
-    private DecodeFormat decodeFormat;
-    private ParcelFileDescriptor resource;
-    private VideoBitmapDecoder decoder;
-    private VideoBitmapDecoder.MediaMetadataRetrieverFactory factory;
-    private MediaMetadataRetriever retriever;
-
-    @Before
-    public void setup() {
-        bitmapPool = mock(BitmapPool.class);
-        decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;
-        resource = mock(ParcelFileDescriptor.class);
-        factory = mock(VideoBitmapDecoder.MediaMetadataRetrieverFactory.class);
-        retriever = mock(MediaMetadataRetriever.class);
-        when(factory.build()).thenReturn(retriever);
-        decoder = new VideoBitmapDecoder(new VideoBitmapDecoder.MediaMetadataRetrieverFactory() {
-            @Override
-            public MediaMetadataRetriever build() {
-                return factory.build();
-            }
-        });
-    }
-
-    @Test
-    public void testReturnsRetrievedFrameForResource() throws IOException {
-        Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(retriever.getFrameAtTime()).thenReturn(expected);
-
-        FileDescriptor toSet = FileDescriptor.in;
-        when(resource.getFileDescriptor()).thenReturn(toSet);
-        Bitmap result = decoder.decode(resource, bitmapPool, 100, 100, decodeFormat);
-
-        verify(retriever).setDataSource(eq(toSet));
-        assertEquals(expected, result);
-    }
-
-    @Test
-    public void testReleasesMediaMetadataRetriever() throws IOException {
-        decoder.decode(resource, bitmapPool, 1, 2, decodeFormat);
-
-        verify(retriever).release();
-    }
-
-    @Test
-    public void testClosesResource() throws IOException {
-        decoder.decode(resource, bitmapPool, 1, 2, decodeFormat);
-
-        verify(resource).close();
-    }
-
-    @Test
-    public void testHasValidId() {
-        Util.assertClassHasValidId(VideoBitmapDecoder.class, decoder.getId());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
deleted file mode 100644
index 7470be0db..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package com.bumptech.glide.load.resource.bytes;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class BytesResourceTest {
-
-    @Test
-    public void testReturnsGivenBytes() {
-        byte[] bytes = new byte[0];
-        BytesResource resource = new BytesResource(bytes);
-
-        assertEquals(bytes, resource.get());
-    }
-
-    @Test
-    public void testReturnsSizeOfGivenBytes() {
-        byte[] bytes = new byte[123];
-        BytesResource resource = new BytesResource(bytes);
-
-        assertEquals(bytes.length, resource.getSize());
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfGivenNullBytes() {
-        new BytesResource(null);
-    }
-
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
deleted file mode 100644
index 1f0330407..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package com.bumptech.glide.load.resource.drawable;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Canvas;
-import android.graphics.ColorFilter;
-import android.graphics.drawable.Drawable;
-
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class DrawableResourceTest {
-    private TestDrawable drawable;
-    private DrawableResource<TestDrawable> resource;
-
-    @Before
-    public void setUp() {
-        drawable = mock(TestDrawable.class);
-        resource = new DrawableResource<TestDrawable>(drawable) {
-            @Override
-            public int getSize() {
-                return 0;
-            }
-
-            @Override
-            public void recycle() { }
-        };
-    }
-
-    @Test
-    public void testReturnsDrawableOnFirstGet() {
-        assertEquals(drawable, resource.get());
-    }
-
-    @Test
-    public void testReturnsNewDrawableOnSecondGet() {
-        GifDrawable expected = mock(GifDrawable.class);
-        Drawable.ConstantState constantState = mock(Drawable.ConstantState.class);
-        when(constantState.newDrawable()).thenReturn(expected);
-        when(drawable.getConstantState()).thenReturn(constantState);
-
-        assertEquals(drawable, resource.get());
-        assertEquals(expected, resource.get());
-
-        verify(drawable).getConstantState();
-        verify(constantState).newDrawable();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfDrawableIsNull() {
-        new DrawableResource<TestDrawable>(null) {
-            @Override
-            public int getSize() {
-                return 0;
-            }
-
-            @Override
-            public void recycle() {
-
-            }
-        };
-    }
-
-    /** Just to have a type to test with which is not directly Drawable */
-    private static class TestDrawable extends Drawable {
-        @Override
-        public void draw(Canvas canvas) {
-
-        }
-
-        @Override
-        public void setAlpha(int alpha) {
-
-        }
-
-        @Override
-        public void setColorFilter(ColorFilter cf) {
-
-        }
-
-        @Override
-        public int getOpacity() {
-            return 0;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
deleted file mode 100644
index 7945e50c6..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.bumptech.glide.load.resource.file;
-
-import static org.junit.Assert.assertEquals;
-
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.File;
-import java.io.IOException;
-
-@RunWith(JUnit4.class)
-public class FileDecoderTest {
-
-    private FileDecoder decoder;
-
-    @Before
-    public void setUp() {
-        decoder = new FileDecoder();
-    }
-
-    @Test
-    public void testReturnsEmptyId() {
-        assertEquals("", decoder.getId());
-    }
-
-    @Test
-    public void testReturnsGivenFileAsResource() throws IOException {
-        File expected = new File("testFile");
-        Resource<File> decoded = decoder.decode(expected, 1, 1);
-
-        assertEquals(expected, decoded.get());
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileToStreamDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileToStreamDecoderTest.java
deleted file mode 100644
index 54be3238f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileToStreamDecoderTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package com.bumptech.glide.load.resource.file;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(JUnit4.class)
-public class FileToStreamDecoderTest {
-
-    private ResourceDecoder<InputStream, Object> streamDecoder;
-    private FileToStreamDecoder<Object> decoder;
-    private FileToStreamDecoder.FileOpener fileOpener;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        fileOpener = mock(FileToStreamDecoder.FileOpener.class);
-        streamDecoder = mock(ResourceDecoder.class);
-        decoder = new FileToStreamDecoder<Object>(streamDecoder, fileOpener);
-    }
-
-    @Test
-    public void testHasEmptyId() {
-        assertEquals("", decoder.getId());
-    }
-
-    @Test
-    public void testReturnsResourceFromStreamDecoder() throws IOException {
-        File file = new File("test");
-        InputStream expected = new ByteArrayInputStream(new byte[0]);
-        when(fileOpener.open(eq(file))).thenReturn(expected);
-        Resource<Object> resource = mock(Resource.class);
-        int width = 123;
-        int height = 456;
-
-        when(streamDecoder.decode(eq(expected), eq(width), eq(height))).thenReturn(resource);
-
-        assertEquals(resource, decoder.decode(file, width, height));
-    }
-
-    @Test
-    public void testClosesStream() throws IOException {
-        InputStream is = mock(InputStream.class);
-        when(fileOpener.open(any(File.class))).thenReturn(is);
-
-        decoder.decode(new File("test"), 100, 100);
-
-        verify(is).close();
-    }
-
-    @Test
-    public void testClosesStreamIfStreamDecoderThrows() throws IOException {
-        InputStream is = mock(InputStream.class);
-        when(fileOpener.open(any(File.class))).thenReturn(is);
-
-        when(streamDecoder.decode(eq(is), anyInt(), anyInt())).thenThrow(new IOException("Test streamDecoder failed"));
-
-        try {
-            decoder.decode(new File("test"), 100, 100);
-        } catch (IOException e) {
-            // Expected.
-        }
-
-        verify(is).close();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
deleted file mode 100644
index 831b62283..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
-
-import com.bumptech.glide.util.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifDrawableResourceTest {
-    private GifDrawable drawable;
-    private GifDrawableResource resource;
-
-    @Before
-    public void setUp() {
-        drawable = mock(GifDrawable.class);
-        resource = new GifDrawableResource(drawable);
-    }
-
-    @Test
-    public void testReturnsDrawableOnFirstGet() {
-        assertEquals(drawable, resource.get());
-    }
-
-    @Test
-    public void testReturnsNewDrawableOnSecondGet() {
-        GifDrawable expected = mock(GifDrawable.class);
-        Drawable.ConstantState constantState = mock(Drawable.ConstantState.class);
-        when(constantState.newDrawable()).thenReturn(expected);
-        when(drawable.getConstantState()).thenReturn(constantState);
-
-        resource.get();
-        assertEquals(expected, resource.get());
-    }
-
-    @Test
-    public void testReturnsDrawableSizePlusFirstFrameSize() {
-        final int size = 2134;
-        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(drawable.getFirstFrame()).thenReturn(firstFrame);
-        when(drawable.getData()).thenReturn(new byte[size]);
-
-        assertEquals(size + Util.getBitmapByteSize(firstFrame), resource.getSize());
-    }
-
-    @Test
-    public void testStopsAndThenRecyclesDrawableWhenRecycled() {
-        resource.recycle();
-
-        InOrder inOrder = inOrder(drawable);
-        inOrder.verify(drawable).stop();
-        inOrder.verify(drawable).recycle();
-    }
-
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
deleted file mode 100644
index 77aca52a5..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ /dev/null
@@ -1,607 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.ColorFilter;
-import android.graphics.Paint;
-import android.graphics.PixelFormat;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.os.Build;
-
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.gifdecoder.GifHeader;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-import com.bumptech.glide.tests.GlideShadowLooper;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
-public class GifDrawableTest {
-    private GifDecoder gifDecoder;
-    private GifDrawable drawable;
-    private Drawable.Callback cb;
-    private int frameHeight;
-    private int frameWidth;
-    private Bitmap firstFrame;
-    private BitmapPool bitmapPool;
-    private int initialSdkVersion;
-    private GifFrameLoader frameLoader;
-    private Paint paint;
-
-    @Before
-    public void setUp() {
-        frameWidth = 120;
-        frameHeight = 450;
-        cb = mock(Drawable.Callback.class);
-        gifDecoder = mock(GifDecoder.class);
-        firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-        bitmapPool = mock(BitmapPool.class);
-        frameLoader = mock(GifFrameLoader.class);
-        paint = mock(Paint.class);
-        drawable = new GifDrawable(gifDecoder, frameLoader, firstFrame, bitmapPool, paint);
-        drawable.setCallback(cb);
-        initialSdkVersion = Build.VERSION.SDK_INT;
-    }
-
-    @After
-    public void tearDown() {
-        Util.setSdkVersionInt(initialSdkVersion);
-    }
-
-    @Test
-    public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
-        Canvas canvas = mock(Canvas.class);
-        drawable.draw(canvas);
-
-        verify(canvas).drawBitmap(eq(firstFrame), anyRect(), anyRect(), anyPaint());
-    }
-
-    @Test
-    public void testShouldNotDrawNullBitmapFrame() {
-        Canvas canvas = mock(Canvas.class);
-        drawable = new GifDrawable(gifDecoder, frameLoader, firstFrame, bitmapPool, paint);
-        drawable.onFrameReady(0);
-        when(frameLoader.getCurrentFrame()).thenReturn(null);
-        drawable.draw(canvas);
-
-        verify(canvas).drawBitmap(eq(firstFrame), anyRect(), anyRect(), anyPaint());
-        verify(canvas, never()).drawBitmap((Bitmap) isNull(), anyRect(), anyRect(), anyPaint());
-    }
-
-    @Test
-    public void testDoesNotDrawNullFirstFrame() {
-        drawable = new GifDrawable(gifDecoder, frameLoader, null, bitmapPool, paint);
-        Canvas canvas = mock(Canvas.class);
-
-        verify(canvas, never()).drawBitmap(any(Bitmap.class), anyRect(), anyRect(), anyPaint());
-    }
-
-    @Test
-    public void testDoesDrawCurrentFrameIfOneIsAvailable() {
-        Canvas canvas = mock(Canvas.class);
-        Bitmap currentFrame = Bitmap.createBitmap(100123, 123141, Bitmap.Config.ARGB_4444);
-        when(frameLoader.getCurrentFrame()).thenReturn(currentFrame);
-
-        drawable.draw(canvas);
-        verify(canvas).drawBitmap(eq(currentFrame), anyRect(), anyRect(), anyPaint());
-        verify(canvas, never()).drawBitmap(eq(firstFrame), anyRect(), anyRect(), anyPaint());
-    }
-
-    @Test
-    public void testRequestsNextFrameOnStart() {
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        verify(frameLoader).start();
-    }
-
-    @Test
-    public void testRequestsNextFrameOnStartWithoutCallToSetVisible() {
-        drawable.start();
-
-        verify(frameLoader).start();
-    }
-
-    @Test
-    public void testDoesNotRequestNextFrameOnStartIfGotCallToSetVisibleWithVisibleFalse() {
-        drawable.setVisible(false, false);
-        drawable.start();
-
-        verify(frameLoader, never()).start();
-    }
-
-    @Test
-    public void testDoesNotRequestNextFrameOnStartIfHasSingleFrame() {
-        when(gifDecoder.getFrameCount()).thenReturn(1);
-        drawable.setVisible(true, false);
-        drawable.start();
-
-        verify(frameLoader, never()).start();
-    }
-
-    @Test
-    public void testInvalidatesSelfOnStartIfHasSingleFrame() {
-        when(gifDecoder.getFrameCount()).thenReturn(1);
-        drawable.setVisible(true, false);
-        drawable.start();
-
-        verify(cb).invalidateDrawable(eq(drawable));
-    }
-
-    @Test
-    public void testShouldInvalidateSelfOnRun() {
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        verify(cb).invalidateDrawable(eq(drawable));
-    }
-
-    @Test
-    public void testShouldNotScheduleItselfIfAlreadyRunning() {
-        drawable.setVisible(true, true);
-        drawable.start();
-        drawable.start();
-
-        verify(frameLoader, times(1)).start();
-    }
-
-    @Test
-    public void testReturnsFalseFromIsRunningWhenNotRunning() {
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testReturnsTrueFromIsRunningWhenRunning() {
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        assertTrue(drawable.isRunning());
-    }
-
-    @Test
-    public void testInvalidatesSelfWhenFrameReady() {
-        drawable.setIsRunning(true);
-        drawable.onFrameReady(0);
-
-        verify(cb).invalidateDrawable(eq(drawable));
-    }
-
-    @Test
-    public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfHasNoCallback() {
-        drawable.setIsRunning(true);
-        drawable.setCallback(null);
-        drawable.onFrameReady(0);
-
-        verify(frameLoader).stop();
-    }
-
-    @Test
-    public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
-        drawable.setIsRunning(true);
-        drawable.setCallback(null);
-        drawable.onFrameReady(0);
-
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testDoesNotStopWhenCurrentFrameFinishesIfHasNoCallbackAndIsPreHoneycomb() {
-        Util.setSdkVersionInt(10);
-
-        drawable.setIsRunning(true);
-        drawable.setCallback(null);
-        drawable.onFrameReady(0);
-
-        assertTrue(drawable.isRunning());
-    }
-
-    @Test
-    public void testResetsFrameManagerWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
-        drawable.setIsRunning(true);
-        drawable.setCallback(null);
-        drawable.onFrameReady(0);
-
-        verify(frameLoader).clear();
-    }
-
-    @Test
-    public void testDoesNotResetFrameManagerWhenCurrentFinishesIfHasNoCallbackPreHoneycomb() {
-        Util.setSdkVersionInt(10);
-
-        drawable.setIsRunning(true);
-        drawable.setCallback(null);
-        drawable.onFrameReady(0);
-
-        verify(frameLoader, never()).clear();
-    }
-
-    @Test
-    public void testSetsIsRunningFalseOnStop() {
-        drawable.start();
-        drawable.stop();
-
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testStopsOnSetVisibleFalse() {
-        drawable.start();
-
-        drawable.setVisible(false, true);
-
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testDoesNotResetOnStopIfAtLeastAtHoneycomb() {
-        drawable.start();
-        drawable.stop();
-
-        verify(frameLoader, never()).clear();
-        // invalidate once from start.
-        verify(cb, times(1)).invalidateDrawable(eq(drawable));
-    }
-
-    @Test
-    public void testDoesResetOnStopIfPreHoneycomb() {
-        Util.setSdkVersionInt(10);
-        drawable.start();
-        drawable.stop();
-
-        verify(frameLoader).clear();
-        verify(cb, times(2)).invalidateDrawable(eq(drawable));
-    }
-
-    @Test
-    public void testStartsOnSetVisibleTrueIfRunning() {
-        drawable.start();
-        drawable.setVisible(false, false);
-        drawable.setVisible(true, true);
-
-        assertTrue(drawable.isRunning());
-    }
-
-    @Test
-    public void testDoesNotStartOnVisibleTrueIfNotRunning() {
-        drawable.setVisible(true, true);
-
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testDoesNotStartOnSetVisibleIfStartedAndStopped() {
-        drawable.start();
-        drawable.stop();
-        drawable.setVisible(true, true);
-
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testDoesNotImmediatelyRunIfStartedWhileNotVisible() {
-        drawable.setVisible(false, false);
-        drawable.start();
-
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testGetOpacityReturnsTransparent() {
-        assertEquals(PixelFormat.TRANSPARENT, drawable.getOpacity());
-    }
-
-    @Test
-    public void testReturnsFrameCountFromDecoder() {
-        int expected = 4;
-        when(gifDecoder.getFrameCount()).thenReturn(expected);
-
-        assertEquals(expected, drawable.getFrameCount());
-    }
-
-    @Test
-    public void testRecycleCallsClearOnFrameManager() {
-        drawable.recycle();
-
-        verify(frameLoader).clear();
-    }
-
-    @Test
-    public void testRecycleReturnsFirstFrameToPool() {
-        drawable.recycle();
-
-        verify(bitmapPool).put(eq(firstFrame));
-    }
-
-    @Test
-    public void testIsNotRecycledIfNotRecycled() {
-        assertFalse(drawable.isRecycled());
-    }
-
-    @Test
-    public void testIsRecycledAfterRecycled() {
-        drawable.recycle();
-
-        assertTrue(drawable.isRecycled());
-    }
-
-    @Test
-    public void testReturnsNonNullConstantState() {
-        assertNotNull(drawable.getConstantState());
-    }
-
-    @Test
-    public void testReturnsNewDrawableFromConstantState() {
-        GifHeader gifHeader = new GifHeader();
-        Transformation<Bitmap> transformation = mock(Transformation.class);
-        GifDecoder.BitmapProvider provider = mock(GifDecoder.BitmapProvider.class);
-        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,
-                new byte[0], firstFrame);
-
-        assertNotNull(drawable.getConstantState().newDrawable());
-        assertNotNull(drawable.getConstantState().newDrawable(Robolectric.application.getResources()));
-    }
-
-    @Test
-    public void testReturnsFrameWidthAndHeightForIntrinsictDimensions() {
-        assertEquals(frameWidth, drawable.getIntrinsicWidth());
-        assertEquals(frameHeight, drawable.getIntrinsicHeight());
-    }
-
-    @Test
-    public void testIsAnimated() {
-        assertTrue(drawable.isAnimated());
-    }
-
-    @Test
-    public void testLoopsASingleTimeIfLoopCountIsSetToOne() {
-        final int loopCount = 1;
-        final int frameCount = 2;
-        when(gifDecoder.getFrameCount()).thenReturn(frameCount);
-        drawable.setLoopCount(loopCount);
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        runLoops(loopCount, frameCount);
-
-        verifyRanLoops(loopCount, frameCount);
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testLoopsForeverIfLoopCountIsSetToLoopForever() {
-        final int loopCount = 40;
-        final int frameCount = 2;
-
-        when(gifDecoder.getFrameCount()).thenReturn(frameCount);
-        drawable.setLoopCount(GifDrawable.LOOP_FOREVER);
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        runLoops(loopCount, frameCount);
-
-        verifyRanLoops(loopCount, frameCount);
-    }
-
-    @Test
-    public void testLoopsOnceIfLoopCountIsSetToOneWithThreeFrames() {
-        final int loopCount = 1;
-        final int frameCount = 3;
-
-        when(gifDecoder.getFrameCount()).thenReturn(frameCount);
-        drawable.setLoopCount(loopCount);
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        runLoops(loopCount, frameCount);
-
-        verifyRanLoops(loopCount, frameCount);
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testLoopsThreeTimesIfLoopCountIsSetToThree() {
-        final int loopCount = 3;
-        final int frameCount = 2;
-
-        when(gifDecoder.getFrameCount()).thenReturn(frameCount);
-        drawable.setLoopCount(loopCount);
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        runLoops(loopCount, frameCount);
-
-        verifyRanLoops(loopCount, frameCount);
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testCallingStartResetsLoopCounter() {
-        when(gifDecoder.getFrameCount()).thenReturn(2);
-        drawable.setLoopCount(1);
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        drawable.onFrameReady(0);
-        drawable.onFrameReady(1);
-
-        drawable.start();
-
-        drawable.onFrameReady(0);
-        drawable.onFrameReady(1);
-
-        // 4 onFrameReady(), 2 start()
-        verify(cb, times(4 + 2)).invalidateDrawable(eq(drawable));
-        assertFalse(drawable.isRunning());
-    }
-
-    @Test
-    public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
-        final int initialLoopCount = 1;
-        final int frameCount = 2;
-
-        when(gifDecoder.getFrameCount()).thenReturn(frameCount);
-        drawable.setLoopCount(initialLoopCount);
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        runLoops(initialLoopCount, frameCount);
-
-        final int newLoopCount = 2;
-
-        drawable.setLoopCount(newLoopCount);
-        drawable.start();
-
-        runLoops(newLoopCount, frameCount);
-
-        int numStarts = 2;
-        int expectedFrames = (initialLoopCount + newLoopCount) * frameCount + numStarts;
-        verify(cb, times(expectedFrames)).invalidateDrawable(eq(drawable));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenLoopCountLessThanZeroAndNotInfinite() {
-        drawable.setLoopCount(-2);
-    }
-
-    @Test
-    public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
-        final int frameCount = 3;
-        final int loopCount = 2;
-        when(gifDecoder.getLoopCount()).thenReturn(loopCount);
-        when(gifDecoder.getFrameCount()).thenReturn(frameCount);
-        drawable.setLoopCount(GlideDrawable.LOOP_INTRINSIC);
-        drawable.setVisible(true, true);
-        drawable.start();
-
-        runLoops(loopCount, frameCount);
-
-        verifyRanLoops(loopCount, frameCount);
-    }
-
-    @Test
-    public void testDoesNotDrawFrameAfterRecycle() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
-        drawable.setVisible(true, true);
-        drawable.start();
-        when(frameLoader.getCurrentFrame()).thenReturn(bitmap);
-        drawable.onFrameReady(1);
-        drawable.recycle();
-        Canvas canvas = mock(Canvas.class);
-        drawable.draw(canvas);
-        verify(canvas, never()).drawBitmap(any(Bitmap.class), anyRect(), anyRect(), anyPaint());
-    }
-
-    @Test
-    public void testSetsFrameTransformationOnFrameManager() {
-        Transformation<Bitmap> transformation = mock(Transformation.class);
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        drawable.setFrameTransformation(transformation, bitmap);
-
-        verify(frameLoader).setFrameTransformation(eq(transformation));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfSetFrameTransformationIsCalledWithANullFrame() {
-        drawable.setFrameTransformation(mock(Transformation.class), null);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfSetFrameTransformationIsCalledWithANullTransformation() {
-        drawable.setFrameTransformation(null, Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfConstructedWIthNullFirstFrame() {
-        new GifDrawable(Robolectric.application, mock(GifDecoder.BitmapProvider.class), mock(BitmapPool.class),
-                mock(Transformation.class), 100, 100, mock(GifHeader.class), new byte[0], null);
-    }
-
-    @Test
-    public void testAppliesGravityOnDrawAfterBoundsChange() {
-        Rect bounds = new Rect(0, 0, frameWidth * 2, frameHeight * 2);
-        drawable.setBounds(bounds);
-
-        Canvas canvas = mock(Canvas.class);
-        drawable.draw(canvas);
-
-        verify(canvas).drawBitmap(any(Bitmap.class), (Rect) isNull(), eq(bounds), eq(paint));
-    }
-
-    @Test
-    public void testSetAlphaSetsAlphaOnPaint() {
-        int alpha = 100;
-        drawable.setAlpha(alpha);
-        verify(paint).setAlpha(eq(alpha));
-    }
-
-    @Test
-    public void testSetColorFilterSetsColorFilterOnPaint() {
-        ColorFilter colorFilter = new ColorFilter();
-        drawable.setColorFilter(colorFilter);
-        verify(paint).setColorFilter(eq(colorFilter));
-    }
-
-    @Test
-    public void testGetDecoderReturnsGivenDecoder() {
-        assertEquals(gifDecoder, drawable.getDecoder());
-    }
-
-    @Test
-    public void testReturnsCurrentTransformationInGetFrameTransformation() {
-        Transformation<Bitmap> newTransformation = mock(Transformation.class);
-        drawable.setFrameTransformation(newTransformation, Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
-
-        assertEquals(newTransformation, drawable.getFrameTransformation());
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfCreatedWithNullState() {
-        new GifDrawable(null);
-    }
-
-    private void verifyRanLoops(int loopCount, int frameCount) {
-        // 1 for invalidate in start().
-        verify(cb, times(1 + loopCount * frameCount)).invalidateDrawable(eq(drawable));
-    }
-
-    private static Paint anyPaint() {
-        return any(Paint.class);
-    }
-
-    private static Rect anyRect() {
-        return any(Rect.class);
-    }
-
-    private void runLoops(int loopCount, int frameCount) {
-        for (int loop = 0; loop < loopCount; loop++) {
-            for (int frame = 0; frame < frameCount; frame++) {
-                drawable.onFrameReady(frame);
-            }
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
deleted file mode 100644
index 71d1825f6..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.UnitTransformation;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifDrawableTransformationTest {
-    Transformation<Bitmap> wrapped;
-    GifDrawableTransformation transformation;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        wrapped = mock(Transformation.class);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        transformation = new GifDrawableTransformation(wrapped, bitmapPool);
-    }
-
-    @Test
-    public void testReturnsWrappedTransformationId() {
-        final String id = "testId";
-        when(wrapped.getId()).thenReturn(id);
-
-        assertEquals(id, transformation.getId());
-    }
-
-    @Test
-    public void testSetsTransformationAsFrameTransformation() {
-        Resource<GifDrawable> resource = mock(Resource.class);
-        GifDrawable gifDrawable = mock(GifDrawable.class);
-        Transformation<Bitmap> unitTransformation = UnitTransformation.get();
-        when(gifDrawable.getFrameTransformation()).thenReturn(unitTransformation);
-        when(gifDrawable.getIntrinsicWidth()).thenReturn(500);
-        when(gifDrawable.getIntrinsicHeight()).thenReturn(500);
-        when(resource.get()).thenReturn(gifDrawable);
-
-        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(gifDrawable.getFirstFrame()).thenReturn(firstFrame);
-
-        final int width = 123;
-        final int height = 456;
-        Bitmap expectedBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-        Resource<Bitmap> expectedResource = mock(Resource.class);
-        when(expectedResource.get()).thenReturn(expectedBitmap);
-        when(wrapped.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(expectedResource);
-
-        transformation.transform(resource, width, height);
-
-        verify(gifDrawable).setFrameTransformation(any(Transformation.class), eq(expectedBitmap));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
deleted file mode 100644
index bc18c8f97..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ /dev/null
@@ -1,216 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.google.common.testing.EqualsTester;
-
-import android.graphics.Bitmap;
-import android.os.Handler;
-import android.os.Message;
-
-import com.bumptech.glide.GenericRequestBuilder;
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.request.Request;
-import com.bumptech.glide.request.target.Target;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.UUID;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifFrameLoaderTest {
-
-    private GifFrameLoader.FrameCallback callback;
-    private GifDecoder gifDecoder;
-    private Handler handler;
-    private GenericRequestBuilder<GifDecoder, GifDecoder, Bitmap, Bitmap> requestBuilder;
-    private GifFrameLoader loader;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        callback = mock(GifFrameLoader.FrameCallback.class);
-        gifDecoder = mock(GifDecoder.class);
-        handler = mock(Handler.class);
-        when(handler.obtainMessage(anyInt(), anyObject())).thenReturn(mock(Message.class));
-
-        requestBuilder = mock(GenericRequestBuilder.class);
-
-        loader = new GifFrameLoader(callback, gifDecoder, handler, requestBuilder);
-        when(requestBuilder.signature(any(Key.class))).thenReturn(requestBuilder);
-    }
-
-    @Test
-    public void testSetFrameTransformationSetsTransformationOnRequestBuilder() {
-        Transformation<Bitmap> transformation = mock(Transformation.class);
-        loader.setFrameTransformation(transformation);
-
-        verify(requestBuilder).transform(eq(transformation));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testSetFrameTransformationThrowsIfGivenNullTransformation() {
-        loader.setFrameTransformation(null);
-    }
-
-    @Test
-    public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
-        loader.start();
-
-        verify(requestBuilder).into(any(Target.class));
-    }
-
-    @Test
-    public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingLoad() {
-        loader.start();
-
-        InOrder order = inOrder(gifDecoder, requestBuilder);
-        order.verify(gifDecoder).advance();
-        order.verify(requestBuilder).signature(any(Key.class));
-        order.verify(requestBuilder).into(any(Target.class));
-    }
-
-    @Test
-    public void testGetCurrentFrameReturnsNullWhenNoLoadHasCompleted() {
-        assertNull(loader.getCurrentFrame());
-    }
-
-    @Test
-    public void testGetCurrentFrameReturnsCurrentBitmapAfterLoadHasCompleted() {
-        final Bitmap result = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
-        GifFrameLoader.DelayTarget target = mock(GifFrameLoader.DelayTarget.class);
-        when(target.getResource()).thenReturn(result);
-        loader.onFrameReady(target);
-
-        assertEquals(result, loader.getCurrentFrame());
-    }
-
-    @Test
-    public void testStartDoesNotStartIfAlreadyRunning() {
-        loader.start();
-        loader.start();
-
-        verify(requestBuilder, times(1)).into(any(Target.class));
-    }
-
-    @Test
-    public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
-        loader.onFrameReady(mock(GifFrameLoader.DelayTarget.class));
-
-        verify(requestBuilder, never()).into(any(Target.class));
-    }
-
-    @Test
-    public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
-        loader.start();
-        loader.stop();
-        loader.start();
-
-        verify(requestBuilder, times(1)).into(any(Target.class));
-    }
-
-    @Test
-    public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
-        loader.start();
-        loader.stop();
-
-        loader.onFrameReady(mock(GifFrameLoader.DelayTarget.class));
-        loader.start();
-
-        verify(requestBuilder, times(2)).into(any(Target.class));
-    }
-
-    @Test
-    public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
-        loader.start();
-        loader.onFrameReady(mock(GifFrameLoader.DelayTarget.class));
-
-        verify(requestBuilder, times(2)).into(any(Target.class));
-    }
-
-    @Test
-    public void testOnFrameReadyClearsPreviousFrame() {
-        // Force the loader to create a real Handler.
-        loader = new GifFrameLoader(callback, gifDecoder, null /*handler*/, requestBuilder);
-
-        GifFrameLoader.DelayTarget previous = mock(GifFrameLoader.DelayTarget.class);
-        Request previousRequest = mock(Request.class);
-        when(previous.getRequest()).thenReturn(previousRequest);
-
-        loader.onFrameReady(previous);
-        loader.onFrameReady(mock(GifFrameLoader.DelayTarget.class));
-
-        verify(previousRequest).clear();
-    }
-
-    @Test
-    public void testDelayTargetSendsMessageWithHandlerDelayed() {
-        long targetTime = 1234;
-        GifFrameLoader.DelayTarget delayTarget = new GifFrameLoader.DelayTarget(handler, 1, targetTime);
-        delayTarget.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null /*glideAnimation*/);
-        verify(handler).sendMessageAtTime(any(Message.class), eq(targetTime));
-    }
-
-    @Test
-    public void testDelayTargetSetsResourceOnResourceReady() {
-        GifFrameLoader.DelayTarget delayTarget = new GifFrameLoader.DelayTarget(handler, 1, 1);
-        Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
-        delayTarget.onResourceReady(expected, null /*glideAnimation*/);
-
-        assertEquals(expected, delayTarget.getResource());
-    }
-
-    @Test
-    public void testClearsCompletedLoadOnFrameReadyIfCleared() {
-        // Force the loader to create a real Handler.
-        loader = new GifFrameLoader(callback, gifDecoder, null /*handler*/, requestBuilder);
-        loader.clear();
-        GifFrameLoader.DelayTarget delayTarget = mock(GifFrameLoader.DelayTarget.class);
-        Request request = mock(Request.class);
-        when(delayTarget.getRequest()).thenReturn(request);
-
-        loader.onFrameReady(delayTarget);
-
-        verify(request).clear();
-    }
-
-    @Test
-    public void testDoesNotReturnResourceForCompletedFrameInGetCurrentFrameIfLoadCompletesWhileCleared() {
-        loader.clear();
-        GifFrameLoader.DelayTarget delayTarget = mock(GifFrameLoader.DelayTarget.class);
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(delayTarget.getResource()).thenReturn(bitmap);
-
-        loader.onFrameReady(delayTarget);
-
-        assertNull(loader.getCurrentFrame());
-    }
-
-    @Test
-    public void testFrameSignatureEquality() {
-        UUID first = UUID.randomUUID();
-        new EqualsTester()
-                .addEqualityGroup(new GifFrameLoader.FrameSignature(first), new GifFrameLoader.FrameSignature(first))
-                .addEqualityGroup(new GifFrameLoader.FrameSignature())
-                .testEquals();
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java
deleted file mode 100644
index 22b896885..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.gifdecoder.GifDecoder;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GifFrameModelLoaderTest {
-    private GifFrameModelLoader loader;
-    private GifDecoder decoder;
-
-    @Before
-    public void setUp() {
-        loader = new GifFrameModelLoader();
-        decoder = mock(GifDecoder.class);
-    }
-
-    @Test
-    public void testFetcherIdIncludesFrameIndex() {
-        String id = "asdfasd";
-        int frameIndex = 124;
-        when(decoder.getCurrentFrameIndex()).thenReturn(frameIndex);
-
-        String fetcherId = loader.getResourceFetcher(decoder, 1, 2).getId();
-
-        assertThat(fetcherId).contains(String.valueOf(frameIndex));
-    }
-
-    @Test
-    public void testAlwaysReturnsGivenDecoderFromFetcher() throws Exception {
-        assertEquals(decoder, loader.getResourceFetcher(decoder, 100, 100).loadData(Priority.NORMAL));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
deleted file mode 100644
index f5641b34f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifFrameResourceDecoderTest {
-    private GifDecoder gifDecoder;
-    private GifFrameResourceDecoder resourceDecoder;
-
-    @Before
-    public void setUp() {
-        gifDecoder = mock(GifDecoder.class);
-        resourceDecoder = new GifFrameResourceDecoder(mock(BitmapPool.class));
-    }
-
-    @Test
-    public void testReturnsValidId() {
-        Util.assertClassHasValidId(GifFrameResourceDecoder.class, resourceDecoder.getId());
-    }
-
-    @Test
-    public void testReturnsFrameFromGifDecoder() throws IOException {
-        Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-        when(gifDecoder.getNextFrame()).thenReturn(expected);
-
-        assertEquals(expected, resourceDecoder.decode(gifDecoder, 100, 100).get());
-    }
-
-    @Test
-    public void testReturnsNullIfGifDecoderReturnsNullFrame() {
-        when(gifDecoder.getNextFrame()).thenReturn(null);
-
-        assertNull(resourceDecoder.decode(gifDecoder, 100, 100));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java
deleted file mode 100644
index b919b7264..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java
+++ /dev/null
@@ -1,179 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.gifdecoder.GifHeader;
-import com.bumptech.glide.gifdecoder.GifHeaderParser;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.GlideShadowLooper;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.mockito.Mockito;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
-public class GifResourceDecoderTest {
-    private GifResourceDecoder decoder;
-    private GifHeaderParser parser;
-    private GifResourceDecoder.GifHeaderParserPool parserPool;
-    private GifResourceDecoder.GifDecoderPool decoderPool;
-    private GifDecoder gifDecoder;
-    private GifHeader gifHeader;
-
-    @Before
-    public void setUp() {
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-
-        gifHeader = Mockito.spy(new GifHeader());
-        parser = mock(GifHeaderParser.class);
-        when(parser.parseHeader()).thenReturn(gifHeader);
-        parserPool = mock(GifResourceDecoder.GifHeaderParserPool.class);
-        when(parserPool.obtain(any(byte[].class))).thenReturn(parser);
-
-        gifDecoder = mock(GifDecoder.class);
-        decoderPool = mock(GifResourceDecoder.GifDecoderPool.class);
-        when(decoderPool.obtain(any(GifDecoder.BitmapProvider.class))).thenReturn(gifDecoder);
-
-        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, parserPool, decoderPool);
-    }
-
-    @Test
-    public void testReturnsNullIfParsedHeaderHasZeroFrames() throws IOException {
-        when(gifHeader.getNumFrames()).thenReturn(0);
-
-        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));
-    }
-
-    @Test
-    public void testReturnsNullIfParsedHeaderHasFormatError() {
-        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_FORMAT_ERROR);
-
-        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));
-    }
-
-    @Test
-    public void testReturnsNullIfParsedHeaderHasOpenError() {
-        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OPEN_ERROR);
-
-        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));
-    }
-
-    @Test
-    public void testReturnsParserToPool() throws IOException {
-        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);
-        verify(parserPool).release(eq(parser));
-    }
-
-    @Test
-    public void testReturnsParserToPoolWhenParserThrows() {
-        when(parser.parseHeader()).thenThrow(new RuntimeException("Test"));
-        try {
-            decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);
-            fail("Failed to receive expected exception");
-        } catch (RuntimeException e) {
-            // Expected.
-        }
-
-        verify(parserPool).release(eq(parser));
-    }
-
-    @Test
-    public void testDecodesFirstFrameAndReturnsGifDecoderToPool() {
-        when(gifHeader.getNumFrames()).thenReturn(1);
-        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);
-        when(gifDecoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
-
-        byte[] data = new byte[100];
-        decoder.decode(new ByteArrayInputStream(data), 100, 100);
-
-        InOrder order = inOrder(decoderPool, gifDecoder);
-        order.verify(decoderPool).obtain(any(GifDecoder.BitmapProvider.class));
-        order.verify(gifDecoder).setData(eq(gifHeader), eq(data));
-        order.verify(gifDecoder).advance();
-        order.verify(gifDecoder).getNextFrame();
-        order.verify(decoderPool).release(eq(gifDecoder));
-    }
-
-    @Test
-    public void testReturnsGifDecoderToPoolWhenDecoderThrows() {
-        when(gifHeader.getNumFrames()).thenReturn(1);
-        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);
-        when(gifDecoder.getNextFrame()).thenThrow(new RuntimeException("test"));
-        try {
-            decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);
-            fail("Failed to receive expected exception");
-        } catch (RuntimeException e) {
-            // Expected.
-        }
-
-        verify(decoderPool).release(eq(gifDecoder));
-    }
-
-    @Test
-    public void testReturnsNullIfGifDecoderFailsToDecodeFirstFrame() {
-        when(gifHeader.getNumFrames()).thenReturn(1);
-        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);
-        when(gifDecoder.getNextFrame()).thenReturn(null);
-
-        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));
-    }
-
-    @Test
-    public void testReturnsGifDecoderToPoolWhenGifDecoderReturnsNullFirstFrame() {
-        when(gifHeader.getNumFrames()).thenReturn(1);
-        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);
-        when(gifDecoder.getNextFrame()).thenReturn(null);
-
-        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);
-
-        verify(decoderPool).release(eq(gifDecoder));
-    }
-
-    @Test
-    public void testCanObtainNonNullDecoderFromPool() {
-        GifDecoder.BitmapProvider provider = mock(GifDecoder.BitmapProvider.class);
-        GifResourceDecoder.GifDecoderPool pool = new GifResourceDecoder.GifDecoderPool();
-        assertNotNull(pool.obtain(provider));
-    }
-
-    @Test
-    public void testCanPutAndObtainDecoderFromPool() {
-        GifResourceDecoder.GifDecoderPool pool = new GifResourceDecoder.GifDecoderPool();
-        pool.release(gifDecoder);
-        GifDecoder fromPool = pool.obtain(mock(GifDecoder.BitmapProvider.class));
-        assertEquals(gifDecoder, fromPool);
-    }
-
-    @Test
-    public void testDecoderPoolClearsDecoders() {
-        GifResourceDecoder.GifDecoderPool pool = new GifResourceDecoder.GifDecoderPool();
-        pool.release(gifDecoder);
-        verify(gifDecoder).clear();
-    }
-
-    @Test
-    public void testHasValidId() {
-        assertEquals("", decoder.getId());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceEncoderTest.java
deleted file mode 100644
index 7cfacd0ad..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceEncoderTest.java
+++ /dev/null
@@ -1,268 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.gifdecoder.GifHeader;
-import com.bumptech.glide.gifdecoder.GifHeaderParser;
-import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.UnitTransformation;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifResourceEncoderTest {
-    private Resource<GifDrawable> resource;
-    private GifResourceEncoder encoder;
-    private GifDecoder decoder;
-    private GifHeaderParser parser;
-    private AnimatedGifEncoder gifEncoder;
-    private GifDrawable gifDrawable;
-    private Resource<Bitmap> frameResource;
-    private Transformation frameTransformation;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        resource = mock(Resource.class);
-
-        GifResourceEncoder.Factory factory = mock(GifResourceEncoder.Factory.class);
-        decoder = mock(GifDecoder.class);
-        when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
-        parser = mock(GifHeaderParser.class);
-        when(factory.buildParser()).thenReturn(parser);
-        gifEncoder = mock(AnimatedGifEncoder.class);
-        when(factory.buildEncoder()).thenReturn(gifEncoder);
-        frameResource = mock(Resource.class);
-        when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class))).thenReturn(frameResource);
-
-        frameTransformation = mock(Transformation.class);
-        when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(frameResource);
-
-        gifDrawable = mock(GifDrawable.class);
-        when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
-        when(gifDrawable.getData()).thenReturn(new byte[0]);
-
-        when(resource.get()).thenReturn(gifDrawable);
-
-        encoder = new GifResourceEncoder(mock(BitmapPool.class), factory);
-    }
-
-    @Test
-    public void testReturnsFalseIfEncoderFailsToStart() {
-        OutputStream os = mock(OutputStream.class);
-        when(gifEncoder.start(eq(os))).thenReturn(false);
-        assertFalse(encoder.encode(resource, mock(OutputStream.class)));
-    }
-
-    @Test
-    public void testSetsDataOnParserBeforeParsingHeader() {
-        byte[] data = new byte[1];
-        when(gifDrawable.getData()).thenReturn(data);
-
-        GifHeader header = mock(GifHeader.class);
-        when(parser.parseHeader()).thenReturn(header);
-
-        encoder.encode(resource, mock(OutputStream.class));
-
-        InOrder order = inOrder(parser, decoder);
-        order.verify(parser).setData(eq(data));
-        order.verify(parser).parseHeader();
-        order.verify(decoder).setData(header, data);
-    }
-
-    @Test
-    public void testAdvancesDecoderBeforeAttemptingToGetFirstFrame() {
-        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-        when(decoder.getFrameCount()).thenReturn(1);
-        when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
-
-        encoder.encode(resource, mock(OutputStream.class));
-
-        InOrder order = inOrder(decoder);
-        order.verify(decoder).advance();
-        order.verify(decoder).getNextFrame();
-    }
-
-    @Test
-    public void testSetsDelayOnEncoderAfterAddingFrame() {
-        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-        when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(true);
-
-        when(decoder.getFrameCount()).thenReturn(1);
-        when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
-        int expectedIndex = 34;
-        when(decoder.getCurrentFrameIndex()).thenReturn(expectedIndex);
-        int expectedDelay = 5000;
-        when(decoder.getDelay(eq(expectedIndex))).thenReturn(expectedDelay);
-
-        encoder.encode(resource, mock(OutputStream.class));
-
-        InOrder order = inOrder(gifEncoder, decoder);
-        order.verify(decoder).advance();
-        order.verify(gifEncoder).addFrame(any(Bitmap.class));
-        order.verify(gifEncoder).setDelay(eq(expectedDelay));
-        order.verify(decoder).advance();
-    }
-
-    @Test
-    public void testWritesSingleFrameToEncoderAndReturnsTrueIfEncoderFinishes() {
-        OutputStream os = mock(OutputStream.class);
-        Bitmap frame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(frameResource.get()).thenReturn(frame);
-
-        when(decoder.getFrameCount()).thenReturn(1);
-        when(decoder.getNextFrame()).thenReturn(frame);
-
-        when(gifEncoder.start(eq(os))).thenReturn(true);
-        when(gifEncoder.addFrame(eq(frame))).thenReturn(true);
-        when(gifEncoder.finish()).thenReturn(true);
-
-        assertTrue(encoder.encode(resource, os));
-        verify(gifEncoder).addFrame(eq(frame));
-    }
-
-    @Test
-    public void testReturnsFalseIfAddingFrameFails() {
-        when(decoder.getFrameCount()).thenReturn(1);
-        when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
-
-        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-        when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(false);
-
-        assertFalse(encoder.encode(resource, mock(OutputStream.class)));
-    }
-
-    @Test
-    public void testReturnsFalseIfFinishingFails() {
-        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-        when(gifEncoder.finish()).thenReturn(false);
-
-        assertFalse(encoder.encode(resource, mock(OutputStream.class)));
-    }
-
-    @Test
-    public void testWritesTransformedBitmaps() {
-        final Bitmap frame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(decoder.getFrameCount()).thenReturn(1);
-        when(decoder.getNextFrame()).thenReturn(frame);
-
-        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-
-        int expectedWidth = 123;
-        int expectedHeight = 456;
-        when(gifDrawable.getIntrinsicWidth()).thenReturn(expectedWidth);
-        when(gifDrawable.getIntrinsicHeight()).thenReturn(expectedHeight);
-
-        Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
-        final Resource<Bitmap> transformedResource = mock(Resource.class);
-        when(transformedResource.get()).thenReturn(transformedFrame);
-        Transformation<Bitmap> transformation = mock(Transformation.class);
-        when(transformation.transform(eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
-                .thenReturn(transformedResource);
-        when(gifDrawable.getFrameTransformation()).thenReturn(transformation);
-
-        encoder.encode(resource, mock(OutputStream.class));
-
-        verify(gifEncoder).addFrame(eq(transformedFrame));
-    }
-
-    @Test
-    public void testRecyclesFrameResourceBeforeWritingIfTransformedResourceIsDifferent() {
-        when(decoder.getFrameCount()).thenReturn(1);
-        Resource<Bitmap> transformedResource = mock(Resource.class);
-        when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
-                .thenReturn(transformedResource);
-        Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
-        when(transformedResource.get()).thenReturn(expected);
-
-        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-
-        encoder.encode(resource, mock(OutputStream.class));
-
-        InOrder order = inOrder(frameResource, gifEncoder);
-        order.verify(frameResource).recycle();
-        order.verify(gifEncoder).addFrame(eq(expected));
-    }
-
-    @Test
-    public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDifferent() {
-        when(decoder.getFrameCount()).thenReturn(1);
-        Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
-        Resource<Bitmap> transformedResource = mock(Resource.class);
-        when(transformedResource.get()).thenReturn(expected);
-        when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
-                .thenReturn(transformedResource);
-
-        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-
-        encoder.encode(resource, mock(OutputStream.class));
-
-        InOrder order = inOrder(transformedResource, gifEncoder);
-        order.verify(gifEncoder).addFrame(eq(expected));
-        order.verify(transformedResource).recycle();
-    }
-
-    @Test
-    public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed() {
-        when(decoder.getFrameCount()).thenReturn(1);
-        when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
-                .thenReturn(frameResource);
-        Bitmap expected = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
-        when(frameResource.get()).thenReturn(expected);
-
-        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-
-        encoder.encode(resource, mock(OutputStream.class));
-
-        InOrder order = inOrder(frameResource, gifEncoder);
-        order.verify(gifEncoder).addFrame(eq(expected));
-        order.verify(frameResource).recycle();
-    }
-
-    @Test
-    public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation() throws IOException {
-        when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
-        byte[] expected = "expected".getBytes();
-        when(gifDrawable.getData()).thenReturn(expected);
-
-        OutputStream os = mock(OutputStream.class);
-
-        encoder.encode(resource, os);
-
-        verify(os).write(eq(expected));
-
-        verify(gifEncoder, never()).start(any(OutputStream.class));
-        verify(parser, never()).setData(any(byte[].class));
-        verify(parser, never()).parseHeader();
-    }
-
-    @Test
-    public void testHasValidId() {
-        assertEquals("", encoder.getId());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapResourceEncoderTest.java
deleted file mode 100644
index 02ac57786..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapResourceEncoderTest.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayOutputStream;
-import java.io.OutputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifBitmapResourceEncoderTest {
-    private ResourceEncoder<Bitmap> bitmapEncoder;
-    private ResourceEncoder<GifDrawable> gifEncoder;
-    private GifBitmapWrapperResourceEncoder encoder;
-    private Resource<GifBitmapWrapper> resource;
-    private GifBitmapWrapper gifBitmap;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        bitmapEncoder = mock(ResourceEncoder.class);
-        gifEncoder = mock(ResourceEncoder.class);
-        encoder = new GifBitmapWrapperResourceEncoder(bitmapEncoder, gifEncoder);
-        resource = mock(Resource.class);
-        gifBitmap = mock(GifBitmapWrapper.class);
-        when(resource.get()).thenReturn(gifBitmap);
-    }
-
-    @Test
-    public void testEncodesWithBitmapEncoderIfHasBitmapResource() {
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-        when(gifBitmap.getBitmapResource()).thenReturn(bitmapResource);
-
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        encoder.encode(resource, os);
-
-        verify(bitmapEncoder).encode(eq(bitmapResource), eq(os));
-    }
-
-    @Test
-    public void testReturnsBitmapEncoderResultIfHasBitmapResource() {
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-        when(gifBitmap.getBitmapResource()).thenReturn(bitmapResource);
-
-        when(bitmapEncoder.encode(any(Resource.class), any(OutputStream.class))).thenReturn(true);
-        assertTrue(encoder.encode(resource, new ByteArrayOutputStream()));
-
-        when(bitmapEncoder.encode(any(Resource.class), any(OutputStream.class))).thenReturn(false);
-        assertFalse(encoder.encode(resource, new ByteArrayOutputStream()));
-    }
-
-    @Test
-    public void testEncodesWithGifEncoderIfHasGif() {
-        Resource<GifDrawable> gifResource = mock(Resource.class);
-        when(gifBitmap.getGifResource()).thenReturn(gifResource);
-
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        encoder.encode(resource, os);
-
-        verify(gifEncoder).encode(eq(gifResource), eq(os));
-    }
-
-    @Test
-    public void testReturnsGifEncoderResultIfHasGifResource() {
-        Resource<GifDrawable> gifResource = mock(Resource.class);
-        when(gifBitmap.getGifResource()).thenReturn(gifResource);
-
-        when(gifEncoder.encode(any(Resource.class), any(OutputStream.class))).thenReturn(true);
-        assertTrue(encoder.encode(resource, new ByteArrayOutputStream()));
-
-        when(gifEncoder.encode(any(Resource.class), any(OutputStream.class))).thenReturn(false);
-        assertFalse(encoder.encode(resource, new ByteArrayOutputStream()));
-    }
-
-    @Test
-    public void testReturnsValidId() {
-        String gifId = "gifId";
-        when(gifEncoder.getId()).thenReturn(gifId);
-        String bitmapId = "bitmapId";
-        when(bitmapEncoder.getId()).thenReturn(bitmapId);
-        String id = encoder.getId();
-        assertThat(id).contains(gifId);
-        assertThat(id).contains(bitmapId);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapStreamResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapStreamResourceDecoderTest.java
deleted file mode 100644
index bf1290fb3..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapStreamResourceDecoderTest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(JUnit4.class)
-public class GifBitmapStreamResourceDecoderTest {
-    ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> gifBitmapDecoder;
-    private GifBitmapWrapperStreamResourceDecoder decoder;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        gifBitmapDecoder = mock(ResourceDecoder.class);
-        decoder = new GifBitmapWrapperStreamResourceDecoder(gifBitmapDecoder);
-    }
-
-    @Test
-    public void testReturnsWrappedDecoderResult() throws IOException {
-        int width = 100;
-        int height = 110;
-        Resource<GifBitmapWrapper> expected = mock(Resource.class);
-        when(gifBitmapDecoder.decode(any(ImageVideoWrapper.class), eq(width), eq(height))).thenReturn(expected);
-
-        assertEquals(expected, decoder.decode(new ByteArrayInputStream(new byte[0]), width, height));
-    }
-
-    @Test
-    public void testPassesGivenInputStreamWrappedAsImageVideoWrapper() throws IOException {
-        final InputStream expected = new ByteArrayInputStream(new byte[0]);
-        when(gifBitmapDecoder.decode(any(ImageVideoWrapper.class), anyInt(), anyInt()))
-                .thenAnswer(new Answer<Object>() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                ImageVideoWrapper wrapper = (ImageVideoWrapper) invocation.getArguments()[0];
-                assertEquals(expected, wrapper.getStream());
-                return null;
-            }
-        });
-
-        decoder.decode(expected, 1, 2);
-    }
-
-    @Test
-    public void testReturnsWrappedId() {
-        String id = "fakeTestId";
-        when(gifBitmapDecoder.getId()).thenReturn(id);
-
-        assertEquals(id, decoder.getId());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java
deleted file mode 100644
index 8342b6cf3..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java
+++ /dev/null
@@ -1,234 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifBitmapWrapperResourceDecoderTest {
-    private ResourceDecoder<ImageVideoWrapper, Bitmap> bitmapDecoder;
-    private ResourceDecoder<InputStream, GifDrawable> gifDecoder;
-    private GifBitmapWrapperResourceDecoder decoder;
-    private GifBitmapWrapperResourceDecoder.ImageTypeParser parser;
-    private ImageVideoWrapper source;
-    private GifBitmapWrapperResourceDecoder.BufferedStreamFactory streamFactory;
-    private InputStream bis;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        bitmapDecoder = mock(ResourceDecoder.class);
-        gifDecoder = mock(ResourceDecoder.class);
-        parser = mock(GifBitmapWrapperResourceDecoder.ImageTypeParser.class);
-        streamFactory = mock(GifBitmapWrapperResourceDecoder.BufferedStreamFactory.class);
-        decoder = new GifBitmapWrapperResourceDecoder(bitmapDecoder, gifDecoder, mock(BitmapPool.class), parser,
-                streamFactory);
-
-        source = mock(ImageVideoWrapper.class);
-        InputStream is = new ByteArrayInputStream(new byte[0]);
-        when(source.getStream()).thenReturn(is);
-        bis = mock(InputStream.class);
-        when(streamFactory.build(eq(is), any(byte[].class))).thenReturn(bis);
-    }
-
-    @Test
-    public void testDecodesGifTypeWithGifDecoder() throws IOException {
-        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);
-        int width = 100;
-        int height = 200;
-        Resource<GifDrawable> expected = mockGifResource();
-
-        when(gifDecoder.decode(any(InputStream.class), eq(width), eq(height))).thenReturn(expected);
-
-        Resource<GifBitmapWrapper> result = decoder.decode(source, width, height);
-
-        assertEquals(expected, result.get().getGifResource());
-    }
-
-    @Test
-    public void testDecodesBitmapTypeWithBitmapDecoder() throws IOException {
-        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.JPEG);
-        int width = 150;
-        int height = 101;
-        Resource<Bitmap> expected = mock(Resource.class);
-
-        when(bitmapDecoder.decode(any(ImageVideoWrapper.class), eq(width), eq(height))).thenReturn(expected);
-
-        Resource<GifBitmapWrapper> result = decoder.decode(source, width, height);
-
-        assertEquals(expected, result.get().getBitmapResource());
-    }
-
-    @Test
-    public void testReturnsGifResourceIfBothGifAndBitmapDecodersCanDecode() throws IOException {
-        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);
-        int width = 101;
-        int height = 102;
-        Resource<GifDrawable> expected = mockGifResource();
-        when(gifDecoder.decode(any(InputStream.class), eq(width), eq(height))).thenReturn(expected);
-        when(bitmapDecoder.decode(any(ImageVideoWrapper.class), eq(width), eq(height)))
-                .thenReturn(mock(Resource.class));
-
-        Resource<GifBitmapWrapper> result = decoder.decode(source, width, height);
-
-        assertEquals(expected, result.get().getGifResource());
-    }
-
-    @Test
-    public void testBitmapDecoderIsGivenImageVideoWrapperWithBufferedStreamIfStreamIsNotNull() throws IOException {
-        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.PNG);
-
-        when(bitmapDecoder.decode(any(ImageVideoWrapper.class), anyInt(), anyInt())).thenAnswer(
-                new Answer<Resource<Bitmap>>() {
-                    @Override
-                    public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
-                        ImageVideoWrapper wrapper = (ImageVideoWrapper) invocation.getArguments()[0];
-                        assertEquals(bis, wrapper.getStream());
-                        return mock(Resource.class);
-                    }
-                });
-
-        decoder.decode(source, 100, 100);
-
-        verify(bitmapDecoder).decode(any(ImageVideoWrapper.class), anyInt(), anyInt());
-    }
-
-    @Test
-    public void testDecodesBitmapTypeWhenGifTypeButGifDecoderFails() throws IOException {
-        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);
-        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(null);
-
-        Resource<Bitmap> expected = mock(Resource.class);
-        when(bitmapDecoder.decode(any(ImageVideoWrapper.class), anyInt(), anyInt())).thenReturn(expected);
-
-        Resource<GifBitmapWrapper> result = decoder.decode(source, 100, 100);
-
-        assertEquals(expected, result.get().getBitmapResource());
-    }
-
-    @Test
-    public void testReturnsBitmapWhenGifTypeButGifHasSingleFrame() throws IOException {
-        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        Resource<GifDrawable> gifResource = mockGifResource();
-        when(gifResource.get().getFrameCount()).thenReturn(1);
-        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);
-
-        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);
-        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifResource);
-
-        Resource<GifBitmapWrapper> result = decoder.decode(source, 100, 100);
-
-        assertEquals(firstFrame, result.get().getBitmapResource().get());
-    }
-
-    @Test
-    public void testDoesNotCallBitmapDecoderWhenGifTypeButGifHasSingleFrame() throws IOException {
-        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        Resource<GifDrawable> gifResource = mockGifResource();
-        when(gifResource.get().getFrameCount()).thenReturn(1);
-        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);
-
-        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);
-        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifResource);
-
-        decoder.decode(source, 100, 100);
-
-        verify(bitmapDecoder, never()).decode(any(ImageVideoWrapper.class), anyInt(), anyInt());
-    }
-
-    @Test
-    public void testDoesNotRecycleGifResourceWhenGifTypeButGifHasSingleFrame() throws IOException {
-        Resource<GifDrawable> gifResource = mockGifResource();
-        when(gifResource.get().getFrameCount()).thenReturn(1);
-
-        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);
-        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifResource);
-        when(gifResource.get().getFirstFrame()).thenReturn(Bitmap.createBitmap(50, 50, Bitmap.Config.RGB_565));
-
-        decoder.decode(source, 100, 100);
-
-        verify(gifResource, never()).recycle();
-    }
-
-    @Test
-    public void testDoesNotTryToParseTypeOrDecodeNullStream() throws IOException {
-        when(source.getFileDescriptor()).thenReturn(mock(ParcelFileDescriptor.class));
-        when(source.getStream()).thenReturn(null);
-
-        Resource<Bitmap> expected = mock(Resource.class);
-        when(bitmapDecoder.decode(eq(source), anyInt(), anyInt())).thenReturn(expected);
-
-        Resource<GifBitmapWrapper> result = decoder.decode(source, 100, 100);
-        assertEquals(expected, result.get().getBitmapResource());
-    }
-
-    @Test
-    public void testReturnsNullResourceIfBothBitmapDecoderAndGifDecoderFail() throws IOException {
-        Resource<GifBitmapWrapper> result = decoder.decode(source, 100, 100);
-        assertNull(result);
-    }
-
-    @Test
-    public void testMarksAndResetsInputStreamBeforeAndAfterParsingType() throws IOException {
-        decoder.decode(source, 100, 100);
-
-        InOrder order = inOrder(bis, parser);
-        order.verify(bis).mark(eq(GifBitmapWrapperResourceDecoder.MARK_LIMIT_BYTES));
-        order.verify(parser).parse(eq(bis));
-        order.verify(bis).reset();
-    }
-
-    @Test
-    public void testHasValidId() {
-        String bitmapId = "bitmapId";
-        when(bitmapDecoder.getId()).thenReturn(bitmapId);
-        String gifId = "gifId";
-        when(gifDecoder.getId()).thenReturn(gifId);
-
-        String id = decoder.getId();
-        assertThat(id).contains(bitmapId);
-        assertThat(id).contains(gifId);
-    }
-
-    @SuppressWarnings("unchecked")
-    private static Resource<GifDrawable> mockGifResource() {
-        GifDrawable drawable = mock(GifDrawable.class);
-        // Something > 1.
-        when(drawable.getFrameCount()).thenReturn(4);
-        Resource<GifDrawable> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(drawable);
-        return resource;
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoderTest.java
deleted file mode 100644
index 076b13618..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoderTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GifBitmapWrapperResourceEncoderTest {
-    private ResourceEncoder<Bitmap> bitmapEncoder;
-    private ResourceEncoder<GifDrawable> gifEncoder;
-    private GifBitmapWrapperResourceEncoder encoder;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        bitmapEncoder = mock(ResourceEncoder.class);
-        gifEncoder = mock(ResourceEncoder.class);
-        encoder = new GifBitmapWrapperResourceEncoder(bitmapEncoder, gifEncoder);
-    }
-
-    @Test
-    public void testHasValidId() {
-        String bitmapId = "bitmapId";
-        when(bitmapEncoder.getId()).thenReturn(bitmapId);
-        String gifId = "gifId";
-        when(gifEncoder.getId()).thenReturn(gifId);
-
-        String id = encoder.getId();
-        assertThat(id).contains(bitmapId);
-        assertThat(id).contains(gifId);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceTest.java
deleted file mode 100644
index bc55a52e6..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GifBitmapWrapperResourceTest {
-    private GifBitmapWrapper data;
-    private GifBitmapWrapperResource resource;
-
-    @Before
-    public void setUp() {
-        data = mock(GifBitmapWrapper.class);
-        resource = new GifBitmapWrapperResource(data);
-    }
-
-    @Test
-    public void testReturnsDataSize() {
-        int size = 332;
-        when(data.getSize()).thenReturn(size);
-
-        assertEquals(size, resource.getSize());
-    }
-
-    @Test
-    public void testReturnsGivenData() {
-        assertEquals(data, resource.get());
-    }
-
-    @Test
-    public void testRecyclesBitmapResource() {
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-        when(data.getBitmapResource()).thenReturn(bitmapResource);
-
-        resource.recycle();
-
-        verify(bitmapResource).recycle();
-    }
-
-    @Test
-    public void testRecyclesGifResource() {
-        Resource<GifDrawable> gifDataResource = mock(Resource.class);
-        when(data.getGifResource()).thenReturn(gifDataResource);
-
-        resource.recycle();
-
-        verify(gifDataResource).recycle();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfGivenWrapperIsNull() {
-        new GifBitmapWrapperResource(null);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoderTest.java
deleted file mode 100644
index 937d5816b..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoderTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GifBitmapWrapperStreamResourceDecoderTest {
-    ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> gifBitmapDecoder;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() throws Exception {
-        gifBitmapDecoder = mock(ResourceDecoder.class);
-    }
-
-    @Test
-    public void testHasValidId() {
-        String id = "asdf225";
-        when(gifBitmapDecoder.getId()).thenReturn(id);
-        assertEquals(id, gifBitmapDecoder.getId());
-    }
-
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTest.java
deleted file mode 100644
index f455dece8..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTest.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GifBitmapWrapperTest {
-
-    @Test
-    public void testReturnsBitmapResourceIfHasBitmapResource() {
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-        GifBitmapWrapper wrapper = new GifBitmapWrapper(bitmapResource, null);
-        assertEquals(bitmapResource, wrapper.getBitmapResource());
-    }
-
-    @Test
-    public void testReturnsGifResourceIfHasGifResource() {
-        Resource<GifDrawable> gifDrawableResource = mock(Resource.class);
-        GifBitmapWrapper wrapper = new GifBitmapWrapper(null, gifDrawableResource);
-        assertEquals(gifDrawableResource, wrapper.getGifResource());
-    }
-
-    @Test
-    public void testReturnsBitmapSizeIfHasBitmap() {
-        final int size = 1234;
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-        when(bitmapResource.getSize()).thenReturn(size);
-        GifBitmapWrapper wrapper = new GifBitmapWrapper(bitmapResource, null);
-
-        assertEquals(size, wrapper.getSize());
-    }
-
-    @Test
-    public void testReturnsGifSizeIfHasGif() {
-        final int size = 48523;
-        Resource<GifDrawable> gifDrawableResource = mock(Resource.class);
-        when(gifDrawableResource.getSize()).thenReturn(size);
-        GifBitmapWrapper wrapper = new GifBitmapWrapper(null, gifDrawableResource);
-
-        assertEquals(size, wrapper.getSize());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenBothBitmapAndGif() {
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-        Resource<GifDrawable> gifDrawableResource = mock(Resource.class);
-        new GifBitmapWrapper(bitmapResource, gifDrawableResource);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenNoResources() {
-        new GifBitmapWrapper(null, null);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java
deleted file mode 100644
index b939771ca..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java
+++ /dev/null
@@ -1,151 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifBitmapWrapperTransformationTest {
-    private Transformation<Bitmap> bitmapTransformation;
-    private Transformation<GifDrawable> gifTransformation;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        bitmapTransformation = mock(Transformation.class);
-        gifTransformation = mock(Transformation.class);
-    }
-
-    private class BitmapResourceHarness {
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-        GifBitmapWrapper gifBitmapWrapper = mock(GifBitmapWrapper.class);
-        Resource<GifBitmapWrapper> resource = mock(Resource.class);
-        GifBitmapWrapperTransformation transformation = new GifBitmapWrapperTransformation(
-                mock(BitmapPool.class), bitmapTransformation);
-        int width = 123;
-        int height = 456;
-
-        public BitmapResourceHarness() {
-            when(gifBitmapWrapper.getBitmapResource()).thenReturn(bitmapResource);
-            when(resource.get()).thenReturn(gifBitmapWrapper);
-        }
-    }
-
-    private class GifResourceHarness {
-        GifDrawable gifDrawable = mock(GifDrawable.class);
-        Resource<GifDrawable> gifResource = mock(Resource.class);
-        GifBitmapWrapper gifBitmapWrapper = mock(GifBitmapWrapper.class);
-        Resource<GifBitmapWrapper> resource = mock(Resource.class);
-        GifBitmapWrapperTransformation transformation = new GifBitmapWrapperTransformation(null, gifTransformation);
-        int width = 123;
-        int height = 456;
-
-        public GifResourceHarness() {
-            when(gifResource.get()).thenReturn(gifDrawable);
-            when(gifBitmapWrapper.getGifResource()).thenReturn(gifResource);
-            when(resource.get()).thenReturn(gifBitmapWrapper);
-        }
-    }
-
-    @Test
-    public void testHasValidId() {
-        String expectedId = "testID";
-        when(bitmapTransformation.getId()).thenReturn(expectedId);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        GifBitmapWrapperTransformation transformation = new GifBitmapWrapperTransformation(pool, bitmapTransformation);
-
-        assertEquals(expectedId, transformation.getId());
-    }
-
-    @Test
-    public void testAppliesBitmapTransformationIfBitmapTransformationIsGivenAndResourceHasBitmapResource() {
-        BitmapResourceHarness harness = new BitmapResourceHarness();
-
-        Resource<Bitmap> transformedBitmapResource = mock(Resource.class);
-        when(bitmapTransformation.transform(eq(harness.bitmapResource), eq(harness.width), eq(harness.height)))
-                .thenReturn(transformedBitmapResource);
-        Resource<GifBitmapWrapper> transformed = harness.transformation.transform(harness.resource, harness.width,
-                harness.height);
-
-        assertNotSame(harness.resource, transformed);
-        assertEquals(transformedBitmapResource, transformed.get().getBitmapResource());
-    }
-
-    @Test
-    public void testReturnsOriginalResourceIfTransformationDoesNotTransformGivenBitmapResource() {
-        BitmapResourceHarness harness = new BitmapResourceHarness();
-
-        when(bitmapTransformation.transform(eq(harness.bitmapResource), eq(harness.width), eq(harness.height)))
-                .thenReturn(harness.bitmapResource);
-        Resource<GifBitmapWrapper> transformed = harness.transformation.transform(harness.resource, harness.width,
-                harness.height);
-
-        assertSame(harness.resource, transformed);
-    }
-
-    @Test
-    public void testReturnsOriginalResourceIfBitmapTransformationIsGivenButResourceHasNoBitmapResource() {
-        BitmapResourceHarness harness = new BitmapResourceHarness();
-        when(harness.gifBitmapWrapper.getBitmapResource()).thenReturn(null);
-
-        Resource<GifBitmapWrapper> transformed = harness.transformation.transform(harness.resource, harness.width,
-                harness.height);
-
-        assertSame(harness.resource, transformed);
-    }
-
-    @Test
-    public void testAppliesGifTransformationIfGifTransformationGivenAndResourceHasGifResource() {
-        GifResourceHarness harness = new GifResourceHarness();
-        Resource<GifDrawable> transformedGifResource = mock(Resource.class);
-        when(gifTransformation.transform(eq(harness.gifResource), eq(harness.width), eq(harness.height)))
-                .thenReturn(transformedGifResource);
-        Resource<GifBitmapWrapper> transformed = harness.transformation.transform(harness.resource, harness.width,
-                harness.height);
-
-        assertNotSame(harness.resource, transformed);
-        assertEquals(transformedGifResource, transformed.get().getGifResource());
-    }
-
-    @Test
-    public void testReturnsOriginalresourceIfTransformationDoesNotTransformGivenGifResource() {
-        GifResourceHarness harness = new GifResourceHarness();
-        when(gifTransformation.transform(eq(harness.gifResource), eq(harness.width), eq(harness.height)))
-                .thenReturn(harness.gifResource);
-
-        Resource<GifBitmapWrapper> transformed = harness.transformation.transform(harness.resource, harness.width,
-                harness.height);
-
-        assertSame(harness.resource, transformed);
-    }
-
-    @Test
-    public void testReturnsOriginalResourceIfGifTransformationIsGivenButResourceHasNoGifResource() {
-        GifResourceHarness harness = new GifResourceHarness();
-        when(harness.gifBitmapWrapper.getGifResource()).thenReturn(null);
-
-        Resource<GifBitmapWrapper> transformed = harness.transformation.transform(harness.resource, harness.width,
-                harness.height);
-
-        assertSame(harness.resource, transformed);
-    }
-}
-
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
deleted file mode 100644
index e7711cbd5..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BitmapBytesTranscoderTest {
-    private BitmapBytesTranscoderHarness harness;
-
-    @Before()
-    public void setUp() {
-        harness = new BitmapBytesTranscoderHarness();
-    }
-
-    @Test
-    public void testReturnsBytesOfGivenBitmap() {
-        String transcodedDescription = harness.getTranscodedDescription();
-        assertThat(transcodedDescription).startsWith(harness.description);
-    }
-
-    @Test
-    public void testUsesGivenQuality() {
-        harness.quality = 66;
-        String transcodedDescription = harness.getTranscodedDescription();
-        assertThat(transcodedDescription).contains(String.valueOf(harness.quality));
-    }
-
-    @Test
-    public void testUsesGivenFormat() {
-        for (Bitmap.CompressFormat format : Bitmap.CompressFormat.values()) {
-            harness.compressFormat = format;
-            String transcodedDescription = harness.getTranscodedDescription();
-            assertThat(transcodedDescription).contains(format.name());
-        }
-    }
-
-    @Test
-    public void testBitampResourceIsRecycled() {
-        harness.getTranscodedDescription();
-
-        verify(harness.bitmapResource).recycle();
-    }
-
-    @Test
-    public void testHasValidId() {
-        Util.assertClassHasValidId(BitmapBytesTranscoder.class,
-                new BitmapBytesTranscoder(harness.compressFormat, harness.quality).getId());
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class BitmapBytesTranscoderHarness {
-        Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
-        int quality = 100;
-        final String description = "TestDescription";
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-
-        public BitmapBytesTranscoderHarness() {
-            when(bitmapResource.get()).thenReturn(bitmap);
-            Robolectric.shadowOf(bitmap).setDescription(description);
-        }
-
-        public String getTranscodedDescription() {
-            BitmapBytesTranscoder transcoder = new BitmapBytesTranscoder(compressFormat, quality);
-            Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource);
-
-            return new String(bytesResource.get());
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoderTest.java
deleted file mode 100644
index bd089b96c..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoderTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BitmapToGlideDrawableTranscoderTest {
-
-    private GlideBitmapDrawableTranscoder wrapped;
-    private BitmapToGlideDrawableTranscoder transcoder;
-
-    @Before
-    public void setUp() {
-        wrapped = mock(GlideBitmapDrawableTranscoder.class);
-        transcoder = new BitmapToGlideDrawableTranscoder(wrapped);
-    }
-
-    @Test
-    public void testReturnsWrappedId() {
-        final String expectedId = "fakeId";
-        when(wrapped.getId()).thenReturn(expectedId);
-        assertEquals(expectedId, transcoder.getId());
-    }
-
-    @Test
-    public void testReturnsResourceFromWrapped() {
-        Resource<Bitmap> toTranscode = mock(Resource.class);
-        Resource<GlideBitmapDrawable> expected = mock(Resource.class);
-
-        when(wrapped.transcode(eq(toTranscode))).thenReturn(expected);
-
-        assertEquals(expected, transcoder.transcode(toTranscode));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoderTest.java
deleted file mode 100644
index 9d99931f0..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoderTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifBitmapWrapperDrawableTranscoderTest {
-    private GifBitmapWrapperDrawableTranscoder transcoder;
-    private ResourceTranscoder<Bitmap, GlideBitmapDrawable> bitmapTranscoder;
-
-    @Before
-    public void setUp() {
-        bitmapTranscoder = mock(ResourceTranscoder.class);
-        transcoder = new GifBitmapWrapperDrawableTranscoder(bitmapTranscoder);
-    }
-
-    @Test
-    public void testReturnsDrawableFromBitmapTranscoderIfGifBitmapHasBitmap() {
-        GifBitmapWithBitmapHarness harness = new GifBitmapWithBitmapHarness();
-        when(bitmapTranscoder.transcode(eq(harness.bitmapResource))).thenReturn(harness.expected);
-
-        assertEquals(harness.expected, transcoder.transcode(harness.gifBitmapResource));
-    }
-
-    @Test
-    public void testReturnsDrawableFromGifTranscoderIfGifBitmapHasGif() {
-        GifBitmapWithGifHarness harness = new GifBitmapWithGifHarness();
-
-        assertEquals(harness.gifResource, transcoder.transcode(harness.gifBitmapResource));
-    }
-
-    @Test
-    public void testHasValid() {
-        Util.assertClassHasValidId(GifBitmapWrapperDrawableTranscoder.class, transcoder.getId());
-    }
-
-    private static class TranscoderHarness {
-        Resource<GifBitmapWrapper> gifBitmapResource = mock(Resource.class);
-        GifBitmapWrapper gifBitmap = mock(GifBitmapWrapper.class);
-        Resource<GlideBitmapDrawable> expected = mock(Resource.class);
-
-        public TranscoderHarness() {
-            when(gifBitmapResource.get()).thenReturn(gifBitmap);
-        }
-    }
-
-    private static class GifBitmapWithBitmapHarness extends TranscoderHarness {
-        Resource<Bitmap> bitmapResource = mock(Resource.class);
-
-        public GifBitmapWithBitmapHarness() {
-            super();
-            when(gifBitmap.getBitmapResource()).thenReturn(bitmapResource);
-        }
-    }
-
-    private static class GifBitmapWithGifHarness extends TranscoderHarness {
-        GifDrawable gifDrawable = mock(GifDrawable.class);
-        Resource<GifDrawable> gifResource = mock(Resource.class);
-
-        public GifBitmapWithGifHarness() {
-            super();
-            when(gifResource.get()).thenReturn(gifDrawable);
-            when(gifBitmap.getGifResource()).thenReturn(gifResource);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
deleted file mode 100644
index d8ac47c48..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GifDrawableBytesTranscoderTest {
-    private GifDrawableBytesTranscoder transcoder;
-    private GifDrawable gifDrawable;
-    private Resource<GifDrawable> resource;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        gifDrawable = mock(GifDrawable.class);
-        resource = mock(Resource.class);
-        when(resource.get()).thenReturn(gifDrawable);
-        transcoder = new GifDrawableBytesTranscoder();
-    }
-
-    @Test
-    public void testReturnsBytesOfGivenGifDrawable() {
-        for (String fakeData : new String[] { "test", "1235asfklaw3", "@$@#"}) {
-            byte[] expected = fakeData.getBytes();
-            when(gifDrawable.getData()).thenReturn(expected);
-
-            Resource<byte[]> transcoded = transcoder.transcode(resource);
-
-            assertArrayEquals(expected, transcoded.get());
-        }
-    }
-
-    @Test
-    public void testReturnsValidId() {
-        Util.assertClassHasValidId(GifDrawableBytesTranscoder.class, transcoder.getId());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoderTest.java
deleted file mode 100644
index d23d3553e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoderTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GlideBitmapDrawableTranscoderTest {
-    private GlideBitmapDrawableTranscoder transcoder;
-
-    @Before
-    public void setUp() {
-        transcoder = new GlideBitmapDrawableTranscoder(Robolectric.application.getResources(), mock(BitmapPool.class));
-    }
-
-    @Test
-    public void testHasValidId() {
-        Util.assertClassHasValidId(GlideBitmapDrawableTranscoder.class, transcoder.getId());
-    }
-
-    @Test
-    public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {
-        Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        Resource<Bitmap> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(expected);
-
-        Resource<GlideBitmapDrawable> transcoded = transcoder.transcode(resource);
-
-        assertEquals(expected, transcoded.get().getBitmap());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
deleted file mode 100644
index bf236004c..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.File;
-
-@RunWith(JUnit4.class)
-public class TranscoderRegistryTest {
-    private TranscoderRegistry factories;
-
-    @Before
-    public void setUp() {
-        factories = new TranscoderRegistry();
-    }
-
-    @Test
-    public void testReturnsUnitDecoderIfClassesAreIdentical() {
-        assertEquals(UnitTranscoder.get(), factories.get(Object.class, Object.class));
-    }
-
-    @Test
-    public void testCanRegisterAndRetreiveResouceTranscoder() {
-        ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
-        factories.register(File.class, Object.class, transcoder);
-
-        assertEquals(transcoder, factories.get(File.class, Object.class));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfNoTranscoderRegistered() {
-        factories.get(File.class, Object.class);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
deleted file mode 100644
index 8259c3206..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class UnitTranscoderTest {
-
-    @Test
-    public void testReturnsTheGivenResource() {
-        Resource resource = mock(Resource.class);
-        ResourceTranscoder<Object, Object> unitTranscoder = UnitTranscoder.get();
-
-        assertEquals(resource, unitTranscoder.transcode(resource));
-    }
-
-    @Test
-    public void testHasEmptyId() {
-        assertEquals("", UnitTranscoder.get().getId());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
deleted file mode 100644
index 573402a5c..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.bumptech.glide.manager;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ConnectivityMonitorFactoryTest {
-    private ConnectivityMonitorFactory factory;
-
-    @Before
-    public void setUp() {
-        factory = new ConnectivityMonitorFactory();
-    }
-
-    @Test
-    public void testReturnsDefaultConnectivityMonitorWhenHasPermission() {
-        Robolectric.getShadowApplication().grantPermissions("android.permission.ACCESS_NETWORK_STATE");
-        ConnectivityMonitor connectivityMonitor =
-                factory.build(Robolectric.application, mock(ConnectivityMonitor.ConnectivityListener.class));
-        assertThat(connectivityMonitor).isInstanceOf(DefaultConnectivityMonitor.class);
-    }
-
-    @Test
-    public void testReturnsNullConnectivityMonitorWhenDoesNotHavePermission() {
-        ConnectivityMonitor connectivityMonitor =
-                factory.build(Robolectric.application, mock(ConnectivityMonitor.ConnectivityListener.class));
-        assertThat(connectivityMonitor).isInstanceOf(NullConnectivityMonitor.class);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
deleted file mode 100644
index d8faae2f5..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ /dev/null
@@ -1,147 +0,0 @@
-package com.bumptech.glide.manager;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowConnectivityManager;
-import org.robolectric.shadows.ShadowNetworkInfo;
-
-import java.util.List;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class DefaultConnectivityMonitorTest {
-    private ConnectivityMonitor.ConnectivityListener listener;
-    private DefaultConnectivityMonitor monitor;
-
-    @Before
-    public void setUp() {
-        listener = mock(ConnectivityMonitor.ConnectivityListener.class);
-        monitor = new DefaultConnectivityMonitor(Robolectric.application, listener);
-    }
-
-    @Test
-    public void testRegistersReceiverOnStart() {
-        monitor.onStart();
-
-        assertThat(getConnectivityReceivers()).hasSize(1);
-    }
-
-    @Test
-    public void testDoesNotRegisterTwiceOnStart() {
-        monitor.onStart();
-        monitor.onStart();
-
-        assertThat(getConnectivityReceivers()).hasSize(1);
-    }
-
-    @Test
-    public void testUnregistersReceiverOnStop() {
-        monitor.onStart();
-        monitor.onStop();
-
-        assertThat(getConnectivityReceivers()).isEmpty();
-    }
-
-    @Test
-    public void testHandlesUnregisteringTwiceInARow() {
-        monitor.onStop();
-        monitor.onStop();
-
-        assertThat(getConnectivityReceivers()).isEmpty();
-    }
-
-    @Test
-    public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
-        ConnectivityHarness harness = new ConnectivityHarness();
-        harness.connect();
-
-        monitor.onStart();
-        harness.broadcast();
-
-        verify(listener, never()).onConnectivityChanged(anyBoolean());
-    }
-
-    @Test
-    public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
-        ConnectivityHarness harness = new ConnectivityHarness();
-        harness.connect();
-
-        monitor.onStart();
-        harness.disconnect();
-        harness.broadcast();
-
-        verify(listener).onConnectivityChanged(eq(false));
-    }
-
-    @Test
-    public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
-        ConnectivityHarness harness = new ConnectivityHarness();
-        harness.disconnect();
-
-        monitor.onStart();
-        harness.connect();
-        harness.broadcast();
-
-        verify(listener).onConnectivityChanged(eq(true));
-    }
-
-    @Test
-    public void testDoesNotNotifyListenerWhenNotRegistered() {
-        ConnectivityHarness harness = new ConnectivityHarness();
-        harness.disconnect();
-
-        monitor.onStart();
-        monitor.onStop();
-        harness.connect();
-        harness.broadcast();
-
-        verify(listener, never()).onConnectivityChanged(anyBoolean());
-    }
-
-    private List<BroadcastReceiver> getConnectivityReceivers() {
-        Intent connectivity = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
-        return Robolectric.getShadowApplication().getReceiversForIntent(connectivity);
-    }
-
-    private static class ConnectivityHarness {
-        private final ShadowConnectivityManager shadowConnectivityManager;
-
-        public ConnectivityHarness() {
-            ConnectivityManager connectivityManager =
-                    (ConnectivityManager) Robolectric.application.getSystemService(Context.CONNECTIVITY_SERVICE);
-            shadowConnectivityManager = Robolectric.shadowOf(connectivityManager);
-        }
-
-        public void disconnect() {
-            shadowConnectivityManager.setActiveNetworkInfo(null);
-        }
-
-        public void connect() {
-            NetworkInfo networkInfo = ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.CONNECTED, 0, 0, true,
-                    true);
-            shadowConnectivityManager.setActiveNetworkInfo(networkInfo);
-        }
-
-        public void broadcast() {
-            Intent connected = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
-            Robolectric.shadowOf(Robolectric.application).sendBroadcast(connected);
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java b/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java
deleted file mode 100644
index 0319aaddb..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.bumptech.glide.manager;
-
-import android.content.Context;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentManager;
-import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.view.ViewPager;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ImageView;
-
-import com.bumptech.glide.Glide;
-
-/**
- * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
- */
-class Issue117Activity extends FragmentActivity {
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        ViewPager viewPager = new ViewPager(this);
-        viewPager.setId(View.generateViewId());
-        setContentView(viewPager,
-                new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
-        viewPager.setAdapter(new Issue117Adapter(getSupportFragmentManager()));
-    }
-
-    private static class Issue117Adapter extends FragmentPagerAdapter {
-
-        public Issue117Adapter(FragmentManager fm) {
-            super(fm);
-        }
-
-        @Override
-        public Fragment getItem(int position) {
-            return new Issue117Fragment();
-        }
-
-        @Override
-        public int getCount() {
-            return 1;
-        }
-    }
-
-    public static class Issue117Fragment extends Fragment {
-        @Override
-        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-            return new Issue117ImageView(getActivity());
-        }
-    }
-
-    public static class Issue117ImageView extends ImageView {
-        public Issue117ImageView(Context context) {
-            super(context);
-        }
-
-        @Override
-        protected void onAttachedToWindow() {
-            super.onAttachedToWindow();
-            Glide.with(getContext()).load(android.R.drawable.ic_menu_rotate).into(this);
-        }
-    }
-}
-
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java
deleted file mode 100644
index 4c364a8f0..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package com.bumptech.glide.manager;
-
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.List;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class LifecycleTest {
-
-    private ActivityFragmentLifecycle lifecycle;
-    private LifecycleListener listener;
-
-    @Before
-    public void setUp() {
-        lifecycle = new ActivityFragmentLifecycle();
-        listener = mock(LifecycleListener.class);
-    }
-
-    @Test
-    public void testNotifiesAddedListenerOnStart() {
-        lifecycle.addListener(listener);
-        lifecycle.onStart();
-        verify(listener).onStart();
-    }
-
-    @Test
-    public void testNotifiesAddedListenerOfStartIfStarted() {
-        lifecycle.onStart();
-        lifecycle.addListener(listener);
-        verify(listener).onStart();
-    }
-
-    @Test
-    public void testDoesNotNotifyAddedListenerOfStartIfDestroyed() {
-        lifecycle.onStart();
-        lifecycle.onStop();
-        lifecycle.onDestroy();
-        lifecycle.addListener(listener);
-
-        verify(listener, never()).onStart();
-    }
-
-    @Test
-    public void testDoesNotNotifyListenerOfStartIfStartedThenStopped() {
-        lifecycle.onStart();
-        lifecycle.onStop();
-        lifecycle.addListener(listener);
-        verify(listener, never()).onStart();
-    }
-
-    @Test
-    public void testNotifiesAddedListenerOnStop() {
-        lifecycle.onStart();
-        lifecycle.addListener(listener);
-        lifecycle.onStop();
-        verify(listener).onStop();
-    }
-
-    @Test
-    public void testNotifiesAddedListenerOfStopIfStopped() {
-        lifecycle.onStop();
-        lifecycle.addListener(listener);
-        verify(listener).onStop();
-    }
-
-    @Test
-    public void testDoesNotNotifyAddedListenerOfStopIfDestroyed() {
-        lifecycle.onStart();
-        lifecycle.onStop();
-        lifecycle.onDestroy();
-        lifecycle.addListener(listener);
-        verify(listener, never()).onStop();
-    }
-
-    @Test
-    public void testDoesNotNotifyListenerOfStopIfStoppedThenStarted() {
-        lifecycle.onStop();
-        lifecycle.onStart();
-        lifecycle.addListener(listener);
-        verify(listener, never()).onStop();
-    }
-
-    @Test
-    public void testNotifiesAddedListenerOnDestroy() {
-        lifecycle.addListener(listener);
-        lifecycle.onDestroy();
-        verify(listener).onDestroy();
-    }
-
-    @Test
-    public void testNotifiesAddedListenerOfDestroyIfDestroyed() {
-        lifecycle.onDestroy();
-        lifecycle.addListener(listener);
-        verify(listener).onDestroy();
-    }
-
-    @Test
-    public void testNotifiesMultipleListeners() {
-        lifecycle.onStart();
-        int toNotify = 20;
-        List<LifecycleListener> listeners = new ArrayList<LifecycleListener>();
-        for (int i = 0; i < toNotify; i++) {
-            listeners.add(mock(LifecycleListener.class));
-        }
-        for (LifecycleListener lifecycleListener : listeners) {
-            lifecycle.addListener(lifecycleListener);
-        }
-        lifecycle.onStop();
-        lifecycle.onDestroy();
-        for (LifecycleListener lifecycleListener : listeners) {
-            verify(lifecycleListener).onStart();
-            verify(lifecycleListener).onStop();
-            verify(lifecycleListener).onDestroy();
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
deleted file mode 100644
index f33b5d000..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ /dev/null
@@ -1,226 +0,0 @@
-package com.bumptech.glide.manager;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-import android.app.Activity;
-import android.support.v4.app.FragmentActivity;
-
-import com.bumptech.glide.RequestManager;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.exceptions.base.MockitoAssertionError;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class RequestManagerFragmentTest {
-    private static final String TAG = "tag";
-    private Harness[] harnesses;
-
-    @Before
-    public void setUp() {
-        harnesses = new Harness[] {
-            new RequestManagerHarness(),
-            new SupportRequestManagerHarness()
-        };
-    }
-
-    @Test
-    public void testSupportCanSetAndGetRequestManager() {
-        runTest(new TestCase() {
-            @Override
-            public void runTest(Harness harness) {
-                RequestManager manager = mock(RequestManager.class);
-                harness.setRequestManager(manager);
-                assertEquals(manager, harness.getManager());
-            }
-        });
-    }
-
-    @Test
-    public void testReturnsLifecycle() {
-        runTest(new TestCase() {
-            @Override
-            public void runTest(Harness harness) {
-                assertEquals(harness.getHarnessLifecycle(), harness.getFragmentLifecycle());
-            }
-        });
-    }
-
-    @Test
-    public void testDoesNotAddNullRequestManagerToLifecycleWhenSet() {
-        runTest(new TestCase() {
-            @Override
-            public void runTest(Harness harness) {
-                harness.setRequestManager(null);
-                verify(harness.getHarnessLifecycle(), never()).addListener(any(LifecycleListener.class));
-            }
-        });
-    }
-
-    @Test
-    public void testCallsLifecycleStart() {
-        runTest(new TestCase() {
-            @Override
-            public void runTest(Harness harness) {
-                harness.getController().start();
-
-                verify(harness.getHarnessLifecycle()).onStart();
-            }
-        });
-    }
-
-    @Test
-    public void testCallsRequestManagerStop() {
-        runTest(new TestCase() {
-            @Override
-            public void runTest(Harness harness) {
-                harness.getController().start().resume().pause().stop();
-
-                verify(harness.getHarnessLifecycle()).onStop();
-            }
-        });
-    }
-
-    @Test
-    public void testCallsRequestManagerDestroy() {
-        runTest(new TestCase() {
-            @Override
-            public void runTest(Harness harness) {
-                harness.getController().start().resume().pause().stop().destroy();
-
-                verify(harness.getHarnessLifecycle()).onDestroy();
-            }
-        });
-    }
-
-    private void runTest(TestCase testCase) {
-        for (Harness harness : harnesses) {
-            try {
-                testCase.runTest(harness);
-            } catch (MockitoAssertionError e) {
-                throw new Error("Failed to get expected call on " + harness, e);
-            }
-        }
-    }
-
-    private interface TestCase {
-        public void runTest(Harness harness);
-    }
-
-    private interface Harness {
-        public RequestManager getManager();
-
-        public void setRequestManager(RequestManager manager);
-
-        public ActivityFragmentLifecycle getHarnessLifecycle();
-
-        public ActivityFragmentLifecycle getFragmentLifecycle();
-
-        public ActivityController getController();
-    }
-
-    private static class RequestManagerHarness implements Harness {
-        private final ActivityController<Activity> controller;
-        private final RequestManagerFragment fragment;
-        private final ActivityFragmentLifecycle lifecycle = mock(ActivityFragmentLifecycle.class);
-
-        public RequestManagerHarness() {
-            fragment = new RequestManagerFragment(lifecycle);
-            controller = Robolectric.buildActivity(Activity.class).create();
-            controller.get()
-                .getFragmentManager()
-                .beginTransaction()
-                .add(fragment, TAG)
-                .commit();
-            controller.get().getFragmentManager().executePendingTransactions();
-        }
-
-        @Override
-        public String toString() {
-            return "DefaultHarness";
-        }
-
-        @Override
-        public RequestManager getManager() {
-            return fragment.getRequestManager();
-        }
-
-        @Override
-        public void setRequestManager(RequestManager requestManager) {
-            fragment.setRequestManager(requestManager);
-        }
-
-        @Override
-        public ActivityFragmentLifecycle getHarnessLifecycle() {
-            return lifecycle;
-        }
-
-        @Override
-        public ActivityFragmentLifecycle getFragmentLifecycle() {
-            return fragment.getLifecycle();
-        }
-
-        @Override
-        public ActivityController getController() {
-            return controller;
-        }
-    }
-
-    private static class SupportRequestManagerHarness implements Harness {
-        private final SupportRequestManagerFragment supportFragment;
-        private final ActivityController<FragmentActivity> supportController;
-        private final ActivityFragmentLifecycle lifecycle = mock(ActivityFragmentLifecycle.class);
-
-        public SupportRequestManagerHarness() {
-            supportFragment = new SupportRequestManagerFragment(lifecycle);
-            supportController = Robolectric.buildActivity(FragmentActivity.class).create();
-
-            supportController.get()
-                .getSupportFragmentManager()
-                .beginTransaction()
-                .add(supportFragment, TAG)
-                .commit();
-            supportController.get().getSupportFragmentManager().executePendingTransactions();
-        }
-
-        @Override
-        public String toString() {
-            return "SupportHarness";
-        }
-
-        @Override
-        public RequestManager getManager() {
-            return supportFragment.getRequestManager();
-        }
-
-        @Override
-        public void setRequestManager(RequestManager manager) {
-            supportFragment.setRequestManager(manager);
-        }
-
-        @Override
-        public ActivityFragmentLifecycle getHarnessLifecycle() {
-            return lifecycle;
-        }
-
-        @Override
-        public ActivityFragmentLifecycle getFragmentLifecycle() {
-            return supportFragment.getLifecycle();
-        }
-
-        @Override
-        public ActivityController getController() {
-            return supportController;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
deleted file mode 100644
index 8783db00d..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ /dev/null
@@ -1,408 +0,0 @@
-package com.bumptech.glide.manager;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.ContextWrapper;
-import android.os.Build;
-import android.os.Looper;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
-
-import com.bumptech.glide.RequestManager;
-import com.bumptech.glide.tests.BackgroundUtil;
-import com.bumptech.glide.tests.GlideShadowLooper;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
-public class RequestManagerRetrieverTest {
-    private static final String PARENT_TAG = "parent";
-    private RetrieverHarness[] harnesses;
-    private RequestManagerRetriever retriever;
-    private int initialSdkVersion;
-
-    @Before
-    public void setUp() {
-        retriever = new RequestManagerRetriever();
-
-        harnesses = new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
-
-        initialSdkVersion = Build.VERSION.SDK_INT;
-        Util.setSdkVersionInt(18);
-    }
-
-    @After
-    public void tearDown() {
-        Util.setSdkVersionInt(initialSdkVersion);
-
-        Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
-        assertThat(retriever.pendingRequestManagerFragments).isEmpty();
-        assertThat(retriever.pendingSupportRequestManagerFragments).isEmpty();
-    }
-
-    @Test
-    public void testCreatesNewFragmentIfNoneExists() {
-        for (RetrieverHarness harness : harnesses) {
-            harness.doGet();
-
-            Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
-            assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.TAG));
-        }
-    }
-
-    @Test
-    public void testReturnsNewManagerIfNoneExists() {
-        for (RetrieverHarness harness : harnesses) {
-            assertNotNull(harness.doGet());
-        }
-    }
-
-    @Test
-    public void testReturnsExistingRequestManagerIfExists() {
-        for (RetrieverHarness harness : harnesses) {
-            RequestManager requestManager = mock(RequestManager.class);
-
-            harness.addFragmentWithTag(RequestManagerRetriever.TAG, requestManager);
-
-            assertEquals(requestManager, harness.doGet());
-        }
-    }
-
-    @Test
-    public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
-        for (RetrieverHarness harness : harnesses) {
-            harness.addFragmentWithTag(RequestManagerRetriever.TAG, null);
-
-            assertNotNull(harness.doGet());
-        }
-    }
-
-    @Test
-    public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
-        for (RetrieverHarness harness : harnesses) {
-            harness.addFragmentWithTag(RequestManagerRetriever.TAG, null);
-            RequestManager first = harness.doGet();
-            RequestManager second = harness.doGet();
-
-            assertEquals(first, second);
-        }
-    }
-
-    @Test
-    public void testHasValidTag() {
-        assertEquals(RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.TAG);
-    }
-
-    @Test
-    public void testCanGetRequestManagerFromActivity() {
-        Activity activity = Robolectric.buildActivity(Activity.class).create().start().get();
-        RequestManager manager = retriever.get(activity);
-        assertEquals(manager, retriever.get(activity));
-    }
-
-    @Test
-    public void testSupportCanGetRequestManagerFromActivity() {
-        FragmentActivity fragmentActivity = Robolectric.buildActivity(FragmentActivity.class).create().start().get();
-        RequestManager manager = retriever.get(fragmentActivity);
-        assertEquals(manager, retriever.get(fragmentActivity));
-    }
-
-    @Test
-    public void testCanGetRequestManagerFromFragment() {
-        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
-        android.app.Fragment fragment = new android.app.Fragment();
-        activity.getFragmentManager()
-                .beginTransaction()
-                .add(fragment, PARENT_TAG)
-                .commit();
-        activity.getFragmentManager().executePendingTransactions();
-
-        RequestManager manager = retriever.get(fragment);
-        assertEquals(manager, retriever.get(fragment));
-    }
-
-    @Test
-    public void testSupportCanGetRequestManagerFromFragment() {
-        FragmentActivity activity = Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
-        Fragment fragment = new Fragment();
-        activity.getSupportFragmentManager()
-                .beginTransaction()
-                .add(fragment, PARENT_TAG)
-                .commit();
-        activity.getSupportFragmentManager().executePendingTransactions();
-
-        RequestManager manager = retriever.get(fragment);
-        assertEquals(manager, retriever.get(fragment));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfFragmentNotAttached() {
-        android.app.Fragment fragment = new android.app.Fragment();
-        retriever.get(fragment);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfSupportFragmentNotAttached() {
-        Fragment fragment = new Fragment();
-        retriever.get(fragment);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfActivityDestroyed() {
-        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
-        harness.getController().pause().stop().destroy();
-        harness.doGet();
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfFragmentActivityDestroyed() {
-        SupportRetrieverHarness harness = new SupportRetrieverHarness();
-        harness.getController().pause().stop().destroy();
-        harness.doGet();
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfGivenNullContext() {
-        retriever.get((Context) null);
-    }
-
-    @Test
-    public void testChecksIfContextIsFragmentActivity() {
-        SupportRetrieverHarness harness = new SupportRetrieverHarness();
-        RequestManager requestManager = harness.doGet();
-
-        assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
-    }
-
-    @Test
-    public void testChecksIfContextIsActivity() {
-        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
-        RequestManager requestManager = harness.doGet();
-
-        assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
-    }
-
-    @Test
-    public void testHandlesContextWrappersForActivities() {
-        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
-        RequestManager requestManager = harness.doGet();
-        ContextWrapper contextWrapper = new ContextWrapper((Context) harness.getController().get());
-
-        assertEquals(requestManager, retriever.get(contextWrapper));
-    }
-
-    @Test
-    public void testHandlesContextWrappersForApplication() {
-        ContextWrapper contextWrapper = new ContextWrapper(Robolectric.application);
-        RequestManager requestManager = retriever.get(Robolectric.application);
-
-        assertEquals(requestManager, retriever.get(contextWrapper));
-    }
-
-    @Test
-    public void testReturnsNonNullManagerIfGivenApplicationContext() {
-        assertNotNull(retriever.get(Robolectric.application));
-    }
-
-    @Test
-    public void testApplicationRequestManagerIsNotPausedWhenRetrieved() {
-        RequestManager manager = retriever.get(Robolectric.application);
-        assertFalse(manager.isPaused());
-    }
-
-    @Test
-    public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
-        RequestManager manager = retriever.get(Robolectric.application);
-        manager.pauseRequests();
-        manager = retriever.get(Robolectric.application);
-        assertTrue(manager.isPaused());
-    }
-
-    @Test
-    public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread() throws InterruptedException {
-        testInBackground(new BackgroundUtil.BackgroundTester() {
-            @Override
-            public void runTest() throws Exception {
-                retriever.get(Robolectric.application);
-            }
-        });
-    }
-
-    // See Issue #117: https://github.com/bumptech/glide/issues/117.
-    @Test
-    public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
-        // Robolectric by default runs messages posted to the main looper synchronously, the framework does not. We post
-        // to the main thread here to work around an issue caused by a recursive method call so we need (and reasonably
-        // expect) our message to not run immediately
-        Robolectric.shadowOf(Looper.getMainLooper()).pause();
-        Robolectric.buildActivity(Issue117Activity.class).create().start().resume().visible();
-    }
-
-    @Test
-    public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
-        Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
-        Activity activity = mock(Activity.class);
-        when(activity.getApplicationContext()).thenReturn(Robolectric.application);
-        when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());
-
-        assertNotNull(retriever.get(activity));
-    }
-
-    @Test
-    public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
-        Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
-        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
-        Activity spyActivity = Mockito.spy(activity);
-        when(spyActivity.isDestroyed()).thenThrow(new NoSuchMethodError());
-
-        assertNotNull(retriever.get(spyActivity));
-    }
-
-    @Test
-    public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
-        Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
-        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
-        android.app.Fragment fragment = new android.app.Fragment();
-
-        activity.getFragmentManager()
-                .beginTransaction().add(fragment, "test")
-                .commit();
-        android.app.Fragment spyFragment = Mockito.spy(fragment);
-        when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());
-
-        assertNotNull(retriever.get(spyFragment));
-    }
-
-    @Test
-    public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
-        Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
-        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
-        android.app.Fragment fragment = new android.app.Fragment();
-
-        activity.getFragmentManager()
-                .beginTransaction().add(fragment, "test")
-                .commit();
-        android.app.Fragment spyFragment = Mockito.spy(fragment);
-        when(spyFragment.getChildFragmentManager()).thenThrow(new NoSuchMethodError());
-
-        assertNotNull(retriever.get(spyFragment));
-    }
-
-    private interface RetrieverHarness {
-
-        public ActivityController getController();
-
-        public RequestManager doGet();
-
-        public boolean hasFragmentWithTag(String tag);
-
-        public void addFragmentWithTag(String tag, RequestManager manager);
-    }
-
-    public class DefaultRetrieverHarness implements RetrieverHarness {
-        private final ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class);
-        private final android.app.Fragment parent;
-
-        public DefaultRetrieverHarness() {
-            this.parent = new android.app.Fragment();
-
-            controller.create();
-            controller.get().getFragmentManager()
-                .beginTransaction()
-                .add(parent, PARENT_TAG)
-                .commitAllowingStateLoss();
-            controller.get().getFragmentManager().executePendingTransactions();
-            controller.start().resume();
-        }
-
-        @Override
-        public ActivityController getController() {
-            return controller;
-        }
-
-        @Override
-        public RequestManager doGet() {
-            return retriever.get(controller.get());
-        }
-
-        @Override
-        public boolean hasFragmentWithTag(String tag) {
-            return controller.get().getFragmentManager().findFragmentByTag(RequestManagerRetriever.TAG) != null;
-        }
-
-        @Override
-        public void addFragmentWithTag(String tag, RequestManager requestManager) {
-            RequestManagerFragment fragment = new RequestManagerFragment();
-            fragment.setRequestManager(requestManager);
-            controller.get().getFragmentManager()
-                    .beginTransaction()
-                    .add(fragment, RequestManagerRetriever.TAG)
-                    .commitAllowingStateLoss();
-            controller.get().getFragmentManager().executePendingTransactions();
-        }
-    }
-
-    public class SupportRetrieverHarness implements RetrieverHarness {
-        private final ActivityController<FragmentActivity> controller = Robolectric.buildActivity(
-                FragmentActivity.class);
-        private final Fragment parent;
-
-        public SupportRetrieverHarness() {
-            this.parent = new Fragment();
-
-            controller.create();
-            controller.get().getSupportFragmentManager()
-                    .beginTransaction()
-                    .add(parent, PARENT_TAG)
-                    .commitAllowingStateLoss();
-            controller.get().getSupportFragmentManager().executePendingTransactions();
-            controller.start().resume();
-        }
-
-        @Override
-        public ActivityController getController() {
-            return controller;
-        }
-
-        @Override
-        public RequestManager doGet() {
-            return retriever.get(controller.get());
-        }
-
-        @Override
-        public boolean hasFragmentWithTag(String tag) {
-            return controller.get().getSupportFragmentManager().findFragmentByTag(RequestManagerRetriever.TAG)
-                    != null;
-        }
-
-        @Override
-        public void addFragmentWithTag(String tag, RequestManager manager) {
-            SupportRequestManagerFragment fragment = new SupportRequestManagerFragment();
-            fragment.setRequestManager(manager);
-            controller.get().getSupportFragmentManager()
-                    .beginTransaction()
-                    .add(fragment, RequestManagerRetriever.TAG)
-                    .commitAllowingStateLoss();
-            controller.get().getSupportFragmentManager().executePendingTransactions();
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java
deleted file mode 100644
index 4bf0941cb..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ /dev/null
@@ -1,244 +0,0 @@
-package com.bumptech.glide.manager;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.request.Request;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class RequestTrackerTest {
-    private RequestTracker tracker;
-
-    @Before
-    public void setUp() {
-        tracker = new RequestTracker();
-    }
-
-    @Test
-    public void testClearsAddedRequestsOnDestroy() {
-        Request request = mock(Request.class);
-        tracker.addRequest(request);
-
-        tracker.clearRequests();
-
-        verify(request).clear();
-    }
-
-    @Test
-    public void testCanAddAndRemoveRequest() {
-        Request request = mock(Request.class);
-        tracker.addRequest(request);
-        tracker.removeRequest(request);
-
-        tracker.clearRequests();
-
-        verify(request, never()).clear();
-    }
-
-    @Test
-    public void testCanAddMultipleRequests() {
-        Request first = mock(Request.class);
-        Request second = mock(Request.class);
-        tracker.addRequest(first);
-        tracker.addRequest(second);
-
-        tracker.clearRequests();
-
-        verify(first).clear();
-        verify(second).clear();
-    }
-
-    @Test
-    public void testPausesInProgressRequestsWhenPaused() {
-        Request request = mock(Request.class);
-        when(request.isRunning()).thenReturn(true);
-        tracker.addRequest(request);
-
-        tracker.pauseRequests();
-
-        verify(request).pause();
-    }
-
-    @Test
-    public void testDoesNotClearCompleteRequestsWhenPaused() {
-        Request request = mock(Request.class);
-        tracker.addRequest(request);
-
-        when(request.isComplete()).thenReturn(true);
-        tracker.pauseRequests();
-
-        verify(request, never()).clear();
-    }
-
-    @Test
-    public void testStartsRequestOnRun() {
-        Request request = mock(Request.class);
-        tracker.runRequest(request);
-
-        verify(request).begin();
-    }
-
-    @Test
-    public void testDoesNotStartRequestOnRunIfPaused() {
-        Request request = mock(Request.class);
-        tracker.pauseRequests();
-        tracker.runRequest(request);
-
-        verify(request, never()).begin();
-    }
-
-    @Test
-    public void testStartsRequestAddedWhenPausedWhenResumed() {
-        Request request = mock(Request.class);
-        tracker.pauseRequests();
-        tracker.runRequest(request);
-        tracker.resumeRequests();
-
-        verify(request).begin();
-    }
-
-    @Test
-    public void testDoesNotClearFailedRequestsWhenPaused() {
-        Request request = mock(Request.class);
-        when(request.isFailed()).thenReturn(true);
-        tracker.addRequest(request);
-
-        tracker.pauseRequests();
-
-        verify(request, never()).clear();
-    }
-
-    @Test
-    public void testRestartsStoppedRequestWhenResumed() {
-        Request request = mock(Request.class);
-        tracker.addRequest(request);
-
-        tracker.resumeRequests();
-
-        verify(request).begin();
-    }
-
-    @Test
-    public void testDoesNotRestartCompletedRequestsWhenResumed() {
-        Request request = mock(Request.class);
-        when(request.isComplete()).thenReturn(true);
-        tracker.addRequest(request);
-
-        tracker.resumeRequests();
-
-        verify(request, never()).begin();
-    }
-
-    @Test
-    public void testDoesRestartFailedRequestsWhenResumed() {
-        Request request = mock(Request.class);
-        when(request.isFailed()).thenReturn(true);
-        tracker.addRequest(request);
-
-        tracker.resumeRequests();
-
-        verify(request).begin();
-    }
-
-    @Test
-    public void testDoesNotStartStartedRequestsWhenResumed() {
-        Request request = mock(Request.class);
-        when(request.isRunning()).thenReturn(true);
-        tracker.addRequest(request);
-
-        tracker.resumeRequests();
-
-        verify(request, never()).begin();
-    }
-
-    @Test
-    public void testRestartsFailedRequestRestart() {
-        Request request = mock(Request.class);
-        when(request.isFailed()).thenReturn(true);
-        tracker.addRequest(request);
-
-        tracker.restartRequests();
-
-        verify(request).begin();
-    }
-
-    @Test
-    public void testPausesAndRestartsNotYetFinishedRequestsOnRestart() {
-        Request request = mock(Request.class);
-        when(request.isComplete()).thenReturn(false);
-        tracker.addRequest(request);
-
-        tracker.restartRequests();
-
-        verify(request).pause();
-        verify(request).begin();
-    }
-
-    @Test
-    public void testDoesNotBeginFailedRequestOnRestartIfPaused() {
-        Request request = mock(Request.class);
-        when(request.isFailed()).thenReturn(true);
-        tracker.pauseRequests();
-        tracker.addRequest(request);
-
-        tracker.restartRequests();
-
-        verify(request, never()).begin();
-    }
-
-    @Test
-    public void testPausesFailedRequestOnRestartIfPaused() {
-        Request request = mock(Request.class);
-        when(request.isFailed()).thenReturn(true);
-        tracker.pauseRequests();
-        tracker.addRequest(request);
-
-        tracker.restartRequests();
-        verify(request).pause();
-    }
-
-    @Test
-    public void testDoesNotBeginIncompleteRequestsOnRestartIfPaused() {
-        Request request = mock(Request.class);
-        when(request.isFailed()).thenReturn(false);
-        when(request.isComplete()).thenReturn(false);
-        tracker.pauseRequests();
-        tracker.addRequest(request);
-        tracker.restartRequests();
-
-        verify(request, never()).begin();
-    }
-
-    @Test
-    public void testPausesIncompleteRequestsOnRestartIfPaused() {
-        Request request = mock(Request.class);
-        when(request.isFailed()).thenReturn(false);
-        when(request.isComplete()).thenReturn(false);
-        tracker.pauseRequests();
-        tracker.addRequest(request);
-        tracker.restartRequests();
-
-        verify(request).pause();
-    }
-
-    @Test
-    public void testReturnsTrueFromIsPausedWhenPaused() {
-        tracker.pauseRequests();
-        assertTrue(tracker.isPaused());
-    }
-
-    @Test
-    public void testReturnsFalseFromIsPausedWhenResumed() {
-        tracker.resumeRequests();
-        assertFalse(tracker.isPaused());
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/provider/ChildLoadProviderTest.java b/library/src/androidTest/java/com/bumptech/glide/provider/ChildLoadProviderTest.java
deleted file mode 100644
index e12f87644..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/provider/ChildLoadProviderTest.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package com.bumptech.glide.provider;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.File;
-
-@RunWith(JUnit4.class)
-public class ChildLoadProviderTest {
-    private ChildLoadHarness harness;
-
-    @Before
-    public void setUp() {
-        harness = new ChildLoadHarness();
-    }
-
-    @Test
-    public void testReturnsParentModelLoader() {
-        when(harness.parent.getModelLoader()).thenReturn(harness.modelLoader);
-
-        assertEquals(harness.modelLoader, harness.provider.getModelLoader());
-    }
-
-    @Test
-    public void testReturnsParentSourceDecoderIfNoneIsSet() {
-        when(harness.parent.getSourceDecoder()).thenReturn(harness.decoder);
-
-        assertEquals(harness.decoder, harness.provider.getSourceDecoder());
-    }
-
-    @Test
-    public void testReturnsChildSourceDecoderIfSet() {
-        harness.provider.setSourceDecoder(harness.decoder);
-
-        assertEquals(harness.decoder, harness.provider.getSourceDecoder());
-    }
-
-    @Test
-    public void testReturnsParentCacheDecoderIfNoneIsSet() {
-        when(harness.parent.getCacheDecoder()).thenReturn(harness.cacheDecoder);
-
-        assertEquals(harness.cacheDecoder, harness.provider.getCacheDecoder());
-    }
-
-    @Test
-    public void testReturnsChildCacheDecoderIfSet() {
-        harness.provider.setCacheDecoder(harness.cacheDecoder);
-
-        assertEquals(harness.cacheDecoder, harness.provider.getCacheDecoder());
-    }
-
-    @Test
-    public void testReturnsParentEncoderIfNoneIsSet() {
-        when(harness.parent.getEncoder()).thenReturn(harness.encoder);
-
-        assertEquals(harness.encoder, harness.provider.getEncoder());
-    }
-
-    @Test
-    public void testReturnsChildEncoderIfSet() {
-        harness.provider.setEncoder(harness.encoder);
-
-        assertEquals(harness.encoder, harness.provider.getEncoder());
-    }
-
-    @Test
-    public void testReturnsParentTranscoderIfNoneIsSet() {
-        when(harness.parent.getTranscoder()).thenReturn(harness.transcoder);
-
-        assertEquals(harness.transcoder, harness.provider.getTranscoder());
-    }
-
-    @Test
-    public void testReturnsChildTranscoderIfSet() {
-        harness.provider.setTranscoder(harness.transcoder);
-
-        assertEquals(harness.transcoder, harness.provider.getTranscoder());
-    }
-
-    @Test
-    public void testReturnsParentSourceEncoderIfNoneIsSet() {
-        when(harness.parent.getSourceEncoder()).thenReturn(harness.sourceEncoder);
-
-        assertEquals(harness.sourceEncoder, harness.provider.getSourceEncoder());
-    }
-
-    @Test
-    public void testReturnsChildSourceEncoderIfSet() {
-        harness.provider.setSourceEncoder(harness.sourceEncoder);
-
-        assertEquals(harness.sourceEncoder, harness.provider.getSourceEncoder());
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class ChildLoadHarness {
-        ResourceEncoder<Object> encoder = mock(ResourceEncoder.class);
-        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
-        ResourceDecoder<Object, Object> decoder = mock(ResourceDecoder.class);
-        Encoder<Object> sourceEncoder = mock(Encoder.class);
-        ModelLoader<Object, Object> modelLoader = mock(ModelLoader.class);
-        LoadProvider<Object, Object, Object, Object> parent = mock(LoadProvider.class);
-        ResourceTranscoder<Object, Object> transcoder = mock(ResourceTranscoder.class);
-        ChildLoadProvider<Object, Object, Object, Object> provider =
-                new ChildLoadProvider<Object, Object, Object, Object>(parent);
-
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/provider/DataLoadProviderRegistryTest.java b/library/src/androidTest/java/com/bumptech/glide/provider/DataLoadProviderRegistryTest.java
deleted file mode 100644
index f1ad80518..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/provider/DataLoadProviderRegistryTest.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.bumptech.glide.provider;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class DataLoadProviderRegistryTest {
-    private DataLoadProviderRegistry factory;
-
-    @Before
-    public void setUp() {
-        factory = new DataLoadProviderRegistry();
-    }
-
-    @Test
-    public void testCanRegisterAndRetrieveDataLoadProvider() {
-        DataLoadProvider<Object, Object> provider = mock(DataLoadProvider.class);
-        factory.register(Object.class, Object.class, provider);
-
-        assertEquals(provider, factory.get(Object.class, Object.class));
-    }
-
-    @Test
-    public void testReturnsEmptyProviderIfNoneIsRegistered() {
-        DataLoadProvider<Object, Object> loadProvider = factory.get(Object.class, Object.class);
-        assertNotNull(loadProvider);
-
-        assertNull(loadProvider.getCacheDecoder());
-        assertNull(loadProvider.getSourceDecoder());
-        assertNull(loadProvider.getEncoder());
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java
deleted file mode 100644
index 9b133690e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java
+++ /dev/null
@@ -1,1038 +0,0 @@
-package com.bumptech.glide.request;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.engine.Engine;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.request.animation.GlideAnimation;
-import com.bumptech.glide.request.animation.GlideAnimationFactory;
-import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.Target;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GenericRequestTest {
-    private RequestHarness harness;
-
-    /**
-     * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
-     * Both are in the middle of the hierarchy having multiple descendants and ancestors.
-     */
-    @SuppressWarnings("unchecked")
-    private static class RequestHarness {
-        ModelLoader<Number, Object> modelLoader;
-        Engine engine = mock(Engine.class);
-        Number model = 123456;
-        Target<List> target = mock(Target.class);
-        Context context = Robolectric.application;
-        Resource<List> resource = mock(Resource.class);
-        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-        Priority priority = Priority.NORMAL;
-        int placeholderResourceId = 0;
-        Drawable placeholderDrawable = null;
-        int errorResourceId = 0;
-        Transformation transformation = mock(Transformation.class);
-        Drawable errorDrawable = null;
-        LoadProvider<Number, Object, Object, List> loadProvider = mock(LoadProvider.class);
-        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
-        ResourceDecoder<Object, Object> sourceDecoder = mock(ResourceDecoder.class);
-        ResourceEncoder<Object> encoder = mock(ResourceEncoder.class);
-        ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
-        Encoder<Object> sourceEncoder = mock(Encoder.class);
-        RequestListener<Number, List> requestListener = mock(RequestListener.class);
-        boolean skipMemoryCache;
-        GlideAnimationFactory<List> factory = mock(GlideAnimationFactory.class);
-        int overrideWidth = -1;
-        int overrideHeight = -1;
-        List result = new ArrayList();
-        DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
-        Key signature = mock(Key.class);
-
-        public RequestHarness() {
-            modelLoader = mock(ModelLoader.class);
-            when(modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt()))
-                    .thenReturn(mock(DataFetcher.class));
-            when(loadProvider.getModelLoader()).thenReturn(modelLoader);
-            when(loadProvider.getCacheDecoder()).thenReturn(cacheDecoder);
-            when(loadProvider.getSourceDecoder()).thenReturn(sourceDecoder);
-            when(loadProvider.getSourceEncoder()).thenReturn(sourceEncoder);
-            when(loadProvider.getEncoder()).thenReturn(encoder);
-            when(loadProvider.getTranscoder()).thenReturn(transcoder);
-            when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
-            when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
-
-            when(resource.get()).thenReturn(result);
-        }
-
-        public GenericRequest<Number, Object, Object, List> getRequest() {
-            return GenericRequest.obtain(loadProvider,
-                    model,
-                    signature,
-                    context,
-                    priority,
-                    target,
-                    1f,
-                    placeholderDrawable,
-                    placeholderResourceId,
-                    errorDrawable,
-                    errorResourceId,
-                    requestListener,
-                    requestCoordinator,
-                    engine,
-                    transformation,
-                    List.class,
-                    skipMemoryCache,
-                    factory,
-                    overrideWidth,
-                    overrideHeight,
-                    diskCacheStrategy);
-        }
-    }
-
-    @Before
-    public void setUp() {
-        harness = new RequestHarness();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenMissingCacheDecoderAndNeeded1() {
-        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
-        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenMissingCacheDecoderAndNeeded2() {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testReturnsWhenMissingCacheDecoderAndNeeded3() {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test
-    public void testReturnsWhenMissingCacheDecoderAndNotNeeded2() {
-        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
-        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);
-
-        assertNotNull(harness.getRequest());
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenMissingSourceDecoderAndNeeded1() {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenMissingSourceDecoderAndNeeded2() {
-        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
-        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test
-    public void testReturnsWhenMissingSourceDecoderAndNotNeeded1() {
-        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
-        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);
-
-        assertNotNull(harness.getRequest());
-    }
-
-    @Test
-    public void testReturnsWhenMissingSourceDecoderAndNotNeeded2() {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);
-
-        assertNotNull(harness.getRequest());
-    }
-
-    @Test(expected =  NullPointerException.class)
-    public void testThrowsWhenMissingEncoderWhenNeeded1() {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.loadProvider.getEncoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test(expected =  NullPointerException.class)
-    public void testThrowsWhenMissingEncoderWhenNeeded2() {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        when(harness.loadProvider.getEncoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test
-    public void testReturnsWhenMissingEncoderWhenNotNeeded1() {
-        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
-        when(harness.loadProvider.getEncoder()).thenReturn(null);
-
-        assertNotNull(harness.getRequest());
-    }
-
-    @Test
-    public void testReturnsWhenMissingEncoderWhenNotNeeded2() {
-        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
-        when(harness.loadProvider.getEncoder()).thenReturn(null);
-
-        assertNotNull(harness.getRequest());
-    }
-
-    @Test
-    public void testThrowsWhenMissingTranscoder() {
-        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
-            harness = new RequestHarness();
-            harness.diskCacheStrategy = strategy;
-            when(harness.loadProvider.getTranscoder()).thenReturn(null);
-
-            try {
-                harness.getRequest();
-                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
-            } catch (NullPointerException ex) {
-                // expected
-            }
-        }
-    }
-
-    @Test
-    public void testThrowsWhenMissingModelLoader() {
-        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
-            harness = new RequestHarness();
-            harness.diskCacheStrategy = strategy;
-            when(harness.loadProvider.getModelLoader()).thenReturn(null);
-
-            try {
-                harness.getRequest();
-                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
-            } catch (NullPointerException ex) {
-                // expected
-            }
-        }
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenMissingSourceEncoderAndNeeded1() {
-        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
-        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenMissingSourceEncoderAndNeeded2() {
-        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
-        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);
-
-        harness.getRequest();
-    }
-
-    @Test
-    public void testReturnsWhenMissingSourceEncoderAndNotNeeded1() {
-        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
-        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);
-
-        assertNotNull(harness.getRequest());
-    }
-
-    @Test
-    public void testReturnsWhenMissingSourceEncoderAndNotNeeded2() {
-        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
-        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);
-
-        assertNotNull(harness.getRequest());
-    }
-
-    @Test
-    public void testThrowsWhenTransformationIsNull() {
-        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
-            harness = new RequestHarness();
-            harness.diskCacheStrategy = strategy;
-            harness.transformation = null;
-
-            try {
-                harness.getRequest();
-                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
-            } catch (NullPointerException ex) {
-                // expected
-            }
-        }
-    }
-
-    @Test
-    public void testIsNotCompleteBeforeReceivingResource() {
-        GenericRequest request = harness.getRequest();
-
-        assertFalse(request.isComplete());
-    }
-
-    @Test
-    public void testCanHandleNullResources() {
-        GenericRequest request = harness.getRequest();
-
-        request.onResourceReady(null);
-
-        assertTrue(request.isFailed());
-        verify(harness.requestListener)
-                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
-    }
-
-    @Test
-    public void testCanHandleEmptyResources() {
-        GenericRequest request = harness.getRequest();
-        when(harness.resource.get()).thenReturn(null);
-
-        request.onResourceReady(harness.resource);
-
-        assertTrue(request.isFailed());
-        verify(harness.engine).release(eq(harness.resource));
-        verify(harness.requestListener)
-                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
-    }
-
-    @Test
-    public void testCanHandleNonConformingResources() {
-        GenericRequest request = harness.getRequest();
-        when(((Resource) (harness.resource)).get()).thenReturn("Invalid mocked String, this should be a List");
-
-        request.onResourceReady(harness.resource);
-
-        assertTrue(request.isFailed());
-        verify(harness.engine).release(eq(harness.resource));
-        verify(harness.requestListener)
-                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
-    }
-
-    @Test
-    public void testIsNotFailedAfterClear() {
-        GenericRequest request = harness.getRequest();
-
-        request.onResourceReady(null);
-        request.clear();
-
-        assertFalse(request.isFailed());
-    }
-
-    @Test
-    public void testIsPausedAfterPause() {
-        GenericRequest request = harness.getRequest();
-        request.pause();
-
-        assertTrue(request.isPaused());
-    }
-
-    @Test
-    public void testIsNotCancelledAfterPause() {
-        GenericRequest request = harness.getRequest();
-        request.pause();
-
-        assertFalse(request.isCancelled());
-    }
-
-    @Test
-    public void testIsNotPausedAfterBeginningWhilePaused() {
-        GenericRequest request = harness.getRequest();
-        request.pause();
-        request.begin();
-
-        assertFalse(request.isPaused());
-        assertTrue(request.isRunning());
-    }
-
-    @Test
-    public void testIsNotFailedAfterBegin() {
-        GenericRequest request = harness.getRequest();
-
-        request.onResourceReady(null);
-        request.begin();
-
-        assertFalse(request.isFailed());
-    }
-
-    @Test
-    public void testIsCompleteAfterReceivingResource() {
-        GenericRequest request = harness.getRequest();
-
-        request.onResourceReady(harness.resource);
-
-        assertTrue(request.isComplete());
-    }
-
-    @Test
-    public void testIsNotCompleteAfterClear() {
-        GenericRequest request = harness.getRequest();
-        request.onResourceReady(harness.resource);
-        request.clear();
-
-        assertFalse(request.isComplete());
-    }
-
-    @Test
-    public void testIsCancelledAfterClear() {
-        GenericRequest request = harness.getRequest();
-        request.clear();
-
-        assertTrue(request.isCancelled());
-    }
-
-    @Test
-    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
-        GenericRequest request = harness.getRequest();
-        request.clear();
-        request.clear();
-
-        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
-    }
-
-    @Test
-    public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
-        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                Request request = (Request) invocation.getArguments()[0];
-                assertFalse(request.isComplete());
-                return true;
-            }
-        }).when(requestCoordinator).canSetImage(any(Request.class));
-
-        harness.requestCoordinator = requestCoordinator;
-        GenericRequest request = harness.getRequest();
-
-        request.onResourceReady(harness.resource);
-
-        verify(requestCoordinator).canSetImage(eq(request));
-    }
-
-    @Test
-    public void testIsNotFailedWithoutException() {
-        GenericRequest request = harness.getRequest();
-
-        assertFalse(request.isFailed());
-    }
-
-    @Test
-    public void testIsFailedAfterException() {
-        GenericRequest request = harness.getRequest();
-
-        request.onException(new Exception("test"));
-        assertTrue(request.isFailed());
-    }
-
-    @Test
-    public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
-        GenericRequest request = harness.getRequest();
-        request.begin();
-        request.onSizeReady(100, 100);
-        request.onSizeReady(100, 100);
-
-        verify(harness.engine, times(1)).load(eq(harness.signature), eq(100), eq(100), any(DataFetcher.class),
-                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
-                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
-    }
-
-    @Test
-    public void testIsFailedAfterNoResultAndNullException() {
-        GenericRequest request = harness.getRequest();
-
-        request.onException(null);
-        assertTrue(request.isFailed());
-    }
-
-    @Test
-    public void testEngineLoadPassedCorrectPriority() {
-        Priority expected = Priority.HIGH;
-        harness.priority = expected;
-        GenericRequest request = harness.getRequest();
-        request.begin();
-
-        request.onSizeReady(100, 100);
-
-        verify(harness.engine).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
-                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
-                eq(expected), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
-    }
-
-    @Test
-    public void testEngineLoadCancelledOnCancel() {
-        Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
-        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
-                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
-                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
-                .thenReturn(loadStatus);
-
-        GenericRequest request = harness.getRequest();
-        request.begin();
-
-        request.onSizeReady(100, 100);
-        request.cancel();
-
-        verify(loadStatus).cancel();
-    }
-
-    @Test
-    public void testResourceIsRecycledOnClear() {
-        GenericRequest request = harness.getRequest();
-
-        request.onResourceReady(harness.resource);
-        request.clear();
-
-        verify(harness.engine).release(eq(harness.resource));
-    }
-
-    @Test
-    public void testPlaceholderResourceIsSet() {
-        final int expectedId = 12345;
-        Drawable expected = new ColorDrawable(Color.RED);
-
-        Context context = mockContextToReturn(expectedId, expected);
-        MockTarget target = new MockTarget();
-
-        harness.context = context;
-        harness.placeholderResourceId = expectedId;
-        harness.target = target;
-        GenericRequest request = harness.getRequest();
-        request.begin();
-
-        assertEquals(expected, target.currentPlaceholder);
-    }
-
-    @Test
-    public void testPlaceholderDrawableIsSet() {
-        Drawable expected = new ColorDrawable(Color.RED);
-
-        MockTarget target = new MockTarget();
-
-        harness.placeholderDrawable = expected;
-        harness.target = target;
-        GenericRequest request = harness.getRequest();
-        request.begin();
-
-        assertEquals(expected, target.currentPlaceholder);
-    }
-
-    @Test
-    public void testErrorResourceIsSetOnLoadFailed() {
-        final int expectedId = 12345;
-        Drawable expected = new ColorDrawable(Color.RED);
-
-        Context context = mockContextToReturn(expectedId, expected);
-        MockTarget target = new MockTarget();
-
-        harness.context = context;
-        harness.errorResourceId = expectedId;
-        harness.target = target;
-        GenericRequest request = harness.getRequest();
-
-        request.onException(null);
-
-        assertEquals(expected, target.currentPlaceholder);
-    }
-
-    @Test
-    public void testErrorDrawableIsSetOnLoadFailed() {
-        Drawable expected = new ColorDrawable(Color.RED);
-
-        MockTarget target = new MockTarget();
-
-        harness.errorDrawable = expected;
-        harness.target = target;
-        GenericRequest request = harness.getRequest();
-
-        request.onException(null);
-
-        assertEquals(expected, target.currentPlaceholder);
-    }
-
-    @Test
-    public void setTestPlaceholderDrawableSetOnNullModel() {
-        Drawable placeholder = new ColorDrawable(Color.RED);
-
-        MockTarget target = new MockTarget();
-
-        harness.placeholderDrawable = placeholder;
-        harness.target = target;
-        harness.model = null;
-        GenericRequest request = harness.getRequest();
-
-        request.begin();
-
-        assertEquals(placeholder, target.currentPlaceholder);
-    }
-
-    @Test
-    public void testErrorDrawableSetOnNullModel() {
-        Drawable placeholder = new ColorDrawable(Color.RED);
-        Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
-
-        MockTarget target = new MockTarget();
-
-        harness.placeholderDrawable = placeholder;
-        harness.errorDrawable = errorPlaceholder;
-        harness.target = target;
-        harness.model = null;
-        GenericRequest request = harness.getRequest();
-
-        request.begin();
-
-        assertEquals(errorPlaceholder, target.currentPlaceholder);
-    }
-
-    @Test
-    public void testIsNotRunningBeforeRunCalled() {
-        assertFalse(harness.getRequest().isRunning());
-    }
-
-    @Test
-    public void testIsRunningAfterRunCalled() {
-        Request request = harness.getRequest();
-        request.begin();
-        assertTrue(request.isRunning());
-    }
-
-    @Test
-    public void testIsNotRunningAfterComplete() {
-        GenericRequest request = harness.getRequest();
-        request.begin();
-        request.onResourceReady(harness.resource);
-
-        assertFalse(request.isRunning());
-    }
-
-    @Test
-    public void testIsNotRunningAfterFailing() {
-        GenericRequest request = harness.getRequest();
-        request.begin();
-        request.onException(new RuntimeException("Test"));
-
-        assertFalse(request.isRunning());
-    }
-
-    @Test
-    public void testIsNotRunningAfterClear() {
-        GenericRequest request = harness.getRequest();
-        request.begin();
-        request.clear();
-
-        assertFalse(request.isRunning());
-    }
-
-    @Test
-    public void testCallsTargetOnResourceReadyIfNoRequestListener() {
-        harness.requestListener = null;
-        GenericRequest request = harness.getRequest();
-        request.onResourceReady(harness.resource);
-
-        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
-        GenericRequest request = harness.getRequest();
-        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
-                anyBoolean(), anyBoolean())).thenReturn(false);
-        request.onResourceReady(harness.resource);
-
-        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
-        GenericRequest request = harness.getRequest();
-        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
-                anyBoolean(), anyBoolean())).thenReturn(true);
-        request.onResourceReady(harness.resource);
-
-        verify(harness.target, never()).onResourceReady(any(List.class), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testCallsTargetOnExceptionIfNoRequestListener() {
-        harness.requestListener = null;
-        GenericRequest request = harness.getRequest();
-        Exception exception = new IOException("test");
-        request.onException(exception);
-
-        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
-    }
-
-    @Test
-    public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
-        GenericRequest request = harness.getRequest();
-        when(harness.requestListener
-                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
-                .thenReturn(false);
-        Exception exception = new IOException("Test");
-        request.onException(exception);
-
-        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
-    }
-
-    @Test
-    public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
-        GenericRequest request = harness.getRequest();
-        when(harness.requestListener
-                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
-                .thenReturn(true);
-
-        request.onException(new IllegalArgumentException("test"));
-
-        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
-    }
-
-    @Test
-    public void testRequestListenerIsCalledWithResourceResult() {
-        GenericRequest request = harness.getRequest();
-        request.onResourceReady(harness.resource);
-
-        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
-                anyBoolean(), anyBoolean());
-    }
-
-    @Test
-    public void testRequestListenerIsCalledWithModel() {
-        GenericRequest request = harness.getRequest();
-        request.onResourceReady(harness.resource);
-
-        verify(harness.requestListener).onResourceReady(any(List.class), eq(harness.model), any(Target.class),
-                anyBoolean(), anyBoolean());
-    }
-
-    @Test
-    public void testRequestListenerIsCalledWithTarget() {
-        GenericRequest request = harness.getRequest();
-        request.onResourceReady(harness.resource);
-
-        verify(harness.requestListener).onResourceReady(any(List.class), any(Number.class), eq(harness.target),
-                anyBoolean(), anyBoolean());
-    }
-
-    @Test
-    public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
-        final GenericRequest request = harness.getRequest();
-        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
-                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
-                any(Priority.class), anyBoolean(),  any(DiskCacheStrategy.class),
-                any(ResourceCallback.class))).thenAnswer(new Answer<Object>() {
-                    @Override
-                    public Object answer(InvocationOnMock invocation) throws Throwable {
-                        request.onResourceReady(harness.resource);
-                        return null;
-                    }
-                });
-
-        request.begin();
-        request.onSizeReady(100, 100);
-        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
-                eq(true), anyBoolean());
-    }
-
-    @Test
-    public void testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
-        GenericRequest request = harness.getRequest();
-        request.onSizeReady(100, 100);
-        request.onResourceReady(harness.resource);
-
-        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
-                eq(false), anyBoolean());
-    }
-
-    @Test
-    public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
-        harness.requestCoordinator = null;
-        GenericRequest request = harness.getRequest();
-        request.onResourceReady(harness.resource);
-
-        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
-                anyBoolean(), eq(true));
-    }
-
-    @Test
-    public void testRequestListenerIsCalledWithIsFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
-        GenericRequest request = harness.getRequest();
-        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
-        request.onResourceReady(harness.resource);
-
-        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
-                anyBoolean(), eq(true));
-    }
-
-    @Test
-    public void testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
-        GenericRequest request = harness.getRequest();
-        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
-        request.onResourceReady(harness.resource);
-
-        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
-                anyBoolean(), eq(false));
-    }
-
-    @Test
-    public void testTargetIsCalledWithAnimationFromFactory() {
-        GenericRequest request = harness.getRequest();
-        GlideAnimation<List> glideAnimation = mock(GlideAnimation.class);
-        when(harness.factory.build(anyBoolean(), anyBoolean())).thenReturn(glideAnimation);
-        request.onResourceReady(harness.resource);
-
-        verify(harness.target).onResourceReady(eq(harness.result), eq(glideAnimation));
-    }
-
-    @Test
-    public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
-        harness.overrideWidth = -1;
-        harness.overrideHeight = 100;
-        GenericRequest request = harness.getRequest();
-        request.begin();
-
-        verify(harness.target).getSize(any(SizeReadyCallback.class));
-    }
-
-    @Test
-    public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
-        harness.overrideHeight = -1;
-        harness.overrideWidth = 100;
-        GenericRequest request = harness.getRequest();
-        request.begin();
-
-        verify(harness.target).getSize(any(SizeReadyCallback.class));
-    }
-
-    @Test
-    public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
-        harness.overrideWidth = 100;
-        harness.overrideHeight = 100;
-        GenericRequest request = harness.getRequest();
-        request.begin();
-
-        verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
-    }
-
-    @Test
-    public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
-        harness.overrideWidth = 1;
-        harness.overrideHeight = 2;
-
-        GenericRequest request = harness.getRequest();
-        request.begin();
-
-        verify(harness.engine).load(any(Key.class), eq(harness.overrideWidth), eq(harness.overrideHeight),
-                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
-                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
-                any(ResourceCallback.class));
-    }
-
-    @Test
-    public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
-        harness.errorDrawable = new ColorDrawable(Color.RED);
-        GenericRequest request = harness.getRequest();
-        when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
-        request.onException(new IOException("Test"));
-
-        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
-    }
-
-    @Test
-    public void testCanReRunCancelledRequests() {
-        doAnswer(new CallSizeReady(100, 100)).when(harness.target)
-                .getSize(any(SizeReadyCallback.class));
-        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
-                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
-                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
-                .thenAnswer(new CallResourceCallback(harness.resource));
-        GenericRequest request = harness.getRequest();
-
-        request.begin();
-        request.cancel();
-        request.begin();
-
-        verify(harness.target, times(2)).onResourceReady(eq(harness.result), any(GlideAnimation.class));
-    }
-
-    @Test
-    public void testResourceOnlyReceivesOneGetOnResourceReady() {
-        GenericRequest request = harness.getRequest();
-        request.onResourceReady(harness.resource);
-
-        verify(harness.resource, times(1)).get();
-    }
-
-    @Test
-    public void testOnSizeReadyWithNullDataFetcherCallsOnException() {
-        GenericRequest request = harness.getRequest();
-        when(harness.modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt())).thenReturn(null);
-        request.begin();
-        request.onSizeReady(100, 100);
-
-        verify(harness.requestListener).onException(any(Exception.class), any(Number.class), any(Target.class),
-                anyBoolean());
-    }
-
-    @Test
-    public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
-        GenericRequest request = harness.getRequest();
-        request.cancel();
-        request.onSizeReady(100, 100);
-
-        verify(harness.engine, never()).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
-                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
-                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
-    }
-
-    private static class CallResourceCallback implements Answer {
-
-        private Resource resource;
-
-        public CallResourceCallback(Resource resource) {
-            this.resource = resource;
-        }
-
-        @Override
-        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-            ResourceCallback cb = (ResourceCallback)
-                    invocationOnMock.getArguments()[invocationOnMock.getArguments().length - 1];
-            cb.onResourceReady(resource);
-            return null;
-        }
-    }
-
-    private static class CallSizeReady implements Answer {
-
-        private int width;
-        private int height;
-
-        public CallSizeReady(int width, int height) {
-            this.width = width;
-            this.height = height;
-        }
-
-        @Override
-        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-            SizeReadyCallback cb =
-                    (SizeReadyCallback) invocationOnMock.getArguments()[0];
-            cb.onSizeReady(width, height);
-            return null;
-        }
-    }
-
-    private Context mockContextToReturn(int resourceId, Drawable drawable) {
-        Resources resources = mock(Resources.class);
-        Context context = mock(Context.class);
-
-        when(context.getApplicationContext()).thenReturn(context);
-        when(context.getResources()).thenReturn(resources);
-        when(resources.getDrawable(eq(resourceId))).thenReturn(drawable);
-
-        return context;
-    }
-
-    private static class MockTarget implements Target {
-        private Drawable currentPlaceholder;
-
-        @Override
-        public void onLoadCleared(Drawable placeholder) {
-            currentPlaceholder = placeholder;
-        }
-
-        @Override
-        public void onLoadStarted(Drawable placeholder) {
-            currentPlaceholder = placeholder;
-
-        }
-
-        @Override
-        public void onLoadFailed(Exception e, Drawable errorDrawable) {
-            currentPlaceholder = errorDrawable;
-
-        }
-
-        @Override
-        public void onResourceReady(Object resource, GlideAnimation glideAnimation) {
-            currentPlaceholder = null;
-        }
-
-
-        @Override
-        public void getSize(SizeReadyCallback cb) {
-        }
-
-        @Override
-        public void setRequest(Request request) {
-        }
-
-        @Override
-        public Request getRequest() {
-            return null;
-        }
-
-        @Override
-        public void onStart() {
-        }
-
-        @Override
-        public void onStop() {
-
-        }
-
-        @Override
-        public void onDestroy() {
-
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java
deleted file mode 100644
index c7f5c944e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ /dev/null
@@ -1,356 +0,0 @@
-package com.bumptech.glide.request;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.os.Handler;
-
-import com.bumptech.glide.request.target.SizeReadyCallback;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class RequestFutureTargetTest {
-    private int width;
-    private int height;
-    private RequestFutureTarget<Object, Object> future;
-    private Request request;
-    private Handler handler;
-    private RequestFutureTarget.Waiter waiter;
-
-    @Before
-    public void setUp() {
-        width = 100;
-        height = 100;
-        handler = mock(Handler.class);
-        waiter = mock(RequestFutureTarget.Waiter.class);
-        future = new RequestFutureTarget<Object, Object>(handler, width, height, false, waiter);
-        request = mock(Request.class);
-        future.setRequest(request);
-    }
-
-    @Test
-    public void testCallsSizeReadyCallbackOnGetSize() {
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        future.getSize(cb);
-        verify(cb).onSizeReady(eq(width), eq(height));
-    }
-
-    @Test
-    public void testReturnsFalseForDoneBeforeDone() {
-        assertFalse(future.isDone());
-    }
-
-    @Test
-    public void testReturnsTrueFromIsDoneIfDone() {
-        future.onResourceReady(new Object(), null);
-        assertTrue(future.isDone());
-    }
-
-    @Test
-    public void testReturnsFalseForIsCancelledBeforeCancelled() {
-        assertFalse(future.isCancelled());
-    }
-
-    @Test
-    public void testReturnsTrueFromCancelIfNotYetDone() {
-        assertTrue(future.cancel(false));
-    }
-
-    @Test
-    public void testClearsRequestOnMainThreadIfNotYetDoneOnCancel() {
-        future.cancel(true);
-
-        verify(handler).post(eq(future));
-    }
-
-    @Test
-    public void testClearsOnMainThreadWhenClearCalled() {
-        future.clear();
-
-        verify(handler).post(eq(future));
-    }
-
-    @Test
-    public void testDoesNotRepeatedlyClearRequestOnMainThreadIfCancelledRepeatedly() {
-        future.cancel(true);
-        future.cancel(true);
-
-        verify(handler, times(1)).post(any(Runnable.class));
-    }
-
-    @Test
-    public void testClearsRequestOnRun() {
-        future.run();
-
-        verify(request).clear();
-    }
-
-    @Test
-    public void testDoesNotClearRequestIfCancelledAfterDone() {
-        future.onResourceReady(new Object(), null);
-        future.cancel(true);
-
-        verify(request, never()).clear();
-    }
-
-    @Test
-    public void testReturnsTrueFromDoneIfCancelled() {
-        future.cancel(true);
-        assertTrue(future.isDone());
-    }
-
-    @Test
-    public void testReturnsFalseFromIsCancelledIfCancelledAfterDone() {
-        future.onResourceReady(new Object(), null);
-        future.cancel(true);
-
-        assertFalse(future.isCancelled());
-    }
-
-    @Test
-    public void testReturnsTrueFromCancelIfCancelled() {
-        future.cancel(true);
-        assertTrue(future.isCancelled());
-    }
-
-    @Test
-    public void testReturnsFalseFromCancelIfDone() {
-        future.onResourceReady(new Object(), null);
-        assertFalse(future.cancel(true));
-    }
-
-    @Test
-    public void testReturnsResourceOnGetIfAlreadyDone() throws ExecutionException, InterruptedException {
-        Object expected = new Object();
-        future.onResourceReady(expected, null);
-
-        assertEquals(expected, future.get());
-    }
-
-    @Test
-    public void testReturnsResourceOnGetWithTimeoutIfAlreadyDone() throws InterruptedException, ExecutionException,
-            TimeoutException {
-        Object expected = new Object();
-        future.onResourceReady(expected, null);
-
-        assertEquals(expected, future.get(100, TimeUnit.MILLISECONDS));
-    }
-
-    @Test(expected = CancellationException.class)
-    public void testThrowsCancellationExceptionIfCancelledBeforeGet() throws ExecutionException, InterruptedException {
-        future.cancel(true);
-        future.get();
-    }
-
-    @Test(expected = CancellationException.class)
-    public void testThrowsCancellationExceptionIfCancelledBeforeGetWithTimeout()
-            throws InterruptedException, ExecutionException, TimeoutException {
-        future.cancel(true);
-        future.get(100, TimeUnit.MILLISECONDS);
-    }
-
-    @Test(expected = ExecutionException.class)
-    public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGet()
-            throws ExecutionException, InterruptedException {
-        future.onLoadFailed(new RuntimeException(), null);
-        future.get();
-    }
-
-    @Test(expected = ExecutionException.class)
-    public void testThrowsExecutionExceptionOnGetIfExceptionWithNullValueBeforeGet()
-            throws ExecutionException, InterruptedException, TimeoutException {
-        future.onLoadFailed(null, null);
-        future.get(100, TimeUnit.MILLISECONDS);
-    }
-
-    @Test(expected = ExecutionException.class)
-    public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGetWithTimeout()
-            throws ExecutionException, InterruptedException, TimeoutException {
-        future.onLoadFailed(new RuntimeException(), null);
-        future.get(100, TimeUnit.MILLISECONDS);
-    }
-
-    @Test(expected = TimeoutException.class)
-    public void testThrowsTimeoutExceptionOnGetIfFailedToReceiveResourceInTime()
-            throws InterruptedException, ExecutionException, TimeoutException {
-        future.get(1, TimeUnit.MILLISECONDS);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsExceptionIfGetCalledOnMainThread() throws ExecutionException, InterruptedException {
-        future = new RequestFutureTarget<Object, Object>(handler, width, height, true, waiter);
-        future.get();
-    }
-
-    @Test(expected = InterruptedException.class)
-    public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting() throws InterruptedException,
-            ExecutionException {
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Thread.currentThread().interrupt();
-                return null;
-            }
-        }).when(waiter).waitForTimeout(eq(future), anyLong());
-
-        future.get();
-    }
-
-    @Test(expected = ExecutionException.class)
-    public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting() throws ExecutionException, InterruptedException {
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                future.onLoadFailed(new IllegalArgumentException("test"), null);
-                return null;
-            }
-        }).when(waiter).waitForTimeout(eq(future), anyLong());
-        future.get();
-    }
-
-    @Test(expected = CancellationException.class)
-    public void testThrowsCancellationExceptionIfCancelledWhileWaiting() throws ExecutionException,
-            InterruptedException {
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                future.cancel(false);
-                return null;
-            }
-        }).when(waiter).waitForTimeout(eq(future), anyLong());
-        future.get();
-    }
-
-    @Test(expected = TimeoutException.class)
-    public void testThrowsTimeoutExceptionIfFinishesWaitingWithTimeoutAndDoesNotReceiveResult() throws
-            ExecutionException,
-            InterruptedException, TimeoutException {
-        future.get(1, TimeUnit.MILLISECONDS);
-    }
-
-    @Test(expected = AssertionError.class)
-    public void testThrowsAssertionErrorIfFinishesWaitingWithoutTimeoutAndDoesNotReceiveResult() throws
-            ExecutionException, InterruptedException {
-        future.get();
-    }
-
-    @Test
-    public void testNotifiesAllWhenLoadFails() {
-        future.onLoadFailed(null, null);
-        verify(waiter).notifyAll(eq(future));
-    }
-
-    @Test
-    public void testNotifiesAllWhenResourceReady() {
-        future.onResourceReady(null, null);
-        verify(waiter).notifyAll(eq(future));
-    }
-
-    @Test
-    public void testNotifiesAllOnCancelIfNotCancelled() {
-        future.cancel(false);
-        verify(waiter).notifyAll(eq(future));
-    }
-
-    @Test
-    public void testDoesNotNotifyAllOnSecondCancel() {
-        future.cancel(true);
-        verify(waiter).notifyAll(eq(future));
-        future.cancel(true);
-        verify(waiter, times(1)).notifyAll(eq(future));
-    }
-
-    @Test
-    public void testReturnsResourceIfReceivedWhileWaiting() throws ExecutionException, InterruptedException {
-        final Object expected = new Object();
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                future.onResourceReady(expected, null);
-                return null;
-            }
-        }).when(waiter).waitForTimeout(eq(future), anyLong());
-        assertEquals(expected, future.get());
-    }
-
-    @Test
-    public void testWaitsForeverIfNoTimeoutSet() throws InterruptedException {
-        try {
-            future.get();
-        } catch (ExecutionException e) {
-            throw new RuntimeException(e);
-        } catch (AssertionError e) {
-            // Expected.
-        }
-        verify(waiter).waitForTimeout(eq(future), eq(0L));
-    }
-
-    @Test
-    public void testWaitsForGivenTimeoutMillisIfTimeoutSet() throws InterruptedException {
-        long timeout = 1234;
-        try {
-            future.get(1234, TimeUnit.MILLISECONDS);
-        } catch (InterruptedException e) {
-            throw new RuntimeException(e);
-        } catch (ExecutionException e) {
-            throw new RuntimeException(e);
-        } catch (TimeoutException e) {
-            // Expected.
-        }
-
-        verify(waiter).waitForTimeout(eq(future), eq(timeout));
-    }
-
-    @Test
-    public void testConvertsOtherTimeUnitsToMillisForWaiter() throws InterruptedException {
-        long timeoutSeconds = 10;
-        try {
-            future.get(timeoutSeconds, TimeUnit.SECONDS);
-        } catch (InterruptedException e) {
-            throw new RuntimeException(e);
-        } catch (ExecutionException e) {
-            throw new RuntimeException(e);
-        } catch (TimeoutException e) {
-            // Expected.
-        }
-
-        verify(waiter).waitForTimeout(eq(future), eq(TimeUnit.SECONDS.toMillis(timeoutSeconds)));
-    }
-
-    @Test
-    public void testDoesNotWaitIfGivenTimeOutEqualToZero() throws InterruptedException {
-        try {
-            future.get(0, TimeUnit.MILLISECONDS);
-        } catch (InterruptedException e) {
-            throw new RuntimeException(e);
-        } catch (ExecutionException e) {
-            throw new RuntimeException(e);
-        } catch (TimeoutException e) {
-            // Expected.
-        }
-
-        verify(waiter, never()).waitForTimeout(eq(future), anyLong());
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
deleted file mode 100644
index 86239d848..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ /dev/null
@@ -1,306 +0,0 @@
-package com.bumptech.glide.request;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.InOrder;
-
-@RunWith(JUnit4.class)
-public class ThumbnailRequestCoordinatorTest {
-    private Request full;
-    private Request thumb;
-    private ThumbnailRequestCoordinator coordinator;
-    private RequestCoordinator parent;
-
-    @Before
-    public void setUp() {
-        full = mock(Request.class);
-        thumb = mock(Request.class);
-        parent = mock(RequestCoordinator.class);
-        coordinator = new ThumbnailRequestCoordinator();
-        coordinator.setRequests(full, thumb);
-    }
-
-    @Test
-    public void testIsRunningIsFalseIfNeitherRequestIsRunning() {
-        assertFalse(coordinator.isRunning());
-    }
-
-    @Test
-    public void testIsRunningIsTrueIfFullIsRunning() {
-        when(full.isRunning()).thenReturn(true);
-        assertTrue(coordinator.isRunning());
-    }
-
-    @Test
-    public void testIsNotRunningIfFullIsNotRunningButThumbIs() {
-        when(full.isRunning()).thenReturn(false);
-        when(thumb.isRunning()).thenReturn(true);
-        assertFalse(coordinator.isRunning());
-    }
-
-    @Test
-    public void testStartsFullOnRunIfNotRunning() {
-        when(full.isRunning()).thenReturn(false);
-        coordinator.begin();
-
-        verify(full).begin();
-    }
-
-    @Test
-    public void testStartsThumbOnRunIfNotRunning() {
-        when(thumb.isRunning()).thenReturn(false);
-        coordinator.begin();
-
-        verify(thumb).begin();
-    }
-
-    @Test
-    public void testDoesNotStartFullOnRunIfRunning() {
-        when(full.isRunning()).thenReturn(true);
-        coordinator.begin();
-
-        verify(full, never()).begin();
-    }
-
-    @Test
-    public void testDoesNotStartThumbOnRunIfRunning() {
-        when(thumb.isRunning()).thenReturn(true);
-        coordinator.begin();
-
-        verify(thumb, never()).begin();
-    }
-
-    @Test
-    public void testCallsClearOnRequestsWhenCleared() {
-        coordinator.clear();
-        InOrder order = inOrder(thumb, full);
-        order.verify(thumb).clear();
-        order.verify(full).clear();
-    }
-
-    @Test
-    public void testRecyclesRequestsWhenRecycled() {
-        coordinator.recycle();
-        verify(thumb).recycle();
-        verify(full).recycle();
-    }
-
-    @Test
-    public void testIsPausedWhenFullIsPaused() {
-        when(full.isPaused()).thenReturn(true);
-        assertTrue(coordinator.isPaused());
-    }
-
-    @Test
-    public void testPausesBothRequestsWhenPaused() {
-        coordinator.pause();
-        verify(full).pause();
-        verify(thumb).pause();
-    }
-
-    @Test
-    public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
-        coordinator = new ThumbnailRequestCoordinator();
-        coordinator.setRequests(full, thumb);
-        assertTrue(coordinator.canSetImage(full));
-    }
-
-    @Test
-    public void testCanSetImageReturnsTrueForFullRequestIfParentAllowsSetImage() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        when(parent.canSetImage(eq(coordinator))).thenReturn(true);
-        assertTrue(coordinator.canSetImage(full));
-    }
-
-    @Test
-    public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImage() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        when(parent.canSetImage(eq(coordinator))).thenReturn(false);
-        assertFalse(coordinator.canSetImage(full));
-    }
-
-    @Test
-    public void testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
-        when(full.isResourceSet()).thenReturn(false);
-        assertTrue(coordinator.canSetImage(thumb));
-    }
-
-    @Test
-    public void testCanSetImageReturnsFalseForThumbRequestIfParentIsNullAndFullHasResourceSet() {
-        when(full.isResourceSet()).thenReturn(true);
-        assertFalse(coordinator.canSetImage(thumb));
-    }
-
-    @Test
-    public void testCanSetImageReturnsFalseForThumbRequestIfParentDoesNotAllowSetImageAndFullDoesNotHaveResourceSet() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        when(parent.canSetImage(eq(coordinator))).thenReturn(false);
-        when(full.isResourceSet()).thenReturn(false);
-        assertFalse(coordinator.canSetImage(thumb));
-    }
-
-    @Test
-    public void testCanNotifyStatusChangedIfFullAndNoRequestsAreComplete() {
-        assertTrue(coordinator.canNotifyStatusChanged(full));
-    }
-
-    @Test
-    public void testCanNotNotifyStatusChangedIfThumb() {
-        assertFalse(coordinator.canNotifyStatusChanged(thumb));
-    }
-
-    @Test
-    public void testCanNotNotifyStatusChangedIfFullHasResourceSet() {
-        when(full.isResourceSet()).thenReturn(true);
-        assertFalse(coordinator.canNotifyStatusChanged(full));
-    }
-
-    @Test
-    public void testCanNotNotifyStatusChangedIfThumbHasResourceSet() {
-        when(thumb.isResourceSet()).thenReturn(true);
-        assertFalse(coordinator.canNotifyStatusChanged(full));
-    }
-
-    @Test
-    public void testCanNotNotifyStatusChangedIfParentHasResourceSet() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        when(parent.isAnyResourceSet()).thenReturn(true);
-        assertFalse(coordinator.canNotifyStatusChanged(full));
-    }
-
-    @Test
-    public void testCanNotifyStatusChangedIfParentAllowsNotify() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(true);
-        assertTrue(coordinator.canNotifyStatusChanged(full));
-    }
-
-    @Test
-    public void testCanNotNotifyStatusChangedIfParentDoesNotAllowNotify() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(false);
-        assertFalse(coordinator.canNotifyStatusChanged(full));
-    }
-
-    @Test
-    public void testIsAnyResourceSetIsFalseIfNeitherRequestHasResourceSet() {
-        when(full.isResourceSet()).thenReturn(false);
-        when(thumb.isResourceSet()).thenReturn(false);
-        assertFalse(coordinator.isAnyResourceSet());
-    }
-
-    @Test
-    public void testIsAnyResourceSetIsTrueIfFullHasResourceSet() {
-        when(full.isResourceSet()).thenReturn(true);
-        when(thumb.isResourceSet()).thenReturn(false);
-        assertTrue(coordinator.isAnyResourceSet());
-    }
-
-    @Test
-    public void testIsAnyResourceSetIsTrueIfThumbHasResourceSet() {
-        when(full.isResourceSet()).thenReturn(false);
-        when(thumb.isResourceSet()).thenReturn(true);
-        assertTrue(coordinator.isAnyResourceSet());
-    }
-
-    @Test
-    public void testIsAnyResourceSetIsTrueIfParentIsNonNullAndParentHasResourceSet() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-
-        when(parent.isAnyResourceSet()).thenReturn(true);
-        when(full.isResourceSet()).thenReturn(false);
-        when(thumb.isResourceSet()).thenReturn(false);
-
-        assertTrue(coordinator.isAnyResourceSet());
-    }
-
-    @Test
-    public void testIsNotCompleteIfNeitherRequestIsComplete() {
-        assertFalse(coordinator.isComplete());
-    }
-
-    @Test
-    public void testIsCompleteIfFullIsComplete() {
-        when(full.isComplete()).thenReturn(true);
-        assertTrue(coordinator.isComplete());
-    }
-
-    @Test
-    public void testIsCompleteIfThumbIsComplete() {
-        when(thumb.isComplete()).thenReturn(true);
-        assertTrue(coordinator.isComplete());
-    }
-
-    @Test
-    public void testIsResourceSetIsFalseIfNeitherRequestHasResourceSet() {
-        assertFalse(coordinator.isResourceSet());
-    }
-
-    @Test
-    public void testIsResourceSetIsTrueIfFullRequestHasResourceSet() {
-        when(full.isResourceSet()).thenReturn(true);
-        assertTrue(coordinator.isResourceSet());
-    }
-
-    @Test
-    public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
-        when(thumb.isResourceSet()).thenReturn(true);
-        assertTrue(coordinator.isResourceSet());
-    }
-
-    @Test
-    public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
-        coordinator.onRequestSuccess(full);
-        verify(thumb).clear();
-    }
-
-    @Test
-    public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        coordinator.onRequestSuccess(full);
-        verify(parent).onRequestSuccess(eq(coordinator));
-    }
-
-    @Test
-    public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        coordinator.onRequestSuccess(full);
-        verify(thumb).clear();
-    }
-
-    @Test
-    public void testDoesNotClearThumbOnThumbRequestComplete() {
-        coordinator.onRequestSuccess(thumb);
-        verify(thumb, never()).clear();
-    }
-
-    @Test
-    public void testDoesNotNotifyParentOnThumbRequestComplete() {
-        coordinator = new ThumbnailRequestCoordinator(parent);
-        coordinator.setRequests(full, thumb);
-        coordinator.onRequestSuccess(thumb);
-
-        verify(parent, never()).onRequestSuccess(any(Request.class));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactoryTest.java
deleted file mode 100644
index 5293af089..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactoryTest.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.mockito.Mockito.mock;
-
-import android.graphics.drawable.Drawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class DrawableCrossFadeFactoryTest {
-
-    private DrawableCrossFadeFactory<Drawable> factory;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
-        factory = new DrawableCrossFadeFactory<Drawable>(viewAnimationFactory, 100 /*duration*/);
-    }
-
-    @Test
-    public void testReturnsNoAnimationIfFromMemoryCache() {
-        assertEquals(NoAnimation.<Drawable>get(), factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/));
-    }
-
-    @Test
-    public void testReturnsReturnsAnimationIfNotFromMemoryCacheAndIsFirstResource() {
-        assertNotEquals(NoAnimation.<Drawable>get(),
-                factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/));
-    }
-
-    @Test
-    public void testReturnsAnimationIfNotFromMemocyCacheAndNotIsFirstResource() {
-        assertNotEquals(NoAnimation.<Drawable>get(),
-                factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimationTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimationTest.java
deleted file mode 100644
index 1cf4622c9..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimationTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import static com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.TransitionDrawable;
-import android.widget.ImageView;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class DrawableCrossFadeViewAnimationTest {
-    private CrossFadeHarness harness;
-
-    @Before
-    public void setup() {
-        harness = new CrossFadeHarness();
-    }
-
-    @Test
-    public void testStartsDefaultAnimationIfNoPreviousDrawableIsNotSet() {
-        when(harness.adapter.getView()).thenReturn(harness.view);
-        harness.animation.animate(harness.current, harness.adapter);
-        verify(harness.defaultAnimation).animate(eq(harness.current), eq(harness.adapter));
-    }
-
-    @Test
-    public void testIgnoresNullViews() {
-        when(harness.adapter.getView()).thenReturn(null);
-        harness.animation.animate(harness.current, harness.adapter);
-    }
-
-    @Test
-    public void testReturnsFalseIfStartsDefaultAnimation() {
-        assertFalse(harness.animation.animate(harness.current, harness.adapter));
-    }
-
-    @Test
-    public void testSetsTransitionDrawableIfPreviousIsNotNull() {
-        Drawable previous = new ColorDrawable(Color.WHITE);
-        when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
-        harness.animation.animate(harness.current, harness.adapter);
-
-        verify(harness.adapter).setDrawable(any(TransitionDrawable.class));
-    }
-
-    @Test
-    public void testReturnsTrueIfSetsTransitionDrawable() {
-        Drawable previous = new ColorDrawable(Color.RED);
-        when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
-        assertTrue(harness.animation.animate(harness.current, harness.adapter));
-    }
-
-    @SuppressWarnings("unchecked")
-    private static class CrossFadeHarness {
-        Drawable current = new ColorDrawable(Color.GRAY);
-        ViewAdapter adapter = mock(ViewAdapter.class);
-        ImageView view = mock(ImageView.class);
-        GlideAnimation<Drawable> defaultAnimation = mock(GlideAnimation.class);
-        int duration = 200;
-        DrawableCrossFadeViewAnimation<Drawable> animation = new DrawableCrossFadeViewAnimation<Drawable>(
-                defaultAnimation, duration);
-    }
-}
-
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationFactoryTest.java
deleted file mode 100644
index 511282c9f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationFactoryTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.view.View;
-import android.view.animation.Animation;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ViewAnimationFactoryTest {
-    private ViewAnimation.AnimationFactory animationFactory;
-    private ViewAnimationFactory<Object> factory;
-
-    @Before
-    public void setUp() {
-        animationFactory = mock(ViewAnimation.AnimationFactory.class);
-        factory = new ViewAnimationFactory<Object>(animationFactory);
-    }
-
-    @Test
-    public void testFactoryReturnsNoAnimationIfFromMemoryCache() {
-        GlideAnimation<Object> animation = factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/);
-        assertEquals(NoAnimation.get(), animation);
-        verify(animationFactory, never()).build();
-    }
-
-    @Test
-    public void testFactoryReturnsNoAnimationIfNotFirstResource() {
-        GlideAnimation<Object> animation = factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/);
-        assertEquals(NoAnimation.get(), animation);
-        verify(animationFactory, never()).build();
-    }
-
-    @Test
-    public void testFactoryReturnsActualAnimationIfNotIsFromMemoryCacheAndIsFirstResource() {
-        GlideAnimation<Object> glideAnimation = factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/);
-
-        Animation animation = mock(Animation.class);
-        when(animationFactory.build()).thenReturn(animation);
-
-        GlideAnimation.ViewAdapter adapter = mock(GlideAnimation.ViewAdapter.class);
-        View view = mock(View.class);
-        when(adapter.getView()).thenReturn(view);
-        glideAnimation.animate(new Object(), adapter);
-
-        verify(view).startAnimation(eq(animation));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationTest.java
deleted file mode 100644
index 5a72ed65a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import static com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter;
-import static org.junit.Assert.assertFalse;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.view.animation.Animation;
-import android.widget.ImageView;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ViewAnimationTest {
-    private ViewAnimation<Object> viewAnimation;
-    private ViewAdapter adapter;
-    private ImageView view;
-    private ViewAnimation.AnimationFactory animationFactory;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp() {
-        animationFactory = mock(ViewAnimation.AnimationFactory.class);
-        view = mock(ImageView.class);
-        adapter = mock(ViewAdapter.class);
-        when(adapter.getView()).thenReturn(view);
-        viewAnimation = new ViewAnimation<Object>(animationFactory);
-    }
-
-    @Test
-    public void testClearsAnimationOnAnimate() {
-        viewAnimation.animate(null, adapter);
-
-        verify(view).clearAnimation();
-    }
-
-    @Test
-    public void testAlwaysReturnsFalse() {
-        assertFalse(viewAnimation.animate(null, adapter));
-    }
-
-    @Test
-    public void testStartsAnimationOnAnimate() {
-        Animation animation = mock(Animation.class);
-        when(animationFactory.build()).thenReturn(animation);
-        viewAnimation.animate(null, adapter);
-        verify(view).clearAnimation();
-        verify(view).startAnimation(eq(animation));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactoryTest.java
deleted file mode 100644
index a3b7e6614..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactoryTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.mockito.Mockito.mock;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ViewPropertyAnimationFactoryTest {
-
-    private ViewPropertyAnimationFactory<Object> factory;
-
-    @Before
-    public void setUp() {
-        ViewPropertyAnimation.Animator animator = mock(ViewPropertyAnimation.Animator.class);
-        factory = new ViewPropertyAnimationFactory<Object>(animator);
-    }
-
-    @Test
-    public void testReturnsNoAnimationIfFromMemoryCache() {
-        assertEquals(NoAnimation.get(), factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/));
-    }
-
-    @Test
-    public void testReturnsNoAnimationIfNotFirstResource() {
-        assertEquals(NoAnimation.get(), factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/));
-    }
-
-    @Test
-    public void testReturnsAnimationIfNotFromMemoryCacheAndFirstResource() {
-        assertNotEquals(NoAnimation.get(), factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationTest.java
deleted file mode 100644
index 3b9cacf18..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationTest.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import static com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter;
-import static org.junit.Assert.assertFalse;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.view.View;
-import android.widget.ImageView;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ViewPropertyAnimationTest {
-    private ViewPropertyAnimation.Animator animator;
-    private ViewPropertyAnimation animation;
-
-    @Before
-    public void setUp() {
-        animator = mock(ViewPropertyAnimation.Animator.class);
-        animation = new ViewPropertyAnimation(animator);
-    }
-
-    @Test
-    public void testAlwaysReturnsFalse() {
-        assertFalse(animation.animate(new Object(), mock(ViewAdapter.class)));
-    }
-
-    @Test
-    public void testCallsAnimatorWithGivenView() {
-        ImageView view = new ImageView(Robolectric.application);
-        ViewAdapter adapter = mock(ViewAdapter.class);
-        when(adapter.getView()).thenReturn(view);
-        animation.animate(new Object(), adapter);
-
-        verify(animator).animate(eq(view));
-    }
-
-    @Test
-    public void testDoesNotCallAnimatorIfGivenAdapterWithNullView() {
-        ViewAdapter adapter = mock(ViewAdapter.class);
-        animation.animate(new Object(), adapter);
-
-        verify(animator, never()).animate(any(View.class));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
deleted file mode 100644
index 0659bbe14..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ /dev/null
@@ -1,136 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import android.appwidget.AppWidgetManager;
-import android.content.ComponentName;
-import android.graphics.Bitmap;
-import android.widget.RemoteViews;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowAppWidgetManager;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = AppWidgetTargetTest.UpdateShadowAppWidgetManager.class)
-public class AppWidgetTargetTest {
-
-    private UpdateShadowAppWidgetManager shadowManager;
-    private RemoteViews views;
-    private int viewId;
-
-    @Before
-    public void setUp() {
-        shadowManager = Robolectric.shadowOf_(AppWidgetManager.getInstance(Robolectric.application));
-        viewId = 1234;
-        views = mock(RemoteViews.class);
-    }
-
-    @Test
-    public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName() {
-        ComponentName componentName = mock(ComponentName.class);
-        AppWidgetTarget target = new AppWidgetTarget(Robolectric.application, views, viewId, componentName);
-
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        target.onResourceReady(bitmap, null /*glideAnimation*/);
-
-        verify(views).setImageViewBitmap(eq(viewId), eq(bitmap));
-    }
-
-    @Test
-    public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
-        ComponentName componentName = mock(ComponentName.class);
-        AppWidgetTarget target = new AppWidgetTarget(Robolectric.application, views, viewId, componentName);
-
-        target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null /*glideAnimation*/);
-
-        assertEquals(componentName, shadowManager.updatedComponentName);
-        assertEquals(views, shadowManager.updatedRemoteViews);
-    }
-
-    @Test
-    public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
-        int[] widgetIds = new int[] { 1 };
-        AppWidgetTarget target = new AppWidgetTarget(Robolectric.application, views, viewId, widgetIds);
-
-        Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
-        target.onResourceReady(bitmap, null /*glideAnimation*/);
-
-        verify(views).setImageViewBitmap(eq(viewId), eq(bitmap));
-    }
-
-    @Test
-    public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
-        int[] widgetIds = new int[] { 1 };
-        AppWidgetTarget target = new AppWidgetTarget(Robolectric.application, views, viewId, widgetIds);
-
-        target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null /*glideAnimation*/);
-
-        assertThat(widgetIds).isEqualTo(shadowManager.updatedWidgetIds);
-        assertEquals(views, shadowManager.updatedRemoteViews);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenGivenNullContextWithWidgetIds() {
-        new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, 1 /*widgetIds*/);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenGivenNullContextWithComponentName() {
-        new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, mock(ComponentName.class));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
-        new AppWidgetTarget(Robolectric.application, null /*remoteViews*/, viewId, 1 /*widgetIds*/);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
-        new AppWidgetTarget(Robolectric.application, null /*remoteViews*/, viewId, mock(ComponentName.class));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenGivenNullWidgetIds() {
-        new AppWidgetTarget(Robolectric.application, views, viewId, (int[]) null /*widgetIds*/);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsWhenGivenEmptyWidgetIds() {
-        new AppWidgetTarget(Robolectric.application, views, viewId);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsWhenGivenNullComponentName() {
-        new AppWidgetTarget(Robolectric.application, views, viewId, (ComponentName) null);
-    }
-
-    @Implements(AppWidgetManager.class)
-    public static class UpdateShadowAppWidgetManager extends ShadowAppWidgetManager {
-        public int[] updatedWidgetIds;
-        public RemoteViews updatedRemoteViews;
-        public ComponentName updatedComponentName;
-
-        @Implementation
-        public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
-            updatedWidgetIds = appWidgetIds;
-            updatedRemoteViews = views;
-        }
-
-        @Implementation
-        public void updateAppWidget(ComponentName componentName, RemoteViews views) {
-            updatedComponentName = componentName;
-            updatedRemoteViews = views;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
deleted file mode 100644
index c25b75f8a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static org.junit.Assert.assertEquals;
-
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.widget.ImageView;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class BitmapImageViewTargetTest {
-
-    private ImageView view;
-    private BitmapImageViewTarget target;
-
-    @Before
-    public void setUp() {
-        view = new ImageView(Robolectric.application);
-        target = new BitmapImageViewTarget(view);
-    }
-
-    @Test
-    public void testSetsBitmapOnViewInSetResource() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 75, Bitmap.Config.RGB_565);
-        target.setResource(bitmap);
-        assertEquals(bitmap, ((BitmapDrawable) view.getDrawable()).getBitmap());
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/GlideDrawableImageViewTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/GlideDrawableImageViewTargetTest.java
deleted file mode 100644
index a4ca6bbed..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/GlideDrawableImageViewTargetTest.java
+++ /dev/null
@@ -1,267 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Canvas;
-import android.graphics.ColorFilter;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.widget.ImageView;
-
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GlideDrawableImageViewTargetTest {
-
-    @Test
-    public void testSetsDrawableOnViewInSetResource() {
-        ImageView view = new ImageView(Robolectric.application);
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(view);
-        GlideDrawable expected = new MockAnimatedDrawable();
-
-        target.setResource(expected);
-
-        assertEquals(expected, view.getDrawable());
-    }
-
-    @Test
-    public void testWrapsDrawableInSquaringDrawableIfDrawableAndViewAreSquare() {
-        ImageView mockView = mock(ImageView.class);
-        when(mockView.getWidth()).thenReturn(100);
-        when(mockView.getHeight()).thenReturn(100);
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(mockView);
-        GlideDrawable drawable = new MockAnimatedDrawable() {
-            @Override
-            public int getIntrinsicHeight() {
-                return 100;
-            }
-
-            @Override
-            public int getIntrinsicWidth() {
-                return 100;
-            }
-        };
-
-
-        target.onResourceReady(drawable, null);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                Drawable drawable = (Drawable) invocation.getArguments()[0];
-                assertThat(drawable).isInstanceOf(SquaringDrawable.class);
-                return null;
-            }
-        }).when(mockView).setImageDrawable(any(Drawable.class));
-        verify(mockView).setImageDrawable(any(BitmapDrawable.class));
-    }
-
-    @Test
-    public void testDoesNotWrapInSquaringDrawableIfDrawableIsAnimated() {
-        ImageView mockView = mock(ImageView.class);
-        when(mockView.getWidth()).thenReturn(100);
-        when(mockView.getHeight()).thenReturn(100);
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(mockView);
-        GlideDrawable drawable = new MockAnimatedDrawable() {
-            @Override
-            public int getIntrinsicHeight() {
-                return 100;
-            }
-
-            @Override
-            public int getIntrinsicWidth() {
-                return 100;
-            }
-        };
-         target.onResourceReady(drawable, null);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                Drawable drawable = (Drawable) invocation.getArguments()[0];
-                assertThat(drawable).isNotInstanceOf(SquaringDrawable.class);
-                return null;
-            }
-        }).when(mockView).setImageDrawable(any(Drawable.class));
-        verify(mockView).setImageDrawable(any(BitmapDrawable.class));
-    }
-
-    @Test
-    public void testDoesNotWrapInSquaringDrawableIfDrawableIsNotSquare() {
-        ImageView mockView = mock(ImageView.class);
-        when(mockView.getWidth()).thenReturn(100);
-        when(mockView.getHeight()).thenReturn(100);
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(mockView);
-        GlideDrawable drawable = new MockAnimatedDrawable() {
-            @Override
-            public int getIntrinsicHeight() {
-                return 100;
-            }
-
-            @Override
-            public int getIntrinsicWidth() {
-                return 150;
-            }
-        };
-         target.onResourceReady(drawable, null);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                Drawable drawable = (Drawable) invocation.getArguments()[0];
-                assertThat(drawable).isNotInstanceOf(SquaringDrawable.class);
-                return null;
-            }
-        }).when(mockView).setImageDrawable(any(Drawable.class));
-        verify(mockView).setImageDrawable(any(BitmapDrawable.class));
-    }
-
-    @Test
-    public void testDoesNotWrapInSquaringDrawableIfViewNotSquare() {
-        ImageView mockView = mock(ImageView.class);
-        when(mockView.getWidth()).thenReturn(100);
-        when(mockView.getHeight()).thenReturn(150);
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(mockView);
-        GlideDrawable drawable = new MockAnimatedDrawable() {
-            @Override
-            public int getIntrinsicHeight() {
-                return 100;
-            }
-
-            @Override
-            public int getIntrinsicWidth() {
-                return 100;
-            }
-        };
-         target.onResourceReady(drawable, null);
-
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                Drawable drawable = (Drawable) invocation.getArguments()[0];
-                assertThat(drawable).isNotInstanceOf(SquaringDrawable.class);
-                return null;
-            }
-        }).when(mockView).setImageDrawable(any(Drawable.class));
-        verify(mockView).setImageDrawable(any(BitmapDrawable.class));
-    }
-
-    @Test
-    public void testStartsAnimatableDrawablesInOnReasourceReady() {
-        MockAnimatedDrawable drawable = new MockAnimatedDrawable();
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(new ImageView(Robolectric.application));
-        target.onResourceReady(drawable, null);
-
-        assertTrue(drawable.isStarted);
-    }
-
-    @Test
-    public void testStartsAnimatableDrawablesOnStart() {
-        MockAnimatedDrawable drawable = new MockAnimatedDrawable();
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(new ImageView(Robolectric.application));
-        target.onResourceReady(drawable, null);
-        target.onStop();
-        target.onStart();
-
-        assertTrue(drawable.isStarted);
-    }
-
-    @Test
-    public void testDoesNotStartNullDrawablesOnStart() {
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(new ImageView(Robolectric.application));
-        target.onStart();
-    }
-
-    @Test
-    public void testStopsAnimatedDrawablesOnStop() {
-        MockAnimatedDrawable drawable = new MockAnimatedDrawable();
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(new ImageView(Robolectric.application));
-        target.onResourceReady(drawable, null);
-        target.onStop();
-
-        assertFalse(drawable.isStarted);
-    }
-
-    @Test
-    public void testDoesNotStopNullDrawablesOnStop() {
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(new ImageView(Robolectric.application));
-        target.onStop();
-    }
-
-    @Test
-    public void testSetsLoopCountOnDrawable() {
-        int maxLoopCount = 6;
-        MockAnimatedDrawable drawable = new MockAnimatedDrawable();
-        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(new ImageView(Robolectric.application),
-                maxLoopCount);
-        target.onResourceReady(drawable, null);
-        assertEquals(maxLoopCount, drawable.loopCount);
-    }
-
-    private static class MockAnimatedDrawable extends GlideDrawable {
-        private boolean isStarted;
-        private int loopCount;
-
-        @Override
-        public void start() {
-            isStarted = true;
-        }
-
-        @Override
-        public void stop() {
-            isStarted = false;
-        }
-
-        @Override
-        public boolean isRunning() {
-            return false;
-        }
-
-        @Override
-        public void draw(Canvas canvas) {
-
-        }
-
-        @Override
-        public void setAlpha(int i) {
-
-        }
-
-        @Override
-        public void setColorFilter(ColorFilter colorFilter) {
-
-        }
-
-        @Override
-        public int getOpacity() {
-            return 0;
-        }
-
-        @Override
-        public boolean isAnimated() {
-            return false;
-        }
-
-        @Override
-        public void setLoopCount(int loopCount) {
-            this.loopCount = loopCount;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
deleted file mode 100644
index 0fca40555..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
-
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import android.widget.ImageView;
-
-import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ImageViewTargetFactoryTest {
-    private ImageViewTargetFactory factory;
-    private ImageView view;
-
-    @Before
-    public void setUp() {
-        factory = new ImageViewTargetFactory();
-        view = new ImageView(Robolectric.application);
-    }
-
-    @Test
-    public void testReturnsTargetForBitmaps() {
-        Bitmap bitmap = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-        Target<Bitmap> target = factory.buildTarget(view, Bitmap.class);
-        target.onResourceReady(bitmap, null);
-        assertThat(target).isInstanceOf(BitmapImageViewTarget.class);
-    }
-
-    @Test
-    public void testReturnsTargetForGlideDrawables() {
-        GlideDrawable glideDrawable = mock(GlideDrawable.class);
-        Target<GlideDrawable> target = factory.buildTarget(view, GlideDrawable.class);
-        target.onResourceReady(glideDrawable, null);
-        assertThat(target).isInstanceOf(GlideDrawableImageViewTarget.class);
-    }
-
-    @Test
-    public void testReturnsTargetForGifDrawables() {
-        GifDrawable gifDrawable = mock(GifDrawable.class);
-        Target target = factory.buildTarget(view, GifDrawable.class);
-        target.onResourceReady(gifDrawable, null);
-        assertThat(target).isInstanceOf(GlideDrawableImageViewTarget.class);
-    }
-
-    @Test
-    public void testReturnsTargetForGlideBitmapDrawables() {
-        GlideBitmapDrawable drawable = mock(GlideBitmapDrawable.class);
-        Target target = factory.buildTarget(view, GlideBitmapDrawable.class);
-        target.onResourceReady(drawable, null);
-        assertThat(target).isInstanceOf(GlideDrawableImageViewTarget.class);
-    }
-
-    @Test
-    public void testReturnsTargetForBitmapDrawables() {
-        BitmapDrawable drawable = new BitmapDrawable(Robolectric.application.getResources(),
-                Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
-
-        Target target = factory.buildTarget(view, BitmapDrawable.class);
-        target.onResourceReady(drawable, null);
-        assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
-    }
-
-    @Test
-    public void testReturnsTargetForDrawables() {
-        Target<Drawable> target = factory.buildTarget(view, Drawable.class);
-        target.onResourceReady(new ColorDrawable(Color.RED), null);
-        assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsForUnknownType() {
-        factory.buildTarget(view, Object.class);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
deleted file mode 100644
index 4cbe7419e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import android.widget.ImageView;
-
-import com.bumptech.glide.request.animation.GlideAnimation;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ImageViewTargetTest {
-
-    private ImageView view;
-    private TestTarget target;
-    private ColorDrawable drawable;
-
-    @Before
-    public void setUp() {
-        view = new ImageView(Robolectric.application);
-        target = new TestTarget(view);
-        drawable = new ColorDrawable(Color.RED);
-    }
-
-    @Test
-    public void testReturnsCurrentDrawable() {
-        view.setImageDrawable(drawable);
-
-        assertEquals(drawable, target.getCurrentDrawable());
-    }
-
-    @Test
-    public void testSetsDrawableSetsDrawableOnView() {
-        target.setDrawable(drawable);
-
-        assertEquals(drawable, view.getDrawable());
-    }
-
-    @Test
-    public void testSetsDrawableOnLoadStarted() {
-        target.onLoadStarted(drawable);
-
-        assertEquals(drawable, view.getDrawable());
-    }
-
-    @Test
-    public void testSetDrawableOnLoadFailed() {
-        target.onLoadFailed(null, drawable);
-
-        assertEquals(drawable, view.getDrawable());
-    }
-
-    @Test
-    public void testSetsDrawableOnLoadCleared() {
-        target.onLoadCleared(drawable);
-
-        assertEquals(drawable, view.getDrawable());
-    }
-
-    @Test
-    public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
-        GlideAnimation<Drawable> animation = mock(GlideAnimation.class);
-        when(animation.animate(any(Drawable.class), eq(target))).thenReturn(false);
-        Drawable resource = new ColorDrawable(Color.GRAY);
-        target.onResourceReady(resource, animation);
-
-        assertEquals(resource, target.resource);
-    }
-
-    @Test
-    public void testDoesNotSetDrawableOnViewInOnResourceReadyWhenAnimationReturnsTrue() {
-        Drawable resource = new ColorDrawable(Color.RED);
-        GlideAnimation<Drawable> animation = mock(GlideAnimation.class);
-        when(animation.animate(eq(resource), eq(target))).thenReturn(true);
-        target.onResourceReady(resource, animation);
-
-        assertNull(target.resource);
-    }
-
-    @Test
-    public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
-        Drawable placeholder = new ColorDrawable(Color.BLACK);
-        view.setImageDrawable(placeholder);
-
-        GlideAnimation<Drawable> animation = mock(GlideAnimation.class);
-
-        target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
-
-        verify(animation).animate(eq(placeholder), eq(target));
-    }
-
-    private static class TestTarget extends ImageViewTarget<Drawable> {
-        public Drawable resource;
-
-        public TestTarget(ImageView view) {
-            super(view);
-        }
-
-        @Override
-        protected void setResource(Drawable resource) {
-            this.resource = resource;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/NotificationTargetTest.java
deleted file mode 100644
index e32a3a628..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.widget.RemoteViews;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowNotificationManager;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = NotificationTargetTest.UpdateShadowNotificationManager.class)
-public class NotificationTargetTest {
-
-    private UpdateShadowNotificationManager shadowManager;
-    private RemoteViews remoteViews;
-    private int viewId;
-    private Notification notification;
-    private int notificationId;
-    private NotificationTarget target;
-
-    @Before
-    public void setUp() {
-        NotificationManager notificationManager =
-                (NotificationManager) Robolectric.application.getSystemService(Context.NOTIFICATION_SERVICE);
-        shadowManager = Robolectric.shadowOf_(notificationManager);
-
-        remoteViews = mock(RemoteViews.class);
-        viewId = 123;
-        notification = mock(Notification.class);
-        notificationId = 456;
-
-
-        target = new NotificationTarget(Robolectric.application, remoteViews, viewId, 100 /*width*/, 100 /*height*/,
-                notification, notificationId);
-    }
-
-    @Test
-    public void testSetsBitmapOnRemoteViewsWithGivenImageIdOnResourceReady() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        target.onResourceReady(bitmap, null /*glideAnimation*/);
-        verify(remoteViews).setImageViewBitmap(eq(viewId), eq(bitmap));
-    }
-
-    @Test
-    public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourceReady() {
-        target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null /*glideAnimation*/);
-
-        assertEquals(notificationId, shadowManager.updatedNotificationId);
-        assertEquals(notification, shadowManager.updatedNotification);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfContextIsNull() {
-        new NotificationTarget(null /*context*/, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
-                100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
-    }
-
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfNotificationIsNull() {
-        new NotificationTarget(Robolectric.application, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
-                100 /*height*/, null /*notification*/, 456 /*notificationId*/);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfRemoteViewsIsNull() {
-        new NotificationTarget(Robolectric.application, null /*remoteViews*/, 123 /*viewId*/, 100 /*width*/,
-                100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
-    }
-
-    @Implements(NotificationManager.class)
-    public static class UpdateShadowNotificationManager extends ShadowNotificationManager {
-        int updatedNotificationId;
-        Notification updatedNotification;
-
-        @Implementation
-        public void notify(int notificationId, Notification notification) {
-            updatedNotificationId = notificationId;
-            updatedNotification = notification;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java
deleted file mode 100644
index 31adb437f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import com.bumptech.glide.request.Request;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class PreloadTargetTest {
-
-    @Test
-    public void testCallsSizeReadyWithGivenDimensions() {
-        int width = 1234;
-        int height = 456;
-        PreloadTarget<Object> target = PreloadTarget.obtain(width, height);
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        verify(cb).onSizeReady(eq(width), eq(height));
-    }
-
-    @Test
-    public void testClearsTargetInOnResourceReady() {
-        Request request = mock(Request.class);
-        PreloadTarget<Object> target = PreloadTarget.obtain(100, 100);
-        target.setRequest(request);
-        target.onResourceReady(new Object(), null);
-
-        verify(request).clear();
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java
deleted file mode 100644
index 7575ea8d4..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.request.animation.GlideAnimation;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class SimpleTargetTest {
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsOnGetSizeIfGivenWidthIsLessThanZero() {
-        getTarget(-1, 1).getSize(mock(SizeReadyCallback.class));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsOnGetSizeIfGivenWidthIsEqualToZero() {
-        getTarget(0, 1).getSize(mock(SizeReadyCallback.class));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsOnGetSizeIfGivenHeightIsLessThanZero() {
-        getTarget(1, -1).getSize(mock(SizeReadyCallback.class));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {
-        getTarget(1, 0).getSize(mock(SizeReadyCallback.class));
-    }
-
-    @Test
-    public void testCanBeConstructedWithoutDimensions() {
-        getTarget();
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsOnGetSizeIfConstructedWithoutDimensions() {
-        getTarget().getSize(mock(SizeReadyCallback.class));
-    }
-
-    private SimpleTarget<Object> getTarget() {
-        return new SimpleTarget<Object>() {
-            @Override
-            public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {
-                // Do nothing.
-            }
-        };
-    }
-
-    private SimpleTarget<Object> getTarget(int width, int height) {
-        return new SimpleTarget<Object>(width, height) {
-            @Override
-            public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {
-                // Do nothing.
-            }
-        };
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/ViewTargetTest.java
deleted file mode 100644
index cd1f6e24e..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ /dev/null
@@ -1,401 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static com.google.common.truth.Truth.assertThat;
-import static android.view.ViewGroup.LayoutParams;
-import static android.view.ViewTreeObserver.OnPreDrawListener;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.content.Context;
-import android.graphics.drawable.Drawable;
-import android.view.View;
-import android.view.ViewTreeObserver;
-import android.view.WindowManager;
-
-import com.bumptech.glide.request.Request;
-import com.bumptech.glide.request.animation.GlideAnimation;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowDisplay;
-import org.robolectric.shadows.ShadowView;
-import org.robolectric.shadows.ShadowViewTreeObserver;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { ViewTargetTest.SizedShadowView.class,
-        ViewTargetTest.PreDrawShadowViewTreeObserver.class })
-public class ViewTargetTest {
-    private View view;
-    private ViewTarget target;
-
-    @Before
-    public void setUp() {
-        view = new View(Robolectric.application);
-        target = new TestViewTarget(view);
-    }
-
-    @Test
-    public void testReturnsWrappedView() {
-        assertEquals(view, target.getView());
-    }
-
-    @Test
-    public void testReturnsNullFromGetRequestIfNoRequestSet() {
-        assertNull(target.getRequest());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsIfViewTagIsNotRequestObject() {
-        view.setTag(new Object());
-        target.getRequest();
-    }
-
-    @Test
-    public void testCanSetAndRetrieveRequest() {
-        Request request = mock(Request.class);
-
-        target.setRequest(request);
-
-        assertEquals(request, target.getRequest());
-    }
-
-    @Test
-    public void testRetrievesRequestFromPreviousTargetForView() {
-        Request request = mock(Request.class);
-
-        target.setRequest(request);
-
-        ViewTarget<View, Object> second = new TestViewTarget(view);
-
-        assertEquals(request, second.getRequest());
-    }
-
-    @Test
-    public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
-        int dimens = 333;
-        SizedShadowView shadowView = Robolectric.shadowOf_(view);
-        shadowView.setWidth(dimens);
-        shadowView.setHeight(dimens);
-
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        verify(cb).onSizeReady(eq(dimens), eq(dimens));
-    }
-
-    @Test
-    public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet() {
-        int dimens = 444;
-        LayoutParams layoutParams = new LayoutParams(dimens, dimens);
-        view.setLayoutParams(layoutParams);
-
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        verify(cb).onSizeReady(eq(dimens), eq(dimens));
-    }
-
-    @Test
-    public void testSizeCallbackIsCalledSynchronouslyWithScreenSizeIfLayoutParamsWrapContent() {
-        LayoutParams layoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
-        view.setLayoutParams(layoutParams);
-
-        int width = 1234;
-        int height = 674;
-        WindowManager windowManager = (WindowManager) view.getContext()
-                .getSystemService(Context.WINDOW_SERVICE);
-        ShadowDisplay shadowDisplay = Robolectric.shadowOf(windowManager.getDefaultDisplay());
-        shadowDisplay.setWidth(width);
-        shadowDisplay.setHeight(height);
-
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        verify(cb).onSizeReady(eq(width), eq(height));
-    }
-
-    @Test
-    public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        int width = 12;
-        int height = 32;
-        SizedShadowView shadowView = Robolectric.shadowOf_(view);
-        shadowView.setWidth(width);
-        shadowView.setHeight(height);
-
-        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowObserver.fireOnPreDrawListeners();
-
-        verify(cb).onSizeReady(eq(width), eq(height));
-    }
-
-    @Test
-    public void testSizeCallbacksAreCalledInOrderPreDraw() {
-        SizeReadyCallback[] cbs = new SizeReadyCallback[25];
-        for (int i = 0; i < cbs.length; i++) {
-            cbs[i] = mock(SizeReadyCallback.class);
-            target.getSize(cbs[i]);
-        }
-
-        int width = 100, height = 111;
-        SizedShadowView shadowView = Robolectric.shadowOf_(view);
-        shadowView.setWidth(width);
-        shadowView.setHeight(height);
-
-        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowObserver.fireOnPreDrawListeners();
-
-        InOrder order = inOrder((Object[]) cbs);
-        for (SizeReadyCallback cb : cbs) {
-            order.verify(cb).onSizeReady(eq(width), eq(height));
-        }
-    }
-
-    @Test
-    public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-        target.getSize(cb);
-
-        view.setLayoutParams(new LayoutParams(100, 100));
-
-        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowObserver.fireOnPreDrawListeners();
-
-        verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
-    }
-
-    @Test
-    public void testDoesNotAddMultipleListenersIfMultipleCallbacksAreAdded() {
-        SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
-        SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
-        target.getSize(cb1);
-        target.getSize(cb2);
-
-        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
-    }
-
-    @Test
-    public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest() {
-        SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
-        target.getSize(cb1);
-
-        view.setLayoutParams(new LayoutParams(100, 100));
-
-        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowObserver.fireOnPreDrawListeners();
-
-        assertThat(shadowObserver.getPreDrawListeners()).hasSize(0);
-
-        SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
-        view.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-        target.getSize(cb2);
-
-        view.setLayoutParams(new LayoutParams(100, 100));
-        shadowObserver.fireOnPreDrawListeners();
-
-        verify(cb2).onSizeReady(anyInt(), anyInt());
-    }
-
-    @Test
-    public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowObserver.fireOnPreDrawListeners();
-
-        verify(cb, never()).onSizeReady(anyInt(), anyInt());
-        assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
-    }
-
-    @Test
-    public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        int width = 689;
-        int height = 354;
-        LayoutParams layoutParams = new LayoutParams(width, height);
-        view.setLayoutParams(layoutParams);
-
-        PreDrawShadowViewTreeObserver shadowViewTreeObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowViewTreeObserver.fireOnPreDrawListeners();
-
-        verify(cb).onSizeReady(eq(width), eq(height));
-    }
-
-    @Test
-    public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        LayoutParams layoutParams = new LayoutParams(1234, 4123);
-        view.setLayoutParams(layoutParams);
-
-        PreDrawShadowViewTreeObserver shadowViewTreeObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowViewTreeObserver.fireOnPreDrawListeners();
-        shadowViewTreeObserver.fireOnPreDrawListeners();
-
-        verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
-    }
-
-    @Test
-    public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
-        SizeReadyCallback firstCb = mock(SizeReadyCallback.class);
-        SizeReadyCallback secondCb = mock(SizeReadyCallback.class);
-        target.getSize(firstCb);
-        target.getSize(secondCb);
-
-        int width = 68;
-        int height = 875;
-        LayoutParams layoutParams = new LayoutParams(width, height);
-        view.setLayoutParams(layoutParams);
-
-        PreDrawShadowViewTreeObserver shadowViewTreeObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowViewTreeObserver.fireOnPreDrawListeners();
-        shadowViewTreeObserver.fireOnPreDrawListeners();
-
-        verify(firstCb, times(1)).onSizeReady(eq(width), eq(height));
-        verify(secondCb, times(1)).onSizeReady(eq(width), eq(height));
-    }
-
-    @Test
-    public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
-        SizeReadyCallback cb = mock(SizeReadyCallback.class);
-        target.getSize(cb);
-
-        int width = 1;
-        int height = 2;
-        LayoutParams layoutParams = new LayoutParams(width, height);
-        view.setLayoutParams(layoutParams);
-
-        PreDrawShadowViewTreeObserver shadowViewTreeObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        shadowViewTreeObserver.setIsAlive(false);
-        shadowViewTreeObserver.fireOnPreDrawListeners();
-
-        verify(cb).onSizeReady(eq(width), eq(height));
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfGivenNullView() {
-        ViewTarget viewTarget = new TestViewTarget(null);
-    }
-
-    @Implements(ViewTreeObserver.class)
-    public static class PreDrawShadowViewTreeObserver extends ShadowViewTreeObserver {
-        private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners =
-                new CopyOnWriteArrayList<OnPreDrawListener>();
-        private boolean isAlive = true;
-
-        @SuppressWarnings("unused")
-        @Implementation
-        public void addOnPreDrawListener(OnPreDrawListener listener) {
-            checkIsAlive();
-            preDrawListeners.add(listener);
-        }
-
-        @SuppressWarnings("unused")
-        @Implementation
-        public void removeOnPreDrawListener(OnPreDrawListener listener) {
-            checkIsAlive();
-            preDrawListeners.remove(listener);
-        }
-
-        @Implementation
-        public boolean isAlive() {
-            return isAlive;
-        }
-
-        private void checkIsAlive() {
-            if (!isAlive()) {
-                throw new IllegalStateException("ViewTreeObserver is not alive!");
-            }
-        }
-
-        public void setIsAlive(boolean isAlive) {
-            this.isAlive = isAlive;
-        }
-
-        public void fireOnPreDrawListeners() {
-            for (OnPreDrawListener listener : preDrawListeners) {
-                listener.onPreDraw();
-            }
-        }
-
-        public List<OnPreDrawListener> getPreDrawListeners() {
-            return preDrawListeners;
-        }
-    }
-
-    @Implements(View.class)
-    public static class SizedShadowView extends ShadowView {
-        private int width;
-        private int height;
-
-        public void setWidth(int width) {
-            this.width = width;
-        }
-
-        public void setHeight(int height) {
-            this.height = height;
-        }
-
-        @Implementation
-        public int getWidth() {
-            return width;
-        }
-
-        @Implementation
-        public int getHeight() {
-            return height;
-        }
-    }
-
-    private static class TestViewTarget extends ViewTarget<View, Object> {
-
-        public TestViewTarget(View view) {
-            super(view);
-        }
-
-        @Override
-        public void onLoadStarted(Drawable placeholder) {
-
-        }
-
-        @Override
-        public void onLoadFailed(Exception e, Drawable errorDrawable) {
-
-        }
-
-        @Override
-        public void onResourceReady(Object resource, GlideAnimation glideAnimation) {
-
-        }
-
-        @Override
-        public void onLoadCleared(Drawable placeholder) {
-
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java
deleted file mode 100644
index 69ff5fb6c..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.bumptech.glide.resize.load;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.testutil.TestResourceUtil;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ExifTest {
-
-    private InputStream open(String imageName) throws IOException {
-        return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
-    }
-
-    private void assertOrientation(String filePrefix, int expectedOrientation) {
-        InputStream is = null;
-        try {
-            is = open(filePrefix + "_" + expectedOrientation + ".jpg");
-            assertEquals(new ImageHeaderParser(is).getOrientation(), expectedOrientation);
-        } catch (IOException e) {
-            e.printStackTrace();
-            assertNull(e);
-        } finally {
-            if (is != null) {
-                try {
-                    is.close();
-                } catch (IOException e) {
-                    // Do nothing.
-                }
-            }
-        }
-    }
-
-    @Test
-    public void testLandscape() throws IOException {
-        for (int i = 1; i <= 8; i++) {
-            assertOrientation("Landscape", i);
-        }
-    }
-
-    @Test
-    public void testPortrait() throws IOException {
-        for (int i = 1; i <= 8; i++) {
-            assertOrientation("Portrait", i);
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/androidTest/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
deleted file mode 100644
index 09386d4ad..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.bumptech.glide.signature;
-
-import static org.junit.Assert.assertNotNull;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.After;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ApplicationVersionSignatureTest {
-
-    @After
-    public void tearDown() {
-        ApplicationVersionSignature.reset();
-    }
-
-    @Test
-    public void testCanGetKeyForSignature() {
-        Key key = ApplicationVersionSignature.obtain(Robolectric.application);
-        assertNotNull(key);
-    }
-
-    @Test
-    public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage() throws NoSuchAlgorithmException,
-            UnsupportedEncodingException {
-        Key first = ApplicationVersionSignature.obtain(Robolectric.application);
-        Key second = ApplicationVersionSignature.obtain(Robolectric.application);
-        KeyAssertions.assertSame(first, second);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/androidTest/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
deleted file mode 100644
index 3756c648f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class MediaStoreSignatureTest {
-
-    @Test
-    public void testSignaturesDifferIfMimeTypeDiffers() throws UnsupportedEncodingException, NoSuchAlgorithmException {
-        MediaStoreSignature first = new MediaStoreSignature("first", 100, 1);
-        MediaStoreSignature second = new MediaStoreSignature("second", 100, 1);
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testSignaturesDifferIfDateModifiedDiffers() throws UnsupportedEncodingException,
-            NoSuchAlgorithmException {
-        MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-        MediaStoreSignature second = new MediaStoreSignature("mimeType", 999, 1);
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testSignaturesDifferIfOrientationDiffers() throws UnsupportedEncodingException,
-            NoSuchAlgorithmException {
-        MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-        MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 9);
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testSignaturesAreTheSameIfAllArgsAreTheSame() throws UnsupportedEncodingException,
-            NoSuchAlgorithmException {
-        MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-        MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 1);
-
-        KeyAssertions.assertSame(first, second);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/signature/StringSignatureTest.java b/library/src/androidTest/java/com/bumptech/glide/signature/StringSignatureTest.java
deleted file mode 100644
index 3aaed56e1..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/signature/StringSignatureTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class StringSignatureTest {
-
-    @Test
-    public void testStringSignatureIsNotEqualIfStringDiffers() throws UnsupportedEncodingException,
-            NoSuchAlgorithmException {
-        StringSignature first = new StringSignature("first");
-        StringSignature second = new StringSignature("second");
-
-        KeyAssertions.assertDifferent(first, second);
-    }
-
-    @Test
-    public void testStringSignatureIsEqualIfStringIsTheSame() throws UnsupportedEncodingException,
-            NoSuchAlgorithmException {
-        StringSignature first = new StringSignature("signature");
-        StringSignature second = new StringSignature("signature");
-
-        KeyAssertions.assertSame(first, second);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/BackgroundUtil.java b/library/src/androidTest/java/com/bumptech/glide/tests/BackgroundUtil.java
deleted file mode 100644
index 02768303a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/tests/BackgroundUtil.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.tests;
-
-public class BackgroundUtil {
-    public interface BackgroundTester {
-        public void runTest() throws Exception;
-    }
-
-    public static void testInBackground(BackgroundTester test) throws InterruptedException {
-        TestThread thread = new TestThread(test);
-        thread.start();
-        thread.join();
-        if (thread.exception != null) {
-            throw new RuntimeException(thread.exception);
-        }
-    }
-
-    private static class TestThread extends Thread {
-        private Exception exception;
-        private BackgroundTester test;
-
-        public TestThread(BackgroundTester test) {
-            this.test = test;
-        }
-
-        @Override
-        public void run() {
-            super.run();
-            try {
-                test.runTest();
-            } catch (Exception e) {
-                exception = e;
-            }
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/src/androidTest/java/com/bumptech/glide/tests/ContentResolverShadow.java
deleted file mode 100644
index e679dfbe6..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/tests/ContentResolverShadow.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.bumptech.glide.tests;
-
-import android.content.ContentResolver;
-import android.content.res.AssetFileDescriptor;
-import android.net.Uri;
-
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowContentResolver;
-
-import java.util.HashMap;
-import java.util.Map;
-
-@Implements(ContentResolver.class)
-public class ContentResolverShadow extends ShadowContentResolver {
-    private Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<Uri, AssetFileDescriptor>();
-
-    public void registerFileDescriptor(Uri uri, AssetFileDescriptor fileDescriptor) {
-        fileDescriptorMap.put(uri, fileDescriptor);
-    }
-
-    @Implementation
-    public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode) {
-        AssetFileDescriptor fileDescriptor = fileDescriptorMap.get(uri);
-        if (fileDescriptor != null) {
-            return fileDescriptor;
-        } else {
-            return null;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/androidTest/java/com/bumptech/glide/tests/KeyAssertions.java
deleted file mode 100644
index 139dad9ba..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/tests/KeyAssertions.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.bumptech.glide.tests;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-
-import com.bumptech.glide.load.Key;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public class KeyAssertions {
-
-    public static void assertSame(Key first, Key second) throws UnsupportedEncodingException, NoSuchAlgorithmException {
-        assertSameOrdered(first, second);
-        assertSameOrdered(second, first);
-    }
-
-    private static void assertSameOrdered(Key first, Key second) throws UnsupportedEncodingException,
-            NoSuchAlgorithmException {
-        assertEquals(first, second);
-        assertEquals(first.hashCode(), second.hashCode());
-
-        assertThat(getDigest(first)).isEqualTo(getDigest(second));
-    }
-
-    public static void assertDifferent(Key first, Key second)
-            throws NoSuchAlgorithmException, UnsupportedEncodingException {
-        assertDifferent(first, second, true);
-        assertDifferent(second, first, true);
-    }
-
-    public static void assertDifferent(Key first, Key second, boolean diskCacheDiffers)
-            throws NoSuchAlgorithmException, UnsupportedEncodingException {
-        assertNotEquals(first, second);
-        assertNotEquals(first.hashCode(), second.hashCode());
-
-        if (diskCacheDiffers) {
-            MessageDigest firstDigest = MessageDigest.getInstance("SHA-1");
-            first.updateDiskCacheKey(firstDigest);
-            MessageDigest secondDigest = MessageDigest.getInstance("SHA-1");
-            second.updateDiskCacheKey(secondDigest);
-
-            assertNotEquals(getDigest(first), getDigest(second));
-        }
-    }
-
-    private static byte[] getDigest(Key key) throws NoSuchAlgorithmException, UnsupportedEncodingException {
-        MessageDigest md = MessageDigest.getInstance("SHA-1");
-        key.updateDiskCacheKey(md);
-        return md.digest();
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/Util.java b/library/src/androidTest/java/com/bumptech/glide/tests/Util.java
deleted file mode 100644
index 08ef49e2a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/tests/Util.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package com.bumptech.glide.tests;
-
-import static org.junit.Assert.assertEquals;
-
-import android.os.Build;
-
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-public class Util {
-
-    public static String getExpectedClassId(Class clazz) {
-        return clazz.getSimpleName() + "." + clazz.getPackage().getName();
-    }
-
-    public static void assertClassHasValidId(Class clazz, String id) {
-        assertEquals(getExpectedClassId(clazz), id);
-    }
-
-    public static boolean isWindows() {
-        return System.getProperty("os.name").startsWith("Windows");
-    }
-
-    public static void writeFile(File file, byte[] data) throws IOException {
-        OutputStream out = new FileOutputStream(file);
-        try {
-            out.write(data);
-            out.flush();
-            out.close();
-        } finally {
-            try {
-                out.close();
-            } catch (IOException ex) {
-                // Do nothing.
-            }
-        }
-    }
-
-    public static byte[] readFile(File file, int expectedLength) throws IOException {
-        InputStream is = new FileInputStream(file);
-        byte[] result = new byte[expectedLength];
-        try {
-            assertEquals(expectedLength, is.read(result));
-            assertEquals(-1, is.read());
-        } finally {
-            try {
-                is.close();
-            } catch (IOException e) {
-                // Do nothing.
-            }
-        }
-        return result;
-    }
-
-    public static <T> Answer<T> arg(final int argumentIndex) {
-        return new Answer<T>() {
-            @SuppressWarnings("unchecked")
-            @Override
-            public T answer(InvocationOnMock invocation) {
-                if (argumentIndex >= invocation.getArguments().length) {
-                    throw new IllegalArgumentException("Cannot invoke argument " + argumentIndex
-                            + " greater than arguments length " + invocation.getArguments().length);
-                }
-                return (T) invocation.getArguments()[argumentIndex];
-            }
-        };
-    }
-
-    public static void setSdkVersionInt(int version) {
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", version);
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/ByteArrayPoolTest.java b/library/src/androidTest/java/com/bumptech/glide/util/ByteArrayPoolTest.java
deleted file mode 100644
index fb6ffa140..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/util/ByteArrayPoolTest.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package com.bumptech.glide.util;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ByteArrayPoolTest {
-
-    @Before
-    public void setUp() throws Exception {
-        ByteArrayPool.get().clear();
-    }
-
-    @Test
-    public void testEmptyPoolReturnsBytes() {
-        assertNotNull(ByteArrayPool.get().getBytes());
-    }
-
-    @Test
-    public void testNonEmptyPoolReturnsAvailableBytes() {
-        ByteArrayPool pool = ByteArrayPool.get();
-        byte[] available = pool.getBytes();
-        pool.releaseBytes(available);
-
-        assertEquals(available, pool.getBytes());
-    }
-
-    @Test
-    public void testPoolIsSizeBounded() {
-        ByteArrayPool pool = ByteArrayPool.get();
-
-        byte[] seed = pool.getBytes();
-        boolean rejected = false;
-        // Some way too high number
-        for (int i = 0; i < 2000 && !rejected; i++) {
-            byte[] toPut = new byte[seed.length];
-            rejected = !pool.releaseBytes(toPut);
-        }
-
-        assertTrue(rejected);
-    }
-
-    @Test
-    public void testByteArrayPoolIgnoresIncorrectSizes() {
-        ByteArrayPool pool = ByteArrayPool.get();
-        byte[] toPut = new byte[0];
-
-        assertFalse(pool.releaseBytes(toPut));
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
deleted file mode 100644
index 9b8d95a72..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
+++ /dev/null
@@ -1,182 +0,0 @@
-package com.bumptech.glide.util;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketTimeoutException;
-
-@RunWith(JUnit4.class)
-public class ExceptionCatchingInputStreamTest {
-
-    private RecyclableBufferedInputStream wrapped;
-    private ExceptionCatchingInputStream is;
-
-    @Before
-    public void setUp() throws Exception {
-        wrapped = mock(RecyclableBufferedInputStream.class);
-        is = new ExceptionCatchingInputStream();
-        is.setInputStream(wrapped);
-    }
-
-    @After
-    public void tearDown() {
-        ExceptionCatchingInputStream.clearQueue();
-    }
-
-    @Test
-    public void testReturnsWrappedAvailable() throws IOException {
-        when(wrapped.available()).thenReturn(25);
-        assertEquals(25, is.available());
-    }
-
-    @Test
-    public void testCallsCloseOnWrapped() throws IOException {
-        is.close();
-        verify(wrapped).close();
-    }
-
-    @Test
-    public void testCallsMarkOnWrapped() {
-        int toMark = 50;
-        is.mark(toMark);
-        verify(wrapped).mark(eq(toMark));
-    }
-
-    @Test
-    public void testReturnsWrappedMarkSupported() {
-        when(wrapped.markSupported()).thenReturn(true);
-        assertTrue(is.markSupported());
-    }
-
-    @Test
-    public void testCallsReadByteArrayOnWrapped() throws IOException {
-        byte[] buffer = new byte[100];
-        when(wrapped.read(eq(buffer))).thenReturn(buffer.length);
-        assertEquals(buffer.length, is.read(buffer));
-    }
-
-    @Test
-    public void testCallsReadArrayWithOffsetAndCountOnWrapped() throws IOException {
-        int offset = 5;
-        int count = 100;
-        byte[] buffer = new byte[105];
-
-        when(wrapped.read(eq(buffer), eq(offset), eq(count))).thenReturn(count);
-        assertEquals(count, is.read(buffer, offset, count));
-    }
-
-    @Test
-    public void testCallsReadOnWrapped() throws IOException {
-        when(wrapped.read()).thenReturn(1);
-        assertEquals(1, is.read());
-    }
-
-    @Test
-    public void testCallsResetOnWrapped() throws IOException {
-        is.reset();
-        verify(wrapped).reset();
-    }
-
-
-    @Test
-    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {
-        is.fixMarkLimit();
-        verify(wrapped).fixMarkLimit();
-    }
-
-    @Test
-    public void testCallsSkipOnWrapped() throws IOException {
-        long toSkip = 67;
-        long expected = 55;
-        when(wrapped.skip(eq(toSkip))).thenReturn(expected);
-        assertEquals(expected, is.skip(toSkip));
-    }
-
-    @Test
-    public void testCatchesExceptionOnRead() throws IOException {
-        IOException expected = new SocketTimeoutException();
-        when(wrapped.read()).thenThrow(expected);
-        int read = is.read();
-
-        assertEquals(-1, read);
-        assertEquals(expected, is.getException());
-    }
-
-    @Test
-    public void testCatchesExceptionOnReadBuffer() throws IOException {
-        IOException exception = new SocketTimeoutException();
-        when(wrapped.read(any(byte[].class))).thenThrow(exception);
-
-        int read = is.read(new byte[0]);
-        assertEquals(-1, read);
-        assertEquals(exception, is.getException());
-    }
-
-    @Test
-    public void testCatchesExceptionOnReadBufferWithOffsetAndCount() throws IOException {
-        IOException exception = new SocketTimeoutException();
-        when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenThrow(exception);
-
-        int read = is.read(new byte[0], 10, 100);
-        assertEquals(-1, read);
-        assertEquals(exception, is.getException());
-    }
-
-    @Test
-    public void testCatchesExceptionOnSkip() throws IOException {
-        IOException exception = new SocketTimeoutException();
-        when(wrapped.skip(anyLong())).thenThrow(exception);
-
-        long skipped = is.skip(100);
-        assertEquals(0, skipped);
-        assertEquals(exception, is.getException());
-    }
-
-    @Test
-    public void testExceptionIsNotSetInitially() {
-        assertNull(is.getException());
-    }
-
-    @SuppressWarnings("ResultOfMethodCallIgnored")
-    @Test
-    public void testResetsExceptionToNullOnRelease() throws IOException {
-        IOException exception = new SocketTimeoutException();
-        when(wrapped.read()).thenThrow(exception);
-        is.read();
-        is.release();
-        assertNull(is.getException());
-    }
-
-    @Test
-    public void testCanReleaseAnObtainFromPool() {
-        is.release();
-        InputStream fromPool = ExceptionCatchingInputStream.obtain(wrapped);
-        assertEquals(is, fromPool);
-    }
-
-    @Test
-    public void testCanObtainNewStreamFromPool() throws IOException {
-        InputStream fromPool = ExceptionCatchingInputStream.obtain(wrapped);
-        when(wrapped.read()).thenReturn(1);
-        int read = fromPool.read();
-        assertEquals(1, read);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java b/library/src/androidTest/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
deleted file mode 100644
index e5d39625f..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.bumptech.glide.util;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class FixedPreloadSizeProviderTest {
-
-    @Test
-    public void testReturnsGivenSize() {
-        int width = 500;
-        int height = 1234;
-        FixedPreloadSizeProvider<Object> provider = new FixedPreloadSizeProvider<Object>(width, height);
-
-        int[] size = provider.getPreloadSize(new Object(), 0, 0);
-
-        assertThat(size).asList().containsExactly(width, height);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java
deleted file mode 100644
index 540fa16ea..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package com.bumptech.glide.util;
-
-import static org.junit.Assert.assertEquals;
-
-import android.graphics.Bitmap;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class UtilTest {
-
-    @Test
-    public void testReturnsCorrectBitmapSizeForDifferentDimensions() {
-        int width = 100;
-        int height = 100;
-        Bitmap.Config config = Bitmap.Config.ARGB_8888;
-
-        int initialSize = Util.getBitmapByteSize(width, height, config);
-        int sizeOne = Util.getBitmapByteSize(width * 2, height, config);
-        int sizeTwo = Util.getBitmapByteSize(width, height * 2, config);
-
-        assertEquals(4 * width * height, initialSize);
-        assertEquals(2 * initialSize, sizeOne);
-        assertEquals(2 * initialSize, sizeTwo);
-    }
-
-    @Test
-    public void testReturnsCorrectBitmapSizeForAlpha8Bitmap() {
-        int width = 110;
-        int height = 43;
-
-        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ALPHA_8);
-        assertEquals(width * height, size);
-    }
-
-    @Test
-    public void testReturnsCorrectBitmapSizeForRgb565() {
-        int width = 34;
-        int height = 1444;
-
-        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.RGB_565);
-        assertEquals(width * height * 2, size);
-    }
-
-    @Test
-    public void testReturnsCorrectBitmapSizeForARGB4444() {
-        int width = 4454;
-        int height = 1235;
-
-        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_4444);
-        assertEquals(width * height * 2, size);
-    }
-
-    @Test
-    public void testReturnsCorrectBitmapSizeForARGB8888() {
-        int width = 943;
-        int height = 3584;
-
-        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_8888);
-        assertEquals(width * height * 4, size);
-    }
-
-    @Test
-    public void testReturnsLargestSizeForNullConfig() {
-        int width = 999;
-        int height = 41324;
-        int size = Util.getBitmapByteSize(width, height, null);
-        assertEquals(width * height * 4, size);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/src/androidTest/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
deleted file mode 100644
index 623db249a..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package com.bumptech.glide.util;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertNull;
-
-import android.view.View;
-import android.view.ViewGroup;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class ViewPreloadSizeProviderTest {
-
-    private View view;
-    private ViewPreloadSizeProvider<Object> provider;
-
-    @Before
-    public void setUp() {
-        view = new View(Robolectric.application);
-        provider = new ViewPreloadSizeProvider<Object>();
-    }
-
-    @Test
-    public void testReturnsNullFromGetPreloadSizeBeforeHasSize() {
-        assertNull(provider.getPreloadSize(new Object(), 0, 0));
-    }
-
-    @Test
-    public void testReturnsValidSizeFromGetPreloadSizeAfterHasSize() {
-        int width = 4123;
-        int height = 342;
-        provider.onSizeReady(width, height);
-
-        int[] size = provider.getPreloadSize(new Object(), 0, 0);
-        assertThat(size).asList().containsExactly(width, height);
-    }
-
-    @Test
-    public void testDoesNotObtainSizeFromViewOnceSizeIsSet() {
-        int width = 123;
-        int height = 456;
-        provider.onSizeReady(width, height);
-        view.setLayoutParams(new ViewGroup.LayoutParams(1, 1));
-
-        provider.setView(view);
-
-        int[] size = provider.getPreloadSize(new Object(), 0, 0);
-        assertThat(size).asList().containsExactly(width, height);
-    }
-
-    @Test
-    public void testCanObtainFixedSizeFromView() {
-        int width = 123;
-        int height = 456;
-        view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
-
-        provider.setView(view);
-
-        int[] size = provider.getPreloadSize(new Object(), 0, 0);
-        assertThat(size).asList().containsExactly(width, height);
-    }
-
-    @Test
-    public void testIgnoresNewViewIfAlreadyWaitingOnSizeOfAnotherView() {
-        provider.setView(view);
-
-        View newView = new View(Robolectric.application);
-        newView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
-        provider.setView(newView);
-
-        assertNull(provider.getPreloadSize(new Object(), 0, 0));
-    }
-
-    @Test
-    public void testCanObtainSizeFromViewWhenGivenViewInConstructor() {
-        int width = 100;
-        int height = 200;
-        view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
-
-        provider = new ViewPreloadSizeProvider<Object>(view);
-
-        int[] size = provider.getPreloadSize(new Object(), 0, 0);
-        assertThat(size).asList().containsExactly(width, height);
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 966088397..06f5c692a 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.bumptech.glide">
-  <application />
+
+    <application/>
 </manifest>
diff --git a/library/src/main/java/com/bumptech/glide/BitmapOptions.java b/library/src/main/java/com/bumptech/glide/BitmapOptions.java
deleted file mode 100644
index 2849d1ccf..000000000
--- a/library/src/main/java/com/bumptech/glide/BitmapOptions.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package com.bumptech.glide;
-
-interface BitmapOptions {
-
-    GenericRequestBuilder<?, ?, ?, ?> fitCenter();
-
-    GenericRequestBuilder<?, ?, ?, ?> centerCrop();
-
-}
diff --git a/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java
deleted file mode 100644
index 07e7c4ab6..000000000
--- a/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java
+++ /dev/null
@@ -1,498 +0,0 @@
-package com.bumptech.glide;
-
-import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
-import android.os.ParcelFileDescriptor;
-import android.view.animation.Animation;
-import android.widget.ImageView;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
-import com.bumptech.glide.load.resource.bitmap.Downsampler;
-import com.bumptech.glide.load.resource.bitmap.FileDescriptorBitmapDecoder;
-import com.bumptech.glide.load.resource.bitmap.ImageVideoBitmapDecoder;
-import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.animation.ViewPropertyAnimation;
-import com.bumptech.glide.request.target.Target;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * A class for creating a request to load a bitmap for an image or from a video. Sets a variety of type independent
- * options including resizing, animations, and placeholders.
- *
- * <p>
- *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
- *     reused.
- * </p>
- *
- * @param <ModelType> The type of model that will be loaded into the target.
- * @param <TranscodeType> The type of the transcoded resource that the target will receive
- */
-public class BitmapRequestBuilder<ModelType, TranscodeType>
-        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> implements BitmapOptions {
-    private final BitmapPool bitmapPool;
-
-    private Downsampler downsampler = Downsampler.AT_LEAST;
-    private DecodeFormat decodeFormat;
-    private ResourceDecoder<InputStream, Bitmap> imageDecoder;
-    private ResourceDecoder<ParcelFileDescriptor, Bitmap> videoDecoder;
-
-    BitmapRequestBuilder(LoadProvider<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> loadProvider,
-            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
-        super(loadProvider, transcodeClass, other);
-        this.bitmapPool = other.glide.getBitmapPool();
-        this.decodeFormat =  other.glide.getDecodeFormat();
-
-        imageDecoder = new StreamBitmapDecoder(bitmapPool, decodeFormat);
-        videoDecoder = new FileDescriptorBitmapDecoder(bitmapPool, decodeFormat);
-    }
-
-    /**
-     * Load images at a size near the size of the target using {@link Downsampler#AT_LEAST}.
-     *
-     * @see #downsample(Downsampler)
-     *
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> approximate() {
-        return downsample(Downsampler.AT_LEAST);
-    }
-
-    /**
-     * Load images at their original size using {@link Downsampler#NONE}.
-     *
-     * @see #downsample(Downsampler)
-     *
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> asIs() {
-        return downsample(Downsampler.NONE);
-    }
-
-    /**
-     * Load images at a size that is at most exactly as big as the target using
-     * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#AT_MOST}.
-     *
-     * @see #downsample(com.bumptech.glide.load.resource.bitmap.Downsampler)
-     *
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> atMost() {
-        return downsample(Downsampler.AT_MOST);
-    }
-
-    /**
-     * Load images using the given {@link Downsampler}. Replaces any existing image decoder. Defaults to
-     * {@link Downsampler#AT_LEAST}. Will be ignored if the data represented by the model is a video. This replaces any
-     * previous calls to {@link #imageDecoder(ResourceDecoder)}  and {@link #decoder(ResourceDecoder)} with default
-     * decoders with the appropriate options set.
-     *
-     * @see #imageDecoder
-     *
-     * @param downsampler The downsampler.
-     * @return This request builder.
-     */
-    private BitmapRequestBuilder<ModelType, TranscodeType> downsample(Downsampler downsampler) {
-        this.downsampler = downsampler;
-        imageDecoder = new StreamBitmapDecoder(downsampler, bitmapPool, decodeFormat);
-        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, videoDecoder));
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(float sizeMultiplier) {
-        super.thumbnail(sizeMultiplier);
-        return this;
-    }
-
-    /**
-     * Loads and displays the {@link android.graphics.Bitmap} retrieved by the given thumbnail request if it finishes
-     * before this request. Best used for loading thumbnail {@link Bitmap}s that are smaller and will be loaded more
-     * quickly than the fullsize {@link Bitmap}. There are no guarantees about the order in which the requests will
-     * actually finish. However, if the thumb request completes after the full request, the thumb
-     * {@link android.graphics.Bitmap} will never replace the full image.
-     *
-     * @see #thumbnail(float)
-     *
-     * <p>
-     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
-     *     you want an animation to occur when either the full {@link android.graphics.Bitmap} loads or the thumbnail
-     *     loads, you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
-     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
-     * </p>
-     *
-     * <p>
-     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
-     * </p>
-     *
-     * @param thumbnailRequest The request to use to load the thumbnail.
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(BitmapRequestBuilder<?, TranscodeType>
-            thumbnailRequest) {
-        super.thumbnail(thumbnailRequest);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> sizeMultiplier(float sizeMultiplier) {
-        super.sizeMultiplier(sizeMultiplier);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> decoder(ResourceDecoder<ImageVideoWrapper, Bitmap> decoder) {
-        super.decoder(decoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> cacheDecoder(ResourceDecoder<File, Bitmap> cacheDecoder) {
-        super.cacheDecoder(cacheDecoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> encoder(ResourceEncoder<Bitmap> encoder) {
-        super.encoder(encoder);
-        return this;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} that will be used to decode {@link Bitmap}s obtained
-     * from an {@link java.io.InputStream}.
-     *
-     * @see #videoDecoder
-     *
-     * @param decoder The decoder to use to decode {@link Bitmap}s.
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> imageDecoder(ResourceDecoder<InputStream, Bitmap> decoder) {
-        imageDecoder = decoder;
-        super.decoder(new ImageVideoBitmapDecoder(decoder, videoDecoder));
-        return this;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} that will be used to decode {@link Bitmap}s obtained
-     * from an {@link android.os.ParcelFileDescriptor}.
-     *
-     * @param decoder The decoder to use to decode {@link Bitmap}s.
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> videoDecoder(
-            ResourceDecoder<ParcelFileDescriptor, Bitmap> decoder) {
-        videoDecoder = decoder;
-        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, decoder));
-        return this;
-    }
-
-    /**
-     * Sets the preferred format for {@link Bitmap}s decoded in this request. Defaults to
-     * {@link DecodeFormat#PREFER_RGB_565}. This replaces any previous calls to {@link #imageDecoder(ResourceDecoder)},
-     * {@link #videoDecoder(ResourceDecoder)}, {@link #decoder(ResourceDecoder)} and
-     * {@link #cacheDecoder(com.bumptech.glide.load.ResourceDecoder)}} with default decoders with the appropriate
-     * options set.
-     *
-     * <p>
-     *     Note - If using a {@link Transformation} that expect bitmaps to support transparency, this should always be
-     *     set to ALWAYS_ARGB_8888. RGB_565 requires fewer bytes per pixel and is generally preferable, but it does not
-     *     support transparency.
-     * </p>
-     *
-     * @see DecodeFormat
-     *
-     * @param format The format to use.
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> format(DecodeFormat format) {
-        this.decodeFormat = format;
-        imageDecoder = new StreamBitmapDecoder(downsampler, bitmapPool, format);
-        videoDecoder = new FileDescriptorBitmapDecoder(new VideoBitmapDecoder(), bitmapPool, format);
-        super.cacheDecoder(new FileToStreamDecoder<Bitmap>(new StreamBitmapDecoder(downsampler, bitmapPool, format)));
-        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, videoDecoder));
-        return this;
-    }
-
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> priority(Priority priority) {
-        super.priority(priority);
-        return this;
-    }
-
-    /**
-     * Transform images using the given {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s.
-     *
-     * @see #centerCrop()
-     * @see #fitCenter()
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @param transformations The transformations to apply in order.
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> transform(BitmapTransformation... transformations) {
-        super.transform(transformations);
-        return this;
-    }
-
-    /**
-     * Transform images using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
-     *
-     * @see #fitCenter()
-     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> centerCrop() {
-        return transform(glide.getBitmapCenterCrop());
-    }
-
-    /**
-     * Transform images using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
-     *
-     * @see #centerCrop()
-     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, TranscodeType> fitCenter() {
-        return transform(glide.getBitmapFitCenter());
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * @see #fitCenter()
-     * @see #centerCrop()
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> transform(Transformation<Bitmap>... transformations) {
-        super.transform(transformations);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> transcoder(
-            ResourceTranscoder<Bitmap, TranscodeType> transcoder) {
-        super.transcoder(transcoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> dontAnimate() {
-        super.dontAnimate();
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> animate(int animationId) {
-        super.animate(animationId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    @SuppressWarnings("deprecation")
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> animate(Animation animation) {
-        super.animate(animation);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> animate(ViewPropertyAnimation.Animator animator) {
-        super.animate(animator);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> placeholder(int resourceId) {
-        super.placeholder(resourceId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> placeholder(Drawable drawable) {
-        super.placeholder(drawable);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> error(int resourceId) {
-        super.error(resourceId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> error(Drawable drawable) {
-        super.error(drawable);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> listener(
-            RequestListener<? super ModelType, TranscodeType> requestListener) {
-        super.listener(requestListener);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> skipMemoryCache(boolean skip) {
-        super.skipMemoryCache(skip);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {
-        super.diskCacheStrategy(strategy);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> override(int width, int height) {
-        super.override(width, height);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(
-            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
-        super.thumbnail(thumbnailRequest);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {
-        super.sourceEncoder(sourceEncoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> dontTransform() {
-        super.dontTransform();
-        return this;
-    }
-
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> signature(Key signature) {
-        super.signature(signature);
-        return this;
-    }
-
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> load(ModelType model) {
-        super.load(model);
-        return this;
-    }
-
-    @Override
-    public BitmapRequestBuilder<ModelType, TranscodeType> clone() {
-        return (BitmapRequestBuilder<ModelType, TranscodeType>) super.clone();
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * <p>
-     *     Note - If no transformation is set for this load, a default transformation will be applied based on the
-     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,
-     *     use {@link #dontTransform()}.
-     * </p>
-     *
-     * @param view {@inheritDoc}
-     * @return {@inheritDoc}
-     */
-    @Override
-    public Target<TranscodeType> into(ImageView view) {
-        return super.into(view);
-    }
-
-    @Override
-    void applyFitCenter() {
-        fitCenter();
-    }
-
-    @Override
-    void applyCenterCrop() {
-        centerCrop();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java
deleted file mode 100644
index 8e2b227ca..000000000
--- a/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package com.bumptech.glide;
-
-import android.graphics.Bitmap;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.model.ImageVideoModelLoader;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.provider.FixedLoadProvider;
-
-import java.io.InputStream;
-
-/**
- * A class for creating a load request that either loads an {@link Bitmap} directly or that adds an
- * {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to transcode the {@link Bitmap} into another
- * resource type.
- *
- * @param <ModelType> The type of model to load the {@link Bitmap} or transcoded class from.
- */
-public class BitmapTypeRequest<ModelType> extends BitmapRequestBuilder<ModelType, Bitmap> {
-    private final ModelLoader<ModelType, InputStream> streamModelLoader;
-    private final ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader;
-    private final Glide glide;
-    private final RequestManager.OptionsApplier optionsApplier;
-
-    private static <A, R> FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R> buildProvider(Glide glide,
-            ModelLoader<A, InputStream> streamModelLoader,
-            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader,
-            Class<R> transcodedClass, ResourceTranscoder<Bitmap, R> transcoder) {
-        if (streamModelLoader == null && fileDescriptorModelLoader == null) {
-            return null;
-        }
-
-        if (transcoder == null) {
-            transcoder = glide.buildTranscoder(Bitmap.class, transcodedClass);
-        }
-        DataLoadProvider<ImageVideoWrapper, Bitmap> loadProvider = glide.buildDataProvider(ImageVideoWrapper.class,
-                Bitmap.class);
-        ImageVideoModelLoader<A> modelLoader = new ImageVideoModelLoader<A>(streamModelLoader,
-                fileDescriptorModelLoader);
-
-        return new FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R>(modelLoader, transcoder, loadProvider);
-    }
-
-    BitmapTypeRequest(GenericRequestBuilder<ModelType, ?, ?, ?> other,
-            ModelLoader<ModelType, InputStream> streamModelLoader,
-            ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader,
-            RequestManager.OptionsApplier optionsApplier) {
-        super(buildProvider(other.glide, streamModelLoader, fileDescriptorModelLoader, Bitmap.class, null),
-                Bitmap.class, other);
-        this.streamModelLoader = streamModelLoader;
-        this.fileDescriptorModelLoader = fileDescriptorModelLoader;
-        this.glide = other.glide;
-        this.optionsApplier = optionsApplier;
-    }
-
-    /**
-     * Sets a transcoder to transcode the decoded and transformed {@link Bitmap} into another resource type.
-     *
-     * @param transcoder The transoder to use.
-     * @param transcodeClass The {@link Class} of the resource the {@link Bitmap} will be transcoded to.
-     * @param <R> The type of the resource the {@link Bitmap} will be transcoded to.
-     * @return This request builder.
-     */
-    public <R> BitmapRequestBuilder<ModelType, R> transcode(ResourceTranscoder<Bitmap, R> transcoder,
-            Class<R> transcodeClass) {
-        return optionsApplier.apply(new BitmapRequestBuilder<ModelType, R>(
-                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, transcodeClass, transcoder),
-                transcodeClass, this));
-    }
-
-    /**
-     * Transcodes the decoded and transformed {@link Bitmap} to bytes by compressing it as a JPEG to a byte array.
-     * array.
-     *
-     * @see #toBytes(android.graphics.Bitmap.CompressFormat, int)
-     *
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, byte[]> toBytes() {
-        return transcode(new BitmapBytesTranscoder(), byte[].class);
-    }
-
-    /**
-     * Transcodes the decoded and transformed {@link android.graphics.Bitmap} to bytes by compressing it using the
-     * given format and quality to a byte array.
-     *
-     * @see android.graphics.Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
-     * @see #toBytes()
-     *
-     * @param compressFormat The {@link android.graphics.Bitmap.CompressFormat} to use to compress the {@link Bitmap}.
-     * @param quality The quality level from 0-100 to use to compress the {@link Bitmap}.
-     * @return This request builder.
-     */
-    public BitmapRequestBuilder<ModelType, byte[]> toBytes(Bitmap.CompressFormat compressFormat, int quality) {
-        return transcode(new BitmapBytesTranscoder(compressFormat, quality), byte[].class);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/DownloadOptions.java b/library/src/main/java/com/bumptech/glide/DownloadOptions.java
deleted file mode 100644
index ae472c857..000000000
--- a/library/src/main/java/com/bumptech/glide/DownloadOptions.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.bumptech.glide;
-
-import com.bumptech.glide.request.FutureTarget;
-import com.bumptech.glide.request.target.Target;
-
-import java.io.File;
-
-interface DownloadOptions {
-
-    /**
-     * Loads the original unmodified data into the cache and calls the given Target with the cache File.
-     *
-     * @param target The Target that will receive the cache File when the load completes
-     * @param <Y> The type of Target.
-     * @return The given Target.
-     */
-    <Y extends Target<File>> Y downloadOnly(Y target);
-
-
-    /**
-     * Loads the original unmodified data into the cache and returns a {@link java.util.concurrent.Future} that can be
-     * used to retrieve the cache File containing the data.
-     *
-     * @param width The width in pixels to use to fetch the data.
-     * @param height The height in pixels to use to fetch the data.
-     * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the data.
-     */
-    FutureTarget<File> downloadOnly(int width, int height);
-}
diff --git a/library/src/main/java/com/bumptech/glide/DrawableOptions.java b/library/src/main/java/com/bumptech/glide/DrawableOptions.java
deleted file mode 100644
index ebc1aa5c1..000000000
--- a/library/src/main/java/com/bumptech/glide/DrawableOptions.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package com.bumptech.glide;
-
-import android.view.animation.Animation;
-
-interface DrawableOptions {
-
-    /**
-     * Applies a cross fade transformation that fades from the placeholder to the loaded
-     * {@link android.graphics.drawable.Drawable}. If no placeholder is set, the Drawable will instead simply fade in.
-     *
-     * @see #crossFade(int)
-     * @see #crossFade(int, int)
-     *
-     * @return This request builder.
-     */
-     GenericRequestBuilder<?, ?, ?, ?> crossFade();
-
-    /**
-     * Applies a cross fade transformation that fades from the placeholder to the loaded
-     * {@link android.graphics.drawable.Drawable}. If no placeholder is set the Drawable will instead simply fade in.
-     *
-     * @see #crossFade()
-     * @see #crossFade(int, int)
-     *
-     * @param duration The duration of the cross fade and initial fade in.
-     * @return This request builder.
-     */
-    GenericRequestBuilder<?, ?, ?, ?> crossFade(int duration);
-
-
-    /**
-     * Applies a cross fade transformation that des from the placeholder to the loaded
-     * {@link android.graphics.drawable.Drawable}. If no placeholder is set, the Drawable will instead be animated in
-     * using the given {@link android.view.animation.Animation}.
-     *
-     * @see #crossFade()
-     * @see #crossFade(int)
-     * @see #crossFade(int, int)
-     *
-     * @deprecated If this builder is used for multiple loads, using this method will result in multiple view's being
-     * asked to start an animation using a single {@link android.view.animation.Animation} object which results in
-     * views animating repeatedly. Use {@link #crossFade(int, int)}} instead, or be sure to call this method once
-     * per call to {@link com.bumptech.glide.GenericRequestBuilder#load(Object)} to avoid re-using animation objects.
-     * Scheduled to be removed in Glide 4.0.
-     * @param animation The Animation to use if no placeholder is set.
-     * @param duration The duration of the cross fade animation.
-     * @return This request builder.
-     */
-    @Deprecated
-    GenericRequestBuilder<?, ?, ?, ?> crossFade(Animation animation, int duration);
-
-    /**
-     * Applies a cross fade transformation that des from the placeholder to the loaded
-     * {@link android.graphics.drawable.Drawable}. If no placeholder is set, the Drawable will instead be animated in
-     * using the {@link android.view.animation.Animation} loaded from the given animation id.
-     *
-     * @see #crossFade()
-     * @see #crossFade(int)
-     *
-     * @param animationId The id of the Animation to use if no placeholder is set.
-     * @param duration The duration of the cross fade animation.
-     * @return This request builder.
-     */
-    GenericRequestBuilder<?, ?, ?, ?> crossFade(int animationId, int duration);
-}
diff --git a/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java
deleted file mode 100644
index 845a01e8c..000000000
--- a/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java
+++ /dev/null
@@ -1,448 +0,0 @@
-package com.bumptech.glide;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
-import android.view.animation.Animation;
-import android.widget.ImageView;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
-import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.animation.DrawableCrossFadeFactory;
-import com.bumptech.glide.request.animation.ViewPropertyAnimation;
-import com.bumptech.glide.request.target.Target;
-
-import java.io.File;
-
-/**
- * A class for creating a request to load a {@link GlideDrawable}.
- *
- * <p>
- *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
- *     reused.
- * </p>
- *
- * @param <ModelType> The type of model that will be loaded into the target.
- */
-public class DrawableRequestBuilder<ModelType>
-        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>
-        implements BitmapOptions, DrawableOptions {
-
-    DrawableRequestBuilder(Context context, Class<ModelType> modelClass,
-            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> loadProvider, Glide glide,
-            RequestTracker requestTracker, Lifecycle lifecycle) {
-        super(context, modelClass, loadProvider, GlideDrawable.class, glide, requestTracker, lifecycle);
-        // Default to animating.
-        crossFade();
-    }
-
-    /**
-     * Loads and displays the {@link GlideDrawable} retrieved by the given thumbnail request if it finishes before this
-     * request. Best used for loading thumbnail {@link GlideDrawable}s that are smaller and will be loaded more quickly
-     * than the fullsize {@link GlideDrawable}. There are no guarantees about the order in which the requests will
-     * actually finish. However, if the thumb request completes after the full request, the thumb {@link GlideDrawable}
-     * will never replace the full image.
-     *
-     * @see #thumbnail(float)
-     *
-     * <p>
-     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
-     *     you want an animation to occur when either the full {@link GlideDrawable} loads or the thumbnail loads,
-     *     you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
-     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
-     * </p>
-     *
-     * <p>
-     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
-     * </p>
-     *
-     * @param thumbnailRequest The request to use to load the thumbnail.
-     * @return This builder object.
-     */
-    public DrawableRequestBuilder<ModelType> thumbnail(
-            DrawableRequestBuilder<?> thumbnailRequest) {
-        super.thumbnail(thumbnailRequest);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> thumbnail(
-            GenericRequestBuilder<?, ?, ?, GlideDrawable> thumbnailRequest) {
-        super.thumbnail(thumbnailRequest);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> thumbnail(float sizeMultiplier) {
-        super.thumbnail(sizeMultiplier);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> sizeMultiplier(float sizeMultiplier) {
-        super.sizeMultiplier(sizeMultiplier);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> decoder(ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {
-        super.decoder(decoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> cacheDecoder(ResourceDecoder<File, GifBitmapWrapper> cacheDecoder) {
-        super.cacheDecoder(cacheDecoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> encoder(ResourceEncoder<GifBitmapWrapper> encoder) {
-        super.encoder(encoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> priority(Priority priority) {
-        super.priority(priority);
-        return this;
-    }
-
-    /**
-     * Transform {@link GlideDrawable}s using the given
-     * {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s.
-     *
-     * <p>
-     *     Note - Bitmap transformations will apply individually to each frame of animated GIF images and also to
-     *     individual {@link Bitmap}s.
-     * </p>
-     *
-     * @see #centerCrop()
-     * @see #fitCenter()
-     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @param transformations The transformations to apply in order.
-     * @return This request builder.
-     */
-    public DrawableRequestBuilder<ModelType> transform(BitmapTransformation... transformations) {
-        return bitmapTransform(transformations);
-    }
-
-    /**
-     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
-     *
-     * @see #fitCenter()
-     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @return This request builder.
-     */
-    @SuppressWarnings("unchecked")
-    public DrawableRequestBuilder<ModelType> centerCrop() {
-        return transform(glide.getDrawableCenterCrop());
-    }
-
-    /**
-     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
-     *
-     * @see #centerCrop()
-     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @return This request builder.
-     */
-    @SuppressWarnings("unchecked")
-    public DrawableRequestBuilder<ModelType> fitCenter() {
-        return transform(glide.getDrawableFitCenter());
-    }
-
-    /**
-     * Transform {@link GlideDrawable}s using the given {@link android.graphics.Bitmap} transformations. Replaces any
-     * previous transformations.
-     *
-     * @see #fitCenter()
-     * @see #centerCrop()
-     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @return This request builder.
-     */
-    public DrawableRequestBuilder<ModelType> bitmapTransform(Transformation<Bitmap>... bitmapTransformations) {
-        GifBitmapWrapperTransformation[] transformations =
-                new GifBitmapWrapperTransformation[bitmapTransformations.length];
-        for (int i = 0; i < bitmapTransformations.length; i++) {
-            transformations[i] = new GifBitmapWrapperTransformation(glide.getBitmapPool(), bitmapTransformations[i]);
-        }
-        return transform(transformations);
-    }
-
-
-
-    /**
-     * {@inheritDoc}
-     *
-     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
-     * @see #centerCrop()
-     * @see #fitCenter()
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> transform(Transformation<GifBitmapWrapper>... transformation) {
-        super.transform(transformation);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> transcoder(
-            ResourceTranscoder<GifBitmapWrapper, GlideDrawable> transcoder) {
-        super.transcoder(transcoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public final DrawableRequestBuilder<ModelType> crossFade() {
-        super.animate(new DrawableCrossFadeFactory<GlideDrawable>());
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public DrawableRequestBuilder<ModelType> crossFade(int duration) {
-        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(duration));
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public DrawableRequestBuilder<ModelType> crossFade(Animation animation, int duration) {
-        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(animation, duration));
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public DrawableRequestBuilder<ModelType> crossFade(int animationId, int duration) {
-        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(context, animationId,
-                duration));
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> dontAnimate() {
-        super.dontAnimate();
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> animate(ViewPropertyAnimation.Animator animator) {
-        super.animate(animator);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> animate(int animationId) {
-        super.animate(animationId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    @SuppressWarnings("deprecation")
-    @Override
-    public DrawableRequestBuilder<ModelType> animate(Animation animation) {
-        super.animate(animation);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> placeholder(int resourceId) {
-        super.placeholder(resourceId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> placeholder(Drawable drawable) {
-        super.placeholder(drawable);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> error(int resourceId) {
-        super.error(resourceId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> error(Drawable drawable) {
-        super.error(drawable);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> listener(
-            RequestListener<? super ModelType, GlideDrawable> requestListener) {
-        super.listener(requestListener);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {
-        super.diskCacheStrategy(strategy);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> skipMemoryCache(boolean skip) {
-        super.skipMemoryCache(skip);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> override(int width, int height) {
-        super.override(width, height);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {
-        super.sourceEncoder(sourceEncoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public DrawableRequestBuilder<ModelType> dontTransform() {
-        super.dontTransform();
-        return this;
-    }
-
-    @Override
-    public DrawableRequestBuilder<ModelType> signature(Key signature) {
-        super.signature(signature);
-        return this;
-    }
-
-    @Override
-    public DrawableRequestBuilder<ModelType> load(ModelType model) {
-        super.load(model);
-        return this;
-    }
-
-    @Override
-    public DrawableRequestBuilder<ModelType> clone() {
-        return (DrawableRequestBuilder<ModelType>) super.clone();
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * <p>
-     *     Note - If no transformation is set for this load, a default transformation will be applied based on the
-     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,
-     *     use {@link #dontTransform()}.
-     * </p>
-     *
-     * @param view {@inheritDoc}
-     * @return {@inheritDoc}
-     */
-    @Override
-    public Target<GlideDrawable> into(ImageView view) {
-        return super.into(view);
-    }
-
-    @Override
-    void applyFitCenter() {
-        fitCenter();
-    }
-
-    @Override
-    void applyCenterCrop() {
-        centerCrop();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java
deleted file mode 100644
index ee67f1a3c..000000000
--- a/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package com.bumptech.glide;
-
-import android.content.Context;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.model.ImageVideoModelLoader;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.provider.FixedLoadProvider;
-import com.bumptech.glide.request.FutureTarget;
-import com.bumptech.glide.request.target.Target;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * A class for creating a load request that loads either an animated GIF drawable or a Bitmap drawable directly, or
- * adds an {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to transcode the data into a
- * resource type other than a {@link android.graphics.drawable.Drawable}.
- *
- * @param <ModelType> The type of model to use to load the {@link android.graphics.drawable.BitmapDrawable} or
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
- */
-public class DrawableTypeRequest<ModelType> extends DrawableRequestBuilder<ModelType> implements DownloadOptions {
-    private final ModelLoader<ModelType, InputStream> streamModelLoader;
-    private final ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader;
-    private final RequestManager.OptionsApplier optionsApplier;
-
-    private static <A, Z, R> FixedLoadProvider<A, ImageVideoWrapper, Z, R> buildProvider(Glide glide,
-            ModelLoader<A, InputStream> streamModelLoader,
-            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader, Class<Z> resourceClass,
-            Class<R> transcodedClass,
-            ResourceTranscoder<Z, R> transcoder) {
-        if (streamModelLoader == null && fileDescriptorModelLoader == null) {
-            return null;
-        }
-
-        if (transcoder == null) {
-            transcoder = glide.buildTranscoder(resourceClass, transcodedClass);
-        }
-        DataLoadProvider<ImageVideoWrapper, Z> dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class,
-                resourceClass);
-        ImageVideoModelLoader<A> modelLoader = new ImageVideoModelLoader<A>(streamModelLoader,
-                fileDescriptorModelLoader);
-        return new FixedLoadProvider<A, ImageVideoWrapper, Z, R>(modelLoader, transcoder, dataLoadProvider);
-    }
-
-    DrawableTypeRequest(Class<ModelType> modelClass, ModelLoader<ModelType, InputStream> streamModelLoader,
-            ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader, Context context, Glide glide,
-            RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) {
-        super(context, modelClass,
-                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,
-                        GlideDrawable.class, null),
-                glide, requestTracker, lifecycle);
-        this.streamModelLoader = streamModelLoader;
-        this.fileDescriptorModelLoader = fileDescriptorModelLoader;
-        this.optionsApplier = optionsApplier;
-    }
-
-    /**
-     * Attempts to always load the resource as a {@link android.graphics.Bitmap}, even if it could actually be animated.
-     *
-     * @return A new request builder for loading a {@link android.graphics.Bitmap}
-     */
-    public BitmapTypeRequest<ModelType> asBitmap() {
-        return optionsApplier.apply(new BitmapTypeRequest<ModelType>(this, streamModelLoader,
-                fileDescriptorModelLoader, optionsApplier));
-    }
-
-    /**
-     * Attempts to always load the resource as a {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
-     * <p>
-     *     If the underlying data is not a GIF, this will fail. As a result, this should only be used if the model
-     *     represents an animated GIF and the caller wants to interact with the GIfDrawable directly. Normally using
-     *     just an {@link com.bumptech.glide.DrawableTypeRequest} is sufficient because it will determine whether or
-     *     not the given data represents an animated GIF and return the appropriate animated or not animated
-     *     {@link android.graphics.drawable.Drawable} automatically.
-     * </p>
-     *
-     * @return A new request builder for loading a {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
-     */
-    public GifTypeRequest<ModelType> asGif() {
-        return optionsApplier.apply(new GifTypeRequest<ModelType>(this, streamModelLoader, optionsApplier));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public <Y extends Target<File>> Y downloadOnly(Y target) {
-        return getDownloadOnlyRequest().downloadOnly(target);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public FutureTarget<File> downloadOnly(int width, int height) {
-        return getDownloadOnlyRequest().downloadOnly(width, height);
-    }
-
-    private GenericTranscodeRequest<ModelType, InputStream, File> getDownloadOnlyRequest() {
-        return optionsApplier.apply(new GenericTranscodeRequest<ModelType, InputStream, File>(File.class, this,
-                streamModelLoader, InputStream.class, File.class, optionsApplier));
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java
deleted file mode 100644
index 65ba231d2..000000000
--- a/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java
+++ /dev/null
@@ -1,787 +0,0 @@
-package com.bumptech.glide;
-
-import android.content.Context;
-import android.graphics.drawable.Drawable;
-import android.view.animation.Animation;
-import android.widget.ImageView;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.MultiTransformation;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.provider.ChildLoadProvider;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.request.FutureTarget;
-import com.bumptech.glide.request.GenericRequest;
-import com.bumptech.glide.request.Request;
-import com.bumptech.glide.request.RequestCoordinator;
-import com.bumptech.glide.request.RequestFutureTarget;
-import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.ThumbnailRequestCoordinator;
-import com.bumptech.glide.request.animation.GlideAnimationFactory;
-import com.bumptech.glide.request.animation.NoAnimation;
-import com.bumptech.glide.request.animation.ViewAnimationFactory;
-import com.bumptech.glide.request.animation.ViewPropertyAnimation;
-import com.bumptech.glide.request.animation.ViewPropertyAnimationFactory;
-import com.bumptech.glide.request.target.PreloadTarget;
-import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.signature.EmptySignature;
-import com.bumptech.glide.util.Util;
-
-import java.io.File;
-
-/**
- * A generic class that can handle setting options and staring loads for generic resource types.
- *
- * @param <ModelType> The type of model representing the resource.
- * @param <DataType> The data type that the resource {@link com.bumptech.glide.load.model.ModelLoader} will provide that
- *                  can be decoded by the {@link com.bumptech.glide.load.ResourceDecoder}.
- * @param <ResourceType> The type of the resource that will be loaded.
- * @param <TranscodeType> The type of resource the decoded resource will be transcoded to.
- */
-public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> implements Cloneable {
-    protected final Class<ModelType> modelClass;
-    protected final Context context;
-    protected final Glide glide;
-    protected final Class<TranscodeType> transcodeClass;
-    protected final RequestTracker requestTracker;
-    protected final Lifecycle lifecycle;
-    private ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider;
-
-    private ModelType model;
-    private Key signature = EmptySignature.obtain();
-    // model may occasionally be null, so to enforce that load() was called, set a boolean rather than relying on model
-    // not to be null.
-    private boolean isModelSet;
-    private int placeholderId;
-    private int errorId;
-    private RequestListener<? super ModelType, TranscodeType> requestListener;
-    private Float thumbSizeMultiplier;
-    private GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequestBuilder;
-    private Float sizeMultiplier = 1f;
-    private Drawable placeholderDrawable;
-    private Drawable errorPlaceholder;
-    private Priority priority = null;
-    private boolean isCacheable = true;
-    private GlideAnimationFactory<TranscodeType> animationFactory = NoAnimation.getFactory();
-    private int overrideHeight = -1;
-    private int overrideWidth = -1;
-    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
-    private Transformation<ResourceType> transformation = UnitTransformation.get();
-    private boolean isTransformationSet;
-
-    GenericRequestBuilder(LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
-            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
-        this(other.context, other.modelClass, loadProvider, transcodeClass, other.glide, other.requestTracker,
-                other.lifecycle);
-        this.model = other.model;
-        this.isModelSet = other.isModelSet;
-        this.signature = other.signature;
-        this.diskCacheStrategy = other.diskCacheStrategy;
-        this.isCacheable = other.isCacheable;
-    }
-
-    GenericRequestBuilder(Context context, Class<ModelType> modelClass,
-            LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
-            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {
-        this.context = context;
-        this.modelClass = modelClass;
-        this.transcodeClass = transcodeClass;
-        this.glide = glide;
-        this.requestTracker = requestTracker;
-        this.lifecycle = lifecycle;
-        this.loadProvider = loadProvider != null
-                ? new ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType>(loadProvider) : null;
-
-        if (context == null) {
-            throw new NullPointerException("Context can't be null");
-        }
-        if (modelClass != null && loadProvider == null) {
-            throw new NullPointerException("LoadProvider must not be null");
-        }
-    }
-
-    /**
-     * Loads and displays the resource retrieved by the given thumbnail request if it finishes before this request.
-     * Best used for loading thumbnail resources that are smaller and will be loaded more quickly than the full size
-     * resource. There are no guarantees about the order in which the requests will actually finish. However, if the
-     * thumb request completes after the full request, the thumb resource will never replace the full resource.
-     *
-     * @see #thumbnail(float)
-     *
-     * <p>
-     *     Recursive calls to thumbnail are supported.
-     * </p>
-     *
-     * @param thumbnailRequest The request to use to load the thumbnail.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
-            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
-        this.thumbnailRequestBuilder = thumbnailRequest;
-
-        return this;
-    }
-
-    /**
-     * Loads a resource in an identical manner to this request except with the dimensions of the target multiplied
-     * by the given size multiplier. If the thumbnail load completes before the fullsize load, the thumbnail will
-     * be shown. If the thumbnail load completes afer the fullsize load, the thumbnail will not be shown.
-     *
-     * <p>
-     *     Note - The thumbnail resource will be smaller than the size requested so the target (or {@link ImageView})
-     *     must be able to scale the thumbnail appropriately. See {@link android.widget.ImageView.ScaleType}.
-     * </p>
-     *
-     * <p>
-     *     Almost all options will be copied from the original load, including the
-     *     {@link com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder}, and
-     *     {@link Transformation}s. However, {@link #placeholder(int)} and {@link #error(int)},
-     *     and {@link #listener(RequestListener)} will only be used on the fullsize load and will not be copied for
-     *     the thumbnail load.
-     * </p>
-     *
-     * <p>
-     *     Recursive calls to thumbnail are supported.
-     * </p>
-     *
-     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the thumbnail.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
-            float sizeMultiplier) {
-        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-        }
-        this.thumbSizeMultiplier = sizeMultiplier;
-
-        return this;
-    }
-
-    /**
-     * Applies a multiplier to the {@link Target}'s size before loading the resource. Useful for loading thumbnails
-     * or trying to avoid loading huge resources (particularly {@link android.graphics.Bitmap}s on devices with overly
-     * dense screens.
-     *
-     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the resource.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sizeMultiplier(
-            float sizeMultiplier) {
-        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-        }
-        this.sizeMultiplier = sizeMultiplier;
-
-        return this;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the original data.
-     * By default, this decoder will only be used if the final transformed resource is not in the disk cache.
-     *
-     * @see #cacheDecoder(com.bumptech.glide.load.ResourceDecoder)
-     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
-     *
-     * @param decoder The {@link com.bumptech.glide.load.ResourceDecoder} to use to decode the resource.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> decoder(
-            ResourceDecoder<DataType, ResourceType> decoder) {
-        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
-        // ignore the decoder.
-        if (loadProvider != null) {
-            loadProvider.setSourceDecoder(decoder);
-        }
-
-        return this;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the disk cache. By
-     * default, this decoder will only be used if the final transformed resource is already in the disk cache.
-     *
-     * @see #decoder(com.bumptech.glide.load.ResourceDecoder)
-     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
-     *
-     * @param cacheDecoder The decoder to use.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> cacheDecoder(
-            ResourceDecoder<File, ResourceType> cacheDecoder) {
-        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
-        // ignore the decoder.
-        if (loadProvider != null) {
-            loadProvider.setCacheDecoder(cacheDecoder);
-        }
-
-        return this;
-    }
-
-    /**
-     * Sets the source encoder to use to encode the data retrieved by this request directly into cache. The returned
-     * resource will then be decoded from the cached data.
-     *
-     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
-     *
-     * @param sourceEncoder The encoder to use.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sourceEncoder(
-            Encoder<DataType> sourceEncoder) {
-        if (loadProvider != null) {
-            loadProvider.setSourceEncoder(sourceEncoder);
-        }
-
-        return this;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load. Defaults to
-     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}.
-     *
-     * <p>
-     *     For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT} is ideal.
-     *     Applications that use the same resource multiple times in multiple sizes and are willing to trade off some
-     *     speed and disk space in return for lower bandwidth usage may want to consider using
-     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
-     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}. Any download only operations should
-     *     typically use {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE}.
-     * </p>
-     *
-     * @param strategy The strategy to use.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>  diskCacheStrategy(
-            DiskCacheStrategy strategy) {
-        this.diskCacheStrategy = strategy;
-
-        return this;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.Encoder} to use to encode the original data directly to cache. Will only
-     * be used if the original data is not already in cache and if the
-     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} is set to
-     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
-     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}.
-     *
-     * @see #sourceEncoder(com.bumptech.glide.load.Encoder)
-     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
-     *
-     * @param encoder The encoder to use.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> encoder(
-            ResourceEncoder<ResourceType> encoder) {
-        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
-        // ignore the encoder.
-        if (loadProvider != null) {
-            loadProvider.setEncoder(encoder);
-        }
-
-        return this;
-    }
-
-    /**
-     * Sets the priority for this load.
-     *
-     * @param priority A priority.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> priority(
-            Priority priority) {
-        this.priority = priority;
-
-        return this;
-    }
-
-    /**
-     * Transform resources with the given {@link Transformation}s. Replaces any existing transformation or
-     * transformations.
-     *
-     * @param transformations the transformations to apply in order.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transform(
-            Transformation<ResourceType>... transformations) {
-        isTransformationSet = true;
-        if (transformations.length == 1) {
-            transformation = transformations[0];
-        } else {
-            transformation = new MultiTransformation<ResourceType>(transformations);
-        }
-
-        return this;
-    }
-
-    /**
-     * Removes the current {@link com.bumptech.glide.load.Transformation}.
-     *
-     * @return This request builder.
-     */
-    @SuppressWarnings("unchecked")
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontTransform() {
-        Transformation<ResourceType> transformation = UnitTransformation.get();
-        return transform(transformation);
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to use for this load.
-     *
-     * @see com.bumptech.glide.load.resource.transcode.UnitTranscoder
-     * @see com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder
-     * @see com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder
-     *
-     * @param transcoder The transcoder to use.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transcoder(
-            ResourceTranscoder<ResourceType, TranscodeType> transcoder) {
-        if (loadProvider != null) {
-            loadProvider.setTranscoder(transcoder);
-        }
-
-        return this;
-    }
-
-    /**
-     * Removes any existing animation set on the builder. Will be overridden by subsequent calls that set an animation.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontAnimate() {
-        GlideAnimationFactory<TranscodeType> animation = NoAnimation.getFactory();
-        return animate(animation);
-    }
-
-    /**
-     * Sets an animation to run on the wrapped target when an resource load finishes. Will only be run if the resource
-     * was loaded asynchronously (ie was not in the memory cache)
-     *
-     * @param animationId The resource id of the animation to run
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(int animationId) {
-        return animate(new ViewAnimationFactory<TranscodeType>(context, animationId));
-    }
-
-    /**
-     * Sets an animation to run on the wrapped target when a resource load finishes. Will only be run if the resource
-     * was loaded asynchronously (ie was not in the memory cache)
-     *
-     * @see #animate(int)
-     * @see #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)
-     *
-     * @deprecated If this builder is used for multiple loads, using this method will result in multiple view's being
-     * asked to start an animation using a single {@link android.view.animation.Animation} object which results in
-     * views animating repeatedly. Use {@link #animate(int)} or
-     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in
-     * Glide 4.0.
-     * @param animation The animation to run
-     * @return This request builder.
-     */
-    @Deprecated
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(Animation animation) {
-        return animate(new ViewAnimationFactory<TranscodeType>(animation));
-    }
-
-    /**
-     * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target may be wrapping
-     * when a resource load finishes. Will only be run if the load was loaded asynchronously (ie was not in the
-     * memory cache).
-     *
-     * @param animator The {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} to run.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
-            ViewPropertyAnimation.Animator animator) {
-        return animate(new ViewPropertyAnimationFactory<TranscodeType>(animator));
-    }
-
-    GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
-            GlideAnimationFactory<TranscodeType> animationFactory) {
-        if (animationFactory == null) {
-            throw new NullPointerException("Animation factory must not be null!");
-        }
-        this.animationFactory = animationFactory;
-
-        return this;
-    }
-
-    /**
-     * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resourceto display while a resource
-     * is loading.
-     *
-     * @param resourceId The id of the resource to use as a placeholder
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
-            int resourceId) {
-        this.placeholderId = resourceId;
-
-        return this;
-    }
-
-    /**
-     * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
-     *
-     * @param drawable The drawable to display as a placeholder.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
-            Drawable drawable) {
-        this.placeholderDrawable = drawable;
-
-        return this;
-    }
-
-    /**
-     * Sets a resource to display if a load fails.
-     *
-     * @param resourceId The id of the resource to use as a placeholder.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
-            int resourceId) {
-        this.errorId = resourceId;
-
-        return this;
-    }
-
-    /**
-     * Sets a {@link Drawable} to display if a load fails.
-     *
-     * @param drawable The drawable to display.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
-            Drawable drawable) {
-        this.errorPlaceholder = drawable;
-
-        return this;
-    }
-
-    /**
-     * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single instance of an
-     * exception handler per type of request (usually activity/fragment) rather than pass one in per request to
-     * avoid some redundant object allocation.
-     *
-     * @param requestListener The request listener to use.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> listener(
-            RequestListener<? super ModelType, TranscodeType> requestListener) {
-        this.requestListener = requestListener;
-
-        return this;
-    }
-
-    /**
-     * Allows the loaded resource to skip the memory cache.
-     *
-     * <p>
-     *     Note - this is not a guarantee. If a request is already pending for this resource and that request is not
-     *     also skipping the memory cache, the resource will be cached in memory.
-     * </p>
-     *
-     * @param skip True to allow the resource to skip the memory cache.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> skipMemoryCache(boolean skip) {
-        this.isCacheable = !skip;
-
-        return this;
-    }
-
-    /**
-     * Overrides the {@link Target}'s width and height with the given values. This is useful almost exclusively for
-     * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or
-     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}.
-     *
-     * @param width The width in pixels to use to load the resource.
-     * @param height The height in pixels to use to load the resource.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {
-        if (width <= 0) {
-            throw new IllegalArgumentException("Width must be > 0");
-        }
-        if (height <= 0) {
-            throw new IllegalArgumentException("Height must be > 0");
-        }
-        this.overrideWidth = width;
-        this.overrideHeight = height;
-
-        return this;
-    }
-
-    /**
-     * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller more control over
-     * when cached data is invalidated.
-     *
-     * <p>
-     *     Note - The signature does not replace the cache key, it is purely additive.
-     * </p>
-     *
-     * @see com.bumptech.glide.signature.StringSignature
-     *
-     * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current state of the
-     *                  model that will be mixed in to the cache key.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> signature(Key signature) {
-        if (signature == null) {
-            throw new NullPointerException("Signature must not be null");
-        }
-        this.signature = signature;
-        return this;
-    }
-
-    /**
-     * Sets the specific model to load data for.
-     *
-     * <p>
-     *      This method must be called at least once before {@link #into(com.bumptech.glide.request.target.Target)} is
-     *      called.
-     * </p>
-     *
-     * @param model The model to load data for, or null.
-     * @return This request builder.
-     */
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {
-        this.model = model;
-        isModelSet = true;
-        return this;
-    }
-
-    /**
-     * Returns a copy of this request builder with all of the options set so far on this builder.
-     *
-     * <p>
-     *     This method returns a "deep" copy in that all non-immutable arguments are copied such that changes to one
-     *     builder will not affect the other builder. However, in addition to immutable arguments, the current model
-     *     is not copied copied so changes to the model will affect both builders.
-     * </p>
-     */
-    @SuppressWarnings("unchecked")
-    @Override
-    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone() {
-        try {
-            GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone =
-                    (GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>) super.clone();
-            clone.loadProvider = loadProvider != null ? loadProvider.clone() : null;
-            return clone;
-        } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    /**
-     * Set the target the resource will be loaded into.
-     *
-     * @see Glide#clear(com.bumptech.glide.request.target.Target)
-     *
-     * @param target The target to load the resource into.
-     * @return The given target.
-     */
-    public <Y extends Target<TranscodeType>> Y into(Y target) {
-        Util.assertMainThread();
-        if (target == null) {
-            throw new IllegalArgumentException("You must pass in a non null Target");
-        }
-        if (!isModelSet) {
-            throw new IllegalArgumentException("You must first set a model (try #load())");
-        }
-
-        Request previous = target.getRequest();
-
-        if (previous != null) {
-            previous.clear();
-            requestTracker.removeRequest(previous);
-            previous.recycle();
-        }
-
-        Request request = buildRequest(target);
-        target.setRequest(request);
-        lifecycle.addListener(target);
-        requestTracker.runRequest(request);
-
-        return target;
-    }
-
-    /**
-     * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into the view, and frees
-     * any resources Glide may have previously loaded into the view so they may be reused.
-     *
-     * @see Glide#clear(android.view.View)
-     *
-     * @param view The view to cancel previous loads for and load the new resource into.
-     * @return The {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
-     */
-    public Target<TranscodeType> into(ImageView view) {
-        Util.assertMainThread();
-        if (view == null) {
-            throw new IllegalArgumentException("You must pass in a non null View");
-        }
-
-        if (!isTransformationSet && view.getScaleType() != null) {
-            switch (view.getScaleType()) {
-                case CENTER_CROP:
-                    applyCenterCrop();
-                    break;
-                case FIT_CENTER:
-                case FIT_START:
-                case FIT_END:
-                    applyFitCenter();
-                    break;
-                //$CASES-OMITTED$
-                default:
-                    // silently ignore
-                    break;
-            }
-        }
-
-        return into(glide.buildImageViewTarget(view, transcodeClass));
-    }
-
-    /**
-     * Returns a future that can be used to do a blocking get on a background thread.
-     *
-     * @param width The desired width in pixels (note this will be overriden by {@link #override(int, int)} if
-     *              previously called).
-     * @param height The desired height in pixels (note this will be overriden by {@link #override(int, int)}}
-     *               if previously called).
-     *
-     * @see Glide#clear(com.bumptech.glide.request.FutureTarget)
-     *
-     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the
-     *         resource in a blocking manner.
-     */
-    public FutureTarget<TranscodeType> into(int width, int height) {
-        final RequestFutureTarget<ModelType, TranscodeType> target =
-                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);
-
-        // TODO: Currently all loads must be started on the main thread...
-        glide.getMainHandler().post(new Runnable() {
-            @Override
-            public void run() {
-                if (!target.isCancelled()) {
-                    into(target);
-                }
-            }
-        });
-
-        return target;
-    }
-
-    /**
-     * Preloads the resource into the cache using the given width and height.
-     *
-     * <p>
-     *     Pre-loading is useful for making sure that resources you are going to to want in the near future are
-     *     available quickly.
-     * </p>
-     *
-     * @see com.bumptech.glide.ListPreloader
-     */
-    public Target<TranscodeType> preload(int width, int height) {
-        final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(width, height);
-        return into(target);
-    }
-
-    void applyCenterCrop() {
-        // To be implemented by subclasses when possible.
-    }
-
-    void applyFitCenter() {
-        // To be implemented by subclasses when possible.
-    }
-
-    private Priority getThumbnailPriority() {
-        final Priority result;
-        if (priority == Priority.LOW) {
-            result = Priority.NORMAL;
-        } else if (priority == Priority.NORMAL) {
-            result = Priority.HIGH;
-        } else {
-            result = Priority.IMMEDIATE;
-        }
-        return result;
-    }
-
-    private Request buildRequest(Target<TranscodeType> target) {
-        if (priority == null) {
-            priority = Priority.NORMAL;
-        }
-        return buildRequestRecursive(target, null);
-    }
-
-    private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
-        if (thumbnailRequestBuilder != null) {
-            // Recursive case: contains a potentially recursive thumbnail request builder.
-            if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
-                thumbnailRequestBuilder.animationFactory = animationFactory;
-            }
-
-            if (thumbnailRequestBuilder.priority == null) {
-                thumbnailRequestBuilder.priority = getThumbnailPriority();
-            }
-
-            if (overrideWidth > 0 && overrideHeight > 0
-                && thumbnailRequestBuilder.overrideWidth < 0
-                && thumbnailRequestBuilder.overrideHeight < 0) {
-              thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
-            }
-
-            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
-            // Recursively generate thumbnail requests.
-            Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
-            coordinator.setRequests(fullRequest, thumbRequest);
-            return coordinator;
-        } else if (thumbSizeMultiplier != null) {
-            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
-            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
-            Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
-            coordinator.setRequests(fullRequest, thumbnailRequest);
-            return coordinator;
-        } else {
-            // Base case: no thumbnail.
-            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
-        }
-    }
-
-    private Request obtainRequest(Target<TranscodeType> target, float sizeMultiplier, Priority priority,
-            RequestCoordinator requestCoordinator) {
-        return GenericRequest.obtain(
-                loadProvider,
-                model,
-                signature,
-                context,
-                priority,
-                target,
-                sizeMultiplier,
-                placeholderDrawable,
-                placeholderId,
-                errorPlaceholder,
-                errorId,
-                requestListener,
-                requestCoordinator,
-                glide.getEngine(),
-                transformation,
-                transcodeClass,
-                isCacheable,
-                animationFactory,
-                overrideWidth,
-                overrideHeight,
-                diskCacheStrategy);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java
deleted file mode 100644
index ca6292369..000000000
--- a/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package com.bumptech.glide;
-
-import android.content.Context;
-
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.load.resource.transcode.UnitTranscoder;
-import com.bumptech.glide.manager.Lifecycle;
-import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.provider.FixedLoadProvider;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.request.FutureTarget;
-import com.bumptech.glide.request.target.Target;
-
-import java.io.File;
-
-/**
- * A class for handling requests to load a generic resource type or transcode the generic resource type into another
- * generic resource type.
- *
- * <p>
- *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
- *     reused.
- * </p>
- *
- * @param <ModelType> The type of the model used to retrieve data.
- * @param <DataType> The type of data retrieved.
- * @param <ResourceType> The type of resource to be decoded from the the data.
- */
-public class GenericTranscodeRequest<ModelType, DataType, ResourceType>
-        extends GenericRequestBuilder<ModelType, DataType, ResourceType, ResourceType> implements DownloadOptions {
-    private final ModelLoader<ModelType, DataType> modelLoader;
-    private final Class<DataType> dataClass;
-    private final Class<ResourceType> resourceClass;
-    private final RequestManager.OptionsApplier optionsApplier;
-
-    private static <A, T, Z, R> LoadProvider<A, T, Z, R> build(Glide glide, ModelLoader<A, T> modelLoader,
-            Class<T> dataClass, Class<Z> resourceClass, ResourceTranscoder<Z, R> transcoder) {
-        DataLoadProvider<T, Z> dataLoadProvider = glide.buildDataProvider(dataClass, resourceClass);
-        return new FixedLoadProvider<A, T, Z, R>(modelLoader, transcoder, dataLoadProvider);
-    }
-
-    GenericTranscodeRequest(
-            Class<ResourceType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other,
-            ModelLoader<ModelType, DataType> modelLoader, Class<DataType> dataClass, Class<ResourceType> resourceClass,
-            RequestManager.OptionsApplier optionsApplier) {
-        super(build(other.glide, modelLoader, dataClass, resourceClass, UnitTranscoder.<ResourceType>get()),
-                transcodeClass, other);
-        this.modelLoader = modelLoader;
-        this.dataClass = dataClass;
-        this.resourceClass = resourceClass;
-        this.optionsApplier = optionsApplier;
-    }
-
-    GenericTranscodeRequest(Context context, Glide glide, Class<ModelType> modelClass,
-            ModelLoader<ModelType, DataType> modelLoader, Class<DataType> dataClass, Class<ResourceType> resourceClass,
-            RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) {
-        super(context, modelClass, build(glide, modelLoader, dataClass, resourceClass,
-                        UnitTranscoder.<ResourceType>get()), resourceClass, glide, requestTracker, lifecycle);
-        this.modelLoader = modelLoader;
-        this.dataClass = dataClass;
-        this.resourceClass = resourceClass;
-        this.optionsApplier = optionsApplier;
-    }
-
-    /**
-     * Adds a transcoder to this request to transcode from the resource type to the given transcode type.
-     *
-     * @param transcoder The transcoder to use.
-     * @param transcodeClass The class of the resource type that will be transcoded to.
-     * @param <TranscodeType> The type of the resource that will be transcoded to.
-     * @return A new request builder to set options for the transcoded load.
-     */
-    public <TranscodeType> GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transcode(
-            ResourceTranscoder<ResourceType, TranscodeType> transcoder, Class<TranscodeType> transcodeClass) {
-        LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider = build(glide, modelLoader,
-                dataClass, resourceClass, transcoder);
-
-        return optionsApplier.apply(new GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>(
-                loadProvider, transcodeClass, this));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public <Y extends Target<File>> Y downloadOnly(Y target) {
-        return getDownloadOnlyRequest().into(target);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public FutureTarget<File> downloadOnly(int width, int height) {
-        return getDownloadOnlyRequest().into(width, height);
-    }
-
-    private GenericRequestBuilder<ModelType, DataType, File, File> getDownloadOnlyRequest() {
-        ResourceTranscoder<File, File> transcoder = UnitTranscoder.get();
-        DataLoadProvider<DataType, File> dataLoadProvider = glide.buildDataProvider(dataClass, File.class);
-        FixedLoadProvider<ModelType, DataType, File, File> fixedLoadProvider =
-                new FixedLoadProvider<ModelType, DataType, File, File>(modelLoader, transcoder, dataLoadProvider);
-        return optionsApplier.apply(new GenericRequestBuilder<ModelType, DataType, File, File>(fixedLoadProvider,
-                File.class, this))
-                .priority(Priority.LOW)
-                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
-                .skipMemoryCache(true);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
new file mode 100644
index 000000000..47657e942
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide;
+
+/**
+ * Implementation of {@link TransitionOptions} that exposes only generic methods that can be applied
+ * to any resource type.
+ *
+ * @param <TranscodeType> The type of the resource that will be displayed.
+ */
+@SuppressWarnings("PMD.UseUtilityClass")
+public final class GenericTransitionOptions<TranscodeType> extends
+  TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
+
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {
+    return new GenericTransitionOptions<TranscodeType>().dontTransition();
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java
deleted file mode 100644
index 474f2e7c0..000000000
--- a/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java
+++ /dev/null
@@ -1,421 +0,0 @@
-package com.bumptech.glide;
-
-import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
-import android.view.animation.Animation;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.animation.DrawableCrossFadeFactory;
-import com.bumptech.glide.request.animation.ViewPropertyAnimation;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * A class for creating a request to load an animated gif.
- *
- * <p>
- *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
- *     reused.
- * </p>
- *
- * @param <ModelType> The type of model that will be loaded into the target.
- */
-public class GifRequestBuilder<ModelType>
-        extends GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable>
-        implements BitmapOptions, DrawableOptions {
-
-    GifRequestBuilder(LoadProvider<ModelType, InputStream, GifDrawable, GifDrawable> loadProvider,
-            Class<GifDrawable> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
-        super(loadProvider, transcodeClass, other);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> thumbnail(GenericRequestBuilder<?, ?, ?, GifDrawable> thumbnailRequest) {
-        super.thumbnail(thumbnailRequest);
-        return this;
-    }
-
-    /**
-     * Loads and displays the GIF retrieved by the given thumbnail request if it finishes before this
-     * request. Best used for loading thumbnail GIFs that are smaller and will be loaded more quickly
-     * than the fullsize GIF. There are no guarantees about the order in which the requests will actually
-     * finish. However, if the thumb request completes after the full request, the thumb GIF will never
-     * replace the full image.
-     *
-     * @see #thumbnail(float)
-     *
-     * <p>
-     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
-     *     you want an animation to occur when either the full GIF loads or the thumbnail loads,
-     *     you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
-     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
-     * </p>
-     *
-     * <p>
-     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
-     * </p>
-     *
-     * @param thumbnailRequest The request to use to load the thumbnail.
-     * @return This builder object.
-     */
-    public GifRequestBuilder<ModelType> thumbnail(GifRequestBuilder<?> thumbnailRequest) {
-        super.thumbnail(thumbnailRequest);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> thumbnail(float sizeMultiplier) {
-        super.thumbnail(sizeMultiplier);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> sizeMultiplier(float sizeMultiplier) {
-        super.sizeMultiplier(sizeMultiplier);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> decoder(
-            ResourceDecoder<InputStream, GifDrawable> decoder) {
-        super.decoder(decoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> cacheDecoder(
-            ResourceDecoder<File, GifDrawable> cacheDecoder) {
-        super.cacheDecoder(cacheDecoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> encoder(
-            ResourceEncoder<GifDrawable> encoder) {
-        super.encoder(encoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> priority(Priority priority) {
-        super.priority(priority);
-        return this;
-    }
-
-    /**
-     * Transforms each frame of the GIF using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
-     *
-     * @see #fitCenter()
-     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @return This request builder.
-     */
-    public GifRequestBuilder<ModelType> centerCrop() {
-        return transformFrame(glide.getBitmapCenterCrop());
-    }
-
-    /**
-     * Transforms each frame of the GIF using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
-     *
-     * @see #centerCrop()
-     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @return This request builder..
-     */
-    public GifRequestBuilder<ModelType> fitCenter() {
-        return transformFrame(glide.getBitmapFitCenter());
-    }
-
-    /**
-     * Transforms each frame of the GIF using the given transformations.
-     *
-     * @see #centerCrop()
-     * @see #fitCenter()
-     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @param bitmapTransformations The transformations to apply in order to each frame.
-     * @return This request builder.
-     */
-    public GifRequestBuilder<ModelType> transformFrame(BitmapTransformation... bitmapTransformations) {
-        return transform(toGifTransformations(bitmapTransformations));
-    }
-
-    /**
-     * Transforms each frame of the GIF using the given transformations.
-     *
-     * @see #fitCenter()
-     * @see #centerCrop()
-     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #transform(com.bumptech.glide.load.Transformation[])
-     *
-     * @param bitmapTransformations The transformations to apply in order to each frame.
-     * @return This request builder.
-     */
-    public GifRequestBuilder<ModelType> transformFrame(Transformation<Bitmap>... bitmapTransformations) {
-        return transform(toGifTransformations(bitmapTransformations));
-    }
-
-    private GifDrawableTransformation[] toGifTransformations(Transformation<Bitmap>[] bitmapTransformations) {
-        GifDrawableTransformation[] transformations = new GifDrawableTransformation[bitmapTransformations.length];
-        for (int i = 0; i < bitmapTransformations.length; i++) {
-            transformations[i] = new GifDrawableTransformation(bitmapTransformations[i], glide.getBitmapPool());
-        }
-        return transformations;
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * @see #fitCenter()
-     * @see #centerCrop()
-     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
-     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
-     *
-     */
-    @Override
-    public GifRequestBuilder<ModelType> transform(Transformation<GifDrawable>... transformations) {
-        super.transform(transformations);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> transcoder(ResourceTranscoder<GifDrawable, GifDrawable> transcoder) {
-        super.transcoder(transcoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> crossFade() {
-        super.animate(new DrawableCrossFadeFactory<GifDrawable>());
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> crossFade(int duration) {
-        super.animate(new DrawableCrossFadeFactory<GifDrawable>(duration));
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    @Override
-    public GifRequestBuilder<ModelType> crossFade(Animation animation, int duration) {
-        super.animate(new DrawableCrossFadeFactory<GifDrawable>(animation, duration));
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> crossFade(int animationId, int duration) {
-        super.animate(new DrawableCrossFadeFactory<GifDrawable>(context, animationId,
-                duration));
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> dontAnimate() {
-        super.dontAnimate();
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> animate(int animationId) {
-        super.animate(animationId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    @SuppressWarnings("deprecation")
-    @Override
-    public GifRequestBuilder<ModelType> animate(Animation animation) {
-        super.animate(animation);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> animate(ViewPropertyAnimation.Animator animator) {
-        super.animate(animator);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> placeholder(int resourceId) {
-        super.placeholder(resourceId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> placeholder(Drawable drawable) {
-        super.placeholder(drawable);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> error(int resourceId) {
-        super.error(resourceId);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> error(Drawable drawable) {
-        super.error(drawable);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> listener(
-            RequestListener<? super ModelType, GifDrawable> requestListener) {
-        super.listener(requestListener);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> skipMemoryCache(boolean skip) {
-        super.skipMemoryCache(skip);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {
-        super.diskCacheStrategy(strategy);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> override(int width, int height) {
-        super.override(width, height);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> sourceEncoder(Encoder<InputStream> sourceEncoder) {
-        super.sourceEncoder(sourceEncoder);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public GifRequestBuilder<ModelType> dontTransform() {
-        super.dontTransform();
-        return this;
-    }
-
-    @Override
-    public GifRequestBuilder<ModelType> signature(Key signature) {
-        super.signature(signature);
-        return this;
-    }
-
-    @Override
-    public GifRequestBuilder<ModelType> load(ModelType model) {
-        super.load(model);
-        return this;
-    }
-
-    @Override
-    public GifRequestBuilder<ModelType> clone() {
-        return (GifRequestBuilder<ModelType>) super.clone();
-    }
-
-    @Override
-    void applyFitCenter() {
-        fitCenter();
-    }
-
-    @Override
-    void applyCenterCrop() {
-        centerCrop();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/GifTypeRequest.java b/library/src/main/java/com/bumptech/glide/GifTypeRequest.java
deleted file mode 100644
index 7fd20898a..000000000
--- a/library/src/main/java/com/bumptech/glide/GifTypeRequest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package com.bumptech.glide;
-
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.provider.FixedLoadProvider;
-
-import java.io.InputStream;
-
-/**
- * A class for creating a load request that either loads an {@link com.bumptech.glide.load.resource.gif.GifDrawable}
- * directly or that adds an {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to transcode
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} into another resource type.
- *
- * @param <ModelType> The type of model to load the {@link com.bumptech.glide.load.resource.gif.GifDrawable} or other
- *           transcoded class from.
- */
-public class GifTypeRequest<ModelType> extends GifRequestBuilder<ModelType> {
-    private final ModelLoader<ModelType, InputStream> streamModelLoader;
-    private final RequestManager.OptionsApplier optionsApplier;
-
-    private static <A, R> FixedLoadProvider<A, InputStream, GifDrawable, R> buildProvider(Glide glide,
-            ModelLoader<A, InputStream> streamModelLoader, Class<R> transcodeClass,
-            ResourceTranscoder<GifDrawable, R> transcoder) {
-        if (streamModelLoader == null) {
-            return null;
-        }
-
-        if (transcoder == null) {
-            transcoder = glide.buildTranscoder(GifDrawable.class, transcodeClass);
-        }
-        DataLoadProvider<InputStream, GifDrawable> dataLoadProvider = glide.buildDataProvider(InputStream.class,
-                GifDrawable.class);
-        return new FixedLoadProvider<A, InputStream, GifDrawable, R>(streamModelLoader, transcoder, dataLoadProvider);
-    }
-
-    GifTypeRequest(GenericRequestBuilder<ModelType, ?, ?, ?> other,
-            ModelLoader<ModelType, InputStream> streamModelLoader, RequestManager.OptionsApplier optionsApplier) {
-        super(buildProvider(other.glide, streamModelLoader, GifDrawable.class, null), GifDrawable.class, other);
-        this.streamModelLoader = streamModelLoader;
-        this.optionsApplier = optionsApplier;
-
-        // Default to animating.
-        crossFade();
-    }
-
-    /**
-     * Sets a transcoder to transcode the decoded {@link com.bumptech.glide.load.resource.gif.GifDrawable} into another
-     * resource type.
-     *
-     * @param transcoder The transcoder to use.
-     * @param transcodeClass The {@link Class} of the resource the
-     * {@link com.bumptech.glide.load.resource.gif.GifDrawable} will be transcoded to.
-     *
-     * @param <R> The type of the resource the {@link com.bumptech.glide.load.resource.gif.GifDrawable} will be
-     *           trasncoded to.
-     * @return This request builder.
-     */
-    public <R> GenericRequestBuilder<ModelType, InputStream, GifDrawable, R> transcode(
-            ResourceTranscoder<GifDrawable, R> transcoder, Class<R> transcodeClass) {
-        FixedLoadProvider<ModelType, InputStream, GifDrawable, R> provider = buildProvider(glide, streamModelLoader,
-                transcodeClass, transcoder);
-        return optionsApplier.apply(new GenericRequestBuilder<ModelType, InputStream, GifDrawable, R>(provider,
-                transcodeClass, this));
-    }
-
-    /**
-     * Setup the request to return the bytes of the loaded gif.
-     * <p>
-     *     Note - Any transformations added during this load do not change the underlying bytes and therefore this
-     *     will always load and provide the bytes of the original image before any transformations to the given target.
-     * </p>
-     *
-     * @return A new Builder object to build a request to transform the given model into the bytes of an animated gif.
-     */
-    public GenericRequestBuilder<ModelType, InputStream, GifDrawable, byte[]> toBytes() {
-        return transcode(new GifDrawableBytesTranscoder(), byte[].class);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 5439a42a1..9366de2a0 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -2,663 +2,500 @@
 
 import android.annotation.TargetApi;
 import android.app.Activity;
+import android.content.ComponentCallbacks2;
 import android.content.Context;
+import android.content.res.Configuration;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
+import android.graphics.drawable.BitmapDrawable;
 import android.net.Uri;
 import android.os.Build;
-import android.os.Handler;
-import android.os.Looper;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
-import android.view.View;
-import android.widget.ImageView;
 
+import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.prefill.BitmapPreFiller;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
+import com.bumptech.glide.load.model.AssetUriLoader;
+import com.bumptech.glide.load.model.ByteArrayLoader;
+import com.bumptech.glide.load.model.ByteBufferEncoder;
+import com.bumptech.glide.load.model.ByteBufferFileLoader;
+import com.bumptech.glide.load.model.FileLoader;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.file_descriptor.FileDescriptorFileLoader;
-import com.bumptech.glide.load.model.file_descriptor.FileDescriptorResourceLoader;
-import com.bumptech.glide.load.model.file_descriptor.FileDescriptorStringLoader;
-import com.bumptech.glide.load.model.file_descriptor.FileDescriptorUriLoader;
-import com.bumptech.glide.load.model.stream.HttpUrlGlideUrlLoader;
-import com.bumptech.glide.load.model.stream.StreamByteArrayLoader;
-import com.bumptech.glide.load.model.stream.StreamFileLoader;
-import com.bumptech.glide.load.model.stream.StreamResourceLoader;
-import com.bumptech.glide.load.model.stream.StreamStringLoader;
-import com.bumptech.glide.load.model.stream.StreamUriLoader;
-import com.bumptech.glide.load.model.stream.StreamUrlLoader;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.FileDescriptorBitmapDataLoadProvider;
-import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
-import com.bumptech.glide.load.resource.bitmap.ImageVideoDataLoadProvider;
-import com.bumptech.glide.load.resource.bitmap.StreamBitmapDataLoadProvider;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-import com.bumptech.glide.load.resource.file.StreamFileDataLoadProvider;
+import com.bumptech.glide.load.model.MediaStoreFileLoader;
+import com.bumptech.glide.load.model.ResourceLoader;
+import com.bumptech.glide.load.model.StreamEncoder;
+import com.bumptech.glide.load.model.StringLoader;
+import com.bumptech.glide.load.model.UnitModelLoader;
+import com.bumptech.glide.load.model.UriLoader;
+import com.bumptech.glide.load.model.UrlUriLoader;
+import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
+import com.bumptech.glide.load.model.stream.HttpUriLoader;
+import com.bumptech.glide.load.model.stream.MediaStoreImageThumbLoader;
+import com.bumptech.glide.load.model.stream.MediaStoreVideoThumbLoader;
+import com.bumptech.glide.load.model.stream.UrlLoader;
+import com.bumptech.glide.load.resource.bitmap.BitmapDrawableDecoder;
+import com.bumptech.glide.load.resource.bitmap.BitmapDrawableEncoder;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bytes.ByteBufferRewinder;
+import com.bumptech.glide.load.resource.file.FileDecoder;
+import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableLoadProvider;
-import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
-import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;
-import com.bumptech.glide.load.resource.gifbitmap.ImageVideoGifDrawableLoadProvider;
-import com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder;
-import com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.load.resource.transcode.TranscoderRegistry;
+import com.bumptech.glide.load.resource.gif.GifDrawableEncoder;
+import com.bumptech.glide.load.resource.gif.GifFrameResourceDecoder;
+import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
+import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
+import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
+import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
 import com.bumptech.glide.manager.RequestManagerRetriever;
-import com.bumptech.glide.provider.DataLoadProvider;
-import com.bumptech.glide.provider.DataLoadProviderRegistry;
-import com.bumptech.glide.request.FutureTarget;
-import com.bumptech.glide.request.Request;
-import com.bumptech.glide.request.animation.GlideAnimation;
+import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.module.ManifestParser;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.util.Util;
 
 import java.io.File;
 import java.io.InputStream;
 import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
- * A singleton to present a simple static interface for building requests with {@link BitmapRequestBuilder} and
- * maintaining an {@link Engine}, {@link BitmapPool}, {@link com.bumptech.glide.load.engine.cache.DiskCache} and
- * {@link MemoryCache}.
+ * A singleton to present a simple static interface for building requests with
+ * {@link RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool},
+ * {@link com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
  */
-public class Glide {
-    /** 250 MB of cache. */
-    static final int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
-
-    private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
-    private static final String TAG = "Glide";
-    private static volatile Glide glide;
-
-    private final GenericLoaderFactory loaderFactory;
-    private final Engine engine;
-    private final BitmapPool bitmapPool;
-    private final MemoryCache memoryCache;
-    private final DecodeFormat decodeFormat;
-    private final ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
-    private final TranscoderRegistry transcoderRegistry = new TranscoderRegistry();
-    private final DataLoadProviderRegistry dataLoadProviderRegistry;
-    private final CenterCrop bitmapCenterCrop;
-    private final GifBitmapWrapperTransformation drawableCenterCrop;
-    private final FitCenter bitmapFitCenter;
-    private final GifBitmapWrapperTransformation drawableFitCenter;
-    private final Handler mainHandler;
-    private final BitmapPreFiller bitmapPreFiller;
-
-    /**
-     * Returns a directory with a default name in the private cache directory of the application to use to store
-     * retrieved media and thumbnails.
-     *
-     * @see #getPhotoCacheDir(android.content.Context, String)
-     *
-     * @param context A context.
-     */
-    public static File getPhotoCacheDir(Context context) {
-        return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
-    }
-
-    /**
-     * Returns a directory with the given name in the private cache directory of the application to use to store
-     * retrieved media and thumbnails.
-     *
-     * @see #getPhotoCacheDir(android.content.Context)
-     *
-     * @param context A context.
-     * @param cacheName The name of the subdirectory in which to store the cache.
-     */
-    public static File getPhotoCacheDir(Context context, String cacheName) {
-        File cacheDir = context.getCacheDir();
-        if (cacheDir != null) {
-            File result = new File(cacheDir, cacheName);
-            if (!result.mkdirs() && (!result.exists() || !result.isDirectory())) {
-                // File wasn't able to create a directory, or the result exists but not a directory
-                return null;
-            }
-            return result;
-        }
-        if (Log.isLoggable(TAG, Log.ERROR)) {
-            Log.e(TAG, "default disk cache dir is null");
-        }
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+public class Glide implements ComponentCallbacks2 {
+  private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
+  private static final String TAG = "Glide";
+  private static volatile Glide glide;
+
+  private final Engine engine;
+  private final BitmapPool bitmapPool;
+  private final MemoryCache memoryCache;
+  private final BitmapPreFiller bitmapPreFiller;
+  private final GlideContext glideContext;
+  private final Registry registry;
+  private final ArrayPool arrayPool;
+  private final ByteArrayPool byteArrayPool;
+  private final List<RequestManager> managers = new ArrayList<>();
+
+  /**
+   * Returns a directory with a default name in the private cache directory of the application to
+   * use to store retrieved media and thumbnails.
+   *
+   * @param context A context.
+   * @see #getPhotoCacheDir(android.content.Context, String)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(Context context) {
+    return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
+  }
+
+  /**
+   * Returns a directory with the given name in the private cache directory of the application to
+   * use to store retrieved media and thumbnails.
+   *
+   * @param context   A context.
+   * @param cacheName The name of the subdirectory in which to store the cache.
+   * @see #getPhotoCacheDir(android.content.Context)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(Context context, String cacheName) {
+    File cacheDir = context.getCacheDir();
+    if (cacheDir != null) {
+      File result = new File(cacheDir, cacheName);
+      if (!result.mkdirs() && (!result.exists() || !result.isDirectory())) {
+        // File wasn't able to create a directory, or the result exists but not a directory
         return null;
-    }
-
-    /**
-     * Get the singleton.
-     *
-     * @return the singleton
-     */
-    public static Glide get(Context context) {
+      }
+      return result;
+    }
+    if (Log.isLoggable(TAG, Log.ERROR)) {
+      Log.e(TAG, "default disk cache dir is null");
+    }
+    return null;
+  }
+
+  /**
+   * Get the singleton.
+   *
+   * @return the singleton
+   */
+  public static Glide get(Context context) {
+    if (glide == null) {
+      synchronized (Glide.class) {
         if (glide == null) {
-            synchronized (Glide.class) {
-                if (glide == null) {
-                    glide = new GlideBuilder(context).createGlide();
-                }
-            }
-        }
-
-        return glide;
-    }
-
-    /**
-     * Returns false if the {@link Glide} singleton has not yet been created and can therefore be setup using
-     * {@link #setup(GlideBuilder)}.
-     *
-     * @see #setup(GlideBuilder)
-     */
-    public static boolean isSetup() {
-        return glide != null;
-    }
-
-    /**
-     * Creates the {@link Glide} singleton using the given builder. Can be used to set options like cache sizes and
-     * locations.
-     *
-     * @see #isSetup()
-     *
-     * @param builder The builder.
-     * @throws IllegalArgumentException if the Glide singleton has already been created.
-     */
-    public static void setup(GlideBuilder builder) {
-        if (isSetup()) {
-            throw new IllegalArgumentException("Glide is already setup, check with isSetup() first");
-        }
-
-        glide = builder.createGlide();
-    }
-
-    // For testing.
-    static void tearDown() {
-        glide = null;
-    }
-
-    Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, Context context, DecodeFormat decodeFormat) {
-        this.engine = engine;
-        this.bitmapPool = bitmapPool;
-        this.memoryCache = memoryCache;
-        this.decodeFormat = decodeFormat;
-        loaderFactory = new GenericLoaderFactory(context);
-        mainHandler = new Handler(Looper.getMainLooper());
-        bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
-
-        dataLoadProviderRegistry = new DataLoadProviderRegistry();
-
-        StreamBitmapDataLoadProvider streamBitmapLoadProvider =
-                new StreamBitmapDataLoadProvider(bitmapPool, decodeFormat);
-        dataLoadProviderRegistry.register(InputStream.class, Bitmap.class, streamBitmapLoadProvider);
-
-        FileDescriptorBitmapDataLoadProvider fileDescriptorLoadProvider =
-                new FileDescriptorBitmapDataLoadProvider(bitmapPool, decodeFormat);
-        dataLoadProviderRegistry.register(ParcelFileDescriptor.class, Bitmap.class, fileDescriptorLoadProvider);
-
-        ImageVideoDataLoadProvider imageVideoDataLoadProvider =
-                new ImageVideoDataLoadProvider(streamBitmapLoadProvider, fileDescriptorLoadProvider);
-        dataLoadProviderRegistry.register(ImageVideoWrapper.class, Bitmap.class, imageVideoDataLoadProvider);
-
-        GifDrawableLoadProvider gifDrawableLoadProvider =
-                new GifDrawableLoadProvider(context, bitmapPool);
-        dataLoadProviderRegistry.register(InputStream.class, GifDrawable.class, gifDrawableLoadProvider);
-
-        dataLoadProviderRegistry.register(ImageVideoWrapper.class, GifBitmapWrapper.class,
-                new ImageVideoGifDrawableLoadProvider(imageVideoDataLoadProvider, gifDrawableLoadProvider, bitmapPool));
-
-        dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider());
-
-        register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());
-        register(File.class, InputStream.class, new StreamFileLoader.Factory());
-        register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());
-        register(int.class, InputStream.class, new StreamResourceLoader.Factory());
-        register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());
-        register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());
-        register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());
-        register(String.class, InputStream.class, new StreamStringLoader.Factory());
-        register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());
-        register(Uri.class, InputStream.class, new StreamUriLoader.Factory());
-        register(URL.class, InputStream.class, new StreamUrlLoader.Factory());
-        register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory());
-        register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory());
-
-        transcoderRegistry.register(Bitmap.class, GlideBitmapDrawable.class,
-                new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool));
-        transcoderRegistry.register(GifBitmapWrapper.class, GlideDrawable.class,
-                new GifBitmapWrapperDrawableTranscoder(
-                        new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool)));
-
-        bitmapCenterCrop = new CenterCrop(bitmapPool);
-        drawableCenterCrop = new GifBitmapWrapperTransformation(bitmapPool, bitmapCenterCrop);
-
-        bitmapFitCenter = new FitCenter(bitmapPool);
-        drawableFitCenter = new GifBitmapWrapperTransformation(bitmapPool, bitmapFitCenter);
-    }
-
-    /**
-     * Returns the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} used to temporarily store
-     * {@link android.graphics.Bitmap}s so they can be reused to avoid garbage collections.
-     *
-     * <p>
-     *     Note - Using this pool directly can lead to undefined behavior and strange drawing errors. Any
-     *     {@link android.graphics.Bitmap} added to the pool must not be currently in use in any other part of the
-     *     application. Any {@link android.graphics.Bitmap} added to the pool must be removed from the pool before it
-     *     is added a second time.
-     * </p>
-     *
-     * <p>
-     *     Note - To make effective use of the pool, any {@link android.graphics.Bitmap} removed from the pool must
-     *     eventually be re-added. Otherwise the pool will eventually empty and will not serve any useful purpose.
-     * </p>
-     *
-     * <p>
-     *     The primary reason this object is exposed is for use in custom
-     *     {@link com.bumptech.glide.load.ResourceDecoder}s and {@link com.bumptech.glide.load.Transformation}s. Use
-     *     outside of these classes is not generally recommended.
-     * </p>
-     */
-    public BitmapPool getBitmapPool() {
-        return bitmapPool;
-    }
-
-    <Z, R> ResourceTranscoder<Z, R> buildTranscoder(Class<Z> decodedClass, Class<R> transcodedClass) {
-        return transcoderRegistry.get(decodedClass, transcodedClass);
-    }
-
-    <T, Z> DataLoadProvider<T, Z> buildDataProvider(Class<T> dataClass, Class<Z> decodedClass) {
-        return dataLoadProviderRegistry.get(dataClass, decodedClass);
-    }
-
-    <R> Target<R> buildImageViewTarget(ImageView imageView, Class<R> transcodedClass) {
-        return imageViewTargetFactory.buildTarget(imageView, transcodedClass);
-    }
-
-    Engine getEngine() {
-        return engine;
-    }
-
-    CenterCrop getBitmapCenterCrop() {
-        return bitmapCenterCrop;
-    }
-
-    FitCenter getBitmapFitCenter() {
-        return bitmapFitCenter;
-    }
-
-    GifBitmapWrapperTransformation getDrawableCenterCrop() {
-        return drawableCenterCrop;
-    }
-
-    GifBitmapWrapperTransformation getDrawableFitCenter() {
-        return drawableFitCenter;
-    }
-
-    Handler getMainHandler() {
-        return mainHandler;
-    }
-
-    DecodeFormat getDecodeFormat() {
-        return decodeFormat;
-    }
-
-    private GenericLoaderFactory getLoaderFactory() {
-        return loaderFactory;
-    }
-
-    /**
-     * Pre-fills the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} using the given sizes.
-     *
-     * <p>
-     *   Enough Bitmaps are added to completely fill the pool, so most or all of the Bitmaps currently in the pool will
-     *   be evicted. Bitmaps are allocated according to the weights of the given sizes, where each size gets
-     *   (weight / prefillWeightSum) percent of the pool to fill.
-     * </p>
-     *
-     * <p>
-     *     Note - Pre-filling is done asynchronously using and {@link android.os.MessageQueue.IdleHandler}. Any
-     *     currently running pre-fill will be cancelled and replaced by a call to this method.
-     * </p>
-     *
-     * <p>
-     *     This method should be used with caution, overly aggressive pre-filling is substantially worse than not
-     *     pre-filling at all. Pre-filling should only be started in onCreate to avoid constantly clearing and
-     *     re-filling the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}. Rotation should be carefully
-     *     considered as well. It may be worth calling this method only when no saved instance state exists so that
-     *     pre-filling only happens when the Activity is first created, rather than on every rotation.
-     * </p>
-     *
-     * @param bitmapAttributeBuilders The list of
-     *     {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
-     *     individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
-     */
-    public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
-        bitmapPreFiller.preFill(bitmapAttributeBuilders);
-    }
-
-    /**
-     * Clears as much memory as possible.
-     *
-     * @see android.content.ComponentCallbacks2#onLowMemory()
-     */
-    public void clearMemory() {
-        bitmapPool.clearMemory();
-        memoryCache.clearMemory();
-    }
-
-    /**
-     * Clears some memory with the exact amount depending on the given level.
-     *
-     * @see android.content.ComponentCallbacks2#onTrimMemory(int)
-     */
-    public void trimMemory(int level) {
-        bitmapPool.trimMemory(level);
-        memoryCache.trimMemory(level);
-    }
-
-    /**
-     * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
-     *
-     * <p>
-     *     The default {@link MemoryCategory} is {@link MemoryCategory#NORMAL}. {@link MemoryCategory#HIGH} increases
-     *     Glide's maximum memory usage by up to 50% and {@link MemoryCategory#LOW} decreases Glide's maximum memory
-     *     usage by 50%. This method should be used to temporarily increase or decrease memory useage for a single
-     *     Activity or part of the app. Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to set a permanent
-     *     memory size if you want to change the default.
-     * </p>
-     */
-    public void setMemoryCategory(MemoryCategory memoryCategory) {
-        memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
-        bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
-    }
-
-    /**
-     * Cancel any pending loads Glide may have for the target and free any resources (such as {@link Bitmap}s) that may
-     * have been loaded for the target so they may be reused.
-     *
-     * @param target The Target to cancel loads for.
-     */
-    public static void clear(Target<?> target) {
-        Util.assertMainThread();
-        Request request = target.getRequest();
-        if (request != null) {
-            request.clear();
-        }
-    }
-
-    /**
-     * Cancel any pending loads Glide may have for the target and free any resources that may have been loaded into
-     * the target so they may be reused.
-     *
-     * @param target The target to cancel loads for.
-     */
-    public static void clear(FutureTarget<?> target) {
-        target.clear();
-    }
-
-    /**
-     * Cancel any pending loads Glide may have for the view and free any resources that may have been loaded for the
-     * view.
-     *
-     * <p>
-     *     Note that this will only work if {@link View#setTag(Object)} is not called on this view outside of Glide.
-     * </p>
-     *
-     * @see #clear(Target).
-     *
-     * @param view The view to cancel loads and free resources for.
-     * @throws IllegalArgumentException if an object other than Glide's metadata is set as the view's tag.
-     */
-    public static void clear(View view) {
-        Target<?> viewTarget = new ClearTarget(view);
-        clear(viewTarget);
-    }
-
-    /**
-     * Use the given factory to build a {@link ModelLoader} for models of the given class. Generally the best use of
-     * this method is to replace one of the default factories or add an implementation for other similar low level
-     * models. Typically the {@link RequestManager#using(com.bumptech.glide.load.model.stream.StreamModelLoader)} or
-     * {@link RequestManager#using(com.bumptech.glide.load.model.file_descriptor.FileDescriptorModelLoader)} syntax is
-     * preferred because it directly links the model with the ModelLoader being used to load it. Any factory replaced
-     * by the given factory will have its {@link ModelLoaderFactory#teardown()}} method called.
-     *
-     * <p>
-     *     Note - If a factory already exists for the given class, it will be replaced. If that factory is not being
-     *     used for any other model class, {@link ModelLoaderFactory#teardown()}
-     *     will be called.
-     * </p>
-     *
-     * <p>
-     *     Note - The factory must not be an anonymous inner class of an Activity or another object that cannot be
-     *     retained statically.
-     * </p>
-     *
-     * @see RequestManager#using(com.bumptech.glide.load.model.file_descriptor.FileDescriptorModelLoader)
-     * @see RequestManager#using(com.bumptech.glide.load.model.stream.StreamModelLoader)
-     *
-     * @param modelClass The model class.
-     * @param resourceClass The resource class the model loader will translate the model type into.
-     * @param factory The factory to use.
-     * @param <T> The type of the model.
-     * @param <Y> the type of the resource.
-     */
-    public <T, Y> void register(Class<T> modelClass, Class<Y> resourceClass, ModelLoaderFactory<T, Y> factory) {
-        ModelLoaderFactory<T, Y> removed = loaderFactory.register(modelClass, resourceClass, factory);
-        if (removed != null) {
-            removed.teardown();
-        }
-    }
-
-    /**
-     * Removes any {@link ModelLoaderFactory} registered for the given model and resource classes if one exists. If a
-     * {@link ModelLoaderFactory} is removed, its {@link ModelLoaderFactory#teardown()}} method will be called.
-     *
-     * @param modelClass The model class.
-     * @param resourceClass The resource class.
-     * @param <T> The type of the model.
-     * @param <Y> The type of the resource.
-     */
-    public <T, Y> void unregister(Class<T> modelClass, Class<Y> resourceClass) {
-        ModelLoaderFactory<T, Y> removed = loaderFactory.unregister(modelClass, resourceClass);
-        if (removed != null) {
-            removed.teardown();
-        }
-    }
-
-    /**
-     * Build a {@link ModelLoader} for the given model class using registered {@link ModelLoaderFactory}s.
-     *
-     * @see  #buildModelLoader(Object, Class, Context)
-     * @see  #buildStreamModelLoader(Class, Context)
-     * @see  #buildFileDescriptorModelLoader(Class, Context)
-     *
-     * @param modelClass The class to get a {@link ModelLoader} for.
-     * @param resourceClass The resource class to get a {@link ModelLoader} for.
-     * @param context Any context.
-     * @param <T> The type of the model.
-     * @param <Y> The type of the resource.
-     * @return A new {@link ModelLoader} for the given model class.
-     */
-    public static <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass,
-            Context context) {
-         if (modelClass == null) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Unable to load null model, setting placeholder only");
-            }
-            return null;
-        }
-        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);
-    }
-
-    /**
-     * A convenience method to build a {@link ModelLoader} for a given model object using registered
-     * {@link ModelLoaderFactory}s.
-     *
-     * @see #buildModelLoader(Class, Class, Context)
-     *
-     * @param model A non null model object whose class we will get a {@link ModelLoader} for.
-     * @param resourceClass The resource class to get a {@link ModelLoader} for.
-     * @param context Any context.
-     * @param <T> The type of the model.
-     * @param <Y> The type of the resource.
-     * @return A new {@link ModelLoader} for the given model and resource classes, or null if model is null.
-     */
-    @SuppressWarnings("unchecked")
-    public static <T, Y> ModelLoader<T, Y> buildModelLoader(T model, Class<Y> resourceClass, Context context) {
-        return buildModelLoader(model != null ? (Class<T>) model.getClass() : null, resourceClass, context);
-    }
-
-    /**
-     * A method to build a {@link ModelLoader} for the given model that produces {@link InputStream}s using a registered
-     * factory.
-     *
-     * @see #buildModelLoader(Class, Class, android.content.Context)
-     */
-    public static <T> ModelLoader<T, InputStream> buildStreamModelLoader(Class<T> modelClass, Context context) {
-        return buildModelLoader(modelClass, InputStream.class, context);
-    }
-
-    /**
-     * A method to build a {@link ModelLoader} for the given model that produces {@link InputStream}s using a registered
-     * factory.
-     *
-     * @see #buildModelLoader(Object, Class, Context)
-     */
-    public static <T> ModelLoader<T, InputStream> buildStreamModelLoader(T model, Context context) {
-        return buildModelLoader(model, InputStream.class, context);
-    }
-
-    /**
-     * A method to build a {@link ModelLoader} for the given model class that produces
-     * {@link ParcelFileDescriptor}s using a registered factory.
-     *
-     * @see #buildModelLoader(Class, Class, android.content.Context)
-     */
-    public static <T> ModelLoader<T, ParcelFileDescriptor> buildFileDescriptorModelLoader(Class<T> modelClass,
-            Context context) {
-        return buildModelLoader(modelClass, ParcelFileDescriptor.class, context);
-    }
-
-    /**
-     * A method to build a {@link ModelLoader} for the given model class that produces
-     * {@link ParcelFileDescriptor}s using a registered factory.
-     *
-     * @see #buildModelLoader(Object, Class, android.content.Context)
-     */
-    public static <T> ModelLoader<T, ParcelFileDescriptor> buildFileDescriptorModelLoader(T model, Context context) {
-        return buildModelLoader(model, ParcelFileDescriptor.class, context);
-    }
-
-    /**
-     * Begin a load with Glide by passing in a context.
-     *
-     * <p>
-     *     Any requests started using a context will only have the application level options applied and will not be
-     *     started or stopped based on lifecycle events. In general, loads should be started at the level the result
-     *     will be used in. If the resource will be used in a view in a child fragment,
-     *     the load should be started with {@link #with(android.app.Fragment)}} using that child fragment. Similarly,
-     *     if the resource will be used in a view in the parent fragment, the load should be started with
-     *     {@link #with(android.app.Fragment)} using the parent fragment. In the same vein, if the resource will be used
-     *     in a view in an activity, the load should be started with {@link #with(android.app.Activity)}}.
-     * </p>
-     *
-     * <p>
-     *     This method is appropriate for resources that will be used outside of the normal fragment or activity
-     *     lifecycle (For example in services, or for notification thumbnails).
-     * </p>
-     *
-     * @see #with(android.app.Activity)
-     * @see #with(android.app.Fragment)
-     * @see #with(android.support.v4.app.Fragment)
-     * @see #with(android.support.v4.app.FragmentActivity)
-     *
-     * @param context Any context, will not be retained.
-     * @return A RequestManager for the top level application that can be used to start a load.
-     */
-    public static RequestManager with(Context context) {
-        RequestManagerRetriever retriever = RequestManagerRetriever.get();
-        return retriever.get(context);
-    }
-
-    /**
-     * Begin a load with Glide that will be tied to the given {@link android.app.Activity}'s lifecycle and that uses the
-     * given {@link Activity}'s default options.
-     *
-     * @param activity The activity to use.
-     * @return A RequestManager for the given activity that can be used to start a load.
-     */
-    public static RequestManager with(Activity activity) {
-        RequestManagerRetriever retriever = RequestManagerRetriever.get();
-        return retriever.get(activity);
-    }
-
-    /**
-     * Begin a load with Glide that will tied to the give {@link android.support.v4.app.FragmentActivity}'s lifecycle
-     * and that uses the given {@link android.support.v4.app.FragmentActivity}'s default options.
-     *
-     * @param activity The activity to use.
-     * @return A RequestManager for the given FragmentActivity that can be used to start a load.
-     */
-    public static RequestManager with(FragmentActivity activity) {
-        RequestManagerRetriever retriever = RequestManagerRetriever.get();
-        return retriever.get(activity);
-    }
-
-    /**
-     * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle and that uses
-     * the given {@link android.app.Fragment}'s default options.
-     *
-     * @param fragment The fragment to use.
-     * @return A RequestManager for the given Fragment that can be used to start a load.
-     */
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public static RequestManager with(android.app.Fragment fragment) {
-        RequestManagerRetriever retriever = RequestManagerRetriever.get();
-        return retriever.get(fragment);
-    }
-
-    /**
-     * Begin a load with Glide that will be tied to the given {@link android.support.v4.app.Fragment}'s lifecycle and
-     * that uses the given {@link android.support.v4.app.Fragment}'s default options.
-     *
-     * @param fragment The fragment to use.
-     * @return A RequestManager for the given Fragment that can be used to start a load.
-     */
-    public static RequestManager with(Fragment fragment) {
-        RequestManagerRetriever retriever = RequestManagerRetriever.get();
-        return retriever.get(fragment);
-    }
-
-    private static class ClearTarget extends ViewTarget<View, Object> {
-        public ClearTarget(View view) {
-            super(view);
-        }
-
-        @Override
-        public void onLoadStarted(Drawable placeholder) {
-            // Do nothing.
+          Context applicationContext = context.getApplicationContext();
+          List<GlideModule> modules = new ManifestParser(applicationContext).parse();
+
+          GlideBuilder builder = new GlideBuilder(applicationContext);
+          for (GlideModule module : modules) {
+            module.applyOptions(applicationContext, builder);
+          }
+          glide = builder.createGlide();
+          for (GlideModule module : modules) {
+            module.registerComponents(applicationContext, glide.registry);
+          }
         }
-
-        @Override
-        public void onLoadFailed(Exception e, Drawable errorDrawable) {
-            // Do nothing.
-        }
-
-        @Override
-        public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {
-            // Do nothing.
+      }
+    }
+
+    return glide;
+  }
+
+  // For testing.
+  static void tearDown() {
+    glide = null;
+  }
+
+  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+  Glide(
+      Engine engine,
+      MemoryCache memoryCache,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      Context context,
+      int logLevel,
+      RequestOptions defaultRequestOptions) {
+    this.engine = engine;
+    this.bitmapPool = bitmapPool;
+    this.arrayPool = arrayPool;
+    this.memoryCache = memoryCache;
+    this.byteArrayPool = new LruByteArrayPool();
+
+    DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
+    bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
+
+    Resources resources = context.getResources();
+
+    Downsampler downsampler =
+        new Downsampler(resources.getDisplayMetrics(), bitmapPool, byteArrayPool);
+    ByteBufferGifDecoder byteBufferGifDecoder =
+        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);
+    registry = new Registry(context)
+        .register(ByteBuffer.class, new ByteBufferEncoder())
+        .register(InputStream.class, new StreamEncoder(byteArrayPool))
+        /* Bitmaps */
+        .append(ByteBuffer.class, Bitmap.class,
+            new ByteBufferBitmapDecoder(downsampler))
+        .append(InputStream.class, Bitmap.class,
+            new StreamBitmapDecoder(downsampler, byteArrayPool))
+        .append(ParcelFileDescriptor.class, Bitmap.class, new VideoBitmapDecoder(bitmapPool))
+        .register(Bitmap.class, new BitmapEncoder())
+        /* GlideBitmapDrawables */
+        .append(ByteBuffer.class, BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, bitmapPool,
+                new ByteBufferBitmapDecoder(downsampler)))
+        .append(InputStream.class, BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, bitmapPool,
+                new StreamBitmapDecoder(downsampler, byteArrayPool)))
+        .append(ParcelFileDescriptor.class, BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
+        .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
+        /* Gifs */
+        .prepend(InputStream.class, GifDrawable.class,
+            new StreamGifDecoder(byteBufferGifDecoder, byteArrayPool))
+        .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
+        .register(GifDrawable.class, new GifDrawableEncoder())
+        /* Gif Frames */
+        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
+        .append(GifDecoder.class, Bitmap.class, new GifFrameResourceDecoder(bitmapPool))
+        /* Files */
+        .register(new ByteBufferRewinder.Factory())
+        .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
+        .append(File.class, InputStream.class, new FileLoader.StreamFactory())
+        .append(File.class, File.class, new FileDecoder())
+        .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
+        .append(File.class, File.class, new UnitModelLoader.Factory<File>())
+        /* Models */
+        .register(new InputStreamRewinder.Factory(byteArrayPool))
+        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory())
+        .append(int.class, ParcelFileDescriptor.class, new ResourceLoader.FileDescriptorFactory())
+        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory())
+        .append(Integer.class, ParcelFileDescriptor.class,
+            new ResourceLoader.FileDescriptorFactory())
+        .append(String.class, InputStream.class, new StringLoader.StreamFactory())
+        .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
+        .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
+        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory())
+        .append(Uri.class, ParcelFileDescriptor.class, new AssetUriLoader.FileDescriptorFactory())
+        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory())
+        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory())
+        .append(Uri.class, InputStream.class, new UriLoader.StreamFactory())
+        .append(Uri.class, ParcelFileDescriptor.class, new UriLoader.FileDescriptorFactory())
+        .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
+        .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
+        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory())
+        .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
+        .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
+        .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
+        /* Transcoders */
+        .register(Bitmap.class, BitmapDrawable.class,
+            new BitmapDrawableTranscoder(resources, bitmapPool))
+        .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
+        .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
+
+    ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
+    glideContext = new GlideContext(context, registry, imageViewTargetFactory,
+        defaultRequestOptions, engine, this, logLevel);
+  }
+
+  /**
+   * Returns the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} used to
+   * temporarily store {@link android.graphics.Bitmap}s so they can be reused to avoid garbage
+   * collections.
+   *
+   * <p> Note - Using this pool directly can lead to undefined behavior and strange drawing errors.
+   * Any {@link android.graphics.Bitmap} added to the pool must not be currently in use in any other
+   * part of the application. Any {@link android.graphics.Bitmap} added to the pool must be removed
+   * from the pool before it is added a second time. </p>
+   *
+   * <p> Note - To make effective use of the pool, any {@link android.graphics.Bitmap} removed from
+   * the pool must eventually be re-added. Otherwise the pool will eventually empty and will not
+   * serve any useful purpose. </p>
+   *
+   * <p> The primary reason this object is exposed is for use in custom
+   * {@link com.bumptech.glide.load.ResourceDecoder}s and
+   * {@link com.bumptech.glide.load.Transformation}s. Use outside of these classes is not generally
+   * recommended. </p>
+   */
+  public BitmapPool getBitmapPool() {
+    return bitmapPool;
+  }
+
+  public ByteArrayPool getByteArrayPool() {
+    return byteArrayPool;
+  }
+
+  public ArrayPool getArrayPool() {
+    return arrayPool;
+  }
+
+  GlideContext getGlideContext() {
+    return glideContext;
+  }
+
+  /**
+   * Pre-fills the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} using the given
+   * sizes.
+   *
+   * <p> Enough Bitmaps are added to completely fill the pool, so most or all of the Bitmaps
+   * currently in the pool will be evicted. Bitmaps are allocated according to the weights of the
+   * given sizes, where each size gets (weight / prefillWeightSum) percent of the pool to fill.
+   * </p>
+   *
+   * <p> Note - Pre-filling is done asynchronously using and
+   * {@link android.os.MessageQueue.IdleHandler}. Any currently running pre-fill will be cancelled
+   * and replaced by a call to this method. </p>
+   *
+   * <p> This method should be used with caution, overly aggressive pre-filling is substantially
+   * worse than not pre-filling at all. Pre-filling should only be started in onCreate to avoid
+   * constantly clearing and re-filling the
+   * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}. Rotation should be carefully
+   * considered as well. It may be worth calling this method only when no saved instance state
+   * exists so that pre-filling only happens when the Activity is first created, rather than on
+   * every rotation. </p>
+   *
+   * @param bitmapAttributeBuilders The list of
+   * {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
+   * individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
+   */
+  public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
+    bitmapPreFiller.preFill(bitmapAttributeBuilders);
+  }
+
+  /**
+   * Clears as much memory as possible.
+   *
+   * @see android.content.ComponentCallbacks#onLowMemory()
+   * @see android.content.ComponentCallbacks2#onLowMemory()
+   */
+  public void clearMemory() {
+    bitmapPool.clearMemory();
+    memoryCache.clearMemory();
+    arrayPool.clearMemory();
+  }
+
+  /**
+   * Clears some memory with the exact amount depending on the given level.
+   *
+   * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+   */
+  public void trimMemory(int level) {
+    bitmapPool.trimMemory(level);
+    memoryCache.trimMemory(level);
+    arrayPool.trimMemory(level);
+  }
+
+  /**
+   * Clears disk cache.
+   *
+   * <p>
+   *     This method should always be called on a background thread, since it is a blocking call.
+   * </p>
+   */
+  public void clearDiskCache() {
+    Util.assertBackgroundThread();
+    engine.clearDiskCache();
+  }
+
+  /**
+   * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
+   *
+   * <p> The default {@link MemoryCategory} is {@link MemoryCategory#NORMAL}.
+   * {@link MemoryCategory#HIGH} increases Glide's maximum memory usage by up to 50% and
+   * {@link MemoryCategory#LOW} decreases Glide's maximum memory usage by 50%. This method should be
+   * used to temporarily increase or decrease memory usage for a single Activity or part of the app.
+   * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want
+   * to change the default. </p>
+   */
+  public void setMemoryCategory(MemoryCategory memoryCategory) {
+    memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
+    bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
+  }
+
+  /**
+   * Begin a load with Glide by passing in a context.
+   *
+   * <p> Any requests started using a context will only have the application level options applied
+   * and will not be started or stopped based on lifecycle events. In general, loads should be
+   * started at the level the result will be used in. If the resource will be used in a view in a
+   * child fragment, the load should be started with {@link #with(android.app.Fragment)}} using that
+   * child fragment. Similarly, if the resource will be used in a view in the parent fragment, the
+   * load should be started with {@link #with(android.app.Fragment)} using the parent fragment. In
+   * the same vein, if the resource will be used in a view in an activity, the load should be
+   * started with {@link #with(android.app.Activity)}}. </p>
+   *
+   * <p> This method is appropriate for resources that will be used outside of the normal fragment
+   * or activity lifecycle (For example in services, or for notification thumbnails). </p>
+   *
+   * @param context Any context, will not be retained.
+   * @return A RequestManager for the top level application that can be used to start a load.
+   * @see #with(android.app.Activity)
+   * @see #with(android.app.Fragment)
+   * @see #with(android.support.v4.app.Fragment)
+   * @see #with(android.support.v4.app.FragmentActivity)
+   */
+  public static RequestManager with(Context context) {
+    RequestManagerRetriever retriever = RequestManagerRetriever.get();
+    return retriever.get(context);
+  }
+
+  /**
+   * Begin a load with Glide that will be tied to the given {@link android.app.Activity}'s lifecycle
+   * and that uses the given {@link Activity}'s default options.
+   *
+   * @param activity The activity to use.
+   * @return A RequestManager for the given activity that can be used to start a load.
+   */
+  public static RequestManager with(Activity activity) {
+    RequestManagerRetriever retriever = RequestManagerRetriever.get();
+    return retriever.get(activity);
+  }
+
+  /**
+   * Begin a load with Glide that will tied to the give
+   * {@link android.support.v4.app.FragmentActivity}'s lifecycle and that uses the given
+   * {@link android.support.v4.app.FragmentActivity}'s default options.
+   *
+   * @param activity The activity to use.
+   * @return A RequestManager for the given FragmentActivity that can be used to start a load.
+   */
+  public static RequestManager with(FragmentActivity activity) {
+    RequestManagerRetriever retriever = RequestManagerRetriever.get();
+    return retriever.get(activity);
+  }
+
+  /**
+   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
+   * and that uses the given {@link android.app.Fragment}'s default options.
+   *
+   * @param fragment The fragment to use.
+   * @return A RequestManager for the given Fragment that can be used to start a load.
+   */
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  public static RequestManager with(android.app.Fragment fragment) {
+    RequestManagerRetriever retriever = RequestManagerRetriever.get();
+    return retriever.get(fragment);
+  }
+
+  /**
+   * Begin a load with Glide that will be tied to the given
+   * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
+   * {@link android.support.v4.app.Fragment}'s default options.
+   *
+   * @param fragment The fragment to use.
+   * @return A RequestManager for the given Fragment that can be used to start a load.
+   */
+  public static RequestManager with(Fragment fragment) {
+    RequestManagerRetriever retriever = RequestManagerRetriever.get();
+    return retriever.get(fragment);
+  }
+
+  public Registry getRegistry() {
+    return registry;
+  }
+
+  void removeFromManagers(Target<?> target) {
+    synchronized (managers) {
+      for (RequestManager requestManager : managers) {
+        if (requestManager.untrack(target)) {
+          return;
         }
-
-        @Override
-        public void onLoadCleared(Drawable placeholder) {
-            // Do nothing.
-        }
-    }
+      }
+    }
+    throw new IllegalStateException("Failed to remove target from managers");
+  }
+
+  void registerRequestManager(RequestManager requestManager) {
+    synchronized (managers) {
+      if (managers.contains(requestManager)) {
+        throw new IllegalStateException("Cannot register already registered manager");
+      }
+      managers.add(requestManager);
+    }
+  }
+
+  void unregisterRequestManager(RequestManager requestManager) {
+    synchronized (managers) {
+      if (!managers.contains(requestManager)) {
+        throw new IllegalStateException("Cannot register not yet registered manager");
+      }
+      managers.remove(requestManager);
+    }
+  }
+
+  @Override
+  public void onTrimMemory(int level) {
+    trimMemory(level);
+  }
+
+  @Override
+  public void onConfigurationChanged(Configuration newConfig) {
+    // Do nothing.
+  }
+
+  @Override
+  public void onLowMemory() {
+    clearMemory();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 49e4d2fe0..8551252e9 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -2,186 +2,294 @@
 
 import android.content.Context;
 import android.os.Build;
+import android.util.Log;
 
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
-import com.bumptech.glide.load.engine.cache.DiskCacheAdapter;
-import com.bumptech.glide.load.engine.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.load.engine.cache.InternalCacheDiskCacheFactory;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
-import com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor;
-
-import java.io.File;
-import java.util.concurrent.ExecutorService;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.request.RequestOptions;
 
 /**
  * A builder class for setting default structural classes for Glide to use.
  */
-public class GlideBuilder {
-    private final Context context;
-
-    private Engine engine;
-    private BitmapPool bitmapPool;
-    private MemoryCache memoryCache;
-    private DiskCache diskCache;
-    private ExecutorService sourceService;
-    private ExecutorService diskCacheService;
-    private DecodeFormat decodeFormat;
-
-    public GlideBuilder(Context context) {
-        this.context = context.getApplicationContext();
-    }
+public final class GlideBuilder {
+  private final Context context;
+
+  private Engine engine;
+  private BitmapPool bitmapPool;
+  private ArrayPool arrayPool;
+  private MemoryCache memoryCache;
+  private GlideExecutor sourceExecutor;
+  private GlideExecutor diskCacheExecutor;
+  private DiskCache.Factory diskCacheFactory;
+  private MemorySizeCalculator memorySizeCalculator;
+  private int logLevel = Log.INFO;
+  private RequestOptions defaultRequestOptions = new RequestOptions();
+
+  GlideBuilder(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  /**
+   * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
+   * to store and retrieve reused {@link android.graphics.Bitmap}s.
+   *
+   * @param bitmapPool The pool to use.
+   * @return This builder.
+   */
+  public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
+    this.bitmapPool = bitmapPool;
+    return this;
+  }
+
+  /**
+   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored
+   * and retrieved as needed.
+   *
+   * @param arrayPool The pool to use.
+   * @return This builder.
+   */
+  public GlideBuilder setArrayPool(ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
+    return this;
+  }
+
+  /**
+   * Sets the {@link com.bumptech.glide.load.engine.cache.MemoryCache} implementation to store
+   * {@link com.bumptech.glide.load.engine.Resource}s that are not currently in use.
+   *
+   * @param memoryCache The cache to use.
+   * @return This builder.
+   */
+  public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
+    this.memoryCache = memoryCache;
+    return this;
+  }
+
+  /**
+   * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
+   * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
+   *
+   * @param diskCache The disk cache to use.
+   * @return This builder.
+   * @deprecated Creating a disk cache directory on the main thread causes strict mode violations,
+   * use {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead.
+   * Scheduled to be removed in Glide 4.0.
+   */
+  @Deprecated
+  public GlideBuilder setDiskCache(final DiskCache diskCache) {
+    return setDiskCache(new DiskCache.Factory() {
+      @Override
+      public DiskCache build() {
+        return diskCache;
+      }
+    });
+  }
+
+  /**
+   * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use
+   * to construct the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store {@link
+   * com.bumptech.glide.load.engine.Resource} data on disk.
+   *
+   * @param diskCacheFactory The disk cache factory to use.
+   * @return This builder.
+   */
+  public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
+    this.diskCacheFactory = diskCacheFactory;
+    return this;
+  }
 
-    /**
-     * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use to store and
-     * retrieve reused {@link android.graphics.Bitmap}s.
-     *
-     * @param bitmapPool The pool to use.
-     * @return This builder.
-     */
-    public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
-        this.bitmapPool = bitmapPool;
-        return this;
+  /**
+   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   *
+   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
+   * for thumbnail requests to work properly.
+   *
+   * @param service The ExecutorService to use.
+   * @return This builder.
+   * @see #setDiskCacheExecutor(GlideExecutor)
+   * @see GlideExecutor
+   */
+  public GlideBuilder setResizeExecutor(GlideExecutor service) {
+    this.sourceExecutor = service;
+    return this;
+  }
+
+  /**
+   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
+   *
+   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
+   * for thumbnail requests to work properly.
+   *
+   * @param service The ExecutorService to use.
+   * @return This builder.
+   * @see #setResizeExecutor(GlideExecutor)
+   * @see GlideExecutor
+   */
+  public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
+    this.diskCacheExecutor = service;
+    return this;
+  }
+
+  /**
+   * Sets the default {@link RequestOptions} to use for all loads across the app.
+   *
+   * <p>Applying additional options with {@link
+   * RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions)} will override defaults
+   * set here.
+   *
+   * @param requestOptions The options to use by default.
+   * @return This builder.
+   */
+  public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
+    this.defaultRequestOptions = requestOptions;
+    return this;
+  }
+
+  /**
+   * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all
+   * the default decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link
+   * android.graphics.Bitmap}s they decode.
+   *
+   * <p> Decode format is always a suggestion, not a requirement. See {@link
+   * com.bumptech.glide.load.DecodeFormat} for more details. </p>
+   *
+   * @param decodeFormat The format to use.
+   * @return This builder.
+   *
+   * @deprecated Use {@link #setDefaultRequestOptions(RequestOptions)} instead.
+   */
+  @Deprecated
+  public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
+    defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));
+    return this;
+  }
+
+  /**
+   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default
+   * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
+   *
+   * @see #setMemorySizeCalculator(MemorySizeCalculator)
+   *
+   * @param builder The builder to use (will not be modified).
+   * @return This builder.
+   */
+  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder) {
+    return setMemorySizeCalculator(builder.build());
+  }
+
+  /**
+   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default
+   * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
+   *
+   * <p>The given {@link MemorySizeCalculator} will not affect custom pools or caches provided
+   * via {@link #setBitmapPool(BitmapPool)} or {@link #setMemoryCache(MemoryCache)}.
+   *
+   * @param calculator The calculator to use.
+   * @return This builder.
+   */
+  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
+    this.memorySizeCalculator = calculator;
+    return this;
+  }
+
+  /**
+   * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity.
+   *
+   * <p>The level must be one of {@link Log#VERBOSE}, {@link Log#DEBUG}, {@link Log#INFO},
+   * {@link Log#WARN}, or {@link Log#ERROR}.
+   *
+   * <p>{@link Log#VERBOSE} means one or more lines will be logged per request, including
+   * timing logs and failures. {@link Log#DEBUG} means at most one line will be logged
+   * per successful request, including timing logs, although many lines may be logged for
+   * failures including multiple complete stack traces. {@link Log#INFO} means
+   * failed loads will be logged including multiple complete stack traces, but successful loads
+   * will not be logged at all. {@link Log#WARN} means only summaries of failed loads will be
+   * logged. {@link Log#ERROR} means only exceptional cases will be logged.
+   *
+   * <p>All logs will be logged using the 'Glide' tag.
+   *
+   * <p>Many other debugging logs are available in individual classes. The log level supplied here
+   * only controls a small set of informative and well formatted logs. Users wishing to debug
+   * certain aspects of the library can look for individual <code>TAG</code> variables at the tops
+   * of classes and use <code>adb shell setprop log.tag.TAG</code> to enable or disable any relevant
+   * tags.
+   *
+   * @param logLevel The log level to use from {@link Log}.
+   * @return This builder.
+   */
+  public GlideBuilder setLogLevel(int logLevel) {
+    if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {
+      throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,"
+          + " Log.INFO, Log.WARN, or Log.ERROR");
     }
+    this.logLevel = logLevel;
+    return this;
+  }
+
+  // For testing.
+  GlideBuilder setEngine(Engine engine) {
+    this.engine = engine;
+    return this;
+  }
 
-    /**
-     * Sets the {@link com.bumptech.glide.load.engine.cache.MemoryCache} implementation to store
-     * {@link com.bumptech.glide.load.engine.Resource}s that are not currently in use.
-     *
-     * @param memoryCache  The cache to use.
-     * @return This builder.
-     */
-    public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
-        this.memoryCache = memoryCache;
-        return this;
+  Glide createGlide() {
+    if (sourceExecutor == null) {
+      final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());
+      sourceExecutor = new GlideExecutor("source", cores);
+    }
+    if (diskCacheExecutor == null) {
+      diskCacheExecutor = new GlideExecutor("disk-cache", 1);
     }
 
-    /**
-     * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
-     * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
-     *
-     * @param diskCache The disk cache to use.
-     * @return This builder.
-     */
-    public GlideBuilder setDiskCache(DiskCache diskCache) {
-        this.diskCache = diskCache;
-        return this;
+    if (memorySizeCalculator == null) {
+      memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
 
-    /**
-     * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
-     * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
-     *
-     * <p>
-     *     Any implementation must order requests based on their {@link com.bumptech.glide.Priority} for thumbnail
-     *     requests to work properly.
-     * </p>
-     *
-     * @see #setDiskCacheService(java.util.concurrent.ExecutorService)
-     * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
-     *
-     * @param service The ExecutorService to use.
-     * @return This builder.
-     */
-    public GlideBuilder setResizeService(ExecutorService service) {
-        this.sourceService = service;
-        return this;
+    if (bitmapPool == null) {
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+        int size = memorySizeCalculator.getBitmapPoolSize();
+        bitmapPool = new LruBitmapPool(size);
+      } else {
+        bitmapPool = new BitmapPoolAdapter();
+      }
     }
 
-    /**
-     * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
-     * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
-     *
-     * <p>
-     *     Any implementation must order requests based on their {@link com.bumptech.glide.Priority} for thumbnail
-     *     requests to work properly.
-     * </p>
-     *
-     * @see #setResizeService(java.util.concurrent.ExecutorService)
-     * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
-     *
-     * @param service The ExecutorService to use.
-     * @return This builder.
-     */
-    public GlideBuilder setDiskCacheService(ExecutorService service) {
-        this.diskCacheService = service;
-        return this;
+    if (arrayPool == null) {
+      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
     }
 
-    /**
-     * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all the default
-     * decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap}s they
-     * decode.
-     *
-     * <p>
-     *     Decode format is always a suggestion, not a requirement. See {@link com.bumptech.glide.load.DecodeFormat} for
-     *     more details.
-     * </p>
-     *
-     * <p>
-     *     If you instantiate and use a custom decoder, it will use
-     *     {@link com.bumptech.glide.load.DecodeFormat#DEFAULT} as its default.
-     * </p>
-     *
-     * @param decodeFormat The format to use.
-     * @return This builder.
-     */
-    public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
-        this.decodeFormat = decodeFormat;
-        return this;
+    if (memoryCache == null) {
+      memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());
     }
 
-    // For testing.
-    GlideBuilder setEngine(Engine engine) {
-        this.engine = engine;
-        return this;
+    if (diskCacheFactory == null) {
+      diskCacheFactory = new InternalCacheDiskCacheFactory(context);
     }
 
-    Glide createGlide() {
-        if (sourceService == null) {
-            final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());
-            sourceService = new FifoPriorityThreadPoolExecutor(cores);
-        }
-        if (diskCacheService == null) {
-            diskCacheService = new FifoPriorityThreadPoolExecutor(1);
-        }
-
-        MemorySizeCalculator calculator = new MemorySizeCalculator(context);
-        if (bitmapPool == null) {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-                bitmapPool = new LruBitmapPool(calculator.getBitmapPoolSize());
-            } else {
-                bitmapPool = new BitmapPoolAdapter();
-            }
-        }
-
-        if (memoryCache == null) {
-            memoryCache = new LruResourceCache(calculator.getMemoryCacheSize());
-        }
-
-        if (diskCache == null) {
-            File cacheDir = Glide.getPhotoCacheDir(context);
-            if (cacheDir != null) {
-                diskCache = DiskLruCacheWrapper.get(cacheDir, Glide.DEFAULT_DISK_CACHE_SIZE);
-            }
-            if (diskCache == null) {
-                diskCache = new DiskCacheAdapter();
-            }
-        }
-
-        if (engine == null) {
-            engine = new Engine(memoryCache, diskCache, diskCacheService, sourceService);
-        }
-
-        if (decodeFormat == null) {
-            decodeFormat = DecodeFormat.DEFAULT;
-        }
-
-        return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);
+    if (engine == null) {
+      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);
     }
-}
\ No newline at end of file
+
+    return new Glide(
+        engine,
+        memoryCache,
+        bitmapPool,
+        arrayPool,
+        context,
+        logLevel,
+        defaultRequestOptions.lock());
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
new file mode 100644
index 000000000..2753b6503
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -0,0 +1,84 @@
+package com.bumptech.glide;
+
+import android.annotation.TargetApi;
+import android.content.ComponentCallbacks2;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.res.Configuration;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import android.widget.ImageView;
+
+import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.ImageViewTargetFactory;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Global context for all loads in Glide containing and exposing the various registries and classes
+ * required to load resources.
+ */
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+public class GlideContext extends ContextWrapper implements ComponentCallbacks2 {
+  private final Handler mainHandler;
+  private final Registry registry;
+  private final ImageViewTargetFactory imageViewTargetFactory;
+  private final RequestOptions defaultRequestOptions;
+  private final Engine engine;
+  private final ComponentCallbacks2 componentCallbacks;
+  private final int logLevel;
+
+  public GlideContext(Context context, Registry registry,
+      ImageViewTargetFactory imageViewTargetFactory, RequestOptions defaultRequestOptions,
+      Engine engine, ComponentCallbacks2 componentCallbacks, int logLevel) {
+    super(context.getApplicationContext());
+    this.registry = registry;
+    this.imageViewTargetFactory = imageViewTargetFactory;
+    this.defaultRequestOptions = defaultRequestOptions;
+    this.engine = engine;
+    this.componentCallbacks = componentCallbacks;
+    this.logLevel = logLevel;
+
+    mainHandler = new Handler(Looper.getMainLooper());
+  }
+
+  public RequestOptions getDefaultRequestOptions() {
+    return defaultRequestOptions;
+  }
+
+  public <X> Target<X> buildImageViewTarget(ImageView imageView, Class<X> transcodeClass) {
+    return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
+  }
+
+  public Handler getMainHandler() {
+    return mainHandler;
+  }
+
+  public Engine getEngine() {
+    return engine;
+  }
+
+  public Registry getRegistry() {
+    return registry;
+  }
+
+  public int getLogLevel() {
+    return logLevel;
+  }
+
+  @Override
+  public void onTrimMemory(int level) {
+    componentCallbacks.onTrimMemory(level);
+  }
+
+  @Override
+  public void onConfigurationChanged(Configuration newConfig) {
+    componentCallbacks.onConfigurationChanged(newConfig);
+  }
+
+  @Override
+  public void onLowMemory() {
+    componentCallbacks.onLowMemory();
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index 6679c20bc..fba351ea0 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,316 +1,266 @@
 package com.bumptech.glide;
 
+import android.app.Activity;
+import android.app.Fragment;
+import android.support.annotation.Nullable;
+import android.support.v4.app.FragmentActivity;
 import android.widget.AbsListView;
 
-import com.bumptech.glide.request.animation.GlideAnimation;
 import com.bumptech.glide.request.target.BaseTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
 
 import java.util.List;
 import java.util.Queue;
 
 /**
- * Loads a few resources ahead in the direction of scrolling in any {@link AbsListView} so that images are in the memory
- * cache just before the corresponding view in created in the list. Gives the appearance of an infinitely large image
- * cache, depending on scrolling speed, cpu speed, and cache size.
+ * Loads a few resources ahead in the direction of scrolling in any {@link AbsListView} so that
+ * images are in the memory cache just before the corresponding view in created in the list. Gives
+ * the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and
+ * cache size.
  *
- * <p>
- * Must be set using {@link AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)}, or have its
- * corresponding methods called from another {@link android.widget.AbsListView.OnScrollListener} to function.
- * </p>
+ * <p> Must be put using
+ * {@link AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)}, or have its
+ * corresponding methods called from another {@link android.widget.AbsListView.OnScrollListener} to
+ * function. </p>
  *
  * @param <T> The type of the model being displayed in the list.
  */
 public class ListPreloader<T> implements AbsListView.OnScrollListener {
 
-    private final int maxPreload;
-    private final PreloadTargetQueue preloadTargetQueue;
-    private final PreloadModelProvider<T> preloadModelProvider;
-    private final PreloadSizeProvider<T> preloadDimensionProvider;
+  private final int maxPreload;
+  private final PreloadTargetQueue preloadTargetQueue;
+  private final RequestManager requestManager;
+  private final PreloadModelProvider<T> preloadModelProvider;
+  private final PreloadSizeProvider<T> preloadDimensionProvider;
 
-    private int lastEnd;
-    private int lastStart;
-    private int lastFirstVisible;
-    private int totalItemCount;
+  private int lastEnd;
+  private int lastStart;
+  private int lastFirstVisible;
+  private int totalItemCount;
 
-    private boolean isIncreasing = true;
+  private boolean isIncreasing = true;
 
-    /**
-     * An implementation of PreloadModelProvider should provide all the models that should be preloaded.
-     *
-     * @param <U> The type of the model being preloaded.
-     */
-    public interface PreloadModelProvider<U> {
-
-        /**
-         * Returns a non null list of all models that need to be loaded for the list to display adapter items in
-         * positions between {@code start} and {@code end}.
-         *
-         * <p>
-         * A list of any size can be returned so there can be multiple models per adapter position.
-         * </p>
-         *
-         * @param position The adapter position.
-         */
-        List<U> getPreloadItems(int position);
-
-        /**
-         * Returns a non null {@link com.bumptech.glide.GenericRequestBuilder} for a given item. Must exactly match
-         * the request used to load the resource in the list.
-         *
-         * <p>
-         * The target and context will be provided by the preloader.
-         * </p>
-         *
-         * @param item The model to load.
-         */
-        GenericRequestBuilder getPreloadRequestBuilder(U item);
-    }
+  /**
+   * An implementation of PreloadModelProvider should provide all the models that should be
+   * preloaded.
+   *
+   * @param <U> The type of the model being preloaded.
+   */
+  public interface PreloadModelProvider<U> {
 
     /**
-     * An implementation of PreloadSizeProvider should provide the size of the view in the list where the resources
-     * will be displayed.
+     * Returns a non null list of all models that need to be loaded for the list to display adapter
+     * items in positions between {@code start} and {@code end}.
      *
-     * @param <T> The type of the model the size should be provided for.
-     */
-    public interface PreloadSizeProvider<T> {
-
-        /**
-         * Returns the size of the view in the list where the resources will be displayed in pixels in the format
-         * [x, y], or {@code null} if no size is currently available.
-         *
-         * <p>
-         * Note - The dimensions returned here must precisely match those of the view in the list.
-         * </p>
-         *
-         * @param item A model
-         */
-        int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
-    }
-
-    /**
-     * Constructor for {@link com.bumptech.glide.ListPreloader} that requires users to subclass and override
-     * the {@link #getItems(int, int)} and {@link #getRequestBuilder(Object)} methods.
+     * <p> A list of any size can be returned so there can be multiple models per adapter position.
+     * </p>
      *
-     * @deprecated Use {@link #ListPreloader(com.bumptech.glide.ListPreloader.PreloadModelProvider,
-     * com.bumptech.glide.ListPreloader.PreloadSizeProvider, int)} instead. This constructor will be removed in Glide
-     * 4.0.
-     * @param maxPreload Maximum number of items to preload.
+     * @param position The adapter position.
      */
-    @Deprecated
-    public ListPreloader(int maxPreload) {
-        this.preloadModelProvider = new PreloadModelProvider<T>() {
-            @Override
-            public List<T> getPreloadItems(int position) {
-                return getItems(position, position + 1);
-            }
-
-            @Override
-            public GenericRequestBuilder getPreloadRequestBuilder(T item) {
-                return getRequestBuilder(item);
-            }
-        };
-        this.preloadDimensionProvider = new PreloadSizeProvider<T>() {
-
-            @Override
-            public int[] getPreloadSize(T item, int adapterPosition, int perItemPosition) {
-                return getDimensions(item);
-            }
-        };
-        this.maxPreload = maxPreload;
-        preloadTargetQueue = new PreloadTargetQueue(maxPreload + 1);
-
-    }
+    List<U> getPreloadItems(int position);
 
     /**
-     * Constructor for {@link com.bumptech.glide.ListPreloader} that accepts interfaces for providing the dimensions of
-     * images to preload, the list of models to preload for a given position, and the request to use to load images.
+     * Returns a non null {@link RequestBuilder} for a given item. Must exactly match the request
+     * used to load the resource in the list.
+     *
+     * <p> The target and context will be provided by the preloader. </p>
      *
-     * @param preloadModelProvider     Provides models to load and requests capable of loading them.
-     * @param preloadDimensionProvider Provides the dimensions of images to load.
-     * @param maxPreload               Maximum number of items to preload.
+     * @param item The model to load.
      */
-    public ListPreloader(PreloadModelProvider<T> preloadModelProvider,
-                         PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
-        this.preloadModelProvider = preloadModelProvider;
-        this.preloadDimensionProvider = preloadDimensionProvider;
-        this.maxPreload = maxPreload;
-        preloadTargetQueue = new PreloadTargetQueue(maxPreload + 1);
-    }
-
-    @Override
-    public void onScrollStateChanged(AbsListView absListView, int scrollState) {
-        // Do nothing.
-    }
+    RequestBuilder getPreloadRequestBuilder(U item);
+  }
 
-    @Override
-    public void onScroll(AbsListView absListView, int firstVisible, int visibleCount,
-                         int totalCount) {
-        totalItemCount = totalCount;
-        if (firstVisible > lastFirstVisible) {
-            preload(firstVisible + visibleCount, true);
-        } else if (firstVisible < lastFirstVisible) {
-            preload(firstVisible, false);
-        }
-        lastFirstVisible = firstVisible;
-    }
+  /**
+   * An implementation of PreloadSizeProvider should provide the size of the view in the list where
+   * the resources will be displayed.
+   *
+   * @param <T> The type of the model the size should be provided for.
+   */
+  public interface PreloadSizeProvider<T> {
 
     /**
-     * Returns the size of the view in the list where the resources will be displayed.
+     * Returns the size of the view in the list where the resources will be displayed in pixels in
+     * the format [x, y], or {@code null} if no size is currently available.
      *
-     * <p>
-     * Note - The size returned here must precisely match those of the view in the list.
+     * <p> Note - The dimensions returned here must precisely match those of the view in the list.
      * </p>
      *
-     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} instead. This method will be removed
-     * in Glide 4.0.
      * @param item A model
-     * @return The size of the view where the item will be displayed
      */
-    @Deprecated
-    protected int[] getDimensions(T item) {
-        throw new IllegalStateException("You must either provide a PreloadDimensionProvider or override "
-                                         + "getDimensions()");
+    @Nullable
+    int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link Activity}.
+   */
+  public ListPreloader(Activity activity, PreloadModelProvider<T> preloadModelProvider,
+      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+    this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link FragmentActivity}.
+   */
+  public ListPreloader(FragmentActivity fragmentActivity,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link Fragment}.
+   */
+  public ListPreloader(Fragment fragment,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
+   */
+  public ListPreloader(android.support.v4.app.Fragment fragment,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Constructor for {@link com.bumptech.glide.ListPreloader} that accepts interfaces for providing
+   * the dimensions of images to preload, the list of models to preload for a given position, and
+   * the request to use to load images.
+   *
+   * @param preloadModelProvider     Provides models to load and requests capable of loading them.
+   * @param preloadDimensionProvider Provides the dimensions of images to load.
+   * @param maxPreload               Maximum number of items to preload.
+   */
+  public ListPreloader(RequestManager requestManager, PreloadModelProvider<T> preloadModelProvider,
+      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+    this.requestManager = requestManager;
+    this.preloadModelProvider = preloadModelProvider;
+    this.preloadDimensionProvider = preloadDimensionProvider;
+    this.maxPreload = maxPreload;
+    preloadTargetQueue = new PreloadTargetQueue(maxPreload + 1);
+  }
+
+  @Override
+  public void onScrollStateChanged(AbsListView absListView, int scrollState) {
+    // Do nothing.
+  }
+
+  @Override
+  public void onScroll(AbsListView absListView, int firstVisible, int visibleCount,
+      int totalCount) {
+    totalItemCount = totalCount;
+    if (firstVisible > lastFirstVisible) {
+      preload(firstVisible + visibleCount, true);
+    } else if (firstVisible < lastFirstVisible) {
+      preload(firstVisible, false);
     }
+    lastFirstVisible = firstVisible;
+  }
 
-    /**
-     * Returns a non null list of all models that need to be loaded for the list to display adapter items
-     * between {@code start} and {@code end}.
-     *
-     * <p>
-     * A list of any size can be returned so there can be multiple models per adapter position.
-     * </p>
-     *
-     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadModelProvider} instead. This method will be
-     * removed in Glide 4.0.
-     * @param start The smallest adapter position. Will be {@code >= 0 && < adapter.getCount() &&
-     *              <= end}
-     * @param end   The largest adapter position. Will be {@code >= 0 && < adapter.getCount && >=
-     *              start}
-     */
-    @Deprecated
-    protected List<T> getItems(int start, int end) {
-        throw new IllegalStateException("You must either provide a PreloadModelProvider or override getItems()");
+  private void preload(int start, boolean increasing) {
+    if (isIncreasing != increasing) {
+      isIncreasing = increasing;
+      cancelAll();
     }
-
-    /**
-     * Returns a non null {@link com.bumptech.glide.GenericRequestBuilder} for a given item. Must exactly match the
-     * request used to load the resource in the list.
-     *
-     * <p>
-     * The target and context will be provided by the preloader.
-     * </p>
-     *
-     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadModelProvider} instead. This method will be
-     * removed in Glide 4.0.
-     * @param item The model to load.
-     */
-    @SuppressWarnings("rawtypes")
-    @Deprecated
-    protected GenericRequestBuilder getRequestBuilder(T item) {
-        throw new IllegalStateException("You must either provide a PreloadModelProvider, or override "
-                                         + "getRequestBuilder()");
+    preload(start, start + (increasing ? maxPreload : -maxPreload));
+  }
+
+  private void preload(int from, int to) {
+    int start;
+    int end;
+    if (from < to) {
+      start = Math.max(lastEnd, from);
+      end = to;
+    } else {
+      start = to;
+      end = Math.min(lastStart, from);
     }
-
-    private void preload(int start, boolean increasing) {
-        if (isIncreasing != increasing) {
-            isIncreasing = increasing;
-            cancelAll();
-        }
-        preload(start, start + (increasing ? maxPreload : -maxPreload));
+    end = Math.min(totalItemCount, end);
+    start = Math.min(totalItemCount, Math.max(0, start));
+
+    if (from < to) {
+      // Increasing
+      for (int i = start; i < end; i++) {
+        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, true);
+      }
+    } else {
+      // Decreasing
+      for (int i = end - 1; i >= start; i--) {
+        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, false);
+      }
     }
 
-    private void preload(int from, int to) {
-        int start;
-        int end;
-        if (from < to) {
-            start = Math.max(lastEnd, from);
-            end = to;
-        } else {
-            start = to;
-            end = Math.min(lastStart, from);
-        }
-        end = Math.min(totalItemCount, end);
-        start = Math.min(totalItemCount, Math.max(0, start));
-
-        if (from < to) {
-            // Increasing
-            for (int i = start; i < end; i++) {
-                preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, true);
-            }
-        } else {
-            // Decreasing
-            for (int i = end - 1; i >= start; i--) {
-                preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, false);
-            }
-        }
-
-        lastStart = start;
-        lastEnd = end;
+    lastStart = start;
+    lastEnd = end;
+  }
+
+  private void preloadAdapterPosition(List<T> items, int position, boolean isIncreasing) {
+    final int numItems = items.size();
+    if (isIncreasing) {
+      for (int i = 0; i < numItems; ++i) {
+        preloadItem(items.get(i), position, i);
+      }
+    } else {
+      for (int i = numItems - 1; i >= 0; --i) {
+        preloadItem(items.get(i), position, i);
+      }
     }
-
-    private void preloadAdapterPosition(List<T> items, int position, boolean isIncreasing) {
-        final int numItems = items.size();
-        if (isIncreasing) {
-            for (int i = 0; i < numItems; ++i) {
-                preloadItem(items.get(i), position, i);
-            }
-        } else {
-            for (int i = numItems - 1; i >= 0; --i) {
-                preloadItem(items.get(i), position, i);
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private void preloadItem(T item, int position, int i) {
-        final int[] dimensions = this.preloadDimensionProvider.getPreloadSize(item, position, i);
-        if (dimensions != null) {
-            GenericRequestBuilder preloadRequestBuilder = this.preloadModelProvider.getPreloadRequestBuilder(item);
-            preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
-        }
+  }
+
+  @SuppressWarnings("unchecked")
+  private void preloadItem(T item, int position, int i) {
+    final int[] dimensions = this.preloadDimensionProvider.getPreloadSize(item, position, i);
+    if (dimensions != null) {
+      RequestBuilder preloadRequestBuilder =
+          this.preloadModelProvider.getPreloadRequestBuilder(item);
+      preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
     }
+  }
 
-    private void cancelAll() {
-        for (int i = 0; i < maxPreload; i++) {
-            Glide.clear(preloadTargetQueue.next(0, 0));
-        }
+  private void cancelAll() {
+    for (int i = 0; i < maxPreload; i++) {
+      requestManager.clear(preloadTargetQueue.next(0, 0));
     }
+  }
 
-    private static final class PreloadTargetQueue {
-        private final Queue<PreloadTarget> queue;
+  private static final class PreloadTargetQueue {
+    private final Queue<PreloadTarget> queue;
 
-        public PreloadTargetQueue(int size) {
-            queue = Util.createQueue(size);
+    public PreloadTargetQueue(int size) {
+      queue = Util.createQueue(size);
 
-            for (int i = 0; i < size; i++) {
-                queue.offer(new PreloadTarget());
-            }
-        }
+      for (int i = 0; i < size; i++) {
+        queue.offer(new PreloadTarget());
+      }
+    }
 
-        public PreloadTarget next(int width, int height) {
-            final PreloadTarget result = queue.poll();
-            queue.offer(result);
-            result.photoWidth = width;
-            result.photoHeight = height;
-            return result;
-        }
+    public PreloadTarget next(int width, int height) {
+      final PreloadTarget result = queue.poll();
+      queue.offer(result);
+      result.photoWidth = width;
+      result.photoHeight = height;
+      return result;
     }
+  }
 
-    private static class PreloadTarget extends BaseTarget<Object> {
-        private int photoHeight;
-        private int photoWidth;
+  private static class PreloadTarget extends BaseTarget<Object> {
+    private int photoHeight;
+    private int photoWidth;
 
-        @Override
-        public void onResourceReady(Object resource,
-                                    GlideAnimation<? super Object> glideAnimation) {
-            // Do nothing.
-        }
+    @Override
+    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+      // Do nothing.
+    }
 
-        @Override
-        public void getSize(SizeReadyCallback cb) {
-            cb.onSizeReady(photoWidth, photoHeight);
-        }
+    @Override
+    public void getSize(SizeReadyCallback cb) {
+      cb.onSizeReady(photoWidth, photoHeight);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/MemoryCategory.java b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
index 08127f468..a5781f62d 100644
--- a/library/src/main/java/com/bumptech/glide/MemoryCategory.java
+++ b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
@@ -4,30 +4,31 @@
  * An enum for dynamically modifying the amount of memory Glide is able to use.
  */
 public enum MemoryCategory {
-    /**
-     * Tells Glide's memory cache and bitmap pool to use at most half of their initial maximum size.
-     */
-    LOW(0.5f),
-    /**
-     * Tells Glide's memory cache and bitmap pool to use at most their initial maximum size.
-     */
-    NORMAL(1f),
-    /**
-     * Tells Glide's memory cache and bitmap pool to use at most one and a half times their initial maximum size.
-     */
-    HIGH(1.5f);
+  /**
+   * Tells Glide's memory cache and bitmap pool to use at most half of their initial maximum size.
+   */
+  LOW(0.5f),
+  /**
+   * Tells Glide's memory cache and bitmap pool to use at most their initial maximum size.
+   */
+  NORMAL(1f),
+  /**
+   * Tells Glide's memory cache and bitmap pool to use at most one and a half times their initial
+   * maximum size.
+   */
+  HIGH(1.5f);
 
-    private float multiplier;
+  private float multiplier;
 
-    MemoryCategory(float multiplier) {
-        this.multiplier = multiplier;
-    }
+  MemoryCategory(float multiplier) {
+    this.multiplier = multiplier;
+  }
 
-    /**
-     * Returns the multiplier that should be applied to the initial maximum size of Glide's memory cache and bitmap
-     * pool.
-     */
-    public float getMultiplier() {
-        return multiplier;
-    }
+  /**
+   * Returns the multiplier that should be applied to the initial maximum size of Glide's memory
+   * cache and bitmap pool.
+   */
+  public float getMultiplier() {
+    return multiplier;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Priority.java b/library/src/main/java/com/bumptech/glide/Priority.java
index 316eae17f..03c7777f9 100644
--- a/library/src/main/java/com/bumptech/glide/Priority.java
+++ b/library/src/main/java/com/bumptech/glide/Priority.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide;
 
 /**
- * Priorities for completing loads. If more than one load is queued at a time, the load with the higher priority will be
- * started first. Priorities are considered best effort, there are no guarantees about the order in which loads will
- * start or finish.
+ * Priorities for completing loads. If more than one load is queued at a time, the load with the
+ * higher priority will be started first. Priorities are considered best effort, there are no
+ * guarantees about the order in which loads will start or finish.
  */
 public enum Priority {
-    IMMEDIATE,
-    HIGH,
-    NORMAL,
-    LOW, priority,
+  IMMEDIATE,
+  HIGH,
+  NORMAL,
+  LOW,
 }
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
new file mode 100644
index 000000000..dea54a6b9
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -0,0 +1,267 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.v4.util.Pools.Pool;
+
+import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.data.DataRewinder;
+import com.bumptech.glide.load.data.DataRewinderRegistry;
+import com.bumptech.glide.load.engine.DecodePath;
+import com.bumptech.glide.load.engine.LoadPath;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.ModelLoaderRegistry;
+import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
+import com.bumptech.glide.load.resource.transcode.TranscoderRegistry;
+import com.bumptech.glide.provider.EncoderRegistry;
+import com.bumptech.glide.provider.LoadPathCache;
+import com.bumptech.glide.provider.ModelToResourceClassCache;
+import com.bumptech.glide.provider.ResourceDecoderRegistry;
+import com.bumptech.glide.provider.ResourceEncoderRegistry;
+import com.bumptech.glide.util.pool.FactoryPools;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Manages component registration.
+ */
+public class Registry {
+  private final ModelLoaderRegistry modelLoaderRegistry;
+  private final EncoderRegistry encoderRegistry;
+  private final ResourceDecoderRegistry decoderRegistry;
+  private final ResourceEncoderRegistry resourceEncoderRegistry;
+  private final DataRewinderRegistry dataRewinderRegistry;
+  private final TranscoderRegistry transcoderRegistry;
+
+  private final ModelToResourceClassCache modelToResourceClassCache =
+      new ModelToResourceClassCache();
+  private final LoadPathCache loadPathCache = new LoadPathCache();
+  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
+
+  public Registry(Context context) {
+    this.modelLoaderRegistry =
+        new ModelLoaderRegistry(context.getApplicationContext(), exceptionListPool);
+    this.encoderRegistry = new EncoderRegistry();
+    this.decoderRegistry = new ResourceDecoderRegistry();
+    this.resourceEncoderRegistry = new ResourceEncoderRegistry();
+    this.dataRewinderRegistry = new DataRewinderRegistry();
+    this.transcoderRegistry = new TranscoderRegistry();
+  }
+
+  public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
+    encoderRegistry.add(dataClass, encoder);
+    return this;
+  }
+
+  public <Data, TResource> Registry append(Class<Data> dataClass, Class<TResource> resourceClass,
+      ResourceDecoder<Data, TResource> decoder) {
+    decoderRegistry.append(decoder, dataClass, resourceClass);
+    return this;
+  }
+
+  public <Data, TResource> Registry prepend(Class<Data> dataClass, Class<TResource> resourceClass,
+      ResourceDecoder<Data, TResource> decoder) {
+    decoderRegistry.prepend(decoder, dataClass, resourceClass);
+    return this;
+  }
+
+  public <TResource> Registry register(Class<TResource> resourceClass,
+      ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.add(resourceClass, encoder);
+    return this;
+  }
+
+  public Registry register(DataRewinder.Factory factory) {
+    dataRewinderRegistry.register(factory);
+    return this;
+  }
+
+  public <TResource, Transcode> Registry register(Class<TResource> resourceClass,
+      Class<Transcode> transcodeClass, ResourceTranscoder<TResource, Transcode> transcoder) {
+    transcoderRegistry.register(resourceClass, transcodeClass, transcoder);
+    return this;
+  }
+
+  /**
+   * Use the given factory to build a {@link com.bumptech.glide.load.model.ModelLoader} for models
+   * of the given class. Generally the best use of this method is to replace one of the default
+   * factories or add an implementation for other similar low level models. Any factory replaced by
+   * the given factory will have its {@link ModelLoaderFactory#teardown()}} method called.
+   *
+   * <p> Note - If a factory already exists for the given class, it will be replaced. If that
+   * factory is not being used for any other model class, {@link ModelLoaderFactory#teardown()} will
+   * be called. </p>
+   *
+   * <p> Note - The factory must not be an anonymous inner class of an Activity or another object
+   * that cannot be retained statically. </p>
+   *
+   * @param modelClass The model class.
+   * @param dataClass  the data class.
+   */
+  public <Model, Data> Registry append(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory) {
+    modelLoaderRegistry.append(modelClass, dataClass, factory);
+    return this;
+  }
+
+  public <Model, Data> Registry prepend(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory) {
+    modelLoaderRegistry.prepend(modelClass, dataClass, factory);
+    return this;
+  }
+
+  public <Model, Data> Registry replace(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory) {
+    modelLoaderRegistry.replace(modelClass, dataClass, factory);
+    return this;
+  }
+
+  public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> getLoadPath(
+      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+    LoadPath<Data, TResource, Transcode> result =
+        loadPathCache.get(dataClass, resourceClass, transcodeClass);
+    if (result == null && !loadPathCache.contains(dataClass, resourceClass, transcodeClass)) {
+      List<DecodePath<Data, TResource, Transcode>> decodePaths =
+          getDecodePaths(dataClass, resourceClass, transcodeClass);
+      // It's possible there is no way to decode or transcode to the desired types from a given
+      // data class.
+      if (decodePaths.isEmpty()) {
+        result = null;
+      } else {
+        result = new LoadPath<>(dataClass, resourceClass, transcodeClass, decodePaths,
+            exceptionListPool);
+      }
+      loadPathCache.put(dataClass, resourceClass, transcodeClass, result);
+    }
+    return result;
+  }
+
+  private <Data, TResource, Transcode> List<DecodePath<Data, TResource, Transcode>> getDecodePaths(
+      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+
+    List<DecodePath<Data, TResource, Transcode>> decodePaths = new ArrayList<>();
+    List<Class<TResource>> registeredResourceClasses =
+        decoderRegistry.getResourceClasses(dataClass, resourceClass);
+
+    for (Class<TResource> registeredResourceClass : registeredResourceClasses) {
+      List<Class<Transcode>> registeredTranscodeClasses =
+          transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);
+
+      for (Class<Transcode> registeredTranscodeClass : registeredTranscodeClasses) {
+
+        List<ResourceDecoder<Data, TResource>> decoders =
+            decoderRegistry.getDecoders(dataClass, registeredResourceClass);
+        ResourceTranscoder<TResource, Transcode> transcoder =
+            transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);
+        decodePaths.add(new DecodePath<>(dataClass, registeredResourceClass,
+            registeredTranscodeClass, decoders, transcoder, exceptionListPool));
+      }
+    }
+    return decodePaths;
+  }
+
+  public <Model, TResource, Transcode> List<Class<?>> getRegisteredResourceClasses(
+      Class<Model> modelClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+    List<Class<?>> result = modelToResourceClassCache.get(modelClass, resourceClass);
+
+    if (result == null) {
+      result = new ArrayList<>();
+      List<Class<?>> dataClasses = modelLoaderRegistry.getDataClasses(modelClass);
+      for (Class<?> dataClass : dataClasses) {
+        List<? extends Class<?>> registeredResourceClasses =
+            decoderRegistry.getResourceClasses(dataClass, resourceClass);
+        for (Class<?> registeredResourceClass : registeredResourceClasses) {
+          List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry
+              .getTranscodeClasses(registeredResourceClass, transcodeClass);
+          if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {
+              result.add(registeredResourceClass);
+          }
+        }
+      }
+      modelToResourceClassCache.put(modelClass, resourceClass,
+          Collections.unmodifiableList(result));
+    }
+
+    return result;
+  }
+
+  public boolean isResourceEncoderAvailable(Resource<?> resource) {
+    return resourceEncoderRegistry.get(resource.getResourceClass()) != null;
+  }
+
+  public <X> ResourceEncoder<X> getResultEncoder(Resource<X> resource)
+      throws NoResultEncoderAvailableException {
+    ResourceEncoder<X> resourceEncoder = resourceEncoderRegistry.get(resource.getResourceClass());
+    if (resourceEncoder != null) {
+      return resourceEncoder;
+    }
+    throw new NoResultEncoderAvailableException(resource.getResourceClass());
+  }
+
+  @SuppressWarnings("unchecked")
+  public <X> Encoder<X> getSourceEncoder(X data) throws NoSourceEncoderAvailableException {
+    Encoder<X> encoder = encoderRegistry.getEncoder((Class<X>) data.getClass());
+    if (encoder != null) {
+      return encoder;
+    }
+    throw new NoSourceEncoderAvailableException(data.getClass());
+  }
+
+  public <X> DataRewinder<X> getRewinder(X data) {
+    return dataRewinderRegistry.build(data);
+  }
+
+  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(Model model) {
+    List<ModelLoader<Model, ?>> result = modelLoaderRegistry.getModelLoaders(model);
+    if (result.isEmpty()) {
+      throw new NoModelLoaderAvailableException(model);
+    }
+    return result;
+  }
+
+  /**
+   * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
+   * model class.
+   */
+  public static class NoModelLoaderAvailableException extends MissingComponentException {
+    public NoModelLoaderAvailableException(Object model) {
+      super("Failed to find any ModelLoaders for model: " + model);
+    }
+
+    public NoModelLoaderAvailableException(Class modelClass, Class dataClass) {
+      super("Failed to find any ModelLoaders for model: " + modelClass + " and data: " + dataClass);
+    }
+  }
+
+  /**
+   * Thrown when no {@link ResourceEncoder} is registered for a given resource class.
+   */
+  public static class NoResultEncoderAvailableException extends MissingComponentException {
+    public NoResultEncoderAvailableException(Class<?> resourceClass) {
+      super("Failed to find result encoder for resource class: " + resourceClass);
+    }
+  }
+
+  /**
+   * Thrown when no {@link Encoder} is registered for a given data class.
+   */
+  public static class NoSourceEncoderAvailableException extends MissingComponentException {
+    public NoSourceEncoderAvailableException(Class<?> dataClass) {
+      super("Failed to find source encoder for data class: " + dataClass);
+    }
+  }
+
+  /**
+   * Thrown when some necessary component is missing for a load.
+   */
+  public static class MissingComponentException extends RuntimeException {
+    public MissingComponentException(String message) {
+      super(message);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
new file mode 100644
index 000000000..ba584647f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -0,0 +1,632 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.request.RequestOptions.signatureOf;
+
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.widget.ImageView;
+
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestCoordinator;
+import com.bumptech.glide.request.RequestFutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.SingleRequest;
+import com.bumptech.glide.request.ThumbnailRequestCoordinator;
+import com.bumptech.glide.request.target.PreloadTarget;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.signature.ApplicationVersionSignature;
+import com.bumptech.glide.signature.StringSignature;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+
+import java.io.File;
+import java.net.URL;
+import java.util.UUID;
+
+/**
+ * A generic class that can handle setting options and staring loads for generic resource types.
+ *
+ * @param <TranscodeType> The type of resource that will be delivered to the
+ * {@link com.bumptech.glide.request.target.Target}.
+ */
+public class RequestBuilder<TranscodeType> implements Cloneable {
+  private static final TransitionOptions<?, ?> DEFAULT_ANIMATION_OPTIONS =
+      new GenericTransitionOptions<Object>();
+  private static final BaseRequestOptions DOWNLOAD_ONLY_OPTIONS =
+      new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
+          .skipMemoryCache(true);
+
+  private final GlideContext context;
+  private final RequestManager requestManager;
+  private final Class<TranscodeType> transcodeClass;
+  private final BaseRequestOptions<?> defaultRequestOptions;
+
+  @NonNull private BaseRequestOptions<?> requestOptions;
+  @SuppressWarnings("unchecked")
+  private TransitionOptions<?, ? super TranscodeType> transitionOptions =
+      (TransitionOptions<?, ? super TranscodeType>) DEFAULT_ANIMATION_OPTIONS;
+
+  @Nullable private Object model;
+  // model may occasionally be null, so to enforce that load() was called, put a boolean rather
+  // than relying on model not to be null.
+  @Nullable private RequestListener<TranscodeType> requestListener;
+  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
+  @Nullable private Float thumbSizeMultiplier;
+  private boolean isModelSet;
+  private boolean isThumbnailBuilt;
+
+  RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+    this(other.context, other.requestManager, transcodeClass);
+    model = other.model;
+    isModelSet = other.isModelSet;
+    requestOptions = other.requestOptions;
+  }
+
+  RequestBuilder(GlideContext context, RequestManager requestManager,
+      Class<TranscodeType> transcodeClass) {
+    this.requestManager = requestManager;
+    this.context = Preconditions.checkNotNull(context);
+    this.transcodeClass = transcodeClass;
+
+    this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
+    this.requestOptions = defaultRequestOptions;
+  }
+
+  public RequestBuilder<TranscodeType> apply(BaseRequestOptions requestOptions) {
+    Preconditions.checkNotNull(requestOptions);
+    BaseRequestOptions<?> toMutate = defaultRequestOptions == this.requestOptions
+        ? this.requestOptions.clone() : this.requestOptions;
+    this.requestOptions = toMutate.apply(requestOptions);
+    return this;
+  }
+
+  public RequestBuilder<TranscodeType> transition(
+      TransitionOptions<?, ? super TranscodeType> transitionOptions) {
+    this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
+    return this;
+  }
+
+  /**
+   * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single
+   * instance of an exception handler per type of request (usually activity/fragment) rather than
+   * pass one in per request to avoid some redundant object allocation.
+   *
+   * @param requestListener The request listener to use.
+   * @return This request builder.
+   */
+  @SuppressWarnings("unchecked")
+  public RequestBuilder<TranscodeType> listener(
+      @Nullable RequestListener<TranscodeType> requestListener) {
+    this.requestListener = requestListener;
+
+    return this;
+  }
+
+  /**
+   * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
+   * this request. Best used for loading thumbnail resources that are smaller and will be loaded
+   * more quickly than the full size resource. There are no guarantees about the order in which the
+   * requests will actually finish. However, if the thumb request completes after the full request,
+   * the thumb resource will never replace the full resource.
+   *
+   * @param thumbnailRequest The request to use to load the thumbnail.
+   * @return This request builder.
+   * @see #thumbnail(float)
+   *
+   * <p> Recursive calls to thumbnail are supported. </p>
+   */
+  @SuppressWarnings("unchecked")
+  public RequestBuilder<TranscodeType> thumbnail(
+      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
+    this.thumbnailBuilder = thumbnailRequest;
+
+    return this;
+  }
+
+  /**
+   * Loads a resource in an identical manner to this request except with the dimensions of the
+   * target multiplied by the given size multiplier. If the thumbnail load completes before the
+   * fullsize load, the thumbnail will be shown. If the thumbnail load completes after the fullsize
+   * load, the thumbnail will not be shown.
+   *
+   * <p> Note - The thumbnail resource will be smaller than the size requested so the target (or
+   * {@link ImageView}) must be able to scale the thumbnail appropriately. See
+   * {@link android.widget.ImageView.ScaleType}. </p>
+   *
+   * <p> Almost all options will be copied from the original load, including the {@link
+   * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
+   * and {@link com.bumptech.glide.load.Transformation}s. However,
+   * {@link com.bumptech.glide.request.BaseRequestOptions#placeholder(int)} and
+   * {@link com.bumptech.glide.request.BaseRequestOptions#error(int)}, and
+   * {@link #listener(RequestListener)} will only be used on the fullsize load and will not be
+   * copied for the thumbnail load. </p>
+   *
+   * <p> Recursive calls to thumbnail are supported. </p>
+   *
+   * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
+   *                       the thumbnail.
+   * @return This request builder.
+   */
+  @SuppressWarnings("unchecked")
+  public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.thumbSizeMultiplier = sizeMultiplier;
+
+    return this;
+  }
+
+  /**
+   * Sets the specific model to load data for.
+   *
+   * <p> This method must be called at least once before
+   * {@link #into(com.bumptech.glide.request.target.Target)} is called. </p>
+   *
+   * @param model The model to load data for, or null.
+   * @return This request builder.
+   */
+  @SuppressWarnings("unchecked")
+  public RequestBuilder<TranscodeType> load(@Nullable Object model) {
+    return loadGeneric(model);
+  }
+
+  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
+    this.model = model;
+    isModelSet = true;
+    return this;
+  }
+
+  /**
+   * Returns a request builder to load the given {@link java.lang.String}. signature.
+   *
+   * <p> Note - this method caches data using only the given String as the cache key. If the data is
+   * a Uri outside of your control, or you otherwise expect the data represented by the given String
+   * to change without the String identifier changing, Consider using
+   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * mixin a signature you create that identifies the data currently at the given String that will
+   * invalidate the cache if that data changes. Alternatively, using
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * appropriate.
+   * </p>
+   *
+   * @see #load(Object)
+   *
+   * @param string A file path, or a uri or url handled by
+   * {@link com.bumptech.glide.load.model.UriLoader}.
+   */
+  public RequestBuilder<TranscodeType> load(@Nullable String string) {
+    return loadGeneric(string);
+  }
+
+  /**
+   * Returns a request builder to load the given {@link Uri}.
+   *
+   * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
+   * represented by Uris from some content providers may change without the Uri changing, which
+   * means using this method can lead to displaying stale data. Consider using
+   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * mixin a signature you create based on the data at the given Uri that will invalidate the cache
+   * if that data changes. Alternatively, using
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * appropriate. </p>
+   *
+   * @see #load(Object)
+   *
+   * @param uri The Uri representing the image. Must be of a type handled by
+   * {@link com.bumptech.glide.load.model.UriLoader}.
+   */
+  public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
+    return loadGeneric(uri);
+  }
+
+  /**
+   * Returns a request builder to load the given {@link File}.
+   *
+   * <p> Note - this method caches data for Files using only the file path itself as the cache key.
+   * The data in the File can change so using this method can lead to displaying stale data. If you
+   * expect the data in the File to change, Consider using
+   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)}
+   * to mixin a signature you create that identifies the data currently in the File that will
+   * invalidate the cache if that data changes. Alternatively, using
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * appropriate.
+   * </p>
+   *
+   * @see #load(Object)
+   *
+   * @param file The File containing the image
+   */
+  public RequestBuilder<TranscodeType> load(@Nullable File file) {
+    return loadGeneric(file);
+  }
+
+  /**
+   * Returns a request builder to load the given resource id. Returns a request builder that uses
+   * the {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
+   * {@link Integer} to load the image represented by the given {@link Integer} resource id.
+   * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
+   *
+   * <p> By default this method adds a version code based signature to the cache key used to cache
+   * this resource in Glide. This signature is sufficient to guarantee that end users will see the
+   * most up to date versions of your Drawables, but during development if you do not increment your
+   * version code before each install and you replace a Drawable with different data without
+   * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
+   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
+   * {@link BaseRequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+   * during development, and re-enabling the default
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
+   *
+   * @see #load(Integer)
+   * @see com.bumptech.glide.signature.ApplicationVersionSignature
+   */
+  public RequestBuilder<TranscodeType> load(@Nullable Integer resourceId) {
+    return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
+  }
+
+  /**
+   * Returns a request builder to load the given {@link URL}.
+   *
+   * @param url The URL representing the image.
+   * @see #load(Object)
+   * @deprecated The {@link java.net.URL} class has <a href="http://goo.gl/c4hHNu">a number of
+   * performance problems</a> and should generally be avoided when possible. Prefer
+   * {@link #load(android.net.Uri)} or {@link #load(String)}.
+   */
+  @Deprecated
+  public RequestBuilder<TranscodeType> load(@Nullable URL url) {
+    return loadGeneric(url);
+  }
+
+  /**
+   * Returns a request to load the given byte array.
+   *
+   * <p> Note - by default loads for bytes are not cached in either the memory or the disk cache.
+   * </p>
+   *
+   * @param model the data to load.
+   * @see #load(Object)
+   */
+  public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
+    return loadGeneric(model).apply(signatureOf(new StringSignature(UUID.randomUUID().toString()))
+        .diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true /*skipMemoryCache*/));
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders. </p>
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  public RequestBuilder<TranscodeType> clone() {
+    try {
+      RequestBuilder<TranscodeType> result = (RequestBuilder<TranscodeType>) super.clone();
+      result.requestOptions = result.requestOptions.clone();
+      result.transitionOptions = result.transitionOptions.clone();
+      return result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /**
+   * Set the target the resource will be loaded into.
+   *
+   * @param target The target to load the resource into.
+   * @return The given target.
+   * @see RequestManager#clear(Target)
+   */
+  public <Y extends Target<TranscodeType>> Y into(Y target) {
+    Util.assertMainThread();
+    if (target == null) {
+      throw new IllegalArgumentException("You must pass in a non null Target");
+    }
+    if (!isModelSet) {
+      throw new IllegalArgumentException("You must call #load() before calling #into()");
+    }
+
+    Request previous = target.getRequest();
+
+    if (previous != null) {
+      requestManager.clear(target);
+    }
+
+    requestOptions.lock();
+    Request request = buildRequest(target);
+    target.setRequest(request);
+    requestManager.track(target, request);
+
+    return target;
+  }
+
+  /**
+   * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
+   * the view, and frees any resources Glide may have previously loaded into the view so they may be
+   * reused.
+   *
+   * @see RequestManager#clear(Target)
+   *
+   * @param view The view to cancel previous loads for and load the new resource into.
+   * @return The
+   * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
+   */
+  public Target<TranscodeType> into(ImageView view) {
+    Util.assertMainThread();
+    if (view == null) {
+      throw new IllegalArgumentException("You must pass in a non null View");
+    }
+
+    if (!requestOptions.isTransformationSet()
+        && requestOptions.isTransformationAllowed()
+        && view.getScaleType() != null) {
+      if (requestOptions.isLocked()) {
+        requestOptions = requestOptions.clone();
+      }
+      switch (view.getScaleType()) {
+        case CENTER_CROP:
+          requestOptions.optionalCenterCrop(context);
+          break;
+        case FIT_CENTER:
+        case FIT_START:
+        case FIT_END:
+          requestOptions.optionalFitCenter(context);
+          break;
+        //$CASES-OMITTED$
+        default:
+          // Do nothing.
+      }
+    }
+
+    return into(context.buildImageViewTarget(view, transcodeClass));
+  }
+
+  /**
+   * Returns a future that can be used to do a blocking get on a background thread.
+   *
+   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *               overridden by
+   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               previously called.
+   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *               overridden by
+   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               previously called).
+   * @see RequestManager#clear(Target)
+   *
+   * @deprecated Use {@link #submit(int, int)} instead.
+   */
+  @Deprecated
+  public FutureTarget<TranscodeType> into(int width, int height) {
+    return submit(width, height);
+  }
+
+  /**
+   * Returns a future that can be used to do a blocking get on a background thread.
+   *
+   * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
+   * since the width and height will be overriden by values passed to {@link
+   * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
+   * with override values are applied, or whenever you want to retrieve the image in its original
+   * size.
+   *
+   * @see #submit(int, int)
+   * @see #into(Target)
+   */
+  public FutureTarget<TranscodeType> submit() {
+    return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+  }
+
+  /**
+   * Returns a future that can be used to do a blocking get on a background thread.
+   *
+   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *               overridden by
+   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               previously called.
+   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *               overridden by
+   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               previously called).
+   */
+  public FutureTarget<TranscodeType> submit(int width, int height) {
+    final RequestFutureTarget<TranscodeType> target =
+        new RequestFutureTarget<>(context.getMainHandler(), width, height);
+
+    if (Util.isOnBackgroundThread()) {
+      context.getMainHandler().post(new Runnable() {
+        @Override
+        public void run() {
+          if (!target.isCancelled()) {
+            into(target);
+          }
+        }
+      });
+    } else {
+      into(target);
+    }
+
+    return target;
+  }
+
+  /**
+   * Preloads the resource into the cache using the given width and height.
+   *
+   * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
+   * future are available quickly. </p>
+   *
+   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *               overridden by
+   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               previously called.
+   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *               overridden by
+   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               previously called).
+   * @return A {@link Target} that can be used to cancel the load via
+   * {@link RequestManager#clear(Target)}.
+   * @see com.bumptech.glide.ListPreloader
+   */
+  public Target<TranscodeType> preload(int width, int height) {
+    final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
+    return into(target);
+  }
+
+  /**
+   * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and
+   * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
+   * the width and height.
+   *
+   * @return A {@link Target} that can be used to cancel the load via
+   * {@link RequestManager#clear(Target)}
+   * @see #preload(int, int)
+   */
+  public Target<TranscodeType> preload() {
+    return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+  }
+
+  /**
+   * Loads the original unmodified data into the cache and calls the given Target with the cache
+   * File.
+   *
+   * @param target The Target that will receive the cache File when the load completes
+   * @param <Y>    The type of Target.
+   * @return The given Target.
+   *
+   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
+   */
+  @Deprecated
+  public <Y extends Target<File>> Y downloadOnly(Y target) {
+    return getDownloadOnlyRequest().into(target);
+  }
+
+  /**
+   * Loads the original unmodified data into the cache and returns a
+   * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
+   * data.
+   *
+   * @param width  The width in pixels to use to fetch the data.
+   * @param height The height in pixels to use to fetch the data.
+   * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
+   * containing the data.
+   *
+   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}.
+   */
+  @Deprecated
+  public FutureTarget<File> downloadOnly(int width, int height) {
+    return getDownloadOnlyRequest().into(width, height);
+  }
+
+  private RequestBuilder<File> getDownloadOnlyRequest() {
+    return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  private Priority getThumbnailPriority(Priority current) {
+    switch (current) {
+      case LOW:
+        return Priority.NORMAL;
+      case NORMAL:
+        return Priority.HIGH;
+      case HIGH:
+      case IMMEDIATE:
+        return Priority.IMMEDIATE;
+      default:
+        throw new IllegalArgumentException("unknown priority: " + requestOptions.getPriority());
+    }
+  }
+
+  private Request buildRequest(Target<TranscodeType> target) {
+    return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),
+        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight());
+  }
+
+  private Request buildRequestRecursive(Target<TranscodeType> target,
+      @Nullable ThumbnailRequestCoordinator parentCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority, int overrideWidth, int overrideHeight) {
+    if (thumbnailBuilder != null) {
+      // Recursive case: contains a potentially recursive thumbnail request builder.
+      if (isThumbnailBuilt) {
+        throw new IllegalStateException("You cannot use a request as both the main request and a "
+            + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
+      }
+
+      TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
+          thumbnailBuilder.transitionOptions;
+      if (DEFAULT_ANIMATION_OPTIONS.equals(thumbTransitionOptions)) {
+        thumbTransitionOptions = transitionOptions;
+      }
+
+      Priority thumbPriority = thumbnailBuilder.requestOptions.isPrioritySet()
+          ? thumbnailBuilder.requestOptions.getPriority() : getThumbnailPriority(priority);
+
+      int thumbOverrideWidth = thumbnailBuilder.requestOptions.getOverrideWidth();
+      int thumbOverrideHeight = thumbnailBuilder.requestOptions.getOverrideHeight();
+      if (Util.isValidDimensions(overrideWidth, overrideHeight)
+          && !thumbnailBuilder.requestOptions.isValidOverride()) {
+        thumbOverrideWidth = requestOptions.getOverrideWidth();
+        thumbOverrideHeight = requestOptions.getOverrideHeight();
+      }
+
+      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+      Request fullRequest = obtainRequest(target, requestOptions, coordinator,
+          transitionOptions, priority, overrideWidth, overrideHeight);
+      isThumbnailBuilt = true;
+      // Recursively generate thumbnail requests.
+      Request thumbRequest = thumbnailBuilder.buildRequestRecursive(target, coordinator,
+          thumbTransitionOptions, thumbPriority, thumbOverrideWidth, thumbOverrideHeight);
+      isThumbnailBuilt = false;
+      coordinator.setRequests(fullRequest, thumbRequest);
+      return coordinator;
+    } else if (thumbSizeMultiplier != null) {
+      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
+      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+      Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
+          priority, overrideWidth, overrideHeight);
+      BaseRequestOptions<?> thumbnailOptions = requestOptions.clone()
+          .sizeMultiplier(thumbSizeMultiplier);
+
+      Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
+          transitionOptions, getThumbnailPriority(priority), overrideWidth, overrideHeight);
+
+      coordinator.setRequests(fullRequest, thumbnailRequest);
+      return coordinator;
+    } else {
+      // Base case: no thumbnail.
+      return obtainRequest(target, requestOptions, parentCoordinator, transitionOptions, priority,
+          overrideWidth, overrideHeight);
+    }
+  }
+
+  private Request obtainRequest(Target<TranscodeType> target,
+      BaseRequestOptions<?> requestOptions, RequestCoordinator requestCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
+      int overrideWidth, int overrideHeight) {
+    requestOptions.lock();
+
+    return SingleRequest.obtain(
+        context,
+        model,
+        transcodeClass,
+        requestOptions,
+        overrideWidth,
+        overrideHeight,
+        priority,
+        target,
+        requestListener,
+        requestCoordinator,
+        context.getEngine(),
+        transitionOptions.getTransitionFactory());
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 071a91e76..40078f8b7 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -1,37 +1,44 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
+
 import android.content.Context;
-import android.net.Uri;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.os.Looper;
-import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
 
-import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.file_descriptor.FileDescriptorModelLoader;
-import com.bumptech.glide.load.model.stream.MediaStoreStreamLoader;
-import com.bumptech.glide.load.model.stream.StreamByteArrayLoader;
-import com.bumptech.glide.load.model.stream.StreamModelLoader;
+import com.bumptech.glide.load.resource.bitmap.BitmapTransitionOptions;
+import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.LifecycleListener;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
-import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.MediaStoreSignature;
-import com.bumptech.glide.signature.StringSignature;
+import com.bumptech.glide.manager.TargetTracker;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
+import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
 
 import java.io.File;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.UUID;
 
 /**
- * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity lifecycle events to
- * intelligently stop, start, and restart requests. Retrieve either by instantiating a new object, or to take advantage
- * built in Activity and Fragment lifecycle handling, use the static Glide.load methods with your Fragment or Activity.
+ * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity
+ * lifecycle events to intelligently stop, start, and restart requests. Retrieve either by
+ * instantiating a new object, or to take advantage built in Activity and Fragment lifecycle
+ * handling, use the static Glide.load methods with your Fragment or Activity.
  *
  * @see Glide#with(android.app.Activity)
  * @see Glide#with(android.support.v4.app.FragmentActivity)
@@ -40,713 +47,433 @@
  * @see Glide#with(Context)
  */
 public class RequestManager implements LifecycleListener {
-    private final Context context;
-    private final Lifecycle lifecycle;
-    private final RequestTracker requestTracker;
-    private final Glide glide;
-    private final OptionsApplier optionsApplier;
-    private DefaultOptions options;
-
-    public RequestManager(Context context, Lifecycle lifecycle) {
-        this(context, lifecycle, new RequestTracker(), new ConnectivityMonitorFactory());
-    }
-
-    RequestManager(Context context, final Lifecycle lifecycle, RequestTracker requestTracker,
-            ConnectivityMonitorFactory factory) {
-        this.context = context.getApplicationContext();
-        this.lifecycle = lifecycle;
-        this.requestTracker = requestTracker;
-        this.glide = Glide.get(context);
-        this.optionsApplier = new OptionsApplier();
-
-        ConnectivityMonitor connectivityMonitor = factory.build(context,
-                new RequestManagerConnectivityListener(requestTracker));
-
-        // If we're the application level request manager, we may be created on a background thread. In that case we
-        // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding
-        // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.
-        if (Util.isOnBackgroundThread()) {
-            new Handler(Looper.getMainLooper()).post(new Runnable() {
-                @Override
-                public void run() {
-                    lifecycle.addListener(RequestManager.this);
-                }
-            });
-        } else {
-            lifecycle.addListener(this);
-        }
-        lifecycle.addListener(connectivityMonitor);
-    }
-
-    /**
-     * An interface that allows a default set of options to be applied to all requests started from an
-     * {@link com.bumptech.glide.RequestManager}.
-     */
-    public interface DefaultOptions {
-        /**
-         * Allows the implementor to apply some options to the given request.
-         *
-         * @param requestBuilder The request builder being used to construct the load.
-         * @param <T> The type of the model.
-         */
-        <T> void apply(GenericRequestBuilder<T, ?, ?, ?> requestBuilder);
-    }
-
-    /**
-     * Sets an interface that can apply some default options to all Requests started using this {@link RequestManager}.
-     *
-     * <p>
-     *     Note - These options will be retained for the life the of this {@link com.bumptech.glide.RequestManager}
-     *     so be wary of using
-     *     {@link com.bumptech.glide.GenericRequestBuilder#listener(com.bumptech.glide.request.RequestListener)}} when
-     *     starting requests using an {@link android.content.Context} or {@link android.app.Application} to avoid
-     *     leaking memory. Any option that does not use an anonymous inner class is generally safe.
-     * </p>
-     *
-     * @param options The default options to apply to all requests.
-     */
-    public void setDefaultOptions(DefaultOptions options) {
-        this.options = options;
-    }
-
-    /**
-     * Returns true if loads for this {@link RequestManager} are currently paused.
-     *
-     * @see #pauseRequests()
-     * @see #resumeRequests()
-     */
-    public boolean isPaused() {
-        Util.assertMainThread();
-        return requestTracker.isPaused();
-    }
-
-    /**
-     * Cancels any in progress loads, but does not clear resources of completed loads.
-     *
-     * @see #isPaused()
-     * @see #resumeRequests()
-     */
-    public void pauseRequests() {
-        Util.assertMainThread();
-        requestTracker.pauseRequests();
-    }
-
-    /**
-     * Restarts any loads that have not yet completed.
-     *
-     * @see #isPaused()
-     * @see #pauseRequests()
-     */
-    public void resumeRequests() {
-        Util.assertMainThread();
-        requestTracker.resumeRequests();
-    }
-
-    /**
-     * Lifecycle callback that registers for connectivity events (if the android.permission.ACCESS_NETWORK_STATE
-     * permission is present) and restarts failed or paused requests.
-     */
-    @Override
-    public void onStart() {
-        // onStart might not be called because this object may be created after the fragment/activity's onStart method.
-        resumeRequests();
-    }
-
-    /**
-     * Lifecycle callback that unregisters for connectivity events (if the android.permission.ACCESS_NETWORK_STATE
-     * permission is present) and pauses in progress loads.
-     */
-    @Override
-    public void onStop() {
-        pauseRequests();
-    }
-
-    /**
-     * Lifecycle callback that cancels all in progress requests and clears and recycles resources for all completed
-     * requests.
-     */
+  private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
+  private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
+  private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
+      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
+          .skipMemoryCache(true);
+
+  private final GlideContext context;
+  private final Lifecycle lifecycle;
+  private final RequestTracker requestTracker;
+  private final RequestManagerTreeNode treeNode;
+  private final TargetTracker targetTracker = new TargetTracker();
+  private final Runnable addSelfToLifecycle = new Runnable() {
     @Override
-    public void onDestroy() {
-        requestTracker.clearRequests();
-    }
-
-    /**
-     * Returns a request builder that uses the given {@link com.bumptech.glide.load.model.ModelLoader} to fetch a
-     * generic data type.
-     *
-     * <p>
-     *     Warning - This is an experimental api that may change without a change in major version.
-     * </p>
-     *
-     * @param modelLoader The {@link ModelLoader} class to use to load the model.
-     * @param dataClass The type of data the {@link ModelLoader} will load.
-     * @param <A> The type of the model to be loaded.
-     * @param <T> The type of the data to be loaded from the mode.
-     */
-    public <A, T> GenericModelRequest<A, T> using(ModelLoader<A, T> modelLoader, Class<T> dataClass) {
-        return new GenericModelRequest<A, T>(modelLoader, dataClass);
-    }
-
-    /**
-     * Returns a request builder that uses the given {@link com.bumptech.glide.load.model.stream.StreamModelLoader} to
-     * fetch an {@link InputStream} for loading images.
-     *
-     * @param modelLoader The model loader to use.
-     * @param <T> The type of the model.
-     */
-    public <T> ImageModelRequest<T> using(final StreamModelLoader<T> modelLoader) {
-        return new ImageModelRequest<T>(modelLoader);
-    }
-
-    /**
-     * Returns a request builder that uses the given
-     * {@link com.bumptech.glide.load.model.stream.StreamByteArrayLoader} to fetch an {@link java.io.InputStream} for
-     * loading Bitmaps.
-     *
-     * @param modelLoader The byte array loader.
-     */
-    public ImageModelRequest<byte[]> using(StreamByteArrayLoader modelLoader) {
-        return new ImageModelRequest<byte[]>(modelLoader);
-    }
-
-    /**
-     * Returns a new request builder that uses the given {@link ModelLoader} to fetch a
-     * {@link ParcelFileDescriptor} for loading video thumbnails.
-     *
-     * @param modelLoader The model loader to use.
-     * @param <T> The type of the model.
-     */
-    public <T> VideoModelRequest<T> using(final FileDescriptorModelLoader<T> modelLoader) {
-        return new VideoModelRequest<T>(modelLoader);
-    }
-
-    /**
-     * Returns a request builder to load the given {@link java.lang.String}.
-     * signature.
-     *
-     * @see #fromString()
-     * @see #load(Object)
-     *
-     * @param string A file path, or a uri or url handled by {@link com.bumptech.glide.load.model.UriLoader}.
-     */
-    public DrawableTypeRequest<String> load(String string) {
-        return (DrawableTypeRequest<String>) fromString().load(string);
-    }
-
-    /**
-     * Returns a request builder that loads data from {@link String}s using an empty signature.
-     *
-     * <p>
-     *     Note - this method caches data using only the given String as the cache key. If the data is a Uri outside of
-     *     your control, or you otherwise expect the data represented by the given String to change without the String
-     *     identifier changing, Consider using
-     *     {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} to mixin a signature
-     *     you create that identifies the data currently at the given String that will invalidate the cache if that data
-     *     changes. Alternatively, using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-     *     {@link com.bumptech.glide.DrawableRequestBuilder#skipMemoryCache(boolean)} may be appropriate.
-     * </p>
-     *
-     * @see #from(Class)
-     * @see #load(String)
-     */
-    public DrawableTypeRequest<String> fromString() {
-        return loadGeneric(String.class);
-    }
-
-    /**
-     * Returns a request builder to load the given {@link Uri}.
-     *
-     * @see #fromUri()
-     * @see #load(Object)
-     *
-     * @param uri The Uri representing the image. Must be of a type handled by
-     * {@link com.bumptech.glide.load.model.UriLoader}.
-     */
-    public DrawableTypeRequest<Uri> load(Uri uri) {
-        return (DrawableTypeRequest<Uri>) fromUri().load(uri);
-    }
-
-    /**
-     * Returns a request builder to load data from {@link android.net.Uri}s using no signature.
-     *
-     * <p>
-     *     Note - this method caches data at Uris using only the Uri itself as the cache key. The data represented by
-     *     Uris from some content providers may change without the Uri changing, which means using this method
-     *     can lead to displaying stale data. Consider using
-     *     {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} to mixin a signature
-     *     you create based on the data at the given Uri that will invalidate the cache if that data changes.
-     *     Alternatively, using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-     *     {@link com.bumptech.glide.DrawableRequestBuilder#skipMemoryCache(boolean)} may be appropriate.
-     * </p>
-     *
-     * @see #from(Class)
-     * @see #loadFromMediaStore(android.net.Uri)
-     * @see #loadFromMediaStore(android.net.Uri, String, long, int)
-     * @see com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)
-     */
-    public DrawableTypeRequest<Uri> fromUri() {
-        return loadGeneric(Uri.class);
-    }
-
-    /**
-     * Returns a request builder that uses {@link android.provider.MediaStore.Images.Thumbnails} and
-     * {@link android.provider.MediaStore.Video.Thumbnails} to retrieve pre-generated thumbnails for the given uri if
-     * available and uses the given additional data to build a unique signature for cache invalidation.
-     *
-     * @see #loadFromMediaStore(android.net.Uri)
-     * @see #load(android.net.Uri)
-     * @see com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)
-     * @see com.bumptech.glide.signature.MediaStoreSignature
-     *
-     * @deprecated Use {@link #loadFromMediaStore(android.net.Uri)},
-     * {@link com.bumptech.glide.signature.MediaStoreSignature}, and
-     * {@link com.bumptech.glide.DrawableRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be
-     * removed in Glide 4.0.
-     * @param uri The uri representing the media.
-     * @param mimeType The mime type of the media store media. Ok to default to empty string "". See
-     *      {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or
-     *      {@link android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}.
-     * @param dateModified The date modified time of the media store media. Ok to default to 0. See
-     *      {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or
-     *      {@link android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}.
-     * @param orientation The orientation of the media store media. Ok to default to 0. See
-     *      {@link android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
-     */
-    @Deprecated
-    public DrawableTypeRequest<Uri> loadFromMediaStore(Uri uri, String mimeType, long dateModified, int orientation) {
-        Key signature = new MediaStoreSignature(mimeType, dateModified, orientation);
-        return (DrawableTypeRequest<Uri>) loadFromMediaStore(uri).signature(signature);
-    }
-
-    /**
-     * Returns a request builder to load the given media store {@link android.net.Uri}.
-     *
-     * @see #fromMediaStore()
-     * @see #load(Object)
-     *
-     * @param uri The uri representing the media.
-     */
-    public DrawableTypeRequest<Uri> loadFromMediaStore(Uri uri) {
-        return (DrawableTypeRequest<Uri>) fromMediaStore().load(uri);
-    }
-
-    /**
-     * Returns a request builder that uses {@link android.provider.MediaStore.Images.Thumbnails} and
-     * {@link android.provider.MediaStore.Video.Thumbnails} to retrieve pre-generated thumbnails for
-     * {@link android.net.Uri}s.
-     *
-     * <p>
-     *  Falls back to the registered {@link com.bumptech.glide.load.model.ModelLoaderFactory} registered for
-     *  {@link Uri}s if the given uri is not a media store uri or if no pre-generated thumbnail exists for the given
-     *  uri.
-     * </p>
-     *
-     * <p>
-     *     Note - This method by default caches data using the given Uri as the key. Since content in the media store
-     *     can change at any time, you should use
-     *     {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} to mix in some
-     *     additional data identifying the current state of the Uri, preferably using
-     *     {@link com.bumptech.glide.signature.MediaStoreSignature}. Alternatively consider avoiding the memory and
-     *     disk caches entirely using
-     *     {@link GenericRequestBuilder#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
-     *     and {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-     *     {@link com.bumptech.glide.GenericRequestBuilder#skipMemoryCache(boolean)}.
-     * </p>
-     *
-     * @see #from(Class)
-     * @see #loadFromMediaStore(android.net.Uri, String, long, int)
-     * @see #load(android.net.Uri)
-     * @see com.bumptech.glide.signature.MediaStoreSignature
-     */
-    public DrawableTypeRequest<Uri> fromMediaStore() {
-        ModelLoader<Uri, InputStream> genericStreamLoader = Glide.buildStreamModelLoader(Uri.class, context);
-        ModelLoader<Uri, InputStream> mediaStoreLoader = new MediaStoreStreamLoader(context, genericStreamLoader);
-        ModelLoader<Uri, ParcelFileDescriptor> fileDescriptorModelLoader =
-                Glide.buildFileDescriptorModelLoader(Uri.class, context);
-
-        return optionsApplier.apply(new DrawableTypeRequest<Uri>(Uri.class, mediaStoreLoader,
-                fileDescriptorModelLoader, context, glide, requestTracker, lifecycle, optionsApplier));
-    }
-
-    /**
-     * Returns a request builder to load the given {@link File}.
-     *
-     * @see #fromFile()
-     * @see #load(Object)
-     *
-     * @param file The File containing the image
-     */
-    public DrawableTypeRequest<File> load(File file) {
-        return (DrawableTypeRequest<File>) fromFile().load(file);
-    }
-
-    /**
-     * Returns a request builder that uses the {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently
-     * registered for {@link File} to load the image represented by the given {@link File}. Defaults to
-     * {@link com.bumptech.glide.load.model.stream.StreamFileLoader.Factory} and
-     * {@link com.bumptech.glide.load.model.stream.StreamFileLoader} to load images from {@link File}s.
-     *
-     *  <p>
-     *     Note - this method caches data for Files using only the file path itself as the cache key. The data in the
-     *     File can change so using this method can lead to displaying stale data. If you expect the data in the File to
-     *     change, Consider using
-     *     {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} to mixin a signature
-     *     you create that identifies the data currently in the File that will invalidate the cache if that data
-     *     changes. Alternatively, using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-     *     {@link com.bumptech.glide.DrawableRequestBuilder#skipMemoryCache(boolean)} may be appropriate.
-     * </p>
-     *
-     * @see #load(java.io.File)
-     * @see #from(Class)
-     */
-    public DrawableTypeRequest<File> fromFile() {
-        return loadGeneric(File.class);
-    }
-
-    /**
-     * Returns a request builder to load the given resource id.
-     *
-     * @see #fromResource()
-     * @see #load(Object)
-     *
-     * @param resourceId the id of the resource containing the image
-     */
-    public DrawableTypeRequest<Integer> load(Integer resourceId) {
-        return (DrawableTypeRequest<Integer>) fromResource().load(resourceId);
-    }
-
-    /**
-     * Returns a request builder that uses the {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently
-     * registered for {@link Integer} to load the image represented by the given {@link Integer} resource id. Defaults
-     * to {@link com.bumptech.glide.load.model.stream.StreamResourceLoader.Factory} and
-     * {@link com.bumptech.glide.load.model.stream.StreamResourceLoader} to load resource id models.
-     *
-     * <p>
-     *     By default this method adds a version code based signature to the cache key used to cache this resource in
-     *     Glide. This signature is sufficient to guarantee that end users will see the most up to date versions of
-     *     your Drawables, but during development if you do not increment your version code before each install and
-     *     you replace a Drawable with different data without changing the Drawable name, you may see inconsistent
-     *     cached data. To get around this, consider using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE}
-     *     via {@link GenericRequestBuilder#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
-     *     during development, and re-enabling the default
-     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT} for release builds.
-     * </p>
-     *
-     * @see #from(Class)
-     * @see #load(Integer)
-     * @see com.bumptech.glide.signature.ApplicationVersionSignature
-     * @see com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)
-     */
-    public DrawableTypeRequest<Integer> fromResource() {
-        return (DrawableTypeRequest<Integer>) loadGeneric(Integer.class)
-                .signature(ApplicationVersionSignature.obtain(context));
-    }
-
-    /**
-     * Returns a request builder to load the given {@link URL}.
-     *
-     * @see #fromUrl()
-     * @see #load(Object)
-     *
-     * @deprecated The {@link java.net.URL} class has
-     * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be avoided when
-     * possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
-     * @param url The URL representing the image.
-     */
-    @Deprecated
-    public DrawableTypeRequest<URL> load(URL url) {
-        return (DrawableTypeRequest<URL>) fromUrl().load(url);
-    }
-
-    /**
-     * Returns a request builder that uses the {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently
-     * registered for {@link URL} to load the image represented by the given {@link URL}. Defaults to
-     * {@link com.bumptech.glide.load.model.stream.HttpUrlGlideUrlLoader} and
-     * {@link com.bumptech.glide.load.data.HttpUrlFetcher} to load {@link java.net.URL} models.
-     *
-     * @see #from(Class)
-     * @see #load(java.net.URL)
-     *
-     * @deprecated The {@link java.net.URL} class has
-     * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be avoided when
-     * possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
-     */
-    @Deprecated
-    public DrawableTypeRequest<URL> fromUrl() {
-        return loadGeneric(URL.class);
-    }
-
-    /**
-     * Returns a request builder that uses a {@link StreamByteArrayLoader} to load an image from the given byte array.
-     *
-     *
-     * <p>
-     *     Note - by default loads for bytes are not cached in either the memory or the disk cache.
-     * </p>
-     *
-     * @see #load(byte[])
-     *
-     * @deprecated Use {@link #load(byte[])} along with
-     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be
-     * removed in Glide 4.0.
-     * @param model The data to load.
-     * @param id A unique id that identifies the image represented by the model suitable for use as a cache key
-     *           (url, filepath etc). If there is no suitable id, use {@link #load(byte[])} instead.
-     */
-    @Deprecated
-    public DrawableTypeRequest<byte[]> load(byte[] model, final String id) {
-        return (DrawableTypeRequest<byte[]>) load(model).signature(new StringSignature(id));
-    }
-
-    /**
-     * Returns a request to load the given byte array.
-     *
-     * @see #fromBytes()
-     * @see #load(Object)
-     *
-     * @param model the data to load.
-     */
-    public DrawableTypeRequest<byte[]> load(byte[] model) {
-        return (DrawableTypeRequest<byte[]>) fromBytes().load(model);
-    }
-
-    /**
-     * Returns a request builder that uses {@link com.bumptech.glide.load.model.stream.StreamByteArrayLoader} to load
-     * images from byte arrays.
-     *
-     * <p>
-     *     Note - by default loads for bytes are not cached in either the memory or the disk cache.
-     * </p>
-     *
-     * @see #from(Class)
-     * @see #load(byte[])
-     */
-    public DrawableTypeRequest<byte[]> fromBytes() {
-        return (DrawableTypeRequest<byte[]>) loadGeneric(byte[].class)
-                .signature(new StringSignature(UUID.randomUUID().toString()))
-                .diskCacheStrategy(DiskCacheStrategy.NONE)
-                .skipMemoryCache(true /*skipMemoryCache*/);
-    }
-
-    /**
-     * Returns a request builder that uses the {@link com.bumptech.glide.load.model.ModelLoaderFactory}s currently
-     * registered for the given model class for {@link InputStream}s and {@link ParcelFileDescriptor}s to load a
-     * thumbnail from either the image or the video represented by the given model.
-     *
-     * <p>
-     *     Note - for maximum efficiency, consider using {@link #from(Class)}} to avoid repeatedly allocating builder
-     *     objects.
-     * </p>
-     *
-     * @see #from(Class)
-     *
-     * @param model The model the load.
-     * @param <T> The type of the model to load.
-     */
-    public <T> DrawableTypeRequest<T> load(T model) {
-        return (DrawableTypeRequest<T>) loadGeneric(getSafeClass(model)).load(model);
+    public void run() {
+      lifecycle.addListener(RequestManager.this);
+    }
+  };
+  private final Handler mainHandler = new Handler(Looper.getMainLooper());
+  private final ConnectivityMonitor connectivityMonitor;
+
+  @NonNull
+  private BaseRequestOptions<?> defaultRequestOptions;
+  @NonNull
+  private BaseRequestOptions<?> requestOptions;
+
+  public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+    this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());
+  }
+
+  RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,
+      RequestTracker requestTracker, ConnectivityMonitorFactory factory) {
+    this.context = Glide.get(context).getGlideContext();
+    this.lifecycle = lifecycle;
+    this.treeNode = treeNode;
+    this.requestTracker = requestTracker;
+
+    connectivityMonitor =
+        factory.build(context, new RequestManagerConnectivityListener(requestTracker));
+
+    // If we're the application level request manager, we may be created on a background thread.
+    // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
+    // issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.
+    // This should be entirely safe.
+    if (Util.isOnBackgroundThread()) {
+      mainHandler.post(addSelfToLifecycle);
+    } else {
+      lifecycle.addListener(this);
+    }
+    lifecycle.addListener(connectivityMonitor);
+
+    defaultRequestOptions = this.context.getDefaultRequestOptions();
+    requestOptions = defaultRequestOptions;
+
+    Glide.get(context).registerRequestManager(this);
+  }
+
+  /**
+   * Updates the default {@link RequestOptions} for all loads started with this request manager
+   * with the given {@link RequestOptions}.
+   *
+   * <p>The {@link RequestOptions} provided here are applied on top of those provided via {@link
+   * GlideBuilder#setDefaultRequestOptions(RequestOptions)}. If there are conflicts, the options
+   * applied here will win. Note that this method does not mutate options provided to
+   * {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   *
+   * <p>Multiple sets of options can be applied. If there are conflicts the last {@link
+   * RequestOptions} applied will win.
+   *
+   * <p>The modified options will only be applied to loads started after this method is called.
+   *
+   * @see RequestBuilder#apply(BaseRequestOptions)
+   *
+   * @return This request manager.
+   */
+  public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions) {
+    BaseRequestOptions<?> toMutate = this.requestOptions == defaultRequestOptions
+        ? this.requestOptions.clone() : this.defaultRequestOptions;
+    this.requestOptions = toMutate.apply(requestOptions);
+    return this;
+  }
+
+  /**
+   * Replaces the default {@link RequestOptions} for all loads started with this request manager
+   * with the given {@link RequestOptions}.
+   *
+   * <p>The {@link RequestOptions} provided here replace those that have been previously provided
+   * via {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, {@link
+   * #setDefaultRequestOptions(RequestOptions)} and {@link
+   * #applyDefaultRequestOptions(RequestOptions)}.
+   *
+   * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
+   * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
+   * options and mutate the clone.
+   *
+   * @see #applyDefaultRequestOptions(RequestOptions)
+   *
+   * @return This request manager.
+   */
+  public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
+    this.defaultRequestOptions = requestOptions;
+    this.requestOptions = requestOptions;
+    return this;
+  }
+
+  /**
+   * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+   */
+  public void onTrimMemory(int level) {
+    context.onTrimMemory(level);
+  }
+
+  /**
+   * @see android.content.ComponentCallbacks2#onLowMemory()
+   */
+  public void onLowMemory() {
+    context.onLowMemory();
+  }
+
+  /**
+   * Returns true if loads for this {@link RequestManager} are currently paused.
+   *
+   * @see #pauseRequests()
+   * @see #resumeRequests()
+   */
+  public boolean isPaused() {
+    Util.assertMainThread();
+    return requestTracker.isPaused();
+  }
+
+  /**
+   * Cancels any in progress loads, but does not clear resources of completed loads.
+   *
+   * @see #isPaused()
+   * @see #resumeRequests()
+   */
+  public void pauseRequests() {
+    Util.assertMainThread();
+    requestTracker.pauseRequests();
+  }
+
+  /**
+   * Performs {@link #pauseRequests()} recursively for all managers that are contextually
+   * descendant to this manager based on the Activity/Fragment hierarchy:
+   *
+   * <ul>
+   *   <li>When pausing on an Activity all attached fragments will also get paused.
+   *   <li>When pausing on an attached Fragment all descendant fragments will also get paused.
+   *   <li>When pausing on a detached Fragment or the application context only the current
+   *   RequestManager is paused.
+   * </ul>
+   *
+   * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
+   * pause, in this case either call pause on the Activity or use a support Fragment.
+   */
+  public void pauseRequestsRecursive() {
+    Util.assertMainThread();
+    pauseRequests();
+    for (RequestManager requestManager : treeNode.getDescendants()) {
+      requestManager.pauseRequests();
+    }
+  }
+
+  /**
+   * Restarts any loads that have not yet completed.
+   *
+   * @see #isPaused()
+   * @see #pauseRequests()
+   */
+  public void resumeRequests() {
+    Util.assertMainThread();
+    requestTracker.resumeRequests();
+  }
+
+  /**
+   * Performs {@link #resumeRequests()} recursively for all managers that are contextually
+   * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
+   * are identical as for {@link #pauseRequestsRecursive()}.
+   */
+  public void resumeRequestsRecursive() {
+    Util.assertMainThread();
+    resumeRequests();
+    for (RequestManager requestManager : treeNode.getDescendants()) {
+      requestManager.resumeRequests();
+    }
+  }
+
+  /**
+   * Lifecycle callback that registers for connectivity events (if the
+   * android.permission.ACCESS_NETWORK_STATE permission is present) and restarts failed or paused
+   * requests.
+   */
+  @Override
+  public void onStart() {
+    resumeRequests();
+    targetTracker.onStart();
+  }
+
+  /**
+   * Lifecycle callback that unregisters for connectivity events (if the
+   * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.
+   */
+  @Override
+  public void onStop() {
+    pauseRequests();
+    targetTracker.onStop();
+  }
+
+  /**
+   * Lifecycle callback that cancels all in progress requests and clears and recycles resources for
+   * all completed requests.
+   */
+  @Override
+  public void onDestroy() {
+    targetTracker.onDestroy();
+    for (Target<?> target : targetTracker.getAll()) {
+      clear(target);
+    }
+    targetTracker.clear();
+    requestTracker.clearRequests();
+    lifecycle.removeListener(this);
+    lifecycle.removeListener(connectivityMonitor);
+    mainHandler.removeCallbacks(addSelfToLifecycle);
+    Glide.get(context).unregisterRequestManager(this);
+  }
+
+  /**
+   * Attempts to always load the resource as a {@link android.graphics.Bitmap}, even if it could
+   * actually be animated.
+   *
+   * @return A new request builder for loading a {@link android.graphics.Bitmap}
+   */
+  public RequestBuilder<Bitmap> asBitmap() {
+    return as(Bitmap.class).transition(new BitmapTransitionOptions()).apply(DECODE_TYPE_BITMAP);
+  }
+
+  /**
+   * Attempts to always load the resource as a
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+   *
+   * <p> If the underlying data is not a GIF, this will fail. As a result, this should only be used
+   * if the model represents an animated GIF and the caller wants to interact with the GifDrawable
+   * directly. Normally using just {@link #asDrawable()} is sufficient because it will determine
+   * whether or not the given data represents an animated GIF and return the appropriate {@link
+   * Drawable}, animated or not, automatically. </p>
+   *
+   * @return A new request builder for loading a
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+   */
+  public RequestBuilder<GifDrawable> asGif() {
+    return as(GifDrawable.class).transition(new DrawableTransitionOptions()).apply(DECODE_TYPE_GIF);
+  }
+
+  /**
+   * Attempts to always load the resource using any registered {@link
+   * com.bumptech.glide.load.ResourceDecoder}s that can decode any subclass of {@link Drawable}.
+   *
+   * <p> By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
+   * GifDrawable}, but if additional decoders are registered for other {@link Drawable} subclasses,
+   * any of those subclasses may also be returned. </p>
+   *
+   * @return A new request builder for loading a {@link Drawable}.
+   */
+  public RequestBuilder<Drawable> asDrawable() {
+    return as(Drawable.class).transition(new DrawableTransitionOptions());
+  }
+
+  /**
+   * A helper method equivalent to calling {@link #asDrawable()} and then {@link
+   * RequestBuilder#load(Object)} with the given model.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  public RequestBuilder<Drawable> load(@Nullable Object model) {
+    return asDrawable().load(model);
+  }
+
+  /**
+   * Attempts always load the resource into the cache and return the {@link File} containing the
+   * cached source data.
+   *
+   * <p>This method is designed to work for remote data that is or will be cached using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not
+   * recommended.
+   *
+   * @return A new request builder for downloading content to cache and returning the cache File.
+   */
+  public RequestBuilder<File> downloadOnly() {
+    return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * A helper method equivalent to calling {@link #downloadOnly()} ()} and then {@link
+   * RequestBuilder#load(Object)} with the given model.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  public RequestBuilder<File> download(@Nullable Object model) {
+    return downloadOnly().load(model);
+  }
+
+  /**
+   * Attempts to always load a {@link File} containing the resource, either using a file path
+   * obtained from the media store (for local images/videos), or using Glide's disk cache
+   * (for remote images/videos).
+   *
+   * <p>For remote content, prefer {@link #downloadOnly()}.
+   *
+   * @return A new request builder for obtaining File paths to content.
+   */
+  public RequestBuilder<File> asFile() {
+    return as(File.class).apply(skipMemoryCacheOf(true));
+  }
+
+  /**
+   * Attempts to load the resource using any registered
+   * {@link com.bumptech.glide.load.ResourceDecoder}s
+   * that can decode the given resource class or any subclass of the given resource class.
+   *
+   * @param resourceClass The resource to decode.
+   * @return A new request builder for loading the given resource class.
+   */
+  public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
+    return new RequestBuilder<>(context, this, resourceClass);
+  }
+
+  /**
+   * Cancel any pending loads Glide may have for the view and free any resources that may have been
+   * loaded for the view.
+   *
+   * <p> Note that this will only work if {@link View#setTag(Object)} is not called on this view
+   * outside of Glide. </p>
+   *
+   * @param view The view to cancel loads and free resources for.
+   * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
+   *                                  tag.
+   * @see #clear(Target).
+   */
+  public void clear(View view) {
+    clear(new ClearTarget(view));
+  }
+
+  /**
+   * Cancel any pending loads Glide may have for the target and free any resources (such as
+   * {@link Bitmap}s) that may have been loaded for the target so they may be reused.
+   *
+   * @param target The Target to cancel loads for.
+   */
+  public void clear(@Nullable final Target<?> target) {
+    if (target == null) {
+      return;
+    }
+
+    if (Util.isOnMainThread()) {
+      untrackOrDelegate(target);
+    } else {
+      mainHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          clear(target);
+        }
+      });
     }
+  }
 
-    /**
-     * Returns a request builder that can be used for multiple loads that uses the
-     * {@link com.bumptech.glide.load.model.ModelLoaderFactory}s registered for the given model class for
-     * {@link java.io.InputStream}s and {@link android.os.ParcelFileDescriptor}s to load a thumbnail from objects of
-     * the given modelClass.
-     *
-     * <p>
-     *     Note - you must use {@link com.bumptech.glide.DrawableRequestBuilder#load(Object)}} to set a concrete model
-     *     to be loaded before calling
-     *     {@link com.bumptech.glide.DrawableRequestBuilder#into(com.bumptech.glide.request.target.Target)}. You may
-     *     also use this object for repeated loads by calling <code>request.load(model).into(target)</code>. You may
-     *     also adjust the options after calling {@link com.bumptech.glide.DrawableRequestBuilder#load(Object)}} and/or
-     *     {@link com.bumptech.glide.DrawableRequestBuilder#into(com.bumptech.glide.request.target.Target)}}. However,
-     *     keep in mind that any changes in options will apply to all future loads.
-     * </p>
-     *
-     * @param modelClass The class of model requests built by this class will load data from.
-     * @param <T> The type of the model.
-     */
-    public <T> DrawableTypeRequest<T> from(Class<T> modelClass) {
-        return loadGeneric(modelClass);
+  private void untrackOrDelegate(Target<?> target) {
+    boolean isOwnedByUs = untrack(target);
+    if (!isOwnedByUs) {
+      Glide.get(context).removeFromManagers(target);
     }
+  }
 
-    private <T> DrawableTypeRequest<T> loadGeneric(Class<T> modelClass) {
-        ModelLoader<T, InputStream> streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);
-        ModelLoader<T, ParcelFileDescriptor> fileDescriptorModelLoader =
-                Glide.buildFileDescriptorModelLoader(modelClass, context);
-        if (modelClass != null && streamModelLoader == null && fileDescriptorModelLoader == null) {
-            throw new IllegalArgumentException("Unknown type " + modelClass + ". You must provide a Model of a type for"
-                    + " which there is a registered ModelLoader, if you are using a custom model, you must first call"
-                    + " Glide#register with a ModelLoaderFactory for your custom model class");
-        }
-
-        return optionsApplier.apply(
-                new DrawableTypeRequest<T>(modelClass, streamModelLoader, fileDescriptorModelLoader, context,
-                        glide, requestTracker, lifecycle, optionsApplier));
+  boolean untrack(Target<?> target) {
+    Request request = target.getRequest();
+    // If the Target doesn't have a request, it's already been cleared.
+    if (request == null) {
+      return true;
     }
 
-    @SuppressWarnings("unchecked")
-    private static <T> Class<T> getSafeClass(T model) {
-        return model != null ? (Class<T>) model.getClass() : null;
+    if (requestTracker.clearRemoveAndRecycle(request)) {
+      targetTracker.untrack(target);
+      target.setRequest(null);
+      return true;
+    } else {
+      return false;
     }
+  }
 
-    /**
-     * A helper class for building requests with custom {@link ModelLoader}s that translate models to
-     * {@link ParcelFileDescriptor} resources for loading video thumbnails.
-     *
-     * @param <T> The type of the model.
-     */
-    public final class VideoModelRequest<T> {
-        private final ModelLoader<T, ParcelFileDescriptor> loader;
-
-        VideoModelRequest(ModelLoader<T, ParcelFileDescriptor> loader) {
-            this.loader = loader;
-        }
+  void track(Target<?> target, Request request) {
+    targetTracker.track(target);
+    requestTracker.runRequest(request);
+  }
 
-        public DrawableTypeRequest<T> load(T model) {
-            return (DrawableTypeRequest<T>) optionsApplier.apply(new DrawableTypeRequest<T>(getSafeClass(model), null,
-                    loader, context, glide, requestTracker, lifecycle, optionsApplier))
-                    .load(model);
-        }
-    }
+  BaseRequestOptions<?> getDefaultRequestOptions() {
+    return requestOptions;
+  }
 
-    /**
-     * A helper class for building requests with custom {@link ModelLoader}s that translate models to
-     * {@link InputStream} resources for loading images.
-     *
-     * @param <T> The type of the model.
-     */
-    public final class ImageModelRequest<T> {
-        private final ModelLoader<T, InputStream> loader;
-
-        ImageModelRequest(ModelLoader<T, InputStream> loader) {
-            this.loader = loader;
-        }
+  @Override
+  public String toString() {
+    return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
+  }
 
-        /**
-         * Returns a request builder that uses the provided {@link com.bumptech.glide.load.model.ModelLoader} to load
-         * images from an {@link java.io.InputStream}s obtained from models of the given model class.
-         *
-         * @param modelClass The class of model to load images from.
-         */
-        public DrawableTypeRequest<T> from(Class<T> modelClass) {
-            return optionsApplier.apply(new DrawableTypeRequest<T>(modelClass, loader, null, context, glide,
-                    requestTracker, lifecycle, optionsApplier));
-        }
+  private static class RequestManagerConnectivityListener implements ConnectivityMonitor
+      .ConnectivityListener {
+    private final RequestTracker requestTracker;
 
-        /**
-         * Returns a request builder that uses the provided {@link com.bumptech.glide.load.model.ModelLoader} to load
-         * an image from an {@link java.io.InputStream} obtained from the given model.
-         *
-         * @see #from(Class)
-         *
-         * @param model The model to load an image from.
-         */
-        public DrawableTypeRequest<T> load(T model) {
-            return (DrawableTypeRequest<T>) from(getSafeClass(model)).load(model);
-        }
+    public RequestManagerConnectivityListener(RequestTracker requestTracker) {
+      this.requestTracker = requestTracker;
     }
 
-    /**
-     * A helper class for building requests with custom {@link ModelLoader}s that requires the user to provide a
-     * specific model.
-     *
-     * @param <A> The type of the model.
-     * @param <T> The type of data the {@link com.bumptech.glide.load.model.ModelLoader} provides an
-     * {@link com.bumptech.glide.load.data.DataFetcher} to convert the model to.
-     */
-    public final class GenericModelRequest<A, T> {
-        private final ModelLoader<A, T> modelLoader;
-        private final Class<T> dataClass;
-
-        GenericModelRequest(ModelLoader<A, T> modelLoader, Class<T> dataClass) {
-            this.modelLoader = modelLoader;
-            this.dataClass = dataClass;
-        }
-
-        /**
-         * Sets the type of model that will be loaded.
-         *
-         * @param modelClass the class of model to use.
-         * @return A request builder
-         */
-        public GenericTypeRequest from(Class<A> modelClass) {
-            return new GenericTypeRequest(modelClass);
-        }
-
-        /**
-         * Sets the specific model that will be loaded.
-         *
-         * @param model The model to use.
-         * @return A request builder.
-         */
-        public GenericTypeRequest load(A model) {
-            return new GenericTypeRequest(model);
-        }
-
-        /**
-         * A helper class for building requests with custom {@link com.bumptech.glide.load.model.ModelLoader}s that
-         * requires the user to specify a specific resource class that will be loaded.
-         *
-         */
-        public final class GenericTypeRequest {
-            private final A model;
-            private final Class<A> modelClass;
-            private final boolean providedModel;
-
-            GenericTypeRequest(A model) {
-                providedModel = true;
-                this.model = model;
-                this.modelClass = getSafeClass(model);
-            }
-
-            GenericTypeRequest(Class<A> modelClass) {
-                providedModel = false;
-                this.model = null;
-                this.modelClass = modelClass;
-            }
-
-            /**
-             * Sets the resource class that will be loaded.
-             *
-             * @param resourceClass The class of the resource that will be loaded.
-             * @param <Z> The type of the resource that will be loaded.
-             * @return This request builder.
-             */
-            public <Z> GenericTranscodeRequest<A, T, Z> as(Class<Z> resourceClass) {
-                GenericTranscodeRequest<A, T, Z> result =
-                        optionsApplier.apply(new GenericTranscodeRequest<A, T, Z>(context, glide, modelClass,
-                                modelLoader, dataClass, resourceClass, requestTracker, lifecycle, optionsApplier));
-                if (providedModel) {
-                    result.load(model);
-                }
-                return result;
-            }
-        }
+    @Override
+    public void onConnectivityChanged(boolean isConnected) {
+      if (isConnected) {
+        requestTracker.restartRequests();
+      }
     }
+  }
 
-    class OptionsApplier {
+  private static class ClearTarget extends ViewTarget<View, Object> {
 
-        public <A, X extends GenericRequestBuilder<A, ?, ?, ?>> X apply(X builder) {
-            if (options != null) {
-                options.apply(builder);
-            }
-            return builder;
-        }
+    public ClearTarget(View view) {
+      super(view);
     }
 
-    private static class RequestManagerConnectivityListener implements ConnectivityMonitor.ConnectivityListener {
-        private final RequestTracker requestTracker;
-
-        public RequestManagerConnectivityListener(RequestTracker requestTracker) {
-            this.requestTracker = requestTracker;
-        }
-
-        @Override
-        public void onConnectivityChanged(boolean isConnected) {
-            if (isConnected) {
-                requestTracker.restartRequests();
-            }
-        }
+    @Override
+    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+      // Do nothing.
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
new file mode 100644
index 000000000..ea285ebf3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -0,0 +1,79 @@
+package com.bumptech.glide;
+
+import com.bumptech.glide.request.transition.NoTransition;
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.request.transition.ViewAnimationFactory;
+import com.bumptech.glide.request.transition.ViewPropertyAnimationFactory;
+import com.bumptech.glide.request.transition.ViewPropertyTransition;
+import com.bumptech.glide.util.Preconditions;
+
+/**
+ * A base class for setting a transition to use on a resource when a load completes.
+ *
+ * @param <CHILD>         The implementation of this class to return to chain methods.
+ * @param <TranscodeType> The type of resource that will be animated.
+ */
+public abstract class TransitionOptions<CHILD extends TransitionOptions<CHILD, TranscodeType>,
+    TranscodeType> implements Cloneable {
+  private TransitionFactory<? super TranscodeType> transitionFactory = NoTransition.getFactory();
+
+  /**
+   * Removes any existing animation put on the builder. Will be overridden by subsequent calls that
+   * put an animation.
+   *
+   * @return This request builder.
+   */
+  public final CHILD dontTransition() {
+    return transition(NoTransition.getFactory());
+  }
+
+  /**
+   * Sets a {@link android.view.animation} to run on the wrapped target when an resource load
+   * finishes. Will only be run if the resource was loaded asynchronously (ie was not in the memory
+   * cache)
+   *
+   * @param viewAnimationId The resource id of the {@link android.view.animation} to use as the
+   *                        transition.
+   * @return This request builder.
+   */
+  public final CHILD transition(int viewAnimationId) {
+    return transition(new ViewAnimationFactory<TranscodeType>(viewAnimationId));
+  }
+
+  /**
+   * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target
+   * may be wrapping when a resource load finishes. Will only be run if the load was loaded
+   * asynchronously (ie was not in the memory cache).
+   *
+   * @param animator The {@link com.bumptech.glide.request.transition.ViewPropertyTransition
+   *                 .Animator} to run.
+   * @return This request builder.
+   */
+  public final CHILD transition(ViewPropertyTransition.Animator animator) {
+    return transition(new ViewPropertyAnimationFactory<TranscodeType>(animator));
+  }
+
+  public final CHILD transition(TransitionFactory<? super TranscodeType> transitionFactory) {
+    this.transitionFactory = Preconditions.checkNotNull(transitionFactory);
+    return self();
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  protected final CHILD clone() {
+    try {
+      return (CHILD) super.clone();
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  final TransitionFactory<? super TranscodeType> getTransitionFactory() {
+    return transitionFactory;
+  }
+
+  @SuppressWarnings("unchecked")
+  private CHILD self() {
+    return (CHILD) this;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/DataSource.java b/library/src/main/java/com/bumptech/glide/load/DataSource.java
new file mode 100644
index 000000000..699a13bfe
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java
@@ -0,0 +1,28 @@
+package com.bumptech.glide.load;
+
+/**
+ * Indicates the origin of some retrieved data.
+ */
+public enum DataSource {
+  /**
+   * Indicates data was probably retrieved locally from the device, although it may have been
+   * obtained through a content provider that may have obtained the data from a remote source.
+   */
+  LOCAL,
+  /**
+   * Indicates data was retrieved from a remote source other than the device.
+   */
+  REMOTE,
+  /**
+   * Indicates data was retrieved unmodified from the on device cache.
+   */
+  DATA_DISK_CACHE,
+  /**
+   * Indicates data was retrieved from modified content in the on device cache.
+   */
+  RESOURCE_DISK_CACHE,
+  /**
+   * Indicates data was retrieved from the in memory cache.
+   */
+  MEMORY_CACHE,
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index afb892a3e..118d407dd 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -1,35 +1,38 @@
 package com.bumptech.glide.load;
 
-import android.os.Build;
-
 /**
- * Options for setting the value of {@link android.graphics.Bitmap#getConfig()} for {@link android.graphics.Bitmap}s
- * returned by a {@link com.bumptech.glide.load.resource.bitmap.BitmapDecoder}.
+ * Options for setting the value of {@link android.graphics.Bitmap#getConfig()} for
+ * {@link android.graphics.Bitmap}s returned by {@link com.bumptech.glide.load.ResourceDecoder}s.
  *
- * <p>
- *     Note - In some cases it may not be possible to obey the requested setting, not all
- *     {@link com.bumptech.glide.load.resource.bitmap.BitmapDecoder}s support setting formats and certain images may
- *     not be able to be loaded as certain configurations. Therefore this class represents a preference rather than a
- *     requirement.
- * </p>
+ * <p> Note - In some cases it may not be possible to obey the requested setting, not all
+ * {@link com.bumptech.glide.load.resource.bitmap.Downsampler}s support setting formats and certain
+ * images may not be able to be loaded as certain configurations. Therefore this class represents a
+ * preference rather than a requirement. </p>
  */
 public enum DecodeFormat {
-    /**
-     * All bitmaps returned by the {@link com.bumptech.glide.load.resource.bitmap.BitmapDecoder} should return
-     * {@link android.graphics.Bitmap.Config#ARGB_8888} for {@link android.graphics.Bitmap#getConfig()}.
-     */
-    ALWAYS_ARGB_8888,
+  /**
+   * Bitmaps returned by the {@link com.bumptech.glide.load.ResourceDecoder}.
+   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
+   * {@link android.graphics.Bitmap#getConfig()} when possible.
+   *
+   * <p> GIF images decoded by {@link android.graphics.BitmapFactory} currently use an internal
+   * hidden format that is returned as null from {@link android.graphics.Bitmap#getConfig()}. Since
+   * we cannot force {@link android.graphics.BitmapFactory} to always return our desired config,
+   * this setting is a preference, not a promise.</p>
+   */
+  PREFER_ARGB_8888,
 
-    /**
-     * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc) should
-     * return {@link android.graphics.Bitmap.Config#ARGB_8888} for {@link android.graphics.Bitmap#getConfig()}. Bitmaps
-     * decoded from formats that don't support or use alpha should return
-     * {@link android.graphics.Bitmap.Config#RGB_565} for {@link android.graphics.Bitmap#getConfig()}.
-     *
-     */
-    PREFER_RGB_565;
+  /**
+   * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)
+   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
+   * {@link android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or
+   * use alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for
+   * {@link android.graphics.Bitmap#getConfig()}.
+   */
+  PREFER_RGB_565;
 
-    /** The default value for DecodeFormat. */
-    public static final DecodeFormat DEFAULT = Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT
-            ? ALWAYS_ARGB_8888 : PREFER_RGB_565;
+  /**
+   * The default value for DecodeFormat.
+   */
+  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java b/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java
new file mode 100644
index 000000000..33eed74dc
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.load;
+
+/**
+ * Details how an {@link com.bumptech.glide.load.ResourceEncoder} will encode a resource to cache.
+ */
+public enum EncodeStrategy {
+  /**
+   * Writes the original unmodified data for the resource to disk, not include downsampling or
+   * transformations.
+   */
+  SOURCE,
+
+  /**
+   * Writes the decoded, downsampled and transformed data for the resource to disk.
+   */
+  TRANSFORMED,
+
+  /**
+   * Will write no data.
+   */
+  NONE,
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/Encoder.java b/library/src/main/java/com/bumptech/glide/load/Encoder.java
index b81230c7d..db652b1ad 100644
--- a/library/src/main/java/com/bumptech/glide/load/Encoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load;
 
-import java.io.OutputStream;
+import java.io.File;
 
 /**
  * An interface for writing data to some persistent data store (i.e. a local File cache).
@@ -9,23 +9,13 @@
  */
 public interface Encoder<T> {
 
-    /**
-     * Writes the given data to the given output stream and returns True if the write completed successfully and
-     * should be committed.
-     *
-     * @param data The data to write.
-     * @param os The OutputStream to write the data to.
-     */
-    boolean encode(T data, OutputStream os);
-
-    /**
-     * Returns an ID identifying any transformation this encoder may apply to the given data that will be mixed in to
-     * the cache key.
-     *
-     * <p>
-     *     If the encoder does not transform the data in a way that significantly affects the cached result (ie performs
-     *     no unusual compression or downsampling) an empty string is an appropriate id.
-     * </p>
-     */
-    String getId();
+  /**
+   * Writes the given data to the given output stream and returns True if the write completed
+   * successfully and should be committed.
+   *
+   * @param data The data to write.
+   * @param file The File to write the data to.
+   * @param options The put of options to apply when encoding.
+   */
+  boolean encode(T data, File file, Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/HttpException.java b/library/src/main/java/com/bumptech/glide/load/HttpException.java
new file mode 100644
index 000000000..ad53292c1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.Nullable;
+
+import java.io.IOException;
+
+/**
+ * Thrown when an http request fails.
+ *
+ * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so
+ * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of
+ * the underlying http library.
+ */
+public final class HttpException extends IOException {
+  public static final int UNKNOWN = -1;
+  private final int statusCode;
+
+  public HttpException(int statusCode) {
+    this("Http request failed with status code: " + statusCode, statusCode);
+  }
+
+  public HttpException(String message) {
+    this(message, UNKNOWN);
+  }
+
+  public HttpException(String message, int statusCode) {
+    this(message, statusCode, null /*cause*/);
+  }
+
+  public HttpException(String message, int statusCode, @Nullable Throwable cause) {
+    super(message, cause);
+    this.statusCode = statusCode;
+  }
+
+  /**
+   * Returns the http status code, or {@link #UNKNOWN} if the request failed without providing
+   * a status code.
+   */
+  public int getStatusCode() {
+    return statusCode;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/Key.java b/library/src/main/java/com/bumptech/glide/load/Key.java
index 4f614ed17..47bb2e01a 100644
--- a/library/src/main/java/com/bumptech/glide/load/Key.java
+++ b/library/src/main/java/com/bumptech/glide/load/Key.java
@@ -1,31 +1,31 @@
 package com.bumptech.glide.load;
 
-import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
 import java.security.MessageDigest;
 
 /**
- * An interface that uniquely identifies some set of data. Implementations must implement {@link Object#equals(Object)}
- * and {@link Object#hashCode()}. Implementations are generally expected to add all uniquely identifying information
- * used in in {@link java.lang.Object#equals(Object)}} and {@link Object#hashCode()}} to the given
- * {@link java.security.MessageDigest} in {@link #updateDiskCacheKey(java.security.MessageDigest)}}, although this
- * requirement is not as strict for partial cache key signatures.
+ * An interface that uniquely identifies some put of data. Implementations must implement {@link
+ * Object#equals(Object)} and {@link Object#hashCode()}. Implementations are generally expected to
+ * add all uniquely identifying information used in in {@link java.lang.Object#equals(Object)}} and
+ * {@link Object#hashCode()}} to the given {@link java.security.MessageDigest} in {@link
+ * #updateDiskCacheKey(java.security.MessageDigest)}}, although this requirement is not as strict
+ * for partial cache key signatures.
  */
 public interface Key {
-    String STRING_CHARSET_NAME = "UTF-8";
+  String STRING_CHARSET_NAME = "UTF-8";
+  Charset CHARSET = Charset.forName(STRING_CHARSET_NAME);
 
-    /**
-     * Adds all uniquely identifying information to the given digest.
-     *
-     * <p>
-     *     Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result in undefined
-     *     behavior.
-     * </p>
-     */
-    void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException;
+  /**
+   * Adds all uniquely identifying information to the given digest.
+   *
+   * <p> Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result
+   * in undefined behavior. </p>
+   */
+  void updateDiskCacheKey(MessageDigest messageDigest);
 
-    @Override
-    boolean equals(Object o);
+  @Override
+  boolean equals(Object o);
 
-    @Override
-    int hashCode();
+  @Override
+  int hashCode();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index f5bd201ca..99a177abc 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -2,6 +2,7 @@
 
 import com.bumptech.glide.load.engine.Resource;
 
+import java.security.MessageDigest;
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -11,47 +12,57 @@
  * @param <T> The type of {@link com.bumptech.glide.load.engine.Resource} that will be transformed.
  */
 public class MultiTransformation<T> implements Transformation<T> {
-    private final Collection<? extends Transformation<T>> transformations;
-    private String id;
-
-    @SafeVarargs
-    public MultiTransformation(Transformation<T>... transformations) {
-        if (transformations.length < 1) {
-            throw new IllegalArgumentException("MultiTransformation must contain at least one Transformation");
-        }
-        this.transformations = Arrays.asList(transformations);
+  private final Collection<? extends Transformation<T>> transformations;
+
+  @SafeVarargs
+  public MultiTransformation(Transformation<T>... transformations) {
+    if (transformations.length < 1) {
+      throw new IllegalArgumentException(
+          "MultiTransformation must contain at least one Transformation");
     }
+    this.transformations = Arrays.asList(transformations);
+  }
 
-    public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
-        if (transformationList.size() < 1) {
-            throw new IllegalArgumentException("MultiTransformation must contain at least one Transformation");
-        }
-        this.transformations = transformationList;
+  public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
+    if (transformationList.size() < 1) {
+      throw new IllegalArgumentException(
+          "MultiTransformation must contain at least one Transformation");
     }
+    this.transformations = transformationList;
+  }
+
+  @Override
+  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+    Resource<T> previous = resource;
 
-    @Override
-    public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
-        Resource<T> previous = resource;
-
-        for (Transformation<T> transformation : transformations) {
-            Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);
-            if (previous != null && !previous.equals(resource) && !previous.equals(transformed)) {
-                previous.recycle();
-            }
-            previous = transformed;
-        }
-        return previous;
+    for (Transformation<T> transformation : transformations) {
+      Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);
+      if (previous != null && !previous.equals(resource) && !previous.equals(transformed)) {
+        previous.recycle();
+      }
+      previous = transformed;
     }
+    return previous;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof MultiTransformation) {
+      MultiTransformation<?> other = (MultiTransformation<?>) o;
+      return transformations.equals(other.transformations);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return transformations.hashCode();
+  }
 
-    @Override
-    public String getId() {
-        if (id == null) {
-            StringBuilder sb = new StringBuilder();
-            for (Transformation<T> transformation : transformations) {
-                sb.append(transformation.getId());
-            }
-            id = sb.toString();
-        }
-        return id;
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    for (Transformation<T> transformation : transformations) {
+      transformation.updateDiskCacheKey(messageDigest);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
new file mode 100644
index 000000000..04a03e5b6
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -0,0 +1,153 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.util.Preconditions;
+
+import java.security.MessageDigest;
+
+/**
+ * Defines available component (decoders, encoders, model loaders etc.) options with optional
+ * default values and the ability to affect the resource disk cache key used by {@link
+ * com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE}.
+ *
+ * <p>
+ *   Implementations must either be unique (usually declared as static final variables), or
+ *   implement {@link #equals(Object)} and {@link #hashCode()}.
+ * </p>
+ *
+ * <p>
+ *   Implementations can implement {@link #update(Object, MessageDigest)} to make sure that
+ *   the disk cache key includes the specific option set.
+ * </p>
+ *
+ * @param <T> The type of the option ({@link Integer}, {@link
+ * android.graphics.Bitmap.CompressFormat} etc.), must implement {@link #equals(Object)} and
+ * {@link #hashCode()}.
+ */
+public final class Option<T> {
+  private static final CacheKeyUpdater<Object> EMPTY_UPDATER = new CacheKeyUpdater<Object>() {
+    @Override
+    public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
+      // Do nothing.
+    }
+  };
+
+  private final T defaultValue;
+  private final CacheKeyUpdater<T> cacheKeyUpdater;
+  private final String key;
+  private volatile byte[] keyBytes;
+
+  /**
+   * Returns a new {@link Option} that does not affect disk cache keys with a {@code null} default
+   * value.
+   *
+   * @param key A unique package prefixed {@link String} that identifies this option (must be
+   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   */
+  public static <T> Option<T> memory(String key) {
+    return new Option<>(key, null /*defaultValue*/, Option.<T>emptyUpdater());
+  }
+
+  /**
+   * Returns a new {@link Option} that does not affect disk cache keys with the given value as the
+   * default value.
+   *
+   * @param key A unique package prefixed {@link String} that identifies this option (must be
+   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   */
+  public static <T> Option<T> memory(String key, T defaultValue) {
+    return new Option<>(key, defaultValue, Option.<T>emptyUpdater());
+  }
+
+  /**
+   * Returns a new {@link Option} that uses the given {@link
+   * com.bumptech.glide.load.Option.CacheKeyUpdater} to update disk cache keys.
+   *
+   * @param key A unique package prefixed {@link String} that identifies this option (must be
+   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   */
+  public static <T> Option<T> disk(String key, CacheKeyUpdater<T> cacheKeyUpdater) {
+    return new Option<>(key, null /*defaultValue*/, cacheKeyUpdater);
+  }
+
+  /**
+   * Returns a new {@link Option} that uses the given {@link
+   * com.bumptech.glide.load.Option.CacheKeyUpdater} to update disk cache keys and provides
+   * the given value as the default value.
+   *
+   * @param key A unique package prefixed {@link String} that identifies this option (must be
+   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   */
+  public static <T> Option<T> disk(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+    return new Option<>(key, defaultValue, cacheKeyUpdater);
+  }
+
+  Option(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+    this.key = Preconditions.checkNotEmpty(key);
+    this.defaultValue = defaultValue;
+    this.cacheKeyUpdater = Preconditions.checkNotNull(cacheKeyUpdater);
+  }
+
+  /**
+   * Returns a reasonable default to use if no other value is set, or {@code null}.
+   */
+  @Nullable
+  public T getDefaultValue() {
+    return defaultValue;
+  }
+
+  /**
+   * Updates the given {@link MessageDigest} used to construct a cache key with the given
+   * value using the {@link com.bumptech.glide.load.Option.CacheKeyUpdater} optionally provided in
+   * the constructor.
+   */
+  public void update(T value, MessageDigest messageDigest) {
+    cacheKeyUpdater.update(getKeyBytes(), value, messageDigest);
+  }
+
+  private byte[] getKeyBytes() {
+    if (keyBytes == null) {
+      keyBytes = key.getBytes(Key.CHARSET);
+    }
+    return keyBytes;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof Option) {
+      Option<?> other = (Option<?>) o;
+      return key.equals(other.key);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return key.hashCode();
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> CacheKeyUpdater<T> emptyUpdater() {
+    return (CacheKeyUpdater<T>) EMPTY_UPDATER;
+  }
+
+  @Override
+  public String toString() {
+    return "Option{"
+        + "key='" + key + '\''
+        + '}';
+  }
+
+  /**
+   * An interface that updates a {@link MessageDigest} with the given value as part of a process to
+   * generate a disk cache key.
+   */
+  public interface CacheKeyUpdater<T> {
+    /**
+     * Updates the given {@link MessageDigest} with the bytes of the given key (to avoid incidental
+     * value collisions when values are not particularly unique) and value.
+     */
+    void update(byte[] keyBytes, T value, MessageDigest messageDigest);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/Options.java b/library/src/main/java/com/bumptech/glide/load/Options.java
new file mode 100644
index 000000000..909cb3620
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/Options.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.load;
+
+import android.support.v4.util.ArrayMap;
+import android.support.v4.util.SimpleArrayMap;
+
+import java.security.MessageDigest;
+import java.util.Map;
+
+/**
+ * A set of {@link Option Options} to apply to in memory and disk cache keys.
+ */
+public final class Options implements Key {
+  private final ArrayMap<Option<?>, Object> values = new ArrayMap<>();
+
+  public void putAll(Options other) {
+    values.putAll((SimpleArrayMap<Option<?>, Object>) other.values);
+  }
+
+  public <T> Options set(Option<T> option, T value) {
+    values.put(option, value);
+    return this;
+  }
+
+  @SuppressWarnings("unchecked")
+  public <T> T get(Option<T> option) {
+    return values.containsKey(option) ? (T) values.get(option) : option.getDefaultValue();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof Options) {
+      Options other = (Options) o;
+      return values.equals(other.values);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return values.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    for (Map.Entry<Option<?>, Object> entry : values.entrySet()) {
+      updateDiskCacheKey(entry.getKey(), entry.getValue(), messageDigest);
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "Options{"
+        + "values=" + values
+        + '}';
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> void updateDiskCacheKey(Option<T> option, Object value, MessageDigest md) {
+    option.update((T) value, md);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index 3de450f63..ebac41d1e 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.Nullable;
+
 import com.bumptech.glide.load.engine.Resource;
 
 import java.io.IOException;
@@ -12,34 +14,48 @@
  */
 public interface ResourceDecoder<T, Z> {
 
-    /**
-     * Returns a decoded resource from the given data or null if no resource could be decoded.
-     * <p>
-     *     The {@code source} is managed by the caller, there's no need to close it.
-     *     The returned {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit.
-     * </p>
-     * <p>
-     *     Note - The {@code width} and {@code height} arguments are hints only,
-     *     there is no requirement that the decoded resource exactly match the given dimensions.
-     *     A typical use case would be to use the target dimensions to determine
-     *     how much to downsample Bitmaps by to avoid overly large allocations.
-     * </p>
-     *
-     * @param source The data the resource should be decoded from.
-     * @param width The ideal width in pixels of the decoded resource.
-     * @param height The ideal height in pixels of the decoded resource.
-     * @throws IOException
-     */
-    Resource<Z> decode(T source, int width, int height) throws IOException;
+  /**
+   * Returns {@code true} if this decoder is capable of decoding the given source with the given
+   * options, and {@code false} otherwise.
+   *
+   * <p> Decoders should make a best effort attempt to quickly determine if they are likely to be
+   * able to decode data, but should not attempt to completely read the given data. A typical
+   * implementation would check the file headers verify they match content the decoder expects to
+   * handle (ie a GIF decoder should verify that the image contains the GIF header block. </p>
+   *
+   * <p> Decoders that return {@code true} from {@link #handles(Object, Options)} may still
+   * return {@code null} from {@link #decode(Object, int, int, Options)} if the data is
+   * partial or formatted incorrectly. </p>
+   *
+   * @throws IOException
+   */
+  boolean handles(T source, Options options) throws IOException;
 
-    /**
-     * Returns an ID identifying any transformation this decoder may apply to the given data that will be mixed in to
-     * the cache key.
-     *
-     * <p>
-     *     If the decoder does not transform the data in a way that significantly affects the cached
-     *     result (ie performs no downsampling) an empty string is an appropriate id.
-     * </p>
-     */
-    String getId();
+  /**
+   * Returns a decoded resource from the given data or null if no resource could be decoded.
+   *
+   * <p> The {@code source} is managed by the caller, there's no need to close it. The returned
+   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit. </p>
+   *
+   * <p> Note - The {@code width} and {@code height} arguments are hints only, there is no
+   * requirement that the decoded resource exactly match the given dimensions. A typical use case
+   * would be to use the target dimensions to determine how much to downsample Bitmaps by to avoid
+   * overly large allocations. </p>
+   *
+   * @param source  The data the resource should be decoded from.
+   * @param width   The ideal width in pixels of the decoded resource, or {@link
+   *                com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original
+   *                resource width.
+   * @param height  The ideal height in pixels of the decoded resource, or {@link
+   *                com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original
+   *                resource height.
+   * @param options A map of string keys to objects that may or may not contain options available to
+   *                this particular implementation. Implementations should not assume that any or
+   *                all of their option keys are present. However, implementations may assume that
+   *                if one of their option keys is present, it's value is non-null and is of the
+   *                expected type.
+   * @throws IOException
+   */
+  @Nullable
+  Resource<Z> decode(T source, int width, int height, Options options) throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
index afa258b43..941d3845d 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
@@ -3,10 +3,12 @@
 import com.bumptech.glide.load.engine.Resource;
 
 /**
- * An interface for writing data from a resource to some persistent data store (i.e. a local File cache).
+ * An interface for writing data from a resource to some persistent data store (i.e. a local File
+ * cache).
  *
  * @param <T> The type of the data contained by the resource.
  */
 public interface ResourceEncoder<T> extends Encoder<Resource<T>> {
-    // specializing the generic arguments
+  // specializing the generic arguments
+  EncodeStrategy getEncodeStrategy(Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index ae7f3ffef..b11a635bd 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -3,41 +3,51 @@
 import com.bumptech.glide.load.engine.Resource;
 
 /**
- * A class for performing an arbitrary transformation on a resource.
+ * A class for performing an arbitrary transformation on a resource that implements
+ * {@link #equals(Object)} and {@link #hashCode()}} to identify the transformation in the memory
+ * cache and {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the
+ * transformation in disk caches.
+ *
+ * <p>Using the fully qualified class name (not {@link Class#getName()} to avoid proguard
+ * obfuscation) is an easy way to implement
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly.
  *
  * @param <T> The type of the resource being transformed.
  */
-public interface Transformation<T> {
-
-    /**
-     * Transforms the given resource and returns the transformed resource.
-     *
-     * <p>
-     *     Note - If the original resource object is not returned, the original resource will be recycled and it's
-     *     internal resources may be reused. This means it is not safe to rely on the original resource or any internal
-     *     state of the original resource in any new resource that is created. Usually this shouldn't occur, but if
-     *     absolutely necessary either the original resource object can be returned with modified internal state, or
-     *     the data in the original resource can be copied into the transformed resource.
-     * </p>
-     *
-     * @param resource The resource to transform.
-     * @param outWidth The width of the view or target the resource will be displayed in.
-     * @param outHeight The height of the view or target the resource will be displayed in.
-     * @return The transformed resource.
-     */
-    Resource<T> transform(Resource<T> resource, int outWidth, int outHeight);
+public interface Transformation<T> extends Key {
 
-    /**
-     * A method to get a unique identifier for this particular transformation that can be used as part of a cache key.
-     * The fully qualified class name for this class is appropriate if written out, but getClass().getName() is not
-     * because the name may be changed by proguard.
-     *
-     * <p>
-     *     If this transformation does not affect the data that will be stored in cache, returning an empty string here
-     *     is acceptable.
-     * </p>
-     *
-     * @return A string that uniquely identifies this transformation.
-     */
-    String getId();
+  /**
+   * Transforms the given resource and returns the transformed resource.
+   *
+   * <p>If the original resource object is not returned, the original resource will be
+   * recycled and it's internal resources may be reused. This means it is not safe to rely on the
+   * original resource or any internal state of the original resource in any new resource that is
+   * created. Usually this shouldn't occur, but if absolutely necessary either the original resource
+   * object can be returned with modified internal state, or the data in the original resource can
+   * be copied into the transformed resource.
+   *
+   * <p>If a Transformation is updated, {@link #equals(Object)}, {@link #hashCode()}, and
+   * {@link #updateDiskCacheKey(java.security.MessageDigest)} should all change. If you're using a
+   * simple String key an easy way to do this is to append a version number to your key. Failing to
+   * do so will mean users may see images loaded from cache that had the old version of the
+   * Transformation applied. Changing the return values of those methods will ensure that the cache
+   * key has changed and therefore that any cached resources will be re-generated using the updated
+   * Transformation.
+   *
+   * <p>During development you may need to either using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} or make sure {@link
+   * #updateDiskCacheKey(java.security.MessageDigest)} changes each time you make a change to the
+   * Transformation. Otherwise the resource you request may be loaded from disk cache and your
+   * Transformation may not be called.
+   *
+   * @param resource  The resource to transform.
+   * @param outWidth  The width of the view or target the resource will be displayed in, or {@link
+   *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
+   *                  original resource width.
+   * @param outHeight The height of the view or target the resource will be displayed in, or {@link
+   *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
+   *                  original resource height.
+   * @return The transformed resource.
+   */
+  Resource<T> transform(Resource<T> resource, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 7c9e62293..823ed42bf 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -4,70 +4,77 @@
 import android.util.Log;
 
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 
 import java.io.IOException;
 
 /**
- * An abstract class for obtaining data for an asset path using an {@link android.content.res.AssetManager}.
+ * An abstract class for obtaining data for an asset path using an {@link
+ * android.content.res.AssetManager}.
  *
  * @param <T> The type of data obtained from the asset path (InputStream, FileDescriptor etc).
  */
 public abstract class AssetPathFetcher<T> implements DataFetcher<T> {
-    private static final String TAG = "AssetUriFetcher";
-    private final String assetPath;
-    private final AssetManager assetManager;
-    private T data;
+  private static final String TAG = "AssetPathFetcher";
+  private final String assetPath;
+  private final AssetManager assetManager;
+  private T data;
 
-    public AssetPathFetcher(AssetManager assetManager, String assetPath) {
-        this.assetManager = assetManager;
-        this.assetPath = assetPath;
-    }
+  public AssetPathFetcher(AssetManager assetManager, String assetPath) {
+    this.assetManager = assetManager;
+    this.assetPath = assetPath;
+  }
 
-    @Override
-    public T loadData(Priority priority) throws Exception {
-        data = loadResource(assetManager, assetPath);
-        return data;
+  @Override
+  public void loadData(Priority priority, DataCallback<? super T> callback) {
+    try {
+      data = loadResource(assetManager, assetPath);
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to load data from asset manager", e);
+      }
+      callback.onLoadFailed(e);
+      return;
     }
+    callback.onDataReady(data);
+  }
 
-    @Override
-    public void cleanup() {
-        if (data == null) {
-            return;
-        }
-        try {
-            close(data);
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "Failed to close data", e);
-            }
-        }
-
+  @Override
+  public void cleanup() {
+    if (data == null) {
+      return;
     }
-
-    @Override
-    public String getId() {
-        return assetPath;
+    try {
+      close(data);
+    } catch (IOException e) {
+      // Ignored.
     }
+  }
 
-    @Override
-    public void cancel() {
-        // Do nothing.
-    }
+  @Override
+  public void cancel() {
+    // Do nothing.
+  }
+
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.LOCAL;
+  }
 
-    /**
-     * Opens the given asset path with the given {@link android.content.res.AssetManager} and returns the conrete data
-     * type returned by the AssetManager.
-     *
-     * @param assetManager An AssetManager to use to open the given path.
-     * @param path A string path pointing to a resource in assets to open.
-     */
-    protected abstract T loadResource(AssetManager assetManager, String path) throws IOException;
+  /**
+   * Opens the given asset path with the given {@link android.content.res.AssetManager} and returns
+   * the conrete data type returned by the AssetManager.
+   *
+   * @param assetManager An AssetManager to use to open the given path.
+   * @param path         A string path pointing to a resource in assets to open.
+   */
+  protected abstract T loadResource(AssetManager assetManager, String path) throws IOException;
 
-    /**
-     * Closes the concrete data type if necessary.
-     *
-     * @param data The data to close.
-     * @throws IOException
-     */
-    protected abstract void close(T data) throws IOException;
+  /**
+   * Closes the concrete data type if necessary.
+   *
+   * @param data The data to close.
+   * @throws IOException
+   */
+  protected abstract void close(T data) throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java
deleted file mode 100644
index ff4269c22..000000000
--- a/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import com.bumptech.glide.Priority;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-
-/**
- * A simple resource fetcher to convert byte arrays into input stream. Requires an id to be passed in to identify the
- * data in the byte array because there is no cheap/simple way to obtain a useful id from the data itself.
- */
-public class ByteArrayFetcher implements DataFetcher<InputStream> {
-    private final byte[] bytes;
-    private final String id;
-
-    public ByteArrayFetcher(byte[] bytes, String id) {
-        this.bytes = bytes;
-        this.id = id;
-    }
-
-    @Override
-    public InputStream loadData(Priority priority) {
-        return new ByteArrayInputStream(bytes);
-    }
-
-    @Override
-    public void cleanup() {
-        // Do nothing. It's safe to leave a ByteArrayInputStream open.
-    }
-
-    @Override
-    public String getId() {
-        return id;
-    }
-
-    @Override
-    public void cancel() {
-        // Do nothing.
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index e192827e8..1bd464284 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -1,76 +1,93 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.Nullable;
+
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 
 /**
- * An interface for lazily retrieving data that can be used to load a resource. A new instance is created per
- * resource load by {@link com.bumptech.glide.load.model.ModelLoader}. {@link #loadData(Priority)} may or may not be
- * called for any given load depending on whether or not the corresponding resource is cached. Cancel also may or may
- * not be called. If {@link #loadData(Priority)} is called, then so {@link #cleanup()} will be called.
+ * Lazily retrieves data that can be used to load a resource.
+ *
+ * <p> A new instance is
+ * created per resource load by {@link com.bumptech.glide.load.model.ModelLoader}. {@link
+ * #loadData(com.bumptech.glide.Priority, com.bumptech.glide.load.data.DataFetcher.DataCallback)}
+ * may or may not be called for any given load depending on whether or not the corresponding
+ * resource is cached. Cancel also may or may not be called. If
+ * {@link #loadData(com.bumptech.glide.Priority,
+ * com.bumptech.glide.load.data.DataFetcher.DataCallback)}} is called, then so {@link #cleanup()}
+ * will be called. </p>
  *
  * @param <T> The type of data to be loaded (InputStream, byte[], File etc).
  */
 public interface DataFetcher<T> {
 
+  /**
+   * Callback that should be called when data has been loaded and is available, or when the load
+   * fails.
+   *
+   * @param <T> The type of data that will be loaded.
+   */
+  interface DataCallback<T> {
     /**
-     * Asynchronously fetch data from which a resource can be decoded. This will always be called on
-     * background thread so it is safe to perform long running tasks here. Any third party libraries called
-     * must be thread safe since this method will be called from a thread in a
-     * {@link java.util.concurrent.ExecutorService} that may have more than one background thread.
-     *
-     * This method will only be called when the corresponding resource is not in the cache.
-     *
-     * <p>
-     *     Note - this method will be run on a background thread so blocking I/O is safe.
-     * </p>
-     *
-     * @param priority The priority with which the request should be completed.
-     * @see #cleanup() where the data retuned will be cleaned up
+     * Called with the loaded data if the load succeeded, or with {@code null} if the load failed.
      */
-    T loadData(Priority priority) throws Exception;
+    void onDataReady(@Nullable T data);
 
     /**
-     * Cleanup or recycle any resources used by this data fetcher. This method will be called in a finally block
-     * after the data returned by {@link #loadData(Priority)} has been decoded by the
-     * {@link com.bumptech.glide.load.ResourceDecoder}.
-     *
-     * <p>
-     *     Note - this method will be run on a background thread so blocking I/O is safe.
-     * </p>
-     *
+     * Called when the load fails.
+     * @param e a non-null {@link Exception} indicating why the load failed.
      */
-    void cleanup();
+    void onLoadFailed(Exception e);
+  }
 
-    /**
-     * Returns a string uniquely identifying the data that this fetcher will fetch including the specific size.
-     *
-     * <p>
-     *     A hash of the bytes of the data that will be fetched is the ideal id but since that is in many cases
-     *     impractical, urls, file paths, and uris are normally sufficient.
-     * </p>
-     *
-     * <p>
-     *     Note - this method will be run on the main thread so it should not perform blocking operations and should
-     *     finish quickly.
-     * </p>
-     */
-    String getId();
+  /**
+   * Synchronously fetch data from which a resource can be decoded.
+   *
+   * <p> This will always be called on
+   * background thread so it is safe to perform long running tasks here. Any third party libraries
+   * called must be thread safe since this method will be called from a thread in a {@link
+   * java.util.concurrent.ExecutorService} that may have more than one background thread. </p>
+   *
+   * <p> This method will only be called when the corresponding resource is not in the cache. </p>
+   *
+   * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
+   *
+   * @param priority The priority with which the request should be completed.
+   * @see #cleanup() where the data retuned will be cleaned up
+   */
+  void loadData(Priority priority, DataCallback<? super T> callback);
 
-    /**
-     * A method that will be called when a load is no longer relevant and has been cancelled. This method does not need
-     * to guarantee that any in process loads do not finish. It also may be called before a load starts or after it
-     * finishes.
-     *
-     * <p>
-     *  The best way to use this method is to cancel any loads that have not yet started, but allow those that are in
-     *  process to finish since its we typically will want to display the same resource in a different view in
-     *  the near future.
-     * </p>
-     *
-     * <p>
-     *     Note - this method will be run on the main thread so it should not perform blocking operations and should
-     *     finish quickly.
-     * </p>
-     */
-    void cancel();
+  /**
+   * Cleanup or recycle any resources used by this data fetcher. This method will be called in a
+   * finally block after the data provided by {@link #loadData(com.bumptech.glide.Priority,
+   * com.bumptech.glide.load.data.DataFetcher.DataCallback)} has been decoded by the
+   * {@link com.bumptech.glide.load.ResourceDecoder}.
+   *
+   * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
+   */
+  void cleanup();
+
+  /**
+   * A method that will be called when a load is no longer relevant and has been cancelled. This
+   * method does not need to guarantee that any in process loads do not finish. It also may be
+   * called before a load starts or after it finishes.
+   *
+   * <p> The best way to use this method is to cancel any loads that have not yet started, but allow
+   * those that are in process to finish since its we typically will want to display the same
+   * resource in a different view in the near future. </p>
+   *
+   * <p> Note - this method will be run on the main thread so it should not perform blocking
+   * operations and should finish quickly. </p>
+   */
+  void cancel();
+
+  /**
+   * Returns the class of the data this fetcher will attempt to obtain.
+   */
+  Class<T> getDataClass();
+
+  /**
+   * Returns the {@link com.bumptech.glide.load.DataSource} this fetcher will return data from.
+   */
+  DataSource getDataSource();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
new file mode 100644
index 000000000..73dd6411e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
@@ -0,0 +1,47 @@
+package com.bumptech.glide.load.data;
+
+import java.io.IOException;
+
+/**
+ * Responsible for rewinding a stream like data types.
+ *
+ * @param <T> The stream like data type that can be rewound.
+ */
+public interface DataRewinder<T> {
+
+  /**
+   * A factory interface for producing individual
+   * {@link com.bumptech.glide.load.data.DataRewinder}s.
+   *
+   * @param <T> The type of data that the {@link com.bumptech.glide.load.data.DataRewinder} will
+   *            wrap.
+   */
+  interface Factory<T> {
+    /**
+     * Returns a new {@link com.bumptech.glide.load.data.DataRewinder} wrapping the given data.
+     */
+    DataRewinder<T> build(T data);
+
+    /**
+     * Returns the class of data this factory can produce
+     * {@link com.bumptech.glide.load.data.DataRewinder}s for.
+     */
+    Class<T> getDataClass();
+  }
+
+  /**
+   * Rewinds the wrapped data back to the position it was at when this object was instantiated and
+   * returns the re-wound data (or a wrapper for the re-wound data).
+   *
+   * @return An object pointing to the wrapped data.
+   * @throws IOException
+   */
+  T rewindAndGet() throws IOException;
+
+  /**
+   * Called when this rewinder is no longer needed and can be cleaned up.
+   *
+   * <p> The underlying data may still be in use and should not be closed or invalidated. </p>
+   */
+  void cleanup();
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
new file mode 100644
index 000000000..63914f07c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
@@ -0,0 +1,66 @@
+package com.bumptech.glide.load.data;
+
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Stores a mapping of data class to {@link com.bumptech.glide.load.data.DataRewinder.Factory} and
+ * allows  registation of new types and factories.
+ */
+public class DataRewinderRegistry {
+  private final Map<Class, DataRewinder.Factory> rewinders = new HashMap<>();
+  private static final DataRewinder.Factory DEFAULT_FACTORY = new DataRewinder.Factory<Object>() {
+    @Override
+    public DataRewinder<Object> build(Object data) {
+      return new DefaultRewinder(data);
+    }
+
+    @Override
+    public Class<Object> getDataClass() {
+      throw new UnsupportedOperationException("Not implemented");
+    }
+  };
+
+  public synchronized void register(DataRewinder.Factory factory) {
+    rewinders.put(factory.getDataClass(), factory);
+  }
+
+  @SuppressWarnings("unchecked")
+  public synchronized <T> DataRewinder<T> build(T data) {
+    Preconditions.checkNotNull(data);
+    DataRewinder.Factory result = rewinders.get(data.getClass());
+    if (result == null) {
+      for (DataRewinder.Factory<?> registeredFactory : rewinders.values()) {
+        if (registeredFactory.getDataClass().isAssignableFrom(data.getClass())) {
+          result = registeredFactory;
+          break;
+        }
+      }
+    }
+
+    if (result == null) {
+      result = DEFAULT_FACTORY;
+    }
+    return result.build(data);
+  }
+
+  private static class DefaultRewinder implements DataRewinder<Object> {
+    private final Object data;
+
+    public DefaultRewinder(Object data) {
+      this.data = data;
+    }
+
+    @Override
+    public Object rewindAndGet() {
+      return data;
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
new file mode 100644
index 000000000..de4436d93
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
@@ -0,0 +1,132 @@
+package com.bumptech.glide.load.data;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
+ * image data.
+ *
+ * <p>This class assumes that the wrapped stream contains an image format that can contain
+ * exif information and performs no verification. </p>
+ */
+public final class ExifOrientationStream extends FilterInputStream {
+  /** Allow two bytes for the file format. */
+  private static final int SEGMENT_START_POSITION = 2;
+  private static final byte[] EXIF_SEGMENT = new byte[] {
+      /** segment start id. */
+      (byte) 0xFF,
+      /** segment type. */
+      (byte) 0xE1,
+      /** segmentLength. */
+      0x00,
+      (byte) 0x1C,
+      /** exif identifier. */
+      0x45,
+      0x78,
+      0x69,
+      0x66,
+      0x00,
+      0x00,
+      /** motorola byte order (big endian). */
+      (byte) 0x4D,
+      (byte) 0x4D,
+      /** filler? */
+      0x00,
+      0x00,
+      /** first id offset. */
+      0x00,
+      0x00,
+      0x00,
+      0x08,
+      /** tagCount. */
+      0x00,
+      0x01,
+      /** exif tag type. */
+      0x01,
+      0x12,
+      /** 2 byte format. */
+      0x00,
+      0x02,
+      /** component count. */
+      0x00,
+      0x00,
+      0x00,
+      0x01,
+      /** 2 byte orientation value, the first byte of which is always 0. */
+      0x00,
+  };
+  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
+  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
+  private final byte orientation;
+  private int position;
+
+  public ExifOrientationStream(InputStream in, int orientation) {
+    super(in);
+    if (orientation < -1 || orientation > 8) {
+      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
+    }
+    this.orientation = (byte) orientation;
+  }
+
+  @Override
+  public boolean markSupported() {
+    return false;
+  }
+
+  @Override
+  public void mark(int readlimit) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int read() throws IOException {
+    final int result;
+    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
+      result = super.read();
+    } else if (position == ORIENTATION_POSITION) {
+      result = orientation;
+    } else {
+      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
+    }
+    if (result != -1) {
+      position++;
+    }
+    return result;
+  }
+
+  @Override
+  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    int read;
+    if (position > ORIENTATION_POSITION) {
+      read = super.read(buffer, byteOffset, byteCount);
+    } else if (position == ORIENTATION_POSITION) {
+      buffer[byteOffset] = orientation;
+      read = 1;
+    } else if (position < SEGMENT_START_POSITION) {
+      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
+    } else {
+      read = Math.min(ORIENTATION_POSITION - position, byteCount);
+      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
+    }
+    if (read > 0) {
+      position += read;
+    }
+    return read;
+  }
+
+  @Override
+  public long skip(long byteCount) throws IOException {
+    long skipped = super.skip(byteCount);
+    if (skipped > 0) {
+      position += skipped;
+    }
+    return skipped;
+  }
+
+  @Override
+  public void reset() throws IOException {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
index 16e321310..6adf9ffa5 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
@@ -9,17 +9,23 @@
  * Fetches an {@link android.os.ParcelFileDescriptor} for an asset path.
  */
 public class FileDescriptorAssetPathFetcher extends AssetPathFetcher<ParcelFileDescriptor> {
-    public FileDescriptorAssetPathFetcher(AssetManager assetManager, String assetPath) {
-        super(assetManager, assetPath);
-    }
+  public FileDescriptorAssetPathFetcher(AssetManager assetManager, String assetPath) {
+    super(assetManager, assetPath);
+  }
 
-    @Override
-    protected ParcelFileDescriptor loadResource(AssetManager assetManager, String path) throws IOException {
-        return assetManager.openFd(path).getParcelFileDescriptor();
-    }
+  @Override
+  protected ParcelFileDescriptor loadResource(AssetManager assetManager, String path)
+      throws IOException {
+    return assetManager.openFd(path).getParcelFileDescriptor();
+  }
 
-    @Override
-    protected void close(ParcelFileDescriptor data) throws IOException {
-        data.close();
-    }
+  @Override
+  protected void close(ParcelFileDescriptor data) throws IOException {
+    data.close();
+  }
+
+  @Override
+  public Class<ParcelFileDescriptor> getDataClass() {
+    return ParcelFileDescriptor.class;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 335b4d7a1..76a9ea297 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -12,17 +12,23 @@
  * Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}.
  */
 public class FileDescriptorLocalUriFetcher extends LocalUriFetcher<ParcelFileDescriptor> {
-    public FileDescriptorLocalUriFetcher(Context context, Uri uri) {
-        super(context, uri);
-    }
+  public FileDescriptorLocalUriFetcher(Context context, Uri uri) {
+    super(context, uri);
+  }
 
-    @Override
-    protected ParcelFileDescriptor loadResource(Uri uri, ContentResolver contentResolver) throws FileNotFoundException {
-        return contentResolver.openAssetFileDescriptor(uri, "r").getParcelFileDescriptor();
-    }
+  @Override
+  protected ParcelFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    return contentResolver.openAssetFileDescriptor(uri, "r").getParcelFileDescriptor();
+  }
 
-    @Override
-    protected void close(ParcelFileDescriptor data) throws IOException {
-        data.close();
-    }
+  @Override
+  protected void close(ParcelFileDescriptor data) throws IOException {
+    data.close();
+  }
+
+  @Override
+  public Class<ParcelFileDescriptor> getDataClass() {
+    return ParcelFileDescriptor.class;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index 7662eb2c1..d9062bb12 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -1,123 +1,175 @@
 package com.bumptech.glide.load.data;
 
 import android.text.TextUtils;
+import android.util.Log;
 
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.HttpException;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.ContentLengthInputStream;
+import com.bumptech.glide.util.LogTime;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.util.Map;
 
 /**
  * A DataFetcher that retrieves an {@link java.io.InputStream} for a Url.
  */
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
-    private static final int MAXIMUM_REDIRECTS = 5;
-    private static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY = new DefaultHttpUrlConnectionFactory();
-
-    private final GlideUrl glideUrl;
-    private final HttpUrlConnectionFactory connectionFactory;
-
-    private HttpURLConnection urlConnection;
-    private InputStream stream;
-    private volatile boolean isCancelled;
-
-    public HttpUrlFetcher(GlideUrl glideUrl) {
-        this(glideUrl, DEFAULT_CONNECTION_FACTORY);
+  private static final String TAG = "HttpUrlFetcher";
+  private static final int MAXIMUM_REDIRECTS = 5;
+  private static final int DEFAULT_TIMEOUT_MS = 2500;
+  // Visible for testing.
+  static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
+      new DefaultHttpUrlConnectionFactory();
+
+  private final GlideUrl glideUrl;
+  private final int timeout;
+  private final HttpUrlConnectionFactory connectionFactory;
+
+  private HttpURLConnection urlConnection;
+  private InputStream stream;
+  private volatile boolean isCancelled;
+
+  public HttpUrlFetcher(GlideUrl glideUrl) {
+    this(glideUrl, DEFAULT_TIMEOUT_MS, DEFAULT_CONNECTION_FACTORY);
+  }
+
+  // Visible for testing.
+  HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
+    this.glideUrl = glideUrl;
+    this.timeout = timeout;
+    this.connectionFactory = connectionFactory;
+  }
+
+  @Override
+  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+    long startTime = LogTime.getLogTime();
+    final InputStream result;
+    try {
+      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
+          glideUrl.getHeaders());
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to load data for url", e);
+      }
+      callback.onLoadFailed(e);
+      return;
     }
 
-    // Visible for testing.
-    HttpUrlFetcher(GlideUrl glideUrl, HttpUrlConnectionFactory connectionFactory) {
-        this.glideUrl = glideUrl;
-        this.connectionFactory = connectionFactory;
-    }
-
-    @Override
-    public InputStream loadData(Priority priority) throws Exception {
-        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/);
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime)
+          + " ms and loaded " + result);
     }
+    callback.onDataReady(result);
+  }
+
+  private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
+      Map<String, String> headers) throws IOException {
+    if (redirects >= MAXIMUM_REDIRECTS) {
+      throw new HttpException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
+    } else {
+      // Comparing the URLs using .equals performs additional network I/O and is generally broken.
+      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
+      try {
+        if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
+          throw new HttpException("In re-direct loop");
 
-    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl) throws IOException {
-        if (redirects >= MAXIMUM_REDIRECTS) {
-            throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
-        } else {
-            // Comparing the URLs using .equals performs additional network I/O and is generally broken.
-            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
-            try {
-                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
-                    throw new IOException("In re-direct loop");
-                }
-            } catch (URISyntaxException e) {
-                // Do nothing, this is best effort.
-            }
-        }
-        urlConnection = connectionFactory.build(url);
-        urlConnection.setConnectTimeout(2500);
-        urlConnection.setReadTimeout(2500);
-        urlConnection.setUseCaches(false);
-        urlConnection.setDoInput(true);
-
-        // Connect explicitly to avoid errors in decoders if connection fails.
-        urlConnection.connect();
-        if (isCancelled) {
-            return null;
-        }
-        final int statusCode = urlConnection.getResponseCode();
-        if (statusCode / 100 == 2) {
-            stream = urlConnection.getInputStream();
-            return stream;
-        } else if (statusCode / 100 == 3) {
-            String redirectUrlString = urlConnection.getHeaderField("Location");
-            if (TextUtils.isEmpty(redirectUrlString)) {
-                throw new IOException("Received empty or null redirect url");
-            }
-            URL redirectUrl = new URL(url, redirectUrlString);
-            return loadDataWithRedirects(redirectUrl, redirects + 1, url);
-        } else {
-            if (statusCode == -1) {
-                throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
-            }
-            throw new IOException("Request failed " + statusCode + ": " + urlConnection.getResponseMessage());
         }
+      } catch (URISyntaxException e) {
+        // Do nothing, this is best effort.
+      }
     }
 
-    @Override
-    public void cleanup() {
-        if (stream != null) {
-            try {
-                stream.close();
-            } catch (IOException e) {
-                // Ignore
-            }
-        }
-        if (urlConnection != null) {
-            urlConnection.disconnect();
-        }
+    urlConnection = connectionFactory.build(url);
+    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
+      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
     }
-
-    @Override
-    public String getId() {
-        return glideUrl.toString();
+    urlConnection.setConnectTimeout(timeout);
+    urlConnection.setReadTimeout(timeout);
+    urlConnection.setUseCaches(false);
+    urlConnection.setDoInput(true);
+
+    // Connect explicitly to avoid errors in decoders if connection fails.
+    urlConnection.connect();
+    if (isCancelled) {
+      return null;
     }
-
-    @Override
-    public void cancel() {
-        // TODO: we should consider disconnecting the url connection here, but we can't do so directly because cancel is
-        // often called on the main thread.
-        isCancelled = true;
+    final int statusCode = urlConnection.getResponseCode();
+    if (statusCode / 100 == 2) {
+      return getStreamForSuccessfulRequest(urlConnection);
+    } else if (statusCode / 100 == 3) {
+      String redirectUrlString = urlConnection.getHeaderField("Location");
+      if (TextUtils.isEmpty(redirectUrlString)) {
+        throw new HttpException("Received empty or null redirect url");
+      }
+      URL redirectUrl = new URL(url, redirectUrlString);
+      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
+    } else if (statusCode == -1) {
+      throw new HttpException(statusCode);
+    } else {
+      throw new HttpException(urlConnection.getResponseMessage(), statusCode);
     }
-
-    interface HttpUrlConnectionFactory {
-        HttpURLConnection build(URL url) throws IOException;
+  }
+
+  private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
+      throws IOException {
+    if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
+      int contentLength = urlConnection.getContentLength();
+      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
+    } else {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Got non empty content encoding: " + urlConnection.getContentEncoding());
+      }
+      stream = urlConnection.getInputStream();
     }
-
-    private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
-        @Override
-        public HttpURLConnection build(URL url) throws IOException {
-            return (HttpURLConnection) url.openConnection();
-        }
+    return stream;
+  }
+
+  @Override
+  public void cleanup() {
+    if (stream != null) {
+      try {
+        stream.close();
+      } catch (IOException e) {
+        // Ignore
+      }
+    }
+    if (urlConnection != null) {
+      urlConnection.disconnect();
+    }
+  }
+
+  @Override
+  public void cancel() {
+    // TODO: we should consider disconnecting the url connection here, but we can't do so
+    // directly because cancel is often called on the main thread.
+    isCancelled = true;
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
+
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.REMOTE;
+  }
+
+  interface HttpUrlConnectionFactory {
+    HttpURLConnection build(URL url) throws IOException;
+  }
+
+  private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
+    @Override
+    public HttpURLConnection build(URL url) throws IOException {
+      return (HttpURLConnection) url.openConnection();
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
new file mode 100644
index 000000000..13d0700fd
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.load.data;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Implementation for {@link InputStream}s that rewinds streams by wrapping them in a buffered
+ * stream.
+ */
+public final class InputStreamRewinder implements DataRewinder<InputStream> {
+  // 5mb.
+  private static final int MARK_LIMIT = 5 * 1024 * 1024;
+
+  private final RecyclableBufferedInputStream bufferedStream;
+
+  InputStreamRewinder(InputStream is, ByteArrayPool byteArrayPool) {
+    bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool);
+    bufferedStream.mark(MARK_LIMIT);
+  }
+
+  @Override
+  public InputStream rewindAndGet() throws IOException {
+    bufferedStream.reset();
+    return bufferedStream;
+  }
+
+  @Override
+  public void cleanup() {
+    bufferedStream.release();
+  }
+
+  /**
+   * Factory for producing {@link com.bumptech.glide.load.data.InputStreamRewinder}s from {@link
+   * java.io.InputStream}s.
+   */
+  public static final class Factory implements DataRewinder.Factory<InputStream> {
+    private final ByteArrayPool byteArrayPool;
+
+    public Factory(ByteArrayPool byteArrayPool) {
+      this.byteArrayPool = byteArrayPool;
+    }
+
+    @Override
+    public DataRewinder<InputStream> build(InputStream data) {
+      return new InputStreamRewinder(data, byteArrayPool);
+    }
+
+    @Override
+    public Class<InputStream> getDataClass() {
+      return InputStream.class;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index 8c3a999aa..add61c095 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -6,88 +6,88 @@
 import android.util.Log;
 
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
 /**
- * A DataFetcher that uses an {@link android.content.ContentResolver} to load data from a {@link android.net.Uri}
- * pointing to a local resource.
+ * A DataFetcher that uses an {@link android.content.ContentResolver} to load data from a {@link
+ * android.net.Uri} pointing to a local resource.
  *
- * @param <T> The type of data that will obtained for the given uri (For example, {@link java.io.InputStream} or
- * {@link android.os.ParcelFileDescriptor}.
+ * @param <T> The type of data that will obtained for the given uri (For example, {@link
+ *            java.io.InputStream} or {@link android.os.ParcelFileDescriptor}.
  */
 public abstract class LocalUriFetcher<T> implements DataFetcher<T> {
-    private static final String TAG = "LocalUriFetcher";
-    private final Uri uri;
-    private final Context context;
-    private T data;
+  private static final String TAG = "LocalUriFetcher";
+  private final Uri uri;
+  private final Context context;
+  private T data;
 
-    /**
-     * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
-     *
-     * @see ContentResolver#openInputStream(android.net.Uri)
-     *
-     * @param context A context (this will be weakly referenced and the load will fail if the weak reference
-     *                is cleared before {@link #loadData(Priority)}} is called.
-     * @param uri A Uri pointing to a local asset. This load will fail if the uri isn't openable by
-     *            {@link ContentResolver#openInputStream(android.net.Uri)}
-     */
-    public LocalUriFetcher(Context context, Uri uri) {
-        this.context = context.getApplicationContext();
-        this.uri = uri;
-    }
+  /**
+   * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
+   *
+   * @param context Any {@link android.content.Context}.
+   * @param uri     A Uri pointing to a local asset. This load will fail if the uri isn't openable
+   *                by {@link ContentResolver#openInputStream(android.net.Uri)}
+   * @see ContentResolver#openInputStream(android.net.Uri)
+   */
+  public LocalUriFetcher(Context context, Uri uri) {
+    this.context = context.getApplicationContext();
+    this.uri = uri;
+  }
 
-    @Override
-    public final T loadData(Priority priority) throws Exception {
-        ContentResolver contentResolver = context.getContentResolver();
-        data = loadResource(uri, contentResolver);
-        return data;
+  @Override
+  public final void loadData(Priority priority, DataCallback<? super T> callback) {
+    ContentResolver contentResolver = context.getContentResolver();
+    try {
+      data = loadResource(uri, contentResolver);
+    } catch (FileNotFoundException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to open Uri", e);
+      }
+      callback.onLoadFailed(e);
+      return;
     }
+    callback.onDataReady(data);
+  }
 
-    @Override
-    public void cleanup() {
-        if (data != null) {
-            try {
-                close(data);
-            } catch (IOException e) {
-                if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                    Log.v(TAG, "failed to close data", e);
-                }
-            }
-
-        }
+  @Override
+  public void cleanup() {
+    if (data != null) {
+      try {
+        close(data);
+      } catch (IOException e) {
+        // Ignored.
+      }
     }
+  }
 
-    @Override
-    public void cancel() {
-        // Do nothing.
-    }
-
-    @Override
-    public String getId() {
-        return uri.toString();
-    }
+  @Override
+  public void cancel() {
+    // Do nothing.
+  }
 
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.LOCAL;
+  }
 
-    /**
-     * Returns a concrete data type from the given {@link android.net.Uri} using the given
-     * {@link android.content.ContentResolver}.
-     *
-     * @throws FileNotFoundException
-     */
-    protected abstract T loadResource(Uri uri, ContentResolver contentResolver) throws FileNotFoundException;
+  /**
+   * Returns a concrete data type from the given {@link android.net.Uri} using the given {@link
+   * android.content.ContentResolver}.
+   */
+  protected abstract T loadResource(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException;
 
-    /**
-     * Closes the concrete data type if necessary.
-     *
-     * <p>
-     *     Note - We can't rely on the closeable interface because it was added after our min API level. See issue #157.
-     * </p>
-     *
-     * @param data The data to close.
-     * @throws IOException
-     */
-    protected abstract void close(T data) throws IOException;
+  /**
+   * Closes the concrete data type if necessary.
+   *
+   * <p> Note - We can't rely on the closeable interface because it was added after our min API
+   * level. See issue #157. </p>
+   *
+   * @param data The data to close.
+   */
+  protected abstract void close(T data) throws IOException;
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java
deleted file mode 100644
index b9b622a11..000000000
--- a/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java
+++ /dev/null
@@ -1,194 +0,0 @@
-package com.bumptech.glide.load.data;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.database.Cursor;
-import android.net.Uri;
-import android.provider.MediaStore;
-import android.text.TextUtils;
-
-import com.bumptech.glide.Priority;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * A DataFetcher that retrieves an {@link java.io.InputStream} for a local Uri that may or may not be for a resource
- * in the media store. If the local Uri is for a resource in the media store and the size requested is less than or
- * equal to the media store thumbnail size, preferentially attempts to fetch data for the pre-generated media store
- * thumbs using {@link android.provider.MediaStore.Images.Thumbnails} and
- * {@link android.provider.MediaStore.Video.Thumbnails}.
- */
-public class MediaStoreThumbFetcher implements DataFetcher<InputStream> {
-    private static final int MINI_WIDTH = 512;
-    private static final int MINI_HEIGHT = 384;
-    private static final ThumbnailStreamOpenerFactory DEFAULT_FACTORY = new ThumbnailStreamOpenerFactory();
-
-    private final Context context;
-    private final Uri mediaStoreUri;
-    private final DataFetcher<InputStream> defaultFetcher;
-    private final int width;
-    private final int height;
-    private final ThumbnailStreamOpenerFactory factory;
-    private InputStream inputStream;
-
-    public MediaStoreThumbFetcher(Context context, Uri mediaStoreUri, DataFetcher<InputStream> defaultFetcher,
-            int width, int height) {
-        this(context, mediaStoreUri, defaultFetcher, width, height, DEFAULT_FACTORY);
-    }
-
-    MediaStoreThumbFetcher(Context context, Uri mediaStoreUri, DataFetcher<InputStream> defaultFetcher, int width,
-            int height, ThumbnailStreamOpenerFactory factory) {
-        this.context = context;
-        this.mediaStoreUri = mediaStoreUri;
-        this.defaultFetcher = defaultFetcher;
-        this.width = width;
-        this.height = height;
-        this.factory = factory;
-    }
-
-    @Override
-    public InputStream loadData(Priority priority) throws Exception {
-        ThumbnailStreamOpener fetcher = factory.build(mediaStoreUri, width, height);
-
-        if (fetcher != null) {
-            inputStream = fetcher.open(context, mediaStoreUri);
-        }
-
-        if (inputStream != null) {
-            return inputStream;
-        } else {
-            return defaultFetcher.loadData(priority);
-        }
-    }
-
-    @Override
-    public void cleanup() {
-        if (inputStream != null) {
-            try {
-                inputStream.close();
-            } catch (IOException e) {
-                // Do nothing.
-            }
-        }
-        defaultFetcher.cleanup();
-    }
-
-    @Override
-    public String getId() {
-        return mediaStoreUri.toString();
-    }
-
-    @Override
-    public void cancel() {
-        // Do nothing.
-    }
-
-    private static boolean isMediaStoreUri(Uri uri) {
-        return uri != null
-                && ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())
-                && MediaStore.AUTHORITY.equals(uri.getAuthority());
-    }
-
-    private static boolean isMediaStoreVideo(Uri uri) {
-        return isMediaStoreUri(uri) && uri.getPathSegments().contains("video");
-    }
-
-    static class FileService {
-        public boolean exists(File file) {
-            return file.exists();
-        }
-
-        public long length(File file) {
-            return file.length();
-        }
-
-        public File get(String path) {
-            return new File(path);
-        }
-    }
-
-    interface ThumbnailQuery {
-        Cursor query(Context context, Uri uri);
-    }
-
-    static class ThumbnailStreamOpener {
-        private static final FileService DEFAULT_SERVICE = new FileService();
-        private final FileService service;
-        private ThumbnailQuery query;
-
-        public ThumbnailStreamOpener(ThumbnailQuery query) {
-            this(DEFAULT_SERVICE, query);
-        }
-
-        public ThumbnailStreamOpener(FileService service, ThumbnailQuery query) {
-            this.service = service;
-            this.query = query;
-        }
-
-        public InputStream open(Context context, Uri uri) throws FileNotFoundException {
-            Uri thumbnailUri = null;
-            InputStream inputStream = null;
-
-            final Cursor cursor = query.query(context, uri);
-            try {
-                if (cursor != null && cursor.moveToFirst()) {
-                    String path = cursor.getString(0);
-                    if (!TextUtils.isEmpty(path)) {
-                        File file = service.get(path);
-                        if (service.exists(file) && service.length(file) > 0) {
-                            thumbnailUri = Uri.fromFile(file);
-                        }
-                    }
-                }
-            } finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-            if (thumbnailUri != null) {
-                inputStream = context.getContentResolver().openInputStream(thumbnailUri);
-            }
-            return inputStream;
-        }
-    }
-
-    static class ImageThumbnailQuery implements ThumbnailQuery {
-
-        @Override
-        public Cursor query(Context context, Uri uri) {
-            String id = uri.getLastPathSegment();
-            return context.getContentResolver().query(MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI, new String[] {
-                            MediaStore.Images.Thumbnails.DATA
-                    }, MediaStore.Images.Thumbnails.IMAGE_ID + " = ? AND " + MediaStore.Images.Thumbnails.KIND + " = ?",
-                    new String[] { id, String.valueOf(MediaStore.Images.Thumbnails.MINI_KIND) }, null);
-        }
-    }
-
-    static class VideoThumbnailQuery implements ThumbnailQuery {
-
-        @Override
-        public Cursor query(Context context, Uri uri) {
-            String id = uri.getLastPathSegment();
-            return context.getContentResolver().query(MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI, new String[] {
-                    MediaStore.Video.Thumbnails.DATA
-            }, MediaStore.Video.Thumbnails.VIDEO_ID + " = ? AND " + MediaStore.Video.Thumbnails.KIND + " = ?",
-                    new String[] { id, String.valueOf(MediaStore.Video.Thumbnails.MINI_KIND) }, null);
-        }
-    }
-
-    static class ThumbnailStreamOpenerFactory {
-
-        public ThumbnailStreamOpener build(Uri uri, int width, int height) {
-            if (!isMediaStoreUri(uri) || width > MINI_WIDTH || height > MINI_HEIGHT) {
-                return null;
-            } else if (isMediaStoreVideo(uri)) {
-                return new ThumbnailStreamOpener(new VideoThumbnailQuery());
-            } else {
-                return new ThumbnailStreamOpener(new ImageThumbnailQuery());
-            }
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
index 4d1a540f2..3fb7b3974 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
@@ -9,17 +9,22 @@
  * Fetches an {@link java.io.InputStream} for an asset path.
  */
 public class StreamAssetPathFetcher extends AssetPathFetcher<InputStream> {
-    public StreamAssetPathFetcher(AssetManager assetManager, String assetPath) {
-        super(assetManager, assetPath);
-    }
+  public StreamAssetPathFetcher(AssetManager assetManager, String assetPath) {
+    super(assetManager, assetPath);
+  }
 
-    @Override
-    protected InputStream loadResource(AssetManager assetManager, String path) throws IOException {
-        return assetManager.open(path);
-    }
+  @Override
+  protected InputStream loadResource(AssetManager assetManager, String path) throws IOException {
+    return assetManager.open(path);
+  }
 
-    @Override
-    protected void close(InputStream data) throws IOException {
-        data.close();
-    }
+  @Override
+  protected void close(InputStream data) throws IOException {
+    data.close();
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index d933de1ac..aafdc25aa 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -12,17 +12,23 @@
  * Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}.
  */
 public class StreamLocalUriFetcher extends LocalUriFetcher<InputStream> {
-    public StreamLocalUriFetcher(Context context, Uri uri) {
-        super(context, uri);
-    }
+  public StreamLocalUriFetcher(Context context, Uri uri) {
+    super(context, uri);
+  }
 
-    @Override
-    protected InputStream loadResource(Uri uri, ContentResolver contentResolver) throws FileNotFoundException {
-        return contentResolver.openInputStream(uri);
-    }
+  @Override
+  protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    return contentResolver.openInputStream(uri);
+  }
 
-    @Override
-    protected void close(InputStream data) throws IOException {
-        data.close();
-    }
+  @Override
+  protected void close(InputStream data) throws IOException {
+    data.close();
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/FileService.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/FileService.java
new file mode 100644
index 000000000..7d511373f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/FileService.java
@@ -0,0 +1,17 @@
+package com.bumptech.glide.load.data.mediastore;
+
+import java.io.File;
+
+class FileService {
+  public boolean exists(File file) {
+    return file.exists();
+  }
+
+  public long length(File file) {
+    return file.length();
+  }
+
+  public File get(String path) {
+    return new File(path);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
new file mode 100644
index 000000000..dc6cbef6e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
@@ -0,0 +1,38 @@
+package com.bumptech.glide.load.data.mediastore;
+
+import android.content.ContentResolver;
+import android.net.Uri;
+import android.provider.MediaStore;
+
+/**
+ * Utility classes for interacting with the media store.
+ */
+public final class MediaStoreUtil {
+  private static final int MINI_THUMB_WIDTH = 512;
+  private static final int MINI_THUMB_HEIGHT = 384;
+
+  private MediaStoreUtil() {
+    // Utility class.
+  }
+
+  public static boolean isMediaStoreUri(Uri uri) {
+    return uri != null && ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())
+        && MediaStore.AUTHORITY.equals(uri.getAuthority());
+  }
+
+  private static boolean isVideoUri(Uri uri) {
+    return uri.getPathSegments().contains("video");
+  }
+
+  public static boolean isMediaStoreVideoUri(Uri uri) {
+    return isMediaStoreUri(uri) && isVideoUri(uri);
+  }
+
+  public static boolean isMediaStoreImageUri(Uri uri) {
+    return isMediaStoreUri(uri) && !isVideoUri(uri);
+  }
+
+  public static boolean isThumbnailSize(int width, int height) {
+    return width <= MINI_THUMB_WIDTH && height <= MINI_THUMB_HEIGHT;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
new file mode 100644
index 000000000..307f2385e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -0,0 +1,146 @@
+package com.bumptech.glide.load.data.mediastore;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.MediaStore;
+import android.util.Log;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.ExifOrientationStream;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A {@link DataFetcher} implementation for {@link InputStream}s that loads data from thumbnail
+ * files obtained from the {@link MediaStore}.
+ */
+public class ThumbFetcher implements DataFetcher<InputStream> {
+  private static final String TAG = "MediaStoreThumbFetcher";
+  private final Context context;
+  private final Uri mediaStoreImageUri;
+  private final ThumbnailStreamOpener opener;
+  private InputStream inputStream;
+
+  public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
+    return build(context, uri, new ImageThumbnailQuery());
+  }
+
+  public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
+    return build(context, uri, new VideoThumbnailQuery());
+  }
+
+  private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
+    ByteArrayPool byteArrayPool = Glide.get(context).getByteArrayPool();
+    return new ThumbFetcher(context, uri, new ThumbnailStreamOpener(query, byteArrayPool));
+  }
+
+  // Visible for testing.
+  ThumbFetcher(Context context, Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
+    this.context = context;
+    this.mediaStoreImageUri = mediaStoreImageUri;
+    this.opener = opener;
+  }
+
+  @Override
+  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+    try {
+      inputStream = openThumbInputStream();
+    } catch (FileNotFoundException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to find thumbnail file", e);
+      }
+      callback.onLoadFailed(e);
+      return;
+    }
+
+    callback.onDataReady(inputStream);
+  }
+
+  private InputStream openThumbInputStream() throws FileNotFoundException {
+    InputStream result = opener.open(context, mediaStoreImageUri);
+
+    int orientation = -1;
+    if (result != null) {
+      orientation = opener.getOrientation(context, mediaStoreImageUri);
+    }
+
+    if (orientation != -1) {
+      result = new ExifOrientationStream(result, orientation);
+    }
+    return result;
+  }
+
+  @Override
+  public void cleanup() {
+    if (inputStream != null) {
+      try {
+        inputStream.close();
+      } catch (IOException e) {
+        // Ignored.
+      }
+    }
+  }
+
+  @Override
+  public void cancel() {
+    // Do nothing.
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
+
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.LOCAL;
+  }
+
+  static class VideoThumbnailQuery implements ThumbnailQuery {
+    private static final String[] PATH_PROJECTION = {
+      MediaStore.Video.Thumbnails.DATA
+    };
+    private static final String PATH_SELECTION =
+        MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
+        + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
+
+    @Override
+    public Cursor query(Context context, Uri uri) {
+      String videoId = uri.getLastPathSegment();
+      return context.getContentResolver().query(
+          MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
+          PATH_PROJECTION,
+          PATH_SELECTION,
+          new String[] { videoId },
+          null /*sortOrder*/);
+    }
+  }
+
+
+  static class ImageThumbnailQuery implements ThumbnailQuery {
+    private static final String[] PATH_PROJECTION = {
+      MediaStore.Images.Thumbnails.DATA,
+    };
+    private static final String PATH_SELECTION =
+        MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
+        + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
+
+    @Override
+    public Cursor query(Context context, Uri uri) {
+      String imageId = uri.getLastPathSegment();
+      return context.getContentResolver().query(
+          MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
+          PATH_PROJECTION,
+          PATH_SELECTION,
+          new String[] { imageId },
+          null /*sortOrder*/);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
new file mode 100644
index 000000000..befebff43
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.load.data.mediastore;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+
+interface ThumbnailQuery {
+  Cursor query(Context context, Uri uri);
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
new file mode 100644
index 000000000..9b9f899f8
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -0,0 +1,85 @@
+package com.bumptech.glide.load.data.mediastore;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+
+class ThumbnailStreamOpener {
+  private static final String TAG = "ThumbStreamOpener";
+  private static final FileService DEFAULT_SERVICE = new FileService();
+  private final FileService service;
+  private final ThumbnailQuery query;
+  private final ByteArrayPool byteArrayPool;
+
+  public ThumbnailStreamOpener(ThumbnailQuery query, ByteArrayPool byteArrayPool) {
+    this(DEFAULT_SERVICE, query, byteArrayPool);
+  }
+
+  public ThumbnailStreamOpener(FileService service, ThumbnailQuery query,
+      ByteArrayPool byteArrayPool) {
+    this.service = service;
+    this.query = query;
+    this.byteArrayPool = byteArrayPool;
+  }
+
+  public int getOrientation(Context context, Uri uri) {
+    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
+    InputStream is = null;
+    try {
+      is = context.getContentResolver().openInputStream(uri);
+      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Failed to open uri: " + uri, e);
+      }
+    } finally {
+      if (is != null) {
+          try {
+              is.close();
+          } catch (IOException e) {
+              // Ignored.
+          }
+      }
+    }
+    return orientation;
+  }
+
+  public InputStream open(Context context, Uri uri) throws FileNotFoundException {
+    Uri thumbnailUri = null;
+    InputStream inputStream = null;
+
+    final Cursor cursor = query.query(context, uri);
+    try {
+      if (cursor == null || !cursor.moveToFirst()) {
+        return null;
+      }
+      String path = cursor.getString(0);
+      if (TextUtils.isEmpty(path)) {
+        return null;
+      }
+
+      File file = service.get(path);
+      if (service.exists(file) && service.length(file) > 0) {
+        thumbnailUri = Uri.fromFile(file);
+      }
+    } finally {
+      if (cursor != null) {
+        cursor.close();
+      }
+    }
+    if (thumbnailUri != null) {
+      inputStream = context.getContentResolver().openInputStream(thumbnailUri);
+    }
+    return inputStream;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/CacheLoader.java b/library/src/main/java/com/bumptech/glide/load/engine/CacheLoader.java
deleted file mode 100644
index eb4304f7c..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/CacheLoader.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import android.util.Log;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.cache.DiskCache;
-
-import java.io.File;
-import java.io.IOException;
-
-class CacheLoader {
-    private static final String TAG = "CacheLoader";
-    private final DiskCache diskCache;
-
-    public CacheLoader(DiskCache diskCache) {
-        this.diskCache = diskCache;
-    }
-
-    public <Z> Resource<Z> load(Key key, ResourceDecoder<File, Z> decoder, int width, int height) {
-        File fromCache = diskCache.get(key);
-        if (fromCache == null) {
-            return null;
-        }
-
-        Resource<Z> result = null;
-        try {
-            result = decoder.decode(fromCache, width, height);
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Exception decoding image from cache", e);
-            }
-        }
-        if (result == null) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Failed to decode image from cache or not present in cache");
-            }
-            diskCache.delete(key);
-        }
-        return result;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
new file mode 100644
index 000000000..bb8284dec
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.load.engine;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoader.LoadData;
+
+import java.io.File;
+import java.util.List;
+
+/**
+ * Generates {@link com.bumptech.glide.load.data.DataFetcher DataFetchers} from cache files
+ * containing original unmodified source data.
+ */
+class DataCacheGenerator implements DataFetcherGenerator,
+    DataFetcher.DataCallback<Object> {
+
+  private List<Key> cacheKeys;
+  private final DecodeHelper<?> helper;
+  private final FetcherReadyCallback cb;
+
+  private int sourceIdIndex = -1;
+  private Key sourceKey;
+  private List<ModelLoader<File, ?>> modelLoaders;
+  private int modelLoaderIndex;
+  private volatile LoadData<?> loadData;
+  // PMD is wrong here, this File must be an instance variable because it may be used across
+  // multiple calls to startNext.
+  @SuppressWarnings("PMD.SingularField")
+  private File cacheFile;
+
+  DataCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+    this(helper.getCacheKeys(), helper, cb);
+  }
+
+  // In some cases we may want to load a specific cache key (when loading from source written to
+  // cache), so we accept a list of keys rather than just obtain the list from the helper.
+  DataCacheGenerator(List<Key> cacheKeys, DecodeHelper<?> helper, FetcherReadyCallback cb) {
+    this.cacheKeys = cacheKeys;
+    this.helper = helper;
+    this.cb = cb;
+  }
+
+  @Override
+  public boolean startNext() {
+    while (modelLoaders == null || !hasNextModelLoader()) {
+      sourceIdIndex++;
+      if (sourceIdIndex >= cacheKeys.size()) {
+        return false;
+      }
+
+      Key sourceId = cacheKeys.get(sourceIdIndex);
+      Key originalKey = new DataCacheKey(sourceId, helper.getSignature());
+      cacheFile = helper.getDiskCache().get(originalKey);
+      if (cacheFile != null) {
+        this.sourceKey = sourceId;
+        modelLoaders = helper.getModelLoaders(cacheFile);
+        modelLoaderIndex = 0;
+      }
+    }
+
+    loadData = null;
+    boolean started = false;
+    while (!started && hasNextModelLoader()) {
+      ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
+      loadData =
+          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
+              helper.getOptions());
+      if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
+        started = true;
+        loadData.fetcher.loadData(helper.getPriority(), this);
+      }
+    }
+    return started;
+  }
+
+  private boolean hasNextModelLoader() {
+    return modelLoaderIndex < modelLoaders.size();
+  }
+
+  @Override
+  public void cancel() {
+    LoadData<?> local = loadData;
+    if (local != null) {
+      local.fetcher.cancel();
+    }
+  }
+
+  @Override
+  public void onDataReady(Object data) {
+    cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey);
+  }
+
+  @Override
+  public void onLoadFailed(Exception e) {
+    cb.onDataFetcherFailed(sourceKey, e, loadData.fetcher, DataSource.DATA_DISK_CACHE);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
new file mode 100644
index 000000000..36e9ac5fb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
@@ -0,0 +1,53 @@
+package com.bumptech.glide.load.engine;
+
+import com.bumptech.glide.load.Key;
+
+import java.security.MessageDigest;
+
+/**
+ * A cache key for original source data + any requested signature.
+ */
+final class DataCacheKey implements Key {
+
+  private final Key sourceKey;
+  private final Key signature;
+
+  public DataCacheKey(Key sourceKey, Key signature) {
+    this.sourceKey = sourceKey;
+    this.signature = signature;
+  }
+
+  public Key getSourceKey() {
+    return sourceKey;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof DataCacheKey) {
+      DataCacheKey other = (DataCacheKey) o;
+      return sourceKey.equals(other.sourceKey) && signature.equals(other.signature);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = sourceKey.hashCode();
+    result = 31 * result + signature.hashCode();
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "DataCacheKey{"
+        + "sourceKey=" + sourceKey
+        + ", signature=" + signature
+        + '}';
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    sourceKey.updateDiskCacheKey(messageDigest);
+    signature.updateDiskCacheKey(messageDigest);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
new file mode 100644
index 000000000..85e274eca
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.load.engine;
+
+import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+
+import java.io.File;
+
+/**
+ * Writes original source data or downsampled/transformed resource data to cache using the
+ * provided {@link com.bumptech.glide.load.Encoder} or
+ * {@link com.bumptech.glide.load.ResourceEncoder} and the given data or
+ * {@link com.bumptech.glide.load.engine.Resource}.
+ *
+ * @param <DataType> The type of data that will be encoded (InputStream, ByteBuffer,
+ *                  Resource<Bitmap> etc).
+ */
+class DataCacheWriter<DataType> implements DiskCache.Writer {
+  private final Encoder<DataType> encoder;
+  private final DataType data;
+  private final Options options;
+
+  DataCacheWriter(Encoder<DataType> encoder, DataType data, Options options) {
+    this.encoder = encoder;
+    this.data = data;
+    this.options = options;
+  }
+
+  @Override
+  public boolean write(File file) {
+    return encoder.encode(data, file, options);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
new file mode 100644
index 000000000..bd1899d7a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.data.DataFetcher;
+
+/**
+ * Generates a series of {@link com.bumptech.glide.load.data.DataFetcher DataFetchers} using
+ * registered {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders} and a model.
+ */
+interface DataFetcherGenerator {
+  /**
+   * Called when the generator has finished loading data from a
+   * {@link com.bumptech.glide.load.data.DataFetcher}.
+   */
+  interface FetcherReadyCallback {
+
+    /**
+     * Requests that we call startNext() again on a Glide owned thread.
+     */
+    void reschedule();
+
+    /**
+     * Notifies the callback that the load is complete.
+     *
+     * @param sourceKey The id of the loaded data.
+     * @param data The loaded data, or null if the load failed.
+     * @param fetcher The data fetcher we attempted to load from.
+     * @param dataSource The data souce we were loading from.
+     * @param attemptedKey The key we were loading data from (may be an alternate).
+     */
+    void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,
+        DataSource dataSource, Key attemptedKey);
+
+    /**
+     * Notifies the callback when the load fails.
+     *
+     * @param attemptedKey The key we were using to load (may be an alternate).
+     * @param e The exception that caused the load to fail.
+     * @param fetcher The fetcher we were loading from.
+     * @param dataSource The data source we were loading from.
+     */
+    void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
+        DataSource dataSource);
+  }
+
+  /**
+   * Attempts to a single new {@link com.bumptech.glide.load.data.DataFetcher} and returns true if
+   * a {@link com.bumptech.glide.load.data.DataFetcher} was started, and false otherwise.
+   */
+  boolean startNext();
+
+  /**
+   * Attempts to cancel the currently running fetcher.
+   *
+   * <p> This will be called on the main thread and should complete quickly. </p>
+   */
+  void cancel();
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
new file mode 100644
index 000000000..3a010fed0
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -0,0 +1,212 @@
+package com.bumptech.glide.load.engine;
+
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoader.LoadData;
+import com.bumptech.glide.load.resource.UnitTransformation;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+final class DecodeHelper<Transcode> {
+
+  private final List<LoadData<?>> loadData = new ArrayList<>();
+  private final List<Key> cacheKeys = new ArrayList<>();
+
+  private GlideContext glideContext;
+  private Object model;
+  private int width;
+  private int height;
+  private Class<?> resourceClass;
+  private DecodeJob.DiskCacheProvider diskCacheProvider;
+  private Options options;
+  private Map<Class<?>, Transformation<?>> transformations;
+  private Class<Transcode> transcodeClass;
+  private boolean isLoadDataSet;
+  private boolean isCacheKeysSet;
+  private Key signature;
+  private Priority priority;
+  private DiskCacheStrategy diskCacheStrategy;
+  private boolean isTransformationRequired;
+
+  @SuppressWarnings("unchecked")
+  <R> DecodeHelper<R> init(
+      GlideContext glideContext,
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      DiskCacheStrategy diskCacheStrategy,
+      Class<?> resourceClass,
+      Class<R> transcodeClass,
+      Priority priority,
+      Options options,
+      Map<Class<?>, Transformation<?>> transformations,
+      boolean isTransformationRequired,
+      DecodeJob.DiskCacheProvider diskCacheProvider) {
+    this.glideContext = glideContext;
+    this.model = model;
+    this.signature = signature;
+    this.width = width;
+    this.height = height;
+    this.diskCacheStrategy = diskCacheStrategy;
+    this.resourceClass = resourceClass;
+    this.diskCacheProvider = diskCacheProvider;
+    this.transcodeClass = (Class<Transcode>) transcodeClass;
+    this.priority = priority;
+    this.options = options;
+    this.transformations = transformations;
+    this.isTransformationRequired = isTransformationRequired;
+
+    return (DecodeHelper<R>) this;
+  }
+
+  Object getModel() {
+    return model;
+  }
+
+  void clear() {
+    glideContext = null;
+    model = null;
+    signature = null;
+    resourceClass = null;
+    transcodeClass = null;
+    options = null;
+    priority = null;
+    transformations = null;
+    diskCacheStrategy = null;
+
+    loadData.clear();
+    isLoadDataSet = false;
+    cacheKeys.clear();
+    isCacheKeysSet = false;
+  }
+
+  DiskCache getDiskCache() {
+    return diskCacheProvider.getDiskCache();
+  }
+
+  DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  Priority getPriority() {
+    return priority;
+  }
+
+  Options getOptions() {
+    return options;
+  }
+
+  Key getSignature() {
+    return signature;
+  }
+
+  int getWidth() {
+    return width;
+  }
+
+  int getHeight() {
+    return height;
+  }
+
+  List<Class<?>> getRegisteredResourceClasses() {
+    return glideContext.getRegistry()
+        .getRegisteredResourceClasses(model.getClass(), resourceClass, transcodeClass);
+  }
+
+  boolean hasLoadPath(Class<?> dataClass) {
+    return getLoadPath(dataClass) != null;
+  }
+
+  <Data> LoadPath<Data, ?, Transcode> getLoadPath(Class<Data> dataClass) {
+    return glideContext.getRegistry().getLoadPath(dataClass, resourceClass, transcodeClass);
+  }
+
+  @SuppressWarnings("unchecked")
+  <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
+    Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
+     if (result == null) {
+      if (transformations.isEmpty() && isTransformationRequired) {
+        throw new IllegalArgumentException(
+            "Missing transformation for " + resourceClass + ". If you wish to"
+                + " ignore unknown resource types, use the optional transformation methods.");
+      } else {
+        return UnitTransformation.get();
+      }
+    }
+    return result;
+  }
+
+  boolean isResourceEncoderAvailable(Resource<?> resource) {
+    return glideContext.getRegistry().isResourceEncoderAvailable(resource);
+  }
+
+  <Z> ResourceEncoder<Z> getResultEncoder(Resource<Z> resource) {
+    return glideContext.getRegistry().getResultEncoder(resource);
+  }
+
+  List<ModelLoader<File, ?>> getModelLoaders(File file)
+      throws Registry.NoModelLoaderAvailableException {
+    return glideContext.getRegistry().getModelLoaders(file);
+  }
+
+  boolean isSourceKey(Key key) {
+    List<LoadData<?>> loadData = getLoadData();
+    int size = loadData.size();
+    for (int i = 0; i < size; i++) {
+      LoadData<?> current = loadData.get(i);
+      if (current.sourceKey.equals(key)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  List<LoadData<?>> getLoadData() {
+    if (!isLoadDataSet) {
+      isLoadDataSet = true;
+      loadData.clear();
+      List<ModelLoader<Object, ?>> modelLoaders = glideContext.getRegistry().getModelLoaders(model);
+      int size = modelLoaders.size();
+      for (int i = 0; i < size; i++) {
+        ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);
+        LoadData<?> current =
+            modelLoader.buildLoadData(model, width, height, options);
+        if (current != null) {
+          loadData.add(current);
+        }
+      }
+    }
+    return loadData;
+  }
+
+  List<Key> getCacheKeys() {
+    if (!isCacheKeysSet) {
+      isCacheKeysSet = true;
+      cacheKeys.clear();
+      List<LoadData<?>> loadData = getLoadData();
+      int size = loadData.size();
+      for (int i = 0; i < size; i++) {
+        LoadData<?> data = loadData.get(i);
+        cacheKeys.add(data.sourceKey);
+        cacheKeys.addAll(data.alternateKeys);
+      }
+    }
+    return cacheKeys;
+  }
+
+  <X> Encoder<X> getSourceEncoder(X data) throws Registry.NoSourceEncoderAvailableException {
+    return glideContext.getRegistry().getSourceEncoder(data);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index f3d9c0085..222d32249 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -1,292 +1,639 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.v4.util.Pools;
 import android.util.Log;
 
+import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.engine.cache.DiskCache;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.pool.FactoryPools.Poolable;
+import com.bumptech.glide.util.pool.StateVerifier;
 
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
 
 /**
- * A class responsible for decoding resources either from cached data or from the original source and applying
- * transformations and transcodes.
+ * A class responsible for decoding resources either from cached data or from the original source
+ * and applying transformations and transcodes.
  *
- * @param <A> The type of the source data the resource can be decoded from.
- * @param <T> The type of resource that will be decoded.
- * @param <Z> The type of resource that will be transcoded from the decoded and transformed resource.
+ * <p>Note: this class has a natural ordering that is inconsistent with equals.
+ *
+ * @param <R> The type of resource that will be transcoded from the decoded and transformed
+ *            resource.
  */
-class DecodeJob<A, T, Z> {
-    private static final String TAG = "DecodeJob";
-    private static final FileOpener DEFAULT_FILE_OPENER = new FileOpener();
-
-    private final EngineKey resultKey;
-    private final int width;
-    private final int height;
-    private final DataFetcher<A> fetcher;
-    private final DataLoadProvider<A, T> loadProvider;
-    private final Transformation<T> transformation;
-    private final ResourceTranscoder<T, Z> transcoder;
-    private final DiskCacheStrategy diskCacheStrategy;
-    private final DiskCache diskCache;
-    private final Priority priority;
-    private final FileOpener fileOpener;
-
-    private volatile boolean isCancelled;
-
-    public DecodeJob(EngineKey resultKey, int width, int height, DataFetcher<A> fetcher,
-            DataLoadProvider<A, T> loadProvider, Transformation<T> transformation, ResourceTranscoder<T, Z> transcoder,
-            DiskCache diskCache, DiskCacheStrategy diskCacheStrategy, Priority priority) {
-        this(resultKey, width, height, fetcher, loadProvider, transformation, transcoder, diskCache, diskCacheStrategy,
-                priority, DEFAULT_FILE_OPENER);
-    }
-
-    // Visible for testing.
-    DecodeJob(EngineKey resultKey, int width, int height, DataFetcher<A> fetcher,
-            DataLoadProvider<A, T> loadProvider, Transformation<T> transformation, ResourceTranscoder<T, Z> transcoder,
-            DiskCache diskCache, DiskCacheStrategy diskCacheStrategy, Priority priority, FileOpener fileOpener) {
-        this.resultKey = resultKey;
-        this.width = width;
-        this.height = height;
-        this.fetcher = fetcher;
-        this.loadProvider = loadProvider;
-        this.transformation = transformation;
-        this.transcoder = transcoder;
-        this.diskCacheStrategy = diskCacheStrategy;
-        this.diskCache = diskCache;
-        this.priority = priority;
-        this.fileOpener = fileOpener;
+class DecodeJob<R> implements DataFetcherGenerator.FetcherReadyCallback,
+    Runnable,
+    Comparable<DecodeJob<?>>,
+    Poolable {
+  private static final String TAG = "DecodeJob";
+
+  private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
+  private final List<Exception> exceptions = new ArrayList<>();
+  private final StateVerifier stateVerifier = StateVerifier.newInstance();
+  private final DiskCacheProvider diskCacheProvider;
+  private final Pools.Pool<DecodeJob<?>> pool;
+  private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
+  private final ReleaseManager releaseManager = new ReleaseManager();
+
+  private GlideContext glideContext;
+  private Key signature;
+  private Priority priority;
+  private EngineKey loadKey;
+  private int width;
+  private int height;
+  private DiskCacheStrategy diskCacheStrategy;
+  private Options options;
+  private Callback<R> callback;
+  private int order;
+  private Stage stage;
+  private RunReason runReason;
+  private long startFetchTime;
+
+  private Thread currentThread;
+  private Key currentSourceKey;
+  private Key currentAttemptingKey;
+  private Object currentData;
+  private DataSource currentDataSource;
+  private DataFetcher<?> currentFetcher;
+
+  private volatile DataFetcherGenerator currentGenerator;
+  private volatile boolean isCallbackNotified;
+  private volatile boolean isCancelled;
+
+  DecodeJob(DiskCacheProvider diskCacheProvider, Pools.Pool<DecodeJob<?>> pool) {
+    this.diskCacheProvider = diskCacheProvider;
+    this.pool = pool;
+  }
+
+  DecodeJob<R> init(
+      GlideContext glideContext,
+      Object model,
+      EngineKey loadKey,
+      Key signature,
+      int width,
+      int height,
+      Class<?> resourceClass,
+      Class<R> transcodeClass,
+      Priority priority,
+      DiskCacheStrategy diskCacheStrategy,
+      Map<Class<?>, Transformation<?>> transformations,
+      boolean isTransformationRequired,
+      Options options,
+      Callback<R> callback,
+      int order) {
+    decodeHelper.init(
+        glideContext,
+        model,
+        signature,
+        width,
+        height,
+        diskCacheStrategy,
+        resourceClass,
+        transcodeClass,
+        priority,
+        options,
+        transformations,
+        isTransformationRequired,
+        diskCacheProvider);
+    this.glideContext = glideContext;
+    this.signature = signature;
+    this.priority = priority;
+    this.loadKey = loadKey;
+    this.width = width;
+    this.height = height;
+    this.diskCacheStrategy = diskCacheStrategy;
+    this.options = options;
+    this.callback = callback;
+    this.order = order;
+    this.runReason = RunReason.INITIALIZE;
+    return this;
+  }
+
+  /**
+   * Returns true if this job will attempt to decode a resource from the disk cache, and false if it
+   * will always decode from source.
+   */
+  boolean willDecodeFromCache() {
+    Stage firstStage = getNextStage(Stage.INITIALIZE);
+    return firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;
+  }
+
+  /**
+   * Called when this object is no longer in use externally.
+   *
+   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run}
+   *                           is neither in progress nor will ever be called again.
+   */
+  void release(boolean isRemovedFromQueue) {
+    if (releaseManager.release(isRemovedFromQueue)) {
+      releaseInternal();
     }
-
-    /**
-     * Returns a transcoded resource decoded from transformed resource data in the disk cache, or null if no such
-     * resource exists.
-     *
-     * @throws Exception
-     */
-    public Resource<Z> decodeResultFromCache() throws Exception {
-        if (!diskCacheStrategy.cacheResult()) {
-            return null;
-        }
-
-        long startTime = LogTime.getLogTime();
-        Resource<T> transformed = loadFromCache(resultKey);
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logWithTimeAndKey("Decoded transformed from cache", startTime);
-        }
-        startTime = LogTime.getLogTime();
-        Resource<Z> result = transcode(transformed);
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logWithTimeAndKey("Transcoded transformed from cache", startTime);
-        }
-        return result;
+  }
+
+  /**
+   * Called when we've finished encoding (either becasue the encode process is complete, or because
+   * we don't have anything to encode).
+   */
+  private void onEncodeComplete() {
+    if (releaseManager.onEncodeComplete()) {
+      releaseInternal();
     }
-
-    /**
-     * Returns a transformed and transcoded resource decoded from source data in the disk cache, or null if no such
-     * resource exists.
-     *
-     * @throws Exception
-     */
-    public Resource<Z> decodeSourceFromCache() throws Exception {
-        if (!diskCacheStrategy.cacheSource()) {
-            return null;
-        }
-
-        long startTime = LogTime.getLogTime();
-        Resource<T> decoded = loadFromCache(resultKey.getOriginalKey());
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logWithTimeAndKey("Decoded source from cache", startTime);
-        }
-        return transformEncodeAndTranscode(decoded);
+  }
+
+  /**
+   * Called when the load has failed due to a an error or a series of errors.
+   */
+  private void onLoadFailed() {
+    if (releaseManager.onFailed()) {
+      releaseInternal();
+    }
+  }
+
+  private void releaseInternal() {
+    releaseManager.reset();
+    deferredEncodeManager.clear();
+    decodeHelper.clear();
+    isCallbackNotified = false;
+    glideContext = null;
+    signature = null;
+    options = null;
+    priority = null;
+    loadKey = null;
+    callback = null;
+    stage = null;
+    currentGenerator = null;
+    currentThread = null;
+    currentSourceKey = null;
+    currentData = null;
+    currentDataSource = null;
+    currentFetcher = null;
+    startFetchTime = 0L;
+    isCancelled = false;
+    exceptions.clear();
+    pool.release(this);
+  }
+
+  @Override
+  public int compareTo(DecodeJob<?> other) {
+    int result = getPriority() - other.getPriority();
+    if (result == 0) {
+      result = order - other.order;
+    }
+    return result;
+  }
+
+  private int getPriority() {
+    return priority.ordinal();
+  }
+
+  public void cancel() {
+    isCancelled = true;
+    DataFetcherGenerator local = currentGenerator;
+    if (local != null) {
+      local.cancel();
+    }
+  }
+
+  @Override
+  public void run() {
+    // This should be much more fine grained, but since Java's thread pool implementation silently
+    // swallows all otherwise fatal exceptions, this will at least make it obvious to developers
+    // that something is failing.
+    try {
+      if (isCancelled) {
+        notifyFailed();
+        return;
+      }
+      runWrapped();
+    } catch (RuntimeException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "DecodeJob threw unexpectedly"
+            + ", isCancelled: " + isCancelled
+            + ", stage: " + stage, e);
+      }
+      // When we're encoding we've already notified our callback and it isn't safe to do so again.
+      if (stage != Stage.ENCODE) {
+        notifyFailed();
+      }
+      if (!isCancelled) {
+        throw e;
+      }
+    }
+  }
+
+  private void runWrapped() {
+     switch (runReason) {
+      case INITIALIZE:
+        stage = getNextStage(Stage.INITIALIZE);
+        currentGenerator = getNextGenerator();
+        runGenerators();
+        break;
+      case SWITCH_TO_SOURCE_SERVICE:
+        runGenerators();
+        break;
+      case DECODE_DATA:
+        decodeFromRetrievedData();
+        break;
+      default:
+        throw new IllegalStateException("Unrecognized run reason: " + runReason);
+    }
+  }
+
+  private DataFetcherGenerator getNextGenerator() {
+    switch (stage) {
+      case RESOURCE_CACHE:
+        return new ResourceCacheGenerator(decodeHelper, this);
+      case DATA_CACHE:
+        return new DataCacheGenerator(decodeHelper, this);
+      case SOURCE:
+        return new SourceGenerator(decodeHelper, this);
+      case FINISHED:
+        return null;
+      default:
+        throw new IllegalStateException("Unrecognized stage: " + stage);
+    }
+  }
+
+  private void runGenerators() {
+    currentThread = Thread.currentThread();
+    startFetchTime = LogTime.getLogTime();
+    boolean isStarted = false;
+    while (!isCancelled && currentGenerator != null
+        && !(isStarted = currentGenerator.startNext())) {
+      stage = getNextStage(stage);
+      currentGenerator = getNextGenerator();
+
+      if (stage == Stage.SOURCE) {
+        reschedule();
+        return;
+      }
+    }
+    // We've run out of stages and generators, give up.
+    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
+      notifyFailed();
     }
 
-    /**
-     * Returns a transformed and transcoded resource decoded from source data, or null if no source data could be
-     * obtained or no resource could be decoded.
-     *
-     * <p>
-     *     Depending on the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} used, source data is either decoded
-     *     directly or first written to the disk cache and then decoded from the disk cache.
-     * </p>
-     *
-     * @throws Exception
-     */
-    public Resource<Z> decodeFromSource() throws Exception {
-        Resource<T> decoded = decodeSource();
-        return transformEncodeAndTranscode(decoded);
+    // Otherwise a generator started a new load and we expect to be called back in
+    // onDataFetcherReady.
+  }
+
+  private void notifyFailed() {
+    setNotifiedOrThrow();
+    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(exceptions));
+    callback.onLoadFailed(e);
+    onLoadFailed();
+  }
+
+  private void notifyComplete(Resource<R> resource, DataSource dataSource) {
+    setNotifiedOrThrow();
+    callback.onResourceReady(resource, dataSource);
+  }
+
+  private void setNotifiedOrThrow() {
+    stateVerifier.throwIfRecycled();
+    if (isCallbackNotified) {
+      throw new IllegalStateException("Already notified");
+    }
+    isCallbackNotified = true;
+  }
+
+  private Stage getNextStage(Stage current) {
+    switch (current) {
+      case INITIALIZE:
+        return diskCacheStrategy.decodeCachedResource()
+            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
+      case RESOURCE_CACHE:
+        return diskCacheStrategy.decodeCachedData()
+            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
+      case DATA_CACHE:
+        return Stage.SOURCE;
+      case SOURCE:
+      case FINISHED:
+        return Stage.FINISHED;
+      default:
+        throw new IllegalArgumentException("Unrecognized stage: " + current);
+    }
+  }
+
+  @Override
+  public void reschedule() {
+    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
+    callback.reschedule(this);
+  }
+
+  @Override
+  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
+      DataSource dataSource, Key attemptedKey) {
+    this.currentSourceKey = sourceKey;
+    this.currentData = data;
+    this.currentFetcher = fetcher;
+    this.currentDataSource = dataSource;
+    this.currentAttemptingKey = attemptedKey;
+    if (Thread.currentThread() != currentThread) {
+      runReason = RunReason.DECODE_DATA;
+      callback.reschedule(this);
+    } else {
+      decodeFromRetrievedData();
+    }
+  }
+
+  @Override
+  public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
+      DataSource dataSource) {
+    GlideException exception = new GlideException("Fetching data failed", e);
+    exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
+    exceptions.add(exception);
+    if (Thread.currentThread() != currentThread) {
+      runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
+      callback.reschedule(this);
+    } else {
+      runGenerators();
+    }
+  }
+
+  private void decodeFromRetrievedData() {
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      logWithTimeAndKey("Retrieved data", startFetchTime,
+          "data: " + currentData
+          + ", cache key: " + currentSourceKey
+          + ", fetcher: " + currentFetcher);
+    }
+    Resource<R> resource = null;
+    try {
+      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
+    } catch (GlideException e) {
+      e.setLoggingDetails(currentAttemptingKey, currentDataSource);
+      exceptions.add(e);
+    }
+    if (resource != null) {
+      notifyEncodeAndRelease(resource, currentDataSource);
+    } else {
+      runGenerators();
+    }
+  }
+
+  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
+    Resource<R> result = resource;
+    LockedResource<R> lockedResource = null;
+    if (deferredEncodeManager.hasResourceToEncode()) {
+      lockedResource = LockedResource.obtain(resource);
+      result = lockedResource;
     }
 
-    public void cancel() {
-        fetcher.cancel();
-        isCancelled = true;
+    notifyComplete(result, dataSource);
+
+    stage = Stage.ENCODE;
+    try {
+      if (deferredEncodeManager.hasResourceToEncode()) {
+        deferredEncodeManager.encode(diskCacheProvider, options);
+      }
+    } finally {
+      if (lockedResource != null) {
+        lockedResource.unlock();
+      }
+      onEncodeComplete();
+    }
+  }
+
+  private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
+      DataSource dataSource) throws GlideException {
+    try {
+      if (data == null) {
+        return null;
+      }
+      long startTime = LogTime.getLogTime();
+      Resource<R> result = decodeFromFetcher(data, dataSource);
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        logWithTimeAndKey("Decoded result " + result, startTime);
+      }
+      return result;
+    } finally {
+      fetcher.cleanup();
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private <Data> Resource<R> decodeFromFetcher(Data data, DataSource dataSource)
+      throws GlideException {
+    LoadPath<Data, ?, R> path = decodeHelper.getLoadPath((Class<Data>) data.getClass());
+    return runLoadPath(data, dataSource, path);
+  }
+
+  private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
+      LoadPath<Data, ResourceType, R> path) throws GlideException {
+    DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
+    try {
+      return path.load(rewinder, options, width, height,
+          new DecodeCallback<ResourceType>(dataSource));
+    } finally {
+      rewinder.cleanup();
     }
+  }
 
-    private Resource<Z> transformEncodeAndTranscode(Resource<T> decoded) {
-        long startTime = LogTime.getLogTime();
-        Resource<T> transformed = transform(decoded);
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logWithTimeAndKey("Transformed resource from source", startTime);
-        }
+  private void logWithTimeAndKey(String message, long startTime) {
+    logWithTimeAndKey(message, startTime, null /*extraArgs*/);
+  }
 
-        writeTransformedToCache(transformed);
+  private void logWithTimeAndKey(String message, long startTime, String extraArgs) {
+    Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + ", load key: " + loadKey
+        + (extraArgs != null ? ", " + extraArgs : "") + ", thread: "
+        + Thread.currentThread().getName());
+  }
 
-        startTime = LogTime.getLogTime();
-        Resource<Z> result = transcode(transformed);
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logWithTimeAndKey("Transcoded transformed from source", startTime);
-        }
-        return result;
-    }
+  @Override
+  public StateVerifier getVerifier() {
+    return stateVerifier;
+  }
 
-    private void writeTransformedToCache(Resource<T> transformed) {
-        if (transformed == null || !diskCacheStrategy.cacheResult()) {
-            return;
-        }
-        long startTime = LogTime.getLogTime();
-        SourceWriter<Resource<T>> writer = new SourceWriter<Resource<T>>(loadProvider.getEncoder(), transformed);
-        diskCache.put(resultKey, writer);
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logWithTimeAndKey("Wrote transformed from source to cache", startTime);
-        }
-    }
+  class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
-    private Resource<T> decodeSource() throws Exception {
-        Resource<T> decoded = null;
-        try {
-            long startTime = LogTime.getLogTime();
-            final A data = fetcher.loadData(priority);
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                logWithTimeAndKey("Fetched data", startTime);
-            }
-            if (isCancelled) {
-                return null;
-            }
-            decoded = decodeFromSourceData(data);
-        } finally {
-            fetcher.cleanup();
-        }
-        return decoded;
+    private final DataSource dataSource;
+
+    public DecodeCallback(DataSource dataSource) {
+      this.dataSource = dataSource;
     }
 
-    private Resource<T> decodeFromSourceData(A data) throws IOException {
-        final Resource<T> decoded;
-        if (diskCacheStrategy.cacheSource()) {
-            decoded = cacheAndDecodeSourceData(data);
+    @Override
+    public Resource<Z> onResourceDecoded(Resource<Z> decoded) {
+      Class<Z> resourceSubClass = getResourceClass(decoded);
+      Transformation<Z> appliedTransformation = null;
+      Resource<Z> transformed = decoded;
+      if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
+        appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
+        transformed = appliedTransformation.transform(decoded, width, height);
+      }
+      // TODO: Make this the responsibility of the Transformation.
+      if (!decoded.equals(transformed)) {
+        decoded.recycle();
+      }
+
+      final EncodeStrategy encodeStrategy;
+      final ResourceEncoder<Z> encoder;
+      if (decodeHelper.isResourceEncoderAvailable(transformed)) {
+        encoder = decodeHelper.getResultEncoder(transformed);
+        encodeStrategy = encoder.getEncodeStrategy(options);
+      } else {
+        encoder = null;
+        encodeStrategy = EncodeStrategy.NONE;
+      }
+
+      Resource<Z> result = transformed;
+      boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
+      if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
+          encodeStrategy)) {
+        if (encoder == null) {
+          throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
+        }
+        final Key key;
+        if (encodeStrategy == EncodeStrategy.SOURCE) {
+          key = new DataCacheKey(currentSourceKey, signature);
+        } else if (encodeStrategy == EncodeStrategy.TRANSFORMED) {
+          key = new ResourceCacheKey(currentSourceKey, signature, width, height,
+              appliedTransformation, resourceSubClass, options);
         } else {
-            long startTime = LogTime.getLogTime();
-            decoded = loadProvider.getSourceDecoder().decode(data, width, height);
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                logWithTimeAndKey("Decoded from source", startTime);
-            }
+          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
         }
-        return decoded;
+
+        LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
+        deferredEncodeManager.init(key, encoder, lockedResult);
+        result = lockedResult;
+      }
+      return result;
     }
 
-    private Resource<T> cacheAndDecodeSourceData(A data) throws IOException {
-        long startTime = LogTime.getLogTime();
-        SourceWriter<A> writer = new SourceWriter<A>(loadProvider.getSourceEncoder(), data);
-        diskCache.put(resultKey.getOriginalKey(), writer);
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logWithTimeAndKey("Wrote source to cache", startTime);
-        }
+    @SuppressWarnings("unchecked")
+    private Class<Z> getResourceClass(Resource<Z> resource) {
+      return (Class<Z>) resource.get().getClass();
+    }
+  }
+
+  /**
+   * Responsible for indicating when it is safe for the job to be cleared and returned to the pool.
+   */
+  private static class ReleaseManager {
+    private boolean isReleased;
+    private boolean isEncodeComplete;
+    private boolean isFailed;
+
+    synchronized boolean release(boolean isRemovedFromQueue) {
+      isReleased = true;
+      return isComplete(isRemovedFromQueue);
+    }
 
-        startTime = LogTime.getLogTime();
-        Resource<T> result = loadFromCache(resultKey.getOriginalKey());
-        if (Log.isLoggable(TAG, Log.VERBOSE) && result != null) {
-            logWithTimeAndKey("Decoded source from cache", startTime);
-        }
-        return result;
+    synchronized boolean onEncodeComplete() {
+      isEncodeComplete = true;
+      return isComplete(false /*isRemovedFromQueue*/);
     }
 
-    private Resource<T> loadFromCache(Key key) throws IOException {
-        File cacheFile = diskCache.get(key);
-        if (cacheFile == null) {
-            return null;
-        }
+    synchronized boolean onFailed() {
+      isFailed = true;
+      return isComplete(false /*isRemovedFromQueue*/);
+    }
 
-        Resource<T> result = null;
-        try {
-            result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);
-        } finally {
-            if (result == null) {
-                diskCache.delete(key);
-            }
-        }
-        return result;
+    synchronized void reset() {
+      isEncodeComplete = false;
+      isReleased = false;
+      isFailed = false;
     }
 
-    private Resource<T> transform(Resource<T> decoded) {
-        if (decoded == null) {
-            return null;
-        }
+    private boolean isComplete(boolean isRemovedFromQueue) {
+      return (isFailed || isRemovedFromQueue || isEncodeComplete) && isReleased;
+    }
+  }
+
+  /**
+   * Allows transformed resources to be encoded after the transcoded result is already delivered
+   * to requestors.
+   */
+  private static class DeferredEncodeManager<Z> {
+    private Key key;
+    private ResourceEncoder<Z> encoder;
+    private LockedResource<Z> toEncode;
+
+    // We just need the encoder and resouce type to match, which this will enforce.
+    @SuppressWarnings("unchecked")
+    <X> void init(Key key, ResourceEncoder<X> encoder, LockedResource<X> toEncode) {
+      this.key = key;
+      this.encoder = (ResourceEncoder<Z>) encoder;
+      this.toEncode = (LockedResource<Z>) toEncode;
+    }
 
-        Resource<T> transformed = transformation.transform(decoded, width, height);
-        if (!decoded.equals(transformed)) {
-            decoded.recycle();
-        }
-        return transformed;
+    void encode(DiskCacheProvider diskCacheProvider, Options options) {
+      try {
+        diskCacheProvider.getDiskCache().put(key,
+            new DataCacheWriter<>(encoder, toEncode, options));
+      } finally {
+        toEncode.unlock();
+      }
     }
 
-    private Resource<Z> transcode(Resource<T> transformed) {
-        if (transformed == null) {
-            return null;
-        }
-        return transcoder.transcode(transformed);
+    boolean hasResourceToEncode() {
+      return toEncode != null;
     }
 
-    private void logWithTimeAndKey(String message, long startTime) {
-        Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + resultKey);
+    void clear() {
+      key = null;
+      encoder = null;
+      toEncode = null;
     }
+  }
 
-    class SourceWriter<DataType> implements DiskCache.Writer {
+  interface Callback<R> {
 
-        private final Encoder<DataType> encoder;
-        private final DataType data;
+    void onResourceReady(Resource<R> resource, DataSource dataSource);
 
-        public SourceWriter(Encoder<DataType> encoder, DataType data) {
-            this.encoder = encoder;
-            this.data = data;
-        }
+    void onLoadFailed(GlideException e);
 
-        @Override
-        public boolean write(File file) {
-            boolean success = false;
-            OutputStream os = null;
-            try {
-                os = fileOpener.open(file);
-                success = encoder.encode(data, os);
-            } catch (FileNotFoundException e) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Failed to find file to write to disk cache", e);
-                }
-            } finally {
-                if (os != null) {
-                    try {
-                        os.close();
-                    } catch (IOException e) {
-                        // Do nothing.
-                    }
-                }
-            }
-            return success;
-        }
-    }
+    void reschedule(DecodeJob<?> job);
+  }
 
-    static class FileOpener {
-        public OutputStream open(File file) throws FileNotFoundException {
-            return new BufferedOutputStream(new FileOutputStream(file));
-        }
-    }
+  interface DiskCacheProvider {
+    DiskCache getDiskCache();
+  }
+
+  /**
+   * Why we're being executed again.
+   */
+  private enum RunReason {
+    /** The first time we've been submitted. */
+    INITIALIZE,
+    /**
+     * We want to switch from the disk cache service to the source executor.
+     */
+    SWITCH_TO_SOURCE_SERVICE,
+    /**
+     * We retrieved some data on a thread we don't own and want to switch back to our thread to
+     * process the data.
+     */
+    DECODE_DATA,
+  }
+
+  /**
+   * Where we're trying to decode data from.
+   */
+  private enum Stage {
+    /** The initial stage. */
+    INITIALIZE,
+    /** Decode from a cached resource. */
+    RESOURCE_CACHE,
+    /** Decode from cached source data. */
+    DATA_CACHE,
+    /** Decode from retrieved source. */
+    SOURCE,
+    /** Encoding transformed resources after a successful load. */
+    ENCODE,
+    /** No more viable stages. */
+    FINISHED,
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
new file mode 100644
index 000000000..929515277
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -0,0 +1,98 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.v4.util.Pools.Pool;
+import android.util.Log;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.data.DataRewinder;
+import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Attempts to decode and transcode  resource type from a given data type.
+ *
+ * @param <DataType>     The type of data ResourceType that will be decoded from.
+ * @param <ResourceType> The type of intermediate resource that will be decoded.
+ * @param <Transcode>    The final type of resource that will be transcoded from ResourceType and
+ *                       returned to the caller.
+ */
+public class DecodePath<DataType, ResourceType, Transcode> {
+  private static final String TAG = "DecodePath";
+  private final Class<DataType> dataClass;
+  private final List<? extends ResourceDecoder<DataType, ResourceType>> decoders;
+  private final ResourceTranscoder<ResourceType, Transcode> transcoder;
+  private final Pool<List<Exception>> listPool;
+  private final String failureMessage;
+
+  public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
+      Class<Transcode> transcodeClass,
+      List<? extends ResourceDecoder<DataType, ResourceType>> decoders,
+      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Exception>> listPool) {
+    this.dataClass = dataClass;
+    this.decoders = decoders;
+    this.transcoder = transcoder;
+    this.listPool = listPool;
+    failureMessage = "Failed DecodePath{" + dataClass.getSimpleName() + "->"
+        + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
+  }
+
+  public Resource<Transcode> decode(DataRewinder<DataType> rewinder, int width, int height,
+      Options options, DecodeCallback<ResourceType> callback) throws GlideException {
+    Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
+    Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
+    return transcoder.transcode(transformed);
+  }
+
+  private Resource<ResourceType> decodeResource(DataRewinder<DataType> rewinder, int width,
+      int height, Options options) throws GlideException {
+    List<Exception> exceptions = listPool.acquire();
+    try {
+      return decodeResourceWithList(rewinder, width, height, options, exceptions);
+    } finally {
+      listPool.release(exceptions);
+    }
+  }
+
+  private Resource<ResourceType> decodeResourceWithList(DataRewinder<DataType> rewinder, int width,
+      int height, Options options, List<Exception> exceptions) throws GlideException {
+    Resource<ResourceType> result = null;
+    for (int i = 0, size = decoders.size(); i < size; i++) {
+      ResourceDecoder<DataType, ResourceType> decoder = decoders.get(i);
+      try {
+        DataType data = rewinder.rewindAndGet();
+        if (decoder.handles(data, options)) {
+          data = rewinder.rewindAndGet();
+          result = decoder.decode(data, width, height, options);
+        }
+      } catch (IOException e) {
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Failed to decode data for " + decoder, e);
+        }
+        exceptions.add(e);
+      }
+
+      if (result != null) {
+        break;
+      }
+    }
+
+    if (result == null) {
+      throw new GlideException(failureMessage, new ArrayList<>(exceptions));
+    }
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "DecodePath{" + " dataClass=" + dataClass + ", decoders=" + decoders + ", transcoder="
+        + transcoder + '}';
+  }
+
+  interface DecodeCallback<ResourceType> {
+    Resource<ResourceType> onResourceDecoded(Resource<ResourceType> resource);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
index a9c79deb1..0633c1c16 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
@@ -1,37 +1,177 @@
 package com.bumptech.glide.load.engine;
 
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.EncodeStrategy;
+
 /**
  * Set of available caching strategies for media.
  */
-public enum DiskCacheStrategy {
-    /** Caches with both {@link #SOURCE} and {@link #RESULT}. */
-    ALL(true, true),
-    /** Saves no data to cache. */
-    NONE(false, false),
-    /** Saves just the original data to cache. */
-    SOURCE(true, false),
-    /** Saves the media item after all transformations to cache. */
-    RESULT(false, true);
+public abstract class DiskCacheStrategy {
+
+  /**
+   * Caches remote data with both {@link #DATA} and {@link #RESOURCE}, and local data with
+   * {@link #RESOURCE} only.
+   */
+  public static final DiskCacheStrategy ALL = new DiskCacheStrategy() {
+    @Override
+    public boolean isDataCacheable(DataSource dataSource) {
+      return dataSource == DataSource.REMOTE;
+    }
+
+    @Override
+    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
+        EncodeStrategy encodeStrategy) {
+      return dataSource != DataSource.RESOURCE_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
+    }
+
+    @Override
+    public boolean decodeCachedResource() {
+      return true;
+    }
+
+    @Override
+    public boolean decodeCachedData() {
+      return true;
+    }
+  };
+
+  /**
+   * Saves no data to cache.
+   */
+  public static final DiskCacheStrategy NONE = new DiskCacheStrategy() {
+    @Override
+    public boolean isDataCacheable(DataSource dataSource) {
+      return false;
+    }
+
+    @Override
+    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
+        EncodeStrategy encodeStrategy) {
+      return false;
+    }
+
+    @Override
+    public boolean decodeCachedResource() {
+      return false;
+    }
+
+    @Override
+    public boolean decodeCachedData() {
+      return false;
+    }
+  };
+
+  /**
+   * Writes retrieved data directly to the disk cache before it's decoded.
+   */
+  public static final DiskCacheStrategy DATA = new DiskCacheStrategy() {
+    @Override
+    public boolean isDataCacheable(DataSource dataSource) {
+      return dataSource != DataSource.DATA_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
+    }
 
-    private final boolean cacheSource;
-    private final boolean cacheResult;
+    @Override
+    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
+        EncodeStrategy encodeStrategy) {
+      return false;
+    }
+
+    @Override
+    public boolean decodeCachedResource() {
+      return false;
+    }
+
+    @Override
+    public boolean decodeCachedData() {
+      return true;
+    }
+  };
 
-    DiskCacheStrategy(boolean cacheSource, boolean cacheResult) {
-        this.cacheSource = cacheSource;
-        this.cacheResult = cacheResult;
+  /**
+   * Writes resources to disk after they've been decoded.
+   */
+  public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {
+    @Override
+    public boolean isDataCacheable(DataSource dataSource) {
+      return true;
     }
 
-    /**
-     * Returns true if this request should cache the original unmodified data.
-     */
-    public boolean cacheSource() {
-        return cacheSource;
+    @Override
+    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
+        EncodeStrategy encodeStrategy) {
+      return dataSource != DataSource.RESOURCE_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
     }
 
-    /**
-     * Returns true if this request should cache the final transformed result.
-     */
-    public boolean cacheResult() {
-        return cacheResult;
+    @Override
+    public boolean decodeCachedResource() {
+      return true;
     }
+
+    @Override
+    public boolean decodeCachedData() {
+      return false;
+    }
+  };
+
+  /**
+   * Tries to intelligently choose a strategy based on the data source of the
+   * {@link com.bumptech.glide.load.data.DataFetcher} and the
+   * {@link com.bumptech.glide.load.EncodeStrategy} of the
+   * {@link com.bumptech.glide.load.ResourceEncoder} (if an
+   * {@link com.bumptech.glide.load.ResourceEncoder} is available).
+   */
+  public static final DiskCacheStrategy AUTOMATIC = new DiskCacheStrategy() {
+    @Override
+    public boolean isDataCacheable(DataSource dataSource) {
+      return dataSource == DataSource.REMOTE;
+    }
+
+    @Override
+    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
+        EncodeStrategy encodeStrategy) {
+      return ((isFromAlternateCacheKey && dataSource == DataSource.DATA_DISK_CACHE)
+          || dataSource == DataSource.LOCAL)
+          && encodeStrategy == EncodeStrategy.TRANSFORMED;
+    }
+
+    @Override
+    public boolean decodeCachedResource() {
+      return true;
+    }
+
+    @Override
+    public boolean decodeCachedData() {
+      return true;
+    }
+  };
+
+  /**
+   * Returns true if this request should cache the original unmodified data.
+   *
+   * @param dataSource Indicates where the data was originally retrieved.
+   */
+  public abstract boolean isDataCacheable(DataSource dataSource);
+
+  /**
+   * Returns true if this request should cache the final transformed resource.
+   *
+   * @param isFromAlternateCacheKey {@code true} if the resource we've decoded was loaded using an
+   *                                alternative, rather than the primary, cache key.
+   * @param dataSource Indicates where the data used to decode the resource was originally
+   *                   retrieved.
+   * @param encodeStrategy The {@link EncodeStrategy} the {@link
+   * com.bumptech.glide.load.ResourceEncoder} will use to encode the resource.
+   */
+  public abstract boolean isResourceCacheable(boolean isFromAlternateCacheKey,
+      DataSource dataSource, EncodeStrategy encodeStrategy);
+
+  /**
+   * Returns true if this request should attempt to decode cached resource data.
+   */
+  public abstract boolean decodeCachedResource();
+
+  /**
+   * Returns true if this request should attempt to decode cached source data.
+   */
+  public abstract boolean decodeCachedData();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index e66031f8f..3d1e3133e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -2,337 +2,456 @@
 
 import android.os.Looper;
 import android.os.MessageQueue;
+import android.support.v4.util.Pools;
 import android.util.Log;
 
+import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.DiskCacheAdapter;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.DataLoadProvider;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
+import com.bumptech.glide.util.pool.FactoryPools;
 
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.concurrent.ExecutorService;
 
 /**
  * Responsible for starting loads and managing active and cached resources.
  */
-public class Engine implements EngineJobListener, MemoryCache.ResourceRemovedListener, EngineResource.ResourceListener {
-    private static final String TAG = "Engine";
-    private final Map<Key, EngineJob> jobs;
-    private final EngineKeyFactory keyFactory;
-    private final MemoryCache cache;
-    private final DiskCache diskCache;
-    private final EngineJobFactory engineJobFactory;
-    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
-    private final ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
-    private final ResourceRecycler resourceRecycler;
-
-    /**
-     * Allows a request to indicate it no longer is interested in a given load.
-     */
-    public static class LoadStatus {
-        private final EngineJob engineJob;
-        private final ResourceCallback cb;
-
-        public LoadStatus(ResourceCallback cb, EngineJob engineJob) {
-            this.cb = cb;
-            this.engineJob = engineJob;
-        }
-
-        public void cancel() {
-            engineJob.removeCallback(cb);
-        }
+public class Engine implements EngineJobListener,
+    MemoryCache.ResourceRemovedListener,
+    EngineResource.ResourceListener {
+  private static final String TAG = "Engine";
+  private static final int JOB_POOL_SIZE = 150;
+  private final Map<Key, EngineJob> jobs;
+  private final EngineKeyFactory keyFactory;
+  private final MemoryCache cache;
+  private final EngineJobFactory engineJobFactory;
+  private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
+  private final ResourceRecycler resourceRecycler;
+  private final LazyDiskCacheProvider diskCacheProvider;
+  private final DecodeJobFactory decodeJobFactory;
+
+  // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
+  // #295.
+  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
+
+  /**
+   * Allows a request to indicate it no longer is interested in a given load.
+   */
+  public static class LoadStatus {
+    private final EngineJob engineJob;
+    private final ResourceCallback cb;
+
+    public LoadStatus(ResourceCallback cb, EngineJob engineJob) {
+      this.cb = cb;
+      this.engineJob = engineJob;
     }
 
-    public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService diskCacheService,
-            ExecutorService sourceService) {
-        this(memoryCache, diskCache, diskCacheService, sourceService, null, null, null, null, null);
+    public void cancel() {
+      engineJob.removeCallback(cb);
     }
+  }
+
+  public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
+      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor) {
+    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, null, null, null, null,
+        null, null);
+  }
+
+  // Visible for testing.
+  Engine(MemoryCache cache, DiskCache.Factory diskCacheFactory, GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor, Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
+      Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory,
+      DecodeJobFactory decodeJobFactory, ResourceRecycler resourceRecycler) {
+    this.cache = cache;
+    this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
+
+    if (activeResources == null) {
+      activeResources = new HashMap<>();
+    }
+    this.activeResources = activeResources;
 
-    // Visible for testing.
-    Engine(MemoryCache cache, DiskCache diskCache, ExecutorService diskCacheService, ExecutorService sourceService,
-            Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
-            Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory,
-            ResourceRecycler resourceRecycler) {
-        this.cache = cache;
-        this.diskCache = diskCache;
-
-        if (activeResources == null) {
-            activeResources = new HashMap<Key, WeakReference<EngineResource<?>>>();
-        }
-        this.activeResources = activeResources;
-
-        if (keyFactory == null) {
-            keyFactory = new EngineKeyFactory();
-        }
-        this.keyFactory = keyFactory;
-
-        if (jobs == null) {
-            jobs = new HashMap<Key, EngineJob>();
-        }
-        this.jobs = jobs;
-
-        if (engineJobFactory == null) {
-            engineJobFactory = new EngineJobFactory(diskCacheService, sourceService, this);
-        }
-        this.engineJobFactory = engineJobFactory;
-
-        if (resourceRecycler == null) {
-            resourceRecycler = new ResourceRecycler();
-        }
-        this.resourceRecycler = resourceRecycler;
+    if (keyFactory == null) {
+      keyFactory = new EngineKeyFactory();
+    }
+    this.keyFactory = keyFactory;
 
-        resourceReferenceQueue = new ReferenceQueue<EngineResource<?>>();
-        MessageQueue queue = Looper.myQueue();
-        queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
-        cache.setResourceRemovedListener(this);
+    if (jobs == null) {
+      jobs = new HashMap<>();
     }
+    this.jobs = jobs;
 
-    /**
-     * Starts a load for the given arguments. Must be called on the main thread.
-     *
-     * <p>
-     *     The flow for any request is as follows:
-     *     <ul>
-     *         <li>Check the memory cache and provide the cached resource if present</li>
-     *         <li>Check the current set of actively used resources and return the active resource if present</li>
-     *         <li>Check the current set of in progress loads and add the cb to the in progress load if present</li>
-     *         <li>Start a new load</li>
-     *     </ul>
-     * </p>
-     *
-     * <p>
-     *     Active resources are those that have been provided to at least one request and have not yet been released.
-     *     Once all consumers of a resource have released that resource, the resource then goes to cache. If the
-     *     resource is ever returned to a new consumer from cache, it is re-added to the active resources. If the
-     *     resource is evicted from the cache, its resources are recycled and re-used if possible and the resource is
-     *     discarded. There is no strict requirement that consumers release their resources so active resources are
-     *     held weakly.
-     * </p>
-     *
-     * @param signature A non-null unique key to be mixed into the cache key that identifies the version of the data to
-     *                  be loaded.
-     * @param width The target width in pixels of the desired resource.
-     * @param height The target height in pixels of the desired resource.
-     * @param fetcher The fetcher to use to retrieve data not in the disk cache.
-     * @param loadProvider The load provider containing various encoders and decoders use to decode and encode data.
-     * @param transformation The transformation to use to transform the decoded resource.
-     * @param transcoder The transcoder to use to transcode the decoded and transformed resource.
-     * @param priority The priority with which the request should run.
-     * @param isMemoryCacheable True if the transcoded resource can be cached in memory.
-     * @param diskCacheStrategy The strategy to use that determines what type of data, if any,
-     *                          will be cached in the local disk cache.
-     * @param cb The callback that will be called when the load completes.
-     *
-     * @param <T> The type of data the resource will be decoded from.
-     * @param <Z> The type of the resource that will be decoded.
-     * @param <R> The type of the resource that will be transcoded from the decoded resource.
-     */
-    public <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,
-            DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,
-            Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {
-        Util.assertMainThread();
-        long startTime = LogTime.getLogTime();
-
-        final String id = fetcher.getId();
-        EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),
-                loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),
-                transcoder, loadProvider.getSourceEncoder());
-
-        EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
-        if (cached != null) {
-            cb.onResourceReady(cached);
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                logWithTimeAndKey("Loaded resource from cache", startTime, key);
-            }
-            return null;
-        }
+    if (engineJobFactory == null) {
+      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor, this);
+    }
+    this.engineJobFactory = engineJobFactory;
 
-        EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
-        if (active != null) {
-            cb.onResourceReady(active);
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                logWithTimeAndKey("Loaded resource from active resources", startTime, key);
-            }
-            return null;
-        }
+    if (decodeJobFactory == null) {
+      decodeJobFactory = new DecodeJobFactory(diskCacheProvider);
+    }
+    this.decodeJobFactory = decodeJobFactory;
 
-        EngineJob current = jobs.get(key);
-        if (current != null) {
-            current.addCallback(cb);
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                logWithTimeAndKey("Added to existing load", startTime, key);
-            }
-            return new LoadStatus(cb, current);
-        }
+    if (resourceRecycler == null) {
+      resourceRecycler = new ResourceRecycler();
+    }
+    this.resourceRecycler = resourceRecycler;
+
+    cache.setResourceRemovedListener(this);
+  }
+
+  /**
+   * Starts a load for the given arguments. Must be called on the main thread.
+   *
+   * <p> The flow for any request is as follows: <ul> <li>Check the memory cache and provide the
+   * cached resource if present</li> <li>Check the current put of actively used resources and return
+   * the active resource if present</li> <li>Check the current put of in progress loads and add the
+   * cb to the in progress load if present</li> <li>Start a new load</li> </ul> </p>
+   *
+   * <p> Active resources are those that have been provided to at least one request and have not yet
+   * been released. Once all consumers of a resource have released that resource, the resource then
+   * goes to cache. If the resource is ever returned to a new consumer from cache, it is re-added to
+   * the active resources. If the resource is evicted from the cache, its resources are recycled and
+   * re-used if possible and the resource is discarded. There is no strict requirement that
+   * consumers release their resources so active resources are held weakly. </p>
+   *
+   * @param width  The target width in pixels of the desired resource.
+   * @param height The target height in pixels of the desired resource.
+   * @param cb     The callback that will be called when the load completes.
+   */
+  public <R> LoadStatus load(
+      GlideContext glideContext,
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Class<?> resourceClass,
+      Class<R> transcodeClass,
+      Priority priority,
+      DiskCacheStrategy diskCacheStrategy,
+      Map<Class<?>, Transformation<?>> transformations,
+      boolean isTransformationRequired,
+      Options options,
+      boolean isMemoryCacheable,
+      ResourceCallback cb) {
+    Util.assertMainThread();
+    long startTime = LogTime.getLogTime();
+
+    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
+        resourceClass, transcodeClass, options);
+
+    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
+    if (cached != null) {
+      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        logWithTimeAndKey("Loaded resource from cache", startTime, key);
+      }
+      return null;
+    }
 
-        EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);
-        DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,
-                transcoder, diskCache, diskCacheStrategy, priority);
-        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);
-        jobs.put(key, engineJob);
-        engineJob.addCallback(cb);
-        engineJob.start(runnable);
+    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
+    if (active != null) {
+      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
+      }
+      return null;
+    }
 
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logWithTimeAndKey("Started new load", startTime, key);
-        }
-        return new LoadStatus(cb, engineJob);
+    EngineJob current = jobs.get(key);
+    if (current != null) {
+      current.addCallback(cb);
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        logWithTimeAndKey("Added to existing load", startTime, key);
+      }
+      return new LoadStatus(cb, current);
     }
 
-    private static void logWithTimeAndKey(String log, long startTime, Key key) {
-        Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
+    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable);
+    DecodeJob<R> decodeJob = decodeJobFactory.build(
+        glideContext,
+        model,
+        key,
+        signature,
+        width,
+        height,
+        resourceClass,
+        transcodeClass,
+        priority,
+        diskCacheStrategy,
+        transformations,
+        isTransformationRequired,
+        options,
+        engineJob);
+    jobs.put(key, engineJob);
+    engineJob.addCallback(cb);
+    engineJob.start(decodeJob);
+
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      logWithTimeAndKey("Started new load", startTime, key);
     }
+    return new LoadStatus(cb, engineJob);
+  }
 
-    private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
-        if (!isMemoryCacheable) {
-            return null;
-        }
+  private static void logWithTimeAndKey(String log, long startTime, Key key) {
+    Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
+  }
 
-        EngineResource<?> active = null;
-        WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
-        if (activeRef != null) {
-            active = activeRef.get();
-            if (active != null) {
-                active.acquire();
-            } else {
-                activeResources.remove(key);
-            }
-        }
+  private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
+    if (!isMemoryCacheable) {
+      return null;
+    }
 
-        return active;
+    EngineResource<?> active = null;
+    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
+    if (activeRef != null) {
+      active = activeRef.get();
+      if (active != null) {
+        active.acquire();
+      } else {
+        activeResources.remove(key);
+      }
     }
 
-    private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
-        if (!isMemoryCacheable) {
-            return null;
-        }
+    return active;
+  }
 
-        EngineResource<?> cached = getEngineResourceFromCache(key);
-        if (cached != null) {
-            cached.acquire();
-            activeResources.put(key, new ResourceWeakReference(key, cached, resourceReferenceQueue));
-        }
-        return cached;
+  private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
+    if (!isMemoryCacheable) {
+      return null;
     }
 
-    @SuppressWarnings("unchecked")
-    private EngineResource<?> getEngineResourceFromCache(Key key) {
-        Resource<?> cached = cache.remove(key);
-
-        final EngineResource result;
-        if (cached == null) {
-            result = null;
-        } else if (cached instanceof EngineResource) {
-            // Save an object allocation if we've cached an EngineResource (the typical case).
-            result = (EngineResource) cached;
-        } else {
-            result = new EngineResource(cached, true /*isCacheable*/);
-        }
-        return result;
+    EngineResource<?> cached = getEngineResourceFromCache(key);
+    if (cached != null) {
+      cached.acquire();
+      activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));
     }
-
-    public void release(Resource resource) {
-        if (resource instanceof EngineResource) {
-            ((EngineResource) resource).release();
-        } else {
-            throw new IllegalArgumentException("Cannot release anything but an EngineResource");
-        }
+    return cached;
+  }
+
+  @SuppressWarnings("unchecked")
+  private EngineResource<?> getEngineResourceFromCache(Key key) {
+    Resource<?> cached = cache.remove(key);
+
+    final EngineResource result;
+    if (cached == null) {
+      result = null;
+    } else if (cached instanceof EngineResource) {
+      // Save an object allocation if we've cached an EngineResource (the typical case).
+      result = (EngineResource) cached;
+    } else {
+      result = new EngineResource(cached, true /*isMemoryCacheable*/);
     }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void onEngineJobComplete(Key key, EngineResource<?> resource) {
-        // A null resource indicates that the load failed, usually due to an exception.
-        if (resource != null) {
-            resource.setResourceListener(key, this);
-
-            if (resource.isCacheable()) {
-                activeResources.put(key, new ResourceWeakReference(key, resource, resourceReferenceQueue));
-            }
-        }
-        // TODO: should this check that the engine job is still current?
-        jobs.remove(key);
+    return result;
+  }
+
+  public void release(Resource resource) {
+    Util.assertMainThread();
+    if (resource instanceof EngineResource) {
+      ((EngineResource) resource).release();
+    } else {
+      throw new IllegalArgumentException("Cannot release anything but an EngineResource");
     }
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public void onEngineJobComplete(Key key, EngineResource<?> resource) {
+    Util.assertMainThread();
+    // A null resource indicates that the load failed, usually due to an exception.
+    if (resource != null) {
+      resource.setResourceListener(key, this);
+
+      if (resource.isCacheable()) {
+        activeResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+      }
+    }
+    // TODO: should this check that the engine job is still current?
+    jobs.remove(key);
+  }
+
+  @Override
+  public void onEngineJobCancelled(EngineJob engineJob, Key key) {
+    Util.assertMainThread();
+    EngineJob current = jobs.get(key);
+    if (engineJob.equals(current)) {
+      jobs.remove(key);
+    }
+  }
+
+  @Override
+  public void onResourceRemoved(final Resource<?> resource) {
+    Util.assertMainThread();
+    resourceRecycler.recycle(resource);
+  }
+
+  @Override
+  public void onResourceReleased(Key cacheKey, EngineResource resource) {
+    Util.assertMainThread();
+    activeResources.remove(cacheKey);
+    if (resource.isCacheable()) {
+      cache.put(cacheKey, resource);
+    } else {
+      resourceRecycler.recycle(resource);
+    }
+  }
 
-    @Override
-    public void onEngineJobCancelled(EngineJob engineJob, Key key) {
-        EngineJob current = jobs.get(key);
-        if (engineJob.equals(current)) {
-            jobs.remove(key);
-        }
+  public void clearDiskCache() {
+    diskCacheProvider.getDiskCache().clear();
+  }
+
+  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
+    if (resourceReferenceQueue == null) {
+      resourceReferenceQueue = new ReferenceQueue<>();
+      MessageQueue queue = Looper.myQueue();
+      queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
     }
+    return resourceReferenceQueue;
+  }
 
-    @Override
-    public void onResourceRemoved(final Resource<?> resource) {
-        resourceRecycler.recycle(resource);
+  private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
+
+    private final DiskCache.Factory factory;
+    private volatile DiskCache diskCache;
+
+    public LazyDiskCacheProvider(DiskCache.Factory factory) {
+      this.factory = factory;
     }
 
     @Override
-    public void onResourceReleased(Key cacheKey, EngineResource resource) {
-        activeResources.remove(cacheKey);
-        if (resource.isCacheable()) {
-            cache.put(cacheKey, resource);
-        } else {
-            resourceRecycler.recycle(resource);
+    public DiskCache getDiskCache() {
+      if (diskCache == null) {
+        synchronized (this) {
+          if (diskCache == null) {
+            diskCache = factory.build();
+          }
+          if (diskCache == null) {
+            diskCache = new DiskCacheAdapter();
+          }
         }
+      }
+      return diskCache;
     }
+  }
 
-    private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-        private final Key key;
+  private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
+    private final Key key;
 
-        public ResourceWeakReference(Key key, EngineResource<?> r, ReferenceQueue<? super EngineResource<?>> q) {
-            super(r, q);
-            this.key = key;
-        }
+    public ResourceWeakReference(Key key, EngineResource<?> r,
+        ReferenceQueue<? super EngineResource<?>> q) {
+      super(r, q);
+      this.key = key;
     }
+  }
 
-    // Responsible for cleaning up the active resource map by remove weak references that have been cleared.
-    private static class RefQueueIdleHandler implements MessageQueue.IdleHandler {
-        private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
-        private final ReferenceQueue<EngineResource<?>> queue;
+  // Responsible for cleaning up the active resource map by remove weak references that have been
+  // cleared.
+  private static class RefQueueIdleHandler implements MessageQueue.IdleHandler {
+    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
+    private final ReferenceQueue<EngineResource<?>> queue;
 
-        public RefQueueIdleHandler(Map<Key, WeakReference<EngineResource<?>>> activeResources,
-                ReferenceQueue<EngineResource<?>> queue) {
-            this.activeResources = activeResources;
-            this.queue = queue;
-        }
+    public RefQueueIdleHandler(Map<Key, WeakReference<EngineResource<?>>> activeResources,
+        ReferenceQueue<EngineResource<?>> queue) {
+      this.activeResources = activeResources;
+      this.queue = queue;
+    }
 
-        @Override
-        public boolean queueIdle() {
-            ResourceWeakReference ref = (ResourceWeakReference) queue.poll();
-            if (ref != null) {
-                activeResources.remove(ref.key);
-            }
+    @Override
+    public boolean queueIdle() {
+      ResourceWeakReference ref = (ResourceWeakReference) queue.poll();
+      if (ref != null) {
+        activeResources.remove(ref.key);
+      }
 
-            return true;
-        }
+      return true;
+    }
+  }
+
+  // Visible for testing.
+  static class DecodeJobFactory {
+    private final DecodeJob.DiskCacheProvider diskCacheProvider;
+    private final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
+        new FactoryPools.Factory<DecodeJob<?>>() {
+          @Override
+          public DecodeJob<?> create() {
+            return new DecodeJob<Object>(diskCacheProvider, pool);
+          }
+        });
+    private int creationOrder;
+
+    DecodeJobFactory(DecodeJob.DiskCacheProvider diskCacheProvider) {
+      this.diskCacheProvider = diskCacheProvider;
     }
 
-    // Visible for testing.
-    static class EngineJobFactory {
-        private final ExecutorService diskCacheService;
-        private final ExecutorService sourceService;
-        private final EngineJobListener listener;
-
-        public EngineJobFactory(ExecutorService diskCacheService, ExecutorService sourceService,
-                EngineJobListener listener) {
-            this.diskCacheService = diskCacheService;
-            this.sourceService = sourceService;
-            this.listener = listener;
-        }
+    @SuppressWarnings("unchecked")
+    <R> DecodeJob<R> build(GlideContext glideContext,
+        Object model,
+        EngineKey loadKey,
+        Key signature,
+        int width,
+        int height,
+        Class<?> resourceClass,
+        Class<R> transcodeClass,
+        Priority priority,
+        DiskCacheStrategy diskCacheStrategy,
+        Map<Class<?>, Transformation<?>> transformations,
+        boolean isTransformationRequired,
+        Options options,
+        DecodeJob.Callback<R> callback) {
+      DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
+      return result.init(
+          glideContext,
+          model,
+          loadKey,
+          signature,
+          width,
+          height,
+          resourceClass,
+          transcodeClass,
+          priority,
+          diskCacheStrategy,
+          transformations,
+          isTransformationRequired,
+          options,
+          callback,
+          creationOrder++);
+    }
+  }
+
+  // Visible for testing.
+  static class EngineJobFactory {
+    private final GlideExecutor diskCacheExecutor;
+    private final GlideExecutor sourceExecutor;
+    private final EngineJobListener listener;
+    private final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
+        new FactoryPools.Factory<EngineJob<?>>() {
+          @Override
+          public EngineJob<?> create() {
+            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, listener, pool);
+          }
+        });
+
+    EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+        EngineJobListener listener) {
+      this.diskCacheExecutor = diskCacheExecutor;
+      this.sourceExecutor = sourceExecutor;
+      this.listener = listener;
+    }
 
-        public EngineJob build(Key key, boolean isMemoryCacheable) {
-            return new EngineJob(key, diskCacheService, sourceService, isMemoryCacheable, listener);
-        }
+    @SuppressWarnings("unchecked")
+    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable) {
+      EngineJob<R> result = (EngineJob<R>) pool.acquire();
+      return result.init(key, isMemoryCacheable);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 06926317b..c58965ca1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -1,211 +1,290 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Handler;
+import android.os.Looper;
 import android.os.Message;
+import android.support.v4.util.Pools;
 
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.Util;
+import com.bumptech.glide.util.pool.FactoryPools.Poolable;
+import com.bumptech.glide.util.pool.StateVerifier;
 
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
 
 /**
- * A class that manages a load by adding and removing callbacks for for the load and notifying callbacks when the
- * load completes.
+ * A class that manages a load by adding and removing callbacks for for the load and notifying
+ * callbacks when the load completes.
  */
-class EngineJob implements EngineRunnable.EngineRunnableManager {
-    private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();
-    private static final Handler MAIN_THREAD_HANDLER = new Handler(new MainThreadCallback());
-
-    private static final int MSG_COMPLETE = 1;
-    private static final int MSG_EXCEPTION = 2;
-
-    private final List<ResourceCallback> cbs = new ArrayList<ResourceCallback>();
-    private final EngineResourceFactory engineResourceFactory;
-    private final EngineJobListener listener;
-    private final Key key;
-    private final ExecutorService diskCacheService;
-    private final ExecutorService sourceService;
-    private final boolean isCacheable;
-
-    private boolean isCancelled;
-    // Either resource or exception (particularly exception) may be returned to us null, so use booleans to track if
-    // we've received them instead of relying on them to be non-null. See issue #180.
-    private Resource<?> resource;
-    private boolean hasResource;
-    private Exception exception;
-    private boolean hasException;
-    // A set of callbacks that are removed while we're notifying other callbacks of a change in status.
-    private Set<ResourceCallback> ignoredCallbacks;
-    private EngineRunnable engineRunnable;
-    private EngineResource<?> engineResource;
-
-    private volatile Future<?> future;
-
-    public EngineJob(Key key, ExecutorService diskCacheService, ExecutorService sourceService, boolean isCacheable,
-            EngineJobListener listener) {
-        this(key, diskCacheService, sourceService, isCacheable, listener, DEFAULT_FACTORY);
-    }
+class EngineJob<R> implements DecodeJob.Callback<R>,
+    Poolable {
+  private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();
+  private static final Handler MAIN_THREAD_HANDLER =
+      new Handler(Looper.getMainLooper(), new MainThreadCallback());
 
-    public EngineJob(Key key, ExecutorService diskCacheService, ExecutorService sourceService, boolean isCacheable,
-            EngineJobListener listener, EngineResourceFactory engineResourceFactory) {
-        this.key = key;
-        this.diskCacheService = diskCacheService;
-        this.sourceService = sourceService;
-        this.isCacheable = isCacheable;
-        this.listener = listener;
-        this.engineResourceFactory = engineResourceFactory;
-    }
+  private static final int MSG_COMPLETE = 1;
+  private static final int MSG_EXCEPTION = 2;
+  // Used when we realize we're cancelled on a background thread in reschedule and can recycle
+  // immediately rather than waiting for a result or an error.
+  private static final int MSG_CANCELLED = 3;
+
+  private final List<ResourceCallback> cbs = new ArrayList<>(2);
+  private final StateVerifier stateVerifier = StateVerifier.newInstance();
+  private final Pools.Pool<EngineJob<?>> pool;
+  private final EngineResourceFactory engineResourceFactory;
+  private final EngineJobListener listener;
+  private final GlideExecutor diskCacheExecutor;
+  private final GlideExecutor sourceExecutor;
+
+  private Key key;
+  private boolean isCacheable;
+  private Resource<?> resource;
+  private DataSource dataSource;
+  private boolean hasResource;
+  private GlideException exception;
+  private boolean hasLoadFailed;
+  // A put of callbacks that are removed while we're notifying other callbacks of a change in
+  // status.
+  private List<ResourceCallback> ignoredCallbacks;
+  private EngineResource<?> engineResource;
+  private DecodeJob<R> decodeJob;
+
+  // Checked primarily on the main thread, but also on other threads in reschedule.
+  private volatile boolean isCancelled;
+
+  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
+    this(diskCacheExecutor, sourceExecutor, listener, pool, DEFAULT_FACTORY);
+  }
+
+  // Visible for testing.
+  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
+      EngineResourceFactory engineResourceFactory) {
+    this.diskCacheExecutor = diskCacheExecutor;
+    this.sourceExecutor = sourceExecutor;
+    this.listener = listener;
+    this.pool = pool;
+    this.engineResourceFactory = engineResourceFactory;
+  }
 
-    public void start(EngineRunnable engineRunnable) {
-        this.engineRunnable = engineRunnable;
-        future = diskCacheService.submit(engineRunnable);
+  // Visible for testing.
+  EngineJob<R> init(Key key, boolean isCacheable) {
+    this.key = key;
+    this.isCacheable = isCacheable;
+    return this;
+  }
+
+  public void start(DecodeJob<R> decodeJob) {
+    this.decodeJob = decodeJob;
+    GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : sourceExecutor;
+    executor.execute(decodeJob);
+  }
+
+  public void addCallback(ResourceCallback cb) {
+    Util.assertMainThread();
+    stateVerifier.throwIfRecycled();
+    if (hasResource) {
+      cb.onResourceReady(engineResource, dataSource);
+    } else if (hasLoadFailed) {
+      cb.onLoadFailed(exception);
+    } else {
+      cbs.add(cb);
     }
+  }
 
-    @Override
-    public void submitForSource(EngineRunnable runnable) {
-        future = sourceService.submit(runnable);
+  public void removeCallback(ResourceCallback cb) {
+    Util.assertMainThread();
+    stateVerifier.throwIfRecycled();
+    if (hasResource || hasLoadFailed) {
+      addIgnoredCallback(cb);
+    } else {
+      cbs.remove(cb);
+      if (cbs.isEmpty()) {
+        cancel();
+      }
     }
+  }
 
-    public void addCallback(ResourceCallback cb) {
-        Util.assertMainThread();
-        if (hasResource) {
-            cb.onResourceReady(engineResource);
-        } else if (hasException) {
-            cb.onException(exception);
-        } else {
-            cbs.add(cb);
-        }
+  // We cannot remove callbacks while notifying our list of callbacks directly because doing so
+  // would cause a ConcurrentModificationException. However, we need to obey the cancellation
+  // request such that if notifying a callback early in the callbacks list cancels a callback later
+  // in the request list, the cancellation for the later request is still obeyed. Using a put of
+  // ignored callbacks allows us to avoid the exception while still meeting the requirement.
+  private void addIgnoredCallback(ResourceCallback cb) {
+    if (ignoredCallbacks == null) {
+      ignoredCallbacks = new ArrayList<>(2);
+    }
+    if (!ignoredCallbacks.contains(cb)) {
+      ignoredCallbacks.add(cb);
     }
+  }
 
-    public void removeCallback(ResourceCallback cb) {
-        Util.assertMainThread();
-        if (hasResource || hasException) {
-            addIgnoredCallback(cb);
-        } else {
-            cbs.remove(cb);
-            if (cbs.isEmpty()) {
-                cancel();
-            }
-        }
+  private boolean isInIgnoredCallbacks(ResourceCallback cb) {
+    return ignoredCallbacks != null && ignoredCallbacks.contains(cb);
+  }
+
+  // Exposed for testing.
+  void cancel() {
+    if (hasLoadFailed || hasResource || isCancelled) {
+      return;
     }
 
-    // We cannot remove callbacks while notifying our list of callbacks directly because doing so would cause a
-    // ConcurrentModificationException. However, we need to obey the cancellation request such that if notifying a
-    // callback early in the callbacks list cancels a callback later in the request list, the cancellation for the later
-    // request is still obeyed. Using a set of ignored callbacks allows us to avoid the exception while still meeting
-    // the requirement.
-    private void addIgnoredCallback(ResourceCallback cb) {
-        if (ignoredCallbacks == null) {
-            ignoredCallbacks = new HashSet<ResourceCallback>();
-        }
-        ignoredCallbacks.add(cb);
+    isCancelled = true;
+    decodeJob.cancel();
+    boolean isPendingJobRemoved =
+        diskCacheExecutor.remove(decodeJob) || sourceExecutor.remove(decodeJob);
+    listener.onEngineJobCancelled(this, key);
+
+    if (isPendingJobRemoved) {
+      release(true /*isRemovedFromQueue*/);
     }
+  }
+
+  // Exposed for testing.
+  boolean isCancelled() {
+    return isCancelled;
+  }
 
-    private boolean isInIgnoredCallbacks(ResourceCallback cb) {
-        return ignoredCallbacks != null && ignoredCallbacks.contains(cb);
+  private void handleResultOnMainThread() {
+    stateVerifier.throwIfRecycled();
+    if (isCancelled) {
+      resource.recycle();
+      release(false /*isRemovedFromQueue*/);
+      return;
+    } else if (cbs.isEmpty()) {
+      throw new IllegalStateException("Received a resource without any callbacks to notify");
+    } else if (hasResource) {
+      throw new IllegalStateException("Already have resource");
     }
+    engineResource = engineResourceFactory.build(resource, isCacheable);
+    hasResource = true;
 
-    // Exposed for testing.
-    void cancel() {
-        if (hasException || hasResource || isCancelled) {
-            return;
-        }
-        engineRunnable.cancel();
-        Future currentFuture = future;
-        if (currentFuture != null) {
-            currentFuture.cancel(true);
-        }
-        isCancelled = true;
-        listener.onEngineJobCancelled(this, key);
+    // Hold on to resource for duration of request so we don't recycle it in the middle of
+    // notifying if it synchronously released by one of the callbacks.
+    engineResource.acquire();
+    listener.onEngineJobComplete(key, engineResource);
+
+    for (ResourceCallback cb : cbs) {
+      if (!isInIgnoredCallbacks(cb)) {
+        engineResource.acquire();
+        cb.onResourceReady(engineResource, dataSource);
+      }
     }
+    // Our request is complete, so we can release the resource.
+    engineResource.release();
 
-    // Exposed for testing.
-    boolean isCancelled() {
-        return isCancelled;
+    release(false /*isRemovedFromQueue*/);
+  }
+
+  private void handleCancelledOnMainThread() {
+    stateVerifier.throwIfRecycled();
+    if (!isCancelled) {
+      throw new IllegalStateException("Not cancelled");
     }
+    listener.onEngineJobCancelled(this, key);
+    release(false /*isRemovedFromQueue*/);
+  }
 
-    @Override
-    public void onResourceReady(final Resource<?> resource) {
-        this.resource = resource;
-        MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();
+  private void release(boolean isRemovedFromQueue) {
+    Util.assertMainThread();
+    cbs.clear();
+    key = null;
+    engineResource = null;
+    resource = null;
+    if (ignoredCallbacks != null) {
+      ignoredCallbacks.clear();
     }
+    hasLoadFailed = false;
+    isCancelled = false;
+    hasResource = false;
+    decodeJob.release(isRemovedFromQueue);
+    decodeJob = null;
+    exception = null;
+    dataSource = null;
+    pool.release(this);
+  }
 
-    private void handleResultOnMainThread() {
-        if (isCancelled) {
-            resource.recycle();
-            return;
-        } else if (cbs.isEmpty()) {
-            throw new IllegalStateException("Received a resource without any callbacks to notify");
-        }
-        engineResource = engineResourceFactory.build(resource, isCacheable);
-        hasResource = true;
-
-        // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it
-        // synchronously released by one of the callbacks.
-        engineResource.acquire();
-        listener.onEngineJobComplete(key, engineResource);
-
-        for (ResourceCallback cb : cbs) {
-            if (!isInIgnoredCallbacks(cb)) {
-                engineResource.acquire();
-                cb.onResourceReady(engineResource);
-            }
-        }
-        // Our request is complete, so we can release the resource.
-        engineResource.release();
+  @Override
+  public void onResourceReady(Resource<R> resource, DataSource dataSource) {
+    this.resource = resource;
+    this.dataSource = dataSource;
+    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();
+  }
+
+  @Override
+  public void onLoadFailed(GlideException e) {
+    this.exception = e;
+    MAIN_THREAD_HANDLER.obtainMessage(MSG_EXCEPTION, this).sendToTarget();
+  }
+
+  @Override
+  public void reschedule(DecodeJob<?> job) {
+    if (isCancelled) {
+      MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();
+    } else {
+      sourceExecutor.execute(job);
     }
+  }
 
-    @Override
-    public void onException(final Exception e) {
-        this.exception = e;
-        MAIN_THREAD_HANDLER.obtainMessage(MSG_EXCEPTION, this).sendToTarget();
+  private void handleExceptionOnMainThread() {
+    stateVerifier.throwIfRecycled();
+    if (isCancelled) {
+      release(false /*isRemovedFromQueue*/);
+      return;
+    } else if (cbs.isEmpty()) {
+      throw new IllegalStateException("Received an exception without any callbacks to notify");
+    } else if (hasLoadFailed) {
+      throw new IllegalStateException("Already failed once");
     }
+    hasLoadFailed = true;
+
+    listener.onEngineJobComplete(key, null);
 
-    private void handleExceptionOnMainThread() {
-        if (isCancelled) {
-            return;
-        } else if (cbs.isEmpty()) {
-            throw new IllegalStateException("Received an exception without any callbacks to notify");
-        }
-        hasException = true;
-
-        listener.onEngineJobComplete(key, null);
-
-        for (ResourceCallback cb : cbs) {
-            if (!isInIgnoredCallbacks(cb)) {
-                cb.onException(exception);
-            }
-        }
+    for (ResourceCallback cb : cbs) {
+      if (!isInIgnoredCallbacks(cb)) {
+        cb.onLoadFailed(exception);
+      }
     }
 
-    // Visible for testing.
-    static class EngineResourceFactory {
-        public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
-            return new EngineResource<R>(resource, isMemoryCacheable);
-        }
+    release(false /*isRemovedFromQueue*/);
+  }
+
+  @Override
+  public StateVerifier getVerifier() {
+    return stateVerifier;
+  }
+
+  // Visible for testing.
+  static class EngineResourceFactory {
+    public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
+      return new EngineResource<>(resource, isMemoryCacheable);
     }
+  }
+
+  private static class MainThreadCallback implements Handler.Callback {
 
-    private static class MainThreadCallback implements Handler.Callback {
-
-        @Override
-        public boolean handleMessage(Message message) {
-            if (MSG_COMPLETE == message.what || MSG_EXCEPTION == message.what) {
-                EngineJob job = (EngineJob) message.obj;
-                if (MSG_COMPLETE == message.what) {
-                    job.handleResultOnMainThread();
-                } else {
-                    job.handleExceptionOnMainThread();
-                }
-                return true;
-            }
-
-            return false;
-        }
+    @Override
+    public boolean handleMessage(Message message) {
+      EngineJob job = (EngineJob) message.obj;
+      switch (message.what) {
+        case MSG_COMPLETE:
+          job.handleResultOnMainThread();
+          break;
+        case MSG_EXCEPTION:
+          job.handleExceptionOnMainThread();
+          break;
+        case MSG_CANCELLED:
+          job.handleCancelledOnMainThread();
+          break;
+        default:
+          throw new IllegalStateException("Unrecognized message: " + message.what);
+      }
+      return true;
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
index e143b22ad..0d3c2e410 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
@@ -4,7 +4,7 @@
 
 interface EngineJobListener {
 
-    void onEngineJobComplete(Key key, EngineResource<?> resource);
+  void onEngineJobComplete(Key key, EngineResource<?> resource);
 
-    void onEngineJobCancelled(EngineJob engineJob, Key key);
+  void onEngineJobCancelled(EngineJob engineJob, Key key);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index 7cbbe6f27..855f48b04 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -1,151 +1,90 @@
 package com.bumptech.glide.load.engine;
 
-import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
+import com.bumptech.glide.util.Preconditions;
 
-import java.io.UnsupportedEncodingException;
-import java.nio.ByteBuffer;
 import java.security.MessageDigest;
+import java.util.Map;
 
-@SuppressWarnings("rawtypes")
+/**
+ * An in memory only cache key used to multiplex loads.
+ */
 class EngineKey implements Key {
-    private final String id;
-    private final int width;
-    private final int height;
-    private final ResourceDecoder cacheDecoder;
-    private final ResourceDecoder decoder;
-    private final Transformation transformation;
-    private final ResourceEncoder encoder;
-    private final ResourceTranscoder transcoder;
-    private final Encoder sourceEncoder;
-    private final Key signature;
-    private String stringKey;
-    private int hashCode;
-    private Key originalKey;
+  private final Object model;
+  private final int width;
+  private final int height;
+  private final Class<?> resourceClass;
+  private final Class<?> transcodeClass;
+  private final Key signature;
+  private final Map<Class<?>, Transformation<?>> transformations;
+  private final Options options;
+  private int hashCode;
 
-    public EngineKey(String id, Key signature, int width, int height, ResourceDecoder cacheDecoder,
-            ResourceDecoder decoder, Transformation transformation, ResourceEncoder encoder,
-            ResourceTranscoder transcoder, Encoder sourceEncoder) {
-        this.id = id;
-        this.signature = signature;
-        this.width = width;
-        this.height = height;
-        this.cacheDecoder = cacheDecoder;
-        this.decoder = decoder;
-        this.transformation = transformation;
-        this.encoder = encoder;
-        this.transcoder = transcoder;
-        this.sourceEncoder = sourceEncoder;
-    }
+  public EngineKey(Object model, Key signature, int width, int height,
+      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
+      Class<?> transcodeClass, Options options) {
+    this.model = Preconditions.checkNotNull(model);
+    this.signature = Preconditions.checkNotNull(signature, "Signature must not be null");
+    this.width = width;
+    this.height = height;
+    this.transformations = Preconditions.checkNotNull(transformations);
+    this.resourceClass =
+        Preconditions.checkNotNull(resourceClass, "Resource class must not be null");
+    this.transcodeClass =
+        Preconditions.checkNotNull(transcodeClass, "Transcode class must not be null");
+    this.options = Preconditions.checkNotNull(options);
+  }
 
-    public Key getOriginalKey() {
-        if (originalKey == null) {
-            originalKey = new OriginalKey(id, signature);
-        }
-        return originalKey;
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof EngineKey) {
+      EngineKey other = (EngineKey) o;
+      return model.equals(other.model)
+          && signature.equals(other.signature)
+          && height == other.height
+          && width == other.width
+          && transformations.equals(other.transformations)
+          && resourceClass.equals(other.resourceClass)
+          && transcodeClass.equals(other.transcodeClass)
+          && options.equals(other.options);
     }
+    return false;
+  }
 
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
-
-        EngineKey engineKey = (EngineKey) o;
-
-        if (!id.equals(engineKey.id)) {
-            return false;
-        } else if (!signature.equals(engineKey.signature)) {
-            return false;
-        } else if (height != engineKey.height) {
-            return false;
-        } else if (width != engineKey.width) {
-            return false;
-        } else if (transformation == null ^ engineKey.transformation == null) {
-            return false;
-        } else if (transformation != null && !transformation.getId().equals(engineKey.transformation.getId())) {
-            return false;
-        } else if (decoder == null ^ engineKey.decoder == null) {
-            return false;
-        } else if (decoder != null && !decoder.getId().equals(engineKey.decoder.getId())) {
-            return false;
-        } else if (cacheDecoder == null ^ engineKey.cacheDecoder == null) {
-            return false;
-        } else if (cacheDecoder != null && !cacheDecoder.getId().equals(engineKey.cacheDecoder.getId())) {
-            return false;
-        } else if (encoder == null ^ engineKey.encoder == null) {
-            return false;
-        } else if (encoder != null && !encoder.getId().equals(engineKey.encoder.getId())) {
-            return false;
-        } else if (transcoder == null ^ engineKey.transcoder == null) {
-            return false;
-        } else if (transcoder != null && !transcoder.getId().equals(engineKey.transcoder.getId())) {
-            return false;
-        } else if (sourceEncoder == null ^ engineKey.sourceEncoder == null) {
-            return false;
-        } else if (sourceEncoder != null && !sourceEncoder.getId().equals(engineKey.sourceEncoder.getId())) {
-            return false;
-        }
-        return true;
+  @Override
+  public int hashCode() {
+    if (hashCode == 0) {
+      hashCode = model.hashCode();
+      hashCode = 31 * hashCode + signature.hashCode();
+      hashCode = 31 * hashCode + width;
+      hashCode = 31 * hashCode + height;
+      hashCode = 31 * hashCode + transformations.hashCode();
+      hashCode = 31 * hashCode + resourceClass.hashCode();
+      hashCode = 31 * hashCode + transcodeClass.hashCode();
+      hashCode = 31 * hashCode + options.hashCode();
     }
+    return hashCode;
+  }
 
-    @Override
-    public int hashCode() {
-        if (hashCode == 0) {
-            hashCode = id.hashCode();
-            hashCode = 31 * hashCode + signature.hashCode();
-            hashCode = 31 * hashCode + width;
-            hashCode = 31 * hashCode + height;
-            hashCode = 31 * hashCode + (cacheDecoder   != null ? cacheDecoder  .getId().hashCode() : 0);
-            hashCode = 31 * hashCode + (decoder        != null ? decoder       .getId().hashCode() : 0);
-            hashCode = 31 * hashCode + (transformation != null ? transformation.getId().hashCode() : 0);
-            hashCode = 31 * hashCode + (encoder        != null ? encoder       .getId().hashCode() : 0);
-            hashCode = 31 * hashCode + (transcoder     != null ? transcoder    .getId().hashCode() : 0);
-            hashCode = 31 * hashCode + (sourceEncoder  != null ? sourceEncoder .getId().hashCode() : 0);
-        }
-        return hashCode;
-    }
+  @Override
+  public String toString() {
+    return "EngineKey{"
+        + "model=" + model
+        + ", width=" + width
+        + ", height=" + height
+        + ", resourceClass=" + resourceClass
+        + ", transcodeClass=" + transcodeClass
+        + ", signature=" + signature
+        + ", hashCode=" + hashCode
+        + ", transformations=" + transformations
+        + ", options=" + options
+        + '}';
+  }
 
-    @Override
-    public String toString() {
-        if (stringKey == null) {
-            stringKey = new StringBuilder()
-                .append(id)
-                .append(signature)
-                .append(width)
-                .append(height)
-                .append(cacheDecoder   != null ? cacheDecoder  .getId() : "")
-                .append(decoder        != null ? decoder       .getId() : "")
-                .append(transformation != null ? transformation.getId() : "")
-                .append(encoder        != null ? encoder       .getId() : "")
-                .append(transcoder     != null ? transcoder    .getId() : "")
-                .append(sourceEncoder  != null ? sourceEncoder .getId() : "")
-                .toString();
-        }
-        return stringKey;
-    }
-
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-        byte[] dimensions = ByteBuffer.allocate(8)
-                .putInt(width)
-                .putInt(height)
-                .array();
-        signature.updateDiskCacheKey(messageDigest);
-        messageDigest.update(id.getBytes(STRING_CHARSET_NAME));
-        messageDigest.update(dimensions);
-        messageDigest.update((cacheDecoder   != null ? cacheDecoder  .getId() : "").getBytes(STRING_CHARSET_NAME));
-        messageDigest.update((decoder        != null ? decoder       .getId() : "").getBytes(STRING_CHARSET_NAME));
-        messageDigest.update((transformation != null ? transformation.getId() : "").getBytes(STRING_CHARSET_NAME));
-        messageDigest.update((encoder        != null ? encoder       .getId() : "").getBytes(STRING_CHARSET_NAME));
-        // The Transcoder is not included in the disk cache key because its result is not cached.
-        messageDigest.update((sourceEncoder  != null ? sourceEncoder .getId() : "").getBytes(STRING_CHARSET_NAME));
-    }
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    throw new UnsupportedOperationException();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
index 029266a77..b458d3132 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
@@ -1,20 +1,18 @@
 package com.bumptech.glide.load.engine;
 
-import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 
-class EngineKeyFactory {
+import java.util.Map;
 
-    @SuppressWarnings("rawtypes")
-    public EngineKey buildKey(String id, Key signature, int width, int height, ResourceDecoder cacheDecoder,
-            ResourceDecoder sourceDecoder, Transformation transformation, ResourceEncoder encoder,
-            ResourceTranscoder transcoder, Encoder sourceEncoder) {
-        return new EngineKey(id, signature, width, height, cacheDecoder, sourceDecoder, transformation, encoder,
-                transcoder, sourceEncoder);
-    }
+class EngineKeyFactory {
 
+  @SuppressWarnings("rawtypes")
+  public EngineKey buildKey(Object model, Key signature, int width, int height,
+      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
+      Class<?> transcodeClass, Options options) {
+    return new EngineKey(model, signature, width, height, transformations, resourceClass,
+        transcodeClass, options);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 49bf096aa..0ba087590 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -3,101 +3,115 @@
 import android.os.Looper;
 
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.util.Preconditions;
 
 /**
- * A wrapper resource that allows reference counting a wrapped {@link com.bumptech.glide.load.engine.Resource}
- * interface.
+ * A wrapper resource that allows reference counting a wrapped {@link
+ * com.bumptech.glide.load.engine.Resource} interface.
  *
  * @param <Z> The type of data returned by the wrapped {@link Resource}.
  */
 class EngineResource<Z> implements Resource<Z> {
-    private final Resource<Z> resource;
-    private final boolean isCacheable;
-    private ResourceListener listener;
-    private Key key;
-    private int acquired;
-    private boolean isRecycled;
+  private final boolean isCacheable;
+  private ResourceListener listener;
+  private Key key;
+  private int acquired;
+  private boolean isRecycled;
+  private final Resource<Z> resource;
 
-    interface ResourceListener {
-        void onResourceReleased(Key key, EngineResource<?> resource);
-    }
+  interface ResourceListener {
+    void onResourceReleased(Key key, EngineResource<?> resource);
+  }
 
-    EngineResource(Resource<Z> toWrap, boolean isCacheable) {
-        if (toWrap == null) {
-            throw new NullPointerException("Wrapped resource must not be null");
-        }
-        resource = toWrap;
-        this.isCacheable = isCacheable;
-    }
+  EngineResource(Resource<Z> toWrap, boolean isCacheable) {
+    resource = Preconditions.checkNotNull(toWrap);
+    this.isCacheable = isCacheable;
+  }
 
-    void setResourceListener(Key key, ResourceListener listener) {
-        this.key = key;
-        this.listener = listener;
-    }
+  void setResourceListener(Key key, ResourceListener listener) {
+    this.key = key;
+    this.listener = listener;
+  }
 
-    boolean isCacheable() {
-        return isCacheable;
-    }
+  boolean isCacheable() {
+    return isCacheable;
+  }
 
-    @Override
-    public Z get() {
-        return resource.get();
-    }
+  @Override
+  public Class<Z> getResourceClass() {
+    return resource.getResourceClass();
+  }
 
-    @Override
-    public int getSize() {
-        return resource.getSize();
-    }
+  @Override
+  public Z get() {
+    return resource.get();
+  }
 
-    @Override
-    public void recycle() {
-        if (acquired > 0) {
-            throw new IllegalStateException("Cannot recycle a resource while it is still acquired");
-        }
-        if (isRecycled) {
-            throw new IllegalStateException("Cannot recycle a resource that has already been recycled");
-        }
-        isRecycled = true;
-        resource.recycle();
+  @Override
+  public int getSize() {
+    return resource.getSize();
+  }
+
+  @Override
+  public void recycle() {
+    if (acquired > 0) {
+      throw new IllegalStateException("Cannot recycle a resource while it is still acquired");
+    }
+    if (isRecycled) {
+      throw new IllegalStateException("Cannot recycle a resource that has already been recycled");
     }
+    isRecycled = true;
+    resource.recycle();
+  }
 
-    /**
-     * Increments the number of consumers using the wrapped resource. Must be called on the main thread.
-     *
-     * <p>
-     *     This must be called with a number corresponding to the number of new consumers each time new consumers
-     *     begin using the wrapped resource. It is always safer to call acquire more often than necessary. Generally
-     *     external users should never call this method, the framework will take care of this for you.
-     * </p>
-     */
-    void acquire() {
-        if (isRecycled) {
-            throw new IllegalStateException("Cannot acquire a recycled resource");
-        }
-        if (!Looper.getMainLooper().equals(Looper.myLooper())) {
-            throw new IllegalThreadStateException("Must call acquire on the main thread");
-        }
-        ++acquired;
+  /**
+   * Increments the number of consumers using the wrapped resource. Must be called on the main
+   * thread.
+   *
+   * <p> This must be called with a number corresponding to the number of new consumers each time
+   * new consumers begin using the wrapped resource. It is always safer to call acquire more often
+   * than necessary. Generally external users should never call this method, the framework will take
+   * care of this for you. </p>
+   */
+  void acquire() {
+    if (isRecycled) {
+      throw new IllegalStateException("Cannot acquire a recycled resource");
+    }
+    if (!Looper.getMainLooper().equals(Looper.myLooper())) {
+      throw new IllegalThreadStateException("Must call acquire on the main thread");
     }
+    ++acquired;
+  }
 
-    /**
-     * Decrements the number of consumers using the wrapped resource. Must be called on the main thread.
-     *
-     * <p>
-     *     This must only be called when a consumer that called the {@link #acquire()} method is now done with the
-     *     resource. Generally external users should never callthis method, the framework will take care of this for
-     *     you.
-     * </p>
-     */
-    void release() {
-        if (acquired <= 0) {
-            throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
-        }
-        if (!Looper.getMainLooper().equals(Looper.myLooper())) {
-            throw new IllegalThreadStateException("Must call release on the main thread");
-        }
-        if (--acquired == 0) {
-            listener.onResourceReleased(key, this);
-        }
+  /**
+   * Decrements the number of consumers using the wrapped resource. Must be called on the main
+   * thread.
+   *
+   * <p> This must only be called when a consumer that called the {@link #acquire()} method is now
+   * done with the resource. Generally external users should never callthis method, the framework
+   * will take care of this for you. </p>
+   */
+  void release() {
+    if (acquired <= 0) {
+      throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
     }
+    if (!Looper.getMainLooper().equals(Looper.myLooper())) {
+      throw new IllegalThreadStateException("Must call release on the main thread");
+    }
+    if (--acquired == 0) {
+      listener.onResourceReleased(key, this);
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "EngineResource{"
+        + "isCacheable=" + isCacheable
+        + ", listener=" + listener
+        + ", key=" + key
+        + ", acquired=" + acquired
+        + ", isRecycled=" + isRecycled
+        + ", resource=" + resource
+        + '}';
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineRunnable.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineRunnable.java
deleted file mode 100644
index 98ec65ecf..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineRunnable.java
+++ /dev/null
@@ -1,140 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import android.util.Log;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.engine.executor.Prioritized;
-import com.bumptech.glide.request.ResourceCallback;
-
-/**
- * A runnable class responsible for using an {@link com.bumptech.glide.load.engine.DecodeJob} to decode resources on a
- * background thread in two stages.
- *
- * <p>
- *     In the first stage, this class attempts to decode a resource
- *     from cache, first using transformed data and then using source data. If no resource can be decoded from cache,
- *     this class then requests to be posted again. During the second stage this class then attempts to use the
- *     {@link com.bumptech.glide.load.engine.DecodeJob} to decode data directly from the original source.
- * </p>
- *
- * <p>
- *     Using two stages with a re-post in between allows us to run fast disk cache decodes on one thread and slow source
- *     fetches on a second pool so that loads for local data are never blocked waiting for loads for remote data to
- *     complete.
- * </p>
- */
-class EngineRunnable implements Runnable, Prioritized {
-    private static final String TAG = "EngineRunnable";
-
-    private final Priority priority;
-    private final EngineRunnableManager manager;
-    private final DecodeJob<?, ?, ?> decodeJob;
-
-    private Stage stage;
-
-    private volatile boolean isCancelled;
-
-    public EngineRunnable(EngineRunnableManager manager, DecodeJob<?, ?, ?> decodeJob, Priority priority) {
-        this.manager = manager;
-        this.decodeJob = decodeJob;
-        this.stage = Stage.CACHE;
-        this.priority = priority;
-    }
-
-    public void cancel() {
-        isCancelled = true;
-        decodeJob.cancel();
-    }
-
-    @Override
-    public void run() {
-        if (isCancelled) {
-            return;
-        }
-
-        Exception exception = null;
-        Resource<?> resource = null;
-        try {
-            resource = decode();
-        } catch (Exception e) {
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "Exception decoding", e);
-            }
-            exception = e;
-        }
-
-        if (isCancelled) {
-            if (resource != null) {
-                resource.recycle();
-            }
-            return;
-        }
-
-        if (resource == null) {
-            onLoadFailed(exception);
-        } else {
-            onLoadComplete(resource);
-        }
-    }
-
-    private boolean isDecodingFromCache() {
-        return stage == Stage.CACHE;
-    }
-
-    private void onLoadComplete(Resource resource) {
-        manager.onResourceReady(resource);
-    }
-
-    private void onLoadFailed(Exception e) {
-        if (isDecodingFromCache()) {
-            stage = Stage.SOURCE;
-            manager.submitForSource(this);
-        } else {
-            manager.onException(e);
-        }
-    }
-
-    private Resource<?> decode() throws Exception {
-        if (isDecodingFromCache()) {
-            return decodeFromCache();
-        } else {
-            return decodeFromSource();
-        }
-    }
-
-    private Resource<?> decodeFromCache() throws Exception {
-        Resource<?> result = null;
-        try {
-            result = decodeJob.decodeResultFromCache();
-        } catch (Exception e) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Exception decoding result from cache: " + e);
-            }
-        }
-
-        if (result == null) {
-            result = decodeJob.decodeSourceFromCache();
-        }
-        return result;
-    }
-
-    private Resource<?> decodeFromSource() throws Exception {
-        return decodeJob.decodeFromSource();
-    }
-
-    @Override
-    public int getPriority() {
-        return priority.ordinal();
-    }
-
-    private enum Stage {
-        /** Attempting to decode resource from cache. */
-        CACHE,
-        /** Attempting to decode resource from source data. */
-        SOURCE
-    }
-
-    interface EngineRunnableManager extends ResourceCallback {
-        void submitForSource(EngineRunnable runnable);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
new file mode 100644
index 000000000..5ae6da255
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -0,0 +1,231 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * An exception with zero or more causes indicating why a load in Glide failed.
+ */
+public final class GlideException extends Exception {
+  private static final StackTraceElement[] EMPTY_ELEMENTS = new StackTraceElement[0];
+
+  private final List<Exception> causes;
+  private Key key;
+  private DataSource dataSource;
+  private Class<?> dataClass;
+
+  public GlideException(String message) {
+    this(message, Collections.<Exception>emptyList());
+  }
+
+  public GlideException(String detailMessage, Exception cause) {
+    this(detailMessage, Collections.singletonList(cause));
+  }
+
+  public GlideException(String detailMessage, List<Exception> causes) {
+    super(detailMessage);
+    setStackTrace(EMPTY_ELEMENTS);
+    this.causes = causes;
+  }
+
+  void setLoggingDetails(Key key, DataSource dataSource) {
+    setLoggingDetails(key, dataSource, null);
+  }
+
+  void setLoggingDetails(Key key, DataSource dataSource, Class<?> dataClass) {
+    this.key = key;
+    this.dataSource = dataSource;
+    this.dataClass = dataClass;
+  }
+
+  @Override
+  public Throwable fillInStackTrace() {
+    // Avoid an expensive allocation by doing nothing here. Causes should contain all relevant
+    // stack traces.
+    return this;
+  }
+
+  /**
+   * Returns a list of causes that are immediate children of this exception.
+   *
+   * @see #getRootCauses().
+   *
+   * <p>Causes may or may not be {@link GlideException GlideExceptions}. Causes may also not be root
+   * causes, and in turn my have been caused by other failures.
+   */
+  public List<Exception> getCauses() {
+    return causes;
+  }
+
+  /**
+   * Returns the list of root causes that are the leaf nodes of all children of this exception.
+   *
+   * <p>Use this method to do things like look for http exceptions that indicate the load may have
+   * failed due to an error that can be retried. Keep in mind that because Glide may attempt to load
+   * a given model using multiple different pathways, there may be multiple related or unrelated
+   * reasons for a load to fail.
+   */
+  public List<Exception> getRootCauses() {
+    List<Exception> rootCauses = new ArrayList<>();
+    addRootCauses(this, rootCauses);
+    return rootCauses;
+  }
+
+  /**
+   * Logs all root causes using the given tag.
+   *
+   * <p>Each root cause is logged separately to avoid throttling. {@link #printStackTrace()} will
+   * provide a more succinct overview of why the exception occurred, although it does not include
+   * complete stack traces.
+   */
+  public void logRootCauses(String tag) {
+    Log.e(tag, getClass() + ": " + getMessage());
+    List<Exception> causes = getRootCauses();
+    for (int i = 0, size = causes.size(); i < size; i++) {
+      Log.i(tag, "Root cause (" + (i + 1) + " of " + size + ")", causes.get(i));
+    }
+  }
+
+  private void addRootCauses(Exception exception, List<Exception> rootCauses) {
+    if (exception instanceof GlideException) {
+      GlideException glideException = (GlideException) exception;
+      for (Exception e : glideException.getCauses()) {
+        addRootCauses(e, rootCauses);
+      }
+    } else {
+      rootCauses.add(exception);
+    }
+  }
+
+  @Override
+  public void printStackTrace() {
+    printStackTrace(System.err);
+  }
+
+  @Override
+  public void printStackTrace(PrintStream err) {
+    printStackTrace((Appendable) err);
+  }
+
+  @Override
+  public void printStackTrace(PrintWriter err) {
+    printStackTrace((Appendable) err);
+  }
+
+  private void printStackTrace(Appendable appendable) {
+    appendExceptionMessage(this, appendable);
+    appendCauses(getCauses(), new IndentedAppendable(appendable));
+  }
+
+  @Override
+  public String getMessage() {
+    return super.getMessage()
+        + (dataClass != null ? ", " + dataClass : "")
+        + (dataSource != null ? ", " + dataSource : "")
+        + (key != null ? ", " + key : "");
+  }
+
+  // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
+  // never happen.
+  @SuppressWarnings("PMD.PreserveStackTrace")
+  private static void appendExceptionMessage(Exception e, Appendable appendable) {
+    try {
+      appendable.append(e.getClass().toString()).append(": ").append(e.getMessage()).append('\n');
+    } catch (IOException e1) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
+  // never happen.
+  @SuppressWarnings("PMD.PreserveStackTrace")
+  private static void appendCauses(List<Exception> causes, Appendable appendable) {
+    try {
+      appendCausesWrapped(causes, appendable);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
+  private static void appendCausesWrapped(List<Exception> causes, Appendable appendable)
+      throws IOException {
+    int size = causes.size();
+    for (int i = 0; i < size; i++) {
+      appendable.append("Cause (")
+          .append(String.valueOf(i + 1))
+          .append(" of ")
+          .append(String.valueOf(size))
+          .append("): ");
+
+      Exception cause = causes.get(i);
+      if (cause instanceof GlideException) {
+        GlideException glideCause = (GlideException) cause;
+        glideCause.printStackTrace(appendable);
+      } else {
+        appendExceptionMessage(cause, appendable);
+      }
+    }
+  }
+
+  private static final class IndentedAppendable implements Appendable {
+    private static final String EMPTY_SEQUENCE = "";
+    private static final String INDENT = "  ";
+    private final Appendable appendable;
+    private boolean printedNewLine = true;
+
+    IndentedAppendable(Appendable appendable) {
+      this.appendable = appendable;
+    }
+
+    @Override
+    public Appendable append(char c) throws IOException {
+      if (printedNewLine) {
+        printedNewLine = false;
+        appendable.append(INDENT);
+      }
+      printedNewLine = c == '\n';
+      appendable.append(c);
+      return this;
+    }
+
+    @Override
+    public Appendable append(@Nullable CharSequence charSequence) throws IOException {
+      charSequence = safeSequence(charSequence);
+      return append(charSequence, 0, charSequence.length());
+    }
+
+    @Override
+    public Appendable append(@Nullable CharSequence charSequence, int start, int end)
+        throws IOException {
+      charSequence = safeSequence(charSequence);
+      if (printedNewLine) {
+        printedNewLine = false;
+        appendable.append(INDENT);
+      }
+      printedNewLine = charSequence.length() > 0 && charSequence.charAt(end - 1) == '\n';
+      appendable.append(charSequence, start, end);
+      return this;
+    }
+
+    @NonNull
+    private CharSequence safeSequence(@Nullable CharSequence sequence) {
+      if (sequence == null) {
+        return EMPTY_SEQUENCE;
+      } else {
+        return sequence;
+      }
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
new file mode 100644
index 000000000..4df0cc8ed
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -0,0 +1,83 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.v4.util.Pools.Pool;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataRewinder;
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * For a given {@link com.bumptech.glide.load.data.DataFetcher} for a given data class, attempts to
+ * fetch the data and then run it through one or more
+ * {@link com.bumptech.glide.load.engine.DecodePath}s.
+ *
+ * @param <Data>         The type of data that will be fetched.
+ * @param <ResourceType> The type of intermediate resource that will be decoded within one of the
+ *                       {@link com.bumptech.glide.load.engine.DecodePath}s.
+ * @param <Transcode>    The type of resource that will be returned as the result if the load and
+ *                       one of the decode paths succeeds.
+ */
+public class LoadPath<Data, ResourceType, Transcode> {
+  private final Class<Data> dataClass;
+  private final Pool<List<Exception>> listPool;
+  private final List<? extends DecodePath<Data, ResourceType, Transcode>> decodePaths;
+  private final String failureMessage;
+
+  public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
+      Class<Transcode> transcodeClass,
+      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Exception>> listPool) {
+    this.dataClass = dataClass;
+    this.listPool = listPool;
+    this.decodePaths = Preconditions.checkNotEmpty(decodePaths);
+    failureMessage = "Failed LoadPath{" + dataClass.getSimpleName() + "->"
+        + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
+  }
+
+  public Resource<Transcode> load(DataRewinder<Data> rewinder, Options options, int width,
+      int height, DecodePath.DecodeCallback<ResourceType> decodeCallback) throws GlideException {
+    List<Exception> exceptions = listPool.acquire();
+    try {
+      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, exceptions);
+    } finally {
+      listPool.release(exceptions);
+    }
+  }
+
+  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder, Options options,
+      int width, int height, DecodePath.DecodeCallback<ResourceType> decodeCallback,
+      List<Exception> exceptions) throws GlideException {
+    int size = decodePaths.size();
+    Resource<Transcode> result = null;
+    for (int i = 0; i < size; i++) {
+      DecodePath<Data, ResourceType, Transcode> path = decodePaths.get(i);
+      try {
+        result = path.decode(rewinder, width, height, options, decodeCallback);
+      } catch (GlideException e) {
+        exceptions.add(e);
+      }
+      if (result != null) {
+        break;
+      }
+    }
+
+    if (result == null) {
+      throw new GlideException(failureMessage, new ArrayList<>(exceptions));
+    }
+
+    return result;
+  }
+
+  public Class<Data> getDataClass() {
+    return dataClass;
+  }
+
+  @Override
+  public String toString() {
+    return "LoadPath{" + "decodePaths="
+        + Arrays.toString(decodePaths.toArray(new DecodePath[decodePaths.size()])) + '}';
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
new file mode 100644
index 000000000..3e21cc186
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.v4.util.Pools;
+
+import com.bumptech.glide.util.pool.FactoryPools;
+import com.bumptech.glide.util.pool.StateVerifier;
+
+/**
+ * A resource that defers any calls to {@link Resource#recycle()} until after {@link #unlock()} is
+ * called.
+ *
+ * <p>If the resource was recycled prior to {@link #unlock()}, then {@link #unlock()} will also
+ * recycle the resource.
+ */
+final class LockedResource<Z> implements Resource<Z>,
+    FactoryPools.Poolable {
+  private static final Pools.Pool<LockedResource<?>> POOL = FactoryPools.threadSafe(20,
+      new FactoryPools.Factory<LockedResource<?>>() {
+        @Override
+        public LockedResource<?> create() {
+          return new LockedResource<Object>();
+        }
+      });
+  private final StateVerifier stateVerifier = StateVerifier.newInstance();
+  private Resource<Z> toWrap;
+  private boolean isLocked;
+  private boolean isRecycled;
+
+  @SuppressWarnings("unchecked")
+  static <Z> LockedResource<Z> obtain(Resource<Z> resource) {
+    LockedResource<Z> result = (LockedResource<Z>) POOL.acquire();
+    result.init(resource);
+    return result;
+  }
+
+  private LockedResource() { }
+
+  private void init(Resource<Z> toWrap) {
+    isRecycled = false;
+    isLocked = true;
+    this.toWrap = toWrap;
+  }
+
+  private void release() {
+    toWrap = null;
+    POOL.release(this);
+  }
+
+  public synchronized void unlock() {
+    stateVerifier.throwIfRecycled();
+
+    if (!isLocked) {
+      throw new IllegalStateException("Already unlocked");
+    }
+    this.isLocked = false;
+    if (isRecycled) {
+      recycle();
+    }
+  }
+
+  @Override
+  public Class<Z> getResourceClass() {
+    return toWrap.getResourceClass();
+  }
+
+  @Override
+  public Z get() {
+    return toWrap.get();
+  }
+
+  @Override
+  public int getSize() {
+    return toWrap.getSize();
+  }
+
+  @Override
+  public synchronized void recycle() {
+    stateVerifier.throwIfRecycled();
+
+    this.isRecycled = true;
+    if (!isLocked) {
+      toWrap.recycle();
+      release();
+    }
+  }
+
+  @Override
+  public StateVerifier getVerifier() {
+    return stateVerifier;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/OriginalKey.java b/library/src/main/java/com/bumptech/glide/load/engine/OriginalKey.java
deleted file mode 100644
index d52e7b60e..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/OriginalKey.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import com.bumptech.glide.load.Key;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-
-/**
- * A class for keeping track of the cache key of the original data + any requested signature.
- */
-class OriginalKey implements Key {
-
-    private final String id;
-    private final Key signature;
-
-    public OriginalKey(String id, Key signature) {
-        this.id = id;
-        this.signature = signature;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
-
-        OriginalKey that = (OriginalKey) o;
-
-        if (!id.equals(that.id)) {
-            return false;
-        }
-        if (!signature.equals(that.signature)) {
-            return false;
-        }
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int result = id.hashCode();
-        result = 31 * result + signature.hashCode();
-        return result;
-    }
-
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-        messageDigest.update(id.getBytes(STRING_CHARSET_NAME));
-        signature.updateDiskCacheKey(messageDigest);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
index febe945d0..3717a889d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
@@ -8,41 +8,44 @@
  */
 public interface Resource<Z> {
 
-    /**
-     * Returns an instance of the wrapped resource.
-     * <p>
-     *     Note - This does not have to be the same instance of the wrapped resource class and in fact it is often
-     *     appropriate to return a new instance for each call. For example,
-     *     {@link android.graphics.drawable.Drawable Drawable}s should only be used by a single
-     *     {@link android.view.View View} at a time so each call to this method for Resources that wrap
-     *     {@link android.graphics.drawable.Drawable Drawable}s should always return a new
-     *     {@link android.graphics.drawable.Drawable Drawable}.
-     * </p>
-     */
-    Z get();
+  /**
+   * Returns the {@link Class} of the wrapped resource.
+   */
+  Class<Z> getResourceClass();
 
-    /**
-     * Returns the size in bytes of the wrapped resource to use to determine how much of the memory cache this resource
-     * uses.
-     */
-    int getSize();
+  /**
+   * Returns an instance of the wrapped resource.
+   *
+   * <p> Note - This does not have to be the same instance of the wrapped resource class and in fact
+   * it is often appropriate to return a new instance for each call. For example,
+   * {@link android.graphics.drawable.Drawable Drawable}s should only be used by a single
+   * {@link android.view.View View} at a time so each call to this method for Resources that wrap
+   * {@link android.graphics.drawable.Drawable Drawable}s should always return a new
+   * {@link android.graphics.drawable.Drawable Drawable}. </p>
+   */
+  Z get();
 
-     /**
-     * Cleans up and recycles internal resources.
-     *
-     * <p>
-     *     It is only safe to call this method if there are no current resource consumers and if this method has not
-     *     yet been called. Typically this occurs at one of two times:
-     *     <ul>
-     *         <li>During a resource load when the resource is transformed or transcoded before any consumer have
-     *         ever had access to this resource</li>
-     *         <li>After all consumers have released this resource and it has been evicted from the cache</li>
-     *     </ul>
-     *
-     *     For most users of this class, the only time this method should ever be called is during transformations or
-     *     transcoders, the framework will call this method when all consumers have released this resource and it has
-     *     been evicted from the cache.
-     * </p>
-     */
-    void recycle();
+  /**
+   * Returns the size in bytes of the wrapped resource to use to determine how much of the memory
+   * cache this resource uses.
+   */
+  int getSize();
+
+  /**
+   * Cleans up and recycles internal resources.
+   *
+   * <p> It is only safe to call this method if there are no current resource consumers and if this
+   * method has not yet been called. Typically this occurs at one of two times:
+   * <ul>
+   *   <li>During a resource load when the resource is transformed or transcoded before any consumer
+   *   have ever had access to this resource</li>
+   *   <li>After all consumers have released this resource and it has been evicted from the cache
+   *   </li>
+   * </ul>
+   *
+   * For most users of this class, the only time this method should ever be called is during
+   * transformations or transcoders, the framework will call this method when all consumers have
+   * released this resource and it has been evicted from the cache. </p>
+   */
+  void recycle();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
new file mode 100644
index 000000000..65c0decd0
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -0,0 +1,106 @@
+package com.bumptech.glide.load.engine;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoader.LoadData;
+
+import java.io.File;
+import java.util.List;
+
+/**
+ * Generates {@link com.bumptech.glide.load.data.DataFetcher DataFetchers} from cache files
+ * containing downsampled/transformed resource data.
+ */
+class ResourceCacheGenerator implements DataFetcherGenerator,
+    DataFetcher.DataCallback<Object> {
+
+  private final FetcherReadyCallback cb;
+  private final DecodeHelper<?> helper;
+
+  private int sourceIdIndex = 0;
+  private int resourceClassIndex = -1;
+  private Key sourceKey;
+  private List<ModelLoader<File, ?>> modelLoaders;
+  private int modelLoaderIndex;
+  private volatile LoadData<?> loadData;
+  // PMD is wrong here, this File must be an instance variable because it may be used across
+  // multiple calls to startNext.
+  @SuppressWarnings("PMD.SingularField")
+  private File cacheFile;
+  private ResourceCacheKey currentKey;
+
+  public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+    this.helper = helper;
+    this.cb = cb;
+  }
+
+  @Override
+  public boolean startNext() {
+    List<Key> sourceIds = helper.getCacheKeys();
+    List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
+    while (modelLoaders == null || !hasNextModelLoader()) {
+      resourceClassIndex++;
+      if (resourceClassIndex >= resourceClasses.size()) {
+        sourceIdIndex++;
+        if (sourceIdIndex >= sourceIds.size()) {
+          return false;
+        }
+        resourceClassIndex = 0;
+      }
+
+      Key sourceId = sourceIds.get(sourceIdIndex);
+      Class<?> resourceClass = resourceClasses.get(resourceClassIndex);
+      Transformation<?> transformation = helper.getTransformation(resourceClass);
+
+      currentKey = new ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),
+          helper.getHeight(), transformation, resourceClass, helper.getOptions());
+      cacheFile = helper.getDiskCache().get(currentKey);
+      if (cacheFile != null) {
+        this.sourceKey = sourceId;
+        modelLoaders = helper.getModelLoaders(cacheFile);
+        modelLoaderIndex = 0;
+      }
+    }
+
+    loadData = null;
+    boolean started = false;
+    while (!started && hasNextModelLoader()) {
+      ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
+      loadData =
+          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
+              helper.getOptions());
+      if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
+        started = true;
+        loadData.fetcher.loadData(helper.getPriority(), this);
+      }
+    }
+
+    return started;
+  }
+
+  private boolean hasNextModelLoader() {
+    return modelLoaderIndex < modelLoaders.size();
+  }
+
+  @Override
+  public void cancel() {
+    LoadData<?> local = loadData;
+    if (local != null) {
+      local.fetcher.cancel();
+    }
+  }
+
+  @Override
+  public void onDataReady(Object data) {
+    cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE,
+        currentKey);
+  }
+
+  @Override
+  public void onLoadFailed(Exception e) {
+    cb.onDataFetcherFailed(currentKey, e, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
new file mode 100644
index 000000000..ea3f11714
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -0,0 +1,98 @@
+package com.bumptech.glide.load.engine;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.util.LruCache;
+
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * A cache key for downsampled and transformed resource data + any requested signature.
+ */
+final class ResourceCacheKey implements Key {
+  private static final LruCache<Class<?>, byte[]> RESOURCE_CLASS_BYTES = new LruCache<>(50);
+  private final Key sourceKey;
+  private final Key signature;
+  private final int width;
+  private final int height;
+  private final Class<?> decodedResourceClass;
+  private final Options options;
+  private final Transformation<?> transformation;
+
+  public ResourceCacheKey(Key sourceKey, Key signature, int width, int height,
+      Transformation<?> appliedTransformation, Class<?> decodedResourceClass, Options options) {
+    this.sourceKey = sourceKey;
+    this.signature = signature;
+    this.width = width;
+    this.height = height;
+    this.transformation = appliedTransformation;
+    this.decodedResourceClass = decodedResourceClass;
+    this.options = options;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof ResourceCacheKey) {
+      ResourceCacheKey other = (ResourceCacheKey) o;
+      return height == other.height && width == other.width
+          && (transformation == null
+              ? other.transformation == null : transformation.equals(other.transformation))
+          && decodedResourceClass.equals(other.decodedResourceClass)
+          && sourceKey.equals(other.sourceKey) && signature.equals(other.signature)
+          && options.equals(other.options);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = sourceKey.hashCode();
+    result = 31 * result + signature.hashCode();
+    result = 31 * result + width;
+    result = 31 * result + height;
+    if (transformation != null) {
+      result = 31 * result + transformation.hashCode();
+    }
+    result = 31 * result + decodedResourceClass.hashCode();
+    result = 31 * result + options.hashCode();
+    return result;
+  }
+
+  // TODO: Include relevant options?
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    byte[] dimensions = ByteBuffer.allocate(8).putInt(width).putInt(height).array();
+    signature.updateDiskCacheKey(messageDigest);
+    sourceKey.updateDiskCacheKey(messageDigest);
+    messageDigest.update(dimensions);
+    if (transformation != null) {
+      transformation.updateDiskCacheKey(messageDigest);
+    }
+    options.updateDiskCacheKey(messageDigest);
+    messageDigest.update(getResourceClassBytes());
+  }
+
+  private byte[] getResourceClassBytes() {
+    byte[] result = RESOURCE_CLASS_BYTES.get(decodedResourceClass);
+    if (result == null) {
+      result = decodedResourceClass.getName().getBytes(CHARSET);
+      RESOURCE_CLASS_BYTES.put(decodedResourceClass, result);
+    }
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "ResourceCacheKey{"
+        + "sourceKey=" + sourceKey
+        + ", signature=" + signature
+        + ", width=" + width
+        + ", height=" + height
+        + ", decodedResourceClass=" + decodedResourceClass
+        + ", transformation='" + transformation + '\''
+        + ", options=" + options
+        + '}';
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index c30376cf6..ddd5d55cb 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Handler;
+import android.os.Looper;
 import android.os.Message;
 
 import com.bumptech.glide.util.Util;
@@ -9,34 +10,37 @@
  * A class that can safely recycle recursive resources.
  */
 class ResourceRecycler {
-    private boolean isRecycling;
-    private final Handler handler = new Handler(new ResourceRecyclerCallback());
+  private boolean isRecycling;
+  private final Handler handler =
+      new Handler(Looper.getMainLooper(), new ResourceRecyclerCallback());
 
-    public void recycle(Resource<?> resource) {
-        Util.assertMainThread();
+  public void recycle(Resource<?> resource) {
+    Util.assertMainThread();
 
-        if (isRecycling) {
-            // If a resource has sub-resources, releasing a sub resource can cause it's parent to be synchronously
-            // evicted which leads to a recycle loop when the parent releases it's children. Posting breaks this loop.
-            handler.obtainMessage(ResourceRecyclerCallback.RECYCLE_RESOURCE, resource).sendToTarget();
-        } else {
-            isRecycling = true;
-            resource.recycle();
-            isRecycling = false;
-        }
+    if (isRecycling) {
+      // If a resource has sub-resources, releasing a sub resource can cause it's parent to be
+      // synchronously
+      // evicted which leads to a recycle loop when the parent releases it's children. Posting
+      // breaks this loop.
+      handler.obtainMessage(ResourceRecyclerCallback.RECYCLE_RESOURCE, resource).sendToTarget();
+    } else {
+      isRecycling = true;
+      resource.recycle();
+      isRecycling = false;
     }
+  }
 
-    private static class ResourceRecyclerCallback implements Handler.Callback {
-        public static final int RECYCLE_RESOURCE = 1;
+  private static class ResourceRecyclerCallback implements Handler.Callback {
+    public static final int RECYCLE_RESOURCE = 1;
 
-        @Override
-        public boolean handleMessage(Message message) {
-            if (message.what == RECYCLE_RESOURCE) {
-                Resource resource = (Resource) message.obj;
-                resource.recycle();
-                return true;
-            }
-            return false;
-        }
+    @Override
+    public boolean handleMessage(Message message) {
+      if (message.what == RECYCLE_RESOURCE) {
+        Resource resource = (Resource) message.obj;
+        resource.recycle();
+        return true;
+      }
+      return false;
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
new file mode 100644
index 000000000..275ea1b06
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -0,0 +1,144 @@
+package com.bumptech.glide.load.engine;
+
+import android.util.Log;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoader.LoadData;
+import com.bumptech.glide.util.LogTime;
+
+import java.util.Collections;
+
+/**
+ * Generates {@link com.bumptech.glide.load.data.DataFetcher DataFetchers} from original source data
+ * using registered {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders} and the model
+ * provided for the load.
+ *
+ * <p> Depending on the disk cache strategy, source data may first be written to disk and then
+ * loaded from the cache file rather than returned directly. </p>
+ */
+class SourceGenerator implements DataFetcherGenerator,
+    DataFetcher.DataCallback<Object>,
+    DataFetcherGenerator.FetcherReadyCallback {
+  private static final String TAG = "SourceGenerator";
+
+  private final DecodeHelper<?> helper;
+  private final FetcherReadyCallback cb;
+
+  private int loadDataListIndex;
+  private DataCacheGenerator sourceCacheGenerator;
+  private Object dataToCache;
+  private volatile ModelLoader.LoadData<?> loadData;
+  private DataCacheKey originalKey;
+
+  public SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+    this.helper = helper;
+    this.cb = cb;
+  }
+
+  @Override
+  public boolean startNext() {
+    if (dataToCache != null) {
+      Object data = dataToCache;
+      dataToCache = null;
+      cacheData(data);
+    }
+
+    if (sourceCacheGenerator != null && sourceCacheGenerator.startNext()) {
+      return true;
+    }
+    sourceCacheGenerator = null;
+
+    loadData = null;
+    boolean started = false;
+    while (!started && hasNextModelLoader()) {
+      loadData = helper.getLoadData().get(loadDataListIndex++);
+      if (loadData != null
+          && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
+          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
+        started = true;
+        loadData.fetcher.loadData(helper.getPriority(), this);
+      }
+    }
+    return started;
+  }
+
+  private boolean hasNextModelLoader() {
+    return loadDataListIndex < helper.getLoadData().size();
+  }
+
+  private void cacheData(Object dataToCache) {
+    long startTime = LogTime.getLogTime();
+    try {
+      Encoder<Object> encoder = helper.getSourceEncoder(dataToCache);
+      DataCacheWriter<Object> writer =
+          new DataCacheWriter<>(encoder, dataToCache, helper.getOptions());
+      originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());
+      helper.getDiskCache().put(originalKey, writer);
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Finished encoding source to cache"
+            + ", key: " + originalKey
+            + ", data: " + dataToCache
+            + ", encoder: " + encoder
+            + ", duration: " + LogTime.getElapsedMillis(startTime));
+      }
+    } finally {
+      loadData.fetcher.cleanup();
+    }
+
+    sourceCacheGenerator =
+        new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);
+  }
+
+  @Override
+  public void cancel() {
+    LoadData<?> local = loadData;
+    if (local != null) {
+      local.fetcher.cancel();
+    }
+  }
+
+  @Override
+  public void onDataReady(Object data) {
+    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();
+    if (data != null && diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) {
+      dataToCache = data;
+      // We might be being called back on someone else's thread. Before doing anything, we should
+      // reschedule to get back onto Glide's thread.
+      cb.reschedule();
+    } else {
+      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,
+          loadData.fetcher.getDataSource(), originalKey);
+    }
+  }
+
+  @Override
+  public void onLoadFailed(Exception e) {
+    cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());
+  }
+
+  @Override
+  public void reschedule() {
+    // We don't expect this to happen, although if we ever need it to we can delegate to our
+    // callback.
+    throw new UnsupportedOperationException();
+  }
+
+  // Called from source cache generator.
+  @Override
+  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
+      DataSource dataSource, Key attemptedKey) {
+    // This data fetcher will be loading from a File and provide the wrong data source, so override
+    // with the data source of the original fetcher
+    cb.onDataFetcherReady(sourceKey, data, fetcher, loadData.fetcher.getDataSource(), sourceKey);
+  }
+
+  @Override
+  public void onDataFetcherFailed(Key sourceKey, Exception e, DataFetcher<?> fetcher,
+      DataSource dataSource) {
+    cb.onDataFetcherFailed(sourceKey, e, fetcher, loadData.fetcher.getDataSource());
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
new file mode 100644
index 000000000..048a43247
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+/**
+ * Interface for handling operations on a primitive array type.
+ * @param <T> Array type (eg byte[], int[])
+ */
+public interface ArrayAdapterInterface<T> {
+
+  /**
+   * TAG for logging.
+   */
+  String getTag();
+
+  /**
+   * Return the length of the given array.
+   */
+  int getArrayLength(T array);
+
+  /**
+   * Reset the array for re-use (e.g. set all values to 0).
+   */
+  void resetArray(T array);
+
+  /**
+   * Allocate and return an array of the specified size.
+   */
+  T newArray(int length);
+
+  /**
+   * Return the size of an element in the array in bytes (e.g. for int return 4).
+   */
+  int getElementSizeInBytes();
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
new file mode 100644
index 000000000..a945ca874
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * Interface for an array pool that pools arrays of different types.
+ */
+public interface ArrayPool {
+  /**
+   * Optionally adds the given array of the given type to the pool.
+   *
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
+   * pool.
+   */
+  <T> void put(T array, Class<T> arrayClass);
+
+  /**
+   * Returns a non-null array of the given type with a length >= to the given size.
+   *
+   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   */
+  <T> T get(int size, Class<T> arrayClass);
+  /**
+   * Clears all arrays from the pool.
+   */
+  void clearMemory();
+
+  /**
+   * Trims the size to the appropriate level.
+   *
+   * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
+   */
+  void trimMemory(int level);
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index eebd1fd53..1a24f4c9c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -5,117 +5,116 @@
 import com.bumptech.glide.util.Util;
 
 /**
- * A strategy for reusing bitmaps that requires any returned bitmap's dimensions to exactly match those request.
+ * A strategy for reusing bitmaps that requires any returned bitmap's dimensions to exactly match
+ * those request.
  */
 class AttributeStrategy implements LruPoolStrategy {
-    private final KeyPool keyPool = new KeyPool();
-    private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<Key, Bitmap>();
-
-    public void put(Bitmap bitmap) {
-        final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
-
-        groupedMap.put(key, bitmap);
+  private final KeyPool keyPool = new KeyPool();
+  private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
+
+  public void put(Bitmap bitmap) {
+    final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
+
+    groupedMap.put(key, bitmap);
+  }
+
+  @Override
+  public Bitmap get(int width, int height, Bitmap.Config config) {
+    final Key key = keyPool.get(width, height, config);
+
+    return groupedMap.get(key);
+  }
+
+  @Override
+  public Bitmap removeLast() {
+    return groupedMap.removeLast();
+  }
+
+  @Override
+  public String logBitmap(Bitmap bitmap) {
+    return getBitmapString(bitmap);
+  }
+
+  @Override
+  public String logBitmap(int width, int height, Bitmap.Config config) {
+    return getBitmapString(width, height, config);
+  }
+
+  @Override
+  public int getSize(Bitmap bitmap) {
+    return Util.getBitmapByteSize(bitmap);
+  }
+
+  @Override
+  public String toString() {
+    return "AttributeStrategy:\n  " + groupedMap;
+  }
+
+  private static String getBitmapString(Bitmap bitmap) {
+    return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
+  }
+
+  private static String getBitmapString(int width, int height, Bitmap.Config config) {
+    return "[" + width + "x" + height + "], " + config;
+  }
+
+  // Visible for testing.
+  static class KeyPool extends BaseKeyPool<Key> {
+    public Key get(int width, int height, Bitmap.Config config) {
+      Key result = get();
+      result.init(width, height, config);
+      return result;
     }
 
     @Override
-    public Bitmap get(int width, int height, Bitmap.Config config) {
-        final Key key = keyPool.get(width, height, config);
-
-        return groupedMap.get(key);
+    protected Key create() {
+      return new Key(this);
     }
-
-    @Override
-    public Bitmap removeLast() {
-        return groupedMap.removeLast();
+  }
+
+  // Visible for testing.
+  static class Key implements Poolable {
+    private final KeyPool pool;
+    private int width;
+    private int height;
+    // Config can be null :(
+    private Bitmap.Config config;
+
+    public Key(KeyPool pool) {
+      this.pool = pool;
     }
 
-    @Override
-    public String logBitmap(Bitmap bitmap) {
-        return getBitmapString(bitmap);
+    public void init(int width, int height, Bitmap.Config config) {
+      this.width = width;
+      this.height = height;
+      this.config = config;
     }
 
     @Override
-    public String logBitmap(int width, int height, Bitmap.Config config) {
-        return getBitmapString(width, height, config);
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return width == other.width && height == other.height && config == other.config;
+      }
+      return false;
     }
 
     @Override
-    public int getSize(Bitmap bitmap) {
-        return Util.getBitmapByteSize(bitmap);
+    public int hashCode() {
+      int result = width;
+      result = 31 * result + height;
+      result = 31 * result + (config != null ? config.hashCode() : 0);
+      return result;
     }
 
     @Override
     public String toString() {
-        return "AttributeStrategy:\n  " + groupedMap;
+      return getBitmapString(width, height, config);
     }
 
-    private static String getBitmapString(Bitmap bitmap) {
-        return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
-    }
-
-    private static String getBitmapString(int width, int height, Bitmap.Config config) {
-        return "[" + width + "x" + height + "], " + config;
-    }
-
-    // Visible for testing.
-    static class KeyPool extends BaseKeyPool<Key> {
-        public Key get(int width, int height, Bitmap.Config config) {
-            Key result = get();
-            result.init(width, height, config);
-            return result;
-        }
-
-        @Override
-        protected Key create() {
-            return new Key(this);
-        }
-    }
-
-    // Visible for testing.
-    static class Key implements Poolable {
-        private final KeyPool pool;
-        private int width;
-        private int height;
-        // Config can be null :(
-        private Bitmap.Config config;
-
-        public Key(KeyPool pool) {
-            this.pool = pool;
-        }
-
-        public void init(int width, int height, Bitmap.Config config) {
-            this.width = width;
-            this.height = height;
-            this.config = config;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Key) {
-                Key other = (Key) o;
-                return width == other.width
-                        && height == other.height
-                        && config == other.config;
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = width;
-            result = 31 * result + height;
-            result = 31 * result + (config != null ? config.hashCode() : 0);
-            return result;
-        }
-
-        @Override
-        public String toString() {
-            return getBitmapString(width, height, config);
-        }
-
-        @Override
-        public void offer() {
-            pool.offer(this);
-        }
+    @Override
+    public void offer() {
+      pool.offer(this);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
index bfd8d373a..32702852b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
@@ -5,22 +5,22 @@
 import java.util.Queue;
 
 abstract class BaseKeyPool<T extends Poolable> {
-    private static final int MAX_SIZE = 20;
-    private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);
+  private static final int MAX_SIZE = 20;
+  private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);
 
-    protected T get() {
-        T result = keyPool.poll();
-        if (result == null) {
-            result = create();
-        }
-        return result;
+  protected T get() {
+    T result = keyPool.poll();
+    if (result == null) {
+      result = create();
     }
+    return result;
+  }
 
-    public void offer(T key) {
-        if (keyPool.size() < MAX_SIZE) {
-            keyPool.offer(key);
-        }
+  public void offer(T key) {
+    if (keyPool.size() < MAX_SIZE) {
+      keyPool.offer(key);
     }
+  }
 
-    protected abstract T create();
+  protected abstract T create();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
index 0390a6681..3fecc0360 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
@@ -1,114 +1,108 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 
 /**
  * An interface for a pool that allows users to reuse {@link android.graphics.Bitmap} objects.
  */
 public interface BitmapPool {
 
-    /**
-     * Returns the current maximum size of the pool in bytes.
-     */
-    int getMaxSize();
+  /**
+   * Returns the current maximum size of the pool in bytes.
+   */
+  int getMaxSize();
 
-    /**
-     * Multiplies the initial size of the pool by the given multipler to dynamically and synchronously allow users to
-     * adjust the size of the pool.
-     *
-     * <p>
-     *     If the current total size of the pool is larger than the max size after the given multiplier is applied,
-     *     {@link Bitmap}s should be evicted until the pool is smaller than the new max size.
-     * </p>
-     *
-     * @param sizeMultiplier The size multiplier to apply between 0 and 1.
-     */
-    void setSizeMultiplier(float sizeMultiplier);
+  /**
+   * Multiplies the initial size of the pool by the given multiplier to dynamically and
+   * synchronously allow users to adjust the size of the pool.
+   *
+   * <p> If the current total size of the pool is larger than the max size after the given
+   * multiplier is applied, {@link Bitmap}s should be evicted until the pool is smaller than the new
+   * max size. </p>
+   *
+   * @param sizeMultiplier The size multiplier to apply between 0 and 1.
+   */
+  void setSizeMultiplier(float sizeMultiplier);
 
-    /**
-     * Adds the given {@link android.graphics.Bitmap} and returns {@code true} if the {@link android.graphics.Bitmap}
-     * was eligible to be added and {@code false} otherwise.
-     *
-     * <p>
-     *     Note - If the {@link android.graphics.Bitmap} is rejected (this method returns false) then it is the caller's
-     *     responsibility to call {@link android.graphics.Bitmap#recycle()}.
-     * </p>
-     *
-     * <p>
-     *     Note - This method will return {@code true} if the given {@link android.graphics.Bitmap} is synchronously
-     *     evicted after being accepted. The only time this method will return {@code false} is if the
-     *     {@link android.graphics.Bitmap} is not eligible to be added to the pool (either it is not mutable or it is
-     *     larger than the max pool size).
-     * </p>
-     *
-     * @see android.graphics.Bitmap#isMutable()
-     * @see android.graphics.Bitmap#recycle()
-     *
-     * @param bitmap The {@link android.graphics.Bitmap} to attempt to add.
-     */
-    boolean put(Bitmap bitmap);
+  /**
+   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool
+   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it.
+   *
+   * <p> Callers must <em>not</em> continue to use the Bitmap after calling this method. </p>
+   *
+   * @param bitmap The {@link android.graphics.Bitmap} to attempt to add.
+   * @see android.graphics.Bitmap#isMutable()
+   * @see android.graphics.Bitmap#recycle()
+   */
+  void put(Bitmap bitmap);
 
-    /**
-     * Returns a {@link android.graphics.Bitmap} of exactly the given width, height, and configuration, and containing
-     * only transparent pixels or null if no such {@link android.graphics.Bitmap} could be obtained from the pool.
-     *
-     * <p>
-     *     Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower than
-     *     {@link #getDirty(int, int, android.graphics.Bitmap.Config)}. If the {@link android.graphics.Bitmap} is being
-     *     obtained to be used in {@link android.graphics.BitmapFactory} or in any other case where every pixel in the
-     *     {@link android.graphics.Bitmap} will always be overwritten or cleared,
-     *     {@link #getDirty(int, int, android.graphics.Bitmap.Config)} will be faster. When in doubt, use this method
-     *     to ensure correctness.
-     * </p>
-     *
-     * <pre>
-     *     Implementations can should clear out every returned Bitmap using the following:
-     *
-     * {@code
-     * bitmap.eraseColor(Color.TRANSPARENT);
-     * }
-     * </pre>
-     *
-     * @see #getDirty(int, int, android.graphics.Bitmap.Config)
-     *
-     * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
-     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
-     * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link android.graphics.Bitmap}.
-     */
-    Bitmap get(int width, int height, Bitmap.Config config);
+  /**
+   * Returns a {@link android.graphics.Bitmap} of exactly the given width, height, and
+   * configuration, and containing only transparent pixels.
+   *
+   * <p> If no Bitmap with the requested attributes is present in the pool, a new one will be
+   * allocated. </p>
+   *
+   * <p> Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower
+   * than {@link #getDirty(int, int, android.graphics.Bitmap.Config)}. If the {@link
+   * android.graphics.Bitmap} is being obtained to be used in {@link android.graphics.BitmapFactory}
+   * or in any other case where every pixel in the {@link android.graphics.Bitmap} will always be
+   * overwritten or cleared, {@link #getDirty(int, int, android.graphics.Bitmap.Config)} will be
+   * faster. When in doubt, use this method to ensure correctness. </p>
+   *
+   * <pre>
+   *     Implementations can should clear out every returned Bitmap using the following:
+   *
+   * {@code
+   * bitmap.eraseColor(Color.TRANSPARENT);
+   * }
+   * </pre>
+   *
+   * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
+   * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
+   * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
+   *               android.graphics.Bitmap}.
+   * @see #getDirty(int, int, android.graphics.Bitmap.Config)
+   */
+  @NonNull
+  Bitmap get(int width, int height, Bitmap.Config config);
 
-    /**
-     * Identical to {@link #get(int, int, android.graphics.Bitmap.Config)} except that any returned non-null
-     * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data.
-     *
-     * <p>
-     *     Although this method is slightly more efficient than {@link #get(int, int, android.graphics.Bitmap.Config)}
-     *     it should be used with caution and only when the caller is sure that they are going to erase the
-     *     {@link android.graphics.Bitmap} entirely before writing new data to it.
-     * </p>
-     *
-     * @see #get(int, int, android.graphics.Bitmap.Config)
-     *
-     * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
-     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
-     * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link android.graphics.Bitmap}.
-     * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config potentially containing
-     * random image data or null if no such {@link android.graphics.Bitmap} could be obtained from the pool.
-     */
-    Bitmap getDirty(int width, int height, Bitmap.Config config);
+  /**
+   * Identical to {@link #get(int, int, android.graphics.Bitmap.Config)} except that any returned
+   * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data.
+   *
+   * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be
+   * allocated. </p>
+   *
+   * <p> Although this method is slightly more efficient than {@link #get(int, int,
+   * android.graphics.Bitmap.Config)} it should be used with caution and only when the caller is
+   * sure that they are going to erase the {@link android.graphics.Bitmap} entirely before writing
+   * new data to it. </p>
+   *
+   * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
+   * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
+   * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
+   *               android.graphics.Bitmap}.
+   * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config
+   * potentially containing random image data or null if no such {@link android.graphics.Bitmap}
+   * could be obtained from the pool.
+   * @see #get(int, int, android.graphics.Bitmap.Config)
+   */
+  @NonNull
+  Bitmap getDirty(int width, int height, Bitmap.Config config);
 
-    /**
-     * Removes all {@link android.graphics.Bitmap}s from the pool.
-     */
-    void clearMemory();
+  /**
+   * Removes all {@link android.graphics.Bitmap}s from the pool.
+   */
+  void clearMemory();
 
-    /**
-     * Reduces the size of the cache by evicting items based on the given level.
-     *
-     * @see android.content.ComponentCallbacks2
-     *
-     * @param level The level from {@link android.content.ComponentCallbacks2} to use to determine how many
-     * {@link android.graphics.Bitmap}s to evict.
-     */
-    void trimMemory(int level);
+  /**
+   * Reduces the size of the cache by evicting items based on the given level.
+   *
+   * @param level The level from {@link android.content.ComponentCallbacks2} to use to determine how
+   *              many {@link android.graphics.Bitmap}s to evict.
+   * @see android.content.ComponentCallbacks2
+   */
+  void trimMemory(int level);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
index ebffc1bec..af72c1b82 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
@@ -1,44 +1,48 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 
 /**
- * An {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool BitmapPool} implementation that rejects all
- * {@link android.graphics.Bitmap Bitmap}s added to it and always returns {@code null} from get.
+ * An {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool BitmapPool} implementation
+ * that rejects all {@link android.graphics.Bitmap Bitmap}s added to it and always returns {@code
+ * null} from get.
  */
 public class BitmapPoolAdapter implements BitmapPool {
-    @Override
-    public int getMaxSize() {
-        return 0;
-    }
-
-    @Override
-    public void setSizeMultiplier(float sizeMultiplier) {
-        // Do nothing.
-    }
-
-    @Override
-    public boolean put(Bitmap bitmap) {
-        return false;
-    }
-
-    @Override
-    public Bitmap get(int width, int height, Bitmap.Config config) {
-        return null;
-    }
-
-    @Override
-    public Bitmap getDirty(int width, int height, Bitmap.Config config) {
-        return null;
-    }
-
-    @Override
-    public void clearMemory() {
-        // Do nothing.
-    }
-
-    @Override
-    public void trimMemory(int level) {
-        // Do nothing.
-    }
+  @Override
+  public int getMaxSize() {
+    return 0;
+  }
+
+  @Override
+  public void setSizeMultiplier(float sizeMultiplier) {
+    // Do nothing.
+  }
+
+  @Override
+  public void put(Bitmap bitmap) {
+    bitmap.recycle();
+  }
+
+  @NonNull
+  @Override
+  public Bitmap get(int width, int height, Bitmap.Config config) {
+    return Bitmap.createBitmap(width, height, config);
+  }
+
+  @NonNull
+  @Override
+  public Bitmap getDirty(int width, int height, Bitmap.Config config) {
+    return get(width, height, config);
+  }
+
+  @Override
+  public void clearMemory() {
+    // Do nothing.
+  }
+
+  @Override
+  public void trimMemory(int level) {
+    // Do nothing.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
new file mode 100644
index 000000000..910dee2f0
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import java.util.Arrays;
+
+/**
+ * Adapter for handling primitive byte arrays.
+ */
+public final class ByteArrayAdapter implements ArrayAdapterInterface<byte[]> {
+  private static final String TAG = "ByteArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(byte[] array) {
+    return array.length;
+  }
+
+  @Override
+  public void resetArray(byte[] array) {
+    Arrays.fill(array, (byte) 0);
+  }
+
+  @Override
+  public byte[] newArray(int length) {
+    return new byte[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 1;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
new file mode 100644
index 000000000..df88773ff
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
@@ -0,0 +1,28 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * Pool containing byte[] arrays of various sizes.
+ * TODO: this should be replaced with an ArrayPool
+ */
+public interface ByteArrayPool {
+  /**
+   * A standard size to use to increase hit rates when the required size isn't defined.
+   * Currently 64KB.
+   */
+  int STANDARD_BUFFER_SIZE_BYTES = 64 * 1024;
+
+  /**
+   * Optionally adds the given byte array to the pool.
+   *
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
+   * pool.
+   */
+  void put(byte[] bytes);
+
+  /**
+   * Returns a non-null byte array with a length >= to the given size.
+   *
+   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   */
+  byte[] get(int size);
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index cbf4f8acc..ea29e42ad 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -1,146 +1,156 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
+import android.support.annotation.Nullable;
+
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 /**
- * Similar to {@link java.util.LinkedHashMap} when access ordered except that it is access ordered on groups
- * of bitmaps rather than individual objects. The idea is to be able to find the LRU bitmap size, rather than the
- * LRU bitmap object. We can then remove bitmaps from the least recently used size of bitmap when we need to
- * reduce our cache size.
+ * Similar to {@link java.util.LinkedHashMap} when access ordered except that it is access ordered
+ * on groups of bitmaps rather than individual objects. The idea is to be able to find the LRU
+ * bitmap size, rather than the LRU bitmap object. We can then remove bitmaps from the least
+ * recently used size of bitmap when we need to reduce our cache size.
  *
- * For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even if no bitmaps
- * of that size are present. We do not count addition or removal of bitmaps as an access.
+ * For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even if
+ * no bitmaps of that size are present. We do not count addition or removal of bitmaps as an
+ * access.
  */
 class GroupedLinkedMap<K extends Poolable, V> {
-    private final LinkedEntry<K, V> head = new LinkedEntry<K, V>();
-    private final Map<K, LinkedEntry<K, V>> keyToEntry = new HashMap<K, LinkedEntry<K, V>>();
-
-    public void put(K key, V value) {
-        LinkedEntry<K, V> entry = keyToEntry.get(key);
-
-        if (entry == null) {
-            entry = new LinkedEntry<K, V>(key);
-            makeTail(entry);
-            keyToEntry.put(key, entry);
-        } else {
-            key.offer();
-        }
-
-        entry.add(value);
+  private final LinkedEntry<K, V> head = new LinkedEntry<>();
+  private final Map<K, LinkedEntry<K, V>> keyToEntry = new HashMap<>();
+
+  public void put(K key, V value) {
+    LinkedEntry<K, V> entry = keyToEntry.get(key);
+
+    if (entry == null) {
+      entry = new LinkedEntry<>(key);
+      makeTail(entry);
+      keyToEntry.put(key, entry);
+    } else {
+      key.offer();
     }
 
-    public V get(K key) {
-        LinkedEntry<K, V> entry = keyToEntry.get(key);
-        if (entry == null) {
-            entry = new LinkedEntry<K, V>(key);
-            keyToEntry.put(key, entry);
-        } else {
-            key.offer();
-        }
-
-        makeHead(entry);
-
-        return entry.removeLast();
+    entry.add(value);
+  }
+
+  @Nullable
+  public V get(K key) {
+    LinkedEntry<K, V> entry = keyToEntry.get(key);
+    if (entry == null) {
+      entry = new LinkedEntry<>(key);
+      keyToEntry.put(key, entry);
+    } else {
+      key.offer();
     }
 
-    public V removeLast() {
-        LinkedEntry<K, V> last = head.prev;
-
-        while (!last.equals(head)) {
-            V removed = last.removeLast();
-            if (removed != null) {
-                return removed;
-            } else {
-                // We will clean up empty lru entries since they are likely to have been one off or unusual sizes and
-                // are not likely to be requested again so the gc thrash should be minimal. Doing so will speed up our
-                // removeLast operation in the future and prevent our linked list from growing to arbitrarily large
-                // sizes.
-                removeEntry(last);
-                keyToEntry.remove(last.key);
-                last.key.offer();
-            }
-
-            last = last.prev;
-        }
-
-        return null;
+    makeHead(entry);
+
+    return entry.removeLast();
+  }
+
+  @Nullable
+  public V removeLast() {
+    LinkedEntry<K, V> last = head.prev;
+
+    while (!last.equals(head)) {
+      V removed = last.removeLast();
+      if (removed != null) {
+        return removed;
+      } else {
+        // We will clean up empty lru entries since they are likely to have been one off or
+        // unusual sizes and
+        // are not likely to be requested again so the gc thrash should be minimal. Doing so will
+        // speed up our
+        // removeLast operation in the future and prevent our linked list from growing to
+        // arbitrarily large
+        // sizes.
+        removeEntry(last);
+        keyToEntry.remove(last.key);
+        last.key.offer();
+      }
+
+      last = last.prev;
     }
 
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder("GroupedLinkedMap( ");
-        LinkedEntry<K, V> current = head.next;
-        boolean hadAtLeastOneItem = false;
-        while (!current.equals(head)) {
-            hadAtLeastOneItem = true;
-            sb.append('{').append(current.key).append(':').append(current.size()).append("}, ");
-            current = current.next;
-        }
-        if (hadAtLeastOneItem) {
-            sb.delete(sb.length() - 2, sb.length());
-        }
-        return sb.append(" )").toString();
+    return null;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("GroupedLinkedMap( ");
+    LinkedEntry<K, V> current = head.next;
+    boolean hadAtLeastOneItem = false;
+    while (!current.equals(head)) {
+      hadAtLeastOneItem = true;
+      sb.append('{').append(current.key).append(':').append(current.size()).append("}, ");
+      current = current.next;
     }
-
-    // Make the entry the most recently used item.
-    private void makeHead(LinkedEntry<K, V> entry) {
-        removeEntry(entry);
-        entry.prev = head;
-        entry.next = head.next;
-        updateEntry(entry);
+    if (hadAtLeastOneItem) {
+      sb.delete(sb.length() - 2, sb.length());
+    }
+    return sb.append(" )").toString();
+  }
+
+  // Make the entry the most recently used item.
+  private void makeHead(LinkedEntry<K, V> entry) {
+    removeEntry(entry);
+    entry.prev = head;
+    entry.next = head.next;
+    updateEntry(entry);
+  }
+
+  // Make the entry the least recently used item.
+  private void makeTail(LinkedEntry<K, V> entry) {
+    removeEntry(entry);
+    entry.prev = head.prev;
+    entry.next = head;
+    updateEntry(entry);
+  }
+
+  private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {
+    entry.next.prev = entry;
+    entry.prev.next = entry;
+  }
+
+  private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {
+    entry.prev.next = entry.next;
+    entry.next.prev = entry.prev;
+  }
+
+  private static class LinkedEntry<K, V> {
+    private final K key;
+    private List<V> values;
+    LinkedEntry<K, V> next;
+    LinkedEntry<K, V> prev;
+
+    // Used only for the first item in the list which we will treat specially and which will not
+    // contain a value.
+    public LinkedEntry() {
+      this(null);
     }
 
-    // Make the entry the least recently used item.
-    private void makeTail(LinkedEntry<K, V> entry) {
-        removeEntry(entry);
-        entry.prev = head.prev;
-        entry.next = head;
-        updateEntry(entry);
+    public LinkedEntry(K key) {
+      next = prev = this;
+      this.key = key;
     }
 
-    private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {
-        entry.next.prev = entry;
-        entry.prev.next = entry;
+    @Nullable
+    public V removeLast() {
+      final int valueSize = size();
+      return valueSize > 0 ? values.remove(valueSize - 1) : null;
     }
 
-    private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {
-        entry.prev.next = entry.next;
-        entry.next.prev = entry.prev;
+    public int size() {
+      return values != null ? values.size() : 0;
     }
 
-    private static class LinkedEntry<K, V> {
-        private final K key;
-        private List<V> values;
-        LinkedEntry<K, V> next;
-        LinkedEntry<K, V> prev;
-
-        // Used only for the first item in the list which we will treat specially and which will not contain a value.
-        public LinkedEntry() {
-            this(null);
-        }
-
-        public LinkedEntry(K key) {
-            next = prev = this;
-            this.key = key;
-        }
-
-        public V removeLast() {
-            final int valueSize = size();
-            return valueSize > 0 ? values.remove(valueSize - 1) : null;
-        }
-
-        public int size() {
-            return values != null ? values.size() : 0;
-        }
-
-        public void add(V value) {
-            if (values == null) {
-                values = new ArrayList<V>();
-            }
-            values.add(value);
-        }
+    public void add(V value) {
+      if (values == null) {
+        values = new ArrayList<>();
+      }
+      values.add(value);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
new file mode 100644
index 000000000..b0a563c21
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import java.util.Arrays;
+
+/**
+ * Adapter for handling primitive int arrays.
+ */
+public final class IntegerArrayAdapter implements ArrayAdapterInterface<int[]> {
+  private static final String TAG = "IntegerArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(int[] array) {
+    return array.length;
+  }
+
+  @Override
+  public void resetArray(int[] array) {
+    Arrays.fill(array, 0);
+  }
+
+  @Override
+  public int[] newArray(int length) {
+    return new int[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 4;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
new file mode 100644
index 000000000..10f17c25f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -0,0 +1,252 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
+/**
+ * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under
+ * the maximum byte size.
+ */
+public final class LruArrayPool implements ArrayPool {
+
+  /**
+   * The maximum number of times larger an int array may be to be than a requested size to eligble
+   * to be returned from the pool.
+   */
+  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
+  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
+
+  private final GroupedLinkedMap<Key, Object> groupedMap = new GroupedLinkedMap<>();
+  private final KeyPool keyPool = new KeyPool();
+  private final Map<Class, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
+  private final Map<Class, ArrayAdapterInterface> adapters = new HashMap<>();
+  private final int maxSize;
+  private int currentSize;
+
+  /**
+   * Constructor for a new pool.
+   *
+   * @param maxSize The maximum size in integers of the pool.
+   */
+  public LruArrayPool(int maxSize) {
+    this.maxSize = maxSize;
+  }
+
+  @Override
+  public synchronized <T> void put(T array, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    int size = arrayAdapter.getArrayLength(array);
+    if (!isSmallEnoughForReuse(size)) {
+      return;
+    }
+    Key key = keyPool.get(size, arrayClass);
+
+    groupedMap.put(key, array);
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(key.size);
+    sizes.put(key.size, current == null ? 1 : current + 1);
+    currentSize += size * arrayAdapter.getElementSizeInBytes();
+    evict();
+  }
+
+  @Override
+  public <T> T get(int size, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    T result;
+    synchronized (this) {
+      Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
+      final Key key;
+      if (mayFillRequest(size, possibleSize)) {
+        key = keyPool.get(possibleSize, arrayClass);
+      } else {
+        key = keyPool.get(size, arrayClass);
+      }
+
+      result = getArrayForKey(key);
+      if (result != null) {
+        currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
+        decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
+      }
+    }
+
+    if (result != null) {
+      arrayAdapter.resetArray(result);
+    } else {
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
+      }
+      result = arrayAdapter.newArray(size);
+    }
+    return result;
+  }
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  private <T> T getArrayForKey(Key key) {
+    return (T) groupedMap.get(key);
+  }
+
+  private boolean isSmallEnoughForReuse(int intSize) {
+    return intSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
+  }
+
+  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
+    return actualSize != null
+        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
+  }
+
+  private boolean isNoMoreThanHalfFull() {
+    return currentSize == 0 || (maxSize / currentSize >= 2);
+  }
+
+  @Override
+  public synchronized void clearMemory() {
+    evictToSize(0);
+  }
+
+  @Override
+  public synchronized void trimMemory(int level) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+      clearMemory();
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+      evictToSize(maxSize / 2);
+    }
+  }
+
+  private void evict() {
+    evictToSize(maxSize);
+  }
+
+  private void evictToSize(int size) {
+    while (currentSize > size) {
+      Object evicted = groupedMap.removeLast();
+      Preconditions.checkNotNull(evicted);
+      ArrayAdapterInterface<Object> arrayAdapter = getAdapterFromObject(evicted);
+      currentSize -= arrayAdapter.getArrayLength(evicted) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(evicted), evicted.getClass());
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "evicted: " + arrayAdapter.getArrayLength(evicted));
+      }
+    }
+  }
+
+  private void decrementArrayOfSize(int size, Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(size);
+    if (current == null) {
+      throw new NullPointerException(
+          "Tried to decrement empty size" + ", size: " + size + ", this: " + this);
+    }
+    if (current == 1) {
+      sizes.remove(size);
+    } else {
+      sizes.put(size, current - 1);
+    }
+  }
+
+  private NavigableMap<Integer, Integer> getSizesForAdapter(Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = sortedSizes.get(arrayClass);
+    if (sizes == null) {
+      sizes = new TreeMap<>();
+      sortedSizes.put(arrayClass, sizes);
+    }
+    return sizes;
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromObject(T object) {
+    return (ArrayAdapterInterface<T>) getAdapterFromType(object.getClass());
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromType(Class<T> arrayPoolClass) {
+    ArrayAdapterInterface adapter = adapters.get(arrayPoolClass);
+    if (adapter == null) {
+      if (arrayPoolClass.equals(int[].class)) {
+        adapter = new IntegerArrayAdapter();
+      } else if (arrayPoolClass.equals(byte[].class)) {
+        adapter = new ByteArrayAdapter();
+      } else {
+          throw new IllegalArgumentException("No array pool found for: "
+              + arrayPoolClass.getSimpleName());
+      }
+      adapters.put(arrayPoolClass, adapter);
+    }
+    return adapter;
+  }
+
+  // VisibleForTesting
+  int getCurrentSize() {
+    int currentSize = 0;
+    for (Class<?> type : sortedSizes.keySet()) {
+      for (Integer size : sortedSizes.get(type).keySet()) {
+        ArrayAdapterInterface<?> adapter = getAdapterFromType(type);
+        currentSize += size * sortedSizes.get(type).get(size) * adapter.getElementSizeInBytes();
+      }
+    }
+    return currentSize;
+  }
+
+  private static final class KeyPool extends BaseKeyPool<Key> {
+
+    Key get(int size, Class arrayClass) {
+      Key result = get();
+      result.init(size, arrayClass);
+      return result;
+    }
+
+    @Override
+    protected Key create() {
+      return new Key(this);
+    }
+  }
+
+  private static final class Key implements Poolable {
+    private final KeyPool pool;
+    private int size;
+    private Class arrayClass;
+
+    Key(KeyPool pool) {
+      this.pool = pool;
+    }
+
+    void init(int length, Class arrayClass) {
+      this.size = length;
+      this.arrayClass = arrayClass;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return size == other.size && arrayClass == other.arrayClass;
+      }
+      return false;
+    }
+
+    @Override
+    public String toString() {
+      return "Key{" + "size=" + size + "array=" + arrayClass + '}';
+    }
+
+    @Override
+    public void offer() {
+      pool.offer(this);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = size;
+      result = 31 * result + (arrayClass != null ? arrayClass.hashCode() : 0);
+      return result;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 79d8c6c4a..8edb0f23c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -5,214 +5,301 @@
 import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
 /**
  * An {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation that uses an
- * {@link com.bumptech.glide.load.engine.bitmap_recycle.LruPoolStrategy} to bucket {@link Bitmap}s and then uses an LRU
- * eviction policy to evict {@link android.graphics.Bitmap}s from the least recently used bucket in order to keep
- * the pool below a given maximum size limit.
+ * {@link com.bumptech.glide.load.engine.bitmap_recycle.LruPoolStrategy} to bucket {@link Bitmap}s
+ * and then uses an LRU eviction policy to evict {@link android.graphics.Bitmap}s from the least
+ * recently used bucket in order to keep the pool below a given maximum size limit.
  */
 public class LruBitmapPool implements BitmapPool {
-    private static final String TAG = "LruBitmapPool";
-    private static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888;
+  private static final String TAG = "LruBitmapPool";
+  private static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888;
 
-    private final LruPoolStrategy strategy;
-    private final int initialMaxSize;
-    private final BitmapTracker tracker;
+  private final LruPoolStrategy strategy;
+  private final Set<Bitmap.Config> allowedConfigs;
+  private final int initialMaxSize;
+  private final BitmapTracker tracker;
 
-    private int maxSize;
-    private int currentSize;
-    private int hits;
-    private int misses;
-    private int puts;
-    private int evictions;
+  private int maxSize;
+  private int currentSize;
+  private int hits;
+  private int misses;
+  private int puts;
+  private int evictions;
 
-    // Exposed for testing only.
-    LruBitmapPool(int maxSize, LruPoolStrategy strategy) {
-        this.initialMaxSize = maxSize;
-        this.maxSize = maxSize;
-        this.strategy = strategy;
-        this.tracker = new NullBitmapTracker();
-    }
+  // Exposed for testing only.
+  LruBitmapPool(int maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
+    this.initialMaxSize = maxSize;
+    this.maxSize = maxSize;
+    this.strategy = strategy;
+    this.allowedConfigs = allowedConfigs;
+    this.tracker = new NullBitmapTracker();
+  }
 
-    /**
-     * Constructor for LruBitmapPool.
-     *
-     * @param maxSize The initial maximum size of the pool in bytes.
-     */
-    public LruBitmapPool(int maxSize) {
-        this(maxSize, getDefaultStrategy());
-    }
+  /**
+   * Constructor for LruBitmapPool.
+   *
+   * @param maxSize The initial maximum size of the pool in bytes.
+   */
+  public LruBitmapPool(int maxSize) {
+    this(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());
+  }
 
-    @Override
-    public int getMaxSize() {
-        return maxSize;
+  /**
+   * Constructor for LruBitmapPool.
+   *
+   * @param maxSize        The initial maximum size of the pool in bytes.
+   * @param allowedConfigs A white listed put of {@link android.graphics.Bitmap.Config} that are
+   *                       allowed to be put into the pool. Configs not in the allowed put will be
+   *                       rejected.
+   */
+  public LruBitmapPool(int maxSize, Set<Bitmap.Config> allowedConfigs) {
+    this(maxSize, getDefaultStrategy(), allowedConfigs);
+  }
+
+  @Override
+  public int getMaxSize() {
+    return maxSize;
+  }
+
+  @Override
+  public synchronized void setSizeMultiplier(float sizeMultiplier) {
+    maxSize = Math.round(initialMaxSize * sizeMultiplier);
+    evict();
+  }
+
+  @Override
+  public synchronized void put(Bitmap bitmap) {
+    if (bitmap == null) {
+      throw new NullPointerException("Bitmap must not be null");
+    }
+    if (bitmap.isRecycled()) {
+      throw new IllegalStateException("Cannot pool recycled bitmap");
+    }
+    if (!bitmap.isMutable() || strategy.getSize(bitmap) > maxSize
+        || !allowedConfigs.contains(bitmap.getConfig())) {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Reject bitmap from pool"
+                + ", bitmap: " + strategy.logBitmap(bitmap)
+                + ", is mutable: " + bitmap.isMutable()
+                + ", is allowed config: " + allowedConfigs.contains(bitmap.getConfig()));
+      }
+      bitmap.recycle();
+      return;
     }
 
-    @Override
-    public synchronized void setSizeMultiplier(float sizeMultiplier) {
-        maxSize = Math.round(initialMaxSize * sizeMultiplier);
-        evict();
+    final int size = strategy.getSize(bitmap);
+    strategy.put(bitmap);
+    tracker.add(bitmap);
+
+    puts++;
+    currentSize += size;
+
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Put bitmap in pool=" + strategy.logBitmap(bitmap));
     }
+    dump();
 
-    @Override
-    public synchronized boolean put(Bitmap bitmap) {
-        if (!bitmap.isMutable() || strategy.getSize(bitmap) > maxSize) {
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable="
-                        + bitmap.isMutable());
-            }
-            return false;
-        }
+    evict();
+  }
 
-        final int size = strategy.getSize(bitmap);
-        strategy.put(bitmap);
-        tracker.add(bitmap);
+  private void evict() {
+    trimToSize(maxSize);
+  }
 
-        puts++;
-        currentSize += size;
+  @Override
+  @NonNull
+  public Bitmap get(int width, int height, Bitmap.Config config) {
+    Bitmap result = getDirtyOrNull(width, height, config);
+    if (result != null) {
+      // Bitmaps in the pool contain random data that in some cases must be cleared for an image
+      // to be rendered correctly. we shouldn't force all consumers to independently erase the
+      // contents individually, so we do so here. See issue #131.
+      result.eraseColor(Color.TRANSPARENT);
+    } else {
+      result = Bitmap.createBitmap(width, height, config);
+    }
 
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Put bitmap in pool=" + strategy.logBitmap(bitmap));
-        }
-        dump();
+    return result;
+  }
 
-        evict();
-        return true;
+  @NonNull
+  @Override
+  public Bitmap getDirty(int width, int height, Bitmap.Config config) {
+    Bitmap result = getDirtyOrNull(width, height, config);
+    if (result == null) {
+      result = Bitmap.createBitmap(width, height, config);
     }
+    return result;
+  }
 
-    private void evict() {
-        trimToSize(maxSize);
+  @Nullable
+  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {
+    // Config will be null for non public config types, which can lead to transformations naively
+    // passing in null as the requested config here. See issue #194.
+    final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG);
+    if (result == null) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Missing bitmap=" + strategy.logBitmap(width, height, config));
+      }
+      misses++;
+    } else {
+      hits++;
+      currentSize -= strategy.getSize(result);
+      tracker.remove(result);
+      normalize(result);
+    }
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Get bitmap=" + strategy.logBitmap(width, height, config));
     }
+    dump();
 
-    @Override
-    public synchronized Bitmap get(int width, int height, Bitmap.Config config) {
-        Bitmap result = getDirty(width, height, config);
-        if (result != null) {
-            // Bitmaps in the pool contain random data that in some cases must be cleared for an image to be rendered
-            // correctly. we shouldn't force all consumers to independently erase the contents individually, so we do so
-            // here. See issue #131.
-            result.eraseColor(Color.TRANSPARENT);
-        }
+    return result;
+  }
 
-        return result;
-    }
+  // Setting these two values provides Bitmaps that are essentially equivalent to those returned
+  // from Bitmap.createBitmap.
+  private static void normalize(Bitmap bitmap) {
+    maybeSetAlpha(bitmap);
+    maybeSetPreMultiplied(bitmap);
+  }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-    @Override
-    public synchronized Bitmap getDirty(int width, int height, Bitmap.Config config) {
-        // Config will be null for non public config types, which can lead to transformations naively passing in
-        // null as the requested config here. See issue #194.
-        final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG);
-        if (result == null) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Missing bitmap=" + strategy.logBitmap(width, height, config));
-            }
-            misses++;
-        } else {
-            hits++;
-            currentSize -= strategy.getSize(result);
-            tracker.remove(result);
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
-                result.setHasAlpha(true);
-            }
-        }
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Get bitmap=" + strategy.logBitmap(width, height, config));
-        }
-        dump();
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+  private static void maybeSetAlpha(Bitmap bitmap) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
+      bitmap.setHasAlpha(true);
+    }
+  }
 
-        return result;
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  private static void maybeSetPreMultiplied(Bitmap bitmap) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      bitmap.setPremultiplied(true);
     }
+  }
 
-    @Override
-    public void clearMemory() {
-        trimToSize(0);
+  @Override
+  public void clearMemory() {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "clearMemory");
     }
+    trimToSize(0);
+  }
 
-    @SuppressLint("InlinedApi")
-    @Override
-    public void trimMemory(int level) {
-        if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
-            clearMemory();
-        } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
-            trimToSize(maxSize / 2);
-        }
+  @SuppressLint("InlinedApi")
+  @Override
+  public void trimMemory(int level) {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "trimMemory, level=" + level);
+    }
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+      clearMemory();
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+      trimToSize(maxSize / 2);
     }
+  }
 
-    private synchronized void trimToSize(int size) {
-        while (currentSize > size) {
-            final Bitmap removed = strategy.removeLast();
-            tracker.remove(removed);
-            currentSize -= strategy.getSize(removed);
-            removed.recycle();
-            evictions++;
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Evicting bitmap=" + strategy.logBitmap(removed));
-            }
-            dump();
+  private synchronized void trimToSize(int size) {
+    while (currentSize > size) {
+      final Bitmap removed = strategy.removeLast();
+      // TODO: This shouldn't ever happen, see #331.
+      if (removed == null) {
+        if (Log.isLoggable(TAG, Log.WARN)) {
+          Log.w(TAG, "Size mismatch, resetting");
+          dumpUnchecked();
         }
+        currentSize = 0;
+        return;
+      }
+      tracker.remove(removed);
+      currentSize -= strategy.getSize(removed);
+      evictions++;
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Evicting bitmap=" + strategy.logBitmap(removed));
+      }
+      dump();
+      removed.recycle();
     }
+  }
 
-    private void dump() {
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Hits=" + hits + " misses=" + misses + " puts=" + puts + " evictions=" + evictions
-                    + " currentSize=" + currentSize + " maxSize=" + maxSize + "\nStrategy=" + strategy);
-        }
+  private void dump() {
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      dumpUnchecked();
     }
+  }
 
-    private static LruPoolStrategy getDefaultStrategy() {
-        final LruPoolStrategy strategy;
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            strategy = new SizeStrategy();
-        } else {
-            strategy = new AttributeStrategy();
-        }
-        return strategy;
+  private void dumpUnchecked() {
+    Log.v(TAG, "Hits=" + hits + ", misses=" + misses + ", puts=" + puts + ", evictions=" + evictions
+        + ", currentSize=" + currentSize + ", maxSize=" + maxSize + "\nStrategy=" + strategy);
+  }
+
+  private static LruPoolStrategy getDefaultStrategy() {
+    final LruPoolStrategy strategy;
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      strategy = new SizeConfigStrategy();
+    } else {
+      strategy = new AttributeStrategy();
     }
+    return strategy;
+  }
 
-    private interface BitmapTracker {
-        void add(Bitmap bitmap);
-        void remove(Bitmap bitmap);
+  private static Set<Bitmap.Config> getDefaultAllowedConfigs() {
+    Set<Bitmap.Config> configs = new HashSet<>();
+    configs.addAll(Arrays.asList(Bitmap.Config.values()));
+    if (Build.VERSION.SDK_INT >= 19) {
+      configs.add(null);
     }
+    return Collections.unmodifiableSet(configs);
+  }
 
-    @SuppressWarnings("unused")
-    // Only used for debugging
-    private static class ThrowingBitmapTracker implements BitmapTracker {
-        private final Set<Bitmap> bitmaps = Collections.synchronizedSet(new HashSet<Bitmap>());
+  private interface BitmapTracker {
+    void add(Bitmap bitmap);
 
-        @Override
-        public void add(Bitmap bitmap) {
-            if (bitmaps.contains(bitmap)) {
-                throw new IllegalStateException("Can't add already added bitmap: " + bitmap + " [" + bitmap.getWidth()
-                        + "x" + bitmap.getHeight() + "]");
-            }
-            bitmaps.add(bitmap);
-        }
+    void remove(Bitmap bitmap);
+  }
 
-        @Override
-        public void remove(Bitmap bitmap) {
-            if (!bitmaps.contains(bitmap)) {
-                throw new IllegalStateException("Cannot remove bitmap not in tracker");
-            }
-            bitmaps.remove(bitmap);
-        }
+  @SuppressWarnings("unused")
+  // Only used for debugging
+  private static class ThrowingBitmapTracker implements BitmapTracker {
+    private final Set<Bitmap> bitmaps = Collections.synchronizedSet(new HashSet<Bitmap>());
+
+    @Override
+    public void add(Bitmap bitmap) {
+      if (bitmaps.contains(bitmap)) {
+        throw new IllegalStateException(
+            "Can't add already added bitmap: " + bitmap + " [" + bitmap.getWidth() + "x" + bitmap
+                .getHeight() + "]");
+      }
+      bitmaps.add(bitmap);
     }
 
-    private static class NullBitmapTracker implements BitmapTracker {
-        @Override
-        public void add(Bitmap bitmap) {
-            // Do nothing.
-        }
+    @Override
+    public void remove(Bitmap bitmap) {
+      if (!bitmaps.contains(bitmap)) {
+        throw new IllegalStateException("Cannot remove bitmap not in tracker");
+      }
+      bitmaps.remove(bitmap);
+    }
+  }
 
-        @Override
-        public void remove(Bitmap bitmap) {
-            // Do nothing.
-        }
+  private static class NullBitmapTracker implements BitmapTracker {
+    @Override
+    public void add(Bitmap bitmap) {
+      // Do nothing.
+    }
+
+    @Override
+    public void remove(Bitmap bitmap) {
+      // Do nothing.
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
new file mode 100644
index 000000000..957a550df
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * A fixed size LruByteArrayPool that evicts arrays using an LRU strategy to keep the pool under
+ * the maximum byte size.
+ *
+ * TODO: update Glide to use ArrayPool<byte[]> instead.
+ */
+public final class LruByteArrayPool implements ByteArrayPool {
+  // 4MB.
+  static final int DEFAULT_SIZE = 4 * 1024 * 1024;
+
+  private final ArrayPool arrayPool;
+
+  public LruByteArrayPool() {
+    this(DEFAULT_SIZE);
+  }
+
+  public LruByteArrayPool(int maxSize) {
+    this.arrayPool = new LruArrayPool(maxSize);
+  }
+
+  @Override
+  public synchronized void put(byte[] bytes) {
+    arrayPool.put(bytes, byte[].class);
+  }
+
+  @Override
+  public byte[] get(int size) {
+    return arrayPool.get(size, byte[].class);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
index d52e69540..376dd9665 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
@@ -1,12 +1,20 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.support.annotation.Nullable;
 
 interface LruPoolStrategy {
-    void put(Bitmap bitmap);
-    Bitmap get(int width, int height, Bitmap.Config config);
-    Bitmap removeLast();
-    String logBitmap(Bitmap bitmap);
-    String logBitmap(int width, int height, Bitmap.Config config);
-    int getSize(Bitmap bitmap);
+  void put(Bitmap bitmap);
+
+  @Nullable
+  Bitmap get(int width, int height, Bitmap.Config config);
+
+  @Nullable
+  Bitmap removeLast();
+
+  String logBitmap(Bitmap bitmap);
+
+  String logBitmap(int width, int height, Bitmap.Config config);
+
+  int getSize(Bitmap bitmap);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/Poolable.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/Poolable.java
index 28e96ba6c..bf67075a0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/Poolable.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/Poolable.java
@@ -1,5 +1,5 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 interface Poolable {
-    void offer();
+  void offer();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
new file mode 100644
index 000000000..5d4176f3c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import java.util.TreeMap;
+
+class PrettyPrintTreeMap<K, V> extends TreeMap<K, V> {
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    sb.append("( ");
+    for (Entry<K, V> entry : entrySet()) {
+      sb.append('{').append(entry.getKey()).append(':').append(entry.getValue()).append("}, ");
+    }
+    if (!isEmpty()) {
+      sb.replace(sb.length() - 2, sb.length(), "");
+    }
+    return sb.append(" )").toString();
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
new file mode 100644
index 000000000..0a011dbc3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -0,0 +1,247 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.os.Build;
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.util.Util;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
+/**
+ * Keys {@link android.graphics.Bitmap Bitmaps} using both
+ * {@link android.graphics.Bitmap#getAllocationByteCount()} and the
+ * {@link android.graphics.Bitmap.Config} returned from
+ * {@link android.graphics.Bitmap#getConfig()}.
+ *
+ * <p> Using both the config and the byte size allows us to safely re-use a greater variety of
+ * {@link android.graphics.Bitmap Bitmaps}, which increases the hit rate of the pool and therefore
+ * the performance of applications. This class works around #301 by only allowing re-use of
+ * {@link android.graphics.Bitmap Bitmaps} with a matching number of bytes per pixel. </p>
+ */
+@TargetApi(Build.VERSION_CODES.KITKAT)
+public class SizeConfigStrategy implements LruPoolStrategy {
+  private static final int MAX_SIZE_MULTIPLE = 8;
+  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS =
+      new Bitmap.Config[] {
+          Bitmap.Config.ARGB_8888,
+          // The value returned by Bitmaps with the hidden Bitmap config.
+          null,
+      };
+  // We probably could allow ARGB_4444 and RGB_565 to decode into each other, but ARGB_4444 is
+  // deprecated and we'd rather be safe.
+  private static final Bitmap.Config[] RGB_565_IN_CONFIGS =
+      new Bitmap.Config[] { Bitmap.Config.RGB_565 };
+  private static final Bitmap.Config[] ARGB_4444_IN_CONFIGS =
+      new Bitmap.Config[] { Bitmap.Config.ARGB_4444 };
+  private static final Bitmap.Config[] ALPHA_8_IN_CONFIGS =
+      new Bitmap.Config[] { Bitmap.Config.ALPHA_8 };
+
+  private final KeyPool keyPool = new KeyPool();
+  private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
+  private final Map<Bitmap.Config, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
+
+  @Override
+  public void put(Bitmap bitmap) {
+    int size = Util.getBitmapByteSize(bitmap);
+    Key key = keyPool.get(size, bitmap.getConfig());
+
+    groupedMap.put(key, bitmap);
+
+    NavigableMap<Integer, Integer> sizes = getSizesForConfig(bitmap.getConfig());
+    Integer current = sizes.get(key.size);
+    sizes.put(key.size, current == null ? 1 : current + 1);
+  }
+
+  @Override
+  @Nullable
+  public Bitmap get(int width, int height, Bitmap.Config config) {
+    int size = Util.getBitmapByteSize(width, height, config);
+    Key bestKey = findBestKey(size, config);
+
+    Bitmap result = groupedMap.get(bestKey);
+    if (result != null) {
+      // Decrement must be called before reconfigure.
+      decrementBitmapOfSize(bestKey.size, result);
+      result.reconfigure(width, height,
+          result.getConfig() != null ? result.getConfig() : Bitmap.Config.ARGB_8888);
+    }
+    return result;
+  }
+
+  private Key findBestKey(int size, Bitmap.Config config) {
+    Key result = keyPool.get(size, config);
+    for (Bitmap.Config possibleConfig : getInConfigs(config)) {
+      NavigableMap<Integer, Integer> sizesForPossibleConfig = getSizesForConfig(possibleConfig);
+      Integer possibleSize = sizesForPossibleConfig.ceilingKey(size);
+      if (possibleSize != null && possibleSize <= size * MAX_SIZE_MULTIPLE) {
+        if (possibleSize != size
+            || (possibleConfig == null ? config != null : !possibleConfig.equals(config))) {
+          keyPool.offer(result);
+          result = keyPool.get(possibleSize, possibleConfig);
+        }
+        break;
+      }
+    }
+    return result;
+  }
+
+  @Override
+  @Nullable
+  public Bitmap removeLast() {
+    Bitmap removed = groupedMap.removeLast();
+    if (removed != null) {
+      int removedSize = Util.getBitmapByteSize(removed);
+      decrementBitmapOfSize(removedSize, removed);
+    }
+    return removed;
+  }
+
+  private void decrementBitmapOfSize(Integer size, Bitmap removed) {
+    Bitmap.Config config = removed.getConfig();
+    NavigableMap<Integer, Integer> sizes = getSizesForConfig(config);
+    Integer current = sizes.get(size);
+    if (current == null) {
+      throw new NullPointerException("Tried to decrement empty size"
+          + ", size: " + size
+          + ", removed: " + logBitmap(removed)
+          + ", this: " + this);
+    }
+
+    if (current == 1) {
+      sizes.remove(size);
+    } else {
+      sizes.put(size, current - 1);
+    }
+  }
+
+  private NavigableMap<Integer, Integer> getSizesForConfig(Bitmap.Config config) {
+    NavigableMap<Integer, Integer> sizes = sortedSizes.get(config);
+    if (sizes == null) {
+      sizes = new TreeMap<>();
+      sortedSizes.put(config, sizes);
+    }
+    return sizes;
+  }
+
+  @Override
+  public String logBitmap(Bitmap bitmap) {
+    int size = Util.getBitmapByteSize(bitmap);
+    return getBitmapString(size, bitmap.getConfig());
+  }
+
+  @Override
+  public String logBitmap(int width, int height, Bitmap.Config config) {
+    int size = Util.getBitmapByteSize(width, height, config);
+    return getBitmapString(size, config);
+  }
+
+  @Override
+  public int getSize(Bitmap bitmap) {
+    return Util.getBitmapByteSize(bitmap);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb =
+        new StringBuilder()
+            .append("SizeConfigStrategy{groupedMap=")
+            .append(groupedMap)
+            .append(", sortedSizes=(");
+    for (Map.Entry<Bitmap.Config, NavigableMap<Integer, Integer>> entry : sortedSizes.entrySet()) {
+      sb.append(entry.getKey()).append('[').append(entry.getValue()).append("], ");
+    }
+    if (!sortedSizes.isEmpty()) {
+      sb.replace(sb.length() - 2, sb.length(), "");
+    }
+    return sb.append(")}").toString();
+  }
+
+  // Visible for testing.
+  static class KeyPool extends BaseKeyPool<Key> {
+
+    public Key get(int size, Bitmap.Config config) {
+      Key result = get();
+      result.init(size, config);
+      return result;
+    }
+
+    @Override
+    protected Key create() {
+      return new Key(this);
+    }
+  }
+
+  // Visible for testing.
+  static final class Key implements Poolable {
+    private final KeyPool pool;
+
+    private int size;
+    private Bitmap.Config config;
+
+    public Key(KeyPool pool) {
+      this.pool = pool;
+    }
+
+    // Visible for testing.
+    Key(KeyPool pool, int size, Bitmap.Config config) {
+      this(pool);
+      init(size, config);
+    }
+
+    public void init(int size, Bitmap.Config config) {
+      this.size = size;
+      this.config = config;
+    }
+
+    @Override
+    public void offer() {
+      pool.offer(this);
+    }
+
+    @Override
+    public String toString() {
+      return getBitmapString(size, config);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return size == other.size
+            && (config == null ? other.config == null : config.equals(other.config));
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = size;
+      result = 31 * result + (config != null ? config.hashCode() : 0);
+      return result;
+    }
+  }
+
+  private static String getBitmapString(int size, Bitmap.Config config) {
+    return "[" + size + "](" + config + ")";
+  }
+
+  private static Bitmap.Config[] getInConfigs(Bitmap.Config requested) {
+    switch (requested) {
+      case ARGB_8888:
+        return ARGB_8888_IN_CONFIGS;
+      case RGB_565:
+        return RGB_565_IN_CONFIGS;
+      case ARGB_4444:
+        return ARGB_4444_IN_CONFIGS;
+      case ALPHA_8:
+        return ALPHA_8_IN_CONFIGS;
+      default:
+        return new Bitmap.Config[] { requested };
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index 2716d337d..007ae8151 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -3,173 +3,159 @@
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
+import android.support.annotation.Nullable;
 
 import com.bumptech.glide.util.Util;
 
 import java.util.TreeMap;
 
 /**
- * A strategy for reusing bitmaps that relies on {@link Bitmap#reconfigure(int, int, Bitmap.Config)}.
- * Requires {@link Build.VERSION_CODES#KITKAT KitKat} (API {@value Build.VERSION_CODES#KITKAT}) or higher.
+ * A strategy for reusing bitmaps that relies on
+ * {@link Bitmap#reconfigure(int, int, Bitmap.Config)}.
+ *
+ * <p> Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher. </p>
  */
 @TargetApi(Build.VERSION_CODES.KITKAT)
 class SizeStrategy implements LruPoolStrategy {
-    private static final int MAX_SIZE_MULTIPLE = 8;
-    private final KeyPool keyPool = new KeyPool();
-    private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<Key, Bitmap>();
-    private final TreeMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<Integer, Integer>();
+  private static final int MAX_SIZE_MULTIPLE = 8;
+  private final KeyPool keyPool = new KeyPool();
+  private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
+  private final TreeMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
+
+  @Override
+  public void put(Bitmap bitmap) {
+    int size = Util.getBitmapByteSize(bitmap);
+    final Key key = keyPool.get(size);
+
+    groupedMap.put(key, bitmap);
+
+    Integer current = sortedSizes.get(key.size);
+    sortedSizes.put(key.size, current == null ? 1 : current + 1);
+  }
+
+  @Override
+  @Nullable
+  public Bitmap get(int width, int height, Bitmap.Config config) {
+    final int size = Util.getBitmapByteSize(width, height, config);
+    Key key = keyPool.get(size);
+
+    Integer possibleSize = sortedSizes.ceilingKey(size);
+    if (possibleSize != null && possibleSize != size && possibleSize <= size * MAX_SIZE_MULTIPLE) {
+      keyPool.offer(key);
+      key = keyPool.get(possibleSize);
+    }
 
-    @Override
-    public void put(Bitmap bitmap) {
-        int size = Util.getBitmapByteSize(bitmap);
-        final Key key = keyPool.get(size);
+    // Do a get even if we know we don't have a bitmap so that the key moves to the front in the
+    // lru pool
+    final Bitmap result = groupedMap.get(key);
+    if (result != null) {
+      result.reconfigure(width, height, config);
+      decrementBitmapOfSize(possibleSize);
+    }
 
-        groupedMap.put(key, bitmap);
+    return result;
+  }
 
-        Integer current = sortedSizes.get(key.size);
-        sortedSizes.put(key.size, current == null ? 1 : current + 1);
+  @Override
+  @Nullable
+  public Bitmap removeLast() {
+    Bitmap removed = groupedMap.removeLast();
+    if (removed != null) {
+      final int removedSize = Util.getBitmapByteSize(removed);
+      decrementBitmapOfSize(removedSize);
     }
-
-    @Override
-    public Bitmap get(int width, int height, Bitmap.Config config) {
-        final int size = Util.getBitmapByteSize(width, height, config);
-        Key key = keyPool.get(size);
-
-        Integer possibleSize = sortedSizes.ceilingKey(size);
-        if (possibleSize != null && possibleSize != size && possibleSize <= size * MAX_SIZE_MULTIPLE) {
-            keyPool.offer(key);
-            key = keyPool.get(possibleSize);
-        }
-
-        // Do a get even if we know we don't have a bitmap so that the key moves to the front in the lru pool
-        final Bitmap result = groupedMap.get(key);
-        if (result != null) {
-            result.reconfigure(width, height, config);
-            decrementBitmapOfSize(possibleSize);
-        }
-
-        return result;
+    return removed;
+  }
+
+  private void decrementBitmapOfSize(Integer size) {
+    Integer current = sortedSizes.get(size);
+    if (current == 1) {
+      sortedSizes.remove(size);
+    } else {
+      sortedSizes.put(size, current - 1);
+    }
+  }
+
+  @Override
+  public String logBitmap(Bitmap bitmap) {
+    return getBitmapString(bitmap);
+  }
+
+  @Override
+  public String logBitmap(int width, int height, Bitmap.Config config) {
+    int size = Util.getBitmapByteSize(width, height, config);
+    return getBitmapString(size);
+  }
+
+  @Override
+  public int getSize(Bitmap bitmap) {
+    return Util.getBitmapByteSize(bitmap);
+  }
+
+  @Override
+  public String toString() {
+    return "SizeStrategy:\n  " + groupedMap + "\n" + "  SortedSizes" + sortedSizes;
+  }
+
+  private static String getBitmapString(Bitmap bitmap) {
+    int size = Util.getBitmapByteSize(bitmap);
+    return getBitmapString(size);
+  }
+
+  private static String getBitmapString(int size) {
+    return "[" + size + "]";
+  }
+
+  // Visible for testing.
+  static class KeyPool extends BaseKeyPool<Key> {
+
+    public Key get(int size) {
+      Key result = get();
+      result.init(size);
+      return result;
     }
 
     @Override
-    public Bitmap removeLast() {
-        Bitmap removed = groupedMap.removeLast();
-        if (removed != null) {
-            final int removedSize = Util.getBitmapByteSize(removed);
-            decrementBitmapOfSize(removedSize);
-        }
-        return removed;
+    protected Key create() {
+      return new Key(this);
     }
+  }
+
+  // Visible for testing.
+  static final class Key implements Poolable {
+    private final KeyPool pool;
+    private int size;
 
-    private void decrementBitmapOfSize(Integer size) {
-        Integer current = sortedSizes.get(size);
-        if (current == 1) {
-            sortedSizes.remove(size);
-        } else {
-            sortedSizes.put(size, current - 1);
-        }
+    Key(KeyPool pool) {
+      this.pool = pool;
     }
 
-    @Override
-    public String logBitmap(Bitmap bitmap) {
-        return getBitmapString(bitmap);
+    public void init(int size) {
+      this.size = size;
     }
 
     @Override
-    public String logBitmap(int width, int height, Bitmap.Config config) {
-        int size = Util.getBitmapByteSize(width, height, config);
-        return getBitmapString(size);
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return size == other.size;
+      }
+      return false;
     }
 
     @Override
-    public int getSize(Bitmap bitmap) {
-        return Util.getBitmapByteSize(bitmap);
+    public int hashCode() {
+      return size;
     }
 
     @Override
     public String toString() {
-        return "SizeStrategy:\n  "
-                + groupedMap + "\n"
-                + "  SortedSizes" + sortedSizes;
-    }
-
-    private static class PrettyPrintTreeMap<K, V> extends TreeMap<K, V> {
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append("( ");
-            for (Entry<K, V> entry : entrySet()) {
-                sb.append('{').append(entry.getKey()).append(':').append(entry.getValue()).append("}, ");
-            }
-            final String result;
-            if (!isEmpty()) {
-                result = sb.substring(0, sb.length() - 2);
-            } else {
-                result = sb.toString();
-            }
-            return result + " )";
-        }
+      return getBitmapString(size);
     }
 
-    private static String getBitmapString(Bitmap bitmap) {
-        int size = Util.getBitmapByteSize(bitmap);
-        return getBitmapString(size);
-    }
-
-    private static String getBitmapString(int size) {
-        return "[" + size + "]";
-    }
-
-    // Visible for testing.
-    static class KeyPool extends BaseKeyPool<Key> {
-
-        public Key get(int size) {
-            Key result = get();
-            result.init(size);
-            return result;
-        }
-
-        @Override
-        protected Key create() {
-            return new Key(this);
-        }
-    }
-
-    // Visible for testing.
-    static final class Key implements Poolable {
-        private final KeyPool pool;
-        private int size;
-
-        Key(KeyPool pool) {
-            this.pool = pool;
-        }
-
-        public void init(int size) {
-            this.size = size;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Key) {
-                Key other = (Key) o;
-                return size == other.size;
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            return size;
-        }
-
-        @Override
-        public String toString() {
-            return getBitmapString(size);
-        }
-
-        @Override
-        public void offer() {
-            pool.offer(this);
-        }
+    @Override
+    public void offer() {
+      pool.offer(this);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index c456249be..01736759f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.Nullable;
+
 import com.bumptech.glide.load.Key;
 
 import java.io.File;
@@ -8,45 +10,66 @@
  * An interface for writing to and reading from a disk cache.
  */
 public interface DiskCache {
-    /**
-     * An interface to actually write data to a key in the disk cache.
-     */
-    interface Writer {
-        /**
-         * Writes data to the file and returns true if the write was successful and should be committed, and
-         * false if the write should be aborted.
-         *
-         * @param file The File the Writer should write to.
-         */
-        boolean write(File file);
-    }
 
-    /**
-     * Get the cache for the value at the given key.
-     *
-     * <p>
-     *     Note - This is potentially dangerous, someone may write a new value to the file at any point in timeand we
-     *     won't know about it.
-     * </p>
-     *
-     * @param key The key in the cache.
-     * @return An InputStream representing the data at key at the time get is called.
-     */
-    File get(Key key);
+  /**
+   * An interface for lazily creating a disk cache.
+   */
+  interface Factory {
 
-    /**
-     * Write to a key in the cache. {@link Writer} is used so that the cache implementation can perform actions after
-     * the write finishes, like commit (via atomic file rename).
-     *
-     * @param key The key to write to.
-     * @param writer An interface that will write data given an OutputStream for the key.
-     */
-    void put(Key key, Writer writer);
+      /** 250 MB of cache. */
+      int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
+      String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
 
+      /**
+       * Returns a new disk cache, or {@code null} if no disk cache could be created.
+       */
+      @Nullable
+      DiskCache build();
+  }
+
+  /**
+   * An interface to actually write data to a key in the disk cache.
+   */
+  interface Writer {
     /**
-     * Remove the key and value from the cache.
+     * Writes data to the file and returns true if the write was successful and should be committed,
+     * and false if the write should be aborted.
      *
-     * @param key The key to remove.
+     * @param file The File the Writer should write to.
      */
-    void delete(Key key);
+    boolean write(File file);
+  }
+
+  /**
+   * Get the cache for the value at the given key.
+   *
+   * <p> Note - This is potentially dangerous, someone may write a new value to the file at any
+   * point in time and we won't know about it. </p>
+   *
+   * @param key The key in the cache.
+   * @return An InputStream representing the data at key at the time get is called.
+   */
+  @Nullable
+  File get(Key key);
+
+  /**
+   * Write to a key in the cache. {@link Writer} is used so that the cache implementation can
+   * perform actions after the write finishes, like commit (via atomic file rename).
+   *
+   * @param key    The key to write to.
+   * @param writer An interface that will write data given an OutputStream for the key.
+   */
+  void put(Key key, Writer writer);
+
+  /**
+   * Remove the key and value from the cache.
+   *
+   * @param key The key to remove.
+   */
+  void delete(Key key);
+
+  /**
+   * Clear the cache.
+   */
+  void clear();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
index 7027b0521..73bbe74c7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
@@ -8,19 +8,24 @@
  * A simple class that returns null for all gets and ignores all writes.
  */
 public class DiskCacheAdapter implements DiskCache {
-    @Override
-    public File get(Key key) {
-        // no op, default for overriders
-        return null;
-    }
+  @Override
+  public File get(Key key) {
+    // no op, default for overriders
+    return null;
+  }
 
-    @Override
-    public void put(Key key, Writer writer) {
-        // no op, default for overriders
-    }
+  @Override
+  public void put(Key key, Writer writer) {
+    // no op, default for overriders
+  }
 
-    @Override
-    public void delete(Key key) {
-        // no op, default for overriders
-    }
+  @Override
+  public void delete(Key key) {
+    // no op, default for overriders
+  }
+
+  @Override
+  public void clear() {
+      // no op, default for overriders
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
new file mode 100644
index 000000000..35586d8ae
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -0,0 +1,93 @@
+package com.bumptech.glide.load.engine.cache;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * Keeps a map of keys to locks that allows locks to be removed from the map when no longer in use
+ * so the size of the collection is bounded.
+ *
+ * <p> This class will be accessed by multiple threads in a thread pool and ensures that the
+ *  number of threads interested in each lock is updated atomically so that when the count reaches
+ *  0, the lock can safely be removed from the map. </p>
+ */
+final class DiskCacheWriteLocker {
+  private final Map<Key, WriteLock> locks = new HashMap<>();
+  private final WriteLockPool writeLockPool = new WriteLockPool();
+
+  void acquire(Key key) {
+    WriteLock writeLock;
+    synchronized (this) {
+      writeLock = locks.get(key);
+      if (writeLock == null) {
+        writeLock = writeLockPool.obtain();
+        locks.put(key, writeLock);
+      }
+      writeLock.interestedThreads++;
+    }
+
+    writeLock.lock.lock();
+  }
+
+  void release(Key key) {
+    WriteLock writeLock;
+    synchronized (this) {
+      writeLock = Preconditions.checkNotNull(locks.get(key));
+      if (writeLock.interestedThreads < 1) {
+        throw new IllegalStateException("Cannot release a lock that is not held"
+            + ", key: " + key
+            + ", interestedThreads: " + writeLock.interestedThreads);
+      }
+
+      writeLock.interestedThreads--;
+      if (writeLock.interestedThreads == 0) {
+        WriteLock removed = locks.remove(key);
+        if (!removed.equals(writeLock)) {
+          throw new IllegalStateException("Removed the wrong lock"
+              + ", expected to remove: " + writeLock
+              + ", but actually removed: " + removed
+              + ", key: " + key);
+        }
+        writeLockPool.offer(removed);
+      }
+    }
+
+    writeLock.lock.unlock();
+  }
+
+  private static class WriteLock  {
+    final Lock lock = new ReentrantLock();
+    int interestedThreads;
+  }
+
+  private static class WriteLockPool {
+    private static final int MAX_POOL_SIZE = 10;
+    private final Queue<WriteLock> pool = new ArrayDeque<>();
+
+    WriteLock obtain() {
+      WriteLock result;
+      synchronized (pool) {
+        result = pool.poll();
+      }
+      if (result == null) {
+        result = new WriteLock();
+      }
+      return result;
+    }
+
+    void offer(WriteLock writeLock) {
+      synchronized (pool) {
+        if (pool.size() < MAX_POOL_SIZE) {
+          pool.offer(writeLock);
+        }
+      }
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
new file mode 100644
index 000000000..f24fa6dd2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.load.engine.cache;
+
+import java.io.File;
+
+/**
+ * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the specified
+ * disk cache directory.
+ *
+ * <p>If you need to make I/O access before returning the cache directory use the {@link
+ * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, int)} constructor variant.
+ */
+public class DiskLruCacheFactory implements DiskCache.Factory {
+  private final int diskCacheSize;
+  private final CacheDirectoryGetter cacheDirectoryGetter;
+
+  /**
+   * Interface called out of UI thread to get the cache folder.
+   */
+  public interface CacheDirectoryGetter {
+    File getCacheDirectory();
+  }
+
+  public DiskLruCacheFactory(final String diskCacheFolder, int diskCacheSize) {
+    this(new CacheDirectoryGetter() {
+      @Override
+      public File getCacheDirectory() {
+        return new File(diskCacheFolder);
+      }
+    }, diskCacheSize);
+  }
+
+  public DiskLruCacheFactory(final String diskCacheFolder, final String diskCacheName,
+      int diskCacheSize) {
+    this(new CacheDirectoryGetter() {
+      @Override
+      public File getCacheDirectory() {
+        return new File(diskCacheFolder, diskCacheName);
+      }
+    }, diskCacheSize);
+  }
+
+  /**
+   * When using this constructor {@link CacheDirectoryGetter#getCacheDirectory()} will be called out
+   * of UI thread, allowing to do I/O access without performance impacts.
+   *
+   * @param cacheDirectoryGetter Interface called out of UI thread to get the cache folder.
+   * @param diskCacheSize        Desired max bytes size for the LRU disk cache.
+   */
+  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, int diskCacheSize) {
+    this.diskCacheSize = diskCacheSize;
+    this.cacheDirectoryGetter = cacheDirectoryGetter;
+  }
+
+  @Override
+  public DiskCache build() {
+    File cacheDir = cacheDirectoryGetter.getCacheDirectory();
+
+    if (cacheDir == null) {
+      return null;
+    }
+
+    if (!cacheDir.mkdirs() && (!cacheDir.exists() || !cacheDir.isDirectory())) {
+      return null;
+    }
+
+    return DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 12648681f..4aeb30c6d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -7,6 +7,7 @@
 import android.util.Log;
 
 import com.bumptech.glide.disklrucache.DiskLruCache;
+import com.bumptech.glide.disklrucache.DiskLruCache.Value;
 import com.bumptech.glide.load.Key;
 
 import java.io.File;
@@ -19,99 +20,138 @@
  * @see #get(java.io.File, int)
  */
 public class DiskLruCacheWrapper implements DiskCache {
-    private static final String TAG = "DiskLruCacheWrapper";
-
-    private static final int APP_VERSION = 1;
-    private static final int VALUE_COUNT = 1;
-    private static DiskLruCacheWrapper wrapper = null;
-
-    private final SafeKeyGenerator safeKeyGenerator;
-    private final File directory;
-    private final int maxSize;
-    private DiskLruCache diskLruCache;
-
-    /**
-     * Get a DiskCache in the given directory and size. If a disk cache has alread been created with
-     * a different directory and/or size, it will be returned instead and the new arguments
-     * will be ignored.
-     *
-     * @param directory The directory for the disk cache
-     * @param maxSize The max size for the disk cache
-     * @return The new disk cache with the given arguments, or the current cache if one already exists
-     */
-    public static synchronized DiskCache get(File directory, int maxSize) {
-        // TODO calling twice with different arguments makes it return the cache for the same directory, it's public!
-        if (wrapper == null) {
-            wrapper = new DiskLruCacheWrapper(directory, maxSize);
-        }
-        return wrapper;
+  private static final String TAG = "DiskLruCacheWrapper";
+
+  private static final int APP_VERSION = 1;
+  private static final int VALUE_COUNT = 1;
+  private static DiskLruCacheWrapper wrapper = null;
+
+  private final SafeKeyGenerator safeKeyGenerator;
+  private final File directory;
+  private final int maxSize;
+  private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
+  private DiskLruCache diskLruCache;
+
+  /**
+   * Get a DiskCache in the given directory and size. If a disk cache has already been created with
+   * a different directory and/or size, it will be returned instead and the new arguments will be
+   * ignored.
+   *
+   * @param directory The directory for the disk cache
+   * @param maxSize   The max size for the disk cache
+   * @return The new disk cache with the given arguments, or the current cache if one already exists
+   */
+  public static synchronized DiskCache get(File directory, int maxSize) {
+    // TODO calling twice with different arguments makes it return the cache for the same
+    // directory, it's public!
+    if (wrapper == null) {
+      wrapper = new DiskLruCacheWrapper(directory, maxSize);
     }
+    return wrapper;
+  }
 
-    protected DiskLruCacheWrapper(File directory, int maxSize) {
-        this.directory = directory;
-        this.maxSize = maxSize;
-        this.safeKeyGenerator = new SafeKeyGenerator();
+  protected DiskLruCacheWrapper(File directory, int maxSize) {
+    this.directory = directory;
+    this.maxSize = maxSize;
+    this.safeKeyGenerator = new SafeKeyGenerator();
+  }
+
+  private synchronized DiskLruCache getDiskCache() throws IOException {
+    if (diskLruCache == null) {
+      diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
     }
+    return diskLruCache;
+  }
 
-    private synchronized DiskLruCache getDiskCache() throws IOException {
-        if (diskLruCache == null) {
-            diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
-        }
-        return diskLruCache;
+  @Override
+  public File get(Key key) {
+    String safeKey = safeKeyGenerator.getSafeKey(key);
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Get: Obtained: " + safeKey + " for for Key: " + key);
     }
+    File result = null;
+    try {
+      // It is possible that the there will be a put in between these two gets. If so that shouldn't
+      // be a problem because we will always put the same value at the same key so our input streams
+      // will still represent the same data.
+      final DiskLruCache.Value value = getDiskCache().get(safeKey);
+      if (value != null) {
+        result = value.getFile(0);
+      }
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to get from disk cache", e);
+      }
+    }
+    return result;
+  }
 
-    @Override
-    public File get(Key key) {
-        String safeKey = safeKeyGenerator.getSafeKey(key);
-        File result = null;
-        try {
-            //It is possible that the there will be a put in between these two gets. If so that shouldn't be a problem
-            //because we will always put the same value at the same key so our input streams will still represent
-            //the same data
-            final DiskLruCache.Value value = getDiskCache().get(safeKey);
-            if (value != null) {
-                result = value.getFile(0);
-            }
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Unable to get from disk cache", e);
-            }
+  @Override
+  public void put(Key key, Writer writer) {
+    // We want to make sure that puts block so that data is available when put completes. We may
+    // actually not write any data if we find that data is written by the time we acquire the lock.
+    writeLocker.acquire(key);
+    try {
+      String safeKey = safeKeyGenerator.getSafeKey(key);
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
+      }
+      try {
+        // We assume we only need to put once, so if data was written while we were trying to get
+        // the lock, we can simply abort.
+        DiskLruCache diskCache = getDiskCache();
+        Value current = diskCache.get(safeKey);
+        if (current != null) {
+          return;
         }
-        return result;
-    }
 
-    @Override
-    public void put(Key key, Writer writer) {
-        String safeKey = safeKeyGenerator.getSafeKey(key);
+        DiskLruCache.Editor editor = diskCache.edit(safeKey);
+        if (editor == null) {
+          throw new IllegalStateException("Had two simultaneous puts for: " + safeKey);
+        }
         try {
-            DiskLruCache.Editor editor = getDiskCache().edit(safeKey);
-            // Editor will be null if there are two concurrent puts. In the worst case we will just silently fail.
-            if (editor != null) {
-                try {
-                    File file = editor.getFile(0);
-                    if (writer.write(file)) {
-                        editor.commit();
-                    }
-                } finally {
-                    editor.abortUnlessCommitted();
-                }
-            }
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Unable to put to disk cache", e);
-            }
+          File file = editor.getFile(0);
+          if (writer.write(file)) {
+            editor.commit();
+          }
+        } finally {
+          editor.abortUnlessCommitted();
         }
+      } catch (IOException e) {
+        if (Log.isLoggable(TAG, Log.WARN)) {
+          Log.w(TAG, "Unable to put to disk cache", e);
+        }
+      }
+    } finally {
+      writeLocker.release(key);
     }
+  }
 
-    @Override
-    public void delete(Key key) {
-        String safeKey = safeKeyGenerator.getSafeKey(key);
-        try {
-            getDiskCache().remove(safeKey);
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Unable to delete from disk cache", e);
-            }
-        }
+  @Override
+  public void delete(Key key) {
+    String safeKey = safeKeyGenerator.getSafeKey(key);
+    try {
+      getDiskCache().remove(safeKey);
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to delete from disk cache", e);
+      }
+    }
+  }
+
+  @Override
+  public synchronized void clear() {
+    try {
+      getDiskCache().delete();
+      resetDiskCache();
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to clear disk cache", e);
+      }
     }
+  }
+
+  private synchronized void resetDiskCache() {
+    diskLruCache = null;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
new file mode 100644
index 000000000..885a8e97e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.load.engine.cache;
+
+import android.content.Context;
+
+import java.io.File;
+
+/**
+ * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the external
+ * disk cache directory.
+ *
+ * <p><b>Images can be read by everyone when using external disk cache.</b>
+ */
+public final class ExternalCacheDiskCacheFactory extends DiskLruCacheFactory {
+
+  public ExternalCacheDiskCacheFactory(Context context) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
+  }
+
+  public ExternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
+  }
+
+  public ExternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
+      int diskCacheSize) {
+    super(new CacheDirectoryGetter() {
+      @Override
+      public File getCacheDirectory() {
+        File cacheDirectory = context.getExternalCacheDir();
+        if (cacheDirectory == null) {
+          return null;
+        }
+        if (diskCacheName != null) {
+          return new File(cacheDirectory, diskCacheName);
+        }
+        return cacheDirectory;
+      }
+    }, diskCacheSize);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
new file mode 100644
index 000000000..a69112738
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -0,0 +1,38 @@
+package com.bumptech.glide.load.engine.cache;
+
+import android.content.Context;
+
+import java.io.File;
+
+/**
+ * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the internal
+ * disk cache directory.
+ */
+public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {
+
+  public InternalCacheDiskCacheFactory(Context context) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
+  }
+
+  public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
+  }
+
+  public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
+      int diskCacheSize) {
+    super(new CacheDirectoryGetter() {
+      @Override
+      public File getCacheDirectory() {
+        File cacheDirectory = context.getCacheDir();
+        if (cacheDirectory == null) {
+          return null;
+        }
+        if (diskCacheName != null) {
+          return new File(cacheDirectory, diskCacheName);
+        }
+        return cacheDirectory;
+      }
+    }, diskCacheSize);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index ffe5a6f95..455204dca 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -10,45 +10,45 @@
  * An LRU in memory cache for {@link com.bumptech.glide.load.engine.Resource}s.
  */
 public class LruResourceCache extends LruCache<Key, Resource<?>> implements MemoryCache {
-    private ResourceRemovedListener listener;
-
-    /**
-     * Constructor for LruResourceCache.
-     *
-     * @param size The maximum size in bytes the in memory cache can use.
-     */
-    public LruResourceCache(int size) {
-        super(size);
+  private ResourceRemovedListener listener;
+
+  /**
+   * Constructor for LruResourceCache.
+   *
+   * @param size The maximum size in bytes the in memory cache can use.
+   */
+  public LruResourceCache(int size) {
+    super(size);
+  }
+
+  @Override
+  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+    this.listener = listener;
+  }
+
+  @Override
+  protected void onItemEvicted(Key key, Resource<?> item) {
+    if (listener != null) {
+      listener.onResourceRemoved(item);
     }
-
-    @Override
-    public void setResourceRemovedListener(ResourceRemovedListener listener) {
-        this.listener = listener;
-    }
-
-    @Override
-    protected void onItemEvicted(Key key, Resource<?> item) {
-        if (listener != null) {
-            listener.onResourceRemoved(item);
-        }
-    }
-
-    @Override
-    protected int getSize(Resource<?> item) {
-        return item.getSize();
-    }
-
-    @SuppressLint("InlinedApi")
-    @Override
-    public void trimMemory(int level) {
-        if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
-            // Nearing middle of list of cached background apps
-            // Evict our entire bitmap cache
-            clearMemory();
-        } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
-            // Entering list of cached background apps
-            // Evict oldest half of our bitmap cache
-            trimToSize(getCurrentSize() / 2);
-        }
+  }
+
+  @Override
+  protected int getSize(Resource<?> item) {
+    return item.getSize();
+  }
+
+  @SuppressLint("InlinedApi")
+  @Override
+  public void trimMemory(int level) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+      // Nearing middle of list of cached background apps
+      // Evict our entire bitmap cache
+      clearMemory();
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+      // Entering list of cached background apps
+      // Evict oldest half of our bitmap cache
+      trimToSize(getCurrentSize() / 2);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index f350f71c9..b432c2825 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.Nullable;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -7,67 +9,69 @@
  * An interface for adding and removing resources from an in memory cache.
  */
 public interface MemoryCache {
-    /**
-     * An interface that will be called whenever a bitmap is removed from the cache.
-     */
-    interface ResourceRemovedListener {
-        void onResourceRemoved(Resource<?> removed);
-    }
+  /**
+   * An interface that will be called whenever a bitmap is removed from the cache.
+   */
+  interface ResourceRemovedListener {
+    void onResourceRemoved(Resource<?> removed);
+  }
 
-    /**
-     * Returns the sum of the sizes of all the contents of the cache in bytes.
-     */
-    int getCurrentSize();
+  /**
+   * Returns the sum of the sizes of all the contents of the cache in bytes.
+   */
+  int getCurrentSize();
 
-    /**
-     * Returns the current maximum size in bytes of the cache.
-     */
-    int getMaxSize();
+  /**
+   * Returns the current maximum size in bytes of the cache.
+   */
+  int getMaxSize();
 
-    /**
-     * Adjust the maximum size of the cache by multiplying the original size of the cache by the given multiplier.
-     *
-     * <p>
-     *     If the size multiplier causes the size of the cache to be decreased, items will be evicted until the cache
-     *     is smaller than the new size.
-     * </p>
-     *
-     * @param multiplier A size multiplier >= 0.
-     */
-    void setSizeMultiplier(float multiplier);
+  /**
+   * Adjust the maximum size of the cache by multiplying the original size of the cache by the given
+   * multiplier.
+   *
+   * <p> If the size multiplier causes the size of the cache to be decreased, items will be evicted
+   * until the cache is smaller than the new size. </p>
+   *
+   * @param multiplier A size multiplier >= 0.
+   */
+  void setSizeMultiplier(float multiplier);
 
-    /**
-     * Removes the value for the given key and returns it if present or null otherwise.
-     *
-     * @param key The key.
-     */
-    Resource<?> remove(Key key);
+  /**
+   * Removes the value for the given key and returns it if present or null otherwise.
+   *
+   * @param key The key.
+   */
+  @Nullable
+  Resource<?> remove(Key key);
 
-    /**
-     * Add bitmap to the cache with the given key.
-     *
-     * @param key The key to retrieve the bitmap.
-     * @param resource The {@link com.bumptech.glide.load.engine.EngineResource} to store.
-     * @return The old value of key (null if key is not in map).
-     */
-    Resource<?> put(Key key, Resource<?> resource);
+  /**
+   * Add bitmap to the cache with the given key.
+   *
+   * @param key      The key to retrieve the bitmap.
+   * @param resource The {@link com.bumptech.glide.load.engine.EngineResource} to store.
+   * @return The old value of key (null if key is not in map).
+   */
+  @Nullable
+  Resource<?> put(Key key, Resource<?> resource);
 
-    /**
-     * Set the listener to be called when a bitmap is removed from the cache.
-     *
-     * @param listener The listener.
-     */
-    void setResourceRemovedListener(ResourceRemovedListener listener);
+  /**
+   * Set the listener to be called when a bitmap is removed from the cache.
+   *
+   * @param listener The listener.
+   */
+  void setResourceRemovedListener(ResourceRemovedListener listener);
 
-    /**
-     * Evict all items from the memory cache.
-     */
-    void clearMemory();
+  /**
+   * Evict all items from the memory cache.
+   */
+  void clearMemory();
 
-    /**
-     * Trim the memory cache to the appropriate level. Typically called on the callback onTrimMemory.
-     *
-     * @param level This integer represents a trim level as specified in {@link android.content.ComponentCallbacks2}.
-     */
-    void trimMemory(int level);
+  /**
+   * Trim the memory cache to the appropriate level. Typically called on the callback onTrimMemory.
+   *
+   * @param level This integer represents a trim level as specified in {@link
+   *              android.content.ComponentCallbacks2}.
+   */
+  void trimMemory(int level);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
index 9fe4aeb5a..e2f92de07 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
@@ -8,46 +8,46 @@
  */
 public class MemoryCacheAdapter implements MemoryCache {
 
-    private ResourceRemovedListener listener;
-
-    @Override
-    public int getCurrentSize() {
-        return 0;
-    }
-
-    @Override
-    public int getMaxSize() {
-        return 0;
-    }
-
-    @Override
-    public void setSizeMultiplier(float multiplier) {
-        // Do nothing.
-    }
-
-    @Override
-    public Resource<?> remove(Key key) {
-        return null;
-    }
-
-    @Override
-    public Resource<?> put(Key key, Resource<?> resource) {
-        listener.onResourceRemoved(resource);
-        return null;
-    }
-
-    @Override
-    public void setResourceRemovedListener(ResourceRemovedListener listener) {
-        this.listener = listener;
-    }
-
-    @Override
-    public void clearMemory() {
-        // Do nothing.
-    }
-
-    @Override
-    public void trimMemory(int level) {
-        // Do nothing.
-    }
+  private ResourceRemovedListener listener;
+
+  @Override
+  public int getCurrentSize() {
+    return 0;
+  }
+
+  @Override
+  public int getMaxSize() {
+    return 0;
+  }
+
+  @Override
+  public void setSizeMultiplier(float multiplier) {
+    // Do nothing.
+  }
+
+  @Override
+  public Resource<?> remove(Key key) {
+    return null;
+  }
+
+  @Override
+  public Resource<?> put(Key key, Resource<?> resource) {
+    listener.onResourceRemoved(resource);
+    return null;
+  }
+
+  @Override
+  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+    this.listener = listener;
+  }
+
+  @Override
+  public void clearMemory() {
+    // Do nothing.
+  }
+
+  @Override
+  public void trimMemory(int level) {
+    // Do nothing.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index d3f9d758c..e2c56dd00 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -4,108 +4,252 @@
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
+import android.text.format.Formatter;
 import android.util.DisplayMetrics;
 import android.util.Log;
 
+import com.bumptech.glide.util.Preconditions;
+
 /**
- * A calculator that tries to intelligently determine cache sizes for a given device based on some constants and the
- * devices screen density, width, and height.
+ * A calculator that tries to intelligently determine cache sizes for a given device based on some
+ * constants and the devices screen density, width, and height.
  */
-public class MemorySizeCalculator {
-    private static final String TAG = "MemorySizeCalculator";
+public final class MemorySizeCalculator {
+  private static final String TAG = "MemorySizeCalculator";
+  // Visible for testing.
+  static final int BYTES_PER_ARGB_8888_PIXEL = 4;
+  static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
+
+  private final int bitmapPoolSize;
+  private final int memoryCacheSize;
+  private final Context context;
+  private final int arrayPoolSize;
+
+  interface ScreenDimensions {
+    int getWidthPixels();
+    int getHeightPixels();
+  }
+
+  MemorySizeCalculator(Context context, ActivityManager activityManager,
+      ScreenDimensions screenDimensions, float memoryCacheScreens, float bitmapPoolScreens,
+      int targetArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
+    this.context = context;
+    arrayPoolSize =
+        isLowMemoryDevice(activityManager)
+            ? targetArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
+            : targetArrayPoolSize;
+    final int maxSize = getMaxSize(activityManager, maxSizeMultiplier, lowMemoryMaxSizeMultiplier);
+
+    final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
+        * BYTES_PER_ARGB_8888_PIXEL;
+
+    int targetPoolSize = Math.round(screenSize * bitmapPoolScreens);
+    int targetMemoryCacheSize = Math.round(screenSize * memoryCacheScreens);
+    int availableSize = maxSize - arrayPoolSize;
+
+    if (targetMemoryCacheSize + targetPoolSize <= availableSize) {
+      memoryCacheSize = targetMemoryCacheSize;
+      bitmapPoolSize = targetPoolSize;
+    } else {
+      float part = availableSize / (bitmapPoolScreens + memoryCacheScreens);
+      memoryCacheSize = Math.round(part * memoryCacheScreens);
+      bitmapPoolSize = Math.round(part * bitmapPoolScreens);
+    }
 
-    static final int BYTES_PER_ARGB_8888_PIXEL = 4;
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(
+          TAG,
+          "Calculation complete"
+              + ", Calculated memory cache size: "
+              + toMb(memoryCacheSize)
+              + ", pool size: "
+              + toMb(bitmapPoolSize)
+              + ", byte array size: "
+              + toMb(arrayPoolSize)
+              + ", memory class limited? "
+              + (targetMemoryCacheSize + targetPoolSize > maxSize)
+              + ", max size: "
+              + toMb(maxSize)
+              + ", memoryClass: "
+              + activityManager.getMemoryClass()
+              + ", isLowMemoryDevice: "
+              + isLowMemoryDevice(activityManager));
+    }
+  }
+
+  /**
+   * Returns the recommended memory cache size for the device it is run on in bytes.
+   */
+  public int getMemoryCacheSize() {
+    return memoryCacheSize;
+  }
+
+  /**
+   * Returns the recommended bitmap pool size for the device it is run on in bytes.
+   */
+  public int getBitmapPoolSize() {
+    return bitmapPoolSize;
+  }
+
+  /**
+   * Returns the recommended array pool size for the device it is run on in bytes.
+   */
+  public int getArrayPoolSizeInBytes() {
+    return arrayPoolSize;
+  }
+
+  private static int getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,
+      float lowMemoryMaxSizeMultiplier) {
+    final int memoryClassBytes = activityManager.getMemoryClass() * 1024 * 1024;
+    final boolean isLowMemoryDevice = isLowMemoryDevice(activityManager);
+    return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier
+        : maxSizeMultiplier));
+  }
+
+  private String toMb(int bytes) {
+    return Formatter.formatFileSize(context, bytes);
+  }
+
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  private static boolean isLowMemoryDevice(ActivityManager activityManager) {
+    final int sdkInt = Build.VERSION.SDK_INT;
+    return sdkInt < Build.VERSION_CODES.HONEYCOMB
+        || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());
+  }
+
+  /**
+   * Constructs an {@link MemorySizeCalculator} with reasonable defaults that can be optionally
+   * overridden.
+   */
+  public static final class Builder {
+    // Visible for testing.
     static final int MEMORY_CACHE_TARGET_SCREENS = 2;
-    static final int BITMAP_POOL_TARGET_SCREENS = 3;
-
+    static final int BITMAP_POOL_TARGET_SCREENS = 4;
     static final float MAX_SIZE_MULTIPLIER = 0.4f;
     static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER = 0.33f;
-    private final int bitmapPoolSize;
-    private final int memoryCacheSize;
+    // 4MB.
+    static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+
+    private final Context context;
+
+    // Modifiable for testing.
+    private ActivityManager activityManager;
+    private ScreenDimensions screenDimensions;
+
+    private float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
+    private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
+    private float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
+    private float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
+    private int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
+
+    public Builder(Context context) {
+      this.context = context;
+      activityManager =
+          (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+      screenDimensions =
+          new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics());
+    }
 
-    interface ScreenDimensions {
-        int getWidthPixels();
-        int getHeightPixels();
+    /**
+     * Sets the number of device screens worth of pixels the
+     * {@link com.bumptech.glide.load.engine.cache.MemoryCache} should be able to hold and
+     * returns this Builder.
+     */
+    public Builder setMemoryCacheScreens(float memoryCacheScreens) {
+      Preconditions.checkArgument(bitmapPoolScreens >= 0,
+          "Memory cache screens must be greater than or equal to 0");
+      this.memoryCacheScreens = memoryCacheScreens;
+      return this;
     }
 
-    public MemorySizeCalculator(Context context) {
-        this((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE),
-                new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics()));
+    /**
+     * Sets the number of device screens worth of pixels the
+     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} should be able to hold and
+     * returns this Builder.
+     */
+    public Builder setBitmapPoolScreens(float bitmapPoolScreens) {
+      Preconditions.checkArgument(bitmapPoolScreens >= 0,
+          "Bitmap pool screens must be greater than or equal to 0");
+      this.bitmapPoolScreens = bitmapPoolScreens;
+      return this;
     }
 
-    MemorySizeCalculator(ActivityManager activityManager, ScreenDimensions screenDimensions) {
-        final int maxSize = getMaxSize(activityManager);
-
-        final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
-                * BYTES_PER_ARGB_8888_PIXEL;
-
-        int targetPoolSize = screenSize * BITMAP_POOL_TARGET_SCREENS;
-        int targetMemoryCacheSize = screenSize * MEMORY_CACHE_TARGET_SCREENS;
-
-        if (targetMemoryCacheSize + targetPoolSize <= maxSize) {
-            memoryCacheSize = targetMemoryCacheSize;
-            bitmapPoolSize = targetPoolSize;
-        } else {
-            int part = Math.round((float) maxSize / (BITMAP_POOL_TARGET_SCREENS + MEMORY_CACHE_TARGET_SCREENS));
-            memoryCacheSize = part * MEMORY_CACHE_TARGET_SCREENS;
-            bitmapPoolSize = part * BITMAP_POOL_TARGET_SCREENS;
-        }
-
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Calculated memory cache size: " + toMb(memoryCacheSize) + " pool size: " + toMb(bitmapPoolSize)
-                    + " memory class limited? " + (targetMemoryCacheSize + targetPoolSize > maxSize) + " max size: "
-                    + toMb(maxSize) + " memoryClass: " + activityManager.getMemoryClass() + " isLowMemoryDevice: "
-                    + isLowMemoryDevice(activityManager));
-        }
+    /**
+     * Sets the maximum percentage of the device's memory class for standard devices that can be
+     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and
+     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns
+     * this builder.
+     */
+    public Builder setMaxSizeMultiplier(float maxSizeMultiplier) {
+      Preconditions.checkArgument(maxSizeMultiplier >= 0 && maxSizeMultiplier <= 1,
+          "Size multiplier must be between 0 and 1");
+      this.maxSizeMultiplier = maxSizeMultiplier;
+      return this;
     }
 
     /**
-     * Returns the recommended memory cache size for the device it is run on in bytes.
+     * Sets the maximum percentage of the device's memory class for low ram devices that can be
+     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and
+     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns
+     * this builder.
+     *
+     * @see ActivityManager#isLowRamDevice()
      */
-    public int getMemoryCacheSize() {
-        return memoryCacheSize;
+    public Builder setLowMemoryMaxSizeMultiplier(float lowMemoryMaxSizeMultiplier) {
+      Preconditions.checkArgument(
+          lowMemoryMaxSizeMultiplier >= 0 && lowMemoryMaxSizeMultiplier <= 1,
+              "Low memory max size multiplier must be between 0 and 1");
+      this.lowMemoryMaxSizeMultiplier = lowMemoryMaxSizeMultiplier;
+      return this;
     }
 
     /**
-     * Returns the recommended bitmap pool size for the device it is run on in bytes.
+     * Sets the size in bytes of the {@link
+     * com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool} to use to store temporary
+     * arrays while decoding data and returns this builder.
+     *
+     * <p>This number will be halved on low memory devices that return {@code true} from
+     * {@link ActivityManager#isLowRamDevice()}.
      */
-    public int getBitmapPoolSize() {
-        return bitmapPoolSize;
+    public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
+      this.arrayPoolSizeBytes = arrayPoolSizeBytes;
+      return this;
     }
 
-    private static int getMaxSize(ActivityManager activityManager) {
-        final int memoryClassBytes = activityManager.getMemoryClass() * 1024 * 1024;
-        final boolean isLowMemoryDevice = isLowMemoryDevice(activityManager);
-        return Math.round(memoryClassBytes
-                * (isLowMemoryDevice ? LOW_MEMORY_MAX_SIZE_MULTIPLIER : MAX_SIZE_MULTIPLIER));
+    // Visible for testing.
+    Builder setActivityManager(ActivityManager activityManager) {
+      this.activityManager = activityManager;
+      return this;
     }
 
-    private static int toMb(int bytes) {
-        return bytes / (1024 * 1024);
+    // Visible for testing.
+    Builder setScreenDimensions(ScreenDimensions screenDimensions) {
+      this.screenDimensions = screenDimensions;
+      return this;
     }
 
-    @TargetApi(Build.VERSION_CODES.KITKAT)
-    private static boolean isLowMemoryDevice(ActivityManager activityManager) {
-        final int sdkInt = Build.VERSION.SDK_INT;
-        return sdkInt < Build.VERSION_CODES.HONEYCOMB
-                || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());
+    public MemorySizeCalculator build() {
+      return new MemorySizeCalculator(context, activityManager, screenDimensions,
+          memoryCacheScreens, bitmapPoolScreens, arrayPoolSizeBytes, maxSizeMultiplier,
+          lowMemoryMaxSizeMultiplier);
     }
+  }
 
-    private static class DisplayMetricsScreenDimensions implements ScreenDimensions {
-        private final DisplayMetrics displayMetrics;
+  private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
+    private final DisplayMetrics displayMetrics;
 
-        public DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
-            this.displayMetrics = displayMetrics;
-        }
+    public DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
+      this.displayMetrics = displayMetrics;
+    }
 
-        @Override
-        public int getWidthPixels() {
-            return displayMetrics.widthPixels;
-        }
+    @Override
+    public int getWidthPixels() {
+      return displayMetrics.widthPixels;
+    }
 
-        @Override
-        public int getHeightPixels() {
-            return displayMetrics.heightPixels;
-        }
+    @Override
+    public int getHeightPixels() {
+      return displayMetrics.heightPixels;
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index a2594f751..06cc14ffa 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -4,35 +4,37 @@
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
 
-import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
 /**
- * A class that generates and caches safe and unique string file names from {@link com.bumptech.glide.load.Key}s.
+ * A class that generates and caches safe and unique string file names from {@link
+ * com.bumptech.glide.load.Key}s.
  */
-class SafeKeyGenerator {
-    private final LruCache<Key, String> loadIdToSafeHash = new LruCache<Key, String>(1000);
+public class SafeKeyGenerator {
+  private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
 
-    public String getSafeKey(Key key) {
-        String safeKey;
-        synchronized (loadIdToSafeHash) {
-            safeKey = loadIdToSafeHash.get(key);
-        }
-        if (safeKey == null) {
-            try {
-                MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-                key.updateDiskCacheKey(messageDigest);
-                safeKey = Util.sha256BytesToHex(messageDigest.digest());
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
-            } catch (NoSuchAlgorithmException e) {
-                e.printStackTrace();
-            }
-            synchronized (loadIdToSafeHash) {
-                loadIdToSafeHash.put(key, safeKey);
-            }
-        }
-        return safeKey;
+  private static String calculateHexStringDigest(Key key) {
+     try {
+        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+        key.updateDiskCacheKey(messageDigest);
+        return Util.sha256BytesToHex(messageDigest.digest());
+      } catch (NoSuchAlgorithmException e) {
+       throw new RuntimeException(e);
+      }
+  }
+
+  public String getSafeKey(Key key) {
+    String safeKey;
+    synchronized (loadIdToSafeHash) {
+      safeKey = loadIdToSafeHash.get(key);
+    }
+    if (safeKey == null) {
+      safeKey = calculateHexStringDigest(key);
+    }
+    synchronized (loadIdToSafeHash) {
+      loadIdToSafeHash.put(key, safeKey);
     }
+    return safeKey;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java
deleted file mode 100644
index db0a128ac..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package com.bumptech.glide.load.engine.executor;
-
-import java.util.concurrent.FutureTask;
-import java.util.concurrent.PriorityBlockingQueue;
-import java.util.concurrent.RunnableFuture;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * A FIFO priority {@link ThreadPoolExecutor} that prioritizes submitted {@link Runnable}s by assuming they implement
- * {@link Prioritized}. {@link Prioritized} runnables that return lower values for {@link Prioritized#getPriority()}
- * will be executed before those that return higher values. Priorities only apply when multiple items are queued at the
- * same time. Runnables with the same priority will be executed in FIFO order.
- */
-public class FifoPriorityThreadPoolExecutor extends ThreadPoolExecutor {
-    AtomicInteger ordering = new AtomicInteger();
-
-    /**
-     * Constructor to build a fixed thread pool with the given pool size using
-     * {@link com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor.DefaultThreadFactory}.
-     *
-     * @param poolSize The number of threads.
-     */
-    public FifoPriorityThreadPoolExecutor(int poolSize) {
-        this(poolSize, poolSize, 0, TimeUnit.MILLISECONDS, new DefaultThreadFactory());
-    }
-
-    public FifoPriorityThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAlive, TimeUnit timeUnit,
-            ThreadFactory threadFactory) {
-        super(corePoolSize, maximumPoolSize, keepAlive, timeUnit, new PriorityBlockingQueue<Runnable>(), threadFactory);
-    }
-
-    @Override
-    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
-        return new LoadTask<T>(runnable, value, ordering.getAndIncrement());
-    }
-
-    /**
-     * A {@link java.util.concurrent.ThreadFactory} that builds threads with priority
-     * {@link android.os.Process#THREAD_PRIORITY_BACKGROUND}.
-     */
-    public static class DefaultThreadFactory implements ThreadFactory {
-        int threadNum = 0;
-        @Override
-        public Thread newThread(Runnable runnable) {
-            final Thread result = new Thread(runnable, "fifo-pool-thread-" + threadNum) {
-                @Override
-                public void run() {
-                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
-                    super.run();
-                }
-            };
-            threadNum++;
-            return result;
-        }
-    }
-
-    // Visible for testing.
-    static class LoadTask<T> extends FutureTask<T> implements Comparable<LoadTask<?>> {
-        private final int priority;
-        private final int order;
-
-        public LoadTask(Runnable runnable, T result, int order) {
-            super(runnable, result);
-            if (!(runnable instanceof Prioritized)) {
-                throw new IllegalArgumentException("FifoPriorityThreadPoolExecutor must be given Runnables that "
-                        + "implement Prioritized");
-            }
-            priority = ((Prioritized) runnable).getPriority();
-            this.order = order;
-        }
-
-        @SuppressWarnings("unchecked")
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof LoadTask) {
-                LoadTask<Object> other = (LoadTask<Object>) o;
-                return order == other.order && priority == other.priority;
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = priority;
-            result = 31 * result + order;
-            return result;
-        }
-
-        @Override
-        public int compareTo(LoadTask<?> loadTask) {
-            int result = priority - loadTask.priority;
-            if (result == 0) {
-                result = order - loadTask.order;
-            }
-            return result;
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
new file mode 100644
index 000000000..aca64853a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -0,0 +1,147 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.util.Log;
+
+import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
+ */
+public class GlideExecutor extends ThreadPoolExecutor {
+  private static final String TAG = "GlideExecutor";
+  private static final String DEFAULT_NAME = "fifo-pool";
+
+  /**
+   * Constructor to build a fixed thread pool with the given pool size.
+   *
+   * @param poolSize The number of threads.
+   */
+  public GlideExecutor(int poolSize) {
+    this(poolSize, new DefaultThreadFactory());
+  }
+
+  /**
+   * Constructor to build a fixed thread pool with the given pool size.
+   *
+   * @param poolSize The number of threads.
+   * @param uncaughtThrowableStrategy Dictates how the pool should handle uncaught and unexpected
+   *                                  throwables thrown by Futures run by the pool.
+   */
+  public GlideExecutor(int poolSize,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    this(poolSize, new DefaultThreadFactory(uncaughtThrowableStrategy));
+  }
+
+  /**
+   * Constructor to build a fixed thread pool with the given pool size.
+   *
+   * @param name The prefix for threads created by this pool.
+   * @param poolSize The number of threads.
+   */
+  public GlideExecutor(String name, int poolSize) {
+    this(poolSize, new DefaultThreadFactory(name));
+  }
+
+  /**
+   * Constructor to build a fixed thread pool with the given pool size.
+   *
+   * @param name The prefix for each thread name.
+   * @param poolSize The number of threads.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
+   */
+  public GlideExecutor(String name, int poolSize,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    this(poolSize, new DefaultThreadFactory(name, uncaughtThrowableStrategy));
+  }
+
+  private GlideExecutor(int corePoolSize, ThreadFactory threadFactory) {
+    super(corePoolSize, corePoolSize, 0, TimeUnit.MILLISECONDS,
+        new PriorityBlockingQueue<Runnable>(), threadFactory);
+  }
+
+  /**
+   * A strategy for handling unexpected and uncaught throwables thrown by futures run on the pool.
+   */
+  public enum UncaughtThrowableStrategy {
+    /**
+     * Silently catches and ignores the uncaught throwables.
+     */
+    IGNORE,
+    /**
+     * Logs the uncaught throwables using {@link #TAG} and {@link Log}.
+     */
+    LOG {
+      @Override
+      protected void handle(Throwable t) {
+        if (t != null && Log.isLoggable(TAG, Log.ERROR)) {
+          Log.e(TAG, "Request threw uncaught throwable", t);
+        }
+      }
+    },
+    /**
+     * Rethrows the uncaught throwables to crash the app.
+     */
+    THROW {
+      @Override
+      protected void handle(Throwable t) {
+        super.handle(t);
+        if (t != null) {
+          throw new RuntimeException("Request threw uncaught throwable", t);
+        }
+      }
+    };
+
+    protected void handle(Throwable t) {
+      // Ignore.
+    }
+  }
+
+  /**
+   * A {@link java.util.concurrent.ThreadFactory} that builds threads with priority {@link
+   * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
+   */
+  private static final class DefaultThreadFactory implements ThreadFactory {
+    private final String name;
+    private final UncaughtThrowableStrategy uncaughtThrowableStrategy;
+    private int threadNum = 0;
+
+    DefaultThreadFactory() {
+      this(DEFAULT_NAME);
+    }
+
+    DefaultThreadFactory(String name) {
+      this(name, UncaughtThrowableStrategy.LOG);
+    }
+
+    DefaultThreadFactory(UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+      this(DEFAULT_NAME, uncaughtThrowableStrategy);
+    }
+
+    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+      this.name = name;
+      this.uncaughtThrowableStrategy = uncaughtThrowableStrategy;
+    }
+
+    @Override
+    public Thread newThread(Runnable runnable) {
+      final Thread result = new Thread(runnable, name + "-thread-" + threadNum) {
+        @Override
+        public void run() {
+          android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+          try {
+            super.run();
+          } catch (Throwable t) {
+            uncaughtThrowableStrategy.handle(t);
+          }
+        }
+      };
+      threadNum++;
+      return result;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/Prioritized.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/Prioritized.java
deleted file mode 100644
index 6e19d2e6c..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/Prioritized.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package com.bumptech.glide.load.engine.executor;
-
-/**
- * A simple interface for exposing the priority of a task. Lower integer values are treated as having higher priority
- * with 0 being the highest priority possible.
- */
-public interface Prioritized {
-    /**
-     * Returns the priority of this task.
-     */
-    int getPriority();
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index 6af89c197..04243f947 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -12,150 +12,147 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.util.Util;
 
-import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 /**
- * A class that allocates {@link android.graphics.Bitmap Bitmaps} to make sure that the
- * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} is pre-populated.
+ * A class that allocates {@link android.graphics.Bitmap Bitmaps} to make sure that the {@link
+ * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} is pre-populated.
  *
- * <p>By posting to the main thread with backoffs, we try to avoid ANRs when the garbage collector gets into a state
- * where a high percentage of {@link Bitmap} allocations trigger a stop the world GC. We try to detect whether or not a
- * GC has occurred by only allowing our allocator to run for a limited number of milliseconds. Since the allocations
- * themselves very fast, a GC is the most likely reason for a substantial delay. If we detect our allocator has run for
- * more than our limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
+ * <p>By posting to the main thread with backoffs, we try to avoid ANRs when the garbage collector
+ * gets into a state where a high percentage of {@link Bitmap} allocations trigger a stop the world
+ * GC. We try to detect whether or not a GC has occurred by only allowing our allocator to run for a
+ * limited number of milliseconds. Since the allocations themselves very fast, a GC is the most
+ * likely reason for a substantial delay. If we detect our allocator has run for more than our
+ * limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
  */
 final class BitmapPreFillRunner implements Runnable {
-    private static final String TAG = "PreFillRunner";
-    private static final Clock DEFAULT_CLOCK = new Clock();
-
-    /**
-     * The maximum number of millis we can run before posting. Set to match and detect the duration of non concurrent
-     * GCs.
-     */
-    static final long MAX_DURATION_MS = 32;
-
-    /**
-     * The amount of time in ms we wait before continuing to allocate after the first GC is detected.
-     */
-    static final long INITIAL_BACKOFF_MS = 40;
-
-    /**
-     * The amount by which the current backoff time is multiplied each time we detect a GC.
-     */
-    static final int BACKOFF_RATIO = 4;
-
-    /**
-     * The maximum amount of time in ms we wait before continuing to allocate.
-     */
-    static final long MAX_BACKOFF_MS = TimeUnit.SECONDS.toMillis(1);
-
-    private final BitmapPool bitmapPool;
-    private final MemoryCache memoryCache;
-    private final PreFillQueue toPrefill;
-    private final Clock clock;
-    private final Set<PreFillType> seenTypes = new HashSet<PreFillType>();
-    private final Handler handler;
-
-    private long currentDelay = INITIAL_BACKOFF_MS;
-    private boolean isCancelled;
-
-    public BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {
-        this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK, new Handler(Looper.getMainLooper()));
-    }
+  private static final String TAG = "PreFillRunner";
+  private static final Clock DEFAULT_CLOCK = new Clock();
+
+  /**
+   * The maximum number of millis we can run before posting. Set to match and detect the duration of
+   * non concurrent GCs.
+   */
+  static final long MAX_DURATION_MS = 32;
+
+  /**
+   * The amount of time in ms we wait before continuing to allocate after the first GC is detected.
+   */
+  static final long INITIAL_BACKOFF_MS = 40;
+
+  /**
+   * The amount by which the current backoff time is multiplied each time we detect a GC.
+   */
+  static final int BACKOFF_RATIO = 4;
+
+  /**
+   * The maximum amount of time in ms we wait before continuing to allocate.
+   */
+  static final long MAX_BACKOFF_MS = TimeUnit.SECONDS.toMillis(1);
+
+  private final BitmapPool bitmapPool;
+  private final MemoryCache memoryCache;
+  private final PreFillQueue toPrefill;
+  private final Clock clock;
+  private final Set<PreFillType> seenTypes = new HashSet<>();
+  private final Handler handler;
+
+  private long currentDelay = INITIAL_BACKOFF_MS;
+  private boolean isCancelled;
+
+  public BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache,
+      PreFillQueue allocationOrder) {
+    this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK,
+        new Handler(Looper.getMainLooper()));
+  }
+
+  // Visible for testing.
+  BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder,
+      Clock clock, Handler handler) {
+    this.bitmapPool = bitmapPool;
+    this.memoryCache = memoryCache;
+    this.toPrefill = allocationOrder;
+    this.clock = clock;
+    this.handler = handler;
+  }
+
+  public void cancel() {
+    isCancelled = true;
+  }
+
+  /**
+   * Attempts to allocate {@link android.graphics.Bitmap}s and returns {@code true} if there are
+   * more {@link android.graphics.Bitmap}s to allocate and {@code false} otherwise.
+   */
+  private boolean allocate() {
+    long start = clock.now();
+    while (!toPrefill.isEmpty() && !isGcDetected(start)) {
+      PreFillType toAllocate = toPrefill.remove();
+      final Bitmap bitmap;
+      if (!seenTypes.contains(toAllocate)) {
+        seenTypes.add(toAllocate);
+        bitmap = bitmapPool.getDirty(toAllocate.getWidth(), toAllocate.getHeight(),
+            toAllocate.getConfig());
+      } else {
+        bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
+            toAllocate.getConfig());
+      }
+
+      // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's
+      // not empty so
+      // we use all available space.
+      if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
+        memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
+      } else {
+        bitmapPool.put(bitmap);
+      }
 
-    // Visible for testing.
-    BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder, Clock clock,
-            Handler handler) {
-        this.bitmapPool = bitmapPool;
-        this.memoryCache = memoryCache;
-        this.toPrefill = allocationOrder;
-        this.clock = clock;
-        this.handler = handler;
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG,
+            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] " + toAllocate
+                .getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
+      }
     }
 
-    public void cancel() {
-        isCancelled = true;
-    }
+    return !isCancelled && !toPrefill.isEmpty();
+  }
 
-    /**
-     * Attempts to allocate {@link android.graphics.Bitmap}s and returns {@code true} if there are more
-     * {@link android.graphics.Bitmap}s to allocate and {@code false} otherwise.
-     */
-    private boolean allocate() {
-        long start = clock.now();
-        while (!toPrefill.isEmpty() && !isGcDetected(start)) {
-            PreFillType toAllocate = toPrefill.remove();
-            Bitmap bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
-                    toAllocate.getConfig());
-
-            // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's not empty so
-            // we use all available space.
-            if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
-                memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
-            } else {
-                addToBitmapPool(toAllocate, bitmap);
-            }
-
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] "
-                        + toAllocate.getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
-            }
-        }
-
-        return !isCancelled && !toPrefill.isEmpty();
-    }
+  private boolean isGcDetected(long startTimeMs) {
+    return clock.now() - startTimeMs >= MAX_DURATION_MS;
+  }
 
-    private boolean isGcDetected(long startTimeMs) {
-        return clock.now() - startTimeMs >= MAX_DURATION_MS;
-    }
+  private int getFreeMemoryCacheBytes() {
+    return memoryCache.getMaxSize() - memoryCache.getCurrentSize();
+  }
 
-    private int getFreeMemoryCacheBytes() {
-        return memoryCache.getMaxSize() - memoryCache.getCurrentSize();
+  @Override
+  public void run() {
+    if (allocate()) {
+      handler.postDelayed(this, getNextDelay());
     }
+  }
 
-    private void addToBitmapPool(PreFillType toAllocate, Bitmap bitmap) {
-        // The pool may not move sizes to the front of the LRU on put. Do a get here to make sure the size we're adding
-        // is at the front of the queue so that the Bitmap we're adding won't be evicted immediately.
-        if (seenTypes.add(toAllocate)) {
-          Bitmap fromPool = bitmapPool.get(toAllocate.getWidth(), toAllocate.getHeight(),
-              toAllocate.getConfig());
-            if (fromPool != null) {
-                bitmapPool.put(fromPool);
-            }
-        }
+  private long getNextDelay() {
+    long result = currentDelay;
+    currentDelay = Math.min(currentDelay * BACKOFF_RATIO, MAX_BACKOFF_MS);
+    return result;
+  }
 
-        bitmapPool.put(bitmap);
-    }
+  private static class UniqueKey implements Key {
 
     @Override
-    public void run() {
-        if (allocate()) {
-            handler.postDelayed(this, getNextDelay());
-        }
-    }
-
-    private long getNextDelay() {
-        long result = currentDelay;
-        currentDelay = Math.min(currentDelay * BACKOFF_RATIO, MAX_BACKOFF_MS);
-        return result;
-    }
-
-    private static class UniqueKey implements Key {
-
-        @Override
-        public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-            // Do nothing.
-        }
+    public void updateDiskCacheKey(MessageDigest messageDigest) {
+      throw new UnsupportedOperationException();
     }
+  }
 
-    // Visible for testing.
-    static class Clock {
-        public long now() {
-            return SystemClock.currentThreadTimeMillis();
-        }
+  // Visible for testing.
+  static class Clock {
+    public long now() {
+      return SystemClock.currentThreadTimeMillis();
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index f2e9accc1..b91c4f73a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -18,63 +18,65 @@
  */
 public final class BitmapPreFiller {
 
-    private final MemoryCache memoryCache;
-    private final BitmapPool bitmapPool;
-    private final DecodeFormat defaultFormat;
-    private final Handler handler = new Handler(Looper.getMainLooper());
-
-    private BitmapPreFillRunner current;
-
-    public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool, DecodeFormat defaultFormat) {
-        this.memoryCache = memoryCache;
-        this.bitmapPool = bitmapPool;
-        this.defaultFormat = defaultFormat;
+  private final MemoryCache memoryCache;
+  private final BitmapPool bitmapPool;
+  private final DecodeFormat defaultFormat;
+  private final Handler handler = new Handler(Looper.getMainLooper());
+
+  private BitmapPreFillRunner current;
+
+  public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool,
+      DecodeFormat defaultFormat) {
+    this.memoryCache = memoryCache;
+    this.bitmapPool = bitmapPool;
+    this.defaultFormat = defaultFormat;
+  }
+
+  public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
+    if (current != null) {
+      current.cancel();
     }
 
-    public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
-        if (current != null) {
-            current.cancel();
-        }
-
-        PreFillType[] bitmapAttributes = new PreFillType[bitmapAttributeBuilders.length];
-        for (int i = 0; i < bitmapAttributeBuilders.length; i++) {
-            PreFillType.Builder builder = bitmapAttributeBuilders[i];
-            if (builder.getConfig() == null) {
-                builder.setConfig(defaultFormat == DecodeFormat.ALWAYS_ARGB_8888
-                        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
-            }
-            bitmapAttributes[i] = builder.build();
-        }
-
-        PreFillQueue allocationOrder = generateAllocationOrder(bitmapAttributes);
-        current = new BitmapPreFillRunner(bitmapPool, memoryCache, allocationOrder);
-        handler.post(current);
+    PreFillType[] bitmapAttributes = new PreFillType[bitmapAttributeBuilders.length];
+    for (int i = 0; i < bitmapAttributeBuilders.length; i++) {
+      PreFillType.Builder builder = bitmapAttributeBuilders[i];
+      if (builder.getConfig() == null) {
+        builder.setConfig(defaultFormat == DecodeFormat.PREFER_ARGB_8888
+            ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
+      }
+      bitmapAttributes[i] = builder.build();
     }
 
-    // Visible for testing.
-    PreFillQueue generateAllocationOrder(PreFillType[] preFillSizes) {
-        final int maxSize = memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
+    PreFillQueue allocationOrder = generateAllocationOrder(bitmapAttributes);
+    current = new BitmapPreFillRunner(bitmapPool, memoryCache, allocationOrder);
+    handler.post(current);
+  }
 
-        int totalWeight = 0;
-        for (PreFillType size : preFillSizes) {
-            totalWeight += size.getWeight();
-        }
+  // Visible for testing.
+  PreFillQueue generateAllocationOrder(PreFillType[] preFillSizes) {
+    final int maxSize =
+        memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
-        final float bytesPerWeight = maxSize / (float) totalWeight;
+    int totalWeight = 0;
+    for (PreFillType size : preFillSizes) {
+      totalWeight += size.getWeight();
+    }
 
-        Map<PreFillType, Integer> attributeToCount = new HashMap<PreFillType, Integer>();
-        for (PreFillType size : preFillSizes) {
-            int bytesForSize = Math.round(bytesPerWeight * size.getWeight());
-            int bytesPerBitmap = getSizeInBytes(size);
-            int bitmapsForSize = bytesForSize / bytesPerBitmap;
-            attributeToCount.put(size, bitmapsForSize);
-        }
+    final float bytesPerWeight = maxSize / (float) totalWeight;
 
-        return new PreFillQueue(attributeToCount);
+    Map<PreFillType, Integer> attributeToCount = new HashMap<>();
+    for (PreFillType size : preFillSizes) {
+      int bytesForSize = Math.round(bytesPerWeight * size.getWeight());
+      int bytesPerBitmap = getSizeInBytes(size);
+      int bitmapsForSize = bytesForSize / bytesPerBitmap;
+      attributeToCount.put(size, bitmapsForSize);
     }
 
-    private static int getSizeInBytes(PreFillType size) {
-        return Util.getBitmapByteSize(size.getWidth(), size.getHeight(), size.getConfig());
-    }
+    return new PreFillQueue(attributeToCount);
+  }
+
+  private static int getSizeInBytes(PreFillType size) {
+    return Util.getBitmapByteSize(size.getWidth(), size.getHeight(), size.getConfig());
+  }
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillQueue.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillQueue.java
index f88032a80..80d0c6852 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillQueue.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillQueue.java
@@ -6,44 +6,44 @@
 
 final class PreFillQueue {
 
-    private final Map<PreFillType, Integer> bitmapsPerType;
-    private final List<PreFillType> keyList;
-    private int bitmapsRemaining;
-    private int keyIndex;
-
-    public PreFillQueue(Map<PreFillType, Integer> bitmapsPerType) {
-        this.bitmapsPerType = bitmapsPerType;
-        // We don't particularly care about the initial order.
-        keyList = new ArrayList<PreFillType>(bitmapsPerType.keySet());
-
-        for (Integer count : bitmapsPerType.values()) {
-            bitmapsRemaining += count;
-        }
+  private final Map<PreFillType, Integer> bitmapsPerType;
+  private final List<PreFillType> keyList;
+  private int bitmapsRemaining;
+  private int keyIndex;
+
+  public PreFillQueue(Map<PreFillType, Integer> bitmapsPerType) {
+    this.bitmapsPerType = bitmapsPerType;
+    // We don't particularly care about the initial order.
+    keyList = new ArrayList<>(bitmapsPerType.keySet());
+
+    for (Integer count : bitmapsPerType.values()) {
+      bitmapsRemaining += count;
     }
+  }
 
-    public PreFillType remove() {
-        PreFillType result = keyList.get(keyIndex);
+  public PreFillType remove() {
+    PreFillType result = keyList.get(keyIndex);
 
-        Integer countForResult = bitmapsPerType.get(result);
-        if (countForResult == 1) {
-            bitmapsPerType.remove(result);
-            keyList.remove(keyIndex);
-        } else {
-            bitmapsPerType.put(result, countForResult - 1);
-        }
-        bitmapsRemaining--;
+    Integer countForResult = bitmapsPerType.get(result);
+    if (countForResult == 1) {
+      bitmapsPerType.remove(result);
+      keyList.remove(keyIndex);
+    } else {
+      bitmapsPerType.put(result, countForResult - 1);
+    }
+    bitmapsRemaining--;
 
-        // Avoid divide by 0.
-        keyIndex =  keyList.isEmpty() ? 0 : (keyIndex + 1) % keyList.size();
+    // Avoid divide by 0.
+    keyIndex = keyList.isEmpty() ? 0 : (keyIndex + 1) % keyList.size();
 
-        return result;
-    }
+    return result;
+  }
 
-    public int getSize() {
-        return bitmapsRemaining;
-    }
+  public int getSize() {
+    return bitmapsRemaining;
+  }
 
-    public boolean isEmpty() {
-        return bitmapsRemaining == 0;
-    }
+  public boolean isEmpty() {
+    return bitmapsRemaining == 0;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
index 5037b3524..b423df158 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -1,172 +1,173 @@
 package com.bumptech.glide.load.engine.prefill;
 
 import android.graphics.Bitmap;
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.util.Preconditions;
 
 /**
- * A container for a set of options used to pre-fill a {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}
- * with {@link Bitmap Bitmaps} of a single size and configuration.
+ * A container for a put of options used to pre-fill a
+ * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} with {@link Bitmap Bitmaps} of a
+ * single size and configuration.
  */
 public final class PreFillType {
-    // Visible for testing.
-    static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
+  // Visible for testing.
+  static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
+  private final int width;
+  private final int height;
+  private final Bitmap.Config config;
+  private final int weight;
+
+  /**
+   * Constructor for a single type of {@link android.graphics.Bitmap}.
+   *
+   * @param width  The width in pixels of the {@link android.graphics.Bitmap Bitmaps} to pre-fill.
+   * @param height The height in pixels of the {@link android.graphics.Bitmap Bitmaps} to pre-fill.
+   * @param config The {@link android.graphics.Bitmap.Config} of the
+   *               {@link android.graphics.Bitmap Bitmaps} to pre-fill.
+   * @param weight An integer indicating how to balance pre-filling this size and configuration of
+   *               {@link android.graphics.Bitmap} against any other sizes/configurations that may
+   *               be being pre-filled.
+   */
+  PreFillType(int width, int height, Bitmap.Config config, int weight) {
+    this.config = Preconditions.checkNotNull(config, "Config must not be null");
+    this.width = width;
+    this.height = height;
+    this.weight = weight;
+  }
+
+  /**
+   * Returns the width in pixels of the {@link android.graphics.Bitmap Bitmaps}.
+   */
+  int getWidth() {
+    return width;
+  }
+
+  /**
+   * Returns the height in pixels of the {@link android.graphics.Bitmap Bitmaps}.
+   */
+  int getHeight() {
+    return height;
+  }
+
+  /**
+   * Returns the {@link android.graphics.Bitmap.Config} of the
+   * {@link android.graphics.Bitmap Bitmaps}.
+   */
+  Bitmap.Config getConfig() {
+    return config;
+  }
+
+  /**
+   * Returns the weight of the {@link android.graphics.Bitmap Bitmaps} of this type.
+   */
+  int getWeight() {
+    return weight;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof PreFillType) {
+      PreFillType other = (PreFillType) o;
+      return height == other.height && width == other.width && weight == other.weight
+          && config == other.config;
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = width;
+    result = 31 * result + height;
+    result = 31 * result + config.hashCode();
+    result = 31 * result + weight;
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "PreFillSize{" + "width=" + width + ", height=" + height + ", config=" + config
+        + ", weight=" + weight + '}';
+  }
+
+  /**
+   * Builder for {@link PreFillType}.
+   */
+  public static class Builder {
     private final int width;
     private final int height;
-    private final Bitmap.Config config;
-    private final int weight;
+
+    private Bitmap.Config config;
+    private int weight = 1;
 
     /**
-     * Constructor for a single type of {@link android.graphics.Bitmap}.
+     * Constructor for a builder that uses the given size as the width and height of the Bitmaps to
+     * prefill.
      *
-     * @param width The width in pixels of the {@link android.graphics.Bitmap Bitmaps} to
-     *              pre-fill.
-     * @param height The height in pixels of the {@link android.graphics.Bitmap Bitmaps} to
-     *               pre-fill.
-     * @param config The {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap Bitmaps} to
-     *               pre-fill.
-     * @param weight An integer indicating how to balance pre-filling this size and configuration of
-     * {@link android.graphics.Bitmap} against any other sizes/configurations that may be being pre-filled.
+     * @param size The width and height in pixels of the Bitmaps to prefill.
      */
-    PreFillType(int width, int height, Bitmap.Config config, int weight) {
-        if (config == null) {
-            throw new NullPointerException("Config must not be null");
-        }
-
-        this.width = width;
-        this.height = height;
-        this.config = config;
-        this.weight = weight;
+    public Builder(int size) {
+      this(size, size);
     }
 
     /**
-     * Returns the width in pixels of the {@link android.graphics.Bitmap Bitmaps}.
+     * Constructor for a builder that uses the given dimensions as the dimensions of the Bitmaps to
+     * prefill.
+     *
+     * @param width  The width in pixels of the Bitmaps to prefill.
+     * @param height The height in pixels of the Bitmaps to prefill.
      */
-    int getWidth() {
-        return width;
+    public Builder(int width, int height) {
+      if (width <= 0) {
+        throw new IllegalArgumentException("Width must be > 0");
+      }
+      if (height <= 0) {
+        throw new IllegalArgumentException("Height must be > 0");
+      }
+      this.width = width;
+      this.height = height;
     }
 
     /**
-     * Returns the height in pixels of the {@link android.graphics.Bitmap Bitmaps}.
+     * Sets the {@link android.graphics.Bitmap.Config} for the Bitmaps to pre-fill.
+     *
+     * @param config The config to use, or null to use Glide's default.
+     * @return This builder.
      */
-    int getHeight() {
-        return height;
+    public Builder setConfig(@Nullable Bitmap.Config config) {
+      this.config = config;
+      return this;
     }
 
     /**
-     * Returns the {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap Bitmaps}.
+     * Returns the current {@link android.graphics.Bitmap.Config}.
      */
     Bitmap.Config getConfig() {
-        return config;
+      return config;
     }
 
     /**
-     * Returns the weight of the {@link android.graphics.Bitmap Bitmaps} of this type.
+     * Sets the weight to use to balance how many Bitmaps of this type are prefilled relative to the
+     * other requested types.
+     *
+     * @param weight An integer indicating how to balance pre-filling this size and configuration of
+     *               {@link android.graphics.Bitmap} against any other sizes/configurations that may
+     *               be being pre-filled.
+     * @return This builder.
      */
-    int getWeight() {
-        return weight;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (o instanceof PreFillType) {
-            PreFillType other = (PreFillType) o;
-            return height == other.height
-                    && width == other.width
-                    && weight == other.weight
-                    && config == other.config;
-        }
-        return false;
-    }
-
-    @Override
-    public int hashCode() {
-        int result = width;
-        result = 31 * result + height;
-        result = 31 * result + config.hashCode();
-        result = 31 * result + weight;
-        return result;
-    }
-
-    @Override
-    public String toString() {
-        return "PreFillSize{"
-                + "width=" + width
-                + ", height=" + height
-                + ", config=" + config
-                + ", weight=" + weight
-                + '}';
+    public Builder setWeight(int weight) {
+      if (weight <= 0) {
+        throw new IllegalArgumentException("Weight must be > 0");
+      }
+      this.weight = weight;
+      return this;
     }
 
     /**
-     * Builder for {@link PreFillType}.
+     * Returns a new {@link PreFillType}.
      */
-    public static class Builder {
-        private final int width;
-        private final int height;
-
-        private Bitmap.Config config;
-        private int weight = 1;
-
-        /**
-         * Constructor for a builder that uses the given size as the width and height of the Bitmaps to prefill.
-         * @param size The width and height in pixels of the Bitmaps to prefill.
-         */
-        public Builder(int size) {
-            this(size, size);
-        }
-
-        /**
-         * Constructor for a builder that uses the given dimensions as the dimensions of the Bitmaps to prefill.
-         * @param width The width in pixels of the Bitmaps to prefill.
-         * @param height The height in pixels of the Bitmaps to prefill.
-         */
-        public Builder(int width, int height) {
-            if (width <= 0) {
-                throw new IllegalArgumentException("Width must be > 0");
-            }
-            if (height <= 0) {
-                throw new IllegalArgumentException("Height must be > 0");
-            }
-            this.width = width;
-            this.height = height;
-        }
-
-        /**
-         * Sets the {@link android.graphics.Bitmap.Config} for the Bitmaps to pre-fill.
-         * @param config The config to use, or null to use Glide's default.
-         * @return This builder.
-         */
-        public Builder setConfig(Bitmap.Config config) {
-            this.config = config;
-            return this;
-        }
-
-        /**
-         * Returns the current {@link android.graphics.Bitmap.Config}.
-         */
-        Bitmap.Config getConfig() {
-            return config;
-        }
-
-        /**
-         * Sets the weight to use to balance how many Bitmaps of this type are prefilled relative to the other requested
-         * types.
-         * @param weight An integer indicating how to balance pre-filling this size and configuration of
-         * {@link android.graphics.Bitmap} against any other sizes/configurations that may be being pre-filled.
-         * @return This builder.
-         */
-        public Builder setWeight(int weight) {
-            if (weight <= 0) {
-                throw new IllegalArgumentException("Weight must be > 0");
-            }
-            this.weight = weight;
-            return this;
-        }
-
-        /**
-         * Returns a new {@link PreFillType}.
-         */
-        PreFillType build() {
-            return new PreFillType(width, height, config, weight);
-        }
+    PreFillType build() {
+      return new PreFillType(width, height, config, weight);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
new file mode 100644
index 000000000..baa57e8c9
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -0,0 +1,105 @@
+package com.bumptech.glide.load.model;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
+import com.bumptech.glide.load.data.StreamAssetPathFetcher;
+import com.bumptech.glide.signature.ObjectKey;
+
+import java.io.InputStream;
+
+/**
+ * Loads a specific data type from an Asset Manager Uri.
+ *
+ * @param <Data> The type of data this loader will obtain.
+ */
+public class AssetUriLoader<Data> implements ModelLoader<Uri, Data> {
+  private static final String ASSET_PATH_SEGMENT = "android_asset";
+  private static final String ASSET_PREFIX =
+      ContentResolver.SCHEME_FILE + ":///" + ASSET_PATH_SEGMENT + "/";
+  private static final int ASSET_PREFIX_LENGTH = ASSET_PREFIX.length();
+
+  private final AssetManager assetManager;
+  private final AssetFetcherFactory<Data> factory;
+
+  public AssetUriLoader(AssetManager assetManager, AssetFetcherFactory<Data> factory) {
+    this.assetManager = assetManager;
+    this.factory = factory;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(Uri model, int width, int height,
+      Options options) {
+    String assetPath = model.toString().substring(ASSET_PREFIX_LENGTH);
+    return new LoadData<>(new ObjectKey(model), factory.buildFetcher(assetManager, assetPath));
+  }
+
+  @Override
+  public boolean handles(Uri model) {
+    return ContentResolver.SCHEME_FILE.equals(model.getScheme()) && !model.getPathSegments()
+        .isEmpty() && ASSET_PATH_SEGMENT.equals(model.getPathSegments().get(0));
+  }
+
+  /**
+   * A factory to build a {@link DataFetcher} for a specific asset path.
+   *
+   * @param <Data> The type of data that will be obtained by the fetcher.
+   */
+  public interface AssetFetcherFactory<Data> {
+    DataFetcher<Data> buildFetcher(AssetManager assetManager, String assetPath);
+  }
+
+  /**
+   * Factory for loading {@link InputStream}s from asset manager Uris.
+   */
+  public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
+      AssetFetcherFactory<InputStream> {
+
+    @Override
+    public ModelLoader<Uri, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(context.getAssets(), this);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+
+    @Override
+    public DataFetcher<InputStream> buildFetcher(AssetManager assetManager, String assetPath) {
+      return new StreamAssetPathFetcher(assetManager, assetPath);
+    }
+  }
+
+  /**
+   * Factory for loading {@link ParcelFileDescriptor}s from asset manager Uris.
+   */
+  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
+      ParcelFileDescriptor>,
+      AssetFetcherFactory<ParcelFileDescriptor> {
+
+    @Override
+    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(context.getAssets(), this);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+
+    @Override
+    public DataFetcher<ParcelFileDescriptor> buildFetcher(AssetManager assetManager,
+        String assetPath) {
+      return new FileDescriptorAssetPathFetcher(assetManager, assetPath);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriParser.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriParser.java
deleted file mode 100644
index a7861e6ca..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriParser.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import android.content.ContentResolver;
-import android.net.Uri;
-
-/**
- * A utility class for parsing Asset uris that look like: file:///android_asset/some/path/in/assets/folder.
- */
-final class AssetUriParser {
-    private static final String ASSET_PATH_SEGMENT = "android_asset";
-    private static final String ASSET_PREFIX = ContentResolver.SCHEME_FILE + ":///" + ASSET_PATH_SEGMENT + "/";
-    private static final int ASSET_PREFIX_LENGTH = ASSET_PREFIX.length();
-
-    private AssetUriParser() {
-        // Utility constructor.
-    }
-
-    /**
-     * Returns true if the given {@link android.net.Uri} matches the asset uri pattern.
-     */
-    public static boolean isAssetUri(Uri uri) {
-        return ContentResolver.SCHEME_FILE.equals(uri.getScheme()) && !uri.getPathSegments().isEmpty()
-                && ASSET_PATH_SEGMENT.equals(uri.getPathSegments().get(0));
-    }
-
-    /**
-     * Returns the string path for the given asset uri.
-     *
-     * <p>
-     *     Assumes the given {@link android.net.Uri} is in fact an asset uri.
-     * </p>
-     */
-    public static String toAssetPath(Uri uri) {
-        return uri.toString().substring(ASSET_PREFIX_LENGTH);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
new file mode 100644
index 000000000..52683e37d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -0,0 +1,140 @@
+package com.bumptech.glide.load.model;
+
+import android.content.Context;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.signature.EmptySignature;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * A base class to convert byte arrays to input streams so they can be decoded. This class is
+ * abstract because there is no simple/quick way to generate an id from the bytes themselves, so
+ * subclass must include an id.
+ *
+ * @param <Data> The type of data that will be loaded from a given byte array.
+ */
+public class ByteArrayLoader<Data> implements ModelLoader<byte[], Data> {
+  private final Converter<Data> converter;
+
+  public ByteArrayLoader(Converter<Data> converter) {
+    this.converter = converter;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(byte[] model, int width, int height,
+      Options options) {
+    // TODO: compare the actual bytes?
+    return new LoadData<>(EmptySignature.obtain(), new Fetcher<>(model, converter));
+  }
+
+  @Override
+  public boolean handles(byte[] model) {
+    return true;
+  }
+
+  /**
+   * Converts between a byte array a desired model class.
+   * @param <Data> The type of data to convert to.
+   */
+  public interface Converter<Data> {
+    Data convert(byte[] model);
+    Class<Data> getDataClass();
+  }
+
+  private static class Fetcher<Data> implements DataFetcher<Data> {
+    private final byte[] model;
+    private final Converter<Data> converter;
+
+    public Fetcher(byte[] model, Converter<Data> converter) {
+      this.model = model;
+      this.converter = converter;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+      Data result = converter.convert(model);
+      callback.onDataReady(result);
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @Override
+    public Class<Data> getDataClass() {
+      return converter.getDataClass();
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+
+  /**
+   * Factory for {@link com.bumptech.glide.load.model.ByteArrayLoader} and
+   * {@link java.nio.ByteBuffer}.
+   */
+  public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
+
+    @Override
+    public ModelLoader<byte[], ByteBuffer> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
+        @Override
+        public ByteBuffer convert(byte[] model) {
+          return ByteBuffer.wrap(model);
+        }
+
+        @Override
+        public Class<ByteBuffer> getDataClass() {
+          return ByteBuffer.class;
+        }
+      });
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Factory for {@link ByteArrayLoader} and {@link java.io.InputStream}.
+   */
+  public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
+
+    @Override
+    public ModelLoader<byte[], InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new ByteArrayLoader<>(new Converter<InputStream>() {
+        @Override
+        public InputStream convert(byte[] model) {
+          return new ByteArrayInputStream(model);
+        }
+
+        @Override
+        public Class<InputStream> getDataClass() {
+          return InputStream.class;
+        }
+      });
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
new file mode 100644
index 000000000..4fbd048eb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.load.model;
+
+import android.util.Log;
+
+import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.util.ByteBufferUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * Writes {@link ByteBuffer ByteBuffers} to {@link File Files}.
+ */
+public class ByteBufferEncoder implements Encoder<ByteBuffer> {
+  private static final String TAG = "ByteBufferEncoder";
+
+  @Override
+  public boolean encode(ByteBuffer data, File file, Options options) {
+    boolean success = false;
+    try {
+      ByteBufferUtil.toFile(data, file);
+      success = true;
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to write data", e);
+      }
+    }
+    return success;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
new file mode 100644
index 000000000..febd8bc1b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -0,0 +1,95 @@
+package com.bumptech.glide.load.model;
+
+import android.content.Context;
+import android.util.Log;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.util.ByteBufferUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * Loads {@link java.nio.ByteBuffer}s using NIO for {@link java.io.File}.
+ */
+public class ByteBufferFileLoader implements ModelLoader<File, ByteBuffer> {
+  private static final String TAG = "ByteBufferFileLoader";
+
+  @Override
+  public LoadData<ByteBuffer> buildLoadData(File file, int width, int height,
+      Options options) {
+    return new LoadData<>(new ObjectKey(file), new ByteBufferFetcher(file));
+  }
+
+  @Override
+  public boolean handles(File file) {
+    return true;
+  }
+
+  /**
+   * Factory for {@link com.bumptech.glide.load.model.ByteBufferFileLoader}.
+   */
+  public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
+
+    @Override
+    public ModelLoader<File, ByteBuffer> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new ByteBufferFileLoader();
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  private static class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
+
+    private final File file;
+
+    public ByteBufferFetcher(File file) {
+      this.file = file;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super ByteBuffer> callback) {
+      ByteBuffer result = null;
+      try {
+        result = ByteBufferUtil.fromFile(file);
+      } catch (IOException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Failed to obtain ByteBuffer for file", e);
+        }
+        callback.onLoadFailed(e);
+        return;
+      }
+
+      callback.onDataReady(result);
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @Override
+    public Class<ByteBuffer> getDataClass() {
+      return ByteBuffer.class;
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index 87d951722..e917a8f8b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,27 +1,177 @@
 package com.bumptech.glide.load.model;
 
-import android.net.Uri;
+import android.content.Context;
+import android.os.ParcelFileDescriptor;
+import android.util.Log;
 
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.signature.ObjectKey;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
 
 /**
  * A simple model loader for loading data from {@link File}s.
  *
- * @param <T> The type of data loaded from the given {@link java.io.File} ({@link java.io.InputStream} or
- *           {@link java.io.FileDescriptor} etc).
+ * @param <Data> The type of data loaded from the given {@link java.io.File} ({@link
+ *               java.io.InputStream} or {@link java.io.FileDescriptor} etc).
  */
-public class FileLoader<T> implements ModelLoader<File, T> {
+public class FileLoader<Data> implements ModelLoader<File, Data> {
+  private static final String TAG = "FileLoader";
 
-    private final ModelLoader<Uri, T> uriLoader;
+  private final FileOpener<Data> fileOpener;
 
-    public FileLoader(ModelLoader<Uri, T> uriLoader) {
-        this.uriLoader = uriLoader;
+  public FileLoader(FileOpener<Data> fileOpener) {
+    this.fileOpener = fileOpener;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(File model, int width, int height,
+      Options options) {
+    return new LoadData<>(new ObjectKey(model), new FileFetcher<>(model, fileOpener));
+  }
+
+  @Override
+  public boolean handles(File model) {
+    return true;
+  }
+
+  /**
+   * Allows opening a specific type of data from a {@link java.io.File}.
+   * @param <Data> The type of data that can be opened.
+   */
+  public interface FileOpener<Data> {
+    Data open(File file) throws FileNotFoundException;
+    void close(Data data) throws IOException;
+    Class<Data> getDataClass();
+  }
+
+  private static class FileFetcher<Data> implements DataFetcher<Data> {
+    private final File file;
+    private final FileOpener<Data> opener;
+    private Data data;
+
+    public FileFetcher(File file, FileOpener<Data> opener) {
+      this.file = file;
+      this.opener = opener;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+      try {
+        data = opener.open(file);
+      } catch (FileNotFoundException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Failed to open file", e);
+        }
+        callback.onLoadFailed(e);
+        return;
+      }
+      callback.onDataReady(data);
+    }
+
+    @Override
+    public void cleanup() {
+      if (data != null) {
+        try {
+          opener.close(data);
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
     }
 
     @Override
-    public DataFetcher<T> getResourceFetcher(File model, int width, int height) {
-        return uriLoader.getResourceFetcher(Uri.fromFile(model), width, height);
+    public Class<Data> getDataClass() {
+      return opener.getDataClass();
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+
+  /**
+   * Base factory for loading data from {@link java.io.File files}.
+   * @param <Data> The type of data that will be loaded for a given {@link java.io.File}.
+   */
+  public static class Factory<Data> implements ModelLoaderFactory<File, Data> {
+    private final FileOpener<Data> opener;
+
+    public Factory(FileOpener<Data> opener) {
+      this.opener = opener;
+    }
+
+    @Override
+    public final ModelLoader<File, Data> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new FileLoader<>(opener);
+    }
+
+    @Override
+    public final void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Factory for loading {@link InputStream}s from {@link File}s.
+   */
+  public static class StreamFactory extends Factory<InputStream> {
+    public StreamFactory() {
+      super(new FileOpener<InputStream>() {
+        @Override
+        public InputStream open(File file) throws FileNotFoundException {
+          return new FileInputStream(file);
+        }
+
+        @Override
+        public void close(InputStream inputStream) throws IOException {
+          inputStream.close();
+        }
+
+        @Override
+        public Class<InputStream> getDataClass() {
+          return InputStream.class;
+        }
+      });
+    }
+  }
+
+  /**
+   * Factory for loading {@link ParcelFileDescriptor}s from {@link File}s.
+   */
+  public static class FileDescriptorFactory extends Factory<ParcelFileDescriptor> {
+
+    public FileDescriptorFactory() {
+      super(new FileOpener<ParcelFileDescriptor>() {
+        @Override
+        public ParcelFileDescriptor open(File file) throws FileNotFoundException {
+          return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        }
+
+        @Override
+        public void close(ParcelFileDescriptor parcelFileDescriptor) throws IOException {
+          parcelFileDescriptor.close();
+        }
+
+        @Override
+        public Class<ParcelFileDescriptor> getDataClass() {
+          return ParcelFileDescriptor.class;
+        }
+      });
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java
deleted file mode 100644
index 9900322fe..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java
+++ /dev/null
@@ -1,201 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import android.content.Context;
-
-import com.bumptech.glide.load.data.DataFetcher;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Maintains a map of model class to factory to retrieve a {@link ModelLoaderFactory} and/or a {@link ModelLoader}
- * for a given model type.
- */
-@SuppressWarnings({ "rawtypes", "unchecked" })
-// this is a general class capable of handling any generic combination
-public class GenericLoaderFactory {
-    private final Map<Class/*T*/, Map<Class/*Y*/, ModelLoaderFactory/*T, Y*/>> modelClassToResourceFactories =
-            new HashMap<Class, Map<Class, ModelLoaderFactory>>();
-    private final Map<Class/*T*/, Map<Class/*Y*/, ModelLoader/*T, Y*/>> cachedModelLoaders =
-            new HashMap<Class, Map<Class, ModelLoader>>();
-
-    private static final ModelLoader NULL_MODEL_LOADER = new ModelLoader() {
-        @Override
-        public DataFetcher getResourceFetcher(Object model, int width, int height) {
-            throw new NoSuchMethodError("This should never be called!");
-        }
-
-        @Override
-        public String toString() {
-            return "NULL_MODEL_LOADER";
-        }
-    };
-
-    private final Context context;
-
-    public GenericLoaderFactory(Context context) {
-       this.context = context.getApplicationContext();
-    }
-
-    /**
-     * Removes and returns the registered {@link ModelLoaderFactory} for the given model and resource classes. Returns
-     * null if no such factory is registered. Clears all cached model loaders.
-     *
-     * @param modelClass The model class.
-     * @param resourceClass The resource class.
-     * @param <T> The type of the model the class.
-     * @param <Y> The type of the resource class.
-     */
-    public synchronized <T, Y> ModelLoaderFactory<T, Y> unregister(Class<T> modelClass, Class<Y> resourceClass) {
-        cachedModelLoaders.clear();
-
-        ModelLoaderFactory/*T, Y*/ result = null;
-        Map<Class/*Y*/, ModelLoaderFactory/*T, Y*/> resourceToFactories = modelClassToResourceFactories.get(modelClass);
-        if (resourceToFactories != null) {
-            result = resourceToFactories.remove(resourceClass);
-        }
-        return result;
-    }
-
-    /**
-     * Registers the given {@link ModelLoaderFactory} for the given model and resource classes and returns the previous
-     * factory registered for the given model and resource classes or null if no such factory existed. Clears all cached
-     * model loaders.
-     *
-     * @param modelClass The model class.
-     * @param resourceClass The resource class.
-     * @param factory The factory to register.
-     * @param <T> The type of the model.
-     * @param <Y> The type of the resource.
-     */
-    public synchronized <T, Y> ModelLoaderFactory<T, Y> register(Class<T> modelClass, Class<Y> resourceClass,
-            ModelLoaderFactory<T, Y> factory) {
-        cachedModelLoaders.clear();
-
-        Map<Class/*Y*/, ModelLoaderFactory/*T, Y*/> resourceToFactories = modelClassToResourceFactories.get(modelClass);
-        if (resourceToFactories == null) {
-            resourceToFactories = new HashMap<Class/*Y*/, ModelLoaderFactory/*T, Y*/>();
-            modelClassToResourceFactories.put(modelClass, resourceToFactories);
-        }
-
-        ModelLoaderFactory/*T, Y*/ previous = resourceToFactories.put(resourceClass, factory);
-
-        if (previous != null) {
-            // This factory may be being used by another model. We don't want to say it has been removed unless we
-            // know it has been removed for all models.
-            for (Map<Class/*Y*/, ModelLoaderFactory/*T, Y*/> factories : modelClassToResourceFactories.values()) {
-                if (factories.containsValue(previous)) {
-                    previous = null;
-                    break;
-                }
-            }
-        }
-
-        return previous;
-    }
-
-    /**
-     * Returns a {@link ModelLoader} for the given model and resource classes by either returning a cached
-     * {@link ModelLoader} or building a new a new {@link ModelLoader} using registered {@link ModelLoaderFactory}s.
-     * Returns null if no {@link ModelLoaderFactory} is registered for the given classes.
-     *
-     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead. Scheduled to be removed in Glide 4.0.
-     * @param modelClass The model class.
-     * @param resourceClass The resource class.
-     * @param context Unused
-     * @param <T> The type of the model.
-     * @param <Y> The type of the resource.
-     */
-    @Deprecated
-    public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass,
-            Context context) {
-        return buildModelLoader(modelClass, resourceClass);
-    }
-
-    /**
-     * Returns a {@link ModelLoader} for the given model and resource classes by either returning a cached
-     * {@link ModelLoader} or building a new a new {@link ModelLoader} using registered {@link ModelLoaderFactory}s.
-     * Returns null if no {@link ModelLoaderFactory} is registered for the given classes.
-     *
-     * @param modelClass The model class.
-     * @param resourceClass The resource class.
-     * @param <T> The type of the model.
-     * @param <Y> The type of the resource.
-     */
-    public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass) {
-        ModelLoader<T, Y> result = getCachedLoader(modelClass, resourceClass);
-        if (result != null) {
-            // We've already tried to create a model loader and can't with the currently registered set of factories,
-            // but we can't use null to demonstrate that failure because model loaders that haven't been requested
-            // yet will be null in the cache. To avoid this, we use a special signal model loader.
-            if (NULL_MODEL_LOADER.equals(result)) {
-                return null;
-            } else {
-                return result;
-            }
-        }
-
-        final ModelLoaderFactory<T, Y> factory = getFactory(modelClass, resourceClass);
-        if (factory != null) {
-            result = factory.build(context, this);
-            cacheModelLoader(modelClass, resourceClass, result);
-        } else {
-            // We can't generate a model loader for the given arguments with the currently registered set of factories.
-            cacheNullLoader(modelClass, resourceClass);
-        }
-        return result;
-    }
-
-    private <T, Y> void cacheNullLoader(Class<T> modelClass, Class<Y> resourceClass) {
-        cacheModelLoader(modelClass, resourceClass, NULL_MODEL_LOADER);
-    }
-
-    private <T, Y> void cacheModelLoader(Class<T> modelClass, Class<Y> resourceClass, ModelLoader<T, Y> modelLoader) {
-        Map<Class/*Y*/, ModelLoader/*T, Y*/> resourceToLoaders = cachedModelLoaders.get(modelClass);
-        if (resourceToLoaders == null) {
-            resourceToLoaders = new HashMap<Class/*Y*/, ModelLoader/*T, Y*/>();
-            cachedModelLoaders.put(modelClass, resourceToLoaders);
-        }
-        resourceToLoaders.put(resourceClass, modelLoader);
-    }
-
-    private <T, Y> ModelLoader<T, Y> getCachedLoader(Class<T> modelClass, Class<Y> resourceClass) {
-        Map<Class/*Y*/, ModelLoader/*T, Y*/> resourceToLoaders = cachedModelLoaders.get(modelClass);
-        ModelLoader/*T, Y*/ result = null;
-        if (resourceToLoaders != null) {
-            result = resourceToLoaders.get(resourceClass);
-        }
-
-        return result;
-    }
-
-    private <T, Y> ModelLoaderFactory<T, Y> getFactory(Class<T> modelClass, Class<Y> resourceClass) {
-        Map<Class/*Y*/, ModelLoaderFactory/*T, Y*/> resourceToFactories = modelClassToResourceFactories.get(modelClass);
-        ModelLoaderFactory/*T, Y*/ result = null;
-        if (resourceToFactories != null) {
-            result = resourceToFactories.get(resourceClass);
-        }
-
-        if (result == null) {
-            for (Class<? super T> registeredModelClass : modelClassToResourceFactories.keySet()) {
-                // This accounts for model subclasses, our map only works for exact matches. We should however still
-                // match a subclass of a model with a factory for a super class of that model if if there isn't a
-                // factory for that particular subclass. Uris are a great example of when this happens, most uris
-                // are actually subclasses for Uri, but we'd generally rather load them all with the same factory rather
-                // than trying to register for each subclass individually.
-                if (registeredModelClass.isAssignableFrom(modelClass)) {
-                    Map<Class/*Y*/, ModelLoaderFactory/*T, Y*/> currentResourceToFactories =
-                            modelClassToResourceFactories.get(registeredModelClass);
-                    if (currentResourceToFactories != null) {
-                        result = currentResourceToFactories.get(resourceClass);
-                        if (result != null) {
-                            break;
-                        }
-                    }
-                }
-            }
-        }
-
-        return result;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 3fb16f746..91cd2ebb1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -1,89 +1,148 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.util.Preconditions;
+
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.security.MessageDigest;
+import java.util.Map;
 
 /**
- * A wrapper for strings representing http/https URLs responsible for ensuring URLs are properly escaped and avoiding
- * unnecessary URL instantiations for loaders that require only string urls rather than URL objects.
+ * A wrapper for strings representing http/https URLs responsible for ensuring URLs are properly
+ * escaped and avoiding unnecessary URL instantiations for loaders that require only string urls
+ * rather than URL objects.
+ *
+ * <p>  Users wishing to replace the class for handling URLs must register a factory using
+ * GlideUrl. </p>
  *
- * <p>
- *  Users wishing to replace the class for handling URLs must register a factory using GlideUrl.
- * </p>
+ * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string
+ * URL, call {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache
+ * key, call {@link #getCacheKey()}. </p>
  *
- * <p>
- *     To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string URL, call
- *     {@link #toURL()} and then {@link java.net.URL#toString()}.
- * </p>
+ * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for
+ * convenience. </p>
  */
-public class GlideUrl {
-    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
+public class GlideUrl implements Key {
+  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
+  private final Headers headers;
+  @Nullable private final URL url;
+  @Nullable private final String stringUrl;
 
-    private final URL url;
-    private String stringUrl;
+  @Nullable private String safeStringUrl;
+  @Nullable private URL safeUrl;
+  @Nullable private volatile byte[] cacheKeyBytes;
 
-    private URL safeUrl;
+  public GlideUrl(URL url) {
+    this(url, Headers.DEFAULT);
+  }
 
-    public GlideUrl(URL url) {
-        if (url == null) {
-            throw new IllegalArgumentException("URL must not be null!");
-        }
-        this.url = url;
-        stringUrl = null;
-    }
+  public GlideUrl(String url) {
+    this(url, Headers.DEFAULT);
+  }
 
-    public GlideUrl(String url) {
-        if (TextUtils.isEmpty(url)) {
-            throw new IllegalArgumentException("String url must not be empty or null: " + url);
-        }
-        this.stringUrl = url;
-        this.url = null;
-    }
+  public GlideUrl(URL url, Headers headers) {
+    this.url = Preconditions.checkNotNull(url);
+    stringUrl = null;
+    this.headers = Preconditions.checkNotNull(headers);
+  }
 
+  public GlideUrl(String url, Headers headers) {
+    this.url = null;
+    this.stringUrl = Preconditions.checkNotEmpty(url);
+    this.headers = Preconditions.checkNotNull(headers);
+  }
 
-    public URL toURL() throws MalformedURLException {
-        return getSafeUrl();
-    }
+  public URL toURL() throws MalformedURLException {
+    return getSafeUrl();
+  }
 
-    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
-    // using it would require both decoding and encoding each string which is more complicated, slower and generates
-    // more objects than the solution below. See also issue #133.
-    private URL getSafeUrl() throws MalformedURLException {
-        if (safeUrl != null) {
-            return safeUrl;
-        }
-        String unsafe = toString();
-        String safe = Uri.encode(unsafe, ALLOWED_URI_CHARS);
-
-        safeUrl = new URL(safe);
-        return safeUrl;
+  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
+  // using URI would work, using it would require both decoding and encoding each string which is
+  // more complicated, slower and generates more objects than the solution below. See also issue
+  // #133.
+  private URL getSafeUrl() throws MalformedURLException {
+    if (safeUrl == null) {
+      safeUrl = new URL(getSafeStringUrl());
     }
+    return safeUrl;
+  }
 
-    @Override
-    public String toString() {
-        if (TextUtils.isEmpty(stringUrl)) {
-            stringUrl = url.toString();
-        }
-        return stringUrl;
+  /**
+   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
+   *
+   * @see #toURL()
+   * @see #getCacheKey()
+   */
+  public String toStringUrl() {
+    return getSafeStringUrl();
+  }
+
+  private String getSafeStringUrl() {
+    if (TextUtils.isEmpty(safeStringUrl)) {
+      String unsafeStringUrl = stringUrl;
+      if (TextUtils.isEmpty(unsafeStringUrl)) {
+        unsafeStringUrl = url.toString();
+      }
+      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
     }
+    return safeStringUrl;
+  }
+
+  /**
+   * Returns a non-null {@link Map} containing headers.
+   */
+  public Map<String, String> getHeaders() {
+    return headers.getHeaders();
+  }
+
+  /**
+   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
+   *
+   * <p> This method does not include headers. </p>
+   *
+   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
+   * input. </p>
+   */
+  public String getCacheKey() {
+    return stringUrl != null ? stringUrl : url.toString();
+  }
 
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
+  @Override
+  public String toString() {
+    return getCacheKey();
+  }
 
-        return toString().equals(o.toString());
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(getCacheKeyBytes());
+  }
+
+  private byte[] getCacheKeyBytes() {
+    if (cacheKeyBytes == null) {
+      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
     }
+    return cacheKeyBytes;
+  }
 
-    @Override
-    public int hashCode() {
-        return toString().hashCode();
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof GlideUrl) {
+      GlideUrl other = (GlideUrl) o;
+      return getCacheKey().equals(other.getCacheKey())
+          && headers.equals(other.headers);
     }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hashCode = getCacheKey().hashCode();
+    hashCode = 31 * hashCode + headers.hashCode();
+    return hashCode;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Headers.java b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
new file mode 100644
index 000000000..f55d16f4e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.model;
+
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * An interface for a wrapper for a set of headers to be included in a Glide request.
+ *
+ * <p> Implementations must implement equals() and hashcode(). </p>
+ */
+public interface Headers {
+
+  /**
+   * An empty Headers object that can be used if users don't want to provide headers.
+   *
+   * @deprecated Use {@link #DEFAULT} instead.
+   */
+  @Deprecated
+  Headers NONE = new Headers() {
+      @Override
+      public Map<String, String> getHeaders() {
+          return Collections.emptyMap();
+      }
+  };
+
+  /**
+   * A Headers object containing reasonable defaults that should be used when users don't want
+   * to provide their own headers.
+   */
+  Headers DEFAULT = new LazyHeaders.Builder().build();
+
+  /**
+   * Returns a non-null map containing a set of headers to apply to an http request.
+   */
+  Map<String, String> getHeaders();
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java
deleted file mode 100644
index 3d057baca..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java
+++ /dev/null
@@ -1,127 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import android.os.ParcelFileDescriptor;
-import android.util.Log;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.data.DataFetcher;
-
-import java.io.InputStream;
-
-/**
- * A wrapper model loader that provides both an {@link java.io.InputStream} and a
- * {@link android.os.ParcelFileDescriptor} for a given model type by wrapping an
- * {@link com.bumptech.glide.load.model.ModelLoader} for {@link java.io.InputStream}s for the given model type and an
- * {@link com.bumptech.glide.load.model.ModelLoader} for {@link android.os.ParcelFileDescriptor} for the given model
- * type.
- *
- * @param <A> The model type.
- */
-public class ImageVideoModelLoader<A> implements ModelLoader<A, ImageVideoWrapper> {
-    private static final String TAG = "IVML";
-
-    private final ModelLoader<A, InputStream> streamLoader;
-    private final ModelLoader<A, ParcelFileDescriptor> fileDescriptorLoader;
-
-    public ImageVideoModelLoader(ModelLoader<A, InputStream> streamLoader,
-            ModelLoader<A, ParcelFileDescriptor> fileDescriptorLoader) {
-        if (streamLoader == null && fileDescriptorLoader == null) {
-            throw new NullPointerException("At least one of streamLoader and fileDescriptorLoader must be non null");
-        }
-        this.streamLoader = streamLoader;
-        this.fileDescriptorLoader = fileDescriptorLoader;
-    }
-
-    @Override
-    public DataFetcher<ImageVideoWrapper> getResourceFetcher(A model, int width, int height) {
-        DataFetcher<InputStream> streamFetcher = null;
-        if (streamLoader != null) {
-            streamFetcher = streamLoader.getResourceFetcher(model, width, height);
-        }
-        DataFetcher<ParcelFileDescriptor> fileDescriptorFetcher = null;
-        if (fileDescriptorLoader != null) {
-            fileDescriptorFetcher = fileDescriptorLoader.getResourceFetcher(model, width, height);
-        }
-
-        if (streamFetcher != null || fileDescriptorFetcher != null) {
-            return new ImageVideoFetcher(streamFetcher, fileDescriptorFetcher);
-        } else {
-            return null;
-        }
-    }
-
-    static class ImageVideoFetcher implements DataFetcher<ImageVideoWrapper> {
-        private final DataFetcher<InputStream> streamFetcher;
-        private final DataFetcher<ParcelFileDescriptor> fileDescriptorFetcher;
-
-        public ImageVideoFetcher(DataFetcher<InputStream> streamFetcher,
-                DataFetcher<ParcelFileDescriptor> fileDescriptorFetcher) {
-            this.streamFetcher = streamFetcher;
-            this.fileDescriptorFetcher = fileDescriptorFetcher;
-        }
-
-        @SuppressWarnings("resource")
-        // @see ModelLoader.loadData
-        @Override
-        public ImageVideoWrapper loadData(Priority priority) throws Exception {
-            InputStream is = null;
-            if (streamFetcher != null) {
-                try {
-                    is = streamFetcher.loadData(priority);
-                } catch (Exception e) {
-                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                        Log.v(TAG, "Exception fetching input stream, trying ParcelFileDescriptor", e);
-                    }
-                    if (fileDescriptorFetcher == null) {
-                        throw e;
-                    }
-                }
-            }
-            ParcelFileDescriptor fileDescriptor = null;
-            if (fileDescriptorFetcher != null) {
-                try {
-                    fileDescriptor = fileDescriptorFetcher.loadData(priority);
-                } catch (Exception e) {
-                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                        Log.v(TAG, "Exception fetching ParcelFileDescriptor", e);
-                    }
-                    if (is == null) {
-                        throw e;
-                    }
-                }
-            }
-            return new ImageVideoWrapper(is, fileDescriptor);
-        }
-
-        @Override
-        public void cleanup() {
-            //TODO: what if this throws?
-            if (streamFetcher != null) {
-                streamFetcher.cleanup();
-            }
-            if (fileDescriptorFetcher != null) {
-                fileDescriptorFetcher.cleanup();
-            }
-        }
-
-        @Override
-        public String getId() {
-            // Both the stream fetcher and the file descriptor fetcher should return the same id.
-            if (streamFetcher != null) {
-                return streamFetcher.getId();
-            } else {
-                return fileDescriptorFetcher.getId();
-            }
-        }
-
-        @Override
-        public void cancel() {
-            if (streamFetcher != null) {
-                streamFetcher.cancel();
-            }
-            if (fileDescriptorFetcher != null) {
-                fileDescriptorFetcher.cancel();
-            }
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapper.java b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapper.java
deleted file mode 100644
index 85ee4d38e..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapper.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import android.os.ParcelFileDescriptor;
-
-import java.io.InputStream;
-
-/**
- * A simple wrapper that wraps an {@link java.io.InputStream} and/or an {@link android.os.ParcelFileDescriptor}.
- */
-public class ImageVideoWrapper {
-    private final InputStream streamData;
-    private final ParcelFileDescriptor fileDescriptor;
-
-    public ImageVideoWrapper(InputStream streamData, ParcelFileDescriptor fileDescriptor) {
-        this.streamData = streamData;
-        this.fileDescriptor = fileDescriptor;
-    }
-
-    public InputStream getStream() {
-        return streamData;
-    }
-
-    public ParcelFileDescriptor getFileDescriptor() {
-        return fileDescriptor;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java
deleted file mode 100644
index 2d9c59a36..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.Encoder;
-
-import java.io.InputStream;
-import java.io.OutputStream;
-
-/**
- * A source encoder that writes a {@link com.bumptech.glide.load.model.ImageVideoWrapper} to disk by preferentially
- * writing data from the wrapper's {@link java.io.InputStream} and falling back to the wrapper's
- * {@link android.os.ParcelFileDescriptor} if the {@link java.io.InputStream} isn't available.
- */
-public class ImageVideoWrapperEncoder implements Encoder<ImageVideoWrapper> {
-    private final Encoder<InputStream> streamEncoder;
-    private final Encoder<ParcelFileDescriptor> fileDescriptorEncoder;
-    private String id;
-
-    public ImageVideoWrapperEncoder(Encoder<InputStream> streamEncoder,
-            Encoder<ParcelFileDescriptor> fileDescriptorEncoder) {
-        this.streamEncoder = streamEncoder;
-        this.fileDescriptorEncoder = fileDescriptorEncoder;
-    }
-
-    @Override
-    public boolean encode(ImageVideoWrapper data, OutputStream os) {
-        if (data.getStream() != null) {
-            return streamEncoder.encode(data.getStream(), os);
-        } else {
-            return fileDescriptorEncoder.encode(data.getFileDescriptor(), os);
-        }
-    }
-
-    @Override
-    public String getId() {
-        if (id == null) {
-            id = streamEncoder.getId() + fileDescriptorEncoder.getId();
-        }
-        return id;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
new file mode 100644
index 000000000..78f292430
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -0,0 +1,13 @@
+package com.bumptech.glide.load.model;
+
+/**
+ * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
+ * example) to be generated in the background during the first fetch.
+ *
+ * <p> Implementations should implement equals() and hashcode() </p> .
+ */
+public interface LazyHeaderFactory {
+
+    String buildHeader();
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
new file mode 100644
index 000000000..915185fbd
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -0,0 +1,265 @@
+package com.bumptech.glide.load.model;
+
+import android.text.TextUtils;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A wrapper class for a set of headers to be included in a Glide request, allowing headers to be
+ * constructed lazily.
+ *
+ * <p> Ideally headers are constructed once and then re-used for multiple loads, rather then being
+ * constructed individually for each load. </p>
+ *
+ * <p> This class is thread safe. </p>
+ */
+public final class LazyHeaders implements Headers {
+  private final Map<String, List<LazyHeaderFactory>> headers;
+  private volatile Map<String, String> combinedHeaders;
+
+  LazyHeaders(Map<String, List<LazyHeaderFactory>> headers) {
+    this.headers = Collections.unmodifiableMap(headers);
+  }
+
+  @Override
+  public Map<String, String> getHeaders() {
+    if (combinedHeaders == null) {
+      synchronized (this) {
+        if (combinedHeaders == null) {
+          this.combinedHeaders = Collections.unmodifiableMap(generateHeaders());
+        }
+      }
+    }
+
+    return combinedHeaders;
+  }
+
+  private Map<String, String> generateHeaders() {
+    Map<String, String> combinedHeaders = new HashMap<>();
+
+    for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
+      StringBuilder sb = new StringBuilder();
+      List<LazyHeaderFactory> factories = entry.getValue();
+      int size = factories.size();
+      for (int i = 0; i < size; i++) {
+        LazyHeaderFactory factory = factories.get(i);
+        sb.append(factory.buildHeader());
+        if (i != factories.size() - 1) {
+          sb.append(',');
+        }
+      }
+      combinedHeaders.put(entry.getKey(), sb.toString());
+    }
+
+    return combinedHeaders;
+  }
+
+  @Override
+  public String toString() {
+    return "LazyHeaders{"
+        + "headers=" + headers
+        + '}';
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof LazyHeaders) {
+      LazyHeaders other = (LazyHeaders) o;
+      return headers.equals(other.headers);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return headers.hashCode();
+  }
+
+  /**
+   * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
+   * key* lazily on a background thread.
+   *
+   * <p> This class is not thread safe. </p>
+   *
+   * <p> This class may include default values for User-Agent and Accept-Encoding headers. These
+   * will be replaced by calls to either {@link #setHeader(String, LazyHeaderFactory)} or
+   * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}
+   * would usually append an additional value. </p>
+   */
+   // PMD doesn't like the necessary static block to initialize DEFAULT_HEADERS.
+  @SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
+  public static final class Builder {
+    private static final String USER_AGENT_HEADER = "User-Agent";
+    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
+    private static final String ENCODING_HEADER = "Accept-Encoding";
+    private static final String DEFAULT_ENCODING = "identity";
+    private static final Map<String, List<LazyHeaderFactory>> DEFAULT_HEADERS;
+
+    // Set Accept-Encoding header to do our best to avoid gzip since it's both inefficient for
+    // images and also makes it more difficult for us to detect and prevent partial content
+    // rendering. See #440.
+    static {
+      Map<String, List<LazyHeaderFactory>> temp
+          = new HashMap<>(2);
+      if (!TextUtils.isEmpty(DEFAULT_USER_AGENT)) {
+        temp.put(USER_AGENT_HEADER,
+            Collections.<LazyHeaderFactory>singletonList(
+                new StringHeaderFactory(DEFAULT_USER_AGENT)));
+      }
+      temp.put(ENCODING_HEADER,
+          Collections.<LazyHeaderFactory>singletonList(
+              new StringHeaderFactory(DEFAULT_ENCODING)));
+      DEFAULT_HEADERS = Collections.unmodifiableMap(temp);
+    }
+
+    private boolean copyOnModify = true;
+    private boolean isEncodingDefault = true;
+    private Map<String, List<LazyHeaderFactory>> headers = DEFAULT_HEADERS;
+    private boolean isUserAgentDefault = headers.containsKey(DEFAULT_USER_AGENT);
+
+    /**
+     * Adds a value for the given header and returns this builder.
+     *
+     * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+     * (ie an oauth token). </p>
+     *
+     * @see #addHeader(String, LazyHeaderFactory)
+
+     */
+    public Builder addHeader(String key, String value) {
+      return addHeader(key, new StringHeaderFactory(value));
+    }
+
+    /**
+     * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
+     * key lazily on a background thread.
+     *
+     * <p> Headers may have multiple values whose order is defined by the order in which
+     * this method is called. </p>
+     *
+     * <p> This class does not prevent you from adding the same value to a given key multiple
+     * times </p>
+     */
+    public Builder addHeader(String key, LazyHeaderFactory factory) {
+      if ((isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key))
+          || (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key))) {
+        return setHeader(key, factory);
+      }
+
+      copyIfNecessary();
+      getFactories(key).add(factory);
+      return this;
+    }
+
+    /**
+     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key
+     * with the given {@link LazyHeaderFactory}.
+     *
+     * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
+     *
+     * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+     * (ie an oauth token). </p>
+     */
+    public Builder setHeader(String key, String value) {
+      return setHeader(key, value == null ? null : new StringHeaderFactory(value));
+    }
+
+    /**
+     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key
+     * with the given {@link LazyHeaderFactory}.
+     *
+     * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
+     */
+    public Builder setHeader(String key, LazyHeaderFactory factory) {
+      copyIfNecessary();
+      if (factory == null) {
+        headers.remove(key);
+      } else {
+        List<LazyHeaderFactory> factories = getFactories(key);
+        factories.clear();
+        factories.add(factory);
+      }
+
+      if (isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key)) {
+        isEncodingDefault = false;
+      }
+      if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
+        isUserAgentDefault = false;
+      }
+
+      return this;
+    }
+
+    private List<LazyHeaderFactory> getFactories(String key) {
+      List<LazyHeaderFactory> factories = headers.get(key);
+      if (factories == null) {
+        factories = new ArrayList<>();
+        headers.put(key, factories);
+      }
+      return factories;
+    }
+
+    private void copyIfNecessary() {
+      if (copyOnModify) {
+        copyOnModify = false;
+        headers = copyHeaders();
+      }
+    }
+
+    /**
+     * Returns a new immutable {@link LazyHeaders} object.
+     */
+    public LazyHeaders build() {
+      copyOnModify = true;
+      return new LazyHeaders(headers);
+    }
+
+    private Map<String, List<LazyHeaderFactory>> copyHeaders() {
+      Map<String, List<LazyHeaderFactory>> result =
+          new HashMap<>(headers.size());
+      for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
+        result.put(entry.getKey(), new ArrayList<>(entry.getValue()));
+      }
+      return result;
+    }
+  }
+
+  static final class StringHeaderFactory implements LazyHeaderFactory {
+
+    private final String value;
+
+    StringHeaderFactory(String value) {
+      this.value = value;
+    }
+
+    @Override
+    public String buildHeader() {
+      return value;
+    }
+
+    @Override
+    public String toString() {
+      return "StringHeaderFactory{"
+          + "value='" + value + '\''
+          + '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof StringHeaderFactory) {
+        StringHeaderFactory other = (StringHeaderFactory) o;
+        return value.equals(other.value);
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return value.hashCode();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
new file mode 100644
index 000000000..ac81aa270
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -0,0 +1,112 @@
+package com.bumptech.glide.load.model;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.MediaStore;
+import android.text.TextUtils;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
+import com.bumptech.glide.signature.ObjectKey;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+
+/**
+ * Loads the file path for {@link MediaStore} owned {@link Uri uris}.
+ */
+public final class MediaStoreFileLoader implements ModelLoader<Uri, File>  {
+
+  private final Context context;
+
+  MediaStoreFileLoader(Context context) {
+    this.context = context;
+  }
+
+  @Override
+  public LoadData<File> buildLoadData(Uri uri, int width, int height, Options options) {
+    return new LoadData<>(new ObjectKey(uri), new FilePathFetcher(context, uri));
+  }
+
+  @Override
+  public boolean handles(Uri uri) {
+    return MediaStoreUtil.isMediaStoreUri(uri);
+  }
+
+  private static class FilePathFetcher implements DataFetcher<File> {
+    private static final String[] PROJECTION = new String[] {
+        MediaStore.MediaColumns.DATA,
+    };
+
+    private final Context context;
+    private final Uri uri;
+
+    FilePathFetcher(Context context, Uri uri) {
+      this.context = context;
+      this.uri = uri;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super File> callback) {
+      Cursor cursor = context.getContentResolver().query(uri, PROJECTION, null /*selection*/,
+          null /*selectionArgs*/, null /*sortOrder*/);
+
+      String filePath = null;
+      if (cursor != null) {
+        try {
+          if (cursor.moveToFirst()) {
+            filePath = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA));
+          }
+        } finally {
+          cursor.close();
+        }
+      }
+
+      if (TextUtils.isEmpty(filePath)) {
+        callback.onLoadFailed(new FileNotFoundException("Failed to find file path for: " + uri));
+      } else {
+        callback.onDataReady(new File(filePath));
+      }
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @Override
+    public Class<File> getDataClass() {
+      return File.class;
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+
+  /**
+   * {@link ModelLoaderFactory} for {@link MediaStoreFileLoader}s.
+   */
+  public static final class Factory implements ModelLoaderFactory<Uri, File> {
+
+    @Override
+    public ModelLoader<Uri, File> build(Context context, MultiModelLoaderFactory multiFactory) {
+      return new MediaStoreFileLoader(context);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index 55c0de0c7..0a4ce4c06 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -1,111 +1,127 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
+
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
 
 import java.util.Queue;
 
 /**
- * A simple cache that can be used by {@link ModelLoader} and {@link ModelLoaderFactory} to cache some data for a given
- * model, width and height. For a loader that takes a model and returns a url, the cache could be used to safely memoize
- * url creation based on the width and height of the view.
+ * A simple cache that can be used by {@link ModelLoader} and {@link ModelLoaderFactory} to cache
+ * some data for a given model, width and height. For a loader that takes a model and returns a url,
+ * the cache could be used to safely memoize url creation based on the width and height of the
+ * view.
  *
  * @param <A> Some Model type that implements {@link #equals} and {@link #hashCode}.
  * @param <B> Some useful type that may be expensive to create (URL, file path, etc).
  */
 public class ModelCache<A, B> {
-    private static final int DEFAULT_SIZE = 250;
+  private static final int DEFAULT_SIZE = 250;
+
+  private final LruCache<ModelKey<A>, B> cache;
+
+  public ModelCache() {
+    this(DEFAULT_SIZE);
+  }
 
-    private final LruCache<ModelKey<A>, B> cache;
+  public ModelCache(int size) {
+    cache = new LruCache<ModelKey<A>, B>(size) {
+      @Override
+      protected void onItemEvicted(ModelKey<A> key, B item) {
+        key.release();
+      }
+    };
+  }
+
+  /**
+   * Get a value.
+   *
+   * @param model  The model.
+   * @param width  The width in pixels of the view the image is being loaded into.
+   * @param height The height in pixels of the view the image is being loaded into.
+   * @return The cached result, or null.
+   */
+  @Nullable
+  public B get(A model, int width, int height) {
+    ModelKey<A> key = ModelKey.get(model, width, height);
+    B result = cache.get(key);
+    key.release();
+    return result;
+  }
+
+  /**
+   * Add a value.
+   *
+   * @param model  The model.
+   * @param width  The width in pixels of the view the image is being loaded into.
+   * @param height The height in pixels of the view the image is being loaded into.
+   * @param value  The value to store.
+   */
+  public void put(A model, int width, int height, B value) {
+    ModelKey<A> key = ModelKey.get(model, width, height);
+    cache.put(key, value);
+  }
+
+  /**
+   * Removes all entries from the cache.
+   */
+  public void clear() {
+    cache.clearMemory();
+  }
+
+  // Visible for testing.
+  static final class ModelKey<A> {
+    private static final Queue<ModelKey<?>> KEY_QUEUE = Util.createQueue(0);
+
+    private int height;
+    private int width;
+    private A model;
+
+    @SuppressWarnings("unchecked")
+    static <A> ModelKey<A> get(A model, int width, int height) {
+      ModelKey<A> modelKey;
+      synchronized (KEY_QUEUE) {
+        modelKey = (ModelKey<A>) KEY_QUEUE.poll();
+      }
+      if (modelKey == null) {
+        modelKey = new ModelKey<>();
+      }
+
+      modelKey.init(model, width, height);
+      return modelKey;
+    }
 
-    public ModelCache() {
-        this(DEFAULT_SIZE);
+    private ModelKey() {
     }
 
-    public ModelCache(int size) {
-        cache = new LruCache<ModelKey<A>, B>(size) {
-            @Override
-            protected void onItemEvicted(ModelKey<A> key, B item) {
-                key.release();
-            }
-        };
+    private void init(A model, int width, int height) {
+      this.model = model;
+      this.width = width;
+      this.height = height;
     }
 
-    /**
-     * Get a value.
-     *
-     * @param model The model.
-     * @param width The width in pixels of the view the image is being loaded into.
-     * @param height The height in pixels of the view the image is being loaded into.
-     *
-     * @return The cached result, or null.
-     */
-    public B get(A model, int width, int height) {
-        ModelKey<A> key = ModelKey.get(model, width, height);
-        B result = cache.get(key);
-        key.release();
-        return result;
+    public void release() {
+      synchronized (KEY_QUEUE) {
+        KEY_QUEUE.offer(this);
+      }
     }
 
-    /**
-     * Add a value.
-     *
-     * @param model The model.
-     * @param width The width in pixels of the view the image is being loaded into.
-     * @param height The height in pixels of the view the image is being loaded into.
-     * @param value The value to store.
-     */
-    public void put(A model, int width, int height, B value) {
-        ModelKey<A> key = ModelKey.get(model, width, height);
-        cache.put(key, value);
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof ModelKey) {
+        ModelKey other = (ModelKey) o;
+        return width == other.width && height == other.height && model.equals(other.model);
+      }
+      return false;
     }
 
-    // Visible for testing.
-    static final class ModelKey<A> {
-        private static final Queue<ModelKey<?>> KEY_QUEUE = Util.createQueue(0);
-
-        private int height;
-        private int width;
-        private A model;
-
-        static <A> ModelKey<A> get(A model, int width, int height) {
-            @SuppressWarnings("unchecked")
-            ModelKey<A> modelKey = (ModelKey<A>) KEY_QUEUE.poll();
-            if (modelKey == null) {
-                modelKey = new ModelKey<A>();
-            }
-
-            modelKey.init(model, width, height);
-            return modelKey;
-        }
-
-        private ModelKey() {  }
-
-        private void init(A model, int width, int height) {
-            this.model = model;
-            this.width = width;
-            this.height = height;
-        }
-
-        public void release() {
-            KEY_QUEUE.offer(this);
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof ModelKey) {
-                ModelKey other = (ModelKey) o;
-                return width == other.width && height == other.height && model.equals(other.model);
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = height;
-            result = 31 * result + width;
-            result = 31 * result + model.hashCode();
-            return result;
-        }
+    @Override
+    public int hashCode() {
+      int result = height;
+      result = 31 * result + width;
+      result = 31 * result + model.hashCode();
+      return result;
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index 164f1d723..c64c6d2bd 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -1,46 +1,95 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.Collections;
+import java.util.List;
 
 /**
- * A factory interface for translating an arbitrarily complex data model into a concrete data type that can be used
- * by an {@link DataFetcher} to obtain the data for a resource represented by the model.
+ * A factory interface for translating an arbitrarily complex data model into a concrete data type
+ * that can be used by an {@link DataFetcher} to obtain the data for a resource represented by the
+ * model.
  *
- * <p>
- *  This interface has two objectives:
- *   1. To translate a specific model into a data type that can be decoded into a resource.
+ * <p> This interface has two objectives: 1. To translate a specific model into a data type that can
+ * be decoded into a resource.
  *
- *   2. To allow a model to be combined with the dimensions of the view to fetch a resource of a specific size.
+ * 2. To allow a model to be combined with the dimensions of the view to fetch a resource of a
+ * specific size.
  *
- *      This not only avoids having to duplicate dimensions in xml and in your code in order to determine the size of a
- *      view on devices with different densities, but also allows you to use layout weights or otherwise
- *      programatically set the dimensions of the view without forcing you to fetch a generic resource size.
+ * This not only avoids having to duplicate dimensions in xml and in your code in order to determine
+ * the size of a view on devices with different densities, but also allows you to use layout weights
+ * or otherwise programatically put the dimensions of the view without forcing you to fetch a
+ * generic resource size.
  *
- *      The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower your memory
- *      footprint per resource.
- *</p>
+ * The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower
+ * your memory footprint per resource. </p>
  *
- * @param <T> The type of the model.
- * @param <Y> The type of the data that can be used by a {@link com.bumptech.glide.load.ResourceDecoder} to decode a
- *           resource.
+ * @param <Model> The type of the model.
+ * @param <Data>  The type of the data that can be used by a
+ * {@link com.bumptech.glide.load.ResourceDecoder} to decode a resource.
  */
-public interface ModelLoader<T, Y> {
-
-    /**
-     * Obtains an {@link DataFetcher} that can fetch the data required to decode the resource represented by this model.
-     * The {@link DataFetcher} will not be used if the resource is already cached.
-     *
-     * <p>
-     *     Note - If no valid data fetcher can be returned (for example if a model has a null URL), then it is
-     *     acceptable to return a null data fetcher from this method. Doing so will be treated any other failure or
-     *     exception during the load process.
-     * </p>
-     *
-     * @param model The model representing the resource.
-     * @param width The width in pixels of the view or target the resource will be loaded into
-     * @param height The height in pixels of the view or target the resource will be loaded into
-     * @return A {@link DataFetcher} that can obtain the data the resource can be decoded from if the resource is not
-     * cached, or null if no valid {@link com.bumptech.glide.load.data.DataFetcher} could be constructed.
-     */
-    DataFetcher<Y> getResourceFetcher(T model, int width, int height);
+public interface ModelLoader<Model, Data> {
+
+  /**
+   * Contains a set of {@link com.bumptech.glide.load.Key Keys} identifying the source of the load,
+   * alternate cache keys pointing to equivalent data, and a
+   * {@link com.bumptech.glide.load.data.DataFetcher} that can be used to fetch data not found in
+   * cache.
+   *
+   * @param <Data> The type of data that well be loaded.
+   */
+  class LoadData<Data> {
+    public final Key sourceKey;
+    public final List<Key> alternateKeys;
+    public final DataFetcher<Data> fetcher;
+
+    public LoadData(Key sourceKey, DataFetcher<Data> fetcher) {
+      this(sourceKey, Collections.<Key>emptyList(), fetcher);
+    }
+
+    public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetcher) {
+      this.sourceKey = Preconditions.checkNotNull(sourceKey);
+      this.alternateKeys = Preconditions.checkNotNull(alternateKeys);
+      this.fetcher = Preconditions.checkNotNull(fetcher);
+    }
+  }
+
+  /**
+   * Returns a {@link com.bumptech.glide.load.model.ModelLoader.LoadData} containing a
+   * {@link com.bumptech.glide.load.data.DataFetcher} required to decode the resource
+   * represented by this model, as well as a set of {@link com.bumptech.glide.load.Key Keys} that
+   * identify the data loaded by the {@link com.bumptech.glide.load.data.DataFetcher} as well as an
+   * optional list of alternate keys from which equivalent data can be loaded. The
+   * {@link DataFetcher} will not be used if the resource is already cached.
+   *
+   * <p> Note - If no valid data fetcher can be returned (for example if a model has a null URL),
+   * then it is acceptable to return a null data fetcher from this method. </p>
+   *
+   * @param model  The model representing the resource.
+   * @param width  The width in pixels of the view or target the resource will be loaded into, or
+   *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that
+   *               the resource should be loaded at its original width.
+   * @param height The height in pixels of the view or target the resource will be loaded into, or
+   *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that
+   *               the resource should be loaded at its original height.
+   */
+  @Nullable
+  LoadData<Data> buildLoadData(Model model, int width, int height, Options options);
+
+  /**
+   * Returns true if the given model is a of a recognized type that this loader can probably load.
+   *
+   * <p> For example, you may want multiple Uri -> InputStream loaders. One might handle media
+   * store Uris, another might handle asset Uris, and a third might handle file Uris etc. </p>
+   *
+   * <p> This method is generally expected to do no I/O and complete quickly, so best effort
+   * results are acceptable. {@link ModelLoader ModelLoaders} that return true from this method may
+   * return {@code null} from {@link #buildLoadData(Object, int, int, Options)} </p>
+   */
+  boolean handles(Model model);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index 10f3a333f..c3813f9ad 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -3,29 +3,31 @@
 import android.content.Context;
 
 /**
- * An interface for creating a {@link ModelLoader} for a given model type. Will be retained statically so should not
- * retain {@link Context} or any other objects that cannot be retained for the life of the application. ModelLoaders
- * will not be retained statically so it is safe for any ModelLoader built by this factory to retain a reference to a
- * {@link Context}.
+ * An interface for creating a {@link ModelLoader} for a given model type. Will be retained
+ * statically so should not retain {@link Context} or any other objects that cannot be retained for
+ * the life of the application. ModelLoaders will not be retained statically so it is safe for any
+ * ModelLoader built by this factory to retain a reference to a {@link Context}.
  *
- * @param <T> The type of the model the {@link com.bumptech.glide.load.model.ModelLoader}s built by this factory
- *           can handle
- * @param <Y> The type of data the {@link com.bumptech.glide.load.model.ModelLoader}s built by this factory can load.
+ * @param <T> The type of the model the {@link com.bumptech.glide.load.model.ModelLoader}s built by
+ *            this factory can handle
+ * @param <Y> The type of data the {@link com.bumptech.glide.load.model.ModelLoader}s built by this
+ *            factory can load.
  */
 public interface ModelLoaderFactory<T, Y> {
 
-    /**
-     * Build a concrete ModelLoader for this model type.
-     *
-     * @param context A context that cannot be retained by the factory but can be retained by the {@link ModelLoader}
-     * @param factories A map of classes to factories that can be used to construct additional {@link ModelLoader}s that
-     *                  this factory's {@link ModelLoader} may depend on
-     * @return A new {@link ModelLoader}
-     */
-    ModelLoader<T, Y> build(Context context, GenericLoaderFactory factories);
+  /**
+   * Build a concrete ModelLoader for this model type.
+   *
+   * @param context      A context that cannot be retained by the factory but can be retained by the
+   *                     {@link ModelLoader}
+   * @param multiFactory A map of classes to factories that can be used to construct additional
+   *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
+   * @return A new {@link ModelLoader}
+   */
+  ModelLoader<T, Y> build(Context context, MultiModelLoaderFactory multiFactory);
 
-    /**
-     * A lifecycle method that will be called when this factory is about to replaced.
-     */
-    void teardown();
+  /**
+   * A lifecycle method that will be called when this factory is about to replaced.
+   */
+  void teardown();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
new file mode 100644
index 000000000..bf3ffbab4
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -0,0 +1,123 @@
+package com.bumptech.glide.load.model;
+
+import android.content.Context;
+import android.support.v4.util.Pools.Pool;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Maintains an ordered put of {@link ModelLoader}s and the model and data types they handle in
+ * order from highest priority to lowest.
+ */
+public class ModelLoaderRegistry {
+
+  private final MultiModelLoaderFactory multiModelLoaderFactory;
+  private final ModelLoaderCache cache = new ModelLoaderCache();
+
+  public ModelLoaderRegistry(Context context, Pool<List<Exception>> exceptionListPool) {
+    this(new MultiModelLoaderFactory(context, exceptionListPool));
+  }
+
+  // Visible for testing.
+  ModelLoaderRegistry(MultiModelLoaderFactory multiModelLoaderFactory) {
+    this.multiModelLoaderFactory = multiModelLoaderFactory;
+  }
+
+  public synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory) {
+    multiModelLoaderFactory.append(modelClass, dataClass, factory);
+    cache.clear();
+  }
+
+  public synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory) {
+    multiModelLoaderFactory.prepend(modelClass, dataClass, factory);
+    cache.clear();
+  }
+
+  public synchronized <Model, Data> void remove(Class<Model> modelClass, Class<Data> dataClass) {
+    tearDown(multiModelLoaderFactory.remove(modelClass, dataClass));
+    cache.clear();
+  }
+
+  public synchronized <Model, Data> void replace(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory) {
+    tearDown(multiModelLoaderFactory.replace(modelClass, dataClass, factory));
+    cache.clear();
+  }
+
+  private <Model, Data> void tearDown(List<ModelLoaderFactory<Model, Data>> factories) {
+    for (ModelLoaderFactory<?, ?> factory : factories) {
+      factory.teardown();
+    }
+  }
+
+  public synchronized <A> List<ModelLoader<A, ?>> getModelLoaders(A model) {
+    List<ModelLoader<A, ?>> modelLoaders = getModelLoadersForClass(getClass(model));
+    int size = modelLoaders.size();
+    List<ModelLoader<A, ?>> filteredLoaders = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      ModelLoader<A, ?> loader = modelLoaders.get(i);
+      if (loader.handles(model)) {
+        filteredLoaders.add(loader);
+      }
+    }
+    return filteredLoaders;
+  }
+
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
+      Class<Data> dataClass) {
+    return multiModelLoaderFactory.build(modelClass, dataClass);
+  }
+
+  public synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+    return multiModelLoaderFactory.getDataClasses(modelClass);
+  }
+
+  private <A> List<ModelLoader<A, ?>> getModelLoadersForClass(Class<A> modelClass) {
+    List<ModelLoader<A, ?>> loaders = cache.get(modelClass);
+    if (loaders == null) {
+      loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));
+      cache.put(modelClass, loaders);
+    }
+    return loaders;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <A> Class<A> getClass(A model) {
+    return (Class<A>) model.getClass();
+  }
+
+  private static class ModelLoaderCache {
+    private final Map<Class<?>, Entry<?>> cachedModelLoaders = new HashMap<>();
+
+    public void clear() {
+      cachedModelLoaders.clear();
+    }
+
+    public <Model> void put(Class<Model> modelClass, List<ModelLoader<Model, ?>> loaders) {
+      Entry<?> previous = cachedModelLoaders.put(modelClass, new Entry<>(loaders));
+      if (previous != null) {
+        throw new IllegalStateException("Already cached loaders for model: " + modelClass);
+      }
+    }
+
+    @SuppressWarnings("unchecked")
+    public <Model> List<ModelLoader<Model, ?>> get(Class<Model> modelClass) {
+      Entry<Model> entry = (Entry<Model>) cachedModelLoaders.get(modelClass);
+      return entry == null ? null : entry.loaders;
+    }
+
+    private static class Entry<Model> {
+      private final List<ModelLoader<Model, ?>> loaders;
+
+      public Entry(List<ModelLoader<Model, ?>> loaders) {
+        this.loaders = loaders;
+      }
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
new file mode 100644
index 000000000..4466666b7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -0,0 +1,148 @@
+package com.bumptech.glide.load.model;
+
+import android.support.v4.util.Pools.Pool;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.DataFetcher.DataCallback;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Allows attempting multiple ModelLoaders registered for a given model and data class.
+ *
+ * <p> TODO: we should try to find a way to remove this class. It exists to allow individual
+ * ModelLoaders to delegate to multiple ModelLoaders without having to duplicate this logic
+ * everywhere. We have very similar logic in the {@link
+ * com.bumptech.glide.load.engine.DataFetcherGenerator} implementations and should try to avoid this
+ * duplication. </p>
+ */
+class MultiModelLoader<Model, Data> implements ModelLoader<Model, Data> {
+
+  private final List<ModelLoader<Model, Data>> modelLoaders;
+  private final Pool<List<Exception>> exceptionListPool;
+
+  MultiModelLoader(List<ModelLoader<Model, Data>> modelLoaders,
+      Pool<List<Exception>> exceptionListPool) {
+    this.modelLoaders = modelLoaders;
+    this.exceptionListPool = exceptionListPool;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(Model model, int width, int height,
+      Options options) {
+    Key sourceKey = null;
+    int size = modelLoaders.size();
+    List<DataFetcher<Data>> fetchers = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      ModelLoader<Model, Data> modelLoader = modelLoaders.get(i);
+      if (modelLoader.handles(model)) {
+        LoadData<Data> loadData = modelLoader.buildLoadData(model, width, height, options);
+        if (loadData != null) {
+          sourceKey = loadData.sourceKey;
+          fetchers.add(loadData.fetcher);
+        }
+      }
+    }
+    return !fetchers.isEmpty()
+        ? new LoadData<>(sourceKey, new MultiFetcher<>(fetchers, exceptionListPool)) : null;
+  }
+
+  @Override
+  public boolean handles(Model model) {
+    for (ModelLoader<Model, Data> modelLoader : modelLoaders) {
+      if (modelLoader.handles(model)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @Override
+  public String toString() {
+    return "MultiModelLoader{" + "modelLoaders=" + Arrays
+        .toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + '}';
+  }
+
+  static class MultiFetcher<Data> implements DataFetcher<Data>, DataCallback<Data> {
+
+    private final List<DataFetcher<Data>> fetchers;
+    private final Pool<List<Exception>> exceptionListPool;
+    private int currentIndex;
+    private Priority priority;
+    private DataCallback<? super Data> callback;
+    private List<Exception> exceptions;
+
+    MultiFetcher(List<DataFetcher<Data>> fetchers, Pool<List<Exception>> exceptionListPool) {
+      this.exceptionListPool = exceptionListPool;
+      Preconditions.checkNotEmpty(fetchers);
+      this.fetchers = fetchers;
+      currentIndex = 0;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+      this.priority = priority;
+      this.callback = callback;
+      exceptions = exceptionListPool.acquire();
+      fetchers.get(currentIndex).loadData(priority, this);
+    }
+
+    @Override
+    public void cleanup() {
+      exceptionListPool.release(exceptions);
+      exceptions = null;
+      for (DataFetcher<Data> fetcher : fetchers) {
+        fetcher.cleanup();
+      }
+    }
+
+    @Override
+    public void cancel() {
+      for (DataFetcher<Data> fetcher : fetchers) {
+        fetcher.cancel();
+      }
+    }
+
+    @Override
+    public Class<Data> getDataClass() {
+      return fetchers.get(0).getDataClass();
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return fetchers.get(0).getDataSource();
+    }
+
+    @Override
+    public void onDataReady(Data data) {
+      if (data != null) {
+        callback.onDataReady(data);
+      } else {
+        startNextOrFail();
+      }
+    }
+
+    @Override
+    public void onLoadFailed(Exception e) {
+      exceptions.add(e);
+      startNextOrFail();
+    }
+
+    private void startNextOrFail() {
+      if (currentIndex < fetchers.size() - 1) {
+        currentIndex++;
+        loadData(priority, callback);
+      } else {
+        callback.onLoadFailed(new GlideException("Fetch failed", new ArrayList<>(exceptions)));
+      }
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
new file mode 100644
index 000000000..e6c82d9c2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -0,0 +1,209 @@
+package com.bumptech.glide.load.model;
+
+import android.content.Context;
+import android.support.v4.util.Pools.Pool;
+
+import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Capable of building an {@link ModelLoader} that wraps one or more other {@link ModelLoader}s for
+ * a given model and data class.
+ */
+public class MultiModelLoaderFactory {
+  private static final Factory DEFAULT_FACTORY = new Factory();
+  private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
+  private final List<Entry<?, ?>> entries = new ArrayList<>();
+  private final Context context;
+  private final Factory factory;
+  private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
+  private final Pool<List<Exception>> exceptionListPool;
+
+  public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool) {
+    this(context, exceptionListPool, DEFAULT_FACTORY);
+  }
+
+  // Visible for testing.
+  MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool,
+      Factory factory) {
+    this.exceptionListPool = exceptionListPool;
+    this.context = context.getApplicationContext();
+    this.factory = factory;
+  }
+
+  synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory) {
+    add(modelClass, dataClass, factory, true /*append*/);
+  }
+
+  synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory) {
+    add(modelClass, dataClass, factory, false /*append*/);
+  }
+
+  private <Model, Data> void add(Class<Model> modelClass, Class<Data> dataClass,
+      ModelLoaderFactory<Model, Data> factory, boolean append) {
+    Entry<Model, Data> entry = new Entry<>(modelClass, dataClass, factory);
+    entries.add(append ? entries.size() : 0, entry);
+  }
+
+  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> replace(Class<Model> modelClass,
+      Class<Data> dataClass, ModelLoaderFactory<Model, Data> factory) {
+    List<ModelLoaderFactory<Model, Data>> removed = remove(modelClass, dataClass);
+    append(modelClass, dataClass, factory);
+    return removed;
+  }
+
+  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> remove(Class<Model> modelClass,
+      Class<Data> dataClass) {
+    List<ModelLoaderFactory<Model, Data>> factories = new ArrayList<>();
+    for (Iterator<Entry<?, ?>> iterator = entries.iterator(); iterator.hasNext(); ) {
+      Entry<?, ?> entry = iterator.next();
+      if (entry.handles(modelClass, dataClass)) {
+        iterator.remove();
+        factories.add(this.<Model, Data>getFactory(entry));
+      }
+    }
+    return factories;
+  }
+
+  synchronized <Model> List<ModelLoader<Model, ?>> build(Class<Model> modelClass) {
+    try {
+      List<ModelLoader<Model, ?>> loaders = new ArrayList<>();
+      for (Entry<?, ?> entry : entries) {
+        // Avoid stack overflow recursively creating model loaders by only creating loaders in
+        // recursive requests if they haven't been created earlier in the chain. For example:
+        // A Uri loader may translate to another model, which in turn may translate back to a Uri.
+        // The original Uri loader won't be provided to the intermediate model loader, although
+        // other Uri loaders will be.
+        if (alreadyUsedEntries.contains(entry)) {
+          continue;
+        }
+        if (entry.handles(modelClass)) {
+          alreadyUsedEntries.add(entry);
+          loaders.add(this.<Model, Object>build(entry));
+          alreadyUsedEntries.remove(entry);
+        }
+      }
+      return loaders;
+    } catch (Throwable t) {
+      alreadyUsedEntries.clear();
+      throw t;
+    }
+  }
+
+  synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+    List<Class<?>> result = new ArrayList<>();
+    for (Entry<?, ?> entry : entries) {
+      if (!result.contains(entry.dataClass) && entry.handles(modelClass)) {
+        result.add(entry.dataClass);
+      }
+    }
+    return result;
+  }
+
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
+      Class<Data> dataClass) {
+    try {
+      List<ModelLoader<Model, Data>> loaders = new ArrayList<>();
+      boolean ignoredAnyEntries = false;
+      for (Entry<?, ?> entry : entries) {
+        // Avoid stack overflow recursively creating model loaders by only creating loaders in
+        // recursive requests if they haven't been created earlier in the chain. For example:
+        // A Uri loader may translate to another model, which in turn may translate back to a Uri.
+        // The original Uri loader won't be provided to the intermediate model loader, although
+        // other Uri loaders will be.
+        if (alreadyUsedEntries.contains(entry)) {
+          ignoredAnyEntries = true;
+          continue;
+        }
+        if (entry.handles(modelClass, dataClass)) {
+          alreadyUsedEntries.add(entry);
+          loaders.add(this.<Model, Data>build(entry));
+          alreadyUsedEntries.remove(entry);
+        }
+      }
+      if (loaders.size() > 1) {
+        return factory.build(loaders, exceptionListPool);
+      } else if (loaders.size() == 1) {
+        return loaders.get(0);
+      } else {
+        // Avoid crashing if recursion results in no loaders available. The assertion is supposed to
+        // catch completely unhandled types, recursion may mean a subtype isn't handled somewhere
+        // down the stack, which is often ok.
+        if (ignoredAnyEntries) {
+          return emptyModelLoader();
+        } else {
+          throw new NoModelLoaderAvailableException(modelClass, dataClass);
+        }
+      }
+    } catch (Throwable t) {
+      alreadyUsedEntries.clear();
+      throw t;
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(Entry<?, ?> entry) {
+    return (ModelLoaderFactory<Model, Data>) entry.factory;
+  }
+
+  @SuppressWarnings("unchecked")
+  private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
+    return (ModelLoader<Model, Data>) Preconditions
+        .checkNotNull(entry.factory.build(context, this));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <Model, Data> ModelLoader<Model, Data> emptyModelLoader() {
+    return (ModelLoader<Model, Data>) EMPTY_MODEL_LOADER;
+  }
+
+  private static class Entry<Model, Data> {
+    private final Class<Model> modelClass;
+    private final Class<Data> dataClass;
+    private final ModelLoaderFactory<Model, Data> factory;
+
+    public Entry(Class<Model> modelClass, Class<Data> dataClass,
+        ModelLoaderFactory<Model, Data> factory) {
+      this.modelClass = modelClass;
+      this.dataClass = dataClass;
+      this.factory = factory;
+    }
+
+    public boolean handles(Class<?> modelClass, Class<?> dataClass) {
+      return handles(modelClass) && this.dataClass.isAssignableFrom(dataClass);
+    }
+
+    public boolean handles(Class<?> modelClass) {
+      return this.modelClass.isAssignableFrom(modelClass);
+    }
+  }
+
+  static class Factory {
+    public <Model, Data> MultiModelLoader<Model, Data> build(
+        List<ModelLoader<Model, Data>> modelLoaders, Pool<List<Exception>> exceptionListPool) {
+      return new MultiModelLoader<>(modelLoaders, exceptionListPool);
+    }
+  }
+
+  private static class EmptyModelLoader implements ModelLoader<Object, Object> {
+
+    @Override
+    public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
+      throw new UnsupportedOperationException("EmptyModelLoader does not handle data");
+    }
+
+    @Override
+    public boolean handles(Object o) {
+      return false;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index efc2bd6a9..8c420ae9f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -4,36 +4,95 @@
 import android.content.Context;
 import android.content.res.Resources;
 import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+import android.support.annotation.Nullable;
+import android.util.Log;
 
-import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.Options;
+
+import java.io.InputStream;
 
 /**
- * A model loader for handling Android resource files. Model must be an Android resource id in the package of the given
- * context.
+ * A model loader for handling Android resource files. Model must be an Android resource id in the
+ * package of the given context.
  *
- * @param <T> The type of data that will be loaded for the given android resource.
+ * @param <Data> The type of data that will be loaded for the given android resource.
  */
-public class ResourceLoader<T> implements ModelLoader<Integer, T> {
+public class ResourceLoader<Data> implements ModelLoader<Integer, Data> {
+  private static final String TAG = "ResourceLoader";
+  private final ModelLoader<Uri, Data> uriLoader;
+  private final Resources resources;
+
+  public ResourceLoader(Context context, ModelLoader<Uri, Data> uriLoader) {
+    this(context.getResources(), uriLoader);
+  }
+
+  public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
+    this.resources = resources;
+    this.uriLoader = uriLoader;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(Integer model, int width, int height, Options options) {
 
-    private final ModelLoader<Uri, T> uriLoader;
-    private final Resources resources;
+    Uri uri = getResourceUri(model);
+    return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
+  }
 
-    public ResourceLoader(Context context, ModelLoader<Uri, T> uriLoader) {
-        this(context.getResources(), uriLoader);
+  @Nullable
+  private Uri getResourceUri(Integer model) {
+    try {
+      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://"
+          + resources.getResourcePackageName(model) + '/'
+          + resources.getResourceTypeName(model) + '/'
+          + resources.getResourceEntryName(model));
+    } catch (Resources.NotFoundException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Received invalid resource id: " + model, e);
+      }
+      return null;
     }
+  }
 
-    public ResourceLoader(Resources resources, ModelLoader<Uri, T> uriLoader) {
-        this.resources = resources;
-        this.uriLoader = uriLoader;
+  @Override
+  public boolean handles(Integer model) {
+    // TODO: check that this is in fact a resource id.
+    return true;
+  }
+
+  /**
+   * Factory for loading {@link InputStream}s from Android resource ids.
+   */
+  public static class StreamFactory implements ModelLoaderFactory<Integer, InputStream> {
+
+    @Override
+    public ModelLoader<Integer, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(context, multiFactory.build(Uri.class, InputStream.class));
     }
 
     @Override
-    public DataFetcher<T> getResourceFetcher(Integer model, int width, int height) {
-        Uri uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://"
-                + resources.getResourcePackageName(model) + '/'
-                + resources.getResourceTypeName(model) + '/'
-                + resources.getResourceEntryName(model));
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Factory for loading {@link ParcelFileDescriptor}s from Android resource ids.
+   */
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
+
+    @Override
+    public ModelLoader<Integer, ParcelFileDescriptor> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(context,
+          multiFactory.build(Uri.class, ParcelFileDescriptor.class));
+    }
 
-        return uriLoader.getResourceFetcher(uri, width, height);
+    @Override
+    public void teardown() {
+      // Do nothing.
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 1022754da..45b168512 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -3,39 +3,54 @@
 import android.util.Log;
 
 import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.util.ByteArrayPool;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 
+import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
 /**
- * An {@link com.bumptech.glide.load.Encoder} that can write an {@link java.io.InputStream} to disk.
+ * An {@link com.bumptech.glide.load.Encoder} that can write an {@link java.io.InputStream} to
+ * disk.
  */
 public class StreamEncoder implements Encoder<InputStream> {
-    private static final String TAG = "StreamEncoder";
+  private static final String TAG = "StreamEncoder";
+  private final ByteArrayPool byteArrayPool;
 
-    @Override
-    public boolean encode(InputStream data, OutputStream os) {
-        byte[] buffer = ByteArrayPool.get().getBytes();
+  public StreamEncoder(ByteArrayPool byteArrayPool) {
+    this.byteArrayPool = byteArrayPool;
+  }
+
+  @Override
+  public boolean encode(InputStream data, File file, Options options) {
+    byte[] buffer = byteArrayPool.get(ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+    boolean success = false;
+    OutputStream os = null;
+    try {
+      os = new FileOutputStream(file);
+      int read;
+      while ((read = data.read(buffer)) != -1) {
+        os.write(buffer, 0, read);
+      }
+      os.close();
+      success = true;
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to encode data onto the OutputStream", e);
+      }
+    } finally {
+      if (os != null) {
         try {
-            int read;
-            while ((read = data.read(buffer)) != -1) {
-                    os.write(buffer, 0, read);
-            }
-            return true;
+          os.close();
         } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Failed to encode data onto the OutputStream", e);
-            }
-            return false;
-        } finally {
-            ByteArrayPool.get().releaseBytes(buffer);
+          // Do nothing.
         }
+      }
+      byteArrayPool.put(buffer);
     }
-
-    @Override
-    public String getId() {
-        return "";
-    }
+    return success;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index efdf666c2..5f878b1c5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,41 +1,94 @@
 package com.bumptech.glide.load.model;
 
+import android.content.Context;
 import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 
-import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.Options;
 
 import java.io.File;
+import java.io.InputStream;
 
 /**
- * A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by
- * {@link android.content.ContentResolver#openInputStream(Uri)}.
+ * A model loader for handling certain string models. Handles paths, urls, and any uri string with a
+ * scheme handled by {@link android.content.ContentResolver#openInputStream(Uri)}.
  *
- * @param <T> The type of data that will be loaded from the given {@link java.lang.String}.
+ * @param <Data> The type of data that will be loaded from the given {@link java.lang.String}.
  */
-public class StringLoader<T> implements ModelLoader<String, T> {
-    private final ModelLoader<Uri, T> uriLoader;
+public class StringLoader<Data> implements ModelLoader<String, Data> {
+  private final ModelLoader<Uri, Data> uriLoader;
 
-    public StringLoader(ModelLoader<Uri, T> uriLoader) {
-        this.uriLoader = uriLoader;
+  public StringLoader(ModelLoader<Uri, Data> uriLoader) {
+    this.uriLoader = uriLoader;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(String model, int width, int height,
+      Options options) {
+    Uri uri = parseUri(model);
+    return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
+  }
+
+  @Override
+  public boolean handles(String model) {
+    return true;
+  }
+
+  @Nullable
+  private static Uri parseUri(String model) {
+    Uri uri;
+    if (TextUtils.isEmpty(model)) {
+      return null;
+    } else if (model.startsWith("/")) {
+      uri = toFileUri(model);
+    } else {
+      uri = Uri.parse(model);
+      String scheme = uri.getScheme();
+      if (scheme == null) {
+        uri = toFileUri(model);
+      }
     }
+    return uri;
+  }
+
+  private static Uri toFileUri(String path) {
+    return Uri.fromFile(new File(path));
+  }
+
+  /**
+   * Factory for loading {@link InputStream}s from Strings.
+   */
+  public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
     @Override
-    public DataFetcher<T> getResourceFetcher(String model, int width, int height) {
-        Uri uri;
-        if (model.startsWith("/")) {
-            uri = toFileUri(model);
-        } else {
-            uri = Uri.parse(model);
-            final String scheme = uri.getScheme();
-            if (scheme == null) {
-                uri = toFileUri(model);
-            }
-        }
-
-        return uriLoader.getResourceFetcher(uri, width, height);
+    public ModelLoader<String, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
-    private static Uri toFileUri(String path) {
-        return Uri.fromFile(new File(path));
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Factory for loading {@link ParcelFileDescriptor}s from Strings.
+   */
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<String, ParcelFileDescriptor> {
+
+    @Override
+    public ModelLoader<String, ParcelFileDescriptor> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
new file mode 100644
index 000000000..b3807a2db
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -0,0 +1,82 @@
+package com.bumptech.glide.load.model;
+
+import android.content.Context;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.signature.ObjectKey;
+
+/**
+ * A put of helper classes that performs no loading and instead always returns the given model as
+ * the data to decode.
+ *
+ * @param <Model> The type of model that will also be returned as decodable data.
+ */
+public class UnitModelLoader<Model> implements ModelLoader<Model, Model> {
+
+  @Override
+  public LoadData<Model> buildLoadData(Model model, int width, int height,
+      Options options) {
+    return new LoadData<>(new ObjectKey(model), new UnitFetcher<>(model));
+  }
+
+  @Override
+  public boolean handles(Model model) {
+    return true;
+  }
+
+  private static class UnitFetcher<Model> implements DataFetcher<Model> {
+
+    private final Model resource;
+
+    public UnitFetcher(Model resource) {
+      this.resource = resource;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super Model> callback) {
+      callback.onDataReady(resource);
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public Class<Model> getDataClass() {
+      return (Class<Model>) resource.getClass();
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+
+  /**
+   * Factory for producing {@link com.bumptech.glide.load.model.UnitModelLoader}s.
+   */
+  public static class Factory<ResourceType> implements ModelLoaderFactory<ResourceType,
+      ResourceType> {
+
+    @Override
+    public ModelLoader<ResourceType, ResourceType> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new UnitModelLoader<>();
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index 30db4a6c1..d6a66a163 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -3,51 +3,111 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
+import android.os.ParcelFileDescriptor;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
+import com.bumptech.glide.load.data.StreamLocalUriFetcher;
+import com.bumptech.glide.signature.ObjectKey;
+
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 
 /**
- * A base ModelLoader for {@link android.net.Uri}s that handles local {@link android.net.Uri}s directly and routes
- * remote {@link android.net.Uri}s to a wrapped {@link com.bumptech.glide.load.model.ModelLoader} that handles
+ * A ModelLoader for {@link android.net.Uri}s that handles local {@link android.net.Uri}s
+ * directly and routes remote {@link android.net.Uri}s to a wrapped
+ * {@link com.bumptech.glide.load.model.ModelLoader} that handles
  * {@link com.bumptech.glide.load.model.GlideUrl}s.
  *
- * @param <T> The type of data that will be retrieved for {@link android.net.Uri}s.
+ * @param <Data> The type of data that will be retrieved for {@link android.net.Uri}s.
  */
-public abstract class UriLoader<T> implements ModelLoader<Uri, T> {
-    private final Context context;
-    private final ModelLoader<GlideUrl, T> urlLoader;
+public class UriLoader<Data> implements ModelLoader<Uri, Data> {
+  private static final Set<String> SCHEMES = Collections.unmodifiableSet(
+      new HashSet<>(
+          Arrays.asList(
+              ContentResolver.SCHEME_FILE,
+              ContentResolver.SCHEME_ANDROID_RESOURCE,
+              ContentResolver.SCHEME_CONTENT
+          )
+      )
+  );
+
+  private final Context context;
+  private final LocalUriFetcherFactory<Data> factory;
+
+  public UriLoader(Context context, LocalUriFetcherFactory<Data> factory) {
+    this.context = context;
+    this.factory = factory;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(Uri model, int width, int height,
+      Options options) {
+    return new LoadData<>(new ObjectKey(model), factory.build(context, model));
+  }
+
+  @Override
+  public boolean handles(Uri model) {
+    return SCHEMES.contains(model.getScheme());
+  }
 
-    public UriLoader(Context context, ModelLoader<GlideUrl, T> urlLoader) {
-        this.context = context;
-        this.urlLoader = urlLoader;
+  /**
+   * Factory for obtaining a {@link DataFetcher} for a data type for a particular {@link Uri}.
+   *
+   * @param <Data> The type of data the returned {@link DataFetcher} will obtain.
+   */
+  public interface LocalUriFetcherFactory<Data> {
+    DataFetcher<Data> build(Context context, Uri uri);
+  }
+
+  /**
+   * Loads {@link InputStream}s from {@link Uri}s.
+   */
+  public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
+      LocalUriFetcherFactory<InputStream> {
+
+    @Override
+    public DataFetcher<InputStream> build(Context context, Uri uri) {
+      return new StreamLocalUriFetcher(context, uri);
     }
 
     @Override
-    public final DataFetcher<T> getResourceFetcher(Uri model, int width, int height) {
-        final String scheme = model.getScheme();
-
-        DataFetcher<T> result = null;
-        if (isLocalUri(scheme)) {
-            if (AssetUriParser.isAssetUri(model)) {
-                String path = AssetUriParser.toAssetPath(model);
-                result = getAssetPathFetcher(context, path);
-            } else {
-                result = getLocalUriFetcher(context, model);
-            }
-        } else if (urlLoader != null && ("http".equals(scheme) || "https".equals(scheme))) {
-            result = urlLoader.getResourceFetcher(new GlideUrl(model.toString()), width, height);
-        }
-
-        return result;
+    public ModelLoader<Uri, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(context, this);
     }
 
-    protected abstract DataFetcher<T> getLocalUriFetcher(Context context, Uri uri);
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Loads {@link ParcelFileDescriptor}s from {@link Uri}s.
+   */
+  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
+      ParcelFileDescriptor>,
+      LocalUriFetcherFactory<ParcelFileDescriptor> {
+
+    @Override
+    public DataFetcher<ParcelFileDescriptor> build(Context context, Uri uri) {
+      return new FileDescriptorLocalUriFetcher(context, uri);
+    }
 
-    protected abstract DataFetcher<T> getAssetPathFetcher(Context context, String path);
+    @Override
+    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(context, this);
+    }
 
-    private static boolean isLocalUri(String scheme) {
-        return ContentResolver.SCHEME_FILE.equals(scheme)
-                || ContentResolver.SCHEME_CONTENT.equals(scheme)
-                || ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme);
+    @Override
+    public void teardown() {
+      // Do nothing.
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlLoader.java
deleted file mode 100644
index 6d29b9b1e..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlLoader.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import com.bumptech.glide.load.data.DataFetcher;
-
-import java.net.URL;
-
-/**
- * A wrapper class that translates {@link java.net.URL} objects into {@link com.bumptech.glide.load.model.GlideUrl}
- * objects and then uses the wrapped {@link com.bumptech.glide.load.model.ModelLoader} for
- * {@link com.bumptech.glide.load.model.GlideUrl}s to load the data.
- *
- * @param <T> The type of data that will be loaded from the {@link java.net.URL}s.
- */
-public class UrlLoader<T> implements ModelLoader<URL, T> {
-    private final ModelLoader<GlideUrl, T> glideUrlLoader;
-
-    public UrlLoader(ModelLoader<GlideUrl, T> glideUrlLoader) {
-        this.glideUrlLoader = glideUrlLoader;
-    }
-
-    @Override
-    public DataFetcher<T> getResourceFetcher(URL model, int width, int height) {
-        return glideUrlLoader.getResourceFetcher(new GlideUrl(model), width, height);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
new file mode 100644
index 000000000..f71d7e789
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -0,0 +1,63 @@
+package com.bumptech.glide.load.model;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.bumptech.glide.load.Options;
+
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Handles http/https Uris by delegating to the {@link ModelLoader} for {@link
+ * com.bumptech.glide.load.model.GlideUrl GlideUrls}.
+ *
+ * @param <Data> The type of data this Loader will obtain for a {@link Uri}.
+ */
+public class UrlUriLoader<Data> implements ModelLoader<Uri, Data> {
+  private static final Set<String> SCHEMES = Collections.unmodifiableSet(
+      new HashSet<>(
+          Arrays.asList(
+              "http",
+              "https"
+          )
+      )
+  );
+  private final ModelLoader<GlideUrl, Data> urlLoader;
+
+  public UrlUriLoader(ModelLoader<GlideUrl, Data> urlLoader) {
+    this.urlLoader = urlLoader;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(Uri uri, int width, int height, Options options) {
+    GlideUrl glideUrl = new GlideUrl(uri.toString());
+    return urlLoader.buildLoadData(glideUrl, width, height, options);
+  }
+
+  @Override
+  public boolean handles(Uri uri) {
+    return SCHEMES.contains(uri.getScheme());
+  }
+
+  /**
+   * Loads {@link java.io.InputStream InputStreams} from {@link android.net.Uri Uris} with http
+   * or https schemes.
+   */
+  public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
+
+    @Override
+    public ModelLoader<Uri, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorFileLoader.java
deleted file mode 100644
index 2431df3e8..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorFileLoader.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.bumptech.glide.load.model.file_descriptor;
-
-import android.content.Context;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.model.FileLoader;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-
-import java.io.File;
-
-/**
- * A {@link ModelLoader} For translating {@link File} models into {@link ParcelFileDescriptor} data.
- */
-public class FileDescriptorFileLoader extends FileLoader<ParcelFileDescriptor>
-        implements FileDescriptorModelLoader<File> {
-
-    /**
-     * The default {@link com.bumptech.glide.load.model.ModelLoaderFactory} for
-     * {@link com.bumptech.glide.load.model.file_descriptor.FileDescriptorFileLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<File, ParcelFileDescriptor> {
-        @Override
-        public ModelLoader<File, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {
-            return new FileDescriptorFileLoader(factories.buildModelLoader(Uri.class, ParcelFileDescriptor.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public FileDescriptorFileLoader(Context context) {
-        this(Glide.buildFileDescriptorModelLoader(Uri.class, context));
-    }
-
-    public FileDescriptorFileLoader(ModelLoader<Uri, ParcelFileDescriptor> uriLoader) {
-        super(uriLoader);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorModelLoader.java
deleted file mode 100644
index c645fdc62..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorModelLoader.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package com.bumptech.glide.load.model.file_descriptor;
-
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.model.ModelLoader;
-
-/**
- * A base class for {@link ModelLoader}s that translate models into {@link java.io.File}s.
- *
- * @param <T> The type of the model that will be translated into an {@link java.io.File}.
- */
-public interface FileDescriptorModelLoader<T> extends ModelLoader<T, ParcelFileDescriptor> {
-    // specializing the generic arguments
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorResourceLoader.java
deleted file mode 100644
index 0f107bd18..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorResourceLoader.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package com.bumptech.glide.load.model.file_descriptor;
-
-import android.content.Context;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.ResourceLoader;
-
-/**
- * A {@link ModelLoader} For translating android resource id models into {@link ParcelFileDescriptor} data.
- */
-public class FileDescriptorResourceLoader extends ResourceLoader<ParcelFileDescriptor>
-        implements FileDescriptorModelLoader<Integer> {
-
-    /**
-     * The default factory for {@link com.bumptech.glide.load.model.file_descriptor.FileDescriptorResourceLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
-
-        @Override
-        public ModelLoader<Integer, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {
-            return new FileDescriptorResourceLoader(context, factories.buildModelLoader(Uri.class,
-                    ParcelFileDescriptor.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public FileDescriptorResourceLoader(Context context) {
-        this(context, Glide.buildFileDescriptorModelLoader(Uri.class, context));
-    }
-
-    public FileDescriptorResourceLoader(Context context, ModelLoader<Uri, ParcelFileDescriptor> uriLoader) {
-        super(context, uriLoader);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorStringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorStringLoader.java
deleted file mode 100644
index c6f335fac..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorStringLoader.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.model.file_descriptor;
-
-import android.content.Context;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.StringLoader;
-
-/**
- * A {@link ModelLoader} For translating {@link String} models, such as file paths, into {@link ParcelFileDescriptor}
- * data.
- */
-public class FileDescriptorStringLoader extends StringLoader<ParcelFileDescriptor>
-        implements FileDescriptorModelLoader<String> {
-
-    /**
-     * The default factory for {@link com.bumptech.glide.load.model.file_descriptor.FileDescriptorStringLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<String, ParcelFileDescriptor> {
-        @Override
-        public ModelLoader<String, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {
-            return new FileDescriptorStringLoader(factories.buildModelLoader(Uri.class, ParcelFileDescriptor.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public FileDescriptorStringLoader(Context context) {
-        this(Glide.buildFileDescriptorModelLoader(Uri.class, context));
-    }
-
-    public FileDescriptorStringLoader(ModelLoader<Uri, ParcelFileDescriptor> uriLoader) {
-        super(uriLoader);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorUriLoader.java
deleted file mode 100644
index d950461ad..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorUriLoader.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.bumptech.glide.load.model.file_descriptor;
-
-import android.content.Context;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
-import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.UriLoader;
-
-/**
- * A {@link ModelLoader} For translating {@link Uri} models for local uris into {@link ParcelFileDescriptor} data.
- */
-public class FileDescriptorUriLoader extends UriLoader<ParcelFileDescriptor> implements FileDescriptorModelLoader<Uri> {
-
-    /**
-     * The default factory for {@link com.bumptech.glide.load.model.file_descriptor.FileDescriptorUriLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<Uri, ParcelFileDescriptor> {
-        @Override
-        public ModelLoader<Uri, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {
-            return new FileDescriptorUriLoader(context, factories.buildModelLoader(GlideUrl.class,
-                    ParcelFileDescriptor.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public FileDescriptorUriLoader(Context context) {
-        this(context, Glide.buildFileDescriptorModelLoader(GlideUrl.class, context));
-    }
-
-    public FileDescriptorUriLoader(Context context, ModelLoader<GlideUrl, ParcelFileDescriptor> urlLoader) {
-        super(context, urlLoader);
-    }
-
-    @Override
-    protected DataFetcher<ParcelFileDescriptor> getLocalUriFetcher(Context context, Uri uri) {
-        return new FileDescriptorLocalUriFetcher(context, uri);
-    }
-
-    @Override
-    protected DataFetcher<ParcelFileDescriptor> getAssetPathFetcher(Context context, String assetPath) {
-        return new FileDescriptorAssetPathFetcher(context.getApplicationContext().getAssets(), assetPath);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index a319c3476..d10f4fac6 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -1,73 +1,117 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
 
 import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 
 /**
- * A base class for loading images over http/https. Can be subclassed for use with any model that can be translated
- * in to {@link java.io.InputStream} data.
+ * A base class for loading data over http/https. Can be subclassed for use with any model that can
+ * be translated in to {@link java.io.InputStream} data.
  *
- * @param <T> The type of the model.
+ * @param <Model> The type of the model.
  */
-public abstract class BaseGlideUrlLoader<T> implements StreamModelLoader<T> {
-    private final ModelLoader<GlideUrl, InputStream> concreteLoader;
-    private final ModelCache<T, GlideUrl> modelCache;
+public abstract class BaseGlideUrlLoader<Model> implements ModelLoader<Model, InputStream> {
+  private final ModelLoader<GlideUrl, InputStream> concreteLoader;
+  @Nullable private final ModelCache<Model, GlideUrl> modelCache;
 
-    public BaseGlideUrlLoader(Context context) {
-        this(context, null);
-    }
-
-    public BaseGlideUrlLoader(Context context, ModelCache<T, GlideUrl> modelCache) {
-        this(Glide.buildModelLoader(GlideUrl.class, InputStream.class, context), modelCache);
-    }
+  protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader) {
+    this(concreteLoader, null);
+  }
 
-    public BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader) {
-        this(concreteLoader, null);
-    }
+  protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+      @Nullable ModelCache<Model, GlideUrl> modelCache) {
+    this.concreteLoader = concreteLoader;
+    this.modelCache = modelCache;
+  }
 
-    public BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader, ModelCache<T, GlideUrl> modelCache) {
-        this.concreteLoader = concreteLoader;
-        this.modelCache = modelCache;
+  @Override
+  @Nullable
+  public LoadData<InputStream> buildLoadData(Model model, int width, int height, Options options) {
+    GlideUrl result = null;
+    if (modelCache != null) {
+      result = modelCache.get(model, width, height);
     }
 
-    @Override
-    public DataFetcher<InputStream> getResourceFetcher(T model, int width, int height) {
-        GlideUrl result = null;
-        if (modelCache != null) {
-            result = modelCache.get(model, width, height);
-        }
+    if (result == null) {
+      String stringURL = getUrl(model, width, height, options);
+      if (TextUtils.isEmpty(stringURL)) {
+        return null;
+      }
 
-        if (result == null) {
-            String stringURL = getUrl(model, width, height);
-            if (TextUtils.isEmpty(stringURL)) {
-               return null;
-            }
+      result = new GlideUrl(stringURL, getHeaders(model, width, height, options));
 
-            result = new GlideUrl(stringURL);
+      if (modelCache != null) {
+        modelCache.put(model, width, height, result);
+      }
+    }
 
-            if (modelCache != null) {
-                modelCache.put(model, width, height, result);
-            }
-        }
+    // TODO: this is expensive and slow to calculate every time, we should either cache these, or
+    // try to come up with a way to avoid finding them when not necessary.
+    List<String> alternateUrls = getAlternateUrls(model, width, height, options);
+    LoadData<InputStream> concreteLoaderData = concreteLoader.buildLoadData(result, width, height,
+        options);
+    if (alternateUrls.isEmpty()) {
+      return concreteLoaderData;
+    } else {
+      return new LoadData<>(concreteLoaderData.sourceKey, getAlternateKeys(alternateUrls),
+          concreteLoaderData.fetcher);
+    }
+  }
 
-        return concreteLoader.getResourceFetcher(result, width, height);
+  private static List<Key> getAlternateKeys(List<String> alternateUrls) {
+    List<Key> result = new ArrayList<>(alternateUrls.size());
+    for (String alternate : alternateUrls) {
+      result.add(new GlideUrl(alternate));
     }
+    return result;
+  }
+
+  /**
+   * Returns a valid url http:// or https:// for the given model and dimensions as a string.
+   *
+   * @param model  The model.
+   * @param width  The width in pixels of the view/target the image will be loaded into.
+   * @param height The height in pixels of the view/target the image will be loaded into.
+   */
+  protected abstract String getUrl(Model model, int width, int height, Options options);
+
+  /**
+   * Returns a list of alternate urls for the given model, width, and height from which equivalent
+   * data can be obtained (usually the same image with the same aspect ratio, but in a larger size)
+   * as the primary url.
+   *
+   * <p> Implementing this method allows Glide to fulfill requests for bucketed images in smaller
+   * bucket sizes using already cached data for larger bucket sizes. </p>
+   *
+   * @param width  The width in pixels of the view/target the image will be loaded into.
+   * @param height The height in pixels of the view/target the image will be loaded into.
+   */
+  protected List<String> getAlternateUrls(Model model, int width, int height,
+      Options options) {
+    return Collections.emptyList();
+  }
 
-    /**
-     * Get a valid url http:// or https:// for the given model and dimensions as a string.
-     *
-     * @param model The model.
-     * @param width The width in pixels of the view/target the image will be loaded into.
-     * @param height The height in pixels of the view/target the image will be loaded into.
-     * @return The String url.
-     */
-    protected abstract String getUrl(T model, int width, int height);
+  /**
+   * Returns the headers for the given model and dimensions as a map of strings to sets of strings,
+   * or null if no headers should be added.
+   *
+   * @param model The model.
+   * @param width The width in pixels of the view/target the image will be loaded into.
+   * @param height The height in pixels of the view/target the image will be loaded into.
+   */
+  @Nullable
+  protected Headers getHeaders(Model model, int width, int height, Options options) {
+    return Headers.DEFAULT;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
new file mode 100644
index 000000000..a42d2ca14
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -0,0 +1,69 @@
+package com.bumptech.glide.load.model.stream;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.HttpUrlFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelCache;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+
+import java.io.InputStream;
+
+/**
+ * An {@link com.bumptech.glide.load.model.ModelLoader} for translating {@link
+ * com.bumptech.glide.load.model.GlideUrl} (http/https URLS) into {@link java.io.InputStream} data.
+ */
+public class HttpGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+  @Nullable private final ModelCache<GlideUrl, GlideUrl> modelCache;
+
+  public HttpGlideUrlLoader() {
+    this(null);
+  }
+
+  public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
+    this.modelCache = modelCache;
+  }
+
+  @Override
+  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
+      Options options) {
+    // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time
+    // spent parsing urls.
+    GlideUrl url = model;
+    if (modelCache != null) {
+      url = modelCache.get(model, 0, 0);
+      if (url == null) {
+        modelCache.put(model, 0, 0, model);
+        url = model;
+      }
+    }
+    return new LoadData<>(url, new HttpUrlFetcher(url));
+  }
+
+  @Override
+  public boolean handles(GlideUrl model) {
+    return true;
+  }
+
+  /**
+   * The default factory for {@link HttpGlideUrlLoader}s.
+   */
+  public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
+    private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
+
+    @Override
+    public ModelLoader<GlideUrl, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new HttpGlideUrlLoader(modelCache);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
new file mode 100644
index 000000000..e3f11a6f4
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.model.stream;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Loads {@link InputStream}s from http or https {@link Uri}s.
+ */
+public class HttpUriLoader implements ModelLoader<Uri, InputStream> {
+  private static final Set<String> SCHEMES =
+      Collections.unmodifiableSet(new HashSet<>(Arrays.asList("http", "https")));
+
+  private final ModelLoader<GlideUrl, InputStream> urlLoader;
+
+  public HttpUriLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
+    this.urlLoader = urlLoader;
+  }
+
+  @Override
+  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+    return urlLoader.buildLoadData(new GlideUrl(model.toString()), width, height, options);
+  }
+
+  @Override
+  public boolean handles(Uri model) {
+    return SCHEMES.contains(model.getScheme());
+  }
+
+  /**
+   * Factory for loading {@link InputStream}s from http/https {@link Uri}s.
+   */
+  public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
+
+    @Override
+    public ModelLoader<Uri, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoader.java
deleted file mode 100644
index 3ee3060da..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoader.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import android.content.Context;
-
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.data.HttpUrlFetcher;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.load.model.ModelCache;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-
-import java.io.InputStream;
-
-/**
- * An {@link com.bumptech.glide.load.model.ModelLoader} for translating {@link com.bumptech.glide.load.model.GlideUrl}
- * (http/https URLS) into {@link java.io.InputStream} data.
- */
-public class HttpUrlGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
-
-    private final ModelCache<GlideUrl, GlideUrl> modelCache;
-
-    /**
-     * The default factory for {@link com.bumptech.glide.load.model.stream.HttpUrlGlideUrlLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
-        private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<GlideUrl, GlideUrl>(500);
-
-        @Override
-        public ModelLoader<GlideUrl, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new HttpUrlGlideUrlLoader(modelCache);
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public HttpUrlGlideUrlLoader() {
-        this(null);
-    }
-
-    public HttpUrlGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
-        this.modelCache = modelCache;
-    }
-
-    @Override
-    public DataFetcher<InputStream> getResourceFetcher(GlideUrl model, int width, int height) {
-        // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time spent parsing urls.
-        GlideUrl url = model;
-        if (modelCache != null) {
-            url = modelCache.get(model, 0, 0);
-            if (url == null) {
-                modelCache.put(model, 0, 0, model);
-                url = model;
-            }
-        }
-        return new HttpUrlFetcher(url);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
new file mode 100644
index 000000000..635d8c131
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.model.stream;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
+import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.signature.ObjectKey;
+
+import java.io.InputStream;
+
+/**
+ * Loads {@link InputStream}s from media store image {@link Uri}s that point to pre-generated
+ * thumbnails for those {@link Uri}s in the media store.
+ */
+public class MediaStoreImageThumbLoader implements ModelLoader<Uri, InputStream> {
+  public final Context context;
+
+  public MediaStoreImageThumbLoader(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  @Override
+  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+    if (MediaStoreUtil.isThumbnailSize(width, height)) {
+      return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildImageFetcher(context, model));
+    } else {
+      return null;
+    }
+  }
+
+  @Override
+  public boolean handles(Uri model) {
+    return MediaStoreUtil.isMediaStoreImageUri(model);
+  }
+
+  /**
+   * Factory that loads {@link InputStream}s from media store image {@link Uri}s.
+   */
+  public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
+
+    @Override
+    public ModelLoader<Uri, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new MediaStoreImageThumbLoader(context);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoader.java
deleted file mode 100644
index 980997a6b..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoader.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.data.MediaStoreThumbFetcher;
-import com.bumptech.glide.load.model.ModelLoader;
-
-import java.io.InputStream;
-
-/**
- * An {@link com.bumptech.glide.load.model.ModelLoader} that can use media store uris to open pre-generated thumbnails
- * from the media store using {@link android.provider.MediaStore.Images.Thumbnails} and
- * {@link android.provider.MediaStore.Video.Thumbnails} if the requested size is less than or equal to the media store
- * thumbnail size. If the given uri is not a media store uri or if the desired dimensions are too large,
- * it falls back to the wrapped {@link com.bumptech.glide.load.model.ModelLoader} to load the
- * {@link java.io.InputStream} data.
- */
-public class MediaStoreStreamLoader implements ModelLoader<Uri, InputStream> {
-    private final Context context;
-    private final ModelLoader<Uri, InputStream> uriLoader;
-
-    public MediaStoreStreamLoader(Context context, ModelLoader<Uri, InputStream> uriLoader) {
-        this.context = context;
-        this.uriLoader = uriLoader;
-    }
-
-    @Override
-    public DataFetcher<InputStream> getResourceFetcher(Uri model, int width, int height) {
-        return new MediaStoreThumbFetcher(context, model, uriLoader.getResourceFetcher(model, width, height), width,
-                height);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
new file mode 100644
index 000000000..1ab758391
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -0,0 +1,71 @@
+package com.bumptech.glide.load.model.stream;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
+import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.signature.ObjectKey;
+
+import java.io.InputStream;
+
+/**
+ * Loads {@link InputStream}s from media store video {@link Uri}s that point to pre-generated
+ * thumbnails for those {@link Uri}s in the media store.
+ *
+ * <p>If {@link VideoBitmapDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
+ * {@link VideoBitmapDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
+ * store does not use a defined frame to generate the thumbnail, so we cannot accurately fulfill
+ * requests for specific frames.
+ */
+public class MediaStoreVideoThumbLoader implements ModelLoader<Uri, InputStream> {
+  private final Context context;
+
+  MediaStoreVideoThumbLoader(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  @Override
+  @Nullable
+  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+    if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
+      return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
+    } else {
+      return null;
+    }
+  }
+
+  private boolean isRequestingDefaultFrame(Options options) {
+    Long specifiedFrame = options.get(VideoBitmapDecoder.TARGET_FRAME);
+    return specifiedFrame != null && specifiedFrame == VideoBitmapDecoder.DEFAULT_FRAME;
+  }
+
+  @Override
+  public boolean handles(Uri model) {
+    return MediaStoreUtil.isMediaStoreVideoUri(model);
+  }
+
+  /**
+   * Loads {@link InputStream}s from media store image {@link Uri}s that point to pre-generated
+   * thumbnails for those {@link Uri}s in the media store.
+   */
+  public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
+
+    @Override
+    public ModelLoader<Uri, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new MediaStoreVideoThumbLoader(context);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java
deleted file mode 100644
index 3f0277dca..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import android.content.Context;
-
-import com.bumptech.glide.load.data.ByteArrayFetcher;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-
-import java.io.InputStream;
-
-/**
- * A base class to convert byte arrays to input streams so they can be decoded. This class is abstract because there is
- * no simple/quick way to generate an id from the bytes themselves, so subclass must include an id.
- */
-public class StreamByteArrayLoader implements StreamModelLoader<byte[]> {
-    private final String id;
-
-    public StreamByteArrayLoader() {
-        this("");
-    }
-
-    /**
-     * @deprecated Use {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)}
-     * and the empty constructor instead. Scheduled to be removed in Glide 4.0.
-     */
-    @Deprecated
-    public StreamByteArrayLoader(String id) {
-        this.id = id;
-    }
-
-    @Override
-    public DataFetcher<InputStream> getResourceFetcher(byte[] model, int width, int height) {
-        return new ByteArrayFetcher(model, id);
-    }
-
-    /**
-     * Factory for {@link com.bumptech.glide.load.model.stream.StreamByteArrayLoader}.
-     */
-    public static class Factory implements ModelLoaderFactory<byte[], InputStream> {
-
-        @Override
-        public ModelLoader<byte[], InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamByteArrayLoader();
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamFileLoader.java
deleted file mode 100644
index 1aca470a9..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamFileLoader.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.model.FileLoader;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * A {@link ModelLoader} For translating {@link File} models for local uris into {@link InputStream} data.
- */
-public class StreamFileLoader extends FileLoader<InputStream> implements StreamModelLoader<File> {
-
-    /**
-     * The default factory for {@link com.bumptech.glide.load.model.stream.StreamFileLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<File, InputStream> {
-        @Override
-        public ModelLoader<File, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamFileLoader(factories.buildModelLoader(Uri.class, InputStream.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public StreamFileLoader(Context context) {
-        this(Glide.buildStreamModelLoader(Uri.class, context));
-    }
-
-    public StreamFileLoader(ModelLoader<Uri, InputStream> uriLoader) {
-        super(uriLoader);
-    }
-
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamModelLoader.java
deleted file mode 100644
index fb203b998..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamModelLoader.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import com.bumptech.glide.load.model.ModelLoader;
-
-import java.io.InputStream;
-
-/**
- * A base class for {@link ModelLoader}s that translate models into {@link InputStream}s.
- *
- * @param <T> The type of the model that will be translated into an {@link InputStream}.
- */
-public interface StreamModelLoader<T> extends ModelLoader<T, InputStream> {
-    // specializing the generic arguments
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamResourceLoader.java
deleted file mode 100644
index a38255748..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamResourceLoader.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.ResourceLoader;
-
-import java.io.InputStream;
-
-/**
- * A {@link ModelLoader} For translating android resource id models for local uris into {@link InputStream} data.
- */
-public class StreamResourceLoader extends ResourceLoader<InputStream> implements StreamModelLoader<Integer> {
-
-    /**
-     * The default factory for {@link com.bumptech.glide.load.model.stream.StreamResourceLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<Integer, InputStream> {
-
-        @Override
-        public ModelLoader<Integer, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamResourceLoader(context, factories.buildModelLoader(Uri.class, InputStream.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public StreamResourceLoader(Context context) {
-        this(context, Glide.buildStreamModelLoader(Uri.class, context));
-    }
-
-    public StreamResourceLoader(Context context, ModelLoader<Uri, InputStream> uriLoader) {
-        super(context, uriLoader);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamStringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamStringLoader.java
deleted file mode 100644
index 80bbb7af6..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamStringLoader.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.StringLoader;
-
-import java.io.InputStream;
-
-/**
- * A {@link ModelLoader} for translating {@link String} models, such as file paths or remote urls, into
- * {@link InputStream} data.
- */
-public class StreamStringLoader extends StringLoader<InputStream> implements StreamModelLoader<String> {
-
-    /**
-     * The default factory for {@link com.bumptech.glide.load.model.stream.StreamStringLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<String, InputStream> {
-        @Override
-        public ModelLoader<String, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamStringLoader(factories.buildModelLoader(Uri.class, InputStream.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public StreamStringLoader(Context context) {
-        this(Glide.buildStreamModelLoader(Uri.class, context));
-    }
-
-    public StreamStringLoader(ModelLoader<Uri, InputStream> uriLoader) {
-        super(uriLoader);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUriLoader.java
deleted file mode 100644
index 086f4c4cb..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUriLoader.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.data.StreamAssetPathFetcher;
-import com.bumptech.glide.load.data.StreamLocalUriFetcher;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.UriLoader;
-
-import java.io.InputStream;
-
-/**
- * A {@link ModelLoader} for translating uri models into {@link InputStream} data. Capable of handling 'http',
- * 'https', 'android.resource', 'content', and 'file' schemes. Unsupported schemes will throw an exception in
- * {@link #getResourceFetcher(Uri, int, int)}.
- */
-public class StreamUriLoader extends UriLoader<InputStream> implements StreamModelLoader<Uri> {
-
-    /**
-     * THe default factory for {@link com.bumptech.glide.load.model.stream.StreamUriLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
-
-        @Override
-        public ModelLoader<Uri, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamUriLoader(context, factories.buildModelLoader(GlideUrl.class, InputStream.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public StreamUriLoader(Context context) {
-        this(context, Glide.buildStreamModelLoader(GlideUrl.class, context));
-    }
-
-    public StreamUriLoader(Context context, ModelLoader<GlideUrl, InputStream> urlLoader) {
-        super(context, urlLoader);
-    }
-
-    @Override
-    protected DataFetcher<InputStream> getLocalUriFetcher(Context context, Uri uri) {
-        return new StreamLocalUriFetcher(context, uri);
-    }
-
-    @Override
-    protected DataFetcher<InputStream> getAssetPathFetcher(Context context, String assetPath) {
-        return new StreamAssetPathFetcher(context.getApplicationContext().getAssets(), assetPath);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUrlLoader.java
deleted file mode 100644
index ec6a207d4..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUrlLoader.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.bumptech.glide.load.model.stream;
-
-import android.content.Context;
-
-import com.bumptech.glide.load.model.GenericLoaderFactory;
-import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.model.UrlLoader;
-
-import java.io.InputStream;
-import java.net.URL;
-
-/**
- * A wrapper class that translates {@link java.net.URL} objects into {@link com.bumptech.glide.load.model.GlideUrl}
- * objects and then uses the wrapped {@link com.bumptech.glide.load.model.ModelLoader} for
- * {@link com.bumptech.glide.load.model.GlideUrl}s to load the {@link java.io.InputStream} data.
- */
-public class StreamUrlLoader extends UrlLoader<InputStream> {
-
-    /**
-     * The default factory for {@link com.bumptech.glide.load.model.stream.StreamUrlLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<URL, InputStream> {
-        @Override
-        public ModelLoader<URL, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamUrlLoader(factories.buildModelLoader(GlideUrl.class, InputStream.class));
-        }
-
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
-
-    public StreamUrlLoader(ModelLoader<GlideUrl, InputStream> glideUrlLoader) {
-        super(glideUrlLoader);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
new file mode 100644
index 000000000..5cbda7216
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -0,0 +1,53 @@
+package com.bumptech.glide.load.model.stream;
+
+import android.content.Context;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+
+import java.io.InputStream;
+import java.net.URL;
+
+/**
+ * A wrapper class that translates {@link java.net.URL} objects into {@link
+ * com.bumptech.glide.load.model.GlideUrl} objects and then uses the wrapped {@link
+ * com.bumptech.glide.load.model.ModelLoader} for {@link com.bumptech.glide.load.model.GlideUrl}s to
+ * load the data.
+ */
+public class UrlLoader implements ModelLoader<URL, InputStream> {
+  private final ModelLoader<GlideUrl, InputStream> glideUrlLoader;
+
+  public UrlLoader(ModelLoader<GlideUrl, InputStream> glideUrlLoader) {
+    this.glideUrlLoader = glideUrlLoader;
+  }
+
+  @Override
+  public LoadData<InputStream> buildLoadData(URL model, int width, int height, Options options) {
+    return glideUrlLoader.buildLoadData(new GlideUrl(model), width, height, options);
+  }
+
+  @Override
+  public boolean handles(URL model) {
+    return true;
+  }
+
+  /**
+   * Factory for loading {@link InputStream}s from {@link URL}s.
+   */
+  public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
+
+    @Override
+    public ModelLoader<URL, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java
deleted file mode 100644
index 5481502f5..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.load.resource;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-
-/**
- * A simple {@link com.bumptech.glide.load.ResourceDecoder} that always returns null.
- *
- * @param <T> The type of the data that will be ignored by this class.
- * @param <Z> The type of the decoded resource that will always be null.
- */
-public class NullDecoder<T, Z> implements ResourceDecoder<T, Z> {
-    private static final NullDecoder<?, ?> NULL_DECODER = new NullDecoder<Object, Object>();
-
-    /**
-     * Returns an instance of the NullDecoder for the given types.
-     *
-     * @param <T> The data type.
-     * @param <Z> The resource type.
-     */
-    @SuppressWarnings("unchecked")
-    public static <T, Z> NullDecoder<T, Z> get() {
-        return (NullDecoder<T, Z>) NULL_DECODER;
-    }
-
-    @Override
-    public Resource<Z> decode(T source, int width, int height) {
-        return null;
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java
deleted file mode 100644
index 15de40310..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.load.resource;
-
-import com.bumptech.glide.load.Encoder;
-
-import java.io.OutputStream;
-
-/**
- * A simple {@link com.bumptech.glide.load.Encoder} that never writes data.
- *
- * @param <T> type discarded by this Encoder
- */
-public class NullEncoder<T> implements Encoder<T> {
-    private static final NullEncoder<?> NULL_ENCODER = new NullEncoder<Object>();
-
-    /**
-     * Returns an Encoder for the given data type.
-     *
-     * @param <T> The type of data to be written (or not in this case).
-     */
-    @SuppressWarnings("unchecked")
-    public static <T> Encoder<T> get() {
-        return (Encoder<T>) NULL_ENCODER;
-
-    }
-
-    @Override
-    public boolean encode(T data, OutputStream os) {
-        return false;
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java
deleted file mode 100644
index 8ea6115fb..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.bumptech.glide.load.resource;
-
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.Resource;
-
-import java.io.OutputStream;
-
-/**
- * A simple {@link com.bumptech.glide.load.ResourceEncoder} that never writes data.
- *
- * @param <T> The type of the resource that will always fail to be encoded.
- */
-public class NullResourceEncoder<T> implements ResourceEncoder<T> {
-    private static final NullResourceEncoder<?> NULL_ENCODER = new NullResourceEncoder<Object>();
-
-    /**
-     * Returns a NullResourceEncoder for the given type.
-     *
-     * @param <T> The type of data to be written (or in this case not written).
-     */
-    @SuppressWarnings("unchecked")
-    public static <T> NullResourceEncoder<T> get() {
-        return (NullResourceEncoder<T>) NULL_ENCODER;
-    }
-
-    @Override
-    public boolean encode(Resource<T> data, OutputStream os) {
-        return false;
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
index 33ccbb8a0..5291061e0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
@@ -1,36 +1,41 @@
 package com.bumptech.glide.load.resource;
 
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Preconditions;
 
 /**
- * Simple wrapper for an arbitrary object which helps to satisfy some of the glide engine's contracts.
- * <b>Suggested usages only include resource object which don't have size and cannot be recycled/closed.</b>
+ * Simple wrapper for an arbitrary object which helps to satisfy some of the glide engine's
+ * contracts. <b>Suggested usages only include resource object which don't have size and cannot be
+ * recycled/closed.</b>
  *
  * @param <T> type of the wrapped resource
  */
 // TODO: there isn't much point in caching these...
 public class SimpleResource<T> implements Resource<T> {
-    protected final T data;
+  protected final T data;
 
-    public SimpleResource(T data) {
-        if (data == null) {
-            throw new NullPointerException("Data must not be null");
-        }
-        this.data = data;
-    }
+  public SimpleResource(T data) {
+    this.data = Preconditions.checkNotNull(data);
+  }
 
-    @Override
-    public final T get() {
-        return data;
-    }
+  @SuppressWarnings("unchecked")
+  @Override
+  public Class<T> getResourceClass() {
+    return (Class<T>) data.getClass();
+  }
 
-    @Override
-    public final int getSize() {
-        return 1;
-    }
+  @Override
+  public final T get() {
+    return data;
+  }
 
-    @Override
-    public void recycle() {
-        // no op
-    }
+  @Override
+  public final int getSize() {
+    return 1;
+  }
+
+  @Override
+  public void recycle() {
+    // no op
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index e4c1aa628..702ed39f0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -3,31 +3,39 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 
+import java.security.MessageDigest;
+
 /**
  * A noop Transformation that simply returns the given resource.
  *
  * @param <T> The type of the resource that will always be returned unmodified.
  */
-public class UnitTransformation<T> implements Transformation<T> {
-    private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();
-
-    /**
-     * Returns a UnitTransformation for the given type.
-     *
-     * @param <T> The type of the resource to be transformed.
-     */
-    @SuppressWarnings("unchecked")
-    public static <T> UnitTransformation<T> get() {
-        return (UnitTransformation<T>) TRANSFORMATION;
-    }
-
-    @Override
-    public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
-        return resource;
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
+public final class UnitTransformation<T> implements Transformation<T> {
+  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();
+
+  /**
+   * Returns a UnitTransformation for the given type.
+   *
+   * @param <T> The type of the resource to be transformed.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> UnitTransformation<T> get() {
+    return (UnitTransformation<T>) TRANSFORMATION;
+  }
+
+  private UnitTransformation() {
+    // Only accessible as a singleton.
+  }
+
+  @Override
+  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+    return resource;
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    // Do nothing.
+  }
+
+  /* Use default implementations of equals and hashcode. */
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java
deleted file mode 100644
index 36c4df17d..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-/**
- * A bitmap decoder for a given resource type.
- *
- * @param <T> The type of resource this decoder can decode a {@link Bitmap} from.
- */
-public interface BitmapDecoder<T> {
-    /**
-     * Returns a decoded bitmap for a given resource and target dimensions.
-     *
-     * @param resource The resource to decode, managed by the caller, no need to clean it up.
-     * @param bitmapPool A bitmap pool that can be used to reuse bitmaps during the load. Any bitmaps created or
-     *                   obtained from the pool other than the bitmap returned by this method should be returned to the
-     *                   pool.
-     * @param outWidth The target width for the returned bitmap (need not match exactly).
-     * @param outHeight The target height for the returned bitmap (need not match exactly).
-     * @param decodeFormat The desired configuration for the returned bitmap.
-     */
-    Bitmap decode(T resource, BitmapPool bitmapPool, int outWidth, int outHeight, DecodeFormat decodeFormat)
-            throws Exception;
-
-    /**
-     * Returns some unique String id that distinguishes this decoder from any other decoder.
-     *
-     * <p>
-     *     This method can return the empty string if for all practical purposes it applies no transformations to the
-     *     data while loading the resource. For {@link android.graphics.Bitmap}s this would mean at a minimum doing no
-     *     downsampling and also probably always producing {@link android.graphics.Bitmap}s with
-     *     {@link android.graphics.Bitmap.Config#ARGB_8888} as their config.
-     * </p>
-     */
-    String getId();
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
new file mode 100644
index 000000000..6b9d9afae
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+
+import java.io.IOException;
+
+/**
+ * Decodes an {@link android.graphics.drawable.BitmapDrawable} for a data type.
+ *
+ * @param <DataType> The type of data that will be decoded.
+ */
+public class BitmapDrawableDecoder<DataType> implements ResourceDecoder<DataType, BitmapDrawable> {
+
+  private final ResourceDecoder<DataType, Bitmap> decoder;
+  private final Resources resources;
+  private final BitmapPool bitmapPool;
+
+  public BitmapDrawableDecoder(Context context, ResourceDecoder<DataType, Bitmap> decoder) {
+    this(context.getResources(), Glide.get(context).getBitmapPool(), decoder);
+  }
+
+  public BitmapDrawableDecoder(Resources resources, BitmapPool bitmapPool,
+      ResourceDecoder<DataType, Bitmap> decoder) {
+    this.resources = Preconditions.checkNotNull(resources);
+    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+    this.decoder = Preconditions.checkNotNull(decoder);
+  }
+
+  @Override
+  public boolean handles(DataType source, Options options) throws IOException {
+    return decoder.handles(source, options);
+  }
+
+  @Override
+  public Resource<BitmapDrawable> decode(DataType source, int width, int height, Options options)
+      throws IOException {
+    Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);
+    if (bitmapResource == null) {
+      return null;
+    }
+
+    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, bitmapResource.get());
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
new file mode 100644
index 000000000..162783822
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import java.io.File;
+
+/**
+ * Encodes {@link android.graphics.drawable.BitmapDrawable}s.
+ */
+public class BitmapDrawableEncoder implements ResourceEncoder<BitmapDrawable> {
+
+  private final BitmapPool bitmapPool;
+  private final ResourceEncoder<Bitmap> encoder;
+
+  public BitmapDrawableEncoder(BitmapPool bitmapPool, ResourceEncoder<Bitmap> encoder) {
+    this.bitmapPool = bitmapPool;
+    this.encoder = encoder;
+  }
+
+  @Override
+  public boolean encode(Resource<BitmapDrawable> data, File file, Options options) {
+    return encoder.encode(new BitmapResource(data.get().getBitmap(), bitmapPool), file, options);
+  }
+
+  @Override
+  public EncodeStrategy getEncodeStrategy(Options options) {
+    return encoder.getEncodeStrategy(options);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index 9d062e173..fc80aa1fa 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -7,29 +7,35 @@
 import com.bumptech.glide.util.Util;
 
 /**
- * A {@link com.bumptech.glide.load.engine.Resource} that wraps an {@link android.graphics.drawable.BitmapDrawable}
- * <p>
- *     This class ensures that every call to {@link #get()}} always returns a new
- *     {@link android.graphics.drawable.BitmapDrawable} to avoid rendering issues if used in multiple views and
- *     is also responsible for returning the underlying {@link android.graphics.Bitmap} to the given
- *     {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is recycled.
- * </p>
+ * A {@link com.bumptech.glide.load.engine.Resource} that wraps an
+ * {@link android.graphics.drawable.BitmapDrawable}
+ *
+ * <p> This class ensures that every call to {@link #get()}} always returns a new
+ * {@link android.graphics.drawable.BitmapDrawable} to avoid rendering issues if used in multiple
+ * views and is also responsible for returning the underlying {@link android.graphics.Bitmap} to the
+ * given {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is
+ * recycled. </p>
  */
 public class BitmapDrawableResource extends DrawableResource<BitmapDrawable> {
-    private final BitmapPool bitmapPool;
+  private final BitmapPool bitmapPool;
 
-    public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
-        super(drawable);
-        this.bitmapPool = bitmapPool;
-    }
+  public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
+    super(drawable);
+    this.bitmapPool = bitmapPool;
+  }
 
-    @Override
-    public int getSize() {
-        return Util.getBitmapByteSize(drawable.getBitmap());
-    }
+  @Override
+  public Class<BitmapDrawable> getResourceClass() {
+    return BitmapDrawable.class;
+  }
 
-    @Override
-    public void recycle() {
-        bitmapPool.put(drawable.getBitmap());
-    }
+  @Override
+  public int getSize() {
+    return Util.getBitmapByteSize(drawable.getBitmap());
+  }
+
+  @Override
+  public void recycle() {
+    bitmapPool.put(drawable.getBitmap());
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
new file mode 100644
index 000000000..6527b931e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -0,0 +1,71 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+
+import java.security.MessageDigest;
+
+/**
+ * Transforms {@link android.graphics.drawable.BitmapDrawable}s.
+ */
+public class BitmapDrawableTransformation implements Transformation<BitmapDrawable> {
+
+  private final Context context;
+  private final BitmapPool bitmapPool;
+  private final Transformation<Bitmap> wrapped;
+
+  public BitmapDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
+    this(context, Glide.get(context).getBitmapPool(), wrapped);
+  }
+
+  // Visible for testing.
+  BitmapDrawableTransformation(Context context, BitmapPool bitmapPool,
+      Transformation<Bitmap> wrapped) {
+    this.context = context.getApplicationContext();
+    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+  }
+
+  @Override
+  public Resource<BitmapDrawable> transform(Resource<BitmapDrawable> drawableResourceToTransform,
+      int outWidth, int outHeight) {
+    BitmapDrawable drawableToTransform = drawableResourceToTransform.get();
+    Bitmap bitmapToTransform = drawableToTransform.getBitmap();
+
+    BitmapResource bitmapResourceToTransform = BitmapResource.obtain(bitmapToTransform, bitmapPool);
+    Resource<Bitmap> transformedBitmapResource =
+        wrapped.transform(bitmapResourceToTransform, outWidth, outHeight);
+
+    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
+      return drawableResourceToTransform;
+    } else {
+      return LazyBitmapDrawableResource.obtain(context, transformedBitmapResource.get());
+    }
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof BitmapDrawableTransformation) {
+      BitmapDrawableTransformation other = (BitmapDrawableTransformation) o;
+      return wrapped.equals(other.wrapped);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return wrapped.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    wrapped.updateDiskCacheKey(messageDigest);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index ab6d8df84..d769ae12a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -3,67 +3,102 @@
 import android.graphics.Bitmap;
 import android.util.Log;
 
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
 
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
 import java.io.OutputStream;
 
 /**
- * An {@link com.bumptech.glide.load.ResourceEncoder} that writes {@link android.graphics.Bitmap}s to
- * {@link java.io.OutputStream}s.
+ * An {@link com.bumptech.glide.load.ResourceEncoder} that writes {@link android.graphics.Bitmap}s
+ * to {@link java.io.OutputStream}s.
  *
- * <p>
- *     {@link android.graphics.Bitmap}s that return true from {@link android.graphics.Bitmap#hasAlpha()}} are written
- *     using {@link android.graphics.Bitmap.CompressFormat#PNG} to preserve alpha and all other bitmaps are written
- *     using {@link android.graphics.Bitmap.CompressFormat#JPEG}.
- * </p>
+ * <p> {@link android.graphics.Bitmap}s that return true from
+ * {@link android.graphics.Bitmap#hasAlpha ()}} are written using
+ * {@link android.graphics.Bitmap.CompressFormat#PNG}
+ * to preserve alpha and all other bitmaps are written using
+ * {@link android.graphics.Bitmap.CompressFormat#JPEG}. </p>
  *
- * @see android.graphics.Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
+ * @see android.graphics.Bitmap#compress(android.graphics.Bitmap.CompressFormat, int,
+ * java.io.OutputStream)
  */
 public class BitmapEncoder implements ResourceEncoder<Bitmap> {
-    private static final String TAG = "BitmapEncoder";
-    private static final int DEFAULT_COMPRESSION_QUALITY = 90;
-    private Bitmap.CompressFormat compressFormat;
-    private int quality;
+  /**
+   * An integer option between 0 and 100 that is used as the compression quality.
+   *
+   * <p> Defaults to 90. </p>
+   */
+  public static final Option<Integer> COMPRESSION_QUALITY = Option.memory(
+      "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionQuality", 90);
 
-    public BitmapEncoder() {
-        this(null, DEFAULT_COMPRESSION_QUALITY);
-    }
+  /**
+   * An {@link android.graphics.Bitmap.CompressFormat} option used as the format to encode
+   * the {@link android.graphics.Bitmap}.
+   *
+   * <p> Defaults to {@link android.graphics.Bitmap.CompressFormat#JPEG} for images without alpha
+   * and {@link android.graphics.Bitmap.CompressFormat#PNG} for images with alpha. </p>
+   */
+  public static final Option<Bitmap.CompressFormat> COMPRESSION_FORMAT = Option.memory(
+      "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionFormat");
 
-    public BitmapEncoder(Bitmap.CompressFormat compressFormat, int quality) {
-        this.compressFormat = compressFormat;
-        this.quality = quality;
-    }
+  private static final String TAG = "BitmapEncoder";
 
-    @Override
-    public boolean encode(Resource<Bitmap> resource, OutputStream os) {
-        final Bitmap bitmap = resource.get();
+  @Override
+  public boolean encode(Resource<Bitmap> resource, File file, Options options) {
+    final Bitmap bitmap = resource.get();
 
-        long start = LogTime.getLogTime();
-        Bitmap.CompressFormat format = getFormat(bitmap);
-        bitmap.compress(format, quality, os);
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Compressed with type: " + format + " of size " + Util.getBitmapByteSize(bitmap) + " in "
-                    + LogTime.getElapsedMillis(start));
+    long start = LogTime.getLogTime();
+    Bitmap.CompressFormat format = getFormat(bitmap, options);
+    int quality = options.get(COMPRESSION_QUALITY);
+
+    boolean success = false;
+    OutputStream os = null;
+    try {
+      os = new FileOutputStream(file);
+      bitmap.compress(format, quality, os);
+      os.close();
+      success = true;
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to encode Bitmap", e);
+      }
+    } finally {
+      if (os != null) {
+        try {
+          os.close();
+        } catch (IOException e) {
+          // Do nothing.
         }
-        return true;
+      }
     }
 
-    @Override
-    public String getId() {
-        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Compressed with type: " + format + " of size " + Util.getBitmapByteSize(bitmap)
+          + " in " + LogTime.getElapsedMillis(start));
     }
+    return success;
+  }
 
-    private Bitmap.CompressFormat getFormat(Bitmap bitmap) {
-        if (compressFormat != null) {
-            return compressFormat;
-        } else if (bitmap.hasAlpha()) {
-            return Bitmap.CompressFormat.PNG;
-        } else {
-            return Bitmap.CompressFormat.JPEG;
-        }
+  private Bitmap.CompressFormat getFormat(Bitmap bitmap, Options options) {
+    Bitmap.CompressFormat format = options.get(COMPRESSION_FORMAT);
+    if (format != null) {
+      return format;
+    } else if (bitmap.hasAlpha()) {
+      return Bitmap.CompressFormat.PNG;
+    } else {
+      return Bitmap.CompressFormat.JPEG;
     }
+  }
 
+  @Override
+  public EncodeStrategy getEncodeStrategy(Options options) {
+    return EncodeStrategy.TRANSFORMED;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 10785c6bb..4753d2476 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -1,58 +1,58 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.Nullable;
 
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 
 /**
  * A resource wrapping a {@link android.graphics.Bitmap} object.
  */
 public class BitmapResource implements Resource<Bitmap> {
-    private final Bitmap bitmap;
-    private final BitmapPool bitmapPool;
-
-    /**
-     * Returns a new {@link BitmapResource} wrapping the given {@link Bitmap} if the Bitmap is non-null or null if the
-     * given Bitmap is null.
-     *
-     * @param bitmap A Bitmap.
-     * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
-     */
-    public static BitmapResource obtain(Bitmap bitmap, BitmapPool bitmapPool) {
-        if (bitmap == null) {
-            return null;
-        } else {
-            return new BitmapResource(bitmap, bitmapPool);
-        }
-    }
-
-    public BitmapResource(Bitmap bitmap, BitmapPool bitmapPool) {
-        if (bitmap == null) {
-            throw new NullPointerException("Bitmap must not be null");
-        }
-        if (bitmapPool == null) {
-            throw new NullPointerException("BitmapPool must not be null");
-        }
-        this.bitmap = bitmap;
-        this.bitmapPool = bitmapPool;
-    }
-
-    @Override
-    public Bitmap get() {
-        return bitmap;
-    }
-
-    @Override
-    public int getSize() {
-        return Util.getBitmapByteSize(bitmap);
-    }
-
-    @Override
-    public void recycle() {
-        if (!bitmapPool.put(bitmap)) {
-            bitmap.recycle();
-        }
+  private final Bitmap bitmap;
+  private final BitmapPool bitmapPool;
+
+  /**
+   * Returns a new {@link BitmapResource} wrapping the given {@link Bitmap} if the Bitmap is
+   * non-null or null if the given Bitmap is null.
+   *
+   * @param bitmap     A Bitmap.
+   * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
+   */
+  @Nullable
+  public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPool) {
+    if (bitmap == null) {
+      return null;
+    } else {
+      return new BitmapResource(bitmap, bitmapPool);
     }
+  }
+
+  public BitmapResource(Bitmap bitmap, BitmapPool bitmapPool) {
+    this.bitmap = Preconditions.checkNotNull(bitmap, "Bitmap must not be null");
+    this.bitmapPool = Preconditions.checkNotNull(bitmapPool, "BitmapPool must not be null");
+  }
+
+  @Override
+  public Class<Bitmap> getResourceClass() {
+    return Bitmap.class;
+  }
+
+  @Override
+  public Bitmap get() {
+    return bitmap;
+  }
+
+  @Override
+  public int getSize() {
+    return Util.getBitmapByteSize(bitmap);
+  }
+
+  @Override
+  public void recycle() {
+    bitmapPool.put(bitmap);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index c3624b1c9..cdd367c82 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -2,20 +2,27 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Util;
 
 /**
- * A simple {@link com.bumptech.glide.load.Transformation} for transforming {@link android.graphics.Bitmap}s that
- * abstracts away dealing with {@link com.bumptech.glide.load.engine.Resource} objects for subclasses.
+ * A simple {@link com.bumptech.glide.load.Transformation} for transforming
+ * {@link android.graphics.Bitmap}s that abstracts away dealing with
+ * {@link com.bumptech.glide.load.engine.Resource} objects for subclasses.
  *
  * Use cases will look something like this:
  * <pre>
  * <code>
  * public class FillSpace extends BaseBitmapTransformation {
+ *     private static final String ID = "com.bumptech.glide.transformations.FillSpace";
+ *     private static final String ID_BYTES = ID.getBytes(STRING_CHARSET_NAME);
+ *
  *     {@literal @Override}
  *     public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
  *         if (toTransform.getWidth() == outWidth && toTransform.getHeight() == outHeight) {
@@ -24,52 +31,87 @@
  *
  *         return Bitmap.createScaledBitmap(toTransform, outWidth, outHeight, true);
  *     }
+ *
+ *     {@literal @Override}
+ *     public void equals(Object o) {
+ *       return o instanceof FillSpace;
+ *     }
+ *
+ *     {@literal @Override}
+ *     public int hashCode() {
+ *       return ID.hashCode();
+ *     }
+ *
+ *     {@literal @Override}
+ *     public void updateDiskCacheKey(MessageDigest messageDigest)
+ *         throws UnsupportedEncodingException {
+ *       messageDigest.update(ID_BYTES);
+ *     }
  * }
  * </code>
  * </pre>
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
-    private BitmapPool bitmapPool;
+  private final BitmapPool bitmapPool;
 
-    public BitmapTransformation(Context context) {
-        this(Glide.get(context).getBitmapPool());
-    }
+  public BitmapTransformation(Context context) {
+    this(Glide.get(context).getBitmapPool());
+  }
 
-    public BitmapTransformation(BitmapPool bitmapPool) {
-        this.bitmapPool = bitmapPool;
-    }
-
-    @Override
-    public final Resource<Bitmap> transform(Resource<Bitmap> resource, int outWidth, int outHeight) {
-        if (outWidth <= 0 || outHeight <= 0) {
-            throw new IllegalArgumentException("Cannot apply transformation on width: " + outWidth + " or height: "
-                    + outHeight + " less than or equal to zero");
-        }
-        Bitmap toTransform = resource.get();
-        Bitmap transformed = transform(bitmapPool, toTransform, outWidth, outHeight);
+  public BitmapTransformation(BitmapPool bitmapPool) {
+    this.bitmapPool = bitmapPool;
+  }
 
-        final Resource<Bitmap> result;
-        if (toTransform.equals(transformed)) {
-            result = resource;
-        } else {
-            result = BitmapResource.obtain(transformed, bitmapPool);
-        }
+  @Override
+  public final Resource<Bitmap> transform(Resource<Bitmap> resource, int outWidth, int outHeight) {
+    if (!Util.isValidDimensions(outWidth, outHeight)) {
+      throw new IllegalArgumentException(
+          "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
+              + " less than or equal to zero and not Target.SIZE_ORIGINAL");
+    }
+    Bitmap toTransform = resource.get();
+    int targetWidth = outWidth == Target.SIZE_ORIGINAL ? toTransform.getWidth() : outWidth;
+    int targetHeight = outHeight == Target.SIZE_ORIGINAL ? toTransform.getHeight() : outHeight;
+    Bitmap transformed = transform(bitmapPool, toTransform, targetWidth, targetHeight);
 
-        return result;
+    final Resource<Bitmap> result;
+    if (toTransform.equals(transformed)) {
+      result = resource;
+    } else {
+      result = BitmapResource.obtain(transformed, bitmapPool);
     }
+    return result;
+  }
 
-    /**
-     * Transforms the given {@link android.graphics.Bitmap} based on the given dimensions and returns the transformed
-     * result.
-     *
-     * @param pool A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can be used to obtain and
-     *             return intermediate {@link Bitmap}s used in this transformation. For every
-     *             {@link android.graphics.Bitmap} obtained from the pool during this transformation, a
-     *             {@link android.graphics.Bitmap} must also be returned.
-     * @param toTransform The {@link android.graphics.Bitmap} to transform.
-     * @param outWidth The ideal width of the transformed bitmap (does not need to match exactly).
-     * @param outHeight The ideal height of the transformed bitmap (does not need to match exactly).
-     */
-    protected abstract Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight);
+  /**
+   * Transforms the given {@link android.graphics.Bitmap} based on the given dimensions and returns
+   * the transformed result.
+   *
+   * <p>The provided Bitmap, toTransform, should not be recycled or returned to the pool. Glide will
+   * automatically recycle and/or reuse toTransform if the transformation returns a different
+   * Bitmap. Similarly implementations should never recycle or return Bitmaps that are returned as
+   * the result of this method. Recycling or returning the provided and/or the returned Bitmap to
+   * the pool will lead to a variety of runtime exceptions and drawing errors. See #408 for an
+   * example. If the implementation obtains and discards intermediate Bitmaps, they may safely be
+   * returned to the BitmapPool and/or recycled.
+   *
+   * <p>outWidth and outHeight will never be
+   * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL},
+   * this class converts them to be the size of the Bitmap we're going to transform before calling
+   * this method.
+   *
+   * @param pool        A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can
+   *                    be used to obtain and return intermediate {@link Bitmap}s used in this
+   *                    transformation. For every {@link android.graphics.Bitmap} obtained from the
+   *                    pool during this transformation, a {@link android.graphics.Bitmap} must also
+   *                    be returned.
+   * @param toTransform The {@link android.graphics.Bitmap} to transform.
+   * @param outWidth    The ideal width of the transformed bitmap (the transformed width does not
+   *                    need to match exactly).
+   * @param outHeight   The ideal height of the transformed bitmap (the transformed heightdoes not
+   *                    need to match exactly).
+   */
+  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
+      int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
new file mode 100644
index 000000000..6a89df27a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.TransitionOptions;
+
+/**
+ * Provides {@link Bitmap} specific animation options.
+ *
+ * TODO: we should probably just use GenericAnimationOptions instead.
+ */
+public final class BitmapTransitionOptions extends TransitionOptions<BitmapTransitionOptions,
+    Bitmap> {
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
new file mode 100644
index 000000000..b8cb4624a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.ByteBufferUtil;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link java.nio.ByteBuffer ByteBuffers}.
+ */
+public class ByteBufferBitmapDecoder implements ResourceDecoder<ByteBuffer, Bitmap> {
+  private final Downsampler downsampler;
+
+  public ByteBufferBitmapDecoder(Downsampler downsampler) {
+    this.downsampler = downsampler;
+  }
+
+  @Override
+  public boolean handles(ByteBuffer source, Options options) throws IOException {
+    return downsampler.handles(source);
+  }
+
+  @Override
+  public Resource<Bitmap> decode(ByteBuffer source, int width, int height, Options options)
+      throws IOException {
+    InputStream is = ByteBufferUtil.toStream(source);
+    return downsampler.decode(is, width, height, options);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index 62eda0fab..c81d59b9b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -2,40 +2,51 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
+import java.security.MessageDigest;
+
 /**
- * Scale the image so that either the width of the image matches the given width and the height of the image is
- * greater than the given height or vice versa, and then crop the larger dimension to match the given dimension.
+ * Scale the image so that either the width of the image matches the given width and the height of
+ * the image is greater than the given height or vice versa, and then crop the larger dimension to
+ * match the given dimension.
  *
  * Does not maintain the image's aspect ratio
  */
 public class CenterCrop extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  public CenterCrop(Context context) {
+    super(context);
+  }
+
+  public CenterCrop(BitmapPool bitmapPool) {
+    super(bitmapPool);
+  }
+
+  // Bitmap doesn't implement equals, so == and .equals are equivalent here.
+  @SuppressWarnings("PMD.CompareObjectsWithEquals")
+  @Override
+  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
+      int outHeight) {
+    return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o instanceof CenterCrop;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode();
+  }
 
-    public CenterCrop(Context context) {
-        super(context);
-    }
-
-    public CenterCrop(BitmapPool bitmapPool) {
-        super(bitmapPool);
-    }
-
-    // Bitmap doesn't implement equals, so == and .equals are equivalent here.
-    @SuppressWarnings("PMD.CompareObjectsWithEquals")
-    @Override
-    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-        final Bitmap toReuse = pool.get(outWidth, outHeight, toTransform.getConfig() != null
-                ? toTransform.getConfig() : Bitmap.Config.ARGB_8888);
-        Bitmap transformed = TransformationUtils.centerCrop(toReuse, toTransform, outWidth, outHeight);
-        if (toReuse != null && toReuse != transformed && !pool.put(toReuse)) {
-            toReuse.recycle();
-        }
-        return transformed;
-    }
-
-    @Override
-    public String getId() {
-        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";
-    }
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
new file mode 100644
index 000000000..39b602969
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import java.security.MessageDigest;
+
+/**
+ * A Glide {@link BitmapTransformation} to circle crop an image.  Behaves similar to a
+ * {@link FitCenter} transform, but the resulting image is masked to a circle.
+ *
+ * <p> Uses a PorterDuff blend mode, see http://ssp.impulsetrain.com/porterduff.html. </p>
+ */
+public class CircleCrop extends BitmapTransformation {
+  // The version of this transformation, incremented to correct an error in a previous version.
+  // See #455.
+  private static final int VERSION = 1;
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  public CircleCrop(Context context) {
+    super(context);
+  }
+
+  public CircleCrop(BitmapPool bitmapPool) {
+    super(bitmapPool);
+  }
+
+  // Bitmap doesn't implement equals, so == and .equals are equivalent here.
+  @SuppressWarnings("PMD.CompareObjectsWithEquals")
+  @Override
+  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
+      int outHeight) {
+    return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o instanceof CircleCrop;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
new file mode 100644
index 000000000..0ab010b53
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -0,0 +1,187 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+/**
+ * Indicates the algorithm to use when downsampling images.
+ */
+public abstract class DownsampleStrategy {
+
+  /**
+   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
+   * exactly equal to the requested size and the other dimension is less than or equal to the
+   * requested size.
+   *
+   * <p>This method will upscale if the requested width and height are greater than the source width
+   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   *
+   * <p>On pre-KitKat devices, this is equivalent to {@link #AT_MOST} because only power of
+   * two downsampling can be used.
+   */
+  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+
+  /**
+   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
+   * exactly equal to the requested size and the other dimension is greater than or equal to
+   * the requested size.
+   *
+   * <p>This method will upscale if the requested width and height are greater than the source width
+   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   *
+   * <p>On pre-KitKat devices, this is equivalent to {@link #AT_LEAST} because only power of
+   * two downsampling can be used.
+   */
+  public static final DownsampleStrategy CENTER_OUTSIDE = new CenterOutside();
+
+  /**
+   * Downsamples so the image's smallest dimension is between the given dimensions and 2x the given
+   * dimensions, with no size restrictions on the image's largest dimension.
+   */
+  public static final DownsampleStrategy AT_LEAST = new AtLeast();
+
+  /**
+   * Downsamples so the image's largest dimension is between 1/2 the given dimensions and the given
+   * dimensions, with no restrictions on the image's smallest dimension.
+   */
+  public static final DownsampleStrategy AT_MOST = new AtMost();
+
+  /**
+   * Performs no downsampling or scaling.
+   */
+  public static final DownsampleStrategy NONE = new None();
+
+  /**
+   * Default strategy, currently {@link #AT_LEAST}.
+   */
+  public static final DownsampleStrategy DEFAULT = AT_LEAST;
+
+  /**
+   * Returns a float (0, +infinity) indicating a scale factor to apply to the source
+   * width and height when displayed in the requested width and height.
+   *
+   * <p>The returned scale factor will be split into a power of two sample size applied via
+   * {@link android.graphics.BitmapFactory.Options#inSampleSize} and a float scale factor applied
+   * after downsampling via {@link android.graphics.BitmapFactory.Options#inTargetDensity} and
+   * {@link android.graphics.BitmapFactory.Options#inDensity}. Because of rounding errors the scale
+   * factor may not be applied precisely.
+   *
+   * <p>The float scaling factor will only be applied on KitKat+. Prior to KitKat, only the power
+   * of two downsampling will be applied.
+   *
+   * @param sourceWidth   The width in pixels of the image to be downsampled.
+   * @param sourceHeight  The height in pixels of the image to be downsampled.
+   * @param requestedWidth  The width in pixels of the view/target the image will be displayed in.
+   * @param requestedHeight The height in pixels of the view/target the image will be displayed in.
+   */
+  public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+      int requestedHeight);
+
+  /**
+   * Returns a non-null {@link SampleSizeRounding} to use to resolve rounding errors and conflicts
+   * between scaling for the width and the height of the image.
+   *
+   * @param sourceWidth   The width in pixels of the image to be downsampled.
+   * @param sourceHeight  The height in pixels of the image to be downsampled.
+   * @param requestedWidth  The width in pixels of the view/target the image will be displayed in.
+   * @param requestedHeight The height in pixels of the view/target the image will be displayed in.
+   */
+  public abstract SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+      int requestedWidth, int requestedHeight);
+
+  private static class CenterInside extends DownsampleStrategy {
+
+    @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+      float widthPercentage = requestedWidth / (float) sourceWidth;
+      float heightPercentage = requestedHeight / (float) sourceHeight;
+      return Math.min(widthPercentage, heightPercentage);
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.QUALITY;
+    }
+  }
+
+  private static class CenterOutside extends DownsampleStrategy {
+     @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+      float widthPercentage = requestedWidth / (float) sourceWidth;
+      float heightPercentage = requestedHeight / (float) sourceHeight;
+      return Math.max(widthPercentage, heightPercentage);
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.QUALITY;
+    }
+  }
+
+  private static class AtLeast extends DownsampleStrategy {
+
+    @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+      int minIntegerFactor = Math.min(sourceHeight / requestedHeight, sourceWidth / requestedWidth);
+      return minIntegerFactor == 0 ? 1f : 1f / Integer.highestOneBit(minIntegerFactor);
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.QUALITY;
+    }
+  }
+
+  private static class AtMost extends DownsampleStrategy {
+    @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+      int maxIntegerFactor = (int) Math.ceil(Math.max(sourceHeight / (float) requestedHeight,
+              sourceWidth / (float) requestedWidth));
+      int lesserOrEqualSampleSize = Math.max(1, Integer.highestOneBit(maxIntegerFactor));
+      int greaterOrEqualSampleSize =
+          lesserOrEqualSampleSize << (lesserOrEqualSampleSize < maxIntegerFactor ? 1 : 0);
+      return 1f / greaterOrEqualSampleSize;
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.MEMORY;
+    }
+  }
+
+  private static class None extends DownsampleStrategy {
+     @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+      return 1f;
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.QUALITY;
+    }
+  }
+
+  /**
+   * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage
+   * or higher quality.
+   */
+  public enum SampleSizeRounding {
+    /**
+     * Prefer to round the sample size up so that the image is downsampled to smaller than the
+     * requested size to use less memory.
+     */
+    MEMORY,
+    /**
+     * Prefer to round the sample size down so that the image is downsampled to larger than the
+     * requested size to maintain quality at the expense of extra memory usage.
+     */
+    QUALITY,
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 904a7c45b..065e9796a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -4,362 +4,522 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.os.Build;
+import android.util.DisplayMetrics;
 import android.util.Log;
 
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.util.ByteArrayPool;
-import com.bumptech.glide.util.ExceptionCatchingInputStream;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.SampleSizeRounding;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Queue;
 import java.util.Set;
 
 /**
- * A base class with methods for loading and decoding images from InputStreams.
+ * Downsamples, decodes, and rotates images according to their exif orientation.
  */
-public abstract class Downsampler implements BitmapDecoder<InputStream> {
-    private static final String TAG = "Downsampler";
-
-    private static final Set<ImageHeaderParser.ImageType> TYPES_THAT_USE_POOL = EnumSet.of(
-            ImageHeaderParser.ImageType.JPEG, ImageHeaderParser.ImageType.PNG_A, ImageHeaderParser.ImageType.PNG);
-
-    private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);
-
-    /**
-     * Load and scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image
-     * will be greater than or equal to the given width and height.
-     */
-    public static final Downsampler AT_LEAST = new Downsampler() {
-        @Override
-        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
-            return Math.min(inHeight / outHeight, inWidth / outWidth);
-        }
-
-        @Override
-        public String getId() {
-            return "AT_LEAST.com.bumptech.glide.load.data.bitmap";
-        }
-    };
-
-    /**
-     * Load and scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image
-     * will be less than or equal to the given width and height.
-     *
-     */
-    public static final Downsampler AT_MOST = new Downsampler() {
-        @Override
-        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
-            return Math.max(inHeight / outHeight, inWidth / outWidth);
-        }
-
-        @Override
-        public String getId() {
-            return "AT_MOST.com.bumptech.glide.load.data.bitmap";
-        }
-    };
-
-    /**
-     * Load the image at its original size.
-     */
-    public static final Downsampler NONE = new Downsampler() {
-        @Override
-        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
-            return 0;
-        }
-
-        @Override
-        public String getId() {
-            return "NONE.com.bumptech.glide.load.data.bitmap";
-        }
-    };
-
-    // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but will resize up to
-    // this amount if necessary.
-    private static final int MARK_POSITION = 5 * 1024 * 1024;
-
-
-    /**
-     * Load the image for the given InputStream. If a recycled Bitmap whose dimensions exactly match those of the image
-     * for the given InputStream is available, the operation is much less expensive in terms of memory.
-     *
-     * <p>
-     *     Note - this method will throw an exception of a Bitmap with dimensions not matching
-     *     those of the image for the given InputStream is provided.
-     * </p>
-     *
-     * @param is An {@link InputStream} to the data for the image.
-     * @param pool A pool of recycled bitmaps.
-     * @param outWidth The width the final image should be close to.
-     * @param outHeight The height the final image should be close to.
-     * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null.
-     */
-    @SuppressWarnings("resource")
-    // see BitmapDecoder.decode
+public final class Downsampler {
+  private static final String TAG = "Downsampler";
+  /**
+   * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction
+   * with the image format to determine the {@link android.graphics.Bitmap.Config} to provide to
+   * {@link android.graphics.BitmapFactory.Options#inPreferredConfig} when decoding the image.
+   */
+  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(
+      "com.bumptech.glide.load.resource.bitmap.Downsampler.DecodeFormat", DecodeFormat.DEFAULT);
+  /**
+   * Indicates the {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option that
+   * will be used to calculate the sample size to use to downsample an image given the original
+   * and target dimensions of the image.
+   */
+  public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
+          DownsampleStrategy.AT_LEAST);
+
+  private static final DecodeCallbacks EMPTY_CALLBACKS = new DecodeCallbacks() {
     @Override
-    public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeight, DecodeFormat decodeFormat) {
-        final ByteArrayPool byteArrayPool = ByteArrayPool.get();
-        final byte[] bytesForOptions = byteArrayPool.getBytes();
-        final byte[] bytesForStream = byteArrayPool.getBytes();
-        final BitmapFactory.Options options = getDefaultOptions();
-
-        // TODO(#126): when the framework handles exceptions better, consider removing.
-        final ExceptionCatchingInputStream stream =
-                ExceptionCatchingInputStream.obtain(new RecyclableBufferedInputStream(is, bytesForStream));
-        try {
-            stream.mark(MARK_POSITION);
-            int orientation = 0;
-            try {
-                orientation = new ImageHeaderParser(stream).getOrientation();
-            } catch (IOException e) {
-                if (Log.isLoggable(TAG, Log.WARN)) {
-                    Log.w(TAG, "Cannot determine the image orientation from header", e);
-                }
-            } finally {
-                try {
-                    stream.reset();
-                } catch (IOException e) {
-                    if (Log.isLoggable(TAG, Log.WARN)) {
-                        Log.w(TAG, "Cannot reset the input stream", e);
-                    }
-                }
-            }
-
-            options.inTempStorage = bytesForOptions;
-
-            final int[] inDimens = getDimensions(stream, options);
-            final int inWidth = inDimens[0];
-            final int inHeight = inDimens[1];
-
-            final int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
-            final int sampleSize = getRoundedSampleSize(degreesToRotate, inWidth, inHeight, outWidth, outHeight);
-
-            final Bitmap downsampled =
-                    downsampleWithSize(stream, options, pool, inWidth, inHeight, sampleSize,
-                            decodeFormat);
-
-            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch
-            // and log a stack trace but still return a non null bitmap. To avoid displaying partially decoded bitmaps,
-            // we catch exceptions reading from the stream in our ExceptionCatchingInputStream and throw them here.
-            final Exception streamException = stream.getException();
-            if (streamException != null) {
-                throw new RuntimeException(streamException);
-            }
-
-            Bitmap rotated = null;
-            if (downsampled != null) {
-                rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation);
-
-                if (!downsampled.equals(rotated) && !pool.put(downsampled)) {
-                    downsampled.recycle();
-                }
-            }
-
-            return rotated;
-        } finally {
-            byteArrayPool.releaseBytes(bytesForOptions);
-            byteArrayPool.releaseBytes(bytesForStream);
-            stream.release();
-            releaseOptions(options);
-        }
+    public void onObtainBounds() {
+      // Do nothing.
     }
 
-    private int getRoundedSampleSize(int degreesToRotate, int inWidth, int inHeight, int outWidth, int outHeight) {
-        final int exactSampleSize;
-        if (degreesToRotate == 90 || degreesToRotate == 270) {
-            // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is
-            // decreased to near our target's height and the image height is decreased to near our target width.
-            exactSampleSize = getSampleSize(inHeight, inWidth, outWidth, outHeight);
-        } else {
-            exactSampleSize = getSampleSize(inWidth, inHeight, outWidth, outHeight);
-        }
-
-        // BitmapFactory only accepts powers of 2, so it will round down to the nearest power of two that is less than
-        // or equal to the sample size we provide. Because we need to estimate the final image width and height to
-        // re-use Bitmaps, we mirror BitmapFactory's calculation here. For bug, see issue #224. For algorithm see
-        // http://stackoverflow.com/a/17379704/800716.
-        final int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize - 1);
-
-        // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code than 0.
-        return Math.max(1, powerOfTwoSampleSize);
+    @Override
+    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException {
+      // Do nothing.
+    }
+  };
+  private static final Set<ImageHeaderParser.ImageType> TYPES_THAT_USE_POOL_PRE_KITKAT =
+      Collections.unmodifiableSet(
+          EnumSet.of(
+              ImageHeaderParser.ImageType.JPEG,
+              ImageHeaderParser.ImageType.PNG_A,
+              ImageHeaderParser.ImageType.PNG
+          )
+      );
+  private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);
+  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer
+  // but will resize up to this amount if necessary.
+  private static final int MARK_POSITION = 5 * 1024 * 1024;
+
+  private final BitmapPool bitmapPool;
+  private final DisplayMetrics displayMetrics;
+  private final ByteArrayPool byteArrayPool;
+
+  public Downsampler(DisplayMetrics displayMetrics, BitmapPool bitmapPool,
+      ByteArrayPool byteArrayPool) {
+    this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
+    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
+  }
+
+  public boolean handles(InputStream is) {
+    // We expect Downsampler to handle any available type Android supports.
+    return true;
+  }
+
+  public boolean handles(ByteBuffer byteBuffer) {
+    // We expect downsampler to handle any available type Android supports.
+    return true;
+  }
+
+  /**
+   * Returns a Bitmap decoded from the given {@link InputStream} that is rotated to match any EXIF
+   * data present in the stream and that is downsampled according to the given dimensions and any
+   * provided  {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
+   *
+   * @see #decode(InputStream, int, int, Options, DecodeCallbacks)
+   */
+  public Resource<Bitmap> decode(InputStream is, int outWidth, int outHeight,
+      Options options) throws IOException {
+    return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);
+  }
+
+  /**
+   * Returns a Bitmap decoded from the given {@link InputStream} that is rotated to match any EXIF
+   * data present in the stream and that is downsampled according to the given dimensions and any
+   * provided  {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
+   *
+   * <p> If a Bitmap is present in the
+   * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} whose dimensions exactly match
+   * those of the image for the given InputStream is available, the operation is much less expensive
+   * in terms of memory. </p>
+   *
+   * <p> The provided {@link java.io.InputStream} must return <code>true</code> from
+   * {@link java.io.InputStream#markSupported()} and is expected to support a reasonably large
+   * mark limit to accommodate reading large image headers (~5MB). </p>
+   *
+   * @param is        An {@link InputStream} to the data for the image.
+   * @param requestedWidth  The width the final image should be close to.
+   * @param requestedHeight The height the final image should be close to.
+   * @param options   A set of options that may contain one or more supported options that influence
+   *                  how a Bitmap will be decoded from the given stream.
+   * @param callbacks A set of callbacks allowing callers to optionally respond to various
+   *                  significant events during the decode process.
+   * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is
+   * not null.
+   */
+  @SuppressWarnings("resource")
+  public Resource<Bitmap> decode(InputStream is, int requestedWidth, int requestedHeight,
+      Options options, DecodeCallbacks callbacks) throws IOException {
+    Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports"
+        + " mark()");
+
+    byte[] bytesForOptions = byteArrayPool.get(ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+    BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();
+    bitmapFactoryOptions.inTempStorage = bytesForOptions;
+
+    DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
+    DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
+
+    try {
+      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
+          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight, callbacks);
+      return BitmapResource.obtain(result, bitmapPool);
+    } finally {
+      releaseOptions(bitmapFactoryOptions);
+      byteArrayPool.put(bytesForOptions);
+    }
+  }
+
+  private Bitmap decodeFromWrappedStreams(InputStream is,
+      BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
+      DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,
+      DecodeCallbacks callbacks) throws IOException {
+
+    int[] sourceDimensions = getDimensions(is, options, callbacks);
+    int sourceWidth = sourceDimensions[0];
+    int sourceHeight = sourceDimensions[1];
+    String sourceMimeType = options.outMimeType;
+
+    int orientation = getOrientation(is);
+    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(getOrientation(is));
+
+    options.inPreferredConfig = getConfig(is, decodeFormat);
+    if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
+      options.inDither = true;
+    }
+    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, requestedWidth,
+        requestedHeight, options);
+
+    Bitmap downsampled = downsampleWithSize(is, options, bitmapPool, sourceWidth,
+        sourceHeight, callbacks);
+    callbacks.onDecodeComplete(bitmapPool, downsampled);
+
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      logDecode(sourceWidth, sourceHeight, sourceMimeType, options, downsampled,
+          requestedWidth, requestedHeight);
+    }
+
+    Bitmap rotated = null;
+    if (downsampled != null) {
+      // If we scaled, the Bitmap density will be our inTargetDensity. Here we correct it back to
+      // the expected density dpi.
+      downsampled.setDensity(displayMetrics.densityDpi);
+
+      rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);
+      if (!downsampled.equals(rotated)) {
+        bitmapPool.put(downsampled);
+      }
+    }
+
+    return rotated;
+  }
+
+  // Visible for testing.
+  static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,
+      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight,
+      BitmapFactory.Options options) {
+    // We can't downsample source content if we can't determine its dimensions.
+    if (sourceWidth <= 0 || sourceHeight <= 0) {
+      return;
+    }
+
+    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
+    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
+
+    final float exactScaleFactor;
+    if (degreesToRotate == 90 || degreesToRotate == 270) {
+      // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
+      // width is decreased to near our target's height and the image height is decreased to near
+      // our target width.
+      //noinspection SuspiciousNameCombination
+      exactScaleFactor = downsampleStrategy.getScaleFactor(sourceHeight, sourceWidth,
+          targetWidth, targetHeight);
+    } else {
+      exactScaleFactor =
+          downsampleStrategy.getScaleFactor(sourceWidth, sourceHeight, targetWidth, targetHeight);
+    }
+
+    if (exactScaleFactor <= 0f) {
+      throw new IllegalArgumentException("Cannot scale with factor: " + exactScaleFactor
+          + " from: " + downsampleStrategy);
+    }
+    SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth,
+        sourceHeight, targetWidth, targetHeight);
+    if (rounding == null) {
+      throw new IllegalArgumentException("Cannot round with null rounding");
     }
 
-    private Bitmap downsampleWithSize(ExceptionCatchingInputStream is, BitmapFactory.Options options, BitmapPool pool,
-            int inWidth, int inHeight, int sampleSize, DecodeFormat decodeFormat) {
-        // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-        Bitmap.Config config = getConfig(is, decodeFormat);
-        options.inSampleSize = sampleSize;
-        options.inPreferredConfig = config;
-        if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT) && shouldUsePool(is)) {
-            int targetWidth = (int) Math.ceil(inWidth / (double) sampleSize);
-            int targetHeight = (int) Math.ceil(inHeight / (double) sampleSize);
-            // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-            setInBitmap(options, pool.getDirty(targetWidth, targetHeight, config));
-        }
-        return decodeStream(is, options);
+    int outWidth = (int) (exactScaleFactor * sourceWidth + 0.5f);
+    int outHeight = (int) (exactScaleFactor * sourceHeight + 0.5f);
+
+    int widthScaleFactor = sourceWidth / outWidth;
+    int heightScaleFactor = sourceHeight / outHeight;
+
+    int scaleFactor = rounding == SampleSizeRounding.MEMORY
+        ? Math.max(widthScaleFactor, heightScaleFactor)
+        : Math.min(widthScaleFactor, heightScaleFactor);
+
+    int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
+    if (rounding == SampleSizeRounding.MEMORY && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
+      powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
     }
 
-    private static boolean shouldUsePool(InputStream is) {
-        // On KitKat+, any bitmap can be used to decode any other bitmap.
-        if (Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT) {
-            return true;
-        }
-
-        is.mark(1024);
-        try {
-            final ImageHeaderParser.ImageType type = new ImageHeaderParser(is).getType();
-            // cannot reuse bitmaps when decoding images that are not PNG or JPG.
-            // look at : https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
-            return TYPES_THAT_USE_POOL.contains(type);
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Cannot determine the image type from header", e);
-            }
-        } finally {
-            try {
-                is.reset();
-            } catch (IOException e) {
-                if (Log.isLoggable(TAG, Log.WARN)) {
-                    Log.w(TAG, "Cannot reset the input stream", e);
-                }
-            }
-        }
-        return false;
+    float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
+
+    options.inSampleSize = powerOfTwoSampleSize;
+    // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
+    // densities here so we calculate the final Bitmap size correctly.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      options.inTargetDensity = (int) (1000 * adjustedScaleFactor + 0.5f);
+      options.inDensity = 1000;
+    }
+    if (isScaling(options)) {
+      options.inScaled = true;
+    } else {
+      options.inDensity = options.inTargetDensity = 0;
     }
 
-    private static Bitmap.Config getConfig(InputStream is, DecodeFormat format) {
-        // Changing configs can cause skewing on 4.1, see issue #128.
-        if (format == DecodeFormat.ALWAYS_ARGB_8888 || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
-            return Bitmap.Config.ARGB_8888;
-        }
-
-        boolean hasAlpha = false;
-        // We probably only need 25, but this is safer (particularly since the buffer size is > 1024).
-        is.mark(1024);
-        try {
-            hasAlpha = new ImageHeaderParser(is).hasAlpha();
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Cannot determine whether the image has alpha or not from header for format " + format, e);
-            }
-        } finally {
-            try {
-                is.reset();
-            } catch (IOException e) {
-                if (Log.isLoggable(TAG, Log.WARN)) {
-                    Log.w(TAG, "Cannot reset the input stream", e);
-                }
-            }
-        }
-
-        return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Calculate scaling"
+          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
+          + ", target: [" + targetWidth + "x" + targetHeight + "]"
+          + ", exact scale factor: " + exactScaleFactor
+          + ", power of 2 sample size: " + powerOfTwoSampleSize
+          + ", adjusted scale factor: " + adjustedScaleFactor
+          + ", target density: " + options.inTargetDensity
+          + ", density: " + options.inDensity);
+    }
+  }
+
+  private int getOrientation(InputStream is) throws IOException {
+    is.mark(MARK_POSITION);
+    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
+    try {
+      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Cannot determine the image orientation from header", e);
+      }
+    } finally {
+      is.reset();
+    }
+    return orientation;
+  }
+
+  private Bitmap downsampleWithSize(InputStream is, BitmapFactory.Options options,
+      BitmapPool pool, int sourceWidth, int sourceHeight, DecodeCallbacks callbacks)
+      throws IOException {
+    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
+    if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT)
+        && shouldUsePool(is)) {
+
+      float densityMultiplier = isScaling(options)
+          ? (float) options.inTargetDensity / options.inDensity : 1f;
+
+      int sampleSize = options.inSampleSize;
+      int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
+      int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
+      int expectedWidth = Math.round(downsampledWidth * densityMultiplier);
+      int expectedHeight = Math.round(downsampledHeight * densityMultiplier);
+
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
+            + " [" + sourceWidth + "x" + sourceHeight + "]"
+            + ", sampleSize: " + sampleSize
+            + ", targetDensity: " + options.inTargetDensity
+            + ", density: " + options.inDensity
+            + ", density multiplier: " + densityMultiplier);
+      }
+      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
+      // will be -1 here.
+      if (expectedWidth > 0 && expectedHeight > 0) {
+        setInBitmap(options, pool, expectedWidth, expectedHeight, options.inPreferredConfig);
+      }
+    }
+    return decodeStream(is, options, callbacks);
+  }
+
+  private boolean shouldUsePool(InputStream is) throws IOException {
+    // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
+    // (with the same config).
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      return true;
     }
 
-    /**
-     * Determine the amount of downsampling to use for a load given the dimensions of the image to be downsampled and
-     * the dimensions of the view/target the image will be displayed in.
-     *
-     * @see android.graphics.BitmapFactory.Options#inSampleSize
-     *
-     * @param inWidth The width of the image to be downsampled.
-     * @param inHeight The height of the image to be downsampled.
-     * @param outWidth The width of the view/target the image will be displayed in.
-     * @param outHeight The height of the view/target the imag will be displayed in.
-     * @return An integer to pass in to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect,
-     *          android.graphics.BitmapFactory.Options)}.
-     */
-    protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);
-
-    /**
-     * A method for getting the dimensions of an image from the given InputStream.
-     *
-     * @param is The InputStream representing the image.
-     * @param options The options to pass to
-     *          {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect,
-     *              android.graphics.BitmapFactory.Options)}.
-     * @return an array containing the dimensions of the image in the form {width, height}.
-     */
-    public int[] getDimensions(ExceptionCatchingInputStream is, BitmapFactory.Options options) {
-        options.inJustDecodeBounds = true;
-        decodeStream(is, options);
-        options.inJustDecodeBounds = false;
-        return new int[] { options.outWidth, options.outHeight };
+    is.mark(MARK_POSITION);
+    try {
+      final ImageHeaderParser.ImageType type = new ImageHeaderParser(is, byteArrayPool).getType();
+      // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
+      // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
+      return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Cannot determine the image type from header", e);
+      }
+    } finally {
+      is.reset();
+    }
+    return false;
+  }
+
+  private Bitmap.Config getConfig(InputStream is, DecodeFormat format) throws IOException {
+    // Changing configs can cause skewing on 4.1, see issue #128.
+    if (format == DecodeFormat.PREFER_ARGB_8888
+        || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
+      return Bitmap.Config.ARGB_8888;
     }
 
-    private static Bitmap decodeStream(ExceptionCatchingInputStream is, BitmapFactory.Options options) {
-         if (options.inJustDecodeBounds) {
-             // This is large, but jpeg headers are not size bounded so we need something large enough to minimize
-             // the possibility of not being able to fit enough of the header in the buffer to get the image size so
-             // that we don't fail to load images. The BufferedInputStream will create a new buffer of 2x the
-             // original size each time we use up the buffer space without passing the mark so this is a maximum
-             // bound on the buffer size, not a default. Most of the time we won't go past our pre-allocated 16kb.
-             is.mark(MARK_POSITION);
-         } else {
-             // Once we've read the image header, we no longer need to allow the buffer to expand in size. To avoid
-             // unnecessary allocations reading image data, we fix the mark limit so that it is no larger than our
-             // current buffer size here. See issue #225.
-             is.fixMarkLimit();
-         }
-
-        final Bitmap result = BitmapFactory.decodeStream(is, null, options);
-
-        try {
-            if (options.inJustDecodeBounds) {
-                is.reset();
-            }
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Exception loading inDecodeBounds=" + options.inJustDecodeBounds
-                        + " sample=" + options.inSampleSize, e);
-            }
-        }
-
-        return result;
+    boolean hasAlpha = false;
+    is.mark(MARK_POSITION);
+    try {
+      hasAlpha = new ImageHeaderParser(is, byteArrayPool).hasAlpha();
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Cannot determine whether the image has alpha or not from header"
+            + ", format " + format, e);
+      }
+    } finally {
+      is.reset();
     }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    private static void setInBitmap(BitmapFactory.Options options, Bitmap recycled) {
-        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-            options.inBitmap = recycled;
-        }
+    return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+  }
+
+  /**
+   * A method for getting the dimensions of an image from the given InputStream.
+   *
+   * @param is      The InputStream representing the image.
+   * @param options The options to pass to {@link BitmapFactory#decodeStream(java.io.InputStream,
+   *                android.graphics.Rect, android.graphics.BitmapFactory.Options)}.
+   * @return an array containing the dimensions of the image in the form {width, height}.
+   */
+  private static int[] getDimensions(InputStream is, BitmapFactory.Options options,
+      DecodeCallbacks decodeCallbacks) throws IOException {
+    options.inJustDecodeBounds = true;
+    decodeStream(is, options, decodeCallbacks);
+    options.inJustDecodeBounds = false;
+    return new int[] { options.outWidth, options.outHeight };
+  }
+
+  private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options,
+      DecodeCallbacks callbacks) throws IOException {
+    if (options.inJustDecodeBounds) {
+      is.mark(MARK_POSITION);
+    } else {
+      // Once we've read the image header, we no longer need to allow the buffer to expand in
+      // size. To avoid unnecessary allocations reading image data, we fix the mark limit so that it
+      // is no larger than our current buffer size here. We need to do so immediately before
+      // decoding the full image to avoid having our mark limit overridden by other calls to
+      // markand reset. See issue #225.
+      callbacks.onObtainBounds();
+    }
+    // BitmapFactory.Options out* variables are reset by most calls to decodeStream, successful or
+    // otherwise, so capture here in case we log below.
+    int sourceWidth = options.outWidth;
+    int sourceHeight = options.outHeight;
+    String outMimeType = options.outMimeType;
+    final Bitmap result;
+    try {
+      result = BitmapFactory.decodeStream(is, null, options);
+    } catch (IllegalArgumentException e) {
+      throw newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
     }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    private static synchronized BitmapFactory.Options getDefaultOptions() {
-        BitmapFactory.Options decodeBitmapOptions;
-        synchronized (OPTIONS_QUEUE) {
-            decodeBitmapOptions = OPTIONS_QUEUE.poll();
-        }
-        if (decodeBitmapOptions == null) {
-            decodeBitmapOptions = new BitmapFactory.Options();
-            resetOptions(decodeBitmapOptions);
-        }
-
-        return decodeBitmapOptions;
+    if (options.inJustDecodeBounds) {
+      is.reset();
+
     }
 
-    private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
-        resetOptions(decodeBitmapOptions);
-        synchronized (OPTIONS_QUEUE) {
-            OPTIONS_QUEUE.offer(decodeBitmapOptions);
-        }
+    return result;
+  }
+
+  private static boolean isScaling(BitmapFactory.Options options) {
+    return options.inTargetDensity > 0 && options.inDensity > 0
+        && options.inTargetDensity != options.inDensity;
+  }
+
+  private static void logDecode(int sourceWidth, int sourceHeight, String outMimeType,
+      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight) {
+    Log.v(TAG, "Decoded " + getBitmapString(result)
+        + " from [" + sourceWidth + "x" + sourceHeight + "] " + outMimeType
+        + " with inBitmap " + getInBitmapString(options)
+        + " for [" + requestedWidth + "x" + requestedHeight + "]"
+        + ", sample size: " + options.inSampleSize
+        + ", density: " + options.inDensity
+        + ", target density: " + options.inTargetDensity
+        + ", thread: " + Thread.currentThread().getName());
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  private static String getInBitmapString(BitmapFactory.Options options) {
+    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB
+        ? getBitmapString(options.inBitmap) : null;
+  }
+
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  private static String getBitmapString(Bitmap bitmap) {
+    final String result;
+    if (bitmap == null) {
+      result = null;
+    } else {
+      String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
+          ? " (" + bitmap.getAllocationByteCount() + ")" : "";
+      result = "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
+          + sizeString;
     }
+    return result;
+  }
+
+  // BitmapFactory throws an IllegalArgumentException if any error occurs attempting to decode a
+  // file when inBitmap is non-null, including those caused by partial or corrupt data. We still log
+  // the error because the IllegalArgumentException is supposed to catch errors reusing Bitmaps, so
+  // want some useful log output. In most cases this can be safely treated as a normal IOException.
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentException e,
+      int outWidth, int outHeight, String outMimeType, BitmapFactory.Options options) {
+    return new IOException("Exception decoding bitmap"
+          + ", outWidth: " + outWidth
+          + ", outHeight: " + outHeight
+          + ", outMimeType: " + outMimeType
+          + ", inBitmap: " + getInBitmapString(options), e);
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
+      int height, Bitmap.Config config) {
+    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
+      // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
+      options.inBitmap = bitmapPool.getDirty(width, height, config);
+    }
+  }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
-        decodeBitmapOptions.inTempStorage = null;
-        decodeBitmapOptions.inDither = false;
-        decodeBitmapOptions.inScaled = false;
-        decodeBitmapOptions.inSampleSize = 1;
-        decodeBitmapOptions.inPreferredConfig = null;
-        decodeBitmapOptions.inJustDecodeBounds = false;
-
-        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT)  {
-            decodeBitmapOptions.inBitmap = null;
-            decodeBitmapOptions.inMutable = true;
-        }
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  private static synchronized BitmapFactory.Options getDefaultOptions() {
+    BitmapFactory.Options decodeBitmapOptions;
+    synchronized (OPTIONS_QUEUE) {
+      decodeBitmapOptions = OPTIONS_QUEUE.poll();
+    }
+    if (decodeBitmapOptions == null) {
+      decodeBitmapOptions = new BitmapFactory.Options();
+      resetOptions(decodeBitmapOptions);
+    }
+
+    return decodeBitmapOptions;
+  }
+
+  private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
+    resetOptions(decodeBitmapOptions);
+    synchronized (OPTIONS_QUEUE) {
+      OPTIONS_QUEUE.offer(decodeBitmapOptions);
+    }
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
+    decodeBitmapOptions.inTempStorage = null;
+    decodeBitmapOptions.inDither = false;
+    decodeBitmapOptions.inScaled = false;
+    decodeBitmapOptions.inSampleSize = 1;
+    decodeBitmapOptions.inPreferredConfig = null;
+    decodeBitmapOptions.inJustDecodeBounds = false;
+    decodeBitmapOptions.inDensity = 0;
+    decodeBitmapOptions.inTargetDensity = 0;
+    decodeBitmapOptions.outWidth = 0;
+    decodeBitmapOptions.outHeight = 0;
+    decodeBitmapOptions.outMimeType = null;
+
+    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
+      decodeBitmapOptions.inBitmap = null;
+      decodeBitmapOptions.inMutable = true;
     }
+  }
+
+  /**
+   * Callbacks for key points during decodes.
+   */
+  public interface DecodeCallbacks {
+    void onObtainBounds();
+    void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDataLoadProvider.java
deleted file mode 100644
index af27bc609..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDataLoadProvider.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import android.graphics.Bitmap;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.NullEncoder;
-import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-
-import java.io.File;
-
-/**
- * An {@link com.bumptech.glide.provider.DataLoadProvider} that provides classes for decoding and encoding
- * {@link android.graphics.Bitmap}s from {@link android.os.ParcelFileDescriptor} data.
- */
-public class FileDescriptorBitmapDataLoadProvider implements DataLoadProvider<ParcelFileDescriptor, Bitmap> {
-    private final ResourceDecoder<File, Bitmap> cacheDecoder;
-    private final FileDescriptorBitmapDecoder sourceDecoder;
-    private final BitmapEncoder encoder;
-    private final Encoder<ParcelFileDescriptor> sourceEncoder;
-
-    public FileDescriptorBitmapDataLoadProvider(BitmapPool bitmapPool, DecodeFormat decodeFormat) {
-        cacheDecoder = new FileToStreamDecoder<Bitmap>(new StreamBitmapDecoder(bitmapPool, decodeFormat));
-        sourceDecoder = new FileDescriptorBitmapDecoder(bitmapPool, decodeFormat);
-        encoder = new BitmapEncoder();
-        sourceEncoder = NullEncoder.get();
-    }
-
-    @Override
-    public ResourceDecoder<File, Bitmap> getCacheDecoder() {
-        return cacheDecoder;
-    }
-
-    @Override
-    public ResourceDecoder<ParcelFileDescriptor, Bitmap> getSourceDecoder() {
-        return sourceDecoder;
-    }
-
-    @Override
-    public Encoder<ParcelFileDescriptor> getSourceEncoder() {
-        return sourceEncoder;
-    }
-
-    @Override
-    public ResourceEncoder<Bitmap> getEncoder() {
-        return encoder;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java
deleted file mode 100644
index f6f2bfbe7..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-import java.io.IOException;
-
-/**
- * An {@link com.bumptech.glide.load.ResourceDecoder} for decoding {@link android.graphics.Bitmap}s from
- * {@link android.os.ParcelFileDescriptor} data.
- */
-public class FileDescriptorBitmapDecoder implements ResourceDecoder<ParcelFileDescriptor, Bitmap> {
-    private final VideoBitmapDecoder bitmapDecoder;
-    private final BitmapPool bitmapPool;
-    private DecodeFormat decodeFormat;
-
-    public FileDescriptorBitmapDecoder(Context context) {
-        this(Glide.get(context).getBitmapPool(), DecodeFormat.DEFAULT);
-    }
-
-    public FileDescriptorBitmapDecoder(Context context, DecodeFormat decodeFormat) {
-        this(Glide.get(context).getBitmapPool(), decodeFormat);
-    }
-
-    public FileDescriptorBitmapDecoder(BitmapPool bitmapPool, DecodeFormat decodeFormat) {
-        this(new VideoBitmapDecoder(), bitmapPool, decodeFormat);
-    }
-
-    public FileDescriptorBitmapDecoder(VideoBitmapDecoder bitmapDecoder, BitmapPool bitmapPool,
-            DecodeFormat decodeFormat) {
-        this.bitmapDecoder = bitmapDecoder;
-        this.bitmapPool = bitmapPool;
-        this.decodeFormat = decodeFormat;
-    }
-
-    @Override
-    public Resource<Bitmap> decode(ParcelFileDescriptor source, int width, int height) throws IOException {
-        Bitmap bitmap = bitmapDecoder.decode(source, bitmapPool, width, height, decodeFormat);
-        return BitmapResource.obtain(bitmap, bitmapPool);
-    }
-
-    @Override
-    public String getId() {
-        return "FileDescriptorBitmapDecoder.com.bumptech.glide.load.data.bitmap";
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index 0d50ec0a8..9f728b1b3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -2,32 +2,49 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
+import java.security.MessageDigest;
+
 /**
- * Scales the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image
- * will be equal to the given dimension and the other will be less than the given dimension.
+ * Scales the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions
+ * of the image will be equal to the given dimension and the other will be less than the given
+ * dimension.
  */
 public class FitCenter extends BitmapTransformation {
-
-    public FitCenter(Context context) {
-        super(context);
-    }
-
-    public FitCenter(BitmapPool bitmapPool) {
-        super(bitmapPool);
-    }
-
-    @Override
-    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-        return TransformationUtils.fitCenter(toTransform, pool, outWidth, outHeight);
-    }
-
-    @Override
-    public String getId() {
-        return "FitCenter.com.bumptech.glide.load.resource.bitmap";
-    }
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.FitCenter";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  public FitCenter(Context context) {
+    super(context);
+  }
+
+  public FitCenter(BitmapPool bitmapPool) {
+    super(bitmapPool);
+  }
+
+  @Override
+  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
+      int outHeight) {
+    return TransformationUtils.fitCenter(pool, toTransform, outWidth, outHeight);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o instanceof FitCenter;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+  }
 }
 
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawable.java
deleted file mode 100644
index 27e05185d..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawable.java
+++ /dev/null
@@ -1,192 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.ColorFilter;
-import android.graphics.Paint;
-import android.graphics.PixelFormat;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.util.DisplayMetrics;
-import android.view.Gravity;
-
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-
-/**
- * A static {@link com.bumptech.glide.load.resource.drawable.GlideDrawable} for displaying a single image.
- */
-public class GlideBitmapDrawable extends GlideDrawable {
-    private final Rect destRect = new Rect();
-    private int width;
-    private int height;
-    private boolean applyGravity;
-    private boolean mutated;
-    private BitmapState state;
-
-    public GlideBitmapDrawable(Resources res, Bitmap bitmap) {
-        this(res, new BitmapState(bitmap));
-    }
-
-    GlideBitmapDrawable(Resources res, BitmapState state) {
-        if (state == null) {
-            throw new NullPointerException("BitmapState must not be null");
-        }
-
-        this.state = state;
-        final int targetDensity;
-        if (res != null) {
-            final int density = res.getDisplayMetrics().densityDpi;
-            targetDensity = density == 0 ? DisplayMetrics.DENSITY_DEFAULT : density;
-            state.targetDensity = targetDensity;
-        } else {
-            targetDensity = state.targetDensity;
-        }
-        width = state.bitmap.getScaledWidth(targetDensity);
-        height = state.bitmap.getScaledHeight(targetDensity);
-    }
-
-    @Override
-    public int getIntrinsicWidth() {
-        return width;
-    }
-
-    @Override
-    public int getIntrinsicHeight() {
-        return height;
-    }
-
-    @Override
-    public boolean isAnimated() {
-        return false;
-    }
-
-    @Override
-    public void setLoopCount(int loopCount) {
-        // Do nothing.
-    }
-
-    @Override
-    public void start() {
-        // Do nothing.
-    }
-
-    @Override
-    public void stop() {
-        // Do nothing.
-    }
-
-    @Override
-    public boolean isRunning() {
-        return false;
-    }
-
-    @Override
-    protected void onBoundsChange(Rect bounds) {
-        super.onBoundsChange(bounds);
-        applyGravity = true;
-    }
-
-    @Override
-    public ConstantState getConstantState() {
-        return state;
-    }
-
-    @Override
-    public void draw(Canvas canvas) {
-        if (applyGravity) {
-            Gravity.apply(BitmapState.GRAVITY, width, height, getBounds(), destRect);
-            applyGravity = false;
-        }
-        canvas.drawBitmap(state.bitmap, null, destRect, state.paint);
-    }
-
-    @Override
-    public void setAlpha(int alpha) {
-        int currentAlpha = state.paint.getAlpha();
-        if (currentAlpha != alpha) {
-            state.setAlpha(alpha);
-            invalidateSelf();
-        }
-    }
-
-    @Override
-    public void setColorFilter(ColorFilter colorFilter) {
-        state.setColorFilter(colorFilter);
-        invalidateSelf();
-    }
-
-    @Override
-    public int getOpacity() {
-        Bitmap bm = state.bitmap;
-        return bm == null || bm.hasAlpha() || state.paint.getAlpha() < 255
-                ? PixelFormat.TRANSLUCENT : PixelFormat.OPAQUE;
-    }
-
-    @Override
-    public Drawable mutate() {
-        if (!mutated && super.mutate() == this) {
-            state = new BitmapState(state);
-            mutated = true;
-        }
-        return this;
-    }
-
-    public Bitmap getBitmap() {
-        return state.bitmap;
-    }
-
-    static class BitmapState extends ConstantState {
-        private static final int DEFAULT_PAINT_FLAGS = Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG;
-        private static final Paint DEFAULT_PAINT = new Paint(DEFAULT_PAINT_FLAGS);
-        private static final int GRAVITY = Gravity.FILL;
-
-        final Bitmap bitmap;
-
-        int targetDensity;
-        Paint paint = DEFAULT_PAINT;
-
-        public BitmapState(Bitmap bitmap) {
-            this.bitmap = bitmap;
-        }
-
-
-        BitmapState(BitmapState other) {
-            this(other.bitmap);
-            targetDensity = other.targetDensity;
-        }
-
-        void setColorFilter(ColorFilter colorFilter) {
-            mutatePaint();
-            paint.setColorFilter(colorFilter);
-        }
-
-        void setAlpha(int alpha) {
-            mutatePaint();
-            paint.setAlpha(alpha);
-        }
-
-        // We want to create a new Paint object so we can mutate it safely.
-        @SuppressWarnings("PMD.CompareObjectsWithEquals")
-        void mutatePaint() {
-            if (DEFAULT_PAINT == paint) {
-                paint = new Paint(DEFAULT_PAINT_FLAGS);
-            }
-        }
-
-        @Override
-        public Drawable newDrawable() {
-            return new GlideBitmapDrawable(null, this);
-        }
-
-        @Override
-        public Drawable newDrawable(Resources res) {
-            return new GlideBitmapDrawable(res, this);
-        }
-
-        @Override
-        public int getChangingConfigurations() {
-            return 0;
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResource.java
deleted file mode 100644
index 91b211e23..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResource.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.drawable.DrawableResource;
-import com.bumptech.glide.util.Util;
-
-/**
- * A resource wrapper for {@link com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable}.
- */
-public class GlideBitmapDrawableResource extends DrawableResource<GlideBitmapDrawable> {
-    private final BitmapPool bitmapPool;
-
-    public GlideBitmapDrawableResource(GlideBitmapDrawable drawable, BitmapPool bitmapPool) {
-        super(drawable);
-        this.bitmapPool = bitmapPool;
-    }
-
-    @Override
-    public int getSize() {
-        return Util.getBitmapByteSize(drawable.getBitmap());
-    }
-
-    @Override
-    public void recycle() {
-        bitmapPool.put(drawable.getBitmap());
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
index cd787817d..2411ddab0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
@@ -8,341 +8,466 @@
 
 import android.util.Log;
 
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.util.Preconditions;
+
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.charset.Charset;
 
 /**
  * A class for parsing the exif orientation and other data from an image header.
  */
 public class ImageHeaderParser {
-    private static final String TAG = "ImageHeaderParser";
-
+  private static final String TAG = "ImageHeaderParser";
+  /**
+   * A constant indicating we were unable to parse the orientation from the image either because
+   * no exif segment containing orientation data existed, or because of an I/O error attempting to
+   * read the exif segment.
+   */
+  public static final int UNKNOWN_ORIENTATION = -1;
+
+  /**
+   * The format of the image data including whether or not the image may include transparent
+   * pixels.
+   */
+  public enum ImageType {
+    GIF(true),
+    JPEG(false),
+    /** PNG type with alpha. */
+    PNG_A(true),
+    /** PNG type without alpha. */
+    PNG(false),
     /**
-     * The format of the image data including whether or not the image may include transparent pixels.
+     * Unrecognized type.
      */
-    public static enum ImageType {
-        /** GIF type. */
-        GIF(true),
-        /** JPG type. */
-        JPEG(false),
-        /** PNG type with alpha. */
-        PNG_A(true),
-        /** PNG type without alpha. */
-        PNG(false),
-        /** Unrecognized type. */
-        UNKNOWN(false);
-        private final boolean hasAlpha;
-
-        ImageType(boolean hasAlpha) {
-            this.hasAlpha = hasAlpha;
-        }
+    UNKNOWN(false);
+    private final boolean hasAlpha;
 
-        public boolean hasAlpha() {
-            return hasAlpha;
-        }
+    ImageType(boolean hasAlpha) {
+      this.hasAlpha = hasAlpha;
     }
 
-    private static final int GIF_HEADER = 0x474946;
-    private static final int PNG_HEADER = 0x89504E47;
-    private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
-    // "MM".
-    private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
-    // "II".
-    private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
-    private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
-    private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES;
-    private static final int SEGMENT_SOS = 0xDA;
-    private static final int MARKER_EOI = 0xD9;
-    private static final int SEGMENT_START_ID = 0xFF;
-    private static final int EXIF_SEGMENT_TYPE = 0xE1;
-    private static final int ORIENTATION_TAG_TYPE = 0x0112;
-    private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
-
-    private final StreamReader streamReader;
-
-    static {
-        byte[] bytes = new byte[0];
-        try {
-            bytes = JPEG_EXIF_SEGMENT_PREAMBLE.getBytes("UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            // Ignore.
-        }
-        JPEG_EXIF_SEGMENT_PREAMBLE_BYTES = bytes;
+    public boolean hasAlpha() {
+      return hasAlpha;
     }
-
-    public ImageHeaderParser(InputStream is) {
-        streamReader = new StreamReader(is);
+  }
+
+  private static final int GIF_HEADER = 0x474946;
+  private static final int PNG_HEADER = 0x89504E47;
+  private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
+  // "MM".
+  private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
+  // "II".
+  private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
+  private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
+  private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
+      JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
+  private static final int SEGMENT_SOS = 0xDA;
+  private static final int MARKER_EOI = 0xD9;
+  private static final int SEGMENT_START_ID = 0xFF;
+  private static final int EXIF_SEGMENT_TYPE = 0xE1;
+  private static final int ORIENTATION_TAG_TYPE = 0x0112;
+  private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
+
+  private final ByteArrayPool byteArrayPool;
+  private final Reader reader;
+
+  public ImageHeaderParser(InputStream is, ByteArrayPool byteArrayPool) {
+    Preconditions.checkNotNull(is);
+    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
+    reader = new StreamReader(is);
+  }
+
+  public ImageHeaderParser(ByteBuffer byteBuffer, ByteArrayPool byteArrayPool) {
+    Preconditions.checkNotNull(byteBuffer);
+    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
+    reader = new ByteBufferReader(byteBuffer);
+  }
+
+  // 0xD0A3C68 -> <htm
+  // 0xCAFEBABE -> <!DOCTYPE...
+  public boolean hasAlpha() throws IOException {
+    return getType().hasAlpha();
+  }
+
+  public ImageType getType() throws IOException {
+    int firstTwoBytes = reader.getUInt16();
+
+    // JPEG.
+    if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
+      return JPEG;
     }
 
-    // 0xD0A3C68 -> <htm
-    // 0xCAFEBABE -> <!DOCTYPE...
-    public boolean hasAlpha() throws IOException {
-        return getType().hasAlpha();
+    final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    // PNG.
+    if (firstFourBytes == PNG_HEADER) {
+      // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha
+      // -color-type
+      reader.skip(25 - 4);
+      int alpha = reader.getByte();
+      // A RGB indexed PNG can also have transparency. Better safe than sorry!
+      return alpha >= 3 ? PNG_A : PNG;
     }
 
-    public ImageType getType() throws IOException {
-        int firstByte = streamReader.getUInt8();
+    // GIF from first 3 bytes.
+    if (firstFourBytes >> 8 == GIF_HEADER) {
+      return GIF;
+    }
 
-        // JPEG.
-        if (firstByte == EXIF_MAGIC_NUMBER >> 8) {
-            return JPEG;
+    return UNKNOWN;
+  }
+
+  /**
+   * Parse the orientation from the image header. If it doesn't handle this image type (or this is
+   * not an image) it will return a default value rather than throwing an exception.
+   *
+   * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
+   * contain an orientation
+   * @throws IOException
+   */
+  public int getOrientation() throws IOException {
+    final int magicNumber = reader.getUInt16();
+
+    if (!handles(magicNumber)) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Parser doesn't handle magic number: " + magicNumber);
+      }
+      return UNKNOWN_ORIENTATION;
+    } else {
+      int exifSegmentLength = moveToExifSegmentAndGetLength();
+      if (exifSegmentLength == -1) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Failed to parse exif segment length, or exif segment not found");
         }
+        return UNKNOWN_ORIENTATION;
+      }
+
+      byte[] exifData = byteArrayPool.get(exifSegmentLength);
+      try {
+        return parseExifSegment(exifData, exifSegmentLength);
+      } finally {
+        byteArrayPool.put(exifData);
+      }
+    }
+  }
+
+  private int parseExifSegment(byte[] tempArray, int exifSegmentLength) throws IOException {
+    int read = reader.read(tempArray, exifSegmentLength);
+    if (read != exifSegmentLength) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to read exif segment data"
+            + ", length: " + exifSegmentLength
+            + ", actually read: " + read);
+      }
+      return UNKNOWN_ORIENTATION;
+    }
 
-        final int firstTwoBytes = firstByte << 8 & 0xFF00 | streamReader.getUInt8() & 0xFF;
-        final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | streamReader.getUInt16() & 0xFFFF;
-        // PNG.
-        if (firstFourBytes == PNG_HEADER) {
-            // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha-color-type
-            streamReader.skip(25 - 4);
-            int alpha = streamReader.getByte();
-            // A RGB indexed PNG can also have transparency. Better safe than sorry!
-            return alpha >= 3 ? PNG_A : PNG;
+    boolean hasJpegExifPreamble = hasJpegExifPreamble(tempArray, exifSegmentLength);
+    if (hasJpegExifPreamble) {
+      return parseExifSegment(new RandomAccessReader(tempArray, exifSegmentLength));
+    } else {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Missing jpeg exif preamble");
+      }
+      return UNKNOWN_ORIENTATION;
+    }
+  }
+
+  private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
+    boolean result =
+        exifData != null && exifSegmentLength > JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length;
+    if (result) {
+      for (int i = 0; i < JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length; i++) {
+        if (exifData[i] != JPEG_EXIF_SEGMENT_PREAMBLE_BYTES[i]) {
+          result = false;
+          break;
         }
-
-        // GIF from first 3 bytes.
-        if (firstFourBytes >> 8 == GIF_HEADER) {
-            return GIF;
+      }
+    }
+    return result;
+  }
+
+  /**
+   * Moves reader to the start of the exif segment and returns the length of the exif segment or
+   * {@code -1} if no exif segment is found.
+   */
+  private int moveToExifSegmentAndGetLength() throws IOException {
+    short segmentId, segmentType;
+    int segmentLength;
+    while (true) {
+      segmentId = reader.getUInt8();
+      if (segmentId != SEGMENT_START_ID) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Unknown segmentId=" + segmentId);
         }
+        return -1;
+      }
 
-        return UNKNOWN;
-    }
+      segmentType = reader.getUInt8();
 
-    /**
-     * Parse the orientation from the image header. If it doesn't handle this image type (or this is not an image)
-     * it will return a default value rather than throwing an exception.
-     *
-     * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't contain an orientation
-     * @throws IOException
-     */
-    public int getOrientation() throws IOException {
-        final int magicNumber = streamReader.getUInt16();
+      if (segmentType == SEGMENT_SOS) {
+        return -1;
+      } else if (segmentType == MARKER_EOI) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Found MARKER_EOI in exif segment");
+        }
+        return -1;
+      }
 
-        if (!handles(magicNumber)) {
-            return -1;
-        } else {
-            byte[] exifData = getExifSegment();
-            boolean hasJpegExifPreamble = exifData != null
-                    && exifData.length >= JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length;
-
-            if (hasJpegExifPreamble) {
-                for (int i = 0; i < JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length; i++) {
-                    if (exifData[i] != JPEG_EXIF_SEGMENT_PREAMBLE_BYTES[i]) {
-                        hasJpegExifPreamble = false;
-                        break;
-                    }
-                }
-            }
+      // Segment length includes bytes for segment length.
+      segmentLength = reader.getUInt16() - 2;
 
-            if (hasJpegExifPreamble) {
-                return parseExifSegment(new RandomAccessReader(exifData));
-            } else {
-                return -1;
+      if (segmentType != EXIF_SEGMENT_TYPE) {
+        long skipped = reader.skip(segmentLength);
+        if (skipped != segmentLength) {
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "Unable to skip enough data"
+                    + ", type: " + segmentType
+                    + ", wanted to skip: " + segmentLength
+                    + ", but actually skipped: " + skipped);
             }
+            return -1;
         }
+      } else {
+        return segmentLength;
+      }
+    }
+  }
+
+  private static int parseExifSegment(RandomAccessReader segmentData) {
+    final int headerOffsetSize = JPEG_EXIF_SEGMENT_PREAMBLE.length();
+
+    short byteOrderIdentifier = segmentData.getInt16(headerOffsetSize);
+    final ByteOrder byteOrder;
+    if (byteOrderIdentifier == MOTOROLA_TIFF_MAGIC_NUMBER) {
+      byteOrder = ByteOrder.BIG_ENDIAN;
+    } else if (byteOrderIdentifier == INTEL_TIFF_MAGIC_NUMBER) {
+      byteOrder = ByteOrder.LITTLE_ENDIAN;
+    } else {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
+      }
+      byteOrder = ByteOrder.BIG_ENDIAN;
     }
 
-    private byte[] getExifSegment() throws IOException {
-        short segmentId, segmentType;
-        int segmentLength;
-        while (true) {
-            segmentId = streamReader.getUInt8();
-
-            if (segmentId != SEGMENT_START_ID) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Unknown segmentId=" + segmentId);
-                }
-                return null;
-            }
+    segmentData.order(byteOrder);
 
-            segmentType = streamReader.getUInt8();
+    int firstIfdOffset = segmentData.getInt32(headerOffsetSize + 4) + headerOffsetSize;
+    int tagCount = segmentData.getInt16(firstIfdOffset);
 
-            if (segmentType == SEGMENT_SOS) {
-                return null;
-            } else if (segmentType == MARKER_EOI) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Found MARKER_EOI in exif segment");
-                }
-                return null;
-            }
+    int tagOffset, tagType, formatCode, componentCount;
+    for (int i = 0; i < tagCount; i++) {
+      tagOffset = calcTagOffset(firstIfdOffset, i);
+      tagType = segmentData.getInt16(tagOffset);
 
-            // Segment length includes bytes for segment length.
-            segmentLength = streamReader.getUInt16() - 2;
-
-            if (segmentType != EXIF_SEGMENT_TYPE) {
-                if (segmentLength != streamReader.skip(segmentLength)) {
-                    if (Log.isLoggable(TAG, Log.DEBUG)) {
-                        Log.d(TAG, "Unable to skip enough data for type=" + segmentType);
-                    }
-                    return null;
-                }
-            } else {
-                byte[] segmentData = new byte[segmentLength];
-
-                if (segmentLength != streamReader.read(segmentData)) {
-                    if (Log.isLoggable(TAG, Log.DEBUG)) {
-                        Log.d(TAG, "Unable to read segment data for type=" + segmentType + " length=" + segmentLength);
-                    }
-                    return null;
-                } else {
-                    return segmentData;
-                }
-            }
-        }
-    }
+      // We only want orientation.
+      if (tagType != ORIENTATION_TAG_TYPE) {
+        continue;
+      }
 
-    private static int parseExifSegment(RandomAccessReader segmentData) {
-        final int headerOffsetSize = JPEG_EXIF_SEGMENT_PREAMBLE.length();
+      formatCode = segmentData.getInt16(tagOffset + 2);
 
-        short byteOrderIdentifier = segmentData.getInt16(headerOffsetSize);
-        final ByteOrder byteOrder;
-        if (byteOrderIdentifier == MOTOROLA_TIFF_MAGIC_NUMBER) {
-            byteOrder = ByteOrder.BIG_ENDIAN;
-        } else if (byteOrderIdentifier == INTEL_TIFF_MAGIC_NUMBER) {
-            byteOrder = ByteOrder.LITTLE_ENDIAN;
-        } else {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
-            }
-            byteOrder = ByteOrder.BIG_ENDIAN;
+      // 12 is max format code.
+      if (formatCode < 1 || formatCode > 12) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Got invalid format code = " + formatCode);
         }
+        continue;
+      }
 
-        segmentData.order(byteOrder);
-
-        int firstIfdOffset = segmentData.getInt32(headerOffsetSize + 4) + headerOffsetSize;
-        int tagCount = segmentData.getInt16(firstIfdOffset);
+      componentCount = segmentData.getInt32(tagOffset + 4);
 
-        int tagOffset, tagType, formatCode, componentCount;
-        for (int i = 0; i < tagCount; i++) {
-            tagOffset = calcTagOffset(firstIfdOffset, i);
+      if (componentCount < 0) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Negative tiff component count");
+        }
+        continue;
+      }
 
-            tagType = segmentData.getInt16(tagOffset);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode=" + formatCode
+            + " componentCount=" + componentCount);
+      }
 
-            // We only want orientation.
-            if (tagType != ORIENTATION_TAG_TYPE) {
-                continue;
-            }
+      final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];
 
-            formatCode = segmentData.getInt16(tagOffset + 2);
+      if (byteCount > 4) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Got byte count > 4, not orientation, continuing, formatCode=" + formatCode);
+        }
+        continue;
+      }
 
-            // 12 is max format code.
-            if (formatCode < 1 || formatCode > 12) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Got invalid format code = " + formatCode);
-                }
-                continue;
-            }
+      final int tagValueOffset = tagOffset + 8;
 
-            componentCount = segmentData.getInt32(tagOffset + 4);
+      if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
+        }
+        continue;
+      }
 
-            if (componentCount < 0) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Negative tiff component count");
-                }
-                continue;
-            }
+      if (byteCount < 0 || tagValueOffset + byteCount > segmentData.length()) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Illegal number of bytes for TI tag data tagType=" + tagType);
+        }
+        continue;
+      }
 
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode =" + formatCode
-                        + " componentCount=" + componentCount);
-            }
+      //assume componentCount == 1 && fmtCode == 3
+      return segmentData.getInt16(tagValueOffset);
+    }
 
-            final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];
+    return -1;
+  }
 
-            if (byteCount > 4) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Got byte count > 4, not orientation, continuing, formatCode=" + formatCode);
-                }
-                continue;
-            }
+  private static int calcTagOffset(int ifdOffset, int tagIndex) {
+    return ifdOffset + 2 + 12 * tagIndex;
+  }
 
-            final int tagValueOffset = tagOffset + 8;
+  private static boolean handles(int imageMagicNumber) {
+    return (imageMagicNumber & EXIF_MAGIC_NUMBER) == EXIF_MAGIC_NUMBER
+        || imageMagicNumber == MOTOROLA_TIFF_MAGIC_NUMBER
+        || imageMagicNumber == INTEL_TIFF_MAGIC_NUMBER;
+  }
 
-            if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
-                }
-                continue;
-            }
+  private static class RandomAccessReader {
+    private final ByteBuffer data;
 
-            if (byteCount < 0 || tagValueOffset + byteCount > segmentData.length()) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Illegal number of bytes for TI tag data tagType=" + tagType);
-                }
-                continue;
-            }
+    public RandomAccessReader(byte[] data, int length) {
+      this.data = (ByteBuffer) ByteBuffer.wrap(data)
+          .order(ByteOrder.BIG_ENDIAN)
+          .limit(length);
+    }
 
-            //assume componentCount == 1 && fmtCode == 3
-            return segmentData.getInt16(tagValueOffset);
-        }
+    public void order(ByteOrder byteOrder) {
+      this.data.order(byteOrder);
+    }
 
-        return -1;
+    public int length() {
+      return data.remaining();
     }
 
-    private static int calcTagOffset(int ifdOffset, int tagIndex) {
-        return ifdOffset + 2 + 12 * tagIndex;
+    public int getInt32(int offset) {
+      return data.getInt(offset);
     }
 
-    private static boolean handles(int imageMagicNumber) {
-        return (imageMagicNumber & EXIF_MAGIC_NUMBER) == EXIF_MAGIC_NUMBER
-                || imageMagicNumber == MOTOROLA_TIFF_MAGIC_NUMBER
-                || imageMagicNumber == INTEL_TIFF_MAGIC_NUMBER;
+    public short getInt16(int offset) {
+      return data.getShort(offset);
     }
+  }
 
-    private static class RandomAccessReader {
-        private final ByteBuffer data;
+  private interface Reader {
+    int getUInt16() throws IOException;
+    short getUInt8() throws IOException;
+    long skip(long total) throws IOException;
+    int read(byte[] buffer, int byteCount) throws IOException;
+    int getByte() throws IOException;
+  }
 
-        public RandomAccessReader(byte[] data) {
-            this.data = ByteBuffer.wrap(data);
-            this.data.order(ByteOrder.BIG_ENDIAN);
-        }
+  private static class ByteBufferReader implements Reader {
 
-        public void order(ByteOrder byteOrder) {
-            this.data.order(byteOrder);
-        }
+    private final ByteBuffer byteBuffer;
 
-        public int length() {
-            return data.array().length;
-        }
+    public ByteBufferReader(ByteBuffer byteBuffer) {
+      this.byteBuffer = byteBuffer;
+      byteBuffer.order(ByteOrder.BIG_ENDIAN);
+    }
 
-        public int getInt32(int offset) {
-            return data.getInt(offset);
-        }
+    @Override
+    public int getUInt16() throws IOException {
+      return (getByte() << 8 & 0xFF00) | (getByte() & 0xFF);
+    }
 
-        public short getInt16(int offset) {
-            return data.getShort(offset);
-        }
+    @Override
+    public short getUInt8() throws IOException {
+      return (short) (getByte() & 0xFF);
     }
 
-    private static class StreamReader {
-        private final InputStream is;
-        //motorola / big endian byte order
+    @Override
+    public long skip(long total) throws IOException {
+      int toSkip = (int) Math.min(byteBuffer.remaining(), total);
+      byteBuffer.position(byteBuffer.position() + toSkip);
+      return toSkip;
+    }
 
-        public StreamReader(InputStream is) {
-            this.is = is;
-        }
+    @Override
+    public int read(byte[] buffer, int byteCount) throws IOException {
+      int toRead = Math.min(byteCount, byteBuffer.remaining());
+      byteBuffer.get(buffer, 0 /*dstOffset*/, byteCount);
+      return toRead;
+    }
 
-        public int getUInt16() throws IOException {
-            return  (is.read() << 8 & 0xFF00) | (is.read() & 0xFF);
-        }
+    @Override
+    public int getByte() throws IOException {
+      if (byteBuffer.remaining() < 1) {
+        return -1;
+      }
+      return byteBuffer.get();
+    }
+  }
 
-        public short getUInt8() throws IOException {
-            return (short) (is.read() & 0xFF);
-        }
+  private static class StreamReader implements Reader {
+    private final InputStream is;
+    // Motorola / big endian byte order.
+    public StreamReader(InputStream is) {
+      this.is = is;
+    }
 
-        public long skip(long total) throws IOException {
-            return is.skip(total);
-        }
+    @Override
+    public int getUInt16() throws IOException {
+      return (is.read() << 8 & 0xFF00) | (is.read() & 0xFF);
+    }
 
-        public int read(byte[] buffer) throws IOException {
-            return is.read(buffer);
-        }
+    @Override
+    public short getUInt8() throws IOException {
+      return (short) (is.read() & 0xFF);
+    }
 
-        public int getByte() throws IOException {
-            return is.read();
+    @Override
+    public long skip(long total) throws IOException {
+      if (total < 0) {
+        return 0;
+      }
+
+      long toSkip = total;
+      while (toSkip > 0) {
+        long skipped = is.skip(toSkip);
+        if (skipped > 0) {
+          toSkip -= skipped;
+        } else {
+          // Skip has no specific contract as to what happens when you reach the end of
+          // the stream. To differentiate between temporarily not having more data and
+          // having finished the stream, we read a single byte when we fail to skip any
+          // amount of data.
+          int testEofByte = is.read();
+          if (testEofByte == -1) {
+            break;
+          } else {
+            toSkip--;
+          }
         }
+      }
+      return total - toSkip;
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteCount) throws IOException {
+      int toRead = byteCount;
+      int read;
+      while (toRead > 0 && ((read = is.read(buffer, byteCount - toRead, toRead)) != -1)) {
+        toRead -= read;
+      }
+      return byteCount - toRead;
+    }
+
+    @Override
+    public int getByte() throws IOException {
+      return is.read();
     }
+  }
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java
deleted file mode 100644
index 58cb60364..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import android.graphics.Bitmap;
-import android.os.ParcelFileDescriptor;
-import android.util.Log;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * A {@link ResourceDecoder} that decodes {@link ImageVideoWrapper}s using
- * a wrapped {@link ResourceDecoder} for {@link InputStream}s
- * and a wrapped {@link ResourceDecoder} for {@link ParcelFileDescriptor}s.
- * The {@link InputStream} data in the {@link ImageVideoWrapper} is always preferred.
- */
-public class ImageVideoBitmapDecoder implements ResourceDecoder<ImageVideoWrapper, Bitmap> {
-    private static final String TAG = "ImageVideoDecoder";
-    private final ResourceDecoder<InputStream, Bitmap> streamDecoder;
-    private final ResourceDecoder<ParcelFileDescriptor, Bitmap> fileDescriptorDecoder;
-
-    public ImageVideoBitmapDecoder(ResourceDecoder<InputStream, Bitmap> streamDecoder,
-            ResourceDecoder<ParcelFileDescriptor, Bitmap> fileDescriptorDecoder) {
-        this.streamDecoder = streamDecoder;
-        this.fileDescriptorDecoder = fileDescriptorDecoder;
-    }
-
-    @SuppressWarnings("resource")
-    // @see ResourceDecoder.decode
-    @Override
-    public Resource<Bitmap> decode(ImageVideoWrapper source, int width, int height) throws IOException {
-        Resource<Bitmap> result = null;
-        InputStream is = source.getStream();
-        if (is != null) {
-            try {
-                result = streamDecoder.decode(is, width, height);
-            } catch (IOException e) {
-                if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                    Log.v(TAG, "Failed to load image from stream, trying FileDescriptor", e);
-                }
-            }
-        }
-
-        if (result == null) {
-            ParcelFileDescriptor fileDescriptor = source.getFileDescriptor();
-            if (fileDescriptor != null) {
-                result = fileDescriptorDecoder.decode(fileDescriptor, width, height);
-            }
-        }
-        return result;
-    }
-
-    @Override
-    public String getId() {
-        return "ImageVideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoDataLoadProvider.java
deleted file mode 100644
index 002a48f92..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoDataLoadProvider.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import android.graphics.Bitmap;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.model.ImageVideoWrapperEncoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * A {@link com.bumptech.glide.provider.DataLoadProvider} for loading either an {@link java.io.InputStream} or an
- * {@link android.os.ParcelFileDescriptor} as an {@link android.graphics.Bitmap}.
- */
-public class ImageVideoDataLoadProvider implements DataLoadProvider<ImageVideoWrapper, Bitmap> {
-    private final ImageVideoBitmapDecoder sourceDecoder;
-    private final ResourceDecoder<File, Bitmap> cacheDecoder;
-    private final ResourceEncoder<Bitmap> encoder;
-    private final ImageVideoWrapperEncoder sourceEncoder;
-
-    public ImageVideoDataLoadProvider(DataLoadProvider<InputStream, Bitmap> streamBitmapProvider,
-            DataLoadProvider<ParcelFileDescriptor, Bitmap> fileDescriptorBitmapProvider) {
-        encoder = streamBitmapProvider.getEncoder();
-        sourceEncoder = new ImageVideoWrapperEncoder(streamBitmapProvider.getSourceEncoder(),
-                fileDescriptorBitmapProvider.getSourceEncoder());
-        cacheDecoder = streamBitmapProvider.getCacheDecoder();
-        sourceDecoder = new ImageVideoBitmapDecoder(streamBitmapProvider.getSourceDecoder(),
-                fileDescriptorBitmapProvider.getSourceDecoder());
-    }
-
-    @Override
-    public ResourceDecoder<File, Bitmap> getCacheDecoder() {
-        return cacheDecoder;
-    }
-
-    @Override
-    public ResourceDecoder<ImageVideoWrapper, Bitmap> getSourceDecoder() {
-        return sourceDecoder;
-    }
-
-    @Override
-    public Encoder<ImageVideoWrapper> getSourceEncoder() {
-        return sourceEncoder;
-    }
-
-    @Override
-    public ResourceEncoder<Bitmap> getEncoder() {
-        return encoder;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
new file mode 100644
index 000000000..9a4b7b205
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -0,0 +1,58 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+
+/**
+ * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
+ * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
+ */
+public class LazyBitmapDrawableResource implements Resource<BitmapDrawable> {
+
+  private final Bitmap bitmap;
+  private final Resources resources;
+  private final BitmapPool bitmapPool;
+
+  public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) {
+    return obtain(context.getResources(), Glide.get(context).getBitmapPool(), bitmap);
+  }
+
+  public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool bitmapPool,
+      Bitmap bitmap) {
+    return new LazyBitmapDrawableResource(resources, bitmapPool, bitmap);
+  }
+
+  LazyBitmapDrawableResource(Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {
+    this.resources = Preconditions.checkNotNull(resources);
+    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+    this.bitmap = Preconditions.checkNotNull(bitmap);
+  }
+
+  @Override
+  public Class<BitmapDrawable> getResourceClass() {
+    return BitmapDrawable.class;
+  }
+
+  @Override
+  public BitmapDrawable get() {
+    return new BitmapDrawable(resources, bitmap);
+  }
+
+  @Override
+  public int getSize() {
+    return Util.getBitmapByteSize(bitmap);
+  }
+
+  @Override
+  public void recycle() {
+    bitmapPool.put(bitmap);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 8699022b5..33a25b6f7 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -17,19 +17,18 @@
  *  limitations under the License.
  */
 
-import android.util.Log;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
 /**
- * Wraps an existing {@link InputStream} and <em>buffers</em> the input.
- * Expensive interaction with the underlying input stream is minimized, since
- * most (smaller) requests can be satisfied by accessing the buffer alone. The
- * drawback is that some extra space is required to hold the buffer and that
- * copying takes place when filling that buffer, but this is usually outweighed
- * by the performance benefits.
+ * Wraps an existing {@link InputStream} and <em>buffers</em> the input. Expensive interaction with
+ * the underlying input stream is minimized, since most (smaller) requests can be satisfied by
+ * accessing the buffer alone. The drawback is that some extra space is required to hold the buffer
+ * and that copying takes place when filling that buffer, but this is usually outweighed by the
+ * performance benefits.
  *
  * <p>A typical application pattern for the class looks like this:</p>
  *
@@ -38,379 +37,378 @@
  * </pre>
  */
 public class RecyclableBufferedInputStream extends FilterInputStream {
-    private static final String TAG = "BufferedIs";
+  /**
+   * The buffer containing the current bytes read from the target InputStream.
+   */
+  private volatile byte[] buf;
 
-    /**
-     * The buffer containing the current bytes read from the target InputStream.
-     */
-    private volatile byte[] buf;
+  /**
+   * The total number of bytes inside the byte array {@code buf}.
+   */
+  private int count;
 
-    /**
-     * The total number of bytes inside the byte array {@code buf}.
-     */
-    private int count;
+  /**
+   * The current limit, which when passed, invalidates the current mark.
+   */
+  private int marklimit;
 
-    /**
-     * The current limit, which when passed, invalidates the current mark.
-     */
-    private int marklimit;
+  /**
+   * The currently marked position. -1 indicates no mark has been put or the mark has been
+   * invalidated.
+   */
+  private int markpos = -1;
 
-    /**
-     * The currently marked position. -1 indicates no mark has been set or the
-     * mark has been invalidated.
-     */
-    private int markpos = -1;
+  /**
+   * The current position within the byte array {@code buf}.
+   */
+  private int pos;
+  private final ByteArrayPool byteArrayPool;
 
-    /**
-     * The current position within the byte array {@code buf}.
-     */
-    private int pos;
+  public RecyclableBufferedInputStream(InputStream in, ByteArrayPool byteArrayPool) {
+    this(in, byteArrayPool, ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  }
 
-    public RecyclableBufferedInputStream(InputStream in, byte[] buffer) {
-        super(in);
-        if (buffer == null || buffer.length == 0) {
-            throw new IllegalArgumentException("buffer is null or empty");
-        }
-        buf = buffer;
-    }
+  // Visible for testing
+  RecyclableBufferedInputStream(InputStream in, ByteArrayPool byteArrayPool,
+      int bufferSize) {
+    super(in);
+    this.byteArrayPool = byteArrayPool;
+    buf = byteArrayPool.get(bufferSize);
+  }
 
-    /**
-     * Returns an estimated number of bytes that can be read or skipped without blocking for more
-     * input. This method returns the number of bytes available in the buffer
-     * plus those available in the source stream, but see {@link InputStream#available} for
-     * important caveats.
-     *
-     * @return the estimated number of bytes available
-     * @throws IOException if this stream is closed or an error occurs
-     */
-    @Override
-    public synchronized int available() throws IOException {
-        // in could be invalidated by close().
-        InputStream localIn = in;
-        if (buf == null || localIn == null) {
-            throw streamClosed();
-        }
-        return count - pos + localIn.available();
+  /**
+   * Returns an estimated number of bytes that can be read or skipped without blocking for more
+   * input. This method returns the number of bytes available in the buffer plus those available in
+   * the source stream, but see {@link InputStream#available} for important caveats.
+   *
+   * @return the estimated number of bytes available
+   * @throws IOException if this stream is closed or an error occurs
+   */
+  @Override
+  public synchronized int available() throws IOException {
+    // in could be invalidated by close().
+    InputStream localIn = in;
+    if (buf == null || localIn == null) {
+      throw streamClosed();
     }
+    return count - pos + localIn.available();
+  }
 
-    private static IOException streamClosed() throws IOException {
-        throw new IOException("BufferedInputStream is closed");
-    }
+  private static IOException streamClosed() throws IOException {
+    throw new IOException("BufferedInputStream is closed");
+  }
+
+  /**
+   * Reduces the mark limit to match the current buffer length to prevent the buffer from continuing
+   * to increase in size.
+   *
+   * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size to
+   * increase.
+   */
+  public synchronized void fixMarkLimit() {
+    marklimit = buf.length;
+  }
 
-    /**
-     * Reduces the mark limit to match the current buffer length to prevent the buffer from
-     * continuing to increase in size.
-     *
-     * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size
-     * to increase.
-     */
-    public synchronized void fixMarkLimit() {
-        marklimit = buf.length;
+  public synchronized void release() {
+    if (buf != null) {
+      byteArrayPool.put(buf);
+      buf = null;
     }
+  }
 
-    /**
-     * Closes this stream. The source stream is closed and any resources
-     * associated with it are released.
-     *
-     * @throws IOException
-     *             if an error occurs while closing this stream.
-     */
-    @Override
-    public void close() throws IOException {
-        buf = null;
-        InputStream localIn = in;
-        in = null;
-        if (localIn != null) {
-            localIn.close();
-        }
+  /**
+   * Closes this stream. The source stream is closed and any resources associated with it are
+   * released.
+   *
+   * @throws IOException if an error occurs while closing this stream.
+   */
+  @Override
+  public void close() throws IOException {
+    if (buf != null) {
+      byteArrayPool.put(buf);
+      buf = null;
+    }
+    InputStream localIn = in;
+    in = null;
+    if (localIn != null) {
+      localIn.close();
     }
+  }
 
-    private int fillbuf(InputStream localIn, byte[] localBuf)
-            throws IOException {
-        if (markpos == -1 || pos - markpos >= marklimit) {
-            // Mark position not set or exceeded readlimit
-            int result = localIn.read(localBuf);
-            if (result > 0) {
-                markpos = -1;
-                pos = 0;
-                count = result;
-            }
-            return result;
-        }
-        // Added count == localBuf.length so that we do not immediately double the buffer size before reading any data
-        // when marklimit > localBuf.length. Instead, we will double the buffer size only after reading the initial
-        // localBuf worth of data without finding what we're looking for in the stream. This allows us to set a
-        // relatively small initial buffer size and a large marklimit for safety without causing an allocation each time
-        // read is called.
-        if (markpos == 0 && marklimit > localBuf.length && count == localBuf.length) {
-            // Increase buffer size to accommodate the readlimit
-            int newLength = localBuf.length * 2;
-            if (newLength > marklimit) {
-                newLength = marklimit;
-            }
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "allocate buffer of length: " + newLength);
-            }
-            byte[] newbuf = new byte[newLength];
-            System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
-            // Reassign buf, which will invalidate any local references
-            // FIXME: what if buf was null?
-            localBuf = buf = newbuf;
-        } else if (markpos > 0) {
-            System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length
-                    - markpos);
-        }
-        // Set the new position and mark position
-        pos -= markpos;
-        count = markpos = 0;
-        int bytesread = localIn.read(localBuf, pos, localBuf.length - pos);
-        count = bytesread <= 0 ? pos : pos + bytesread;
-        return bytesread;
+  private int fillbuf(InputStream localIn, byte[] localBuf) throws IOException {
+    if (markpos == -1 || pos - markpos >= marklimit) {
+      // Mark position not put or exceeded readlimit
+      int result = localIn.read(localBuf);
+      if (result > 0) {
+        markpos = -1;
+        pos = 0;
+        count = result;
+      }
+      return result;
+    }
+    // Added count == localBuf.length so that we do not immediately double the buffer size before
+    // reading any data
+    // when marklimit > localBuf.length. Instead, we will double the buffer size only after
+    // reading the initial
+    // localBuf worth of data without finding what we're looking for in the stream. This allows
+    // us to put a
+    // relatively small initial buffer size and a large marklimit for safety without causing an
+    // allocation each time
+    // read is called.
+    if (markpos == 0 && marklimit > localBuf.length && count == localBuf.length) {
+      // Increase buffer size to accommodate the readlimit
+      int newLength = localBuf.length * 2;
+      if (newLength > marklimit) {
+        newLength = marklimit;
+      }
+      byte[] newbuf = byteArrayPool.get(newLength);
+      System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
+      byte[] oldbuf = localBuf;
+      // Reassign buf, which will invalidate any local references
+      // FIXME: what if buf was null?
+      localBuf = buf = newbuf;
+      byteArrayPool.put(oldbuf);
+    } else if (markpos > 0) {
+      System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length - markpos);
     }
+    // Set the new position and mark position
+    pos -= markpos;
+    count = markpos = 0;
+    int bytesread = localIn.read(localBuf, pos, localBuf.length - pos);
+    count = bytesread <= 0 ? pos : pos + bytesread;
+    return bytesread;
+  }
+
+  /**
+   * Sets a mark position in this stream. The parameter {@code readlimit} indicates how many bytes
+   * can be read before a mark is invalidated. Calling {@link #reset()} will reposition the stream
+   * back to the marked position if {@code readlimit} has not been surpassed. The underlying buffer
+   * may be increased in size to allow {@code readlimit} number of bytes to be supported.
+   *
+   * @param readlimit the number of bytes that can be read before the mark is invalidated.
+   * @see #reset()
+   */
+  @Override
+  public synchronized void mark(int readlimit) {
+    // This is stupid, but BitmapFactory.decodeStream calls mark(1024)
+    // which is too small for a substantial portion of images. This
+    // change (using Math.max) ensures that we don't overwrite readlimit
+    // with a smaller value
+    marklimit = Math.max(marklimit, readlimit);
+    markpos = pos;
+  }
 
-    /**
-     * Sets a mark position in this stream. The parameter {@code readlimit}
-     * indicates how many bytes can be read before a mark is invalidated.
-     * Calling {@link #reset()} will reposition the stream back to the marked
-     * position if {@code readlimit} has not been surpassed. The underlying
-     * buffer may be increased in size to allow {@code readlimit} number of
-     * bytes to be supported.
-     *
-     * @param readlimit
-     *            the number of bytes that can be read before the mark is
-     *            invalidated.
-     * @see #reset()
-     */
-    @Override
-    public synchronized void mark(int readlimit) {
-        // This is stupid, but BitmapFactory.decodeStream calls mark(1024)
-        // which is too small for a substantial portion of images. This
-        // change (using Math.max) ensures that we don't overwrite readlimit
-        // with a smaller value
-        marklimit = Math.max(marklimit, readlimit);
-        markpos = pos;
+  /**
+   * Indicates whether {@code BufferedInputStream} supports the {@link #mark(int)} and {@link
+   * #reset()} methods.
+   *
+   * @return {@code true} for BufferedInputStreams.
+   * @see #mark(int)
+   * @see #reset()
+   */
+  @Override
+  public boolean markSupported() {
+    return true;
+  }
+
+  /**
+   * Reads a single byte from this stream and returns it as an integer in the range from 0 to 255.
+   * Returns -1 if the end of the source string has been reached. If the internal buffer does not
+   * contain any available bytes then it is filled from the source stream and the first byte is
+   * returned.
+   *
+   * @return the byte read or -1 if the end of the source stream has been reached.
+   * @throws IOException if this stream is closed or another IOException occurs.
+   */
+  @Override
+  public synchronized int read() throws IOException {
+    // Use local refs since buf and in may be invalidated by an
+    // unsynchronized close()
+    byte[] localBuf = buf;
+    InputStream localIn = in;
+    if (localBuf == null || localIn == null) {
+      throw streamClosed();
     }
 
-    /**
-     * Indicates whether {@code BufferedInputStream} supports the {@link #mark(int)}
-     * and {@link #reset()} methods.
-     *
-     * @return {@code true} for BufferedInputStreams.
-     * @see #mark(int)
-     * @see #reset()
-     */
-    @Override
-    public boolean markSupported() {
-        return true;
+    // Are there buffered bytes available?
+    if (pos >= count && fillbuf(localIn, localBuf) == -1) {
+      // no, fill buffer
+      return -1;
+    }
+    // localBuf may have been invalidated by fillbuf
+    if (localBuf != buf) {
+      localBuf = buf;
+      if (localBuf == null) {
+        throw streamClosed();
+      }
     }
 
-    /**
-     * Reads a single byte from this stream and returns it as an integer in the
-     * range from 0 to 255. Returns -1 if the end of the source string has been
-     * reached. If the internal buffer does not contain any available bytes then
-     * it is filled from the source stream and the first byte is returned.
-     *
-     * @return the byte read or -1 if the end of the source stream has been
-     *         reached.
-     * @throws IOException
-     *             if this stream is closed or another IOException occurs.
-     */
-    @Override
-    public synchronized int read() throws IOException {
-        // Use local refs since buf and in may be invalidated by an
-        // unsynchronized close()
-        byte[] localBuf = buf;
-        InputStream localIn = in;
-        if (localBuf == null || localIn == null) {
-            throw streamClosed();
-        }
+    // Did filling the buffer fail with -1 (EOF)?
+    if (count - pos > 0) {
+      return localBuf[pos++] & 0xFF;
+    }
+    return -1;
+  }
 
-        // Are there buffered bytes available?
-        if (pos >= count && fillbuf(localIn, localBuf) == -1) {
-            // no, fill buffer
-            return -1;
-        }
-        // localBuf may have been invalidated by fillbuf
-        if (localBuf != buf) {
-            localBuf = buf;
-            if (localBuf == null) {
-                throw streamClosed();
-            }
-        }
+  /**
+   * Reads at most {@code byteCount} bytes from this stream and stores them in byte array {@code
+   * buffer} starting at offset {@code offset}. Returns the number of bytes actually read or -1 if
+   * no bytes were read and the end of the stream was encountered. If all the buffered bytes have
+   * been used, a mark has not been put and the requested number of bytes is larger than the
+   * receiver's buffer size, this implementation bypasses the buffer and simply places the results
+   * directly into {@code buffer}.
+   *
+   * @param buffer the byte array in which to store the bytes read.
+   * @return the number of bytes actually read or -1 if end of stream.
+   * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code byteCount < 0}, or if {@code
+   *                                   offset + byteCount} is greater than the size of {@code
+   *                                   buffer}.
+   * @throws IOException               if the stream is already closed or another IOException
+   *                                   occurs.
+   */
+  @Override
+  public synchronized int read(byte[] buffer, int offset, int byteCount) throws IOException {
+    // Use local ref since buf may be invalidated by an unsynchronized close()
+    byte[] localBuf = buf;
+    if (localBuf == null) {
+      throw streamClosed();
+    }
+    //Arrays.checkOffsetAndCount(buffer.length, offset, byteCount);
+    if (byteCount == 0) {
+      return 0;
+    }
+    InputStream localIn = in;
+    if (localIn == null) {
+      throw streamClosed();
+    }
 
-        // Did filling the buffer fail with -1 (EOF)?
-        if (count - pos > 0) {
-            return localBuf[pos++] & 0xFF;
-        }
-        return -1;
+    int required;
+    if (pos < count) {
+      // There are bytes available in the buffer.
+      int copylength = count - pos >= byteCount ? byteCount : count - pos;
+      System.arraycopy(localBuf, pos, buffer, offset, copylength);
+      pos += copylength;
+      if (copylength == byteCount || localIn.available() == 0) {
+        return copylength;
+      }
+      offset += copylength;
+      required = byteCount - copylength;
+    } else {
+      required = byteCount;
     }
 
-    /**
-     * Reads at most {@code byteCount} bytes from this stream and stores them in
-     * byte array {@code buffer} starting at offset {@code offset}. Returns the
-     * number of bytes actually read or -1 if no bytes were read and the end of
-     * the stream was encountered. If all the buffered bytes have been used, a
-     * mark has not been set and the requested number of bytes is larger than
-     * the receiver's buffer size, this implementation bypasses the buffer and
-     * simply places the results directly into {@code buffer}.
-     *
-     * @param buffer
-     *            the byte array in which to store the bytes read.
-     * @return the number of bytes actually read or -1 if end of stream.
-     * @throws IndexOutOfBoundsException
-     *             if {@code offset < 0} or {@code byteCount < 0}, or if
-     *             {@code offset + byteCount} is greater than the size of
-     *             {@code buffer}.
-     * @throws IOException
-     *             if the stream is already closed or another IOException
-     *             occurs.
-     */
-    @Override
-    public synchronized int read(byte[] buffer, int offset, int byteCount) throws IOException {
-        // Use local ref since buf may be invalidated by an unsynchronized close()
-        byte[] localBuf = buf;
-        if (localBuf == null) {
-            throw streamClosed();
+    while (true) {
+      int read;
+      // If we're not marked and the required size is greater than the buffer,
+      // simply read the bytes directly bypassing the buffer.
+      if (markpos == -1 && required >= localBuf.length) {
+        read = localIn.read(buffer, offset, required);
+        if (read == -1) {
+          return required == byteCount ? -1 : byteCount - required;
         }
-        //Arrays.checkOffsetAndCount(buffer.length, offset, byteCount);
-        if (byteCount == 0) {
-            return 0;
+      } else {
+        if (fillbuf(localIn, localBuf) == -1) {
+          return required == byteCount ? -1 : byteCount - required;
         }
-        InputStream localIn = in;
-        if (localIn == null) {
+        // localBuf may have been invalidated by fillbuf
+        if (localBuf != buf) {
+          localBuf = buf;
+          if (localBuf == null) {
             throw streamClosed();
+          }
         }
 
-        int required;
-        if (pos < count) {
-            // There are bytes available in the buffer.
-            int copylength = count - pos >= byteCount ? byteCount : count - pos;
-            System.arraycopy(localBuf, pos, buffer, offset, copylength);
-            pos += copylength;
-            if (copylength == byteCount || localIn.available() == 0) {
-                return copylength;
-            }
-            offset += copylength;
-            required = byteCount - copylength;
-        } else {
-            required = byteCount;
-        }
-
-        while (true) {
-            int read;
-            // If we're not marked and the required size is greater than the buffer,
-            // simply read the bytes directly bypassing the buffer.
-            if (markpos == -1 && required >= localBuf.length) {
-                read = localIn.read(buffer, offset, required);
-                if (read == -1) {
-                    return required == byteCount ? -1 : byteCount - required;
-                }
-            } else {
-                if (fillbuf(localIn, localBuf) == -1) {
-                    return required == byteCount ? -1 : byteCount - required;
-                }
-                // localBuf may have been invalidated by fillbuf
-                if (localBuf != buf) {
-                    localBuf = buf;
-                    if (localBuf == null) {
-                        throw streamClosed();
-                    }
-                }
-
-                read = count - pos >= required ? required : count - pos;
-                System.arraycopy(localBuf, pos, buffer, offset, read);
-                pos += read;
-            }
-            required -= read;
-            if (required == 0) {
-                return byteCount;
-            }
-            if (localIn.available() == 0) {
-                return byteCount - required;
-            }
-            offset += read;
-        }
+        read = count - pos >= required ? required : count - pos;
+        System.arraycopy(localBuf, pos, buffer, offset, read);
+        pos += read;
+      }
+      required -= read;
+      if (required == 0) {
+        return byteCount;
+      }
+      if (localIn.available() == 0) {
+        return byteCount - required;
+      }
+      offset += read;
     }
+  }
 
-    /**
-     * Resets this stream to the last marked location.
-     *
-     * @throws IOException
-     *             if this stream is closed, no mark has been set or the mark is
-     *             no longer valid because more than {@code readlimit} bytes
-     *             have been read since setting the mark.
-     * @see #mark(int)
-     */
-    @Override
-    public synchronized void reset() throws IOException {
-        if (buf == null) {
-            throw new IOException("Stream is closed");
-        }
-        if (-1 == markpos) {
-            throw new InvalidMarkException("Mark has been invalidated");
-        }
-        pos = markpos;
+  /**
+   * Resets this stream to the last marked location.
+   *
+   * @throws IOException if this stream is closed, no mark has been put or the mark is no longer
+   *                     valid because more than {@code readlimit} bytes have been read since
+   *                     setting the mark.
+   * @see #mark(int)
+   */
+  @Override
+  public synchronized void reset() throws IOException {
+    if (buf == null) {
+      throw new IOException("Stream is closed");
+    }
+    if (-1 == markpos) {
+      throw new InvalidMarkException("Mark has been invalidated, pos: " + pos + " markLimit: "
+          + marklimit);
     }
+    pos = markpos;
+  }
 
-    /**
-     * Skips {@code byteCount} bytes in this stream. Subsequent calls to
-     * {@link #read} will not return these bytes unless {@link #reset} is
-     * used.
-     *
-     * @param byteCount
-     *            the number of bytes to skip. {@link #skip} does nothing and
-     *            returns 0 if {@code byteCount} is less than zero.
-     * @return the number of bytes actually skipped.
-     * @throws IOException
-     *             if this stream is closed or another IOException occurs.
-     */
-    @Override
-    public synchronized long skip(long byteCount) throws IOException {
-        // Use local refs since buf and in may be invalidated by an unsynchronized close()
-        byte[] localBuf = buf;
-        InputStream localIn = in;
-        if (localBuf == null) {
-            throw streamClosed();
-        }
-        if (byteCount < 1) {
-            return 0;
-        }
-        if (localIn == null) {
-            throw streamClosed();
-        }
+  /**
+   * Skips {@code byteCount} bytes in this stream. Subsequent calls to {@link #read} will not return
+   * these bytes unless {@link #reset} is used.
+   *
+   * @param byteCount the number of bytes to skip. {@link #skip} does nothing and returns 0 if
+   *                  {@code byteCount} is less than zero.
+   * @return the number of bytes actually skipped.
+   * @throws IOException if this stream is closed or another IOException occurs.
+   */
+  @Override
+  public synchronized long skip(long byteCount) throws IOException {
+    // Use local refs since buf and in may be invalidated by an unsynchronized close()
+    byte[] localBuf = buf;
+    InputStream localIn = in;
+    if (localBuf == null) {
+      throw streamClosed();
+    }
+    if (byteCount < 1) {
+      return 0;
+    }
+    if (localIn == null) {
+      throw streamClosed();
+    }
 
-        if (count - pos >= byteCount) {
-            pos += byteCount;
-            return byteCount;
-        }
-        long read = count - pos;
-        pos = count;
+    if (count - pos >= byteCount) {
+      pos += byteCount;
+      return byteCount;
+    }
+    long read = count - pos;
+    pos = count;
 
-        if (markpos != -1 && byteCount <= marklimit) {
-            if (fillbuf(localIn, localBuf) == -1) {
-                return read;
-            }
-            if (count - pos >= byteCount - read) {
-                pos += byteCount - read;
-                return byteCount;
-            }
-            // Couldn't get all the bytes, skip what we read.
-            read = read + count - pos;
-            pos = count;
-            return read;
-        }
-        return read + localIn.skip(byteCount - read);
+    if (markpos != -1 && byteCount <= marklimit) {
+      if (fillbuf(localIn, localBuf) == -1) {
+        return read;
+      }
+      if (count - pos >= byteCount - read) {
+        pos += byteCount - read;
+        return byteCount;
+      }
+      // Couldn't get all the bytes, skip what we read.
+      read = read + count - pos;
+      pos = count;
+      return read;
     }
+    return read + localIn.skip(byteCount - read);
+  }
 
-    /**
-     * An exception thrown when a mark can no longer be obeyed because the underlying buffer size is smaller than the
-     * amount of data read after the mark position.
-     */
-    public static class InvalidMarkException extends RuntimeException {
-        private static final long serialVersionUID = -4338378848813561757L;
+  /**
+   * An exception thrown when a mark can no longer be obeyed because the underlying buffer size is
+   * smaller than the amount of data read after the mark position.
+   */
+  public static class InvalidMarkException extends IOException {
+    private static final long serialVersionUID = -4338378848813561757L;
 
-        public InvalidMarkException(String detailMessage) {
-            super(detailMessage);
-        }
+    public InvalidMarkException(String detailMessage) {
+      super(detailMessage);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
new file mode 100644
index 000000000..33af8b853
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -0,0 +1,64 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * A {@link BitmapTransformation} which rounds the corners of a bitmap.
+ */
+public final class RoundedCorners extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  private final int roundingRadius;
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   */
+  public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {
+    super(bitmapPool);
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+    this.roundingRadius = roundingRadius;
+  }
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   */
+  public RoundedCorners(Context context, int roundingRadius) {
+    super(context);
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+    this.roundingRadius = roundingRadius;
+  }
+
+  @Override
+  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,
+        roundingRadius);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return (o instanceof RoundedCorners) && ((RoundedCorners) o).roundingRadius == roundingRadius;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode() + roundingRadius;
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+
+    byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
+    messageDigest.update(radiusData);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDataLoadProvider.java
deleted file mode 100644
index e05e48459..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDataLoadProvider.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.model.StreamEncoder;
-import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * An {@link com.bumptech.glide.provider.DataLoadProvider} that provides decoders and encoders for decoding and caching
- * {@link android.graphics.Bitmap}s using {@link java.io.InputStream} data.
- */
-public class StreamBitmapDataLoadProvider implements DataLoadProvider<InputStream, Bitmap> {
-    private final StreamBitmapDecoder decoder;
-    private final BitmapEncoder encoder;
-    private final StreamEncoder sourceEncoder;
-    private final FileToStreamDecoder<Bitmap> cacheDecoder;
-
-    public StreamBitmapDataLoadProvider(BitmapPool bitmapPool, DecodeFormat decodeFormat) {
-        sourceEncoder = new StreamEncoder();
-        decoder = new StreamBitmapDecoder(bitmapPool, decodeFormat);
-        encoder = new BitmapEncoder();
-        cacheDecoder = new FileToStreamDecoder<Bitmap>(decoder);
-    }
-
-    @Override
-    public ResourceDecoder<File, Bitmap> getCacheDecoder() {
-        return cacheDecoder;
-    }
-
-    @Override
-    public ResourceDecoder<InputStream, Bitmap> getSourceDecoder() {
-        return decoder;
-    }
-
-    @Override
-    public Encoder<InputStream> getSourceEncoder() {
-        return sourceEncoder;
-    }
-
-    @Override
-    public ResourceEncoder<Bitmap> getEncoder() {
-        return encoder;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index 407b8cb63..bedf360ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -1,65 +1,108 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.util.ExceptionCatchingInputStream;
+import com.bumptech.glide.util.MarkEnforcingInputStream;
 
+import java.io.IOException;
 import java.io.InputStream;
 
 /**
- * An {@link com.bumptech.glide.load.ResourceDecoder} that uses an
- * {@link com.bumptech.glide.load.resource.bitmap.Downsampler} to decode an {@link android.graphics.Bitmap} from an
- * {@link java.io.InputStream}.
+ * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link java.io.InputStream InputStreams}.
  */
 public class StreamBitmapDecoder implements ResourceDecoder<InputStream, Bitmap> {
-    private static final String ID = "StreamBitmapDecoder.com.bumptech.glide.load.resource.bitmap";
-    private final Downsampler downsampler;
-    private BitmapPool bitmapPool;
-    private DecodeFormat decodeFormat;
-    private String id;
 
-    public StreamBitmapDecoder(Context context) {
-        this(Glide.get(context).getBitmapPool());
-    }
+  private final Downsampler downsampler;
+  private final ByteArrayPool byteArrayPool;
 
-    public StreamBitmapDecoder(BitmapPool bitmapPool) {
-        this(bitmapPool, DecodeFormat.DEFAULT);
-    }
+  public StreamBitmapDecoder(Downsampler downsampler, ByteArrayPool byteArrayPool) {
+    this.downsampler = downsampler;
+    this.byteArrayPool = byteArrayPool;
+  }
+
+  @Override
+  public boolean handles(InputStream source, Options options) throws IOException {
+    return downsampler.handles(source);
+  }
 
-    public StreamBitmapDecoder(Context context, DecodeFormat decodeFormat) {
-        this(Glide.get(context).getBitmapPool(), decodeFormat);
+  @Override
+  public Resource<Bitmap> decode(InputStream source, int width, int height, Options options)
+      throws IOException {
+
+    // Use to fix the mark limit to avoid allocating buffers that fit entire images.
+    final RecyclableBufferedInputStream bufferedStream;
+    final boolean ownsBufferedStream;
+    if (source instanceof RecyclableBufferedInputStream) {
+      bufferedStream = (RecyclableBufferedInputStream) source;
+      ownsBufferedStream = false;
+    } else {
+      bufferedStream = new RecyclableBufferedInputStream(source, byteArrayPool);
+      ownsBufferedStream = true;
     }
 
-    public StreamBitmapDecoder(BitmapPool bitmapPool, DecodeFormat decodeFormat) {
-        this(Downsampler.AT_LEAST, bitmapPool, decodeFormat);
+    // Use to retrieve exceptions thrown while reading.
+    // TODO(#126): when the framework no longer returns partially decoded Bitmaps or provides a
+    // way to determine if a Bitmap is partially decoded, consider removing.
+    ExceptionCatchingInputStream exceptionStream =
+        ExceptionCatchingInputStream.obtain(bufferedStream);
+
+    // Use to read data.
+    // Ensures that we can always reset after reading an image header so that we can still
+    // attempt to decode the full image even when the header decode fails and/or overflows our read
+    // buffer. See #283.
+    MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);
+    UntrustedCallbacks callbacks = new UntrustedCallbacks(bufferedStream, exceptionStream);
+    try {
+      return downsampler.decode(invalidatingStream, width, height, options, callbacks);
+    } finally {
+      exceptionStream.release();
+      if (ownsBufferedStream) {
+        bufferedStream.release();
+      }
     }
+  }
+
+  /**
+   * Callbacks that provide reasonable handling for streams that may be unbuffered or insufficiently
+   * buffered or that may throw exceptions during decoding.
+   */
+  static class UntrustedCallbacks implements Downsampler.DecodeCallbacks {
+    private final RecyclableBufferedInputStream bufferedStream;
+    private final ExceptionCatchingInputStream exceptionStream;
 
-    public StreamBitmapDecoder(Downsampler downsampler, BitmapPool bitmapPool, DecodeFormat decodeFormat) {
-        this.downsampler = downsampler;
-        this.bitmapPool = bitmapPool;
-        this.decodeFormat = decodeFormat;
+    public UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
+        ExceptionCatchingInputStream exceptionStream) {
+      this.bufferedStream = bufferedStream;
+      this.exceptionStream = exceptionStream;
     }
 
     @Override
-    public Resource<Bitmap> decode(InputStream source, int width, int height) {
-        Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);
-        return BitmapResource.obtain(bitmap, bitmapPool);
+    public void onObtainBounds() {
+      // Once we've read the image header, we no longer need to allow the buffer to expand in
+      // size. To avoid unnecessary allocations reading image data, we fix the mark limit so that it
+      // is no larger than our current buffer size here. See issue #225.
+      bufferedStream.fixMarkLimit();
     }
 
     @Override
-    public String getId() {
-        if (id == null) {
-            id = new StringBuilder()
-                .append(ID)
-                .append(downsampler.getId())
-                .append(decodeFormat.name())
-                .toString();
+    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException {
+      // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non
+      // null, may catch and log a stack trace but still return a non null bitmap. To avoid
+      // displaying partially decoded bitmaps, we catch exceptions reading from the stream in our
+      // ExceptionCatchingInputStream and throw them here.
+      IOException streamException = exceptionStream.getException();
+      if (streamException != null) {
+        if (downsampled != null) {
+          bitmapPool.put(downsampled);
         }
-        return id;
+        throw streamException;
+      }
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 10a341ebe..64dff14b9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -2,314 +2,377 @@
 
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Matrix;
 import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.Rect;
 import android.graphics.RectF;
+import android.graphics.Shader;
 import android.media.ExifInterface;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.util.Log;
 
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
 
 /**
  * A class with methods to efficiently resize Bitmaps.
  */
 public final class TransformationUtils {
-    private static final String TAG = "TransformationUtils";
-    public static final int PAINT_FLAGS = Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
+  private static final String TAG = "TransformationUtils";
+  public static final int PAINT_FLAGS = Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
+  private static final Paint DEFAULT_PAINT = new Paint(PAINT_FLAGS);
+  private static final int CIRCLE_CROP_PAINT_FLAGS = PAINT_FLAGS | Paint.ANTI_ALIAS_FLAG;
+  private static final Paint CIRCLE_CROP_SHAPE_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
+  private static final Paint CIRCLE_CROP_BITMAP_PAINT;
+  static {
+    CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
+    CIRCLE_CROP_BITMAP_PAINT.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
+  }
 
-    private TransformationUtils() {
-        // Utility class.
+  private TransformationUtils() {
+    // Utility class.
+  }
+
+  /**
+   * A potentially expensive operation to crop the given Bitmap so that it fills the given
+   * dimensions. This operation is significantly less expensive in terms of memory if a mutable
+   * Bitmap with the given dimensions is passed in as well.
+   *
+   * @param pool     The BitmapPool to obtain a bitmap from.
+   * @param toCrop   The Bitmap to resize.
+   * @param width    The width in pixels of the final Bitmap.
+   * @param height   The height in pixels of the final Bitmap.
+   * @return The resized Bitmap (will be recycled if recycled is not null).
+   */
+  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int width,
+      int height) {
+    if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
+      return toCrop;
+    }
+    // From ImageView/Bitmap.createScaledBitmap.
+    final float scale;
+    float dx = 0, dy = 0;
+    Matrix m = new Matrix();
+    if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
+      scale = (float) height / (float) toCrop.getHeight();
+      dx = (width - toCrop.getWidth() * scale) * 0.5f;
+    } else {
+      scale = (float) width / (float) toCrop.getWidth();
+      dy = (height - toCrop.getHeight() * scale) * 0.5f;
     }
 
-    /**
-     * A potentially expensive operation to crop the given Bitmap so that it fills the given dimensions. This operation
-     * is significantly less expensive in terms of memory if a mutable Bitmap with the given dimensions is passed in
-     * as well.
-     *
-     * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
-     *                 into.
-     * @param toCrop The Bitmap to resize.
-     * @param width The width in pixels of the final Bitmap.
-     * @param height The height in pixels of the final Bitmap.
-     * @return The resized Bitmap (will be recycled if recycled is not null).
-     */
-    public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
-        if (toCrop == null) {
-            return null;
-        } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
-            return toCrop;
-        }
-        // From ImageView/Bitmap.createScaledBitmap.
-        final float scale;
-        float dx = 0, dy = 0;
-        Matrix m = new Matrix();
-        if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
-            scale = (float) height / (float) toCrop.getHeight();
-            dx = (width - toCrop.getWidth() * scale) * 0.5f;
-        } else {
-            scale = (float) width / (float) toCrop.getWidth();
-            dy = (height - toCrop.getHeight() * scale) * 0.5f;
-        }
-
-        m.setScale(scale, scale);
-        m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        final Bitmap result;
-        if (recycled != null) {
-            result = recycled;
-        } else {
-            result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null
-                        ? Bitmap.Config.ARGB_8888 : toCrop.getConfig());
-        }
-
-        // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-        TransformationUtils.setAlpha(toCrop, result);
-
-        Canvas canvas = new Canvas(result);
-        Paint paint = new Paint(PAINT_FLAGS);
-        canvas.drawBitmap(toCrop, m, paint);
-        return result;
+    m.setScale(scale, scale);
+    m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+
+    Bitmap result = pool.get(width, height, getSafeConfig(toCrop));
+    // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
+    TransformationUtils.setAlpha(toCrop, result);
+
+    Canvas canvas = new Canvas(result);
+    canvas.drawBitmap(toCrop, m, DEFAULT_PAINT);
+    clear(canvas);
+    return result;
+  }
+
+  /**
+   * An expensive operation to resize the given Bitmap down so that it fits within the given
+   * dimensions maintain the original proportions.
+   *
+   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param toFit  The Bitmap to shrink.
+   * @param width  The width in pixels the final image will fit within.
+   * @param height The height in pixels the final image will fit within.
+   * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or
+   * height matches the given dimensions and toFit fits within the given dimensions
+   */
+  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap toFit, int width,
+      int height) {
+    if (toFit.getWidth() == width && toFit.getHeight() == height) {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size matches input, returning input");
+      }
+      return toFit;
     }
+    final float widthPercentage = width / (float) toFit.getWidth();
+    final float heightPercentage = height / (float) toFit.getHeight();
+    final float minPercentage = Math.min(widthPercentage, heightPercentage);
 
-    /**
-     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintain
-     * the original proportions.
-     *
-     * @param toFit The Bitmap to shrink.
-     * @param pool The BitmapPool to try to reuse a bitmap from.
-     * @param width The width in pixels the final image will fit within.
-     * @param height The height in pixels the final image will fit within.
-     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
-     * given dimensions and toFit fits within the given dimensions
-     */
-    public static Bitmap fitCenter(Bitmap toFit, BitmapPool pool, int width, int height) {
-        if (toFit.getWidth() == width && toFit.getHeight() == height) {
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "requested target size matches input, returning input");
-            }
-            return toFit;
-        }
-        final float widthPercentage = width / (float) toFit.getWidth();
-        final float heightPercentage = height / (float) toFit.getHeight();
-        final float minPercentage = Math.min(widthPercentage, heightPercentage);
-
-        // take the floor of the target width/height, not round. If the matrix
-        // passed into drawBitmap rounds differently, we want to slightly
-        // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
-        final int targetWidth = (int) (minPercentage * toFit.getWidth());
-        final int targetHeight = (int) (minPercentage * toFit.getHeight());
-
-        if (toFit.getWidth() == targetWidth && toFit.getHeight() == targetHeight) {
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "adjusted target size matches input, returning input");
-            }
-            return toFit;
-        }
-
-        Bitmap.Config config = toFit.getConfig() != null ? toFit.getConfig() : Bitmap.Config.ARGB_8888;
-        Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
-        if (toReuse == null) {
-            toReuse = Bitmap.createBitmap(targetWidth, targetHeight, config);
-        }
-        // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-        TransformationUtils.setAlpha(toFit, toReuse);
-
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "request: " + width + "x" + height);
-            Log.v(TAG, "toFit:   " + toFit.getWidth() + "x" + toFit.getHeight());
-            Log.v(TAG, "toReuse: " + toReuse.getWidth() + "x" + toReuse.getHeight());
-            Log.v(TAG, "minPct:   " + minPercentage);
-        }
-
-        Canvas canvas = new Canvas(toReuse);
-        Matrix matrix = new Matrix();
-        matrix.setScale(minPercentage, minPercentage);
-        Paint paint = new Paint(PAINT_FLAGS);
-        canvas.drawBitmap(toFit, matrix, paint);
+    // take the floor of the target width/height, not round. If the matrix
+    // passed into drawBitmap rounds differently, we want to slightly
+    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
+    final int targetWidth = (int) (minPercentage * toFit.getWidth());
+    final int targetHeight = (int) (minPercentage * toFit.getHeight());
 
-        return toReuse;
+    if (toFit.getWidth() == targetWidth && toFit.getHeight() == targetHeight) {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "adjusted target size matches input, returning input");
+      }
+      return toFit;
     }
 
-    /**
-     * Sets the alpha of the Bitmap we're going to re-use to the alpha of the Bitmap we're going to transform. This
-     * keeps {@link android.graphics.Bitmap#hasAlpha()}} consistent before and after the transformation for
-     * transformations that don't add or remove transparent pixels.
-     *
-     * @param toTransform The {@link android.graphics.Bitmap} that will be transformed.
-     * @param outBitmap The {@link android.graphics.Bitmap} that will be returned from the transformation.
-     */
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-    public static void setAlpha(Bitmap toTransform, Bitmap outBitmap) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1 && outBitmap != null) {
-            outBitmap.setHasAlpha(toTransform.hasAlpha());
-        }
+    Bitmap.Config config = getSafeConfig(toFit);
+    Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
+
+    // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
+    TransformationUtils.setAlpha(toFit, toReuse);
+
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "request: " + width + "x" + height);
+      Log.v(TAG, "toFit:   " + toFit.getWidth() + "x" + toFit.getHeight());
+      Log.v(TAG, "toReuse: " + toReuse.getWidth() + "x" + toReuse.getHeight());
+      Log.v(TAG, "minPct:   " + minPercentage);
     }
 
-    /**
-     * Returns a matrix with rotation set based on Exif orientation tag.
-     * If the orientation is undefined or 0 null is returned.
-     *
-     * @deprecated No longer used by Glide, scheduled to be removed in Glide 4.0
-     * @param pathToOriginal Path to original image file that may have exif data.
-     * @return  A rotation in degrees based on exif orientation
-     */
-    @TargetApi(Build.VERSION_CODES.ECLAIR)
-    @Deprecated
-    public static int getOrientation(String pathToOriginal) {
-        int degreesToRotate = 0;
-        try {
-            ExifInterface exif = new ExifInterface(pathToOriginal);
-            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
-            return getExifOrientationDegrees(orientation);
-        } catch (Exception e) {
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Unable to get orientation for image with path=" + pathToOriginal, e);
-            }
-        }
-        return degreesToRotate;
+    Canvas canvas = new Canvas(toReuse);
+    Matrix matrix = new Matrix();
+    matrix.setScale(minPercentage, minPercentage);
+    canvas.drawBitmap(toFit, matrix, DEFAULT_PAINT);
+    clear(canvas);
+
+    return toReuse;
+  }
+
+  /**
+   * Sets the alpha of the Bitmap we're going to re-use to the alpha of the Bitmap we're going to
+   * transform. This keeps {@link android.graphics.Bitmap#hasAlpha()}} consistent before and after
+   * the transformation for transformations that don't add or remove transparent pixels.
+   *
+   * @param toTransform The {@link android.graphics.Bitmap} that will be transformed.
+   * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
+   *                    transformation.
+   */
+  public static void setAlpha(Bitmap toTransform, Bitmap outBitmap) {
+    setAlphaIfAvailable(outBitmap, toTransform.hasAlpha());
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+  private static void setAlphaIfAvailable(Bitmap bitmap, boolean hasAlpha) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1 && bitmap != null) {
+      bitmap.setHasAlpha(hasAlpha);
+    }
+  }
+
+  /**
+   * This is an expensive operation that copies the image in place with the pixels rotated. If
+   * possible rather use getOrientationMatrix, and put that as the imageMatrix on an ImageView.
+   *
+   * @param imageToOrient   Image Bitmap to orient.
+   * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is
+   *                        returned unmodified.
+   * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
+   */
+  public static Bitmap rotateImage(@NonNull Bitmap imageToOrient, int degreesToRotate) {
+    Bitmap result = imageToOrient;
+    try {
+      if (degreesToRotate != 0) {
+        Matrix matrix = new Matrix();
+        matrix.setRotate(degreesToRotate);
+        result = Bitmap.createBitmap(imageToOrient, 0, 0, imageToOrient.getWidth(),
+            imageToOrient.getHeight(), matrix, true /*filter*/);
+      }
+    } catch (Exception e) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Exception when trying to orient image", e);
+      }
     }
+    return result;
+  }
 
-    /**
-     * This is an expensive operation that copies the image in place with the pixels rotated.
-     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
-     *
-     * @deprecated No longer used by Glide, scheduled to be removed in Glide 4.0
-     * @param pathToOriginal Path to original image file that may have exif data.
-     * @param imageToOrient Image Bitmap to orient.
-     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
-     */
-    @Deprecated
-    public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient) {
-        int degreesToRotate = getOrientation(pathToOriginal);
-        return rotateImage(imageToOrient, degreesToRotate);
+  /**
+   * Get the # of degrees an image must be rotated to match the given exif orientation.
+   *
+   * @param exifOrientation The exif orientation [1-8]
+   * @return the number of degrees to rotate
+   */
+  public static int getExifOrientationDegrees(int exifOrientation) {
+    final int degreesToRotate;
+    switch (exifOrientation) {
+      case ExifInterface.ORIENTATION_TRANSPOSE:
+      case ExifInterface.ORIENTATION_ROTATE_90:
+        degreesToRotate = 90;
+        break;
+      case ExifInterface.ORIENTATION_ROTATE_180:
+      case ExifInterface.ORIENTATION_FLIP_VERTICAL:
+        degreesToRotate = 180;
+        break;
+      case ExifInterface.ORIENTATION_TRANSVERSE:
+      case ExifInterface.ORIENTATION_ROTATE_270:
+        degreesToRotate = 270;
+        break;
+      default:
+        degreesToRotate = 0;
     }
+    return degreesToRotate;
+  }
 
-    /**
-     * This is an expensive operation that copies the image in place with the pixels rotated.
-     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
-     *
-     * @param imageToOrient Image Bitmap to orient.
-     * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned
-     *                        unmodified.
-     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
-     */
-    public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
-        Bitmap result = imageToOrient;
-        try {
-            if (degreesToRotate != 0) {
-                Matrix matrix = new Matrix();
-                matrix.setRotate(degreesToRotate);
-                result = Bitmap.createBitmap(
-                        imageToOrient,
-                        0,
-                        0,
-                        imageToOrient.getWidth(),
-                        imageToOrient.getHeight(),
-                        matrix,
-                        true);
-            }
-        } catch (Exception e) {
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Exception when trying to orient image", e);
-            }
-        }
-        return result;
+  /**
+   * Rotate and/or flip the image to match the given exif orientation.
+   *
+   * @param pool            A pool that may or may not contain an image of the necessary
+   *                        dimensions.
+   * @param toOrient        The bitmap to rotate/flip.
+   * @param exifOrientation the exif orientation [1-8].
+   * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary.
+   */
+  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap toOrient,
+      int exifOrientation) {
+    final Matrix matrix = new Matrix();
+    initializeMatrixForRotation(exifOrientation, matrix);
+    if (matrix.isIdentity()) {
+      return toOrient;
     }
 
-    /**
-     * Get the # of degrees an image must be rotated to match the given exif orientation.
-     *
-     * @param exifOrientation The exif orientation [1-8]
-     * @return the number of degrees to rotate
-     */
-    public static int getExifOrientationDegrees(int exifOrientation) {
-        final int degreesToRotate;
-        switch (exifOrientation) {
-            case ExifInterface.ORIENTATION_TRANSPOSE:
-            case ExifInterface.ORIENTATION_ROTATE_90:
-                degreesToRotate = 90;
-                break;
-            case ExifInterface.ORIENTATION_ROTATE_180:
-            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
-                degreesToRotate = 180;
-                break;
-            case ExifInterface.ORIENTATION_TRANSVERSE:
-            case ExifInterface.ORIENTATION_ROTATE_270:
-                degreesToRotate = 270;
-                break;
-            default:
-                degreesToRotate = 0;
-
-        }
-        return degreesToRotate;
+    // From Bitmap.createBitmap.
+    final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
+    matrix.mapRect(newRect);
+
+    final int newWidth = Math.round(newRect.width());
+    final int newHeight = Math.round(newRect.height());
+
+    Bitmap.Config config = getSafeConfig(toOrient);
+    Bitmap result = pool.get(newWidth, newHeight, config);
+
+    matrix.postTranslate(-newRect.left, -newRect.top);
+
+    final Canvas canvas = new Canvas(result);
+    canvas.drawBitmap(toOrient, matrix, DEFAULT_PAINT);
+    clear(canvas);
+
+    return result;
+  }
+
+  /**
+   * Crop the image to a circle and resize to the specified width/height.  The circle crop will
+   * have the same width and height equal to the min-edge of the result image.
+   *
+   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param toCrop   The Bitmap to resize.
+   * @param destWidth    The width in pixels of the final Bitmap.
+   * @param destHeight   The height in pixels of the final Bitmap.
+   * @return The resized Bitmap (will be recycled if recycled is not null).
+   */
+  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int destWidth,
+      int destHeight) {
+    int destMinEdge = Math.min(destWidth, destHeight);
+    float radius = destMinEdge / 2f;
+    Rect destRect = new Rect((destWidth - destMinEdge) / 2, (destHeight - destMinEdge) / 2,
+        destMinEdge, destMinEdge);
+
+    int srcWidth = toCrop.getWidth();
+    int srcHeight = toCrop.getHeight();
+    int srcMinEdge = Math.min(srcWidth, srcHeight);
+    Rect srcRect = new Rect((srcWidth - srcMinEdge) / 2, (srcHeight - srcMinEdge) / 2,
+        srcMinEdge, srcMinEdge);
+
+    Bitmap result = pool.get(destWidth, destHeight, getSafeConfig(toCrop));
+    setAlphaIfAvailable(result, true /*hasAlpha*/);
+    Canvas canvas = new Canvas(result);
+
+    // Draw a circle
+    canvas.drawCircle(destRect.left + radius, destRect.top + radius, radius,
+        CIRCLE_CROP_SHAPE_PAINT);
+
+    // Draw the bitmap in the circle
+    canvas.drawBitmap(toCrop, srcRect, destRect, CIRCLE_CROP_BITMAP_PAINT);
+    clear(canvas);
+
+    return result;
+  }
+
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * @param toTransform the source bitmap to use as a basis for the created bitmap.
+   * @param width the width of the generated bitmap.
+   * @param height the height of the generated bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to toTransform but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   */
+  public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
+      int width, int height, int roundingRadius) {
+    Preconditions.checkArgument(width > 0, "width must be greater than 0.");
+    Preconditions.checkArgument(height > 0, "height must be greater than 0.");
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+
+    boolean recycleToTransform = false;
+
+    // Alpha is required for this transformation.
+    if (!Bitmap.Config.ARGB_8888.equals(toTransform.getConfig())) {
+      Bitmap argbBitmap = pool.get(toTransform.getWidth(), toTransform.getHeight(),
+          Bitmap.Config.ARGB_8888);
+      new Canvas(argbBitmap).drawBitmap(toTransform, 0, 0, null);
+
+      // We now own toTransform. It's our responsibility to replace it in the pool.
+      toTransform = argbBitmap;
+      recycleToTransform = true;
     }
+    final Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
+
+    setAlphaIfAvailable(result, true /* hasAlpha */);
 
-    /**
-     * Rotate and/or flip the image to match the given exif orientation.
-     *
-     * @param toOrient The bitmap to rotate/flip.
-     * @param pool A pool that may or may not contain an image of the necessary dimensions.
-     * @param exifOrientation the exif orientation [1-8].
-     * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary.
-     */
-    public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifOrientation) {
-        final Matrix matrix = new Matrix();
-        initializeMatrixForRotation(exifOrientation, matrix);
-        if (matrix.isIdentity()) {
-            return toOrient;
-        }
-
-        // From Bitmap.createBitmap.
-        final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
-        matrix.mapRect(newRect);
-
-        final int newWidth = Math.round(newRect.width());
-        final int newHeight = Math.round(newRect.height());
-
-        Bitmap result = pool.get(newWidth, newHeight, toOrient.getConfig());
-        if (result == null) {
-            result = Bitmap.createBitmap(newWidth, newHeight, toOrient.getConfig());
-        }
-
-        matrix.postTranslate(-newRect.left, -newRect.top);
-
-        final Canvas canvas = new Canvas(result);
-        final Paint paint = new Paint(PAINT_FLAGS);
-        canvas.drawBitmap(toOrient, matrix, paint);
-
-        return result;
+    BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
+        Shader.TileMode.CLAMP);
+    Paint paint = new Paint();
+    paint.setAntiAlias(true);
+    paint.setShader(shader);
+    RectF rect = new RectF(0, 0, result.getWidth(), result.getHeight());
+    Canvas canvas = new Canvas(result);
+    canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+    canvas.drawRoundRect(rect, roundingRadius, roundingRadius, paint);
+    clear(canvas);
+
+    if (recycleToTransform) {
+      pool.put(toTransform);
     }
 
-    // Visible for testing.
-    static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
-        switch (exifOrientation) {
-            case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
-                matrix.setScale(-1, 1);
-                break;
-            case ExifInterface.ORIENTATION_ROTATE_180:
-                matrix.setRotate(180);
-                break;
-            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
-                matrix.setRotate(180);
-                matrix.postScale(-1, 1);
-                break;
-            case ExifInterface.ORIENTATION_TRANSPOSE:
-                matrix.setRotate(90);
-                matrix.postScale(-1, 1);
-                break;
-            case ExifInterface.ORIENTATION_ROTATE_90:
-                matrix.setRotate(90);
-                break;
-            case ExifInterface.ORIENTATION_TRANSVERSE:
-                matrix.setRotate(-90);
-                matrix.postScale(-1, 1);
-                break;
-            case ExifInterface.ORIENTATION_ROTATE_270:
-                matrix.setRotate(-90);
-                break;
-            default:
-                // Do nothing.
-        }
+    return result;
+  }
+
+  // Avoids warnings in M+.
+  private static void clear(Canvas canvas) {
+    canvas.setBitmap(null);
+  }
+
+  private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
+    return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
+  }
+
+  // Visible for testing.
+  static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
+    switch (exifOrientation) {
+      case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
+        matrix.setScale(-1, 1);
+        break;
+      case ExifInterface.ORIENTATION_ROTATE_180:
+        matrix.setRotate(180);
+        break;
+      case ExifInterface.ORIENTATION_FLIP_VERTICAL:
+        matrix.setRotate(180);
+        matrix.postScale(-1, 1);
+        break;
+      case ExifInterface.ORIENTATION_TRANSPOSE:
+        matrix.setRotate(90);
+        matrix.postScale(-1, 1);
+        break;
+      case ExifInterface.ORIENTATION_ROTATE_90:
+        matrix.setRotate(90);
+        break;
+      case ExifInterface.ORIENTATION_TRANSVERSE:
+        matrix.setRotate(-90);
+        matrix.postScale(-1, 1);
+        break;
+      case ExifInterface.ORIENTATION_ROTATE_270:
+        matrix.setRotate(-90);
+        break;
+      default:
+        // Do nothing.
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index 537b185ca..c3cb3f5c6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -1,53 +1,149 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
 
-import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
 import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
 
 /**
- * An {@link com.bumptech.glide.load.resource.bitmap.BitmapDecoder} that can decode a thumbnail frame
- * {@link Bitmap} from a {@link android.os.ParcelFileDescriptor} containing a video.
+ * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame
+ * {@link android.graphics.Bitmap} from a {@link android.os.ParcelFileDescriptor} containing a
+ * video.
  *
  * @see android.media.MediaMetadataRetriever
  */
-public class VideoBitmapDecoder implements BitmapDecoder<ParcelFileDescriptor> {
-    private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =  new MediaMetadataRetrieverFactory();
-    private MediaMetadataRetrieverFactory factory;
+public class VideoBitmapDecoder implements ResourceDecoder<ParcelFileDescriptor, Bitmap> {
+  /**
+   * A constant indicating we should use whatever frame we consider best, frequently not the first
+   * frame.
+   */
+  public static final long DEFAULT_FRAME = -1;
 
-    public VideoBitmapDecoder() {
-        this(DEFAULT_FACTORY);
-    }
+  /**
+   * A long indicating the time position (in microseconds) of the target frame which will be
+   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
+   * extract the video frame.
+   *
+   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
+   * source has a frame located at the position. When this happens, a frame nearby will be returned.
+   * If the long is negative, time position and option will ignored, and any frame that the
+   * implementation considers as representative may be returned.
+   */
+  public static final Option<Long> TARGET_FRAME = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
+      new Option.CacheKeyUpdater<Long>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
+        @Override
+        public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putLong(value).array());
+          }
+        }
+      });
+
+  /**
+   * An integer indicating the frame option used to retrieve a target frame.
+   *
+   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
+   * {@link #DEFAULT_FRAME}.
+   *
+   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
+   */
+  public static final Option<Integer> FRAME_OPTION = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
+      null /*defaultValue*/,
+      new Option.CacheKeyUpdater<Integer>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+        @Override
+        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {
+          if (value == null) {
+            return;
+          }
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putInt(value).array());
+          }
+        }
+      }
+  );
+
+  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
+      new MediaMetadataRetrieverFactory();
 
-    VideoBitmapDecoder(MediaMetadataRetrieverFactory factory) {
-        this.factory = factory;
+  private final BitmapPool bitmapPool;
+  private final MediaMetadataRetrieverFactory factory;
+
+  public VideoBitmapDecoder(Context context) {
+    this(Glide.get(context).getBitmapPool());
+  }
+
+  public VideoBitmapDecoder(BitmapPool bitmapPool) {
+    this(bitmapPool, DEFAULT_FACTORY);
+  }
+
+  // Visible for testing.
+  VideoBitmapDecoder(BitmapPool bitmapPool, MediaMetadataRetrieverFactory factory) {
+    this.bitmapPool = bitmapPool;
+    this.factory = factory;
+  }
+
+  @Override
+  public boolean handles(ParcelFileDescriptor data, Options options) {
+    MediaMetadataRetriever retriever = factory.build();
+    try {
+      retriever.setDataSource(data.getFileDescriptor());
+      return true;
+    } catch (RuntimeException e) {
+      // Throws a generic runtime exception when given invalid data.
+      return false;
+    } finally {
+      retriever.release();
     }
+  }
 
-    @Override
-    public Bitmap decode(ParcelFileDescriptor resource, BitmapPool bitmapPool, int outWidth, int outHeight,
-            DecodeFormat decodeFormat)
-            throws IOException {
-        MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-        mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
-        Bitmap result = mediaMetadataRetriever.getFrameAtTime();
-        mediaMetadataRetriever.release();
-        resource.close();
-        return result;
+  @Override
+  public Resource<Bitmap> decode(ParcelFileDescriptor resource, int outWidth, int outHeight,
+      Options options) throws IOException {
+    long frameTimeMicros = options.get(TARGET_FRAME);
+    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
+      throw new IllegalArgumentException(
+          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
     }
+    Integer frameOption = options.get(FRAME_OPTION);
 
-    @Override
-    public String getId() {
-        return "VideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
+    final Bitmap result;
+    if (frameTimeMicros == DEFAULT_FRAME) {
+      result = mediaMetadataRetriever.getFrameAtTime();
+    } else if (frameOption == null) {
+      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
+    } else {
+      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
     }
+    mediaMetadataRetriever.release();
+    resource.close();
+    return BitmapResource.obtain(result, bitmapPool);
+  }
 
-    // Visible for testing.
-    static class MediaMetadataRetrieverFactory {
-        public MediaMetadataRetriever build() {
-            return new MediaMetadataRetriever();
-        }
+  // Visible for testing.
+  static class MediaMetadataRetrieverFactory {
+    public MediaMetadataRetriever build() {
+      return new MediaMetadataRetriever();
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
new file mode 100644
index 000000000..815c14b8f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
@@ -0,0 +1,44 @@
+package com.bumptech.glide.load.resource.bytes;
+
+import com.bumptech.glide.load.data.DataRewinder;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * Rewinds {@link java.nio.ByteBuffer}s.
+ */
+public class ByteBufferRewinder implements DataRewinder<ByteBuffer> {
+  private final ByteBuffer buffer;
+
+  public ByteBufferRewinder(ByteBuffer buffer) {
+    this.buffer = buffer;
+  }
+
+  @Override
+  public ByteBuffer rewindAndGet() throws IOException {
+    buffer.position(0);
+    return buffer;
+  }
+
+  @Override
+  public void cleanup() {
+    // Do nothing.
+  }
+
+  /**
+   * Factory for {@link com.bumptech.glide.load.resource.bytes.ByteBufferRewinder}.
+   */
+  public static class Factory implements DataRewinder.Factory<ByteBuffer> {
+
+    @Override
+    public DataRewinder<ByteBuffer> build(ByteBuffer data) {
+      return new ByteBufferRewinder(data);
+    }
+
+    @Override
+    public Class<ByteBuffer> getDataClass() {
+      return ByteBuffer.class;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
index a6368d26b..6b0d7a2be 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
@@ -1,32 +1,35 @@
 package com.bumptech.glide.load.resource.bytes;
 
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Preconditions;
 
 /**
  * An {@link com.bumptech.glide.load.engine.Resource} wrapping a byte array.
  */
 public class BytesResource implements Resource<byte[]> {
-    private final byte[] bytes;
+  private final byte[] bytes;
 
-    public BytesResource(byte[] bytes) {
-        if (bytes == null) {
-            throw new NullPointerException("Bytes must not be null");
-        }
-        this.bytes = bytes;
-    }
+  public BytesResource(byte[] bytes) {
+    this.bytes = Preconditions.checkNotNull(bytes);
+  }
 
-    @Override
-    public byte[] get() {
-        return bytes;
-    }
+  @Override
+  public Class<byte[]> getResourceClass() {
+    return byte[].class;
+  }
 
-    @Override
-    public int getSize() {
-        return bytes.length;
-    }
+  @Override
+  public byte[] get() {
+    return bytes;
+  }
 
-    @Override
-    public void recycle() {
-        // Do nothing.
-    }
+  @Override
+  public int getSize() {
+    return bytes.length;
+  }
+
+  @Override
+  public void recycle() {
+    // Do nothing.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 643f7b40e..4cea85519 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -3,36 +3,33 @@
 import android.graphics.drawable.Drawable;
 
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Preconditions;
 
 /**
- * Simple wrapper for an Android {@link Drawable} which returns a
- * {@link android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable}
- * based on it's {@link android.graphics.drawable.Drawable.ConstantState state}.
+ * Simple wrapper for an Android {@link Drawable} which returns a {@link
+ * android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable} based on it's {@link
+ * android.graphics.drawable.Drawable.ConstantState state}.
  *
- * <b>Suggested usages only include {@code T}s where the new drawable is of the same or descendant class.</b>
+ * <b>Suggested usages only include {@code T}s where the new drawable is of the same or descendant
+ * class.</b>
  *
  * @param <T> type of the wrapped {@link Drawable}
  */
 public abstract class DrawableResource<T extends Drawable> implements Resource<T> {
-    protected final T drawable;
-    private boolean returnedOriginalDrawable;
+  protected final T drawable;
 
-    public DrawableResource(T drawable) {
-        if (drawable == null) {
-            throw new NullPointerException("Drawable must not be null!");
-        }
-        this.drawable = drawable;
-    }
+  public DrawableResource(T drawable) {
+    this.drawable = Preconditions.checkNotNull(drawable);
+  }
 
-    @SuppressWarnings("unchecked")
-    // drawables should always return a copy of the same class
-    @Override
-    public final T get() {
-        if (!returnedOriginalDrawable) {
-            returnedOriginalDrawable = true;
-            return drawable;
-        } else {
-            return (T) drawable.getConstantState().newDrawable();
-        }
-    }
+  @SuppressWarnings("unchecked")
+  @Override
+  public final T get() {
+    // Drawables contain temporary state related to how they're being displayed (alpha, color
+    // filter etc), so
+    // return a new copy each time. If we ever return the original drawable, it's temporary state
+    // may be changed
+    // and subsequent copies may end up with that temporary state. See #276.
+    return (T) drawable.getConstantState().newDrawable();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
new file mode 100644
index 000000000..9d8c8a2f2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -0,0 +1,38 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+
+/**
+ * Contains {@link Drawable} specific animation options.
+ */
+public final class DrawableTransitionOptions extends
+    TransitionOptions<DrawableTransitionOptions, Drawable> {
+
+  public static DrawableTransitionOptions withCrossFade() {
+    return new DrawableTransitionOptions().crossFade();
+  }
+
+  public static DrawableTransitionOptions withCrossFade(int duration) {
+    return new DrawableTransitionOptions().crossFade(duration);
+  }
+
+  public static DrawableTransitionOptions withCrossFade(int animationId, int duration) {
+    return new DrawableTransitionOptions().crossFade(animationId, duration);
+  }
+
+  public DrawableTransitionOptions crossFade() {
+    return transition(new DrawableCrossFadeFactory());
+  }
+
+  public DrawableTransitionOptions crossFade(int duration) {
+    return transition(new DrawableCrossFadeFactory(duration));
+  }
+
+  public DrawableTransitionOptions crossFade(int animationId, int duration) {
+    return transition(new DrawableCrossFadeFactory(animationId, duration));
+  }
+}
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/GlideDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/GlideDrawable.java
deleted file mode 100644
index c38dcefa4..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/GlideDrawable.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.bumptech.glide.load.resource.drawable;
-
-import android.graphics.drawable.Animatable;
-import android.graphics.drawable.Drawable;
-
-/**
- * A base class for drawables that are either static equivalents of {@link android.graphics.drawable.BitmapDrawable} or
- * that contain an animation.
- */
-public abstract class GlideDrawable extends Drawable implements Animatable {
-    /** A constant indicating that an animated drawable should loop continuously. */
-    public static final int LOOP_FOREVER = -1;
-    /**
-     * A constant indicating that an animated drawable should loop for its default number of times. For animated GIFs,
-     * this constant indicates the GIF should use the netscape loop count if present.
-     */
-    public static final int LOOP_INTRINSIC = 0;
-
-    /**
-     * Returns {@code true} if this drawable is animated.
-     */
-    public abstract boolean isAnimated();
-
-    /**
-     * Sets the number of times the animation should loop. This method will only have an affect if
-     * {@link #isAnimated ()}}  returns {@code true}. A loop count of <=0 indicates loop forever.
-     */
-    public abstract void setLoopCount(int loopCount);
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
index ebd1e1157..01c54c297 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
@@ -1,22 +1,24 @@
 package com.bumptech.glide.load.resource.file;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 
 import java.io.File;
 
 /**
- * A simple {@link com.bumptech.glide.load.ResourceDecoder} that creates resource for a given {@link java.io.File}.
+ * A simple {@link com.bumptech.glide.load.ResourceDecoder} that creates resource for a given {@link
+ * java.io.File}.
  */
 public class FileDecoder implements ResourceDecoder<File, File> {
 
-    @Override
-    public Resource<File> decode(File source, int width, int height) {
-        return new FileResource(source);
-    }
+  @Override
+  public boolean handles(File source, Options options) {
+    return true;
+  }
 
-    @Override
-    public String getId() {
-        return "";
-    }
+  @Override
+  public Resource<File> decode(File source, int width, int height, Options options) {
+    return new FileResource(source);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
index 40830a8af..4cc540b0c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
@@ -8,7 +8,7 @@
  * A simple {@link com.bumptech.glide.load.engine.Resource} that wraps a {@link File}.
  */
 public class FileResource extends SimpleResource<File> {
-    public FileResource(File file) {
-        super(file);
-    }
+  public FileResource(File file) {
+    super(file);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileToStreamDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileToStreamDecoder.java
deleted file mode 100644
index a06099867..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileToStreamDecoder.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package com.bumptech.glide.load.resource.file;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * A decoder that wraps an {@link InputStream} decoder to allow it to decode from a file.
- *
- * @param <T> The type of resource that the wrapped InputStream decoder decodes.
- */
-public class FileToStreamDecoder<T> implements ResourceDecoder<File, T> {
-    private static final FileOpener DEFAULT_FILE_OPENER = new FileOpener();
-
-    private ResourceDecoder<InputStream, T> streamDecoder;
-    private final FileOpener fileOpener;
-
-    public FileToStreamDecoder(ResourceDecoder<InputStream, T> streamDecoder) {
-        this(streamDecoder, DEFAULT_FILE_OPENER);
-    }
-
-    // Exposed for testing.
-    FileToStreamDecoder(ResourceDecoder<InputStream, T> streamDecoder, FileOpener fileOpener) {
-        this.streamDecoder = streamDecoder;
-        this.fileOpener = fileOpener;
-    }
-
-    @Override
-    public Resource<T> decode(File source, int width, int height) throws IOException {
-        InputStream is = null;
-        Resource<T> result = null;
-        try {
-            is = fileOpener.open(source);
-            result = streamDecoder.decode(is, width, height);
-        } finally {
-            if (is != null) {
-                try {
-                    is.close();
-                } catch (IOException e) {
-                    // Do nothing.
-                }
-            }
-        }
-        return result;
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
-
-    // Visible for testing.
-    static class FileOpener {
-        public InputStream open(File file) throws FileNotFoundException {
-            return new FileInputStream(file);
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/StreamFileDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/file/StreamFileDataLoadProvider.java
deleted file mode 100644
index 13df0a204..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/StreamFileDataLoadProvider.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package com.bumptech.glide.load.resource.file;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.model.StreamEncoder;
-import com.bumptech.glide.load.resource.NullResourceEncoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * An {@link com.bumptech.glide.provider.DataLoadProvider} that provides encoders and decoders for for obtaining a
- * cache file from {@link java.io.InputStream} data.
- */
-public class StreamFileDataLoadProvider implements DataLoadProvider<InputStream, File> {
-    private static final ErrorSourceDecoder ERROR_DECODER = new ErrorSourceDecoder();
-
-    private final ResourceDecoder<File, File> cacheDecoder;
-    private final Encoder<InputStream> encoder;
-
-    public StreamFileDataLoadProvider() {
-        cacheDecoder = new FileDecoder();
-        encoder = new StreamEncoder();
-    }
-
-    @Override
-    public ResourceDecoder<File, File> getCacheDecoder() {
-        return cacheDecoder;
-    }
-
-    @Override
-    public ResourceDecoder<InputStream, File> getSourceDecoder() {
-        return ERROR_DECODER;
-    }
-
-    @Override
-    public Encoder<InputStream> getSourceEncoder() {
-        return encoder;
-    }
-
-    @Override
-    public ResourceEncoder<File> getEncoder() {
-        return NullResourceEncoder.get();
-    }
-
-    private static class ErrorSourceDecoder implements ResourceDecoder<InputStream, File> {
-        @Override
-        public Resource<File> decode(InputStream source, int width, int height) {
-            throw new Error("You cannot decode a File from an InputStream by default,"
-                    + " try either #diskCacheStratey(DiskCacheStrategy.SOURCE) to avoid this call or"
-                    + " #decoder(ResourceDecoder) to replace this Decoder");
-        }
-
-        @Override
-        public String getId() {
-            return "";
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
new file mode 100644
index 000000000..da9ba30ff
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -0,0 +1,165 @@
+package com.bumptech.glide.load.resource.gif;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.util.Log;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.gifdecoder.GifHeader;
+import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.resource.UnitTransformation;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
+import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Util;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Queue;
+
+/**
+ * An {@link com.bumptech.glide.load.ResourceDecoder} that decodes {@link
+ * com.bumptech.glide.load.resource.gif.GifDrawable} from {@link java.io.InputStream} data.
+ */
+public class ByteBufferGifDecoder implements ResourceDecoder<ByteBuffer, GifDrawable> {
+  private static final String TAG = "BufferGifDecoder";
+  private static final GifDecoderFactory GIF_DECODER_FACTORY = new GifDecoderFactory();
+
+  /**
+   *  If set to {@code true}, disables this decoder
+   *  ({@link #handles(ByteBuffer, Options)} will return {@code false}). Defaults to
+   * {@code false}.
+   */
+  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
+      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
+
+  private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
+
+  private final Context context;
+  private final GifHeaderParserPool parserPool;
+  private final BitmapPool bitmapPool;
+  private final GifDecoderFactory gifDecoderFactory;
+  private final GifBitmapProvider provider;
+
+  public ByteBufferGifDecoder(Context context) {
+    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
+  }
+
+  public ByteBufferGifDecoder(
+      Context context, BitmapPool bitmapPool, ArrayPool arrayPool) {
+    this(context, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
+  }
+
+  // Visible for testing.
+  ByteBufferGifDecoder(
+      Context context,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      GifHeaderParserPool parserPool,
+      GifDecoderFactory gifDecoderFactory) {
+    this.context = context;
+    this.bitmapPool = bitmapPool;
+    this.gifDecoderFactory = gifDecoderFactory;
+    this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
+    this.parserPool = parserPool;
+  }
+
+  @Override
+  public boolean handles(ByteBuffer source, Options options) throws IOException {
+    ByteArrayPool byteArrayPool = new LruByteArrayPool();
+    return !options.get(DISABLE_ANIMATION)
+        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+  }
+
+  @Override
+  public GifDrawableResource decode(ByteBuffer source, int width, int height, Options options) {
+    final GifHeaderParser parser = parserPool.obtain(source);
+    try {
+      return decode(source, width, height, parser);
+    } finally {
+      parserPool.release(parser);
+    }
+  }
+
+  private GifDrawableResource decode(ByteBuffer byteBuffer, int width, int height,
+      GifHeaderParser parser) {
+    long startTime = LogTime.getLogTime();
+    final GifHeader header = parser.parseHeader();
+    if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
+      // If we couldn't decode the GIF, we will end up with a frame count of 0.
+      return null;
+    }
+
+
+    int sampleSize = getSampleSize(header, width, height);
+    GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
+    gifDecoder.advance();
+    Bitmap firstFrame = gifDecoder.getNextFrame();
+    if (firstFrame == null) {
+      return null;
+    }
+
+    Transformation<Bitmap> unitTransformation = UnitTransformation.get();
+
+    GifDrawable gifDrawable =
+        new GifDrawable(context, gifDecoder, bitmapPool, unitTransformation, width, height,
+            firstFrame);
+
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Decoded gif from stream in " + LogTime.getElapsedMillis(startTime));
+    }
+
+    return new GifDrawableResource(gifDrawable);
+  }
+
+  private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {
+    int exactSampleSize = Math.min(gifHeader.getHeight() / targetHeight,
+        gifHeader.getWidth() / targetWidth);
+    int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);
+    // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code
+    // than 0.
+    int sampleSize = Math.max(1, powerOfTwoSampleSize);
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Downsampling gif"
+          + ", sampleSize: " + sampleSize
+          + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
+          + ", actual dimens: [" + gifHeader.getWidth() + "x" + gifHeader.getHeight() + "]");
+    }
+    return sampleSize;
+  }
+
+  // Visible for testing.
+  static class GifDecoderFactory {
+    public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
+        ByteBuffer data, int sampleSize) {
+      return new GifDecoder(provider, header, data, sampleSize);
+    }
+  }
+
+  // Visible for testing.
+  static class GifHeaderParserPool {
+    private final Queue<GifHeaderParser> pool = Util.createQueue(0);
+
+    public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
+      GifHeaderParser result = pool.poll();
+      if (result == null) {
+        result = new GifHeaderParser();
+      }
+      return result.setData(buffer);
+    }
+
+    public synchronized void release(GifHeaderParser parser) {
+      parser.clear();
+      pool.offer(parser);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index de52039fb..0cd50a9ce 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -2,26 +2,78 @@
 
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
-class GifBitmapProvider implements GifDecoder.BitmapProvider {
-    private final BitmapPool bitmapPool;
+/**
+ * Implements {@link com.bumptech.glide.gifdecoder.GifDecoder.BitmapProvider} by wrapping Glide's
+ * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
+ */
+public final class GifBitmapProvider implements GifDecoder.BitmapProvider {
+  private final BitmapPool bitmapPool;
+  @Nullable private final ArrayPool arrayPool;
 
-    public GifBitmapProvider(BitmapPool bitmapPool) {
-        this.bitmapPool = bitmapPool;
+  /**
+   * Constructs an instance without a shared byte array pool. Byte arrays will be always constructed
+   * when requested.
+   */
+  public GifBitmapProvider(BitmapPool bitmapPool) {
+    this(bitmapPool, null /* arrayPool */);
+  }
+
+  /**
+   * Constructs an instance with a shared array pool. Arrays will be reused where
+   * possible.
+   */
+  public GifBitmapProvider(BitmapPool bitmapPool, ArrayPool arrayPool) {
+    this.bitmapPool = bitmapPool;
+    this.arrayPool = arrayPool;
+  }
+
+  @NonNull
+  @Override
+  public Bitmap obtain(int width, int height, Bitmap.Config config) {
+    return bitmapPool.getDirty(width, height, config);
+  }
+
+  @Override
+  public void release(Bitmap bitmap) {
+    bitmapPool.put(bitmap);
+  }
+
+  @Override
+  public byte[] obtainByteArray(int size) {
+    if (arrayPool == null) {
+      return new byte[size];
+    }
+    return arrayPool.get(size, byte[].class);
+  }
+
+  @Override
+  public void release(byte[] bytes) {
+    if (arrayPool == null) {
+      return;
     }
+    arrayPool.put(bytes, byte[].class);
+  }
 
-    @Override
-    public Bitmap obtain(int width, int height, Bitmap.Config config) {
-        return bitmapPool.getDirty(width, height, config);
+  @Override
+  public int[] obtainIntArray(int size) {
+    if (arrayPool == null) {
+      return new int[size];
     }
+    return arrayPool.get(size, int[].class);
+  }
 
-    @Override
-    public void release(Bitmap bitmap) {
-        if (!bitmapPool.put(bitmap)) {
-            bitmap.recycle();
-        }
+  @Override
+  public void release(int[] array) {
+    if (arrayPool == null) {
+      return;
     }
+    arrayPool.put(array, int[].class);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index b70794f5d..dfcffbc6f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -9,360 +9,333 @@
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
 import android.graphics.Rect;
+import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.view.Gravity;
 
 import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
+import com.bumptech.glide.util.Preconditions;
+
+import java.nio.ByteBuffer;
 
 /**
  * An animated {@link android.graphics.drawable.Drawable} that plays the frames of an animated GIF.
  */
-public class GifDrawable extends GlideDrawable implements GifFrameLoader.FrameCallback {
-    private final Paint paint;
-    private final Rect destRect = new Rect();
-    private final GifState state;
-    private final GifDecoder decoder;
-    private final GifFrameLoader frameLoader;
-
-    /** True if the drawable is currently animating. */
-    private boolean isRunning;
-    /** True if the drawable should animate while visible. */
-    private boolean isStarted;
-    /** True if the drawable's resources have been recycled. */
-    private boolean isRecycled;
-    /**
-     * True if the drawable is currently visible. Default to true because on certain platforms (at least 4.1.1),
-     * setVisible is not called on {@link android.graphics.drawable.Drawable Drawables} during
-     * {@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}. See issue #130.
-     */
-    private boolean isVisible = true;
-    /** The number of times we've looped over all the frames in the gif. */
-    private int loopCount;
-    /** The number of times to loop through the gif animation. */
-    private int maxLoopCount = LOOP_FOREVER;
-
-    private boolean applyGravity;
-
-    /**
-     * Constructor for GifDrawable.
-     *
-     * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
-     *
-     * @param context A context.
-     * @param bitmapProvider An {@link com.bumptech.glide.gifdecoder.GifDecoder.BitmapProvider} that can be used to
-     *                       retrieve re-usable {@link android.graphics.Bitmap}s.
-     * @param bitmapPool A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can be used to return
-     *                   the first frame when this drawable is recycled.
-     * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be applied to each frame.
-     * @param targetFrameWidth The desired width of the frames displayed by this drawable (the width of the view or
-     *                         {@link com.bumptech.glide.request.target.Target} this drawable is being loaded into).
-     * @param targetFrameHeight The desired height of the frames displayed by this drawable (the height of the view or
-     *                          {@link com.bumptech.glide.request.target.Target} this drawable is being loaded into).
-     * @param gifHeader The header data for this gif.
-     * @param data The full bytes of the gif.
-     * @param firstFrame The decoded and transformed first frame of this gif.
-     */
-    public GifDrawable(Context context, GifDecoder.BitmapProvider bitmapProvider, BitmapPool bitmapPool,
-            Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
-            GifHeader gifHeader, byte[] data, Bitmap firstFrame) {
-        this(new GifState(gifHeader, data, context, frameTransformation, targetFrameWidth, targetFrameHeight,
-                bitmapProvider, bitmapPool, firstFrame));
-    }
-
-    GifDrawable(GifState state) {
-        if (state == null) {
-            throw new NullPointerException("GifState must not be null");
-        }
-
-        this.state = state;
-        this.decoder = new GifDecoder(state.bitmapProvider);
-        this.paint = new Paint();
-        decoder.setData(state.gifHeader, state.data);
-        frameLoader = new GifFrameLoader(state.context, this, decoder, state.targetWidth, state.targetHeight);
-    }
-
-    // Visible for testing.
-    GifDrawable(GifDecoder decoder, GifFrameLoader frameLoader, Bitmap firstFrame, BitmapPool bitmapPool, Paint paint) {
-        this.decoder = decoder;
-        this.frameLoader = frameLoader;
-        this.state = new GifState(null);
-        this.paint = paint;
-        state.bitmapPool = bitmapPool;
-        state.firstFrame = firstFrame;
-    }
-
-    public Bitmap getFirstFrame() {
-        return state.firstFrame;
-    }
-
-    public void setFrameTransformation(Transformation<Bitmap> frameTransformation, Bitmap firstFrame) {
-        if (firstFrame == null) {
-            throw new NullPointerException("The first frame of the GIF must not be null");
-        }
-        if (frameTransformation == null) {
-            throw new NullPointerException("The frame transformation must not be null");
-        }
-        state.frameTransformation = frameTransformation;
-        state.firstFrame = firstFrame;
-        frameLoader.setFrameTransformation(frameTransformation);
-    }
-
-    public GifDecoder getDecoder() {
-        return decoder;
-    }
-
-    public Transformation<Bitmap> getFrameTransformation() {
-        return state.frameTransformation;
+public class GifDrawable extends Drawable implements GifFrameLoader.FrameCallback,
+    Animatable {
+  /**
+   * A constant indicating that an animated drawable should loop continuously.
+   */
+  public static final int LOOP_FOREVER = -1;
+  /**
+   * A constant indicating that an animated drawable should loop for its default number of times.
+   * For animated GIFs, this constant indicates the GIF should use the netscape loop count if
+   * present.
+   */
+  public static final int LOOP_INTRINSIC = 0;
+
+  private final GifState state;
+  /**
+   * True if the drawable is currently animating.
+   */
+  private boolean isRunning;
+  /**
+   * True if the drawable should animate while visible.
+   */
+  private boolean isStarted;
+  /**
+   * True if the drawable's resources have been recycled.
+   */
+  private boolean isRecycled;
+  /**
+   * True if the drawable is currently visible. Default to true because on certain platforms (at
+   * least 4.1.1), setVisible is not called on {@link android.graphics.drawable.Drawable Drawables}
+   * during {@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
+   * See issue #130.
+   */
+  private boolean isVisible = true;
+  /**
+   * The number of times we've looped over all the frames in the gif.
+   */
+  private int loopCount;
+  /**
+   * The number of times to loop through the gif animation.
+   */
+  private int maxLoopCount = LOOP_FOREVER;
+
+  private boolean applyGravity;
+  private Paint paint;
+  private Rect destRect;
+
+  /**
+   * Constructor for GifDrawable.
+   *
+   * @param context             A context.
+   * @param bitmapPool          A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}
+   *                            that can be used to return the first frame when this drawable is
+   *                            recycled.
+   * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
+   *                            applied to each frame.
+   * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
+   *                            width of the view or
+   *                            {@link com.bumptech.glide.request.target.Target}
+   *                            this drawable is being loaded into).
+   * @param targetFrameHeight   The desired height of the frames displayed by this drawable (the
+   *                            height of the view or
+   *                            {@link com.bumptech.glide.request.target.Target}
+   *                            this drawable is being loaded into).
+   * @param gifDecoder          The decoder to use to decode gif data.
+   * @param firstFrame          The decoded and transformed first frame of this gif.
+   * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
+   */
+  public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
+      Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
+      Bitmap firstFrame) {
+    this(new GifState(context, bitmapPool,
+        new GifFrameLoader(context, gifDecoder, targetFrameWidth, targetFrameHeight,
+            frameTransformation, firstFrame)));
+  }
+
+  GifDrawable(GifState state) {
+    this.state = Preconditions.checkNotNull(state);
+  }
+
+  // Visible for testing.
+  GifDrawable(Context context, GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
+    this(new GifState(context, bitmapPool, frameLoader));
+    this.paint = paint;
+  }
+
+  public int getSize() {
+    return state.frameLoader.getSize();
+  }
+
+  public Bitmap getFirstFrame() {
+    return state.frameLoader.getFirstFrame();
+  }
+
+  public void setFrameTransformation(Transformation<Bitmap> frameTransformation,
+      Bitmap firstFrame) {
+    state.frameLoader.setFrameTransformation(frameTransformation, firstFrame);
+  }
+
+  public Transformation<Bitmap> getFrameTransformation() {
+    return state.frameLoader.getFrameTransformation();
+  }
+
+  public ByteBuffer getBuffer() {
+    return state.frameLoader.getBuffer();
+  }
+
+  public int getFrameCount() {
+    return state.frameLoader.getFrameCount();
+  }
+
+  /**
+   * Returns the current frame index in the range 0..{@link #getFrameCount()} - 1, or -1 if no frame
+   * is displayed.
+   */
+  public int getFrameIndex() {
+    return state.frameLoader.getCurrentIndex();
+  }
+
+  private void resetLoopCount() {
+    loopCount = 0;
+  }
+
+  @Override
+  public void start() {
+    isStarted = true;
+    resetLoopCount();
+    if (isVisible) {
+      startRunning();
+    }
+  }
+
+  @Override
+  public void stop() {
+    isStarted = false;
+    stopRunning();
+  }
+
+  private void startRunning() {
+    // If we have only a single frame, we don't want to decode it endlessly.
+    if (state.frameLoader.getFrameCount() == 1) {
+      invalidateSelf();
+    } else if (!isRunning) {
+      isRunning = true;
+      state.frameLoader.subscribe(this);
+      invalidateSelf();
+    }
+  }
+
+  private void stopRunning() {
+    isRunning = false;
+    state.frameLoader.unsubscribe(this);
+  }
+
+  @Override
+  public boolean setVisible(boolean visible, boolean restart) {
+    isVisible = visible;
+    if (!visible) {
+      stopRunning();
+    } else if (isStarted) {
+      startRunning();
+    }
+    return super.setVisible(visible, restart);
+  }
+
+  @Override
+  public int getIntrinsicWidth() {
+    return state.frameLoader.getWidth();
+  }
+
+  @Override
+  public int getIntrinsicHeight() {
+    return state.frameLoader.getHeight();
+  }
+
+  @Override
+  public boolean isRunning() {
+    return isRunning;
+  }
+
+  // For testing.
+  void setIsRunning(boolean isRunning) {
+    this.isRunning = isRunning;
+  }
+
+  @Override
+  protected void onBoundsChange(Rect bounds) {
+    super.onBoundsChange(bounds);
+    applyGravity = true;
+  }
+
+  @Override
+  public void draw(Canvas canvas) {
+    if (isRecycled) {
+      return;
+    }
+
+    if (applyGravity) {
+      Gravity.apply(GifState.GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(),
+          getDestRect());
+      applyGravity = false;
+    }
+
+    Bitmap currentFrame = state.frameLoader.getCurrentFrame();
+    canvas.drawBitmap(currentFrame, null, getDestRect(), getPaint());
+  }
+
+  @Override
+  public void setAlpha(int i) {
+    getPaint().setAlpha(i);
+  }
+
+  @Override
+  public void setColorFilter(ColorFilter colorFilter) {
+    getPaint().setColorFilter(colorFilter);
+  }
+
+  private Rect getDestRect() {
+    if (destRect == null) {
+      destRect = new Rect();
+    }
+    return destRect;
+  }
+
+  private Paint getPaint() {
+    if (paint == null) {
+      paint = new Paint(Paint.FILTER_BITMAP_FLAG);
+    }
+    return paint;
+  }
+
+  @Override
+  public int getOpacity() {
+    // We can't tell, so default to transparent to be safe.
+    return PixelFormat.TRANSPARENT;
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @Override
+  public void onFrameReady() {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && getCallback() == null) {
+      stop();
+      invalidateSelf();
+      return;
     }
 
-    public byte[] getData() {
-        return state.data;
-    }
+    invalidateSelf();
 
-    public int getFrameCount() {
-        return decoder.getFrameCount();
+    if (getFrameIndex() == getFrameCount() - 1) {
+      loopCount++;
     }
 
-    private void resetLoopCount() {
-        loopCount = 0;
+    if (maxLoopCount != LOOP_FOREVER && loopCount >= maxLoopCount) {
+      stop();
     }
+  }
 
-    @Override
-    public void start() {
-        isStarted = true;
-        resetLoopCount();
-        if (isVisible) {
-            startRunning();
-        }
-    }
+  @Override
+  public ConstantState getConstantState() {
+    return state;
+  }
 
-    @Override
-    public void stop() {
-        isStarted = false;
-        stopRunning();
-
-        // On APIs > honeycomb we know our drawable is not being displayed anymore when it's callback is cleared and so
-        // we can use the absence of a callback as an indication that it's ok to clear our temporary data. Prior to
-        // honeycomb we can't tell if our callback is null and instead eagerly reset to avoid holding on to resources we
-        // no longer need.
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
-            reset();
-        }
-    }
-
-    /**
-     * Clears temporary data and resets the drawable back to the first frame.
-     */
-    private void reset() {
-        frameLoader.clear();
-        invalidateSelf();
-    }
+  /**
+   * Clears any resources for loading frames that are currently held on to by this object.
+   */
+  public void recycle() {
+    isRecycled = true;
+    state.frameLoader.clear();
+  }
 
-    private void startRunning() {
-        // If we have only a single frame, we don't want to decode it endlessly.
-        if (decoder.getFrameCount() == 1) {
-            invalidateSelf();
-        }  else if (!isRunning) {
-            isRunning = true;
-            frameLoader.start();
-            invalidateSelf();
-        }
-    }
+  // For testing.
+  boolean isRecycled() {
+    return isRecycled;
+  }
 
-    private void stopRunning() {
-        isRunning = false;
-        frameLoader.stop();
+  public void setLoopCount(int loopCount) {
+    if (loopCount <= 0 && loopCount != LOOP_FOREVER && loopCount != LOOP_INTRINSIC) {
+      throw new IllegalArgumentException("Loop count must be greater than 0, or equal to "
+          + "GlideDrawable.LOOP_FOREVER, or equal to GlideDrawable.LOOP_INTRINSIC");
     }
 
-    @Override
-    public boolean setVisible(boolean visible, boolean restart) {
-        isVisible = visible;
-        if (!visible) {
-            stopRunning();
-        } else if (isStarted) {
-            startRunning();
-        }
-        return super.setVisible(visible, restart);
+    if (loopCount == LOOP_INTRINSIC) {
+      maxLoopCount = state.frameLoader.getLoopCount();
+    } else {
+      maxLoopCount = loopCount;
     }
+  }
 
-    @Override
-    public int getIntrinsicWidth() {
-        return state.firstFrame.getWidth();
-    }
+  static class GifState extends ConstantState {
+    static final int GRAVITY = Gravity.FILL;
+    final Context context;
+    final BitmapPool bitmapPool;
+    final GifFrameLoader frameLoader;
 
-    @Override
-    public int getIntrinsicHeight() {
-        return state.firstFrame.getHeight();
+    public GifState(Context context, BitmapPool bitmapPool, GifFrameLoader frameLoader) {
+      this.bitmapPool = bitmapPool;
+      this.context = context.getApplicationContext();
+      this.frameLoader = frameLoader;
     }
 
     @Override
-    public boolean isRunning() {
-        return isRunning;
-    }
-
-    // For testing.
-    void setIsRunning(boolean isRunning) {
-        this.isRunning = isRunning;
+    public Drawable newDrawable(Resources res) {
+      return newDrawable();
     }
 
     @Override
-    protected void onBoundsChange(Rect bounds) {
-        super.onBoundsChange(bounds);
-        applyGravity = true;
+    public Drawable newDrawable() {
+      return new GifDrawable(this);
     }
 
     @Override
-    public void draw(Canvas canvas) {
-        if (isRecycled) {
-            return;
-        }
-
-        if (applyGravity) {
-            Gravity.apply(GifState.GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(), destRect);
-            applyGravity = false;
-        }
-
-        Bitmap currentFrame = frameLoader.getCurrentFrame();
-        Bitmap toDraw = currentFrame != null ? currentFrame : state.firstFrame;
-        canvas.drawBitmap(toDraw, null, destRect, paint);
-    }
-
-    @Override
-    public void setAlpha(int i) {
-        paint.setAlpha(i);
-    }
-
-    @Override
-    public void setColorFilter(ColorFilter colorFilter) {
-        paint.setColorFilter(colorFilter);
-    }
-
-    @Override
-    public int getOpacity() {
-        // We can't tell, so default to transparent to be safe.
-        return PixelFormat.TRANSPARENT;
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    @Override
-    public void onFrameReady(int frameIndex) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && getCallback() == null) {
-            stop();
-            reset();
-            return;
-        }
-
-        invalidateSelf();
-
-        if (frameIndex == decoder.getFrameCount() - 1) {
-            loopCount++;
-        }
-
-        if (maxLoopCount != LOOP_FOREVER && loopCount >= maxLoopCount) {
-            stop();
-        }
-    }
-
-    @Override
-    public ConstantState getConstantState() {
-        return state;
-    }
-
-    /**
-     * Clears any resources for loading frames that are currently held on to by this object.
-     */
-    public void recycle() {
-        isRecycled = true;
-        state.bitmapPool.put(state.firstFrame);
-        frameLoader.clear();
-        frameLoader.stop();
-    }
-
-    // For testing.
-    boolean isRecycled() {
-        return isRecycled;
-    }
-
-    @Override
-    public boolean isAnimated() {
-        return true;
-    }
-
-    @Override
-    public void setLoopCount(int loopCount) {
-        if (loopCount <= 0 && loopCount != LOOP_FOREVER && loopCount != LOOP_INTRINSIC) {
-            throw new IllegalArgumentException("Loop count must be greater than 0, or equal to "
-                    + "GlideDrawable.LOOP_FOREVER, or equal to GlideDrawable.LOOP_INTRINSIC");
-        }
-
-        if (loopCount == LOOP_INTRINSIC) {
-            maxLoopCount = decoder.getLoopCount();
-        } else {
-            maxLoopCount = loopCount;
-        }
-    }
-
-    static class GifState extends ConstantState {
-        private static final int GRAVITY = Gravity.FILL;
-        GifHeader gifHeader;
-        byte[] data;
-        Context context;
-        Transformation<Bitmap> frameTransformation;
-        int targetWidth;
-        int targetHeight;
-        GifDecoder.BitmapProvider bitmapProvider;
-        BitmapPool bitmapPool;
-        Bitmap firstFrame;
-
-        public GifState(GifHeader header, byte[] data, Context context,
-                Transformation<Bitmap> frameTransformation, int targetWidth, int targetHeight,
-                GifDecoder.BitmapProvider provider, BitmapPool bitmapPool, Bitmap firstFrame) {
-            if (firstFrame == null) {
-                throw new NullPointerException("The first frame of the GIF must not be null");
-            }
-            gifHeader = header;
-            this.data = data;
-            this.bitmapPool = bitmapPool;
-            this.firstFrame = firstFrame;
-            this.context = context.getApplicationContext();
-            this.frameTransformation = frameTransformation;
-            this.targetWidth = targetWidth;
-            this.targetHeight = targetHeight;
-            bitmapProvider = provider;
-        }
-
-        public GifState(GifState original) {
-            if (original != null) {
-                gifHeader = original.gifHeader;
-                data = original.data;
-                context = original.context;
-                frameTransformation = original.frameTransformation;
-                targetWidth = original.targetWidth;
-                targetHeight = original.targetHeight;
-                bitmapProvider = original.bitmapProvider;
-                bitmapPool = original.bitmapPool;
-                firstFrame = original.firstFrame;
-            }
-        }
-
-        @Override
-        public Drawable newDrawable(Resources res) {
-            return newDrawable();
-        }
-
-        @Override
-        public Drawable newDrawable() {
-            return new GifDrawable(this);
-        }
-
-        @Override
-        public int getChangingConfigurations() {
-            return 0;
-        }
+    public int getChangingConfigurations() {
+      return 0;
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
new file mode 100644
index 000000000..44268ec8e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.load.resource.gif;
+
+import android.util.Log;
+
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.ByteBufferUtil;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Writes the original bytes of a {@link com.bumptech.glide.load.resource.gif.GifDrawable} to an
+ * {@link java.io.OutputStream}.
+ */
+public class GifDrawableEncoder implements ResourceEncoder<GifDrawable> {
+  private static final String TAG = "GifEncoder";
+
+  @Override
+  public EncodeStrategy getEncodeStrategy(Options options) {
+    return EncodeStrategy.SOURCE;
+  }
+
+  @Override
+  public boolean encode(Resource<GifDrawable> data, File file, Options options) {
+    GifDrawable drawable = data.get();
+    boolean success = false;
+    try {
+      ByteBufferUtil.toFile(drawable.getBuffer(), file);
+      success = true;
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to encode gif drawable data", e);
+      }
+    }
+    return success;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java
deleted file mode 100644
index 971847d3b..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import android.content.Context;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.model.StreamEncoder;
-import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
-import com.bumptech.glide.provider.DataLoadProvider;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * An {@link com.bumptech.glide.provider.DataLoadProvider} that loads an {@link java.io.InputStream} into
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} that can be used to display an animated GIF.
- */
-public class GifDrawableLoadProvider implements DataLoadProvider<InputStream, GifDrawable> {
-    private final GifResourceDecoder decoder;
-    private final GifResourceEncoder encoder;
-    private final StreamEncoder sourceEncoder;
-    private final FileToStreamDecoder<GifDrawable> cacheDecoder;
-
-    public GifDrawableLoadProvider(Context context, BitmapPool bitmapPool) {
-        decoder = new GifResourceDecoder(context, bitmapPool);
-        cacheDecoder = new FileToStreamDecoder<GifDrawable>(decoder);
-        encoder = new GifResourceEncoder(bitmapPool);
-        sourceEncoder = new StreamEncoder();
-    }
-
-    @Override
-    public ResourceDecoder<File, GifDrawable> getCacheDecoder() {
-        return cacheDecoder;
-    }
-
-    @Override
-    public ResourceDecoder<InputStream, GifDrawable> getSourceDecoder() {
-        return decoder;
-    }
-
-    @Override
-    public Encoder<InputStream> getSourceEncoder() {
-        return sourceEncoder;
-    }
-
-    @Override
-    public ResourceEncoder<GifDrawable> getEncoder() {
-        return encoder;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index 7d2b67f26..6b8301462 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,24 +1,28 @@
 package com.bumptech.glide.load.resource.gif;
 
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
-import com.bumptech.glide.util.Util;
 
 /**
  * A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableResource extends DrawableResource<GifDrawable> {
-    public GifDrawableResource(GifDrawable drawable) {
-        super(drawable);
-    }
+  public GifDrawableResource(GifDrawable drawable) {
+    super(drawable);
+  }
 
-    @Override
-    public int getSize() {
-        return drawable.getData().length + Util.getBitmapByteSize(drawable.getFirstFrame());
-    }
+  @Override
+  public Class<GifDrawable> getResourceClass() {
+    return GifDrawable.class;
+  }
 
-    @Override
-    public void recycle() {
-        drawable.stop();
-        drawable.recycle();
-    }
+  @Override
+  public int getSize() {
+   return drawable.getSize();
+  }
+
+  @Override
+  public void recycle() {
+    drawable.stop();
+    drawable.recycle();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 2e17d2902..1d78c736e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -1,47 +1,73 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.util.Preconditions;
+
+import java.security.MessageDigest;
 
 /**
- * An {@link com.bumptech.glide.load.Transformation} that wraps a transformation for a {@link Bitmap}
- * and can apply it to every frame of any {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+ * An {@link com.bumptech.glide.load.Transformation} that wraps a transformation for a
+ * {@link Bitmap} and can apply it to every frame of any
+ * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableTransformation implements Transformation<GifDrawable> {
-    private final Transformation<Bitmap> wrapped;
-    private final BitmapPool bitmapPool;
+  private final Transformation<Bitmap> wrapped;
+  private final BitmapPool bitmapPool;
 
-    public GifDrawableTransformation(Transformation<Bitmap> wrapped, BitmapPool bitmapPool) {
-        this.wrapped = wrapped;
-        this.bitmapPool = bitmapPool;
-    }
+  public GifDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped, Glide.get(context).getBitmapPool());
+  }
+
+  public GifDrawableTransformation(Transformation<Bitmap> wrapped, BitmapPool bitmapPool) {
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+  }
+
+  @Override
+  public Resource<GifDrawable> transform(Resource<GifDrawable> resource, int outWidth,
+      int outHeight) {
+    GifDrawable drawable = resource.get();
 
-    @Override
-    public Resource<GifDrawable> transform(Resource<GifDrawable> resource, int outWidth, int outHeight) {
-        GifDrawable drawable = resource.get();
-
-        // The drawable needs to be initialized with the correct width and height in order for a view displaying it
-        // to end up with the right dimensions. Since our transformations may arbitrarily modify the dimensions of
-        // our gif, here we create a stand in for a frame and pass it to the transformation to see what the final
-        // transformed dimensions will be so that our drawable can report the correct intrinsic width and height.
-        Bitmap firstFrame = resource.get().getFirstFrame();
-        Resource<Bitmap> bitmapResource = new BitmapResource(firstFrame, bitmapPool);
-        Resource<Bitmap> transformed = wrapped.transform(bitmapResource, outWidth, outHeight);
-        if (!bitmapResource.equals(transformed)) {
-            bitmapResource.recycle();
-        }
-        Bitmap transformedFrame = transformed.get();
-
-        drawable.setFrameTransformation(wrapped, transformedFrame);
-        return resource;
+    // The drawable needs to be initialized with the correct width and height in order for a view
+    // displaying it to end up with the right dimensions. Since our transformations may arbitrarily
+    // modify the dimensions of our gif, here we create a stand in for a frame and pass it to the
+    // transformation to see what the final transformed dimensions will be so that our drawable can
+    // report the correct intrinsic width and height.
+    Bitmap firstFrame = drawable.getFirstFrame();
+    Resource<Bitmap> bitmapResource = new BitmapResource(firstFrame, bitmapPool);
+    Resource<Bitmap> transformed = wrapped.transform(bitmapResource, outWidth, outHeight);
+    if (!bitmapResource.equals(transformed)) {
+      bitmapResource.recycle();
     }
+    Bitmap transformedFrame = transformed.get();
 
-    @Override
-    public String getId() {
-        return wrapped.getId();
+    drawable.setFrameTransformation(wrapped, transformedFrame);
+    return resource;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof GifDrawableTransformation) {
+      GifDrawableTransformation other = (GifDrawableTransformation) o;
+      return wrapped.equals(other.wrapped);
     }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return wrapped.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    wrapped.updateDiskCacheKey(messageDigest);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 5b8ae83de..5431bca24 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
+import static com.bumptech.glide.request.RequestOptions.signatureOf;
+
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Handler;
@@ -7,213 +10,298 @@
 import android.os.Message;
 import android.os.SystemClock;
 
-import com.bumptech.glide.GenericRequestBuilder;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.NullEncoder;
-import com.bumptech.glide.request.animation.GlideAnimation;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.SimpleTarget;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
 
-import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
 import java.security.MessageDigest;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.UUID;
 
 class GifFrameLoader {
+  private final GifDecoder gifDecoder;
+  private final Handler handler;
+  private final Context context;
+  private final List<FrameCallback> callbacks = new ArrayList<>();
+  private final RequestManager requestManager;
+
+  private boolean isRunning = false;
+  private boolean isLoadPending = false;
+  private RequestBuilder<Bitmap> requestBuilder;
+  private DelayTarget current;
+  private boolean isCleared;
+  private DelayTarget next;
+  private Bitmap firstFrame;
+  private Transformation<Bitmap> transformation;
+
+  public interface FrameCallback {
+    void onFrameReady();
+  }
+
+  public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int height,
+      Transformation<Bitmap> transformation, Bitmap firstFrame) {
+    this(context,
+        Glide.with(context),
+        gifDecoder,
+        null /*handler*/,
+        getRequestBuilder(context, width, height), transformation, firstFrame);
+  }
+
+  GifFrameLoader(Context context, RequestManager requestManager, GifDecoder gifDecoder,
+      Handler handler, RequestBuilder<Bitmap> requestBuilder, Transformation<Bitmap> transformation,
+      Bitmap firstFrame) {
+    this.requestManager = requestManager;
+    if (handler == null) {
+      handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
+    }
+    this.context = context;
+    this.handler = handler;
+    this.requestBuilder = requestBuilder;
+
+    this.gifDecoder = gifDecoder;
+
+    setFrameTransformation(transformation, firstFrame);
+  }
+
+  void setFrameTransformation(Transformation<Bitmap> transformation, Bitmap firstFrame) {
+    this.transformation = Preconditions.checkNotNull(transformation);
+    this.firstFrame = Preconditions.checkNotNull(firstFrame);
+    requestBuilder = requestBuilder.apply(new RequestOptions().transform(context, transformation));
+  }
+
+  Transformation<Bitmap> getFrameTransformation() {
+    return transformation;
+  }
+
+  Bitmap getFirstFrame() {
+    return firstFrame;
+  }
+
+  void subscribe(FrameCallback frameCallback) {
+    if (isCleared) {
+      throw new IllegalStateException("Cannot subscribe to a cleared frame loader");
+    }
+    boolean start = callbacks.isEmpty();
+    if (callbacks.contains(frameCallback)) {
+      throw new IllegalStateException("Cannot subscribe twice in a row");
+    }
+    callbacks.add(frameCallback);
+    if (start) {
+      start();
+    }
+  }
+
+  void unsubscribe(FrameCallback frameCallback) {
+    callbacks.remove(frameCallback);
+    if (callbacks.isEmpty()) {
+      stop();
+    }
+  }
+
+  int getWidth() {
+    return getCurrentFrame().getWidth();
+  }
+
+  int getHeight() {
+    return getCurrentFrame().getHeight();
+  }
+
+  int getSize() {
+    return gifDecoder.getByteSize() + getFrameSize();
+  }
+
+  int getCurrentIndex() {
+    return current != null ? current.index : -1;
+  }
+
+  private int getFrameSize() {
+    return Util.getBitmapByteSize(getCurrentFrame().getWidth(), getCurrentFrame().getHeight(),
+        getCurrentFrame().getConfig());
+  }
+
+  ByteBuffer getBuffer() {
+    return gifDecoder.getData().asReadOnlyBuffer();
+  }
+
+  int getFrameCount() {
+    return gifDecoder.getFrameCount();
+  }
 
-    private final FrameCallback callback;
-    private final GifDecoder gifDecoder;
+  int getLoopCount() {
+    return gifDecoder.getLoopCount();
+  }
+
+  private void start() {
+    if (isRunning) {
+      return;
+    }
+    isRunning = true;
+    isCleared = false;
+
+    loadNextFrame();
+  }
+
+  private void stop() {
+    isRunning = false;
+  }
+
+  void clear() {
+    callbacks.clear();
+    recycleFirstFrame();
+    stop();
+    if (current != null) {
+      requestManager.clear(current);
+      current = null;
+    }
+    if (next != null) {
+      requestManager.clear(next);
+      next = null;
+    }
+    gifDecoder.clear();
+    isCleared = true;
+  }
+
+  Bitmap getCurrentFrame() {
+    return current != null ? current.getResource() : firstFrame;
+  }
+
+  private void loadNextFrame() {
+    if (!isRunning || isLoadPending) {
+      return;
+    }
+    isLoadPending = true;
+    // Get the delay before incrementing the pointer because the delay indicates the amount of time
+    // we want to spend on the current frame.
+    int delay = gifDecoder.getNextDelay();
+    long targetTime = SystemClock.uptimeMillis() + delay;
+
+    gifDecoder.advance();
+    next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
+    requestBuilder.clone().apply(signatureOf(new FrameSignature())).load(gifDecoder).into(next);
+  }
+
+  private void recycleFirstFrame() {
+    if (firstFrame != null) {
+      Glide.get(context).getBitmapPool().put(firstFrame);
+      firstFrame = null;
+    }
+  }
+
+  // Visible for testing.
+  void onFrameReady(DelayTarget delayTarget) {
+    if (isCleared) {
+      handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, delayTarget).sendToTarget();
+      return;
+    }
+
+    if (delayTarget.getResource() != null) {
+      recycleFirstFrame();
+      DelayTarget previous = current;
+      current = delayTarget;
+      // The callbacks may unregister when onFrameReady is called, so iterate in reverse to avoid
+      // concurrent modifications.
+      for (int i = callbacks.size() - 1; i >= 0; i--) {
+        FrameCallback cb = callbacks.get(i);
+        cb.onFrameReady();
+      }
+      if (previous != null) {
+        handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, previous).sendToTarget();
+      }
+    }
+
+    isLoadPending = false;
+    loadNextFrame();
+  }
+
+  private class FrameLoaderCallback implements Handler.Callback {
+    public static final int MSG_DELAY = 1;
+    public static final int MSG_CLEAR = 2;
+
+    @Override
+    public boolean handleMessage(Message msg) {
+      if (msg.what == MSG_DELAY) {
+        GifFrameLoader.DelayTarget target = (DelayTarget) msg.obj;
+        onFrameReady(target);
+        return true;
+      } else if (msg.what == MSG_CLEAR) {
+        GifFrameLoader.DelayTarget target = (DelayTarget) msg.obj;
+        requestManager.clear(target);
+      }
+      return false;
+    }
+  }
+
+  // Visible for testing.
+  static class DelayTarget extends SimpleTarget<Bitmap> {
     private final Handler handler;
+    private final int index;
+    private final long targetTime;
+    private Bitmap resource;
+
+    DelayTarget(Handler handler, int index, long targetTime) {
+      this.handler = handler;
+      this.index = index;
+      this.targetTime = targetTime;
+    }
 
-    private boolean isRunning = false;
-    private boolean isLoadPending = false;
-    private GenericRequestBuilder<GifDecoder, GifDecoder, Bitmap, Bitmap> requestBuilder;
-    private DelayTarget current;
-    private boolean isCleared;
+    Bitmap getResource() {
+      return resource;
+    }
 
-    public interface FrameCallback {
-        void onFrameReady(int index);
+    @Override
+    public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+      this.resource = resource;
+      Message msg = handler.obtainMessage(FrameLoaderCallback.MSG_DELAY, this);
+      handler.sendMessageAtTime(msg, targetTime);
     }
+  }
+
+  private static RequestBuilder<Bitmap> getRequestBuilder(Context context, int width, int height) {
+    return Glide.with(context).asBitmap().apply(
+        diskCacheStrategyOf(DiskCacheStrategy.NONE).skipMemoryCache(true).override(width, height));
+  }
 
-    public GifFrameLoader(Context context, FrameCallback callback, GifDecoder gifDecoder, int width, int height) {
-        this(callback, gifDecoder, null,
-                getRequestBuilder(context, gifDecoder, width, height, Glide.get(context).getBitmapPool()));
+  // Visible for testing.
+  static class FrameSignature implements Key {
+    private final UUID uuid;
+
+    public FrameSignature() {
+      this(UUID.randomUUID());
     }
 
-    GifFrameLoader(FrameCallback callback, GifDecoder gifDecoder, Handler handler,
-            GenericRequestBuilder<GifDecoder, GifDecoder, Bitmap, Bitmap>  requestBuilder) {
-        if (handler == null) {
-            handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
-        }
-        this.callback = callback;
-        this.gifDecoder = gifDecoder;
-        this.handler = handler;
-        this.requestBuilder = requestBuilder;
+    // VisibleForTesting.
+    FrameSignature(UUID uuid) {
+      this.uuid = uuid;
     }
 
-    @SuppressWarnings("unchecked")
-    public void setFrameTransformation(Transformation<Bitmap> transformation) {
-        if (transformation == null) {
-            throw new NullPointerException("Transformation must not be null");
-        }
-        requestBuilder = requestBuilder.transform(transformation);
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof FrameSignature) {
+        FrameSignature other = (FrameSignature) o;
+        return other.uuid.equals(uuid);
+      }
+      return false;
     }
 
-    public void start() {
-        if (isRunning) {
-            return;
-        }
-        isRunning = true;
-        isCleared = false;
+    @Override
+    public int hashCode() {
+      return uuid.hashCode();
+    }
 
-        loadNextFrame();
-    }
-
-    public void stop() {
-        isRunning = false;
-    }
-
-    public void clear() {
-        stop();
-        if (current != null) {
-            Glide.clear(current);
-            current = null;
-        }
-        isCleared = true;
-        // test.
-    }
-
-    public Bitmap getCurrentFrame() {
-        return current != null ? current.getResource() : null;
-    }
-
-    private void loadNextFrame() {
-        if (!isRunning || isLoadPending) {
-            return;
-        }
-        isLoadPending = true;
-
-        gifDecoder.advance();
-        long targetTime = SystemClock.uptimeMillis() + gifDecoder.getNextDelay();
-        DelayTarget next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
-        requestBuilder
-                .signature(new FrameSignature())
-                .into(next);
-    }
-
-    // Visible for testing.
-    void onFrameReady(DelayTarget delayTarget) {
-        if (isCleared) {
-            handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, delayTarget).sendToTarget();
-            return;
-        }
-
-        DelayTarget previous = current;
-        current = delayTarget;
-        callback.onFrameReady(delayTarget.index);
-
-        if (previous != null) {
-            handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, previous).sendToTarget();
-        }
-
-        isLoadPending = false;
-        loadNextFrame();
-    }
-
-    private class FrameLoaderCallback implements Handler.Callback {
-        public static final int MSG_DELAY = 1;
-        public static final int MSG_CLEAR = 2;
-
-        @Override
-        public boolean handleMessage(Message msg) {
-            if (msg.what == MSG_DELAY) {
-                GifFrameLoader.DelayTarget target = (DelayTarget) msg.obj;
-                onFrameReady(target);
-                return true;
-            } else if (msg.what == MSG_CLEAR) {
-                GifFrameLoader.DelayTarget target = (DelayTarget) msg.obj;
-                Glide.clear(target);
-            }
-            return false;
-        }
-    }
-
-    // Visible for testing.
-    static class DelayTarget extends SimpleTarget<Bitmap> {
-        private final Handler handler;
-        private final int index;
-        private final long targetTime;
-        private Bitmap resource;
-
-        public DelayTarget(Handler handler, int index, long targetTime) {
-            this.handler = handler;
-            this.index = index;
-            this.targetTime = targetTime;
-        }
-
-        public Bitmap getResource() {
-            return resource;
-        }
-
-        @Override
-        public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {
-            this.resource = resource;
-            Message msg = handler.obtainMessage(FrameLoaderCallback.MSG_DELAY, this);
-            handler.sendMessageAtTime(msg, targetTime);
-        }
-    }
-
-    private static GenericRequestBuilder<GifDecoder, GifDecoder, Bitmap, Bitmap> getRequestBuilder(Context context,
-            GifDecoder gifDecoder, int width, int height, BitmapPool bitmapPool) {
-        GifFrameResourceDecoder frameResourceDecoder = new GifFrameResourceDecoder(bitmapPool);
-        GifFrameModelLoader frameLoader = new GifFrameModelLoader();
-        Encoder<GifDecoder> sourceEncoder = NullEncoder.get();
-        return Glide.with(context)
-                .using(frameLoader, GifDecoder.class)
-                .load(gifDecoder)
-                .as(Bitmap.class)
-                .sourceEncoder(sourceEncoder)
-                .decoder(frameResourceDecoder)
-                .skipMemoryCache(true)
-                .diskCacheStrategy(DiskCacheStrategy.NONE)
-                .override(width, height);
-
-    }
-
-    // Visible for testing.
-    static class FrameSignature implements Key {
-        private final UUID uuid;
-
-        public FrameSignature() {
-            this(UUID.randomUUID());
-        }
-
-        // VisibleForTesting.
-        FrameSignature(UUID uuid) {
-            this.uuid = uuid;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof FrameSignature) {
-                FrameSignature other = (FrameSignature) o;
-                return other.uuid.equals(uuid);
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            return uuid.hashCode();
-        }
-
-        @Override
-        public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-            throw new UnsupportedOperationException("Not implemented");
-        }
+    @Override
+    public void updateDiskCacheKey(MessageDigest messageDigest) {
+      throw new UnsupportedOperationException("Not implemented");
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoader.java
deleted file mode 100644
index 4db390f91..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoader.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.model.ModelLoader;
-
-class GifFrameModelLoader implements ModelLoader<GifDecoder, GifDecoder> {
-
-    @Override
-    public DataFetcher<GifDecoder> getResourceFetcher(GifDecoder model, int width, int height) {
-        return new GifFrameDataFetcher(model);
-    }
-
-    private static class GifFrameDataFetcher implements DataFetcher<GifDecoder> {
-        private final GifDecoder decoder;
-
-        public GifFrameDataFetcher(GifDecoder decoder) {
-            this.decoder = decoder;
-        }
-
-        @Override
-        public GifDecoder loadData(Priority priority) {
-            return decoder;
-        }
-
-        @Override
-        public void cleanup() {
-            // Do nothing. GifDecoder reads from an arbitrary InputStream, the caller will close that stream.
-        }
-
-        @Override
-        public String getId() {
-            return String.valueOf(decoder.getCurrentFrameIndex());
-        }
-
-        @Override
-        public void cancel() {
-            // Do nothing.
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index 1815c99d5..a644056aa 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -3,26 +3,32 @@
 import android.graphics.Bitmap;
 
 import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 
-class GifFrameResourceDecoder implements ResourceDecoder<GifDecoder, Bitmap> {
-    private final BitmapPool bitmapPool;
+/**
+ * Decodes {@link Bitmap}s from {@link GifDecoder}s representing a particular frame of a particular
+ * GIF image.
+ */
+public final class GifFrameResourceDecoder implements ResourceDecoder<GifDecoder, Bitmap> {
+  private final BitmapPool bitmapPool;
 
-    public GifFrameResourceDecoder(BitmapPool bitmapPool) {
-        this.bitmapPool = bitmapPool;
-    }
+  public GifFrameResourceDecoder(BitmapPool bitmapPool) {
+    this.bitmapPool = bitmapPool;
+  }
 
-    @Override
-    public Resource<Bitmap> decode(GifDecoder source, int width, int height) {
-        Bitmap bitmap = source.getNextFrame();
-        return BitmapResource.obtain(bitmap, bitmapPool);
-    }
+  @Override
+  public boolean handles(GifDecoder source, Options options) {
+    return true;
+  }
 
-    @Override
-    public String getId() {
-        return "GifFrameResourceDecoder.com.bumptech.glide.load.resource.gif";
-    }
+  @Override
+  public Resource<Bitmap> decode(GifDecoder source, int width, int height,
+      Options options) {
+    Bitmap bitmap = source.getNextFrame();
+    return BitmapResource.obtain(bitmap, bitmapPool);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java
deleted file mode 100644
index 55a257fd3..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java
+++ /dev/null
@@ -1,151 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.util.Log;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.gifdecoder.GifHeader;
-import com.bumptech.glide.gifdecoder.GifHeaderParser;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.util.Util;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Queue;
-
-/**
- * An {@link com.bumptech.glide.load.ResourceDecoder} that decodes
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} from {@link java.io.InputStream} data.
- */
-public class GifResourceDecoder implements ResourceDecoder<InputStream, GifDrawable> {
-    private static final String TAG = "GifResourceDecoder";
-    private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
-    private static final GifDecoderPool DECODER_POOL = new GifDecoderPool();
-
-    private final Context context;
-    private final GifHeaderParserPool parserPool;
-    private final BitmapPool bitmapPool;
-    private final GifDecoderPool decoderPool;
-    private final GifBitmapProvider provider;
-
-    public GifResourceDecoder(Context context) {
-        this(context, Glide.get(context).getBitmapPool());
-    }
-
-    public GifResourceDecoder(Context context, BitmapPool bitmapPool) {
-        this(context, bitmapPool, PARSER_POOL, DECODER_POOL);
-    }
-
-    // Visible for testing.
-    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParserPool parserPool,
-            GifDecoderPool decoderPool) {
-        this.context = context;
-        this.bitmapPool = bitmapPool;
-        this.decoderPool = decoderPool;
-        this.provider = new GifBitmapProvider(bitmapPool);
-        this.parserPool = parserPool;
-    }
-
-    @Override
-    public GifDrawableResource decode(InputStream source, int width, int height) {
-        byte[] data = inputStreamToBytes(source);
-        final GifHeaderParser parser = parserPool.obtain(data);
-        final GifDecoder decoder = decoderPool.obtain(provider);
-        try {
-            return decode(data, width, height, parser, decoder);
-        } finally {
-            parserPool.release(parser);
-            decoderPool.release(decoder);
-        }
-    }
-
-    private GifDrawableResource decode(byte[] data, int width, int height, GifHeaderParser parser, GifDecoder decoder) {
-        final GifHeader header = parser.parseHeader();
-        if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
-            // If we couldn't decode the GIF, we will end up with a frame count of 0.
-            return null;
-        }
-
-        Bitmap firstFrame = decodeFirstFrame(decoder, header, data);
-        if (firstFrame == null) {
-            return null;
-        }
-
-        Transformation<Bitmap> unitTransformation = UnitTransformation.get();
-
-        GifDrawable gifDrawable = new GifDrawable(context, provider, bitmapPool, unitTransformation, width, height,
-                header, data, firstFrame);
-
-        return new GifDrawableResource(gifDrawable);
-    }
-
-    private Bitmap decodeFirstFrame(GifDecoder decoder, GifHeader header, byte[] data) {
-        decoder.setData(header, data);
-        decoder.advance();
-        return decoder.getNextFrame();
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
-
-    private static byte[] inputStreamToBytes(InputStream is) {
-        final int bufferSize = 16384;
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream(bufferSize);
-        try {
-            int nRead;
-            byte[] data = new byte[bufferSize];
-            while ((nRead = is.read(data)) != -1) {
-                buffer.write(data, 0, nRead);
-            }
-            buffer.flush();
-        } catch (IOException e) {
-            Log.w(TAG, "Error reading data from stream", e);
-        }
-        //TODO the returned byte[] may be partial if an IOException was thrown from read
-        return buffer.toByteArray();
-    }
-
-    // Visible for testing.
-    static class GifDecoderPool {
-        private final Queue<GifDecoder> pool = Util.createQueue(0);
-
-        public synchronized GifDecoder obtain(GifDecoder.BitmapProvider bitmapProvider) {
-            GifDecoder result = pool.poll();
-            if (result == null) {
-                result = new GifDecoder(bitmapProvider);
-            }
-            return result;
-        }
-
-        public synchronized void release(GifDecoder decoder) {
-            decoder.clear();
-            pool.offer(decoder);
-        }
-    }
-
-    // Visible for testing.
-    static class GifHeaderParserPool {
-        private final Queue<GifHeaderParser> pool = Util.createQueue(0);
-
-        public synchronized GifHeaderParser obtain(byte[] data) {
-            GifHeaderParser result = pool.poll();
-            if (result == null) {
-                result = new GifHeaderParser();
-            }
-            return result.setData(data);
-        }
-
-        public synchronized void release(GifHeaderParser parser) {
-            parser.clear();
-            pool.offer(parser);
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java
deleted file mode 100644
index df3b51fb2..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java
+++ /dev/null
@@ -1,148 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import android.graphics.Bitmap;
-import android.util.Log;
-
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.gifdecoder.GifHeader;
-import com.bumptech.glide.gifdecoder.GifHeaderParser;
-import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.load.resource.bitmap.BitmapResource;
-import com.bumptech.glide.util.LogTime;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * An {@link com.bumptech.glide.load.ResourceEncoder} that can write
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} to cache.
- */
-public class GifResourceEncoder implements ResourceEncoder<GifDrawable> {
-    private static final Factory FACTORY = new Factory();
-    private static final String TAG = "GifEncoder";
-    private final GifDecoder.BitmapProvider provider;
-    private final BitmapPool bitmapPool;
-    private final Factory factory;
-
-    public GifResourceEncoder(BitmapPool bitmapPool) {
-        this(bitmapPool, FACTORY);
-    }
-
-    // Visible for testing.
-    GifResourceEncoder(BitmapPool bitmapPool, Factory factory) {
-        this.bitmapPool = bitmapPool;
-        provider = new GifBitmapProvider(bitmapPool);
-        this.factory = factory;
-    }
-
-    @Override
-    public boolean encode(Resource<GifDrawable> resource, OutputStream os) {
-        long startTime = LogTime.getLogTime();
-
-        GifDrawable drawable = resource.get();
-        Transformation<Bitmap> transformation = drawable.getFrameTransformation();
-        if (transformation instanceof UnitTransformation) {
-            return writeDataDirect(drawable.getData(), os);
-        }
-
-        GifDecoder decoder = decodeHeaders(drawable.getData());
-
-        AnimatedGifEncoder encoder = factory.buildEncoder();
-        if (!encoder.start(os)) {
-            return false;
-        }
-
-        for (int i = 0; i < decoder.getFrameCount(); i++) {
-            Bitmap currentFrame = decoder.getNextFrame();
-            Resource<Bitmap> transformedResource = getTransformedFrame(currentFrame, transformation, drawable);
-            try {
-                if (!encoder.addFrame(transformedResource.get())) {
-                    return false;
-                }
-                int currentFrameIndex = decoder.getCurrentFrameIndex();
-                int delay = decoder.getDelay(currentFrameIndex);
-                encoder.setDelay(delay);
-
-                decoder.advance();
-            } finally {
-                transformedResource.recycle();
-            }
-        }
-
-        boolean result = encoder.finish();
-
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Encoded gif with " + decoder.getFrameCount() + " frames and " + drawable.getData().length
-                    + " bytes in " + LogTime.getElapsedMillis(startTime) + " ms");
-        }
-
-        return result;
-    }
-
-    private boolean writeDataDirect(byte[] data, OutputStream os) {
-        boolean success = true;
-        try {
-            os.write(data);
-        } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Failed to write data to output stream in GifResourceEncoder", e);
-            }
-            success = false;
-        }
-        return success;
-    }
-
-    private GifDecoder decodeHeaders(byte[] data) {
-        GifHeaderParser parser = factory.buildParser();
-        parser.setData(data);
-        GifHeader header = parser.parseHeader();
-
-        GifDecoder decoder = factory.buildDecoder(provider);
-        decoder.setData(header, data);
-        decoder.advance();
-
-        return decoder;
-    }
-
-    private Resource<Bitmap> getTransformedFrame(Bitmap currentFrame, Transformation<Bitmap> transformation,
-            GifDrawable drawable) {
-        // TODO: what if current frame is null?
-        Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
-        Resource<Bitmap> transformedResource = transformation.transform(bitmapResource,
-                drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
-        if (!bitmapResource.equals(transformedResource)) {
-            bitmapResource.recycle();
-        }
-        return transformedResource;
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
-
-    // Visible for testing.
-    static class Factory {
-
-        public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
-            return new GifDecoder(bitmapProvider);
-        }
-
-        public GifHeaderParser buildParser() {
-            return new GifHeaderParser();
-        }
-
-        public AnimatedGifEncoder buildEncoder() {
-            return new AnimatedGifEncoder();
-        }
-
-        public Resource<Bitmap> buildFrameResource(Bitmap bitmap, BitmapPool bitmapPool) {
-            return new BitmapResource(bitmap, bitmapPool);
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
new file mode 100644
index 000000000..bef067093
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -0,0 +1,77 @@
+package com.bumptech.glide.load.resource.gif;
+
+import android.util.Log;
+
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * A relatively inefficient decoder for {@link com.bumptech.glide.load.resource.gif.GifDrawable}
+ * that converts {@link java.io.InputStream}s to {@link java.nio.ByteBuffer}s and then passes
+ * the buffer to a wrapped decoder.
+ */
+public class StreamGifDecoder implements ResourceDecoder<InputStream, GifDrawable> {
+  private static final String TAG = "StreamGifDecoder";
+  /**
+   * If set to {@code true}, disables this decoder
+   * ({@link #handles(InputStream, Options)} will return {@code false}). Defaults to
+   * {@code false}.
+   */
+  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
+      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
+
+  private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
+  private final ByteArrayPool byteArrayPool;
+
+  public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
+      ByteArrayPool byteArrayPool) {
+    this.byteBufferDecoder = byteBufferDecoder;
+    this.byteArrayPool = byteArrayPool;
+  }
+
+  @Override
+  public boolean handles(InputStream source, Options options) throws IOException {
+    return !options.get(DISABLE_ANIMATION)
+        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+  }
+
+  @Override
+  public Resource<GifDrawable> decode(InputStream source, int width, int height,
+      Options options) throws IOException {
+    byte[] data = inputStreamToBytes(source);
+    if (data == null) {
+      return null;
+    }
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    return byteBufferDecoder.decode(byteBuffer, width, height, options);
+  }
+
+  private static byte[] inputStreamToBytes(InputStream is) {
+    final int bufferSize = 16384;
+    ByteArrayOutputStream buffer = new ByteArrayOutputStream(bufferSize);
+    try {
+      int nRead;
+      byte[] data = new byte[bufferSize];
+      while ((nRead = is.read(data)) != -1) {
+        buffer.write(data, 0, nRead);
+      }
+      buffer.flush();
+    } catch (IOException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Error reading data from stream", e);
+      }
+      return null;
+    }
+    return buffer.toByteArray();
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapper.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapper.java
deleted file mode 100644
index 0b3b62ba6..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapper.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-/**
- * A wrapper that contains either an {@link android.graphics.Bitmap} resource or an
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} resource.
- */
-public class GifBitmapWrapper {
-    private final Resource<GifDrawable> gifResource;
-    private final Resource<Bitmap> bitmapResource;
-
-    public GifBitmapWrapper(Resource<Bitmap> bitmapResource, Resource<GifDrawable> gifResource) {
-        if (bitmapResource != null && gifResource != null) {
-            throw new IllegalArgumentException("Can only contain either a bitmap resource or a gif resource, not both");
-        }
-        if (bitmapResource == null && gifResource == null) {
-            throw new IllegalArgumentException("Must contain either a bitmap resource or a gif resource");
-        }
-        this.bitmapResource = bitmapResource;
-        this.gifResource = gifResource;
-    }
-
-    /**
-     * Returns the size of the wrapped resource.
-     */
-    public int getSize() {
-        if (bitmapResource != null) {
-            return bitmapResource.getSize();
-        } else {
-            return gifResource.getSize();
-        }
-    }
-
-    /**
-     * Returns the wrapped {@link android.graphics.Bitmap} resource if it exists, or null.
-     */
-    public Resource<Bitmap> getBitmapResource() {
-        return bitmapResource;
-    }
-
-    /**
-     * Returns the wrapped {@link com.bumptech.glide.load.resource.gif.GifDrawable} resource if it exists, or null.
-     */
-    public Resource<GifDrawable> getGifResource() {
-        return gifResource;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResource.java
deleted file mode 100644
index 0fcd22053..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResource.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-/**
- * A resource that wraps an {@link com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper}.
- */
-public class GifBitmapWrapperResource implements Resource<GifBitmapWrapper> {
-    private final GifBitmapWrapper data;
-
-    public GifBitmapWrapperResource(GifBitmapWrapper data) {
-        if (data == null) {
-            throw new NullPointerException("Data must not be null");
-        }
-        this.data = data;
-    }
-
-    @Override
-    public GifBitmapWrapper get() {
-        return data;
-    }
-
-    @Override
-    public int getSize() {
-        return data.getSize();
-    }
-
-    @Override
-    public void recycle() {
-        Resource<Bitmap> bitmapResource = data.getBitmapResource();
-        if (bitmapResource != null) {
-            bitmapResource.recycle();
-        }
-        Resource<GifDrawable> gifDataResource = data.getGifResource();
-        if (gifDataResource != null) {
-            gifDataResource.recycle();
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoder.java
deleted file mode 100644
index 18b198a2a..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoder.java
+++ /dev/null
@@ -1,150 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.resource.bitmap.BitmapResource;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.util.ByteArrayPool;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * An {@link ResourceDecoder} that can decode either an {@link Bitmap} or an {@link GifDrawable}
- * from an {@link InputStream} or a {@link android.os.ParcelFileDescriptor ParcelFileDescriptor}.
- */
-public class GifBitmapWrapperResourceDecoder implements ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> {
-    private static final ImageTypeParser DEFAULT_PARSER = new ImageTypeParser();
-    private static final BufferedStreamFactory DEFAULT_STREAM_FACTORY = new BufferedStreamFactory();
-    // 2048 is rather arbitrary, for most well formatted image types we only need 32 bytes.
-    // Visible for testing.
-    static final int MARK_LIMIT_BYTES = 2048;
-
-    private final ResourceDecoder<ImageVideoWrapper, Bitmap> bitmapDecoder;
-    private final ResourceDecoder<InputStream, GifDrawable> gifDecoder;
-    private final BitmapPool bitmapPool;
-    private final ImageTypeParser parser;
-    private final BufferedStreamFactory streamFactory;
-    private String id;
-
-    public GifBitmapWrapperResourceDecoder(ResourceDecoder<ImageVideoWrapper, Bitmap> bitmapDecoder,
-            ResourceDecoder<InputStream, GifDrawable> gifDecoder, BitmapPool bitmapPool) {
-        this(bitmapDecoder, gifDecoder, bitmapPool, DEFAULT_PARSER, DEFAULT_STREAM_FACTORY);
-    }
-
-    // Visible for testing.
-    GifBitmapWrapperResourceDecoder(ResourceDecoder<ImageVideoWrapper, Bitmap> bitmapDecoder,
-            ResourceDecoder<InputStream, GifDrawable> gifDecoder, BitmapPool bitmapPool, ImageTypeParser parser,
-            BufferedStreamFactory streamFactory) {
-        this.bitmapDecoder = bitmapDecoder;
-        this.gifDecoder = gifDecoder;
-        this.bitmapPool = bitmapPool;
-        this.parser = parser;
-        this.streamFactory = streamFactory;
-    }
-
-    @SuppressWarnings("resource")
-    // @see ResourceDecoder.decode
-    @Override
-    public Resource<GifBitmapWrapper> decode(ImageVideoWrapper source, int width, int height) throws IOException {
-        ByteArrayPool pool = ByteArrayPool.get();
-        byte[] tempBytes = pool.getBytes();
-
-        GifBitmapWrapper wrapper = null;
-        try {
-            wrapper = decode(source, width, height, tempBytes);
-        } finally {
-            pool.releaseBytes(tempBytes);
-        }
-        return wrapper != null ? new GifBitmapWrapperResource(wrapper) : null;
-    }
-
-    private GifBitmapWrapper decode(ImageVideoWrapper source, int width, int height, byte[] bytes) throws IOException {
-        final GifBitmapWrapper result;
-        if (source.getStream() != null) {
-            result = decodeStream(source, width, height, bytes);
-        } else {
-            result = decodeBitmapWrapper(source, width, height);
-        }
-        return result;
-    }
-
-    private GifBitmapWrapper decodeStream(ImageVideoWrapper source, int width, int height, byte[] bytes)
-            throws IOException {
-        InputStream bis = streamFactory.build(source.getStream(), bytes);
-        bis.mark(MARK_LIMIT_BYTES);
-        ImageHeaderParser.ImageType type = parser.parse(bis);
-        bis.reset();
-
-        GifBitmapWrapper result = null;
-        if (type == ImageHeaderParser.ImageType.GIF) {
-            result = decodeGifWrapper(bis, width, height);
-        }
-        // Decoding the gif may fail even if the type matches.
-        if (result == null) {
-            // We can only reset the buffered InputStream, so to start from the beginning of the stream, we need to
-            // pass in a new source containing the buffered stream rather than the original stream.
-            ImageVideoWrapper forBitmapDecoder = new ImageVideoWrapper(bis, source.getFileDescriptor());
-            result = decodeBitmapWrapper(forBitmapDecoder, width, height);
-        }
-        return result;
-    }
-
-    private GifBitmapWrapper decodeGifWrapper(InputStream bis, int width, int height) throws IOException {
-        GifBitmapWrapper result = null;
-        Resource<GifDrawable> gifResource = gifDecoder.decode(bis, width, height);
-        if (gifResource != null) {
-            GifDrawable drawable = gifResource.get();
-            // We can more efficiently hold Bitmaps in memory, so for static GIFs, try to return Bitmaps
-            // instead. Returning a Bitmap incurs the cost of allocating the GifDrawable as well as the normal
-            // Bitmap allocation, but since we can encode the Bitmap out as a JPEG, future decodes will be
-            // efficient.
-            if (drawable.getFrameCount() > 1) {
-                result = new GifBitmapWrapper(null /*bitmapResource*/, gifResource);
-            } else {
-                Resource<Bitmap> bitmapResource = new BitmapResource(drawable.getFirstFrame(), bitmapPool);
-                result = new GifBitmapWrapper(bitmapResource, null /*gifResource*/);
-            }
-        }
-        return result;
-    }
-
-    private GifBitmapWrapper decodeBitmapWrapper(ImageVideoWrapper toDecode, int width, int height) throws IOException {
-        GifBitmapWrapper result = null;
-
-        Resource<Bitmap> bitmapResource = bitmapDecoder.decode(toDecode, width, height);
-        if (bitmapResource != null) {
-            result = new GifBitmapWrapper(bitmapResource, null);
-        }
-
-        return result;
-    }
-
-    @Override
-    public String getId() {
-        if (id == null) {
-            id = gifDecoder.getId() + bitmapDecoder.getId();
-        }
-        return id;
-    }
-
-    // Visible for testing.
-    static class BufferedStreamFactory {
-        public InputStream build(InputStream is, byte[] buffer) {
-            return new RecyclableBufferedInputStream(is, buffer);
-        }
-    }
-
-    // Visible for testing.
-    static class ImageTypeParser {
-        public ImageHeaderParser.ImageType parse(InputStream is) throws IOException {
-            return new ImageHeaderParser(is).getType();
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoder.java
deleted file mode 100644
index ee18ab71d..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoder.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-
-import java.io.OutputStream;
-
-/**
- * A {@link com.bumptech.glide.load.ResourceEncoder} that can encode either an {@link Bitmap} or
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
- */
-public class GifBitmapWrapperResourceEncoder implements ResourceEncoder<GifBitmapWrapper> {
-    private final ResourceEncoder<Bitmap> bitmapEncoder;
-    private final ResourceEncoder<GifDrawable> gifEncoder;
-    private String id;
-
-    public GifBitmapWrapperResourceEncoder(ResourceEncoder<Bitmap> bitmapEncoder,
-            ResourceEncoder<GifDrawable> gifEncoder) {
-        this.bitmapEncoder = bitmapEncoder;
-        this.gifEncoder = gifEncoder;
-    }
-
-    @Override
-    public boolean encode(Resource<GifBitmapWrapper> resource, OutputStream os) {
-        final GifBitmapWrapper gifBitmap = resource.get();
-        final Resource<Bitmap> bitmapResource = gifBitmap.getBitmapResource();
-
-        if (bitmapResource != null) {
-            return bitmapEncoder.encode(bitmapResource, os);
-        } else {
-            return gifEncoder.encode(gifBitmap.getGifResource(), os);
-        }
-    }
-
-    @Override
-    public String getId() {
-        if (id == null) {
-            id = bitmapEncoder.getId() + gifEncoder.getId();
-        }
-        return id;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoder.java
deleted file mode 100644
index 2e594e517..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoder.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * A {@link com.bumptech.glide.load.ResourceDecoder} that can decode an
- * {@link com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper} from {@link java.io.InputStream} data.
- */
-public class GifBitmapWrapperStreamResourceDecoder implements ResourceDecoder<InputStream, GifBitmapWrapper> {
-    private final ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> gifBitmapDecoder;
-
-    public GifBitmapWrapperStreamResourceDecoder(
-            ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> gifBitmapDecoder) {
-        this.gifBitmapDecoder = gifBitmapDecoder;
-    }
-
-    @Override
-    public Resource<GifBitmapWrapper> decode(InputStream source, int width, int height) throws IOException {
-        return gifBitmapDecoder.decode(new ImageVideoWrapper(source, null), width, height);
-    }
-
-    @Override
-    public String getId() {
-        return gifBitmapDecoder.getId();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformation.java
deleted file mode 100644
index 791e81bd4..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformation.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-
-/**
- * A {@link com.bumptech.glide.load.Transformation} that can apply a wrapped {@link android.graphics.Bitmap}
- * transformation to both {@link android.graphics.Bitmap}s and {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
- */
-public class GifBitmapWrapperTransformation implements Transformation<GifBitmapWrapper> {
-    private final Transformation<Bitmap> bitmapTransformation;
-    private final Transformation<GifDrawable> gifDataTransformation;
-
-    public GifBitmapWrapperTransformation(BitmapPool bitmapPool, Transformation<Bitmap> bitmapTransformation) {
-        this(bitmapTransformation, new GifDrawableTransformation(bitmapTransformation, bitmapPool));
-    }
-
-    GifBitmapWrapperTransformation(Transformation<Bitmap> bitmapTransformation,
-            Transformation<GifDrawable> gifDataTransformation) {
-        this.bitmapTransformation = bitmapTransformation;
-        this.gifDataTransformation = gifDataTransformation;
-    }
-
-    @Override
-    public Resource<GifBitmapWrapper> transform(Resource<GifBitmapWrapper> resource, int outWidth, int outHeight) {
-        Resource<Bitmap> bitmapResource = resource.get().getBitmapResource();
-        Resource<GifDrawable> gifResource = resource.get().getGifResource();
-        if (bitmapResource != null && bitmapTransformation != null) {
-            Resource<Bitmap> transformed = bitmapTransformation.transform(bitmapResource, outWidth, outHeight);
-            if (!bitmapResource.equals(transformed)) {
-                GifBitmapWrapper gifBitmap = new GifBitmapWrapper(transformed, resource.get().getGifResource());
-                return new GifBitmapWrapperResource(gifBitmap);
-            }
-        } else if (gifResource != null && gifDataTransformation != null) {
-            Resource<GifDrawable> transformed = gifDataTransformation.transform(gifResource, outWidth, outHeight);
-            if (!gifResource.equals(transformed)) {
-                GifBitmapWrapper gifBitmap = new GifBitmapWrapper(resource.get().getBitmapResource(), transformed);
-                return new GifBitmapWrapperResource(gifBitmap);
-            }
-        }
-        return resource;
-    }
-
-    @Override
-    public String getId() {
-        return bitmapTransformation.getId();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/ImageVideoGifDrawableLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/ImageVideoGifDrawableLoadProvider.java
deleted file mode 100644
index e084fb524..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/ImageVideoGifDrawableLoadProvider.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package com.bumptech.glide.load.resource.gifbitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.model.ImageVideoWrapper;
-import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.provider.DataLoadProvider;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * An {@link com.bumptech.glide.provider.DataLoadProvider} that can load either an
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or an {@link Bitmap} from either an
- * {@link java.io.InputStream} or an {@link android.os.ParcelFileDescriptor}.
- */
-public class ImageVideoGifDrawableLoadProvider implements DataLoadProvider<ImageVideoWrapper, GifBitmapWrapper> {
-    private final ResourceDecoder<File, GifBitmapWrapper> cacheDecoder;
-    private final ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> sourceDecoder;
-    private final ResourceEncoder<GifBitmapWrapper> encoder;
-    private final Encoder<ImageVideoWrapper> sourceEncoder;
-
-    public ImageVideoGifDrawableLoadProvider(DataLoadProvider<ImageVideoWrapper, Bitmap> bitmapProvider,
-            DataLoadProvider<InputStream, GifDrawable> gifProvider, BitmapPool bitmapPool) {
-
-        final GifBitmapWrapperResourceDecoder decoder = new GifBitmapWrapperResourceDecoder(
-                bitmapProvider.getSourceDecoder(),
-                gifProvider.getSourceDecoder(),
-                bitmapPool
-        );
-        cacheDecoder = new FileToStreamDecoder<GifBitmapWrapper>(new GifBitmapWrapperStreamResourceDecoder(decoder));
-        sourceDecoder = decoder;
-        encoder = new GifBitmapWrapperResourceEncoder(bitmapProvider.getEncoder(), gifProvider.getEncoder());
-
-        //TODO: what about the gif provider?
-        sourceEncoder = bitmapProvider.getSourceEncoder();
-    }
-
-    @Override
-    public ResourceDecoder<File, GifBitmapWrapper> getCacheDecoder() {
-        return cacheDecoder;
-    }
-
-    @Override
-    public ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> getSourceDecoder() {
-        return sourceDecoder;
-    }
-
-    @Override
-    public Encoder<ImageVideoWrapper> getSourceEncoder() {
-        return sourceEncoder;
-    }
-
-    @Override
-    public ResourceEncoder<GifBitmapWrapper> getEncoder() {
-        return encoder;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index 01d944075..af4a0281b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -8,33 +8,29 @@
 import java.io.ByteArrayOutputStream;
 
 /**
- * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that converts
- * {@link android.graphics.Bitmap}s into byte arrays using
- * {@link android.graphics.Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}.
+ * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that converts {@link
+ * android.graphics.Bitmap}s into byte arrays using {@link android.graphics.Bitmap#compress
+ * (android.graphics.Bitmap.CompressFormat,
+ * int, java.io.OutputStream)}.
  */
 public class BitmapBytesTranscoder implements ResourceTranscoder<Bitmap, byte[]> {
-    private final Bitmap.CompressFormat compressFormat;
-    private final int quality;
-
-    public BitmapBytesTranscoder() {
-        this(Bitmap.CompressFormat.JPEG, 100);
-    }
-
-    public BitmapBytesTranscoder(Bitmap.CompressFormat compressFormat, int quality) {
-        this.compressFormat = compressFormat;
-        this.quality = quality;
-    }
-
-    @Override
-    public Resource<byte[]> transcode(Resource<Bitmap> toTranscode) {
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        toTranscode.get().compress(compressFormat, quality, os);
-        toTranscode.recycle();
-        return new BytesResource(os.toByteArray());
-    }
-
-    @Override
-    public String getId() {
-        return "BitmapBytesTranscoder.com.bumptech.glide.load.resource.transcode";
-    }
+  private final Bitmap.CompressFormat compressFormat;
+  private final int quality;
+
+  public BitmapBytesTranscoder() {
+    this(Bitmap.CompressFormat.JPEG, 100);
+  }
+
+  public BitmapBytesTranscoder(Bitmap.CompressFormat compressFormat, int quality) {
+    this.compressFormat = compressFormat;
+    this.quality = quality;
+  }
+
+  @Override
+  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    toTranscode.get().compress(compressFormat, quality, os);
+    toTranscode.recycle();
+    return new BytesResource(os.toByteArray());
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
new file mode 100644
index 000000000..b3993cbb2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.resource.transcode;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.LazyBitmapDrawableResource;
+import com.bumptech.glide.util.Preconditions;
+
+/**
+ * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that converts {@link
+ * android.graphics.Bitmap}s into {@link android.graphics.drawable.BitmapDrawable}s.
+ */
+public class BitmapDrawableTranscoder implements ResourceTranscoder<Bitmap, BitmapDrawable> {
+  private final Resources resources;
+  private final BitmapPool bitmapPool;
+
+  public BitmapDrawableTranscoder(Context context) {
+    this(context.getResources(), Glide.get(context).getBitmapPool());
+  }
+
+  public BitmapDrawableTranscoder(Resources resources, BitmapPool bitmapPool) {
+    this.resources = Preconditions.checkNotNull(resources);
+    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+  }
+
+  @Override
+  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode) {
+    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, toTranscode.get());
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoder.java
deleted file mode 100644
index 293439161..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoder.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-
-/**
- * A wrapper for {@link com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder} that transcodes
- * to {@link com.bumptech.glide.load.resource.drawable.GlideDrawable} rather than
- * {@link com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable}.
- *
- * TODO: use ? extends GlideDrawable rather than GlideDrawable directly and remove this class.
- */
-public class BitmapToGlideDrawableTranscoder implements ResourceTranscoder<Bitmap, GlideDrawable> {
-
-    private final GlideBitmapDrawableTranscoder glideBitmapDrawableTranscoder;
-
-    public BitmapToGlideDrawableTranscoder(Context context) {
-        this(new GlideBitmapDrawableTranscoder(context));
-    }
-
-    public BitmapToGlideDrawableTranscoder(GlideBitmapDrawableTranscoder glideBitmapDrawableTranscoder) {
-        this.glideBitmapDrawableTranscoder = glideBitmapDrawableTranscoder;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public Resource<GlideDrawable> transcode(Resource<Bitmap> toTranscode) {
-        return (Resource<GlideDrawable>) (Resource<? extends GlideDrawable>)
-                glideBitmapDrawableTranscoder.transcode(toTranscode);
-    }
-
-    @Override
-    public String getId() {
-        return glideBitmapDrawableTranscoder.getId();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoder.java
deleted file mode 100644
index d226d68d8..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoder.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
-
-/**
- * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that can transcode either an
- * {@link Bitmap} or an {@link com.bumptech.glide.load.resource.gif.GifDrawable} into an
- * {@link android.graphics.drawable.Drawable}.
- */
-public class GifBitmapWrapperDrawableTranscoder implements ResourceTranscoder<GifBitmapWrapper, GlideDrawable> {
-    private final ResourceTranscoder<Bitmap, GlideBitmapDrawable> bitmapDrawableResourceTranscoder;
-
-    public GifBitmapWrapperDrawableTranscoder(
-            ResourceTranscoder<Bitmap, GlideBitmapDrawable> bitmapDrawableResourceTranscoder) {
-        this.bitmapDrawableResourceTranscoder = bitmapDrawableResourceTranscoder;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public Resource<GlideDrawable> transcode(Resource<GifBitmapWrapper> toTranscode) {
-        GifBitmapWrapper gifBitmap = toTranscode.get();
-        Resource<Bitmap> bitmapResource = gifBitmap.getBitmapResource();
-
-        final Resource<? extends GlideDrawable> result;
-        if (bitmapResource != null) {
-            result = bitmapDrawableResourceTranscoder.transcode(bitmapResource);
-        } else {
-            result = gifBitmap.getGifResource();
-        }
-        // This is unchecked but always safe, anything that extends a Drawable can be safely cast to a Drawable.
-        return (Resource<GlideDrawable>) result;
-    }
-
-    @Override
-    public String getId() {
-        return "GifBitmapWrapperDrawableTranscoder.com.bumptech.glide.load.resource.transcode";
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 586744c14..98e3f9790 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -3,21 +3,20 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.util.ByteBufferUtil;
+
+import java.nio.ByteBuffer;
 
 /**
- * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that converts
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} into bytes by obtaining the original bytes of the GIF from
- * the {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+ * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that converts {@link
+ * com.bumptech.glide.load.resource.gif.GifDrawable} into bytes by obtaining the original bytes of
+ * the GIF from the {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableBytesTranscoder implements ResourceTranscoder<GifDrawable, byte[]> {
-    @Override
-    public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode) {
-        GifDrawable gifData = toTranscode.get();
-        return new BytesResource(gifData.getData());
-    }
-
-    @Override
-    public String getId() {
-        return "GifDrawableBytesTranscoder.com.bumptech.glide.load.resource.transcode";
-    }
+  @Override
+  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode) {
+    GifDrawable gifData = toTranscode.get();
+    ByteBuffer byteBuffer = gifData.getBuffer();
+    return new BytesResource(ByteBufferUtil.toBytes(byteBuffer));
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoder.java
deleted file mode 100644
index bdc03df84..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoder.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.bumptech.glide.load.resource.transcode;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
-import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawableResource;
-
-/**
- * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that converts
- * {@link android.graphics.Bitmap}s into {@link android.graphics.drawable.BitmapDrawable}s.
- */
-public class GlideBitmapDrawableTranscoder implements ResourceTranscoder<Bitmap, GlideBitmapDrawable> {
-    private final Resources resources;
-    private final BitmapPool bitmapPool;
-
-    public GlideBitmapDrawableTranscoder(Context context) {
-        this(context.getResources(), Glide.get(context).getBitmapPool());
-    }
-
-    public GlideBitmapDrawableTranscoder(Resources resources, BitmapPool bitmapPool) {
-        this.resources = resources;
-        this.bitmapPool = bitmapPool;
-    }
-
-    @Override
-    public Resource<GlideBitmapDrawable> transcode(Resource<Bitmap> toTranscode) {
-        GlideBitmapDrawable drawable = new GlideBitmapDrawable(resources, toTranscode.get());
-        return new GlideBitmapDrawableResource(drawable, bitmapPool);
-    }
-
-    @Override
-    public String getId() {
-        return "GlideBitmapDrawableTranscoder.com.bumptech.glide.load.resource.transcode";
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index 0e70dcbe7..ad1c55c6e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -10,12 +10,10 @@
  */
 public interface ResourceTranscoder<Z, R> {
 
-    /**
-     * Transcodes the given resource to the new resource type and returns the wew resource.
-     *
-     * @param toTranscode The resource to transcode.
-     */
-    Resource<R> transcode(Resource<Z> toTranscode);
-
-    String getId();
+  /**
+   * Transcodes the given resource to the new resource type and returns the new resource.
+   *
+   * @param toTranscode The resource to transcode.
+   */
+  Resource<R> transcode(Resource<Z> toTranscode);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
index adc854c7f..c0a0bdb42 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
@@ -1,58 +1,96 @@
 package com.bumptech.glide.load.resource.transcode;
 
-import com.bumptech.glide.util.MultiClassKey;
-
-import java.util.HashMap;
-import java.util.Map;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
- * A class that allows {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder}s to be registered and
- * retrieved by the classes they convert between.
+ * A class that allows {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder}s to be
+ * registered and retrieved by the classes they convert between.
  */
 public class TranscoderRegistry {
-    private static final MultiClassKey GET_KEY = new MultiClassKey();
+  private final List<Entry<?, ?>> transcoders = new ArrayList<>();
 
-    private final Map<MultiClassKey, ResourceTranscoder<?, ?>> factories =
-            new HashMap<MultiClassKey, ResourceTranscoder<?, ?>>();
+  /**
+   * Registers the given {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} using
+   * the given classes so it can later be retrieved using the given classes.
+   *
+   * @param decodedClass    The class of the resource that the transcoder transcodes from.
+   * @param transcodedClass The class of the resource that the transcoder transcodes to.
+   * @param transcoder      The transcoder.
+   * @param <Z>             The type of the resource that the transcoder transcodes from.
+   * @param <R>             The type of the resource that the transcoder transcodes to.
+   */
+  public synchronized <Z, R> void register(Class<Z> decodedClass, Class<R> transcodedClass,
+      ResourceTranscoder<Z, R> transcoder) {
+    transcoders.add(new Entry<>(decodedClass, transcodedClass, transcoder));
+  }
 
-    /**
-     * Registers the given {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} using the given
-     * classes so it can later be retrieved using the given classes.
-     *
-     * @param decodedClass The class of the resource that the transcoder transcodes from.
-     * @param transcodedClass The class of the resource that the transcoder transcodes to.
-     * @param transcoder The transcoder.
-     * @param <Z> The type of the resource that the transcoder transcodes from.
-     * @param <R> The type of the resource that the transcoder transcodes to.
-     */
-    public <Z, R> void register(Class<Z> decodedClass, Class<R> transcodedClass, ResourceTranscoder<Z, R> transcoder) {
-        factories.put(new MultiClassKey(decodedClass, transcodedClass), transcoder);
+  /**
+   * Returns the currently registered
+   * {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} for the given classes.
+   *
+   * @param resourceClass   The class of the resource that the transcoder transcodes from.
+   * @param transcodedClass The class of the resource that the transcoder transcodes to.
+   * @param <Z>             The type of the resource that the transcoder transcodes from.
+   * @param <R>             The type of the resource that the transcoder transcodes to.
+   */
+  @SuppressWarnings("unchecked")
+  public synchronized <Z, R> ResourceTranscoder<Z, R> get(Class<Z> resourceClass,
+      Class<R> transcodedClass) {
+    // For example, there may be a transcoder that can convert a GifDrawable to a Drawable, which
+    // will be caught above. However, if there is no registered transcoder, we can still just use
+    // the UnitTranscoder to return the Drawable because the transcode class (Drawable) is
+    // assignable from the resource class (GifDrawable).
+    if (transcodedClass.isAssignableFrom(resourceClass)) {
+      return (ResourceTranscoder<Z, R>) UnitTranscoder.get();
+    }
+    for (Entry<?, ?> entry : transcoders) {
+      if (entry.handles(resourceClass, transcodedClass)) {
+        return (ResourceTranscoder<Z, R>) entry.transcoder;
+      }
+    }
+
+    throw new IllegalArgumentException(
+        "No transcoder registered to transcode from " + resourceClass + " to " + transcodedClass);
+  }
+
+  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(Class<Z> resourceClass,
+      Class<R> transcodeClass) {
+    List<Class<R>> transcodeClasses = new ArrayList<>();
+    // GifDrawable -> Drawable is just the UnitTranscoder, as is GifDrawable -> GifDrawable.
+    if (transcodeClass.isAssignableFrom(resourceClass)) {
+      transcodeClasses.add(transcodeClass);
+      return transcodeClasses;
+    }
+
+    for (Entry<?, ?> entry : transcoders) {
+      if (entry.handles(resourceClass, transcodeClass)) {
+        transcodeClasses.add(transcodeClass);
+      }
+    }
+
+    return transcodeClasses;
+  }
+
+  private static final class Entry<Z, R> {
+    private final Class<Z> fromClass;
+    private final Class<R> toClass;
+    private final ResourceTranscoder<Z, R> transcoder;
+
+    Entry(Class<Z> fromClass, Class<R> toClass, ResourceTranscoder<Z, R> transcoder) {
+      this.fromClass = fromClass;
+      this.toClass = toClass;
+      this.transcoder = transcoder;
     }
 
     /**
-     * Returns the currently registered {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} for the
-     * given classes.
-     *
-     * @param decodedClass The class of the resource that the transcoder transcodes from.
-     * @param transcodedClass The class of the resource that the transcoder transcodes to.
-     * @param <Z> The type of the resource that the transcoder transcodes from.
-     * @param <R> The type of the resource that the transcoder transcodes to.
+     * If we convert from a specific Drawable, we must get that specific Drawable class or a
+     * subclass of that Drawable. In contrast, if we we convert <em>to</em> a specific Drawable,
+     * we can fulfill requests for a more generic parent class (like Drawable). As a result, we
+     * check fromClass and toClass in different orders.
      */
-    @SuppressWarnings("unchecked")
-    public <Z, R> ResourceTranscoder<Z, R> get(Class<Z> decodedClass, Class<R> transcodedClass) {
-        if (decodedClass.equals(transcodedClass)) {
-            // we know they're the same type (Z and R)
-            return (ResourceTranscoder<Z, R>) UnitTranscoder.get();
-        }
-        final ResourceTranscoder<?, ?> result;
-        synchronized (GET_KEY) {
-            GET_KEY.set(decodedClass, transcodedClass);
-            result = factories.get(GET_KEY);
-        }
-        if (result == null) {
-            throw new IllegalArgumentException("No transcoder registered for " + decodedClass + " and "
-                    + transcodedClass);
-        }
-        return (ResourceTranscoder<Z, R>) result;
+    public boolean handles(Class<?> fromClass, Class<?> toClass) {
+      return this.fromClass.isAssignableFrom(fromClass) && toClass.isAssignableFrom(this.toClass);
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
index 6bf8ed8c7..966e11ecf 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
@@ -8,20 +8,15 @@
  * @param <Z> The type of the resource that will be transcoded from and to.
  */
 public class UnitTranscoder<Z> implements ResourceTranscoder<Z, Z> {
-    private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<Object>();
+  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<Object>();
 
-    @SuppressWarnings("unchecked")
-    public static <Z> ResourceTranscoder<Z, Z> get() {
-        return (ResourceTranscoder<Z, Z>) UNIT_TRANSCODER;
-    }
+  @SuppressWarnings("unchecked")
+  public static <Z> ResourceTranscoder<Z, Z> get() {
+    return (ResourceTranscoder<Z, Z>) UNIT_TRANSCODER;
+  }
 
-    @Override
-    public Resource<Z> transcode(Resource<Z> toTranscode) {
-        return toTranscode;
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
+  @Override
+  public Resource<Z> transcode(Resource<Z> toTranscode) {
+    return toTranscode;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index f91270cd2..177165f4e 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,65 +1,68 @@
 package com.bumptech.glide.manager;
 
+import com.bumptech.glide.util.Util;
+
 import java.util.Collections;
 import java.util.Set;
 import java.util.WeakHashMap;
 
 /**
- * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying listeners of
- * {@link android.app.Fragment} and {@link android.app.Activity} lifecycle events.
+ * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying
+ * listeners of {@link android.app.Fragment} and {@link android.app.Activity} lifecycle events.
  */
 class ActivityFragmentLifecycle implements Lifecycle {
-    private final Set<LifecycleListener> lifecycleListeners =
-            Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>()));
-    private boolean isStarted;
-    private boolean isDestroyed;
+  private final Set<LifecycleListener> lifecycleListeners =
+      Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>());
+  private boolean isStarted;
+  private boolean isDestroyed;
 
-    /**
-     * Adds the given listener to the list of listeners to be notified on each lifecycle event.
-     *
-     * <p>
-     *     The latest lifecycle event will be called on the given listener synchronously in this method. If the
-     *     activity or fragment is stopped, {@link LifecycleListener#onStop()}} will be called, and same for onStart and
-     *     onDestroy.
-     * </p>
-     *
-     * <p>
-     *     Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once will have their
-     *     lifecycle methods called more than once. It is the caller's responsibility to avoid adding listeners
-     *     multiple times.
-     * </p>
-     */
-    @Override
-    public void addListener(LifecycleListener listener) {
-        lifecycleListeners.add(listener);
+  /**
+   * Adds the given listener to the list of listeners to be notified on each lifecycle event.
+   *
+   * <p> The latest lifecycle event will be called on the given listener synchronously in this
+   * method. If the activity or fragment is stopped, {@link LifecycleListener#onStop()}} will be
+   * called, and same for onStart and onDestroy. </p>
+   *
+   * <p> Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once
+   * will have their lifecycle methods called more than once. It is the caller's responsibility to
+   * avoid adding listeners multiple times. </p>
+   */
+  @Override
+  public void addListener(LifecycleListener listener) {
+    lifecycleListeners.add(listener);
 
-        if (isDestroyed) {
-            listener.onDestroy();
-        } else if (isStarted) {
-            listener.onStart();
-        } else {
-            listener.onStop();
-        }
+    if (isDestroyed) {
+      listener.onDestroy();
+    } else if (isStarted) {
+      listener.onStart();
+    } else {
+      listener.onStop();
     }
+  }
+
+  @Override
+  public void removeListener(LifecycleListener listener) {
+    lifecycleListeners.remove(listener);
+  }
 
-    void onStart() {
-        isStarted = true;
-        for (LifecycleListener lifecycleListener : lifecycleListeners) {
-            lifecycleListener.onStart();
-        }
+  void onStart() {
+    isStarted = true;
+    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
+      lifecycleListener.onStart();
     }
+  }
 
-    void onStop() {
-        isStarted = false;
-        for (LifecycleListener lifecycleListener : lifecycleListeners) {
-            lifecycleListener.onStop();
-        }
+  void onStop() {
+    isStarted = false;
+    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
+      lifecycleListener.onStop();
     }
+  }
 
-    void onDestroy() {
-        isDestroyed = true;
-        for (LifecycleListener lifecycleListener : lifecycleListeners) {
-            lifecycleListener.onDestroy();
-        }
+  void onDestroy() {
+    isDestroyed = true;
+    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
+      lifecycleListener.onDestroy();
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
index de9a77d9d..5911d5234 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
@@ -1,17 +1,20 @@
 package com.bumptech.glide.manager;
 
 /**
- * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying listeners of
- * {@link android.app.Application} lifecycle events.
+ * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying
+ * listeners of {@link android.app.Application} lifecycle events.
  *
- * <p>
- *     Since there are essentially no {@link android.app.Application} lifecycle events, this class simply defaults to
- *     notifying new listeners that they are started.
- * </p>
+ * <p> Since there are essentially no {@link android.app.Application} lifecycle events, this class
+ * simply defaults to notifying new listeners that they are started. </p>
  */
 class ApplicationLifecycle implements Lifecycle {
-    @Override
-    public void addListener(LifecycleListener listener) {
-        listener.onStart();
-    }
+  @Override
+  public void addListener(LifecycleListener listener) {
+    listener.onStart();
+  }
+
+  @Override
+  public void removeListener(LifecycleListener listener) {
+    // Do nothing.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
index fbd671b6c..dc216c871 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
@@ -5,15 +5,15 @@
  */
 public interface ConnectivityMonitor extends LifecycleListener {
 
+  /**
+   * An interface for listening to network connectivity events picked up by the monitor.
+   */
+  interface ConnectivityListener {
     /**
-     * An interface for listening to network connectivity events picked up by the monitor.
+     * Called when the connectivity state changes.
+     *
+     * @param isConnected True if we're currently connected to a network, false otherwise.
      */
-    interface ConnectivityListener {
-        /**
-         * Called when the connectivity state changes.
-         *
-         * @param isConnected True if we're currently connected to a network, false otherwise.
-         */
-        void onConnectivityChanged(boolean isConnected);
-    }
+    void onConnectivityChanged(boolean isConnected);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
index 77d1c5068..3b130fd70 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
@@ -4,18 +4,20 @@
 import android.content.pm.PackageManager;
 
 /**
- * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the application
- * has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op non functional
- * {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have the required permission.
+ * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
+ * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
+ * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
+ * the required permission.
  */
 public class ConnectivityMonitorFactory {
-    public ConnectivityMonitor build(Context context, ConnectivityMonitor.ConnectivityListener listener) {
-        final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
-        final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
-        if (hasPermission) {
-            return new DefaultConnectivityMonitor(context, listener);
-        } else {
-            return new NullConnectivityMonitor();
-        }
+  public ConnectivityMonitor build(Context context,
+      ConnectivityMonitor.ConnectivityListener listener) {
+    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
+    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
+    if (hasPermission) {
+      return new DefaultConnectivityMonitor(context, listener);
+    } else {
+      return new NullConnectivityMonitor();
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index aa194c4cb..945df9f96 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -8,66 +8,67 @@
 import android.net.NetworkInfo;
 
 class DefaultConnectivityMonitor implements ConnectivityMonitor {
-    private final Context context;
-    private final ConnectivityListener listener;
+  private final Context context;
+  private final ConnectivityListener listener;
 
-    private boolean isConnected;
-    private boolean isRegistered;
+  private boolean isConnected;
+  private boolean isRegistered;
 
-    private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            boolean wasConnected = isConnected;
-            isConnected = isConnected(context);
-            if (wasConnected != isConnected) {
-                listener.onConnectivityChanged(isConnected);
-            }
-        }
-    };
-
-    public DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {
-        this.context = context.getApplicationContext();
-        this.listener = listener;
+  private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
+    @Override
+    public void onReceive(Context context, Intent intent) {
+      boolean wasConnected = isConnected;
+      isConnected = isConnected(context);
+      if (wasConnected != isConnected) {
+        listener.onConnectivityChanged(isConnected);
+      }
     }
+  };
 
-    private void register() {
-        if (isRegistered) {
-            return;
-        }
+  public DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {
+    this.context = context.getApplicationContext();
+    this.listener = listener;
+  }
 
-        isConnected = isConnected(context);
-        context.registerReceiver(connectivityReceiver, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
-        isRegistered = true;
+  private void register() {
+    if (isRegistered) {
+      return;
     }
 
-    private void unregister() {
-        if (!isRegistered) {
-            return;
-        }
+    isConnected = isConnected(context);
+    context.registerReceiver(connectivityReceiver,
+        new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+    isRegistered = true;
+  }
 
-        context.unregisterReceiver(connectivityReceiver);
-        isRegistered = false;
+  private void unregister() {
+    if (!isRegistered) {
+      return;
     }
 
-    private boolean isConnected(Context context) {
-        ConnectivityManager connectivityManager =
-                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-        NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
-        return networkInfo != null && networkInfo.isConnected();
-    }
+    context.unregisterReceiver(connectivityReceiver);
+    isRegistered = false;
+  }
 
-    @Override
-    public void onStart() {
-        register();
-    }
+  private boolean isConnected(Context context) {
+    ConnectivityManager connectivityManager =
+        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+    return networkInfo != null && networkInfo.isConnected();
+  }
 
-    @Override
-    public void onStop() {
-        unregister();
-    }
+  @Override
+  public void onStart() {
+    register();
+  }
 
-    @Override
-    public void onDestroy() {
-        // Do nothing.
-    }
+  @Override
+  public void onStop() {
+    unregister();
+  }
+
+  @Override
+  public void onDestroy() {
+    // Do nothing.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
new file mode 100644
index 000000000..41505a86e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.manager;
+
+import com.bumptech.glide.RequestManager;
+
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * A {@link RequestManagerTreeNode} that returns no relatives.
+ */
+final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
+    @Override
+    public Set<RequestManager> getDescendants() {
+        return Collections.emptySet();
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
index a4a9be957..5a84cd246 100644
--- a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
@@ -4,8 +4,17 @@
  * An interface for listening to Activity/Fragment lifecycle events.
  */
 public interface Lifecycle {
-    /**
-     * Adds the given listener to the set of listeners managed by this Lifecycle implementation.
-     */
-    void addListener(LifecycleListener listener);
+  /**
+   * Adds the given listener to the set of listeners managed by this Lifecycle implementation.
+   */
+  void addListener(LifecycleListener listener);
+
+  /**
+   * Removes the given listener from the set of listeners managed by this Lifecycle implementation,
+   * returning {@code true} if the listener was removed sucessfully, and {@code false} otherwise.
+   *
+   * <p>This is an optimization only, there is no guarantee that every added listener will
+   * eventually be removed.
+   */
+  void removeListener(LifecycleListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/LifecycleListener.java b/library/src/main/java/com/bumptech/glide/manager/LifecycleListener.java
index e9deebe20..0a546f418 100644
--- a/library/src/main/java/com/bumptech/glide/manager/LifecycleListener.java
+++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleListener.java
@@ -1,23 +1,26 @@
 package com.bumptech.glide.manager;
 
 /**
- * An interface for listener to {@link android.app.Fragment} and {@link android.app.Activity} lifecycle events.
+ * An interface for listener to {@link android.app.Fragment} and {@link android.app.Activity}
+ * lifecycle events.
  */
 public interface LifecycleListener {
 
-    /**
-     * Callback for when {@link android.app.Fragment#onStart()}} or {@link android.app.Activity#onStart()} is called.
-     */
-    void onStart();
+  /**
+   * Callback for when {@link android.app.Fragment#onStart()}} or {@link
+   * android.app.Activity#onStart()} is called.
+   */
+  void onStart();
 
-    /**
-     * Callback for when {@link android.app.Fragment#onStop()}} or {@link android.app.Activity#onStop()}} is called.
-     */
-    void onStop();
+  /**
+   * Callback for when {@link android.app.Fragment#onStop()}} or {@link
+   * android.app.Activity#onStop()}} is called.
+   */
+  void onStop();
 
-    /**
-     * Callback for when {@link android.app.Fragment#onDestroy()}} or {@link android.app.Activity#onDestroy()} is
-     * called.
-     */
-    void onDestroy();
+  /**
+   * Callback for when {@link android.app.Fragment#onDestroy()}} or {@link
+   * android.app.Activity#onDestroy()} is called.
+   */
+  void onDestroy();
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
index 1cbb0b878..b182cb0ab 100644
--- a/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
@@ -5,18 +5,18 @@
  */
 class NullConnectivityMonitor implements ConnectivityMonitor {
 
-    @Override
-    public void onStart() {
-        // Do nothing.
-    }
+  @Override
+  public void onStart() {
+    // Do nothing.
+  }
 
-    @Override
-    public void onStop() {
-        // Do nothing.
-    }
+  @Override
+  public void onStop() {
+    // Do nothing.
+  }
 
-    @Override
-    public void onDestroy() {
-        // Do nothing.
-    }
+  @Override
+  public void onDestroy() {
+    // Do nothing.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 47d93afd1..1650bf2f2 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -2,15 +2,22 @@
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.app.Activity;
 import android.app.Fragment;
 import android.os.Build;
+import android.support.annotation.Nullable;
+import android.util.Log;
 
 import com.bumptech.glide.RequestManager;
 
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
 /**
- * A view-less {@link android.app.Fragment} used to safely store an {@link com.bumptech.glide.RequestManager} that
- * can be used to start, stop and manage Glide requests started for targets the fragment or activity this fragment is a
- * child of.
+ * A view-less {@link android.app.Fragment} used to safely store an {@link
+ * com.bumptech.glide.RequestManager} that can be used to start, stop and manage Glide requests
+ * started for targets the fragment or activity this fragment is a child of.
  *
  * @see com.bumptech.glide.manager.SupportRequestManagerFragment
  * @see com.bumptech.glide.manager.RequestManagerRetriever
@@ -18,54 +25,218 @@
  */
 @TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class RequestManagerFragment extends Fragment {
-    private final ActivityFragmentLifecycle lifecycle;
-    private RequestManager requestManager;
+  private static final String TAG = "RMFragment";
+  private final ActivityFragmentLifecycle lifecycle;
+  private final RequestManagerTreeNode requestManagerTreeNode =
+      new FragmentRequestManagerTreeNode();
+  private final HashSet<RequestManagerFragment> childRequestManagerFragments =
+      new HashSet<>();
+
+  @Nullable private RequestManager requestManager;
+  @Nullable private RequestManagerFragment rootRequestManagerFragment;
+  @Nullable private Fragment parentFragmentHint;
+
+  public RequestManagerFragment() {
+    this(new ActivityFragmentLifecycle());
+  }
+
+  // For testing only.
+  @SuppressLint("ValidFragment")
+  RequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+    this.lifecycle = lifecycle;
+  }
+
+  /**
+   * Sets the current {@link com.bumptech.glide.RequestManager}.
+   *
+   * @param requestManager The request manager to use.
+   */
+  public void setRequestManager(RequestManager requestManager) {
+    this.requestManager = requestManager;
+  }
+
+  ActivityFragmentLifecycle getLifecycle() {
+    return lifecycle;
+  }
 
-    public RequestManagerFragment() {
-        this(new ActivityFragmentLifecycle());
+  /**
+   * Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists.
+   */
+  @Nullable
+  public RequestManager getRequestManager() {
+    return requestManager;
+  }
+
+  /**
+   * Returns the {@link RequestManagerTreeNode} for this fragment.
+   */
+  public RequestManagerTreeNode getRequestManagerTreeNode() {
+    return requestManagerTreeNode;
+  }
+
+  private void addChildRequestManagerFragment(RequestManagerFragment child) {
+    childRequestManagerFragments.add(child);
+  }
+
+  private void removeChildRequestManagerFragment(RequestManagerFragment child) {
+    childRequestManagerFragments.remove(child);
+  }
+
+  /**
+   * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
+   * our parent is the fragment that we are annotating).
+   */
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  public Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
+    if (rootRequestManagerFragment == this) {
+      return Collections.unmodifiableSet(childRequestManagerFragments);
+    } else if (rootRequestManagerFragment == null
+        || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
+      // Pre JB MR1 doesn't allow us to get the parent fragment so we can't introspect hierarchy,
+      // so just return an empty set.
+      return Collections.emptySet();
+    } else {
+      HashSet<RequestManagerFragment> descendants = new HashSet<>();
+      for (RequestManagerFragment fragment : rootRequestManagerFragment
+          .getDescendantRequestManagerFragments()) {
+        if (isDescendant(fragment.getParentFragment())) {
+          descendants.add(fragment);
+        }
+      }
+      return Collections.unmodifiableSet(descendants);
     }
+  }
 
-    // For testing only.
-    @SuppressLint("ValidFragment")
-    RequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
-        this.lifecycle = lifecycle;
+  /**
+   * Sets a hint for which fragment is our parent which allows the fragment to return correct
+   * information about its parents before pending fragment transactions have been executed.
+   */
+  void setParentFragmentHint(Fragment parentFragmentHint) {
+    this.parentFragmentHint = parentFragmentHint;
+    if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
+      registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
+  }
 
-    /**
-     * Sets the current {@link com.bumptech.glide.RequestManager}.
-     *
-     * @param requestManager The request manager to use.
-     */
-    public void setRequestManager(RequestManager requestManager) {
-        this.requestManager = requestManager;
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  private Fragment getParentFragmentUsingHint() {
+    final Fragment fragment;
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+      fragment = getParentFragment();
+    } else {
+      fragment = null;
     }
+    return fragment != null ? fragment : parentFragmentHint;
+  }
 
-    ActivityFragmentLifecycle getLifecycle() {
-        return lifecycle;
+  /**
+   * Returns true if the fragment is a descendant of our parent.
+   */
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  private boolean isDescendant(Fragment fragment) {
+    Fragment root = this.getParentFragment();
+    while (fragment.getParentFragment() != null) {
+      if (fragment.getParentFragment() == root) {
+        return true;
+      }
+      fragment = fragment.getParentFragment();
     }
+    return false;
+  }
 
-    /**
-     * Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists.
-     */
-    public RequestManager getRequestManager() {
-        return requestManager;
+  private void registerFragmentWithRoot(Activity activity) {
+    unregisterFragmentWithRoot();
+    rootRequestManagerFragment = RequestManagerRetriever.get()
+        .getRequestManagerFragment(activity.getFragmentManager(), null);
+    if (rootRequestManagerFragment != this) {
+      rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
+  }
 
-    @Override
-    public void onStart() {
-        super.onStart();
-        lifecycle.onStart();
+  private void unregisterFragmentWithRoot() {
+    if (rootRequestManagerFragment != null) {
+      rootRequestManagerFragment.removeChildRequestManagerFragment(this);
+      rootRequestManagerFragment = null;
     }
+  }
+
+  @Override
+  public void onAttach(Activity activity) {
+    super.onAttach(activity);
+    try {
+      registerFragmentWithRoot(activity);
+    } catch (IllegalArgumentException e) {
+      // OnAttach can be called after the activity is destroyed, see #497.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to register fragment with root", e);
+      }
+    }
+  }
+
+  @Override
+  public void onDetach() {
+    super.onDetach();
+    unregisterFragmentWithRoot();
+  }
+
+  @Override
+  public void onStart() {
+    super.onStart();
+    lifecycle.onStart();
+  }
+
+  @Override
+  public void onStop() {
+    super.onStop();
+    lifecycle.onStop();
+  }
+
+  @Override
+  public void onDestroy() {
+    super.onDestroy();
+    lifecycle.onDestroy();
+    unregisterFragmentWithRoot();
+  }
+
+  @Override
+  public void onTrimMemory(int level) {
+    // If an activity is re-created, onTrimMemory may be called before a manager is ever put.
+    // See #329.
+    if (requestManager != null) {
+      requestManager.onTrimMemory(level);
+    }
+  }
+
+  @Override
+  public void onLowMemory() {
+    // If an activity is re-created, onLowMemory may be called before a manager is ever put.
+    // See #329.
+    if (requestManager != null) {
+      requestManager.onLowMemory();
+    }
+  }
+
+  @Override
+  public String toString() {
+    return super.toString() + "{parent=" + getParentFragmentUsingHint() + "}";
+  }
 
+  private class FragmentRequestManagerTreeNode implements RequestManagerTreeNode {
     @Override
-    public void onStop() {
-        super.onStop();
-        lifecycle.onStop();
+    public Set<RequestManager> getDescendants() {
+      Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
+      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      for (RequestManagerFragment fragment : descendantFragments) {
+        if (fragment.getRequestManager() != null) {
+          descendants.add(fragment.getRequestManager());
+        }
+      }
+      return descendants;
     }
 
     @Override
-    public void onDestroy() {
-        super.onDestroy();
-        lifecycle.onDestroy();
+    public String toString() {
+      return super.toString() + "{fragment=" + RequestManagerFragment.this + "}";
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index b0b80fa56..e46936da8 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -21,205 +21,228 @@
 import java.util.Map;
 
 /**
- * A collection of static methods for creating new {@link com.bumptech.glide.RequestManager}s or retrieving existing
- * ones from activities and fragment.
+ * A collection of static methods for creating new {@link com.bumptech.glide.RequestManager}s or
+ * retrieving existing ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-    static final String TAG = "com.bumptech.glide.manager";
-
-    /** The singleton instance of RequestManagerRetriever. */
-    private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();
-
-    private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
-    private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
-
-    /** The top application level RequestManager. */
-    private volatile RequestManager applicationManager;
-
-    // Visible for testing.
-    /** Pending adds for RequestManagerFragments. */
-    final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
-            new HashMap<android.app.FragmentManager, RequestManagerFragment>();
-
-    // Visible for testing.
-    /** Pending adds for SupportRequestManagerFragments. */
-    final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
-            new HashMap<FragmentManager, SupportRequestManagerFragment>();
-
-    /** Main thread handler to handle cleaning up pending fragment maps. */
-    private final Handler handler;
-
-    /**
-     * Retrieves and returns the RequestManagerRetriever singleton.
-     */
-    public static RequestManagerRetriever get() {
-        return INSTANCE;
+  // Visible for testing.
+  static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
+  private static final String TAG = "RMRetriever";
+
+  /**
+   * The singleton instance of RequestManagerRetriever.
+   */
+  private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();
+
+  private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
+  private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
+
+  /**
+   * The top application level RequestManager.
+   */
+  private volatile RequestManager applicationManager;
+
+  // Visible for testing.
+  /**
+   * Pending adds for RequestManagerFragments.
+   */
+  final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
+      new HashMap<>();
+
+  // Visible for testing.
+  /**
+   * Pending adds for SupportRequestManagerFragments.
+   */
+  final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
+      new HashMap<>();
+
+  /**
+   * Main thread handler to handle cleaning up pending fragment maps.
+   */
+  private final Handler handler;
+
+  /**
+   * Retrieves and returns the RequestManagerRetriever singleton.
+   */
+  public static RequestManagerRetriever get() {
+    return INSTANCE;
+  }
+
+  // Visible for testing.
+  RequestManagerRetriever() {
+    handler = new Handler(Looper.getMainLooper(), this /* Callback */);
+  }
+
+  private RequestManager getApplicationManager(Context context) {
+    // Either an application context or we're on a background thread.
+    if (applicationManager == null) {
+      synchronized (this) {
+        if (applicationManager == null) {
+          // Normally pause/resume is taken care of by the fragment we add to the fragment or
+          // activity. However, in this case since the manager attached to the application will not
+          // receive lifecycle events, we must force the manager to start resumed using
+          // ApplicationLifecycle.
+          applicationManager =
+              new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(),
+                  new EmptyRequestManagerTreeNode());
+        }
+      }
     }
 
-    // Visible for testing.
-    RequestManagerRetriever() {
-        handler = new Handler(Looper.getMainLooper(), this /* Callback */);
+    return applicationManager;
+  }
+
+  public RequestManager get(Context context) {
+    if (context == null) {
+      throw new IllegalArgumentException("You cannot start a load on a null Context");
+    } else if (Util.isOnMainThread() && !(context instanceof Application)) {
+      if (context instanceof FragmentActivity) {
+        return get((FragmentActivity) context);
+      } else if (context instanceof Activity) {
+        return get((Activity) context);
+      } else if (context instanceof ContextWrapper) {
+        return get(((ContextWrapper) context).getBaseContext());
+      }
     }
 
-    private RequestManager getApplicationManager(Context context) {
-        // Either an application context or we're on a background thread.
-        if (applicationManager == null) {
-            synchronized (this) {
-                if (applicationManager == null) {
-                    // Normally pause/resume is taken care of by the fragment we add to the fragment or activity.
-                    // However, in this case since the manager attached to the application will not receive lifecycle
-                    // events, we must force the manager to start resumed using ApplicationLifecycle.
-                    applicationManager = new RequestManager(context.getApplicationContext(),
-                            new ApplicationLifecycle());
-                }
-            }
-        }
+    return getApplicationManager(context);
+  }
 
-        return applicationManager;
+  public RequestManager get(FragmentActivity activity) {
+    if (Util.isOnBackgroundThread()) {
+      return get(activity.getApplicationContext());
+    } else {
+      assertNotDestroyed(activity);
+      FragmentManager fm = activity.getSupportFragmentManager();
+      return supportFragmentGet(activity, fm, null);
     }
+  }
 
-    public RequestManager get(Context context) {
-        if (context == null) {
-            throw new IllegalArgumentException("You cannot start a load on a null Context");
-        } else if (Util.isOnMainThread() && !(context instanceof Application)) {
-            if (context instanceof FragmentActivity) {
-                return get((FragmentActivity) context);
-            } else if (context instanceof Activity) {
-                return get((Activity) context);
-            } else if (context instanceof ContextWrapper) {
-                return get(((ContextWrapper) context).getBaseContext());
-            }
-        }
-
-        return getApplicationManager(context);
+  public RequestManager get(Fragment fragment) {
+    if (fragment.getActivity() == null) {
+      throw new IllegalArgumentException(
+          "You cannot start a load on a fragment before it is attached");
     }
-
-    public RequestManager get(FragmentActivity activity) {
-        if (Util.isOnBackgroundThread()) {
-            return get(activity.getApplicationContext());
-        } else {
-            assertNotDestroyed(activity);
-            FragmentManager fm = activity.getSupportFragmentManager();
-            return supportFragmentGet(activity, fm);
-        }
+    if (Util.isOnBackgroundThread()) {
+      return get(fragment.getActivity().getApplicationContext());
+    } else {
+      FragmentManager fm = fragment.getChildFragmentManager();
+      return supportFragmentGet(fragment.getActivity(), fm, fragment);
     }
-
-    public RequestManager get(Fragment fragment) {
-        if (fragment.getActivity() == null) {
-            throw new IllegalArgumentException("You cannot start a load on a fragment before it is attached");
-        }
-        if (Util.isOnBackgroundThread()) {
-            return get(fragment.getActivity().getApplicationContext());
-        } else {
-            if (fragment.isDetached()) {
-                throw new IllegalArgumentException("You cannot start a load on a detached fragment");
-            }
-            FragmentManager fm = fragment.getChildFragmentManager();
-            return supportFragmentGet(fragment.getActivity(), fm);
-        }
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  public RequestManager get(Activity activity) {
+    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+      return get(activity.getApplicationContext());
+    } else {
+      assertNotDestroyed(activity);
+      android.app.FragmentManager fm = activity.getFragmentManager();
+      return fragmentGet(activity, fm, null);
     }
+  }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public RequestManager get(Activity activity) {
-        if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
-            return get(activity.getApplicationContext());
-        } else {
-            assertNotDestroyed(activity);
-            android.app.FragmentManager fm = activity.getFragmentManager();
-            return fragmentGet(activity, fm);
-        }
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  private static void assertNotDestroyed(Activity activity) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
+      throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
     }
+  }
 
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    private static void assertNotDestroyed(Activity activity) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
-            throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
-        }
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  public RequestManager get(android.app.Fragment fragment) {
+    if (fragment.getActivity() == null) {
+      throw new IllegalArgumentException(
+          "You cannot start a load on a fragment before it is attached");
     }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    public RequestManager get(android.app.Fragment fragment) {
-        if (fragment.getActivity() == null) {
-            throw new IllegalArgumentException("You cannot start a load on a fragment before it is attached");
-        }
-        if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
-            return get(fragment.getActivity().getApplicationContext());
-        } else {
-            assertNotDetached(fragment);
-            android.app.FragmentManager fm = fragment.getChildFragmentManager();
-            return fragmentGet(fragment.getActivity(), fm);
-        }
+    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
+      return get(fragment.getActivity().getApplicationContext());
+    } else {
+      android.app.FragmentManager fm = fragment.getChildFragmentManager();
+      return fragmentGet(fragment.getActivity(), fm, fragment);
     }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
-    private static void assertNotDetached(android.app.Fragment fragment) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2 && fragment.isDetached()) {
-            throw new IllegalArgumentException("You cannot start a load on a detached fragment");
-        }
+  }
+
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  RequestManagerFragment getRequestManagerFragment(
+      final android.app.FragmentManager fm, android.app.Fragment parentHint) {
+    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
+    if (current == null) {
+      current = pendingRequestManagerFragments.get(fm);
+      if (current == null) {
+        current = new RequestManagerFragment();
+        current.setParentFragmentHint(parentHint);
+        pendingRequestManagerFragments.put(fm, current);
+        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
+        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
+      }
     }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    RequestManager fragmentGet(Context context, final android.app.FragmentManager fm) {
-        RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(TAG);
-        if (current == null) {
-            current = pendingRequestManagerFragments.get(fm);
-            if (current == null) {
-                current = new RequestManagerFragment();
-                pendingRequestManagerFragments.put(fm, current);
-                fm.beginTransaction().add(current, TAG).commitAllowingStateLoss();
-                handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
-            }
-        }
-        RequestManager requestManager = current.getRequestManager();
-        if (requestManager == null) {
-            requestManager = new RequestManager(context, current.getLifecycle());
-            current.setRequestManager(requestManager);
-        }
-        return requestManager;
-
+    return current;
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
+      android.app.Fragment parentHint) {
+    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
+    RequestManager requestManager = current.getRequestManager();
+    if (requestManager == null) {
+      requestManager =
+          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+      current.setRequestManager(requestManager);
     }
-
-    RequestManager supportFragmentGet(Context context, final FragmentManager fm) {
-        SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(TAG);
-        if (current == null) {
-            current = pendingSupportRequestManagerFragments.get(fm);
-            if (current == null) {
-                current = new SupportRequestManagerFragment();
-                pendingSupportRequestManagerFragments.put(fm, current);
-                fm.beginTransaction().add(current, TAG).commitAllowingStateLoss();
-                handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
-            }
-        }
-        RequestManager requestManager = current.getRequestManager();
-        if (requestManager == null) {
-            requestManager = new RequestManager(context, current.getLifecycle());
-            current.setRequestManager(requestManager);
-        }
-        return requestManager;
+    return requestManager;
+  }
+
+  SupportRequestManagerFragment getSupportRequestManagerFragment(
+      final FragmentManager fm, Fragment parentHint) {
+    SupportRequestManagerFragment current =
+        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
+    if (current == null) {
+      current = pendingSupportRequestManagerFragments.get(fm);
+      if (current == null) {
+        current = new SupportRequestManagerFragment();
+        current.setParentFragmentHint(parentHint);
+        pendingSupportRequestManagerFragments.put(fm, current);
+        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
+        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
+      }
     }
-
-    @Override
-    public boolean handleMessage(Message message) {
-        boolean handled = true;
-        Object removed = null;
-        Object key = null;
-        switch (message.what) {
-            case ID_REMOVE_FRAGMENT_MANAGER:
-                android.app.FragmentManager fm = (android.app.FragmentManager) message.obj;
-                key = fm;
-                removed = pendingRequestManagerFragments.remove(fm);
-                break;
-            case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:
-                FragmentManager supportFm = (FragmentManager) message.obj;
-                key = supportFm;
-                removed = pendingSupportRequestManagerFragments.remove(supportFm);
-                break;
-            default:
-                handled = false;
-        }
-        if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
-            Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
-        }
-        return handled;
+    return current;
+  }
+
+  RequestManager supportFragmentGet(Context context, FragmentManager fm, Fragment parentHint) {
+    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
+    RequestManager requestManager = current.getRequestManager();
+    if (requestManager == null) {
+      requestManager =
+          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+      current.setRequestManager(requestManager);
+    }
+    return requestManager;
+  }
+
+  @Override
+  public boolean handleMessage(Message message) {
+    boolean handled = true;
+    Object removed = null;
+    Object key = null;
+    switch (message.what) {
+      case ID_REMOVE_FRAGMENT_MANAGER:
+        android.app.FragmentManager fm = (android.app.FragmentManager) message.obj;
+        key = fm;
+        removed = pendingRequestManagerFragments.remove(fm);
+        break;
+      case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:
+        FragmentManager supportFm = (FragmentManager) message.obj;
+        key = supportFm;
+        removed = pendingSupportRequestManagerFragments.remove(supportFm);
+        break;
+      default:
+        handled = false;
+    }
+    if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
+      Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
     }
+    return handled;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
new file mode 100644
index 000000000..87f982947
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.manager;
+
+import com.bumptech.glide.RequestManager;
+
+import java.util.Set;
+
+/**
+ * Provides access to the relatives of a RequestManager based on the current context. The context
+ * hierarchy is provided by nesting in Activity and Fragments; the application context does not
+ * provide access to any other RequestManagers hierarchically.
+ */
+public interface RequestManagerTreeNode {
+  /**
+   * Returns all descendant {@link RequestManager}s relative to the context of the current
+   * {@link RequestManager}.
+   */
+  Set<RequestManager> getDescendants();
+}
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 1fed826d5..48d5882a7 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -1,98 +1,132 @@
 package com.bumptech.glide.manager;
 
 import com.bumptech.glide.request.Request;
+import com.bumptech.glide.util.Util;
 
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
 import java.util.Set;
 import java.util.WeakHashMap;
 
 /**
  * A class for tracking, canceling, and restarting in progress, completed, and failed requests.
+ *
+ * <p>This class is not thread safe and must be accessed on the main thread.
  */
 public class RequestTracker {
-    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag.
-    // However, a user can always pass in a different type of target which may end up not being strongly referenced even
-    // though the user still would like the request to finish. Weak references are therefore only really functional in
-    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user
-    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager
-    // where holding strong references would steadily leak bitmaps and/or views.
-    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());
-    private boolean isPaused;
+  // Most requests will be for views and will therefore be held strongly (and safely) by the view
+  // via the tag. However, a user can always pass in a different type of target which may end up not
+  // being strongly referenced even though the user still would like the request to finish. Weak
+  // references are therefore only really functional in this context for view targets. Despite the
+  // side affects, WeakReferences are still essentially required. A user can always make repeated
+  // requests into targets other than views, or use an activity manager in a fragment pager where
+  // holding strong references would steadily leak bitmaps and/or views.
+  private final Set<Request> requests =
+      Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());
+  // A set of requests that have not completed and are queued to be run again. We use this list to
+  // maintain hard references to these requests to ensure that they are not garbage collected
+  // before
+  // they start running or while they are paused. See #346.
+  @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
+  private final List<Request> pendingRequests = new ArrayList<>();
+  private boolean isPaused;
 
-    /**
-     * Starts tracking the given request.
-     */
-    public void runRequest(Request request) {
-        requests.add(request);
-        if (!isPaused) {
-            request.begin();
-        }
+  /**
+   * Starts tracking the given request.
+   */
+  public void runRequest(Request request) {
+    requests.add(request);
+    if (!isPaused) {
+      request.begin();
+    } else {
+      pendingRequests.add(request);
     }
+  }
 
-    // Exposed for testing.
-    void addRequest(Request request) {
-        requests.add(request);
-    }
+  // Visible for testing.
+  void addRequest(Request request) {
+    requests.add(request);
+  }
 
-    /**
-     * Stops tracking the given request.
-     */
-    public void removeRequest(Request request) {
-        requests.remove(request);
+  /**
+   * Stops tracking the given request, clears, and recycles it, and returns {@code true} if the
+   * request was removed or {@code false} if the request was not found.
+   */
+  public boolean clearRemoveAndRecycle(Request request) {
+    boolean isOwnedByUs =
+        request != null && (requests.remove(request) || pendingRequests.remove(request));
+    if (isOwnedByUs) {
+      request.clear();
+      request.recycle();
     }
+    return isOwnedByUs;
+  }
 
-    /**
-     * Returns {@code true} if requests are currently paused, and {@code false} otherwise.
-     */
-    public boolean isPaused() {
-        return isPaused;
-    }
+  /**
+   * Returns {@code true} if requests are currently paused, and {@code false} otherwise.
+   */
+  public boolean isPaused() {
+    return isPaused;
+  }
 
-    /**
-     * Stops any in progress requests.
-     */
-    public void pauseRequests() {
-        isPaused = true;
-        for (Request request : requests) {
-            if (request.isRunning()) {
-                request.pause();
-            }
-        }
+  /**
+   * Stops any in progress requests.
+   */
+  public void pauseRequests() {
+    isPaused = true;
+    for (Request request : Util.getSnapshot(requests)) {
+      if (request.isRunning()) {
+        request.pause();
+        pendingRequests.add(request);
+      }
     }
+  }
 
-    /**
-     * Starts any not yet completed or failed requests.
-     */
-    public void resumeRequests() {
-        isPaused = false;
-        for (Request request : requests) {
-            if (!request.isComplete() && !request.isCancelled() && !request.isRunning()) {
-                request.begin();
-            }
-        }
+  /**
+   * Starts any not yet completed or failed requests.
+   */
+  public void resumeRequests() {
+    isPaused = false;
+    for (Request request : Util.getSnapshot(requests)) {
+      if (!request.isComplete() && !request.isCancelled() && !request.isRunning()) {
+        request.begin();
+      }
     }
+    pendingRequests.clear();
+  }
 
-    /**
-     * Cancels all requests and clears their resources.
-     */
-    public void clearRequests() {
-        for (Request request : requests) {
-            request.clear();
-        }
+  /**
+   * Cancels all requests and clears their resources.
+   *
+   * <p>After this call requests cannot be restarted.
+   */
+  public void clearRequests() {
+    for (Request request : Util.getSnapshot(requests)) {
+      clearRemoveAndRecycle(request);
     }
+    pendingRequests.clear();
+  }
 
-    /**
-     * Restarts failed requests and cancels and restarts in progress requests.
-     */
-    public void restartRequests() {
-        for (Request request : requests) {
-            if (!request.isComplete() && !request.isCancelled()) {
-                // Ensure the request will be restarted in onResume.
-                request.pause();
-                if (!isPaused) {
-                    request.begin();
-                }
-            }
+  /**
+   * Restarts failed requests and cancels and restarts in progress requests.
+   */
+  public void restartRequests() {
+    for (Request request : Util.getSnapshot(requests)) {
+      if (!request.isComplete() && !request.isCancelled()) {
+        // Ensure the request will be restarted in onResume.
+        request.pause();
+        if (!isPaused) {
+          request.begin();
+        } else {
+          pendingRequests.add(request);
         }
+      }
     }
+  }
+
+  @Override
+  public String toString() {
+    return super.toString() + "{numRequests=" + requests.size() + ", isPaused=" + isPaused + "}";
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index b5e73b6d0..6fa4b4c41 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -1,68 +1,225 @@
 package com.bumptech.glide.manager;
 
 import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.util.Log;
 
 import com.bumptech.glide.RequestManager;
 
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
 /**
- * A view-less {@link android.support.v4.app.Fragment} used to safely store an
- * {@link com.bumptech.glide.RequestManager} that can be used to start, stop and manage Glide requests started for
- * targets within the fragment or activity this fragment is a child of.
+ * A view-less {@link android.support.v4.app.Fragment} used to safely store an {@link
+ * com.bumptech.glide.RequestManager} that can be used to start, stop and manage Glide requests
+ * started for targets within the fragment or activity this fragment is a child of.
  *
  * @see com.bumptech.glide.manager.RequestManagerFragment
  * @see com.bumptech.glide.manager.RequestManagerRetriever
  * @see com.bumptech.glide.RequestManager
  */
 public class SupportRequestManagerFragment extends Fragment {
-    private RequestManager requestManager;
-    private final ActivityFragmentLifecycle lifecycle;
+  private static final String TAG = "SupportRMFragment";
+  private final ActivityFragmentLifecycle lifecycle;
+  private final RequestManagerTreeNode requestManagerTreeNode =
+      new SupportFragmentRequestManagerTreeNode();
+  private final HashSet<SupportRequestManagerFragment> childRequestManagerFragments =
+      new HashSet<>();
+
+  @Nullable private SupportRequestManagerFragment rootRequestManagerFragment;
+  @Nullable private RequestManager requestManager;
+  @Nullable private Fragment parentFragmentHint;
+
+  public SupportRequestManagerFragment() {
+    this(new ActivityFragmentLifecycle());
+  }
+
+  // For testing only.
+  @SuppressLint("ValidFragment")
+  public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+    this.lifecycle = lifecycle;
+  }
+
+  /**
+   * Sets the current {@link com.bumptech.glide.RequestManager}.
+   *
+   * @param requestManager The manager to put.
+   */
+  public void setRequestManager(RequestManager requestManager) {
+    this.requestManager = requestManager;
+  }
+
+  ActivityFragmentLifecycle getLifecycle() {
+    return lifecycle;
+  }
+
+  /**
+   * Returns the current {@link com.bumptech.glide.RequestManager} or null if none is put.
+   */
+  @Nullable
+  public RequestManager getRequestManager() {
+    return requestManager;
+  }
+
+  /**
+   * Returns the {@link RequestManagerTreeNode} that provides tree traversal methods relative
+   * to the
+   * associated {@link RequestManager}.
+   */
+  public RequestManagerTreeNode getRequestManagerTreeNode() {
+    return requestManagerTreeNode;
+  }
+
+  private void addChildRequestManagerFragment(SupportRequestManagerFragment child) {
+    childRequestManagerFragments.add(child);
+  }
+
+  private void removeChildRequestManagerFragment(SupportRequestManagerFragment child) {
+    childRequestManagerFragments.remove(child);
+  }
 
-    public SupportRequestManagerFragment() {
-        this(new ActivityFragmentLifecycle());
+  /**
+   * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
+   * our parent is the fragment that we are annotating).
+   */
+  public Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
+    if (rootRequestManagerFragment == null) {
+      return Collections.emptySet();
+    } else if (rootRequestManagerFragment == this) {
+      return Collections.unmodifiableSet(childRequestManagerFragments);
+    } else {
+      HashSet<SupportRequestManagerFragment> descendants = new HashSet<>();
+      for (SupportRequestManagerFragment fragment : rootRequestManagerFragment
+          .getDescendantRequestManagerFragments()) {
+        if (isDescendant(fragment.getParentFragmentUsingHint())) {
+          descendants.add(fragment);
+        }
+      }
+      return Collections.unmodifiableSet(descendants);
     }
+  }
 
-    // For testing only.
-    @SuppressLint("ValidFragment")
-    public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
-        this.lifecycle = lifecycle;
+  /**
+   * Sets a hint for which fragment is our parent which allows the fragment to return correct
+   * information about its parents before pending fragment transactions have been executed.
+   */
+  void setParentFragmentHint(Fragment parentFragmentHint) {
+    this.parentFragmentHint = parentFragmentHint;
+    if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
+      registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
+  }
 
-    /**
-     * Sets the current {@link com.bumptech.glide.RequestManager}.
-     *
-     * @param requestManager The manager to set.
-     */
-    public void setRequestManager(RequestManager requestManager) {
-        this.requestManager = requestManager;
+  private Fragment getParentFragmentUsingHint() {
+    Fragment fragment = getParentFragment();
+    return fragment != null ? fragment : parentFragmentHint;
+  }
+
+  /**
+   * Returns true if the fragment is a descendant of our parent.
+   */
+  private boolean isDescendant(Fragment fragment) {
+    Fragment root = this.getParentFragmentUsingHint();
+    while (fragment.getParentFragment() != null) {
+      if (fragment.getParentFragment() == root) {
+        return true;
+      }
+      fragment = fragment.getParentFragment();
     }
+    return false;
+  }
 
-    ActivityFragmentLifecycle getLifecycle() {
-        return lifecycle;
+  private void registerFragmentWithRoot(FragmentActivity activity) {
+    unregisterFragmentWithRoot();
+    rootRequestManagerFragment = RequestManagerRetriever.get()
+        .getSupportRequestManagerFragment(activity.getSupportFragmentManager(), null);
+    if (rootRequestManagerFragment != this) {
+      rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
+  }
 
-    /**
-     * Returns the current {@link com.bumptech.glide.RequestManager} or null if none is set.
-     */
-    public RequestManager getRequestManager() {
-        return requestManager;
+  private void unregisterFragmentWithRoot() {
+    if (rootRequestManagerFragment != null) {
+      rootRequestManagerFragment.removeChildRequestManagerFragment(this);
+      rootRequestManagerFragment = null;
     }
+  }
 
-    @Override
-    public void onStart() {
-        super.onStart();
-        lifecycle.onStart();
+  @Override
+  public void onAttach(Activity activity) {
+    super.onAttach(activity);
+    try {
+      registerFragmentWithRoot(getActivity());
+    } catch (IllegalArgumentException e) {
+      // OnAttach can be called after the activity is destroyed, see #497.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to register fragment with root", e);
+      }
     }
+  }
+
+  @Override
+  public void onDetach() {
+    super.onDetach();
+    parentFragmentHint = null;
+    unregisterFragmentWithRoot();
+  }
+
+  @Override
+  public void onStart() {
+    super.onStart();
+    lifecycle.onStart();
+  }
+
+  @Override
+  public void onStop() {
+    super.onStop();
+    lifecycle.onStop();
+  }
+
+  @Override
+  public void onDestroy() {
+    super.onDestroy();
+    lifecycle.onDestroy();
+    unregisterFragmentWithRoot();
+  }
+
+  @Override
+  public void onLowMemory() {
+    super.onLowMemory();
+    // If an activity is re-created, onLowMemory may be called before a manager is ever put.
+    // See #329.
+    if (requestManager != null) {
+      requestManager.onLowMemory();
+    }
+  }
+
+  @Override
+  public String toString() {
+    return super.toString() + "{parent=" + getParentFragmentUsingHint() + "}";
+  }
 
+  private class SupportFragmentRequestManagerTreeNode implements RequestManagerTreeNode {
     @Override
-    public void onStop() {
-        super.onStop();
-        lifecycle.onStop();
+    public Set<RequestManager> getDescendants() {
+      Set<SupportRequestManagerFragment> descendantFragments =
+          getDescendantRequestManagerFragments();
+      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      for (SupportRequestManagerFragment fragment : descendantFragments) {
+        if (fragment.getRequestManager() != null) {
+          descendants.add(fragment.getRequestManager());
+        }
+      }
+      return descendants;
     }
 
     @Override
-    public void onDestroy() {
-        super.onDestroy();
-        lifecycle.onDestroy();
+    public String toString() {
+      return super.toString() + "{fragment=" + SupportRequestManagerFragment.this + "}";
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
new file mode 100644
index 000000000..6c83dd896
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.manager;
+
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Util;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.WeakHashMap;
+
+/**
+ * Holds the set of {@link Target}s currently active for a
+ * {@link com.bumptech.glide.RequestManager} and forwards on lifecycle events.
+ */
+public final class TargetTracker implements LifecycleListener {
+  private final Set<Target<?>> targets =
+      Collections.newSetFromMap(new WeakHashMap<Target<?>, Boolean>());
+
+  public void track(Target<?> target) {
+    targets.add(target);
+  }
+
+  public void untrack(Target<?> target) {
+    targets.remove(target);
+  }
+
+  @Override
+  public void onStart() {
+    for (Target<?> target : Util.getSnapshot(targets)) {
+      target.onStart();
+    }
+  }
+
+  @Override
+  public void onStop() {
+    for (Target<?> target : Util.getSnapshot(targets)) {
+      target.onStop();
+    }
+  }
+
+  @Override
+  public void onDestroy() {
+    for (Target<?> target : Util.getSnapshot(targets)) {
+      target.onDestroy();
+    }
+  }
+
+  public List<Target<?>> getAll() {
+    return new ArrayList<>(targets);
+  }
+
+  public void clear() {
+    targets.clear();
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
new file mode 100644
index 000000000..061856a6c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -0,0 +1,80 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+
+/**
+ * An interface allowing lazy configuration of Glide including setting options using
+ * {@link com.bumptech.glide.GlideBuilder} and registering
+ * {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders}.
+ *
+ * <p> To use this interface: <ol> <li> Implement the GlideModule interface in a class with public
+ * visibility, calling
+ * {@link Registry#prepend(Class, Class, com.bumptech.glide.load.ResourceDecoder)} for each
+ * {@link com.bumptech.glide.load.model.ModelLoader} you'd like to register:
+ * <pre>
+ *                  <code>
+ *                      public class FlickrGlideModule implements GlideModule {
+ *                          {@literal @}Override
+ *                          public void applyOptions(Context context, GlideBuilder builder) {
+ *                              buidler.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
+ *                          }
+ *
+ *                          {@literal @}Override
+ *                          public void registerComponents(Context context, Glide glide) {
+ *                              glide.register(Model.class, Data.class, new MyModelLoader());
+ *                          }
+ *                      }
+ *                  </code>
+ *             </pre>
+ * </li> <li> Add your implementation to your list of keeps in your proguard.cfg file:
+ * <pre>
+ *                  {@code
+ *                      -keepnames class * com.bumptech.glide.samples.flickr.FlickrGlideModule
+ *                  }
+ *              </pre>
+ * </li> <li> Add a metadata tag to your AndroidManifest.xml with your GlideModule implementation's
+ * fully qualified classname as the key, and {@code GlideModule} as the value:
+ * <pre>
+ *                 {@code
+ *                      <meta-data
+ *                          android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
+ *                          android:value="GlideModule" />
+ *                 }
+ *             </pre>
+ * </li> </ol> </p>
+ *
+ * <p> All implementations must be publicly visible and contain only an empty constructor so they
+ * can be instantiated via reflection when Glide is lazily initialized. </p>
+ *
+ * <p> There is no defined order in which modules are called, so projects should be careful to avoid
+ * applying conflicting settings in different modules. If an application depends on libraries that
+ * have conflicting modules, the application should consider avoiding the library modules and
+ * instead providing their required dependencies in a single application module. </p>
+ */
+public interface GlideModule {
+
+  /**
+   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
+   * singleton is created.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context An Application {@link android.content.Context}.
+   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
+   */
+  void applyOptions(Context context, GlideBuilder builder);
+
+  /**
+   * Lazily register components immediately after the Glide singleton is created but before any
+   * requests can be started.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context  An Application {@link android.content.Context}.
+   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
+   */
+  void registerComponents(Context context, Registry registry);
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
new file mode 100644
index 000000000..7d9a755e5
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -0,0 +1,62 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
+ */
+public final class ManifestParser {
+  private static final String GLIDE_MODULE_VALUE = "GlideModule";
+
+  private final Context context;
+
+  public ManifestParser(Context context) {
+    this.context = context;
+  }
+
+  public List<GlideModule> parse() {
+    List<GlideModule> modules = new ArrayList<>();
+    try {
+      ApplicationInfo appInfo = context.getPackageManager()
+          .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
+      if (appInfo.metaData != null) {
+        for (String key : appInfo.metaData.keySet()) {
+          if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
+            modules.add(parseModule(key));
+          }
+        }
+      }
+    } catch (PackageManager.NameNotFoundException e) {
+      throw new RuntimeException("Unable to find metadata to parse GlideModules", e);
+    }
+
+    return modules;
+  }
+
+  private static GlideModule parseModule(String className) {
+    Class<?> clazz;
+    try {
+      clazz = Class.forName(className);
+    } catch (ClassNotFoundException e) {
+      throw new IllegalArgumentException("Unable to find GlideModule implementation", e);
+    }
+
+    Object module;
+    try {
+      module = clazz.newInstance();
+    } catch (InstantiationException | IllegalAccessException e) {
+      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
+          e);
+    }
+
+    if (!(module instanceof GlideModule)) {
+      throw new RuntimeException("Expected instanceof GlideModule, but found: " + module);
+    }
+    return (GlideModule) module;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/ChildLoadProvider.java b/library/src/main/java/com/bumptech/glide/provider/ChildLoadProvider.java
deleted file mode 100644
index 5478eab21..000000000
--- a/library/src/main/java/com/bumptech/glide/provider/ChildLoadProvider.java
+++ /dev/null
@@ -1,154 +0,0 @@
-package com.bumptech.glide.provider;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-
-import java.io.File;
-
-/**
- * A {@link com.bumptech.glide.provider.LoadProvider} that returns classes preferentially from those set on it but
- * that also defaults to a wrapped {@link com.bumptech.glide.provider.LoadProvider} when a particular class is not set.
- *
- * @param <A> The type of the model the resource will be loaded from.
- * @param <T> The type of the data that will be retrieved for the model.
- * @param <Z> The type of the resource that will be decoded from the data.
- * @param <R> The type of the resource that will be transcoded from the decoded resource.
- */
-public class ChildLoadProvider<A, T, Z, R> implements LoadProvider<A, T, Z, R>, Cloneable {
-    private final LoadProvider<A, T, Z, R> parent;
-
-    private ResourceDecoder<File, Z> cacheDecoder;
-    private ResourceDecoder<T, Z> sourceDecoder;
-    private ResourceEncoder<Z> encoder;
-    private ResourceTranscoder<Z, R> transcoder;
-    private Encoder<T> sourceEncoder;
-
-    public ChildLoadProvider(LoadProvider<A, T, Z, R> parent) {
-        this.parent = parent;
-    }
-
-    @Override
-    public ModelLoader<A, T> getModelLoader() {
-        return parent.getModelLoader();
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use for decoding the resource from the disk cache.
-     *
-     * @param cacheDecoder The decoder to use.
-     */
-    public void setCacheDecoder(ResourceDecoder<File, Z> cacheDecoder) {
-        this.cacheDecoder = cacheDecoder;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to decoding the resource from the original data.
-     *
-     * @param sourceDecoder The decoder to use.
-     */
-    public void setSourceDecoder(ResourceDecoder<T, Z> sourceDecoder) {
-        this.sourceDecoder = sourceDecoder;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.ResourceEncoder} to use to write the decoded and transformed resource to
-     * the disk cache.
-     *
-     * @param encoder The encoder to use.
-     */
-    public void setEncoder(ResourceEncoder<Z> encoder) {
-        this.encoder = encoder;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to use to transcode the decoded
-     * resource.
-     *
-     * @param transcoder The transcoder to use.
-     */
-    public void setTranscoder(ResourceTranscoder<Z, R> transcoder) {
-        this.transcoder = transcoder;
-    }
-
-    /**
-     * Sets the {@link com.bumptech.glide.load.Encoder} to use to write the original data to the disk cache.
-     *
-     * @param sourceEncoder The encoder to use.
-     */
-    public void setSourceEncoder(Encoder<T> sourceEncoder) {
-        this.sourceEncoder = sourceEncoder;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ResourceDecoder<File, Z> getCacheDecoder() {
-        if (cacheDecoder != null) {
-            return cacheDecoder;
-        } else {
-            return parent.getCacheDecoder();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ResourceDecoder<T, Z> getSourceDecoder() {
-        if (sourceDecoder != null) {
-            return sourceDecoder;
-        } else {
-            return parent.getSourceDecoder();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Encoder<T> getSourceEncoder() {
-        if (sourceEncoder != null) {
-            return sourceEncoder;
-        } else {
-            return parent.getSourceEncoder();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ResourceEncoder<Z> getEncoder() {
-        if (encoder != null) {
-            return encoder;
-        } else {
-            return parent.getEncoder();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ResourceTranscoder<Z, R> getTranscoder() {
-        if (transcoder != null) {
-            return transcoder;
-        } else {
-            return parent.getTranscoder();
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public ChildLoadProvider<A, T, Z, R> clone() {
-        try {
-            return (ChildLoadProvider<A, T, Z, R>) super.clone();
-        } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/provider/DataLoadProvider.java b/library/src/main/java/com/bumptech/glide/provider/DataLoadProvider.java
deleted file mode 100644
index 9a504c3b9..000000000
--- a/library/src/main/java/com/bumptech/glide/provider/DataLoadProvider.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.bumptech.glide.provider;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-
-import java.io.File;
-
-/**
- * A load provider that provides the necessary encoders and decoders to decode a specific type of resource from a
- * specific type of data.
- *
- * @param <T> The type of data the resource will be decoded from.
- * @param <Z> The type of resource that will be decoded.
- */
-public interface DataLoadProvider<T, Z> {
-
-    /**
-     * Returns the {@link com.bumptech.glide.load.ResourceDecoder} to use to decode the resource from the disk cache.
-     */
-    ResourceDecoder<File, Z> getCacheDecoder();
-
-    /**
-     * Returns the {@link com.bumptech.glide.load.ResourceDecoder} to use to decode the resource from the original data.
-     */
-    ResourceDecoder<T, Z> getSourceDecoder();
-
-    /**
-     * Returns the {@link com.bumptech.glide.load.Encoder} to use to write the original data to the disk cache.
-     */
-    Encoder<T> getSourceEncoder();
-
-    /**
-     * Returns the {@link com.bumptech.glide.load.ResourceEncoder} to use to write the decoded and transformed resource
-     * to the disk cache.
-     */
-    ResourceEncoder<Z> getEncoder();
-}
diff --git a/library/src/main/java/com/bumptech/glide/provider/DataLoadProviderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/DataLoadProviderRegistry.java
deleted file mode 100644
index 7c50577ba..000000000
--- a/library/src/main/java/com/bumptech/glide/provider/DataLoadProviderRegistry.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.bumptech.glide.provider;
-
-import com.bumptech.glide.util.MultiClassKey;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * A class that allows {@link com.bumptech.glide.provider.DataLoadProvider}s to be registered and retrieved by the
- * data and resource classes they provide encoders and decoders for.
- */
-public class DataLoadProviderRegistry {
-    private static final MultiClassKey GET_KEY = new MultiClassKey();
-
-    private final Map<MultiClassKey, DataLoadProvider<?, ?>> providers =
-            new HashMap<MultiClassKey, DataLoadProvider<?, ?>>();
-
-    /**
-     * Registers the given {@link com.bumptech.glide.provider.DataLoadProvider} using the given classes so it can later
-     * be retrieved using the given classes.
-     *
-     * @param dataClass The class of the data that the provider provides encoders and decoders for.
-     * @param resourceClass The class of the resource that the provider provides encoders and decoders for.
-     * @param provider The provider.
-     * @param <T> The type of the data that the provider provides encoders and decoders for.
-     * @param <Z> The type of the resource that the provider provides encoders and decoders for.
-     */
-    public <T, Z> void register(Class<T> dataClass, Class<Z> resourceClass, DataLoadProvider<T, Z> provider) {
-        //TODO: maybe something like DataLoadProvider<? super T, ? extends Z> may work here
-        providers.put(new MultiClassKey(dataClass, resourceClass), provider);
-    }
-
-    /**
-     * Returns the currently registered {@link com.bumptech.glide.provider.DataLoadProvider} for the given classes.
-     *
-     * @param dataClass The class of the data that the provider provides encoders and decoders for.
-     * @param resourceClass The class of the resource that the provider provides encoders and decoders for.
-     * @param <T> The type of the data that the provider provides encoders and decoders for.
-     * @param <Z> The type of the resource that the provider provides encoders and decoders for.
-     */
-    @SuppressWarnings("unchecked")
-    public <T, Z> DataLoadProvider<T, Z> get(Class<T> dataClass, Class<Z> resourceClass) {
-        DataLoadProvider<?, ?> result;
-        synchronized (GET_KEY) {
-            GET_KEY.set(dataClass, resourceClass);
-            result = providers.get(GET_KEY);
-        }
-        if (result == null) {
-            result = EmptyDataLoadProvider.get();
-        }
-        return (DataLoadProvider<T, Z>) result;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/provider/EmptyDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/provider/EmptyDataLoadProvider.java
deleted file mode 100644
index 7e40d9d0c..000000000
--- a/library/src/main/java/com/bumptech/glide/provider/EmptyDataLoadProvider.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.provider;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-
-import java.io.File;
-
-/**
- * A {@link com.bumptech.glide.provider.DataLoadProvider} that returns {@code null} for every class.
- *
- * @param <T> unused data type.
- * @param <Z> unused resource type.
- */
-public class EmptyDataLoadProvider<T, Z> implements DataLoadProvider<T, Z> {
-    private static final DataLoadProvider<?, ?> EMPTY_DATA_LOAD_PROVIDER = new EmptyDataLoadProvider<Object, Object>();
-
-    @SuppressWarnings("unchecked")
-    public static <T, Z> DataLoadProvider<T, Z> get() {
-        return (DataLoadProvider<T, Z>) EMPTY_DATA_LOAD_PROVIDER;
-    }
-
-    @Override
-    public ResourceDecoder<File, Z> getCacheDecoder() {
-        return null;
-    }
-
-    @Override
-    public ResourceDecoder<T, Z> getSourceDecoder() {
-        return null;
-    }
-
-    @Override
-    public Encoder<T> getSourceEncoder() {
-        return null;
-    }
-
-    @Override
-    public ResourceEncoder<Z> getEncoder() {
-        return null;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
new file mode 100644
index 000000000..915bd0024
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -0,0 +1,45 @@
+package com.bumptech.glide.provider;
+
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.load.Encoder;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains an unordered list of {@link Encoder}s capable of encoding arbitrary data types.
+ */
+public class EncoderRegistry {
+  // TODO: This registry should probably contain a put, rather than a list.
+  private final List<Entry<?>> encoders = new ArrayList<>();
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  public synchronized <T> Encoder<T> getEncoder(Class<T> dataClass) {
+    for (Entry<?> entry : encoders) {
+      if (entry.handles(dataClass)) {
+        return (Encoder<T>) entry.encoder;
+      }
+    }
+    return null;
+  }
+
+  public synchronized <T> void add(Class<T> dataClass, Encoder<T> encoder) {
+    encoders.add(new Entry<>(dataClass, encoder));
+  }
+
+  private static final class Entry<T> {
+    private final Class<T> dataClass;
+    private final Encoder<T> encoder;
+
+    public Entry(Class<T> dataClass, Encoder<T> encoder) {
+      this.dataClass = dataClass;
+      this.encoder = encoder;
+    }
+
+    public boolean handles(Class<?> dataClass) {
+      return this.dataClass.isAssignableFrom(dataClass);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/FixedLoadProvider.java b/library/src/main/java/com/bumptech/glide/provider/FixedLoadProvider.java
deleted file mode 100644
index 7f50c9e44..000000000
--- a/library/src/main/java/com/bumptech/glide/provider/FixedLoadProvider.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package com.bumptech.glide.provider;
-
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-
-import java.io.File;
-
-/**
- * A {@link com.bumptech.glide.provider.LoadProvider} that sets the classes it provides using non null arguments in its
- * constructor.
- *
- * @param <A> The type of the model the resource will be loaded from.
- * @param <T> The type of the data that will be retrieved for the model.
- * @param <Z> The type of the resource that will be decoded from the data.
- * @param <R> The type of the resource that will be transcoded from the decoded resource.
- */
-public class FixedLoadProvider<A, T, Z, R> implements LoadProvider<A, T, Z, R>  {
-    private final ModelLoader<A, T> modelLoader;
-    private final ResourceTranscoder<Z, R> transcoder;
-    private final DataLoadProvider<T, Z> dataLoadProvider;
-
-    public FixedLoadProvider(ModelLoader<A, T> modelLoader, ResourceTranscoder<Z, R> transcoder,
-            DataLoadProvider<T, Z> dataLoadProvider) {
-        if (modelLoader == null) {
-            throw new NullPointerException("ModelLoader must not be null");
-        }
-        this.modelLoader = modelLoader;
-
-        if (transcoder == null) {
-            throw new NullPointerException("Transcoder must not be null");
-        }
-        this.transcoder = transcoder;
-
-        if (dataLoadProvider == null) {
-            throw new NullPointerException("DataLoadProvider must not be null");
-        }
-        this.dataLoadProvider = dataLoadProvider;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ModelLoader<A, T> getModelLoader() {
-        return modelLoader;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ResourceTranscoder<Z, R> getTranscoder() {
-        return transcoder;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ResourceDecoder<File, Z> getCacheDecoder() {
-        return dataLoadProvider.getCacheDecoder();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ResourceDecoder<T, Z> getSourceDecoder() {
-        return dataLoadProvider.getSourceDecoder();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Encoder<T> getSourceEncoder() {
-        return dataLoadProvider.getSourceEncoder();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ResourceEncoder<Z> getEncoder() {
-        return dataLoadProvider.getEncoder();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
new file mode 100644
index 000000000..f9c68b34a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
@@ -0,0 +1,59 @@
+package com.bumptech.glide.provider;
+
+import android.support.annotation.Nullable;
+import android.support.v4.util.ArrayMap;
+
+import com.bumptech.glide.load.engine.LoadPath;
+import com.bumptech.glide.util.MultiClassKey;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Maintains a cache of data, resource, and transcode classes to available
+ * {@link com.bumptech.glide.load.engine.LoadPath}s capable of decoding with the requested types.
+ */
+public class LoadPathCache {
+  private final ArrayMap<MultiClassKey, LoadPath<?, ?, ?>> cache = new ArrayMap<>();
+  private final AtomicReference<MultiClassKey> keyRef = new AtomicReference<>();
+
+  public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass) {
+    MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
+    boolean result;
+    synchronized (cache) {
+      result = cache.containsKey(key);
+    }
+    keyRef.set(key);
+    return result;
+  }
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> get(
+      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+    MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
+    LoadPath<?, ?, ?> result;
+    synchronized (cache) {
+       result = cache.get(key);
+    }
+    keyRef.set(key);
+
+    return (LoadPath<Data, TResource, Transcode>) result;
+  }
+
+  public void put(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass,
+      LoadPath<?, ?, ?> loadPath) {
+    synchronized (cache) {
+      cache.put(new MultiClassKey(dataClass, resourceClass, transcodeClass), loadPath);
+    }
+  }
+
+  private MultiClassKey getKey(Class<?> dataClass, Class<?> resourceClass,
+      Class<?> transcodeClass) {
+     MultiClassKey key = keyRef.getAndSet(null);
+    if (key == null) {
+      key = new MultiClassKey();
+    }
+    key.set(dataClass, resourceClass, transcodeClass);
+    return key;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadProvider.java b/library/src/main/java/com/bumptech/glide/provider/LoadProvider.java
deleted file mode 100644
index 694ab54ba..000000000
--- a/library/src/main/java/com/bumptech/glide/provider/LoadProvider.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.bumptech.glide.provider;
-
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-
-/**
- * An extension of {@link com.bumptech.glide.provider.DataLoadProvider} that also allows a
- * {@link com.bumptech.glide.load.model.ModelLoader} and a
- * {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to be retrieved.
- *
- * @param <A> The type of model.
- * @param <T> The type of data that will be decoded from.
- * @param <Z> The type of resource that will be decoded.
- * @param <R> The type of resource that the decoded resource will be transcoded to.
- */
-public interface LoadProvider<A, T, Z, R> extends DataLoadProvider<T, Z> {
-
-    /**
-     * Returns the {@link com.bumptech.glide.load.model.ModelLoader} to convert from the given model to a data type.
-     */
-    ModelLoader<A, T> getModelLoader();
-
-    /**
-     * Returns the {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to convert from the decoded
-     * and transformed resource into the transcoded resource.
-     */
-    ResourceTranscoder<Z, R> getTranscoder();
-}
diff --git a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
new file mode 100644
index 000000000..01e771d7d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
@@ -0,0 +1,48 @@
+package com.bumptech.glide.provider;
+
+import android.support.annotation.Nullable;
+import android.support.v4.util.ArrayMap;
+
+import com.bumptech.glide.util.MultiClassKey;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Maintains a cache of Model + Resource class to a set of registered resource classes that are
+ * subclasses of the resource class that can be decoded from the model class.
+ */
+public class ModelToResourceClassCache {
+  private final AtomicReference<MultiClassKey> resourceClassKeyRef = new AtomicReference<>();
+  private final ArrayMap<MultiClassKey, List<Class<?>>> registeredResourceClassCache =
+      new ArrayMap<>();
+
+  @Nullable
+  public List<Class<?>> get(Class<?> modelClass, Class<?> resourceClass) {
+    MultiClassKey key = resourceClassKeyRef.getAndSet(null);
+    if (key == null) {
+      key = new MultiClassKey(modelClass, resourceClass);
+    } else {
+      key.set(modelClass, resourceClass);
+    }
+    final List<Class<?>> result;
+    synchronized (registeredResourceClassCache) {
+       result = registeredResourceClassCache.get(key);
+    }
+    resourceClassKeyRef.set(key);
+    return result;
+  }
+
+  public void put(Class<?> modelClass, Class<?> resourceClass, List<Class<?>> resourceClasses) {
+    synchronized (registeredResourceClassCache) {
+      registeredResourceClassCache
+          .put(new MultiClassKey(modelClass, resourceClass), resourceClasses);
+    }
+  }
+
+  public void clear() {
+    synchronized (registeredResourceClassCache) {
+      registeredResourceClassCache.clear();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
new file mode 100644
index 000000000..b56158351
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.provider;
+
+import com.bumptech.glide.load.ResourceDecoder;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains an ordered list of {@link ResourceDecoder}s capable of decoding arbitrary data types
+ * into arbitrary resource types from highest priority decoders to loweset priority decoders.
+ */
+@SuppressWarnings("rawtypes")
+public class ResourceDecoderRegistry {
+  private final List<Entry<?, ?>> decoders = new ArrayList<>();
+
+  @SuppressWarnings("unchecked")
+  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(Class<T> dataClass,
+      Class<R> resourceClass) {
+    List<ResourceDecoder<T, R>> result = new ArrayList<>();
+    for (Entry<?, ?> entry : decoders) {
+      if (entry.handles(dataClass, resourceClass)) {
+        result.add((ResourceDecoder<T, R>) entry.decoder);
+      }
+    }
+    // TODO: cache result list.
+
+    return result;
+  }
+
+  @SuppressWarnings("unchecked")
+  public synchronized <T, R> List<Class<R>> getResourceClasses(Class<T> dataClass,
+      Class<R> resourceClass) {
+    List<Class<R>> result = new ArrayList<>();
+    for (Entry<?, ?> entry : decoders) {
+      if (entry.handles(dataClass, resourceClass)) {
+        result.add((Class<R>) entry.resourceClass);
+      }
+    }
+    return result;
+  }
+
+  public synchronized <T, R> void append(ResourceDecoder<T, R> decoder, Class<T> dataClass,
+      Class<R> resourceClass) {
+    decoders.add(new Entry<>(dataClass, resourceClass, decoder));
+  }
+
+  public synchronized <T, R> void prepend(ResourceDecoder<T, R> decoder, Class<T> dataClass,
+      Class<R> resourceClass) {
+    decoders.add(0, new Entry<>(dataClass, resourceClass, decoder));
+  }
+
+  private static class Entry<T, R> {
+    private final Class<T> dataClass;
+    private final Class<R> resourceClass;
+    private final ResourceDecoder<T, R> decoder;
+
+    public Entry(Class<T> dataClass, Class<R> resourceClass, ResourceDecoder<T, R> decoder) {
+      this.dataClass = dataClass;
+      this.resourceClass = resourceClass;
+      this.decoder = decoder;
+    }
+
+    public boolean handles(Class<?> dataClass, Class<?> resourceClass) {
+      return this.dataClass.isAssignableFrom(dataClass) && resourceClass
+          .isAssignableFrom(this.resourceClass);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
new file mode 100644
index 000000000..e5f5ef9c7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -0,0 +1,49 @@
+package com.bumptech.glide.provider;
+
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.load.ResourceEncoder;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains an unordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
+ * types.
+ */
+public class ResourceEncoderRegistry {
+  // TODO: this should probably be a put.
+  final List<Entry<?>> encoders = new ArrayList<>();
+
+  public synchronized <Z> void add(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+    encoders.add(new Entry<>(resourceClass, encoder));
+  }
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  public synchronized <Z> ResourceEncoder<Z> get(Class<Z> resourceClass) {
+    int size = encoders.size();
+    for (int i = 0; i < size; i++) {
+      Entry<?> entry = encoders.get(i);
+      if (entry.handles(resourceClass)) {
+        return (ResourceEncoder<Z>) entry.encoder;
+      }
+    }
+    // TODO: throw an exception here?
+    return null;
+  }
+
+  private static final class Entry<T> {
+    private final Class<T> resourceClass;
+    private final ResourceEncoder<T> encoder;
+
+    Entry(Class<T> resourceClass, ResourceEncoder<T> encoder) {
+      this.resourceClass = resourceClass;
+      this.encoder = encoder;
+    }
+
+    private boolean handles(Class<?> resourceClass) {
+      return this.resourceClass.isAssignableFrom(resourceClass);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
new file mode 100644
index 000000000..c23a56923
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -0,0 +1,916 @@
+package com.bumptech.glide.request;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.FitCenter;
+import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
+import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
+import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Contains and exposes a variety of non type specific options that can be applied to a load in
+ * Glide.
+ *
+ * <p> If {@link #lock()} has been called, this class will throw if any further mutations are
+ * attempted. To unlock, use {@link #clone()}. </p>
+ *
+ * @param <CHILD> The concrete and <em>final</em> subclass.
+ */
+public abstract class BaseRequestOptions<CHILD extends BaseRequestOptions<CHILD>>
+    implements Cloneable {
+  private static final int UNSET = -1;
+  private static final int SIZE_MULTIPLIER = 1 << 1;
+  private static final int DISK_CACHE_STRATEGY = 1 << 2;
+  private static final int PRIORITY = 1 << 3;
+  private static final int ERROR_PLACEHOLDER = 1 << 4;
+  private static final int ERROR_ID = 1 << 5;
+  private static final int PLACEHOLDER = 1 << 6;
+  private static final int PLACEHOLDER_ID = 1 << 7;
+  private static final int IS_CACHEABLE = 1 << 8;
+  private static final int OVERRIDE = 1 << 9;
+  private static final int SIGNATURE = 1 << 10;
+  private static final int TRANSFORMATION = 1 << 11;
+  private static final int RESOURCE_CLASS = 1 << 12;
+  private static final int FALLBACK = 1 << 13;
+  private static final int FALLBACK_ID = 1 << 14;
+  private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+
+  private int fields;
+
+  private float sizeMultiplier = 1f;
+  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  private Priority priority = Priority.NORMAL;
+  private Drawable errorPlaceholder;
+  private int errorId;
+  private Drawable placeholderDrawable;
+  private int placeholderId;
+  private boolean isCacheable = true;
+  private int overrideHeight = UNSET;
+  private int overrideWidth = UNSET;
+  private Key signature = EmptySignature.obtain();
+  private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
+  private Drawable fallbackDrawable;
+  private int fallbackId;
+
+  private Options options = new Options();
+  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+  private Class<?> resourceClass = Object.class;
+  private boolean isLocked;
+  private Resources.Theme theme;
+  private boolean isAutoCloneEnabled;
+
+  /**
+   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
+   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
+   * (particularly {@link android.graphics.Bitmap}s on devices with overly dense screens.
+   *
+   * @param sizeMultiplier The multiplier to apply to the
+   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
+   *                       loading the resource.
+   * @return This request builder.
+   */
+  public final CHILD sizeMultiplier(float sizeMultiplier) {
+    if (isAutoCloneEnabled) {
+      return clone().sizeMultiplier(sizeMultiplier);
+    }
+
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.sizeMultiplier = sizeMultiplier;
+    fields |= SIZE_MULTIPLIER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
+   *
+   * <p> Defaults to {@link com.bumptech.glide.load.engine.DiskCacheStrategy#AUTOMATIC}. </p>
+   *
+   * <p> For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} is
+   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
+   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
+   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#DATA} or
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}. </p>
+   *
+   * @param strategy The strategy to use.
+   * @return This request builder.
+   */
+  public final CHILD diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    if (isAutoCloneEnabled) {
+      return clone().diskCacheStrategy(strategy);
+    }
+    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
+    fields |= DISK_CACHE_STRATEGY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the priority for this load.
+   *
+   * @param priority A priority.
+   * @return This request builder.
+   */
+  public final CHILD priority(@NonNull Priority priority) {
+    if (isAutoCloneEnabled) {
+      return clone().priority(priority);
+    }
+
+    this.priority = Preconditions.checkNotNull(priority);
+    fields |= PRIORITY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  public final CHILD placeholder(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(drawable);
+    }
+
+    this.placeholderDrawable = drawable;
+    fields |= PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resource to
+   * display while a resource is loading.
+   *
+   * @param resourceId The id of the resource to use as a placeholder
+   * @return This request builder.
+   */
+  public final CHILD placeholder(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(resourceId);
+    }
+
+    this.placeholderId = resourceId;
+    fields |= PLACEHOLDER_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link android.graphics.drawable.Drawable} to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  public final CHILD fallback(Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(drawable);
+    }
+
+    this.fallbackDrawable = drawable;
+    fields |= FALLBACK;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
+   * the error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param resourceId The id of the resource to use as a fallback.
+   * @return This request builder.
+   */
+  public final CHILD fallback(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(resourceId);
+    }
+
+    this.fallbackId = resourceId;
+    fields |= FALLBACK_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a {@link Drawable} to display if a load fails.
+   *
+   * @param drawable The drawable to display.
+   * @return This request builder.
+   */
+  public final CHILD error(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().error(drawable);
+    }
+
+    this.errorPlaceholder = drawable;
+    fields |= ERROR_PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if a load fails.
+   *
+   * @param resourceId The id of the resource to use as a placeholder.
+   * @return This request builder.
+   */
+  public final CHILD error(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().error(resourceId);
+    }
+    this.errorId = resourceId;
+    fields |= ERROR_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
+   * {@link #fallback(Drawable)}.
+   *
+   * @param theme The theme to use when loading Drawables.
+   * @return this request builder.
+   */
+  public final CHILD theme(Resources.Theme theme) {
+    if (isAutoCloneEnabled) {
+      return clone().theme(theme);
+    }
+
+    this.theme = theme;
+    fields |= THEME;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Allows the loaded resource to skip the memory cache.
+   *
+   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
+   *
+   * @param skip True to allow the resource to skip the memory cache.
+   * @return This request builder.
+   */
+  public final CHILD skipMemoryCache(boolean skip) {
+    if (isAutoCloneEnabled) {
+      return clone().skipMemoryCache(true);
+    }
+
+    this.isCacheable = !skip;
+    fields |= IS_CACHEABLE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given values. This is useful for thumbnails, and should only be used for other cases when you
+   * need a very specific image size.
+   *
+   * @param width  The width in pixels to use to load the resource.
+   * @param height The height in pixels to use to load the resource.
+   * @return This request builder.
+   */
+  public final CHILD override(int width, int height) {
+    if (isAutoCloneEnabled) {
+      return clone().override(width, height);
+    }
+
+    this.overrideWidth = width;
+    this.overrideHeight = height;
+    fields |= OVERRIDE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given size.
+   *
+   * @see #override(int, int)
+   * @param size The width and height to use.
+   * @return This request builder.
+   */
+  public final CHILD override(int size) {
+    return override(size, size);
+  }
+
+  /**
+   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
+   * more control over when cached data is invalidated.
+   *
+   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
+   *
+   * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current
+   *                  state of the model that will be mixed in to the cache key.
+   * @return This request builder.
+   * @see com.bumptech.glide.signature.StringSignature
+   */
+  public final CHILD signature(@NonNull Key signature) {
+    if (isAutoCloneEnabled) {
+      return clone().signature(signature);
+    }
+
+    this.signature = Preconditions.checkNotNull(signature);
+    fields |= SIGNATURE;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders. </p>
+   *
+   * <p> Even if this object was locked, the cloned object returned from this method will not be
+   * locked. </p>
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  public final CHILD clone() {
+    try {
+      BaseRequestOptions<CHILD> result = (BaseRequestOptions<CHILD>) super.clone();
+      result.options = new Options();
+      result.options.putAll(options);
+      result.transformations = new HashMap<>();
+      result.transformations.putAll(transformations);
+      result.isLocked = false;
+      result.isAutoCloneEnabled = false;
+      return (CHILD) result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public final <T> CHILD set(@NonNull Option<T> option, @NonNull T value) {
+    if (isAutoCloneEnabled) {
+      return clone().set(option, value);
+    }
+
+    Preconditions.checkNotNull(option);
+    Preconditions.checkNotNull(value);
+    options.set(option, value);
+    return selfOrThrowIfLocked();
+  }
+
+  public final CHILD decode(@NonNull Class<?> resourceClass) {
+    if (isAutoCloneEnabled) {
+      return clone().decode(resourceClass);
+    }
+
+    this.resourceClass = Preconditions.checkNotNull(resourceClass);
+    fields |= RESOURCE_CLASS;
+    return selfOrThrowIfLocked();
+  }
+
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
+  public final boolean isTransformationSet() {
+    return isSet(TRANSFORMATION);
+  }
+
+  public final boolean isLocked() {
+    return isLocked;
+  }
+
+  /**
+   * Sets the value for key
+   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   */
+  public CHILD encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the value for key
+   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_QUALITY}.
+   */
+  public CHILD encodeQuality(int quality) {
+    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+  }
+
+  /**
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
+   * {@link Downsampler}.
+   *
+   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
+   * decoded using a decoder that cannot control the format
+   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
+   * ignore the requested format if it can't display the image (ie RGB_565 is requested, but the
+   * image has alpha).
+   */
+  public CHILD format(@NonNull DecodeFormat format) {
+    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the time position of the frame to extract from a video.
+   *
+   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
+   *                        Android framework implementation return a representative frame.
+   */
+  public CHILD frame(long frameTimeMicros) {
+    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
+  }
+
+  /**
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
+   * {@link Downsampler}.
+   */
+  public CHILD downsample(@NonNull DownsampleStrategy strategy) {
+    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link android.content.Context}.
+   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
+   * @see #centerCrop(android.content.Context)
+   */
+  public CHILD optionalCenterCrop(Context context) {
+    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link android.content.Context}.
+   * @see #transform(Class, com.bumptech.glide.load.Transformation)
+   * @see #optionalCenterCrop(android.content.Context)
+   */
+  public CHILD centerCrop(Context context) {
+    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link android.content.Context}.
+   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
+   * @see #fitCenter(android.content.Context)
+   */
+  public CHILD optionalFitCenter(Context context) {
+    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link android.content.Context}.
+   * @see #transform(Class, com.bumptech.glide.load.Transformation)
+   * @see #optionalFitCenter(android.content.Context)
+   */
+  public CHILD fitCenter(Context context) {
+    return transform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link Context}.
+   * @see #optionalTransform(Context, Transformation)
+   * @see #circleCrop(Context)
+   */
+  public CHILD optionalCircleCrop(Context context) {
+    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link Context}.
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop(Context)
+   */
+  public CHILD circleCrop(Context context) {
+    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));
+  }
+
+  final CHILD optionalTransform(Context context, DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(context, downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return optionalTransform(context, transformation);
+  }
+
+  final CHILD transform(Context context, DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(context, downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(context, transformation);
+  }
+
+  /**
+   * Applies the given {@link com.bumptech.glide.load.Transformation} for
+   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context        Any {@link android.content.Context}.
+   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
+   *                       {@link android.graphics.Bitmap}s.
+   * @see #optionalTransform(android.content.Context, com.bumptech.glide.load.Transformation)
+   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
+   */
+  public CHILD transform(Context context, @NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(context, transformation);
+    }
+
+    optionalTransform(context, transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link com.bumptech.glide.load.Transformation} for
+   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context        Any {@link android.content.Context}.
+   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
+   *                       {@link android.graphics.Bitmap}s.
+   * @see #transform(android.content.Context, com.bumptech.glide.load.Transformation)
+   * @see #transform(Class, com.bumptech.glide.load.Transformation)
+   */
+  public CHILD optionalTransform(Context context, Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(context, transformation);
+    }
+
+    optionalTransform(Bitmap.class, transformation);
+    // TODO: remove BitmapDrawable decoder and this transformation.
+    optionalTransform(BitmapDrawable.class,
+        new BitmapDrawableTransformation(context, transformation));
+    optionalTransform(GifDrawable.class, new GifDrawableTransformation(context, transformation));
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
+   * the given type and allows unknown resource types to be ignored.
+   *
+   * <p> Users can apply different transformations for each resource class. Applying a
+   * {@link com.bumptech.glide.load.Transformation} for a resource type that already has a
+   * {@link com.bumptech.glide.load.Transformation} will override the previous call. </p>
+   *
+   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
+   * an unknown resource class will throw an exception. To allow unknown types, users must always
+   * call the optional version of each method. </p>
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
+   */
+  public final <T> CHILD optionalTransform(Class<T> resourceClass,
+      Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(resourceClass, transformation);
+    }
+
+    Preconditions.checkNotNull(resourceClass);
+    Preconditions.checkNotNull(transformation);
+    transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
+   * the given type and throws if asked to transform an unknown resource type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
+   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
+   */
+  public final <T> CHILD transform(Class<T> resourceClass, Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(resourceClass, transformation);
+    }
+
+    optionalTransform(resourceClass, transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Removes all applied {@link com.bumptech.glide.load.Transformation Transformations} for all
+   * resource classes and allows unknown resource types to be transformed without throwing an
+   * exception.
+   */
+  public final CHILD dontTransform() {
+    if (isAutoCloneEnabled) {
+      return clone().dontTransform();
+    }
+
+    transformations.clear();
+    fields &= ~TRANSFORMATION;
+    isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Disables resource decoders that return animated resources so any resource returned will be
+   * static.
+   *
+   * <p> To disable transitions (fades etc) use
+   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
+   */
+  public final CHILD dontAnimate() {
+    if (isAutoCloneEnabled) {
+      return clone().dontAnimate();
+    }
+
+    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    return selfOrThrowIfLocked();
+  }
+
+  public final CHILD apply(BaseRequestOptions<?> other) {
+    if (isAutoCloneEnabled) {
+      return clone().apply(other);
+    }
+
+    if (isSet(other.fields, SIZE_MULTIPLIER)) {
+      sizeMultiplier = other.sizeMultiplier;
+    }
+    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
+      diskCacheStrategy = other.diskCacheStrategy;
+    }
+    if (isSet(other.fields, PRIORITY)) {
+      priority = other.priority;
+    }
+    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
+      errorPlaceholder = other.errorPlaceholder;
+    }
+    if (isSet(other.fields, ERROR_ID)) {
+      errorId = other.errorId;
+    }
+    if (isSet(other.fields, PLACEHOLDER)) {
+      placeholderDrawable = other.placeholderDrawable;
+    }
+    if (isSet(other.fields, PLACEHOLDER_ID)) {
+      placeholderId = other.placeholderId;
+    }
+    if (isSet(other.fields, IS_CACHEABLE)) {
+      isCacheable = other.isCacheable;
+    }
+    if (isSet(other.fields, OVERRIDE)) {
+      overrideWidth = other.overrideWidth;
+      overrideHeight = other.overrideHeight;
+    }
+    if (isSet(other.fields, SIGNATURE)) {
+      signature = other.signature;
+    }
+    if (isSet(other.fields, RESOURCE_CLASS)) {
+      resourceClass = other.resourceClass;
+    }
+    if (isSet(other.fields, FALLBACK)) {
+      fallbackDrawable = other.fallbackDrawable;
+    }
+    if (isSet(other.fields, FALLBACK_ID)) {
+      fallbackId = other.fallbackId;
+    }
+    if (isSet(other.fields, THEME)) {
+      theme = other.theme;
+    }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+    }
+
+    fields |= other.fields;
+    options.putAll(other.options);
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Throws if any further mutations are attempted.
+   *
+   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
+   */
+  @SuppressWarnings("unchecked")
+  public final CHILD lock() {
+    isLocked = true;
+    // This is the only place we should not check locked.
+    return (CHILD) this;
+  }
+
+  /**
+   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
+   * before the mutation resulting in all methods returning a new Object and leaving the original
+   * locked object unmodified.
+   *
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
+   * are mutable and are not locked.
+   */
+  public final CHILD autoLock() {
+    if (isLocked && !isAutoCloneEnabled) {
+      throw new IllegalStateException("You cannot auto lock an already locked options object"
+          + ", try clone() first");
+    }
+    isAutoCloneEnabled = true;
+    return lock();
+  }
+
+  @SuppressWarnings("unchecked")
+  private CHILD selfOrThrowIfLocked() {
+    if (isLocked) {
+      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
+    }
+    return (CHILD) this;
+  }
+
+  public final Map<Class<?>, Transformation<?>> getTransformations() {
+    return transformations;
+  }
+
+  public final boolean isTransformationRequired() {
+    return isTransformationRequired;
+  }
+
+  public final Options getOptions() {
+    return options;
+  }
+
+  public final Class<?> getResourceClass() {
+    return resourceClass;
+  }
+
+  public final DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  public final Drawable getErrorPlaceholder() {
+    return errorPlaceholder;
+  }
+
+  public final int getErrorId() {
+    return errorId;
+  }
+
+  public final int getPlaceholderId() {
+    return placeholderId;
+  }
+
+  public final Drawable getPlaceholderDrawable() {
+    return placeholderDrawable;
+  }
+
+  public final int getFallbackId() {
+    return fallbackId;
+  }
+
+  public final Drawable getFallbackDrawable() {
+    return fallbackDrawable;
+  }
+
+  public final Resources.Theme getTheme() {
+    return theme;
+  }
+
+  public final boolean isMemoryCacheable() {
+    return isCacheable;
+  }
+
+  public final Key getSignature() {
+    return signature;
+  }
+
+  public final boolean isPrioritySet() {
+    return isSet(PRIORITY);
+  }
+
+  public final Priority getPriority() {
+    return priority;
+  }
+
+  public final int getOverrideWidth() {
+    return overrideWidth;
+  }
+
+  public final boolean isValidOverride() {
+    return Util.isValidDimensions(overrideWidth, overrideHeight);
+  }
+
+  public final int getOverrideHeight() {
+    return overrideHeight;
+  }
+
+  public final float getSizeMultiplier() {
+    return sizeMultiplier;
+  }
+
+  private boolean isSet(int flag) {
+    return isSet(fields, flag);
+  }
+
+  private static boolean isSet(int fields, int flag) {
+    return (fields & flag) != 0;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
index 882a8c96b..aa485d357 100644
--- a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
@@ -15,21 +15,14 @@
  *                                       .into(250, 250);
  * Bitmap myBitmap = futureTarget.get();
  * ... // do things with bitmap and then release when finished:
- * Glide.clear(futureTarget);
+ * futureTarget.cancel(false);
  * }
  * </pre>
  *
- * <p>
- *     Note - {@link #get()} and {@link #get(long, java.util.concurrent.TimeUnit)} must be called
- *     off of the main thread or they will block forever.
- * </p>
+ * <p> Note - {@link #get()} and {@link #get(long, java.util.concurrent.TimeUnit)} must be called
+ * off of the main thread or they will block forever. </p>
  *
  * @param <R> The type of resource this FutureTarget will retrieve.
  */
-public interface FutureTarget<R> extends Future<R>, Target<R>  {
-
-    /**
-     * Safely clears the target from a background thread to release its resources.
-     */
-    void clear();
+public interface FutureTarget<R> extends Future<R>, Target<R> {
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/GenericRequest.java b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java
deleted file mode 100644
index 24efdfc5e..000000000
--- a/library/src/main/java/com/bumptech/glide/request/GenericRequest.java
+++ /dev/null
@@ -1,531 +0,0 @@
-package com.bumptech.glide.request;
-
-import android.content.Context;
-import android.graphics.drawable.Drawable;
-import android.util.Log;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.engine.Engine;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-import com.bumptech.glide.provider.LoadProvider;
-import com.bumptech.glide.request.animation.GlideAnimation;
-import com.bumptech.glide.request.animation.GlideAnimationFactory;
-import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.util.LogTime;
-import com.bumptech.glide.util.Util;
-
-import java.util.Queue;
-
-/**
- * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given {@link Target}.
- *
- * @param <A> The type of the model that the resource will be loaded from.
- * @param <T> The type of the data that the resource will be loaded from.
- * @param <Z> The type of the resource that will be loaded.
- * @param <R> The type of the resource that will be transcoded from the loaded resource.
- */
-public final class GenericRequest<A, T, Z, R> implements Request, SizeReadyCallback,
-        ResourceCallback {
-    private static final String TAG = "GenericRequest";
-    private static final Queue<GenericRequest<?, ?, ?, ?>> REQUEST_POOL = Util.createQueue(0);
-    private static final double TO_MEGABYTE = 1d / (1024d * 1024d);
-
-    private enum Status {
-        /** Created but not yet running. */
-        PENDING,
-        /** In the process of fetching media. */
-        RUNNING,
-        /** Waiting for a callback given to the Target to be called to determine target dimensions. */
-        WAITING_FOR_SIZE,
-        /** Finished loading media successfully. */
-        COMPLETE,
-        /** Failed to load media, may be restarted. */
-        FAILED,
-        /** Cancelled by the user, may not be restarted. */
-        CANCELLED,
-        /** Cleared by the user with a placeholder set, may not be restarted. */
-        CLEARED,
-        /** Temporarily paused by the system, may be restarted. */
-        PAUSED,
-    }
-
-    private final String tag = String.valueOf(hashCode());
-
-    private Key signature;
-    private int placeholderResourceId;
-    private int errorResourceId;
-    private Context context;
-    private Transformation<Z> transformation;
-    private LoadProvider<A, T, Z, R> loadProvider;
-    private RequestCoordinator requestCoordinator;
-    private A model;
-    private Class<R> transcodeClass;
-    private boolean isMemoryCacheable;
-    private Priority priority;
-    private Target<R> target;
-    private RequestListener<? super A, R> requestListener;
-    private float sizeMultiplier;
-    private Engine engine;
-    private GlideAnimationFactory<R> animationFactory;
-    private int overrideWidth;
-    private int overrideHeight;
-    private DiskCacheStrategy diskCacheStrategy;
-
-    private Drawable placeholderDrawable;
-    private Drawable errorDrawable;
-    private boolean loadedFromMemoryCache;
-    // doing our own type check
-    private Resource<?> resource;
-    private Engine.LoadStatus loadStatus;
-    private long startTime;
-    private Status status;
-
-    public static <A, T, Z, R> GenericRequest<A, T, Z, R> obtain(
-            LoadProvider<A, T, Z, R> loadProvider,
-            A model,
-            Key signature,
-            Context context,
-            Priority priority,
-            Target<R> target,
-            float sizeMultiplier,
-            Drawable placeholderDrawable,
-            int placeholderResourceId,
-            Drawable errorDrawable,
-            int errorResourceId,
-            RequestListener<? super A, R> requestListener,
-            RequestCoordinator requestCoordinator,
-            Engine engine,
-            Transformation<Z> transformation,
-            Class<R> transcodeClass,
-            boolean isMemoryCacheable,
-            GlideAnimationFactory<R> animationFactory,
-            int overrideWidth,
-            int overrideHeight,
-            DiskCacheStrategy diskCacheStrategy) {
-        @SuppressWarnings("unchecked")
-        GenericRequest<A, T, Z, R> request = (GenericRequest<A, T, Z, R>) REQUEST_POOL.poll();
-        if (request == null) {
-            request = new GenericRequest<A, T, Z, R>();
-        }
-        request.init(loadProvider,
-                model,
-                signature,
-                context,
-                priority,
-                target,
-                sizeMultiplier,
-                placeholderDrawable,
-                placeholderResourceId,
-                errorDrawable,
-                errorResourceId,
-                requestListener,
-                requestCoordinator,
-                engine,
-                transformation,
-                transcodeClass,
-                isMemoryCacheable,
-                animationFactory,
-                overrideWidth,
-                overrideHeight,
-                diskCacheStrategy);
-        return request;
-    }
-
-    private GenericRequest() {
-        // just create, instances are reused with recycle/init
-    }
-
-    @Override
-    public void recycle() {
-        loadProvider = null;
-        model = null;
-        context = null;
-        target = null;
-        placeholderDrawable = null;
-        errorDrawable = null;
-        requestListener = null;
-        requestCoordinator = null;
-        transformation = null;
-        animationFactory = null;
-        loadedFromMemoryCache = false;
-        loadStatus = null;
-        REQUEST_POOL.offer(this);
-    }
-
-    private void init(
-            LoadProvider<A, T, Z, R> loadProvider,
-            A model,
-            Key signature,
-            Context context,
-            Priority priority,
-            Target<R> target,
-            float sizeMultiplier,
-            Drawable placeholderDrawable,
-            int placeholderResourceId,
-            Drawable errorDrawable,
-            int errorResourceId,
-            RequestListener<? super A, R> requestListener,
-            RequestCoordinator requestCoordinator,
-            Engine engine,
-            Transformation<Z> transformation,
-            Class<R> transcodeClass,
-            boolean isMemoryCacheable,
-            GlideAnimationFactory<R> animationFactory,
-            int overrideWidth,
-            int overrideHeight,
-            DiskCacheStrategy diskCacheStrategy) {
-        this.loadProvider = loadProvider;
-        this.model = model;
-        this.signature = signature;
-        this.context = context.getApplicationContext();
-        this.priority = priority;
-        this.target = target;
-        this.sizeMultiplier = sizeMultiplier;
-        this.placeholderDrawable = placeholderDrawable;
-        this.placeholderResourceId = placeholderResourceId;
-        this.errorDrawable = errorDrawable;
-        this.errorResourceId = errorResourceId;
-        this.requestListener = requestListener;
-        this.requestCoordinator = requestCoordinator;
-        this.engine = engine;
-        this.transformation = transformation;
-        this.transcodeClass = transcodeClass;
-        this.isMemoryCacheable = isMemoryCacheable;
-        this.animationFactory = animationFactory;
-        this.overrideWidth = overrideWidth;
-        this.overrideHeight = overrideHeight;
-        this.diskCacheStrategy = diskCacheStrategy;
-        status = Status.PENDING;
-
-        // We allow null models by just setting an error drawable. Null models will always have empty providers, we
-        // simply skip our sanity checks in that unusual case.
-        if (model != null) {
-            check("ModelLoader", loadProvider.getModelLoader(), "try .using(ModelLoader)");
-            check("Transcoder", loadProvider.getTranscoder(), "try .as*(Class).transcode(ResourceTranscoder)");
-            check("Transformation", transformation, "try .transform(UnitTransformation.get())");
-            if (diskCacheStrategy.cacheSource()) {
-                check("SourceEncoder", loadProvider.getSourceEncoder(),
-                        "try .sourceEncoder(Encoder) or .diskCacheStrategy(NONE/RESULT)");
-            } else {
-                check("SourceDecoder", loadProvider.getSourceDecoder(),
-                        "try .decoder/.imageDecoder/.videoDecoder(ResourceDecoder) or .diskCacheStrategy(ALL/SOURCE)");
-            }
-            if (diskCacheStrategy.cacheSource() || diskCacheStrategy.cacheResult()) {
-                // TODO if(resourceClass.isAssignableFrom(InputStream.class) it is possible to wrap sourceDecoder
-                // and use it instead of cacheDecoder: new FileToStreamDecoder<Z>(sourceDecoder)
-                // in that case this shouldn't throw
-                check("CacheDecoder", loadProvider.getCacheDecoder(),
-                        "try .cacheDecoder(ResouceDecoder) or .diskCacheStrategy(NONE)");
-            }
-            if (diskCacheStrategy.cacheResult()) {
-                check("Encoder", loadProvider.getEncoder(),
-                        "try .encode(ResourceEncoder) or .diskCacheStrategy(NONE/SOURCE)");
-            }
-        }
-    }
-
-    private static void check(String name, Object object, String suggestion) {
-        if (object == null) {
-            StringBuilder message = new StringBuilder(name);
-            message.append(" must not be null");
-            if (suggestion != null) {
-                message.append(", ");
-                message.append(suggestion);
-            }
-            throw new NullPointerException(message.toString());
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void begin() {
-        startTime = LogTime.getLogTime();
-        if (model == null) {
-            onException(null);
-            return;
-        }
-
-        status = Status.WAITING_FOR_SIZE;
-        if (overrideWidth > 0 && overrideHeight > 0) {
-            onSizeReady(overrideWidth, overrideHeight);
-        } else {
-            target.getSize(this);
-        }
-
-        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {
-            target.onLoadStarted(getPlaceholderDrawable());
-        }
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
-        }
-    }
-
-    /**
-     * Cancels the current load but does not release any resources held by the request and continues to display
-     * the loaded resource if the load completed before the call to cancel.
-     *
-     * <p>
-     *     Cancelled requests can be restarted with a subsequent call to {@link #begin()}.
-     * </p>
-     *
-     * @see #clear()
-     */
-    void cancel() {
-        status = Status.CANCELLED;
-        if (loadStatus != null) {
-            loadStatus.cancel();
-            loadStatus = null;
-        }
-    }
-
-    /**
-     * Cancels the current load if it is in progress, clears any resources held onto by the request and replaces
-     * the loaded resource if the load completed with the placeholder.
-     *
-     * <p>
-     *     Cleared requests can be restarted with a subsequent call to {@link #begin()}
-     * </p>
-     *
-     * @see #cancel()
-     */
-    @Override
-    public void clear() {
-        Util.assertMainThread();
-        if (status == Status.CLEARED) {
-            return;
-        }
-        cancel();
-        // Resource must be released before canNotifyStatusChanged is called.
-        if (resource != null) {
-            releaseResource(resource);
-        }
-        if (canNotifyStatusChanged()) {
-            target.onLoadCleared(getPlaceholderDrawable());
-        }
-        // Must be after cancel().
-        status = Status.CLEARED;
-    }
-
-    @Override
-    public boolean isPaused() {
-        return status == Status.PAUSED;
-    }
-
-    @Override
-    public void pause() {
-        clear();
-        status = Status.PAUSED;
-    }
-
-    private void releaseResource(Resource resource) {
-        engine.release(resource);
-        this.resource = null;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isRunning() {
-        return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isComplete() {
-        return status == Status.COMPLETE;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isResourceSet() {
-        return isComplete();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isCancelled() {
-        return status == Status.CANCELLED || status == Status.CLEARED;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isFailed() {
-        return status == Status.FAILED;
-    }
-
-    private void setErrorPlaceholder(Exception e) {
-        if (!canNotifyStatusChanged()) {
-            return;
-        }
-
-        Drawable error = getErrorDrawable();
-        if (error == null) {
-            error = getPlaceholderDrawable();
-        }
-        target.onLoadFailed(e, error);
-    }
-
-    private Drawable getErrorDrawable() {
-        if (errorDrawable == null && errorResourceId > 0) {
-            errorDrawable = context.getResources().getDrawable(errorResourceId);
-        }
-        return errorDrawable;
-    }
-
-    private Drawable getPlaceholderDrawable() {
-        if (placeholderDrawable == null && placeholderResourceId > 0) {
-            placeholderDrawable = context.getResources().getDrawable(placeholderResourceId);
-        }
-        return placeholderDrawable;
-    }
-
-    /**
-     * A callback method that should never be invoked directly.
-     */
-    @Override
-    public void onSizeReady(int width, int height) {
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
-        }
-        if (status != Status.WAITING_FOR_SIZE) {
-            return;
-        }
-        status = Status.RUNNING;
-
-        width = Math.round(sizeMultiplier * width);
-        height = Math.round(sizeMultiplier * height);
-
-        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();
-        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);
-
-        if (dataFetcher == null) {
-            onException(new Exception("Got null fetcher from model loader"));
-            return;
-        }
-        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
-        }
-        loadedFromMemoryCache = true;
-        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
-                priority, isMemoryCacheable, diskCacheStrategy, this);
-        loadedFromMemoryCache = resource != null;
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
-        }
-    }
-
-    private boolean canSetResource() {
-        return requestCoordinator == null || requestCoordinator.canSetImage(this);
-    }
-
-    private boolean canNotifyStatusChanged() {
-        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
-    }
-
-    private boolean isFirstReadyResource() {
-        return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
-    }
-
-    private void notifyLoadSuccess() {
-      if (requestCoordinator != null) {
-        requestCoordinator.onRequestSuccess(this);
-      }
-    }
-
-    /**
-     * A callback method that should never be invoked directly.
-     */
-    @SuppressWarnings("unchecked")
-    @Override
-    public void onResourceReady(Resource<?> resource) {
-        if (resource == null) {
-            onException(new Exception("Expected to receive a Resource<R> with an object of " + transcodeClass
-                    + " inside, but instead got null."));
-            return;
-        }
-
-        Object received = resource.get();
-        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
-            releaseResource(resource);
-            onException(new Exception("Expected to receive an object of " + transcodeClass
-                    + " but instead got " + (received != null ? received.getClass() : "") + "{" + received + "}"
-                    + " inside Resource{" + resource + "}."
-                    + (received != null ? "" : " "
-                        + "To indicate failure return a null Resource object, "
-                        + "rather than a Resource object containing null data.")
-            ));
-            return;
-        }
-
-        if (!canSetResource()) {
-            releaseResource(resource);
-            // We can't set the status to complete before asking canSetResource().
-            status = Status.COMPLETE;
-            return;
-        }
-
-        onResourceReady(resource, (R) received);
-    }
-
-    /**
-     * Internal {@link #onResourceReady(Resource)} where arguments are known to be safe.
-     *
-     * @param resource original {@link Resource}, never <code>null</code>
-     * @param result object returned by {@link Resource#get()}, checked for type and never <code>null</code>
-     */
-    private void onResourceReady(Resource<?> resource, R result) {
-        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
-                isFirstReadyResource())) {
-            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstReadyResource());
-            target.onResourceReady(result, animation);
-        }
-
-        status = Status.COMPLETE;
-        this.resource = resource;
-        notifyLoadSuccess();
-
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: "
-                    + (resource.getSize() * TO_MEGABYTE) + " fromCache: " + loadedFromMemoryCache);
-        }
-    }
-
-    /**
-     * A callback method that should never be invoked directly.
-     */
-    @Override
-    public void onException(Exception e) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "load failed", e);
-        }
-
-        status = Status.FAILED;
-        //TODO: what if this is a thumbnail request?
-        if (requestListener == null || !requestListener.onException(e, model, target, isFirstReadyResource())) {
-            setErrorPlaceholder(e);
-        }
-    }
-
-    private void logV(String message) {
-        Log.v(TAG, message + " this: " + tag);
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index 44b5482cb..ffa21d02f 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -5,55 +5,56 @@
  */
 public interface Request {
 
-    /**
-     * Starts an asynchronous load.
-     */
-    void begin();
-
-    /**
-     * Identical to {@link #clear()} except that the request may later be restarted.
-     */
-    void pause();
-
-    /**
-     * Prevents any bitmaps being loaded from previous requests, releases any resources held by this request,
-     * displays the current placeholder if one was provided, and marks the request as having been cancelled.
-     */
-    void clear();
-
-    /**
-     * Returns true if this request is paused and may be restarted.
-     */
-    boolean isPaused();
-
-    /**
-     * Returns true if this request is running and has not completed or failed.
-     */
-    boolean isRunning();
-
-    /**
-     * Returns true if the request has completed successfully.
-     */
-    boolean isComplete();
-
-    /**
-     * Returns true if a non-placeholder resource is set. For Requests that load more than one resource, isResourceSet
-     * may return true even if {@link #isComplete()}} returns false.
-     */
-    boolean isResourceSet();
-
-    /**
-     * Returns true if the request has been cancelled.
-     */
-    boolean isCancelled();
-
-    /**
-     * Returns true if the request has failed.
-     */
-    boolean isFailed();
-
-    /**
-     * Recycles the request object and releases its resources.
-     */
-    void recycle();
+  /**
+   * Starts an asynchronous load.
+   */
+  void begin();
+
+  /**
+   * Identical to {@link #clear()} except that the request may later be restarted.
+   */
+  void pause();
+
+  /**
+   * Prevents any bitmaps being loaded from previous requests, releases any resources held by this
+   * request, displays the current placeholder if one was provided, and marks the request as having
+   * been cancelled.
+   */
+  void clear();
+
+  /**
+   * Returns true if this request is paused and may be restarted.
+   */
+  boolean isPaused();
+
+  /**
+   * Returns true if this request is running and has not completed or failed.
+   */
+  boolean isRunning();
+
+  /**
+   * Returns true if the request has completed successfully.
+   */
+  boolean isComplete();
+
+  /**
+   * Returns true if a non-placeholder resource is put. For Requests that load more than one
+   * resource, isResourceSet may return true even if {@link #isComplete()}} returns false.
+   */
+  boolean isResourceSet();
+
+  /**
+   * Returns true if the request has been cancelled.
+   */
+  boolean isCancelled();
+
+  /**
+   * Returns true if the request has failed.
+   */
+  boolean isFailed();
+
+  /**
+   * Recycles the request object and releases its resources.
+   */
+  void recycle();
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
index c8c717164..2143366eb 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
@@ -1,33 +1,34 @@
 package com.bumptech.glide.request;
 
 /**
- * An interface for coordinating multiple requests with the same {@link com.bumptech.glide.request.target.Target}.
+ * An interface for coordinating multiple requests with the same {@link
+ * com.bumptech.glide.request.target.Target}.
  */
 public interface RequestCoordinator {
 
-    /**
-     * Returns true if the {@link Request} can display a loaded bitmap.
-     *
-     * @param request The {@link Request} requesting permission to display a bitmap.
-     */
-    boolean canSetImage(Request request);
+  /**
+   * Returns true if the {@link Request} can display a loaded bitmap.
+   *
+   * @param request The {@link Request} requesting permission to display a bitmap.
+   */
+  boolean canSetImage(Request request);
 
-    /**
-     * Returns true if the {@link Request} can display a placeholder.
-     *
-     * @param request The {@link Request} requesting permission to display a placeholder.
-     */
-    boolean canNotifyStatusChanged(Request request);
+  /**
+   * Returns true if the {@link Request} can display a placeholder.
+   *
+   * @param request The {@link Request} requesting permission to display a placeholder.
+   */
+  boolean canNotifyStatusChanged(Request request);
 
-    /**
-     * Returns true if any coordinated {@link Request} has successfully completed.
-     *
-     * @see Request#isComplete()
-     */
-    boolean isAnyResourceSet();
+  /**
+   * Returns true if any coordinated {@link Request} has successfully completed.
+   *
+   * @see Request#isComplete()
+   */
+  boolean isAnyResourceSet();
 
-    /**
-     * Must be called when a request coordinated by this object completes successfully.
-     */
-    void onRequestSuccess(Request request);
+  /**
+   * Must be called when a request coordinated by this object completes successfully.
+   */
+  void onRequestSuccess(Request request);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index e7b58a878..3c57db530 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -2,9 +2,10 @@
 
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
+import android.support.annotation.Nullable;
 
-import com.bumptech.glide.request.animation.GlideAnimation;
 import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
 
 import java.util.concurrent.CancellationException;
@@ -13,258 +14,229 @@
 import java.util.concurrent.TimeoutException;
 
 /**
- * A {@link java.util.concurrent.Future} implementation for Glide that can be used to load resources in a blocking
- * manner on background threads.
+ * A {@link java.util.concurrent.Future} implementation for Glide that can be used to load resources
+ * in a blocking manner on background threads.
  *
- * <p>
- *     Note - Unlike most targets, RequestFutureTargets can be used once and only once. Attempting to reuse a
- *     RequestFutureTarget will probably result in undesirable behavior or exceptions. Instead of reusing
- *     objects of this class, the pattern should be:
+ * <p> Note - Unlike most targets, RequestFutureTargets can be used once and only once. Attempting
+ * to reuse a RequestFutureTarget will probably result in undesirable behavior or exceptions.
+ * Instead of reusing objects of this class, the pattern should be:
  *
- *     <pre>
+ * <pre>
  *     {@code
  *      RequestFutureTarget target = Glide.load("")...
  *     Object resource = target.get();
  *     // Do something with resource, and when finished:
- *     Glide.clear(target);
+ *     target.cancel(false);
  *     }
  *     </pre>
- *     The {@link com.bumptech.glide.Glide#clear(FutureTarget)} call will make sure any resources used are recycled.
+ * The {@link #cancel(boolean)} call will make sure any resources used are recycled.
  * </p>
  *
- * @param <T> The type of the data to load.
  * @param <R> The type of the resource that will be loaded.
  */
-public class RequestFutureTarget<T, R> implements FutureTarget<R>, Runnable {
-    private static final Waiter DEFAULT_WAITER = new Waiter();
-
-    private final Handler mainHandler;
-    private final int width;
-    private final int height;
-    // Exists for testing only.
-    private final boolean assertBackgroundThread;
-    private final Waiter waiter;
-
-    private R resource;
-    private Request request;
-    private boolean isCancelled;
-    private Exception exception;
-    private boolean resultReceived;
-    private boolean exceptionReceived;
-
-    /**
-     * Constructor for a RequestFutureTarget. Should not be used directly.
-     */
-    public RequestFutureTarget(Handler mainHandler, int width, int height) {
-        this(mainHandler, width, height, true, DEFAULT_WAITER);
-    }
-
-    RequestFutureTarget(Handler mainHandler, int width, int height, boolean assertBackgroundThread, Waiter waiter) {
-        this.mainHandler = mainHandler;
-        this.width = width;
-        this.height = height;
-        this.assertBackgroundThread = assertBackgroundThread;
-        this.waiter = waiter;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public synchronized boolean cancel(boolean b) {
-        if (isCancelled) {
-            return true;
-        }
-
-        final boolean result = !isDone();
-        if (result) {
-            isCancelled = true;
-            clear();
-            waiter.notifyAll(this);
-        }
-        return result;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public synchronized boolean isCancelled() {
-        return isCancelled;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public synchronized boolean isDone() {
-        return isCancelled || resultReceived;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public R get() throws InterruptedException, ExecutionException {
-        try {
-            return doGet(null);
-        } catch (TimeoutException e) {
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public R get(long time, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {
-        return doGet(timeUnit.toMillis(time));
-    }
-
-    /**
-     * A callback that should never be invoked directly.
-     */
-    @Override
-    public void getSize(SizeReadyCallback cb) {
-        cb.onSizeReady(width, height);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void setRequest(Request request) {
-        this.request = request;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Request getRequest() {
-        return request;
-    }
-
-    /**
-     * A callback that should never be invoked directly.
-     */
-    @Override
-    public void onLoadCleared(Drawable placeholder) {
-        // Do nothing.
-    }
-
-    /**
-     * A callback that should never be invoked directly.
-     */
-    @Override
-    public void onLoadStarted(Drawable placeholder) {
-        // Do nothing.
-    }
-
-    /**
-     * A callback that should never be invoked directly.
-     */
-    @Override
-    public synchronized void onLoadFailed(Exception e, Drawable errorDrawable) {
-         // We might get a null exception.
-        exceptionReceived = true;
-        this.exception = e;
-        waiter.notifyAll(this);
-    }
-
-    /**
-     * A callback that should never be invoked directly.
-     */
-    @Override
-    public synchronized void onResourceReady(R resource, GlideAnimation<? super R> glideAnimation) {
-        // We might get a null result.
-        resultReceived = true;
-        this.resource = resource;
-        waiter.notifyAll(this);
-    }
-
-    private synchronized R doGet(Long timeoutMillis) throws ExecutionException, InterruptedException, TimeoutException {
-        if (assertBackgroundThread) {
-            Util.assertBackgroundThread();
-        }
-
-        if (isCancelled) {
-            throw new CancellationException();
-        } else if (exceptionReceived) {
-            throw new ExecutionException(exception);
-        } else if (resultReceived) {
-            return resource;
-        }
-
-        if (timeoutMillis == null) {
-            waiter.waitForTimeout(this, 0);
-        } else if (timeoutMillis > 0) {
-            waiter.waitForTimeout(this, timeoutMillis);
-        }
-
-        if (Thread.interrupted()) {
-            throw new InterruptedException();
-        } else if (exceptionReceived) {
-            throw new ExecutionException(exception);
-        } else if (isCancelled) {
-            throw new CancellationException();
-        } else if (!resultReceived) {
-            throw new TimeoutException();
-        }
-
-        return resource;
-    }
-
-    /**
-     * A callback that should never be invoked directly.
-     */
-    @Override
-    public void run() {
-        request.clear();
-    }
-
-    /**
-     * Can be safely called from either the main thread or a background thread to cleanup the resources used by this
-     * target.
-     */
-    @Override
-    public void clear() {
-        mainHandler.post(this);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onStart() {
-        // Do nothing.
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onStop() {
-        // Do nothing.
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onDestroy() {
-        // Do nothing.
-    }
-
-    // Visible for testing.
-    static class Waiter {
-
-        public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
-            toWaitOn.wait(timeoutMillis);
-        }
-
-        public void notifyAll(Object toNotify) {
-            toNotify.notifyAll();
-        }
-    }
+public class RequestFutureTarget<R> implements FutureTarget<R>,
+    Runnable {
+  private static final Waiter DEFAULT_WAITER = new Waiter();
+
+  private final Handler mainHandler;
+  private final int width;
+  private final int height;
+  // Exists for testing only.
+  private final boolean assertBackgroundThread;
+  private final Waiter waiter;
+
+  @Nullable private R resource;
+  @Nullable private Request request;
+  private boolean isCancelled;
+  private boolean resultReceived;
+  private boolean loadFailed;
+
+  /**
+   * Constructor for a RequestFutureTarget. Should not be used directly.
+   */
+  public RequestFutureTarget(Handler mainHandler, int width, int height) {
+    this(mainHandler, width, height, true, DEFAULT_WAITER);
+  }
+
+  RequestFutureTarget(Handler mainHandler, int width, int height, boolean assertBackgroundThread,
+      Waiter waiter) {
+    this.mainHandler = mainHandler;
+    this.width = width;
+    this.height = height;
+    this.assertBackgroundThread = assertBackgroundThread;
+    this.waiter = waiter;
+  }
+
+  @Override
+  public synchronized boolean cancel(boolean mayInterruptIfRunning) {
+    if (isCancelled) {
+      return true;
+    }
+
+    final boolean result = !isDone();
+    if (result) {
+      isCancelled = true;
+      waiter.notifyAll(this);
+    }
+    clearOnMainThread();
+    return result;
+  }
+
+  @Override
+  public synchronized boolean isCancelled() {
+    return isCancelled;
+  }
+
+  @Override
+  public synchronized boolean isDone() {
+    return isCancelled || resultReceived;
+  }
+
+  @Override
+  public R get() throws InterruptedException, ExecutionException {
+    try {
+      return doGet(null);
+    } catch (TimeoutException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Override
+  public R get(long time, TimeUnit timeUnit)
+      throws InterruptedException, ExecutionException, TimeoutException {
+    return doGet(timeUnit.toMillis(time));
+  }
+
+  /**
+   * A callback that should never be invoked directly.
+   */
+  @Override
+  public void getSize(SizeReadyCallback cb) {
+    cb.onSizeReady(width, height);
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void setRequest(@Nullable Request request) {
+    this.request = request;
+  }
+
+  @Override
+  @Nullable
+  public Request getRequest() {
+    return request;
+  }
+
+  /**
+   * A callback that should never be invoked directly.
+   */
+  @Override
+  public void onLoadCleared(Drawable placeholder) {
+    // Do nothing.
+  }
+
+  /**
+   * A callback that should never be invoked directly.
+   */
+  @Override
+  public void onLoadStarted(Drawable placeholder) {
+    // Do nothing.
+  }
+
+  /**
+   * A callback that should never be invoked directly.
+   */
+  @Override
+  public synchronized void onLoadFailed(Drawable errorDrawable) {
+    loadFailed = true;
+    waiter.notifyAll(this);
+  }
+
+  /**
+   * A callback that should never be invoked directly.
+   */
+  @Override
+  public synchronized void onResourceReady(R resource, Transition<? super R> transition) {
+    // We might get a null result.
+    resultReceived = true;
+    this.resource = resource;
+    waiter.notifyAll(this);
+  }
+
+  private synchronized R doGet(Long timeoutMillis)
+      throws ExecutionException, InterruptedException, TimeoutException {
+    if (assertBackgroundThread) {
+      Util.assertBackgroundThread();
+    }
+
+    if (isCancelled) {
+      throw new CancellationException();
+    } else if (loadFailed) {
+      throw new ExecutionException(new IllegalStateException("Load failed"));
+    } else if (resultReceived) {
+      return resource;
+    }
+
+    if (timeoutMillis == null) {
+      waiter.waitForTimeout(this, 0);
+    } else if (timeoutMillis > 0) {
+      waiter.waitForTimeout(this, timeoutMillis);
+    }
+
+    if (Thread.interrupted()) {
+      throw new InterruptedException();
+    } else if (loadFailed) {
+      throw new ExecutionException(new IllegalStateException("Load failed"));
+    } else if (isCancelled) {
+      throw new CancellationException();
+    } else if (!resultReceived) {
+      throw new TimeoutException();
+    }
+
+    return resource;
+  }
+
+  /**
+   * A callback that should never be invoked directly.
+   */
+  @Override
+  public void run() {
+    if (request != null) {
+      request.clear();
+      request = null;
+    }
+  }
+
+  private void clearOnMainThread() {
+    mainHandler.post(this);
+  }
+
+  @Override
+  public void onStart() {
+    // Do nothing.
+  }
+
+  @Override
+  public void onStop() {
+    // Do nothing.
+  }
+
+  @Override
+  public void onDestroy() {
+    // Do nothing.
+  }
+
+  // Visible for testing.
+  static class Waiter {
+
+    public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
+      toWaitOn.wait(timeoutMillis);
+    }
+
+    public void notifyAll(Object toNotify) {
+      toNotify.notifyAll();
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index 4719a8a02..0bde3e95a 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -1,61 +1,66 @@
 package com.bumptech.glide.request;
 
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.Target;
 
 /**
  * A class for monitoring the status of a request while images load.
  *
- * @param <T> The type of the model being loaded.
  * @param <R> The type of resource being loaded.
  */
-public interface RequestListener<T, R> {
+public interface RequestListener<R> {
 
-    /**
-     * Called when an exception occurs during a load. Will only be called if we currently want to display an image
-     * for the given model in the given target. It is recommended to create a single instance per activity/fragment
-     * rather than instantiate a new object for each call to {@code Glide.load()} to avoid object churn.
-     *
-     * <p>
-     *     It is safe to reload this or a different model or change what is displayed in the target at this point.
-     *     For example:
-     * <pre>
-     * {@code
-     * public void onException(Exception e, T model, Target target, boolean isFirstResource) {
-     *     target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
-     *     Glide.load(model).into(target);
-     * }
-     * }
-     * </pre>
-     * </p>
-     *
-     * <p>
-     *     Note - if you want to reload this or any other model after an exception, you will need to include all
-     *     relevant builder calls (like centerCrop, placeholder etc).
-     * </p>
-     *
-     * @param e The exception, or null.
-     * @param model The model we were trying to load when the exception occurred.
-     * @param target The {@link Target} we were trying to load the image into.
-     * @param isFirstResource True if this exception is for the first resource to load.
-     * @return True if the listener has handled updating the target for the given exception, false to allow
-     *         Glide's request to update the target.
-     */
-    boolean onException(Exception e, T model, Target<R> target, boolean isFirstResource);
+  /**
+   * Called when an exception occurs during a load. Will only be called if we currently want to
+   * display an image for the given model in the given target. It is recommended to create a single
+   * instance per activity/fragment rather than instantiate a new object for each call to {@code
+   * Glide.load()} to avoid object churn.
+   *
+   * <p> It is safe to reload this or a different model or change what is displayed in the target at
+   * this point. For example:
+   * <pre>
+   * {@code
+   * public void onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
+   *     target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
+   *     Glide.load(model).into(target);
+   * }
+   * }
+   * </pre>
+   * </p>
+   *
+   * <p> Note - if you want to reload this or any other model after an exception, you will need to
+   * include all relevant builder calls (like centerCrop, placeholder etc). </p>
+   *
+   * @param e               The maybe {@code null} exception containing information about why the
+   *                        request failed.
+   * @param model           The model we were trying to load when the exception occurred.
+   * @param target          The {@link Target} we were trying to load the image into.
+   * @param isFirstResource {@code true} if this exception is for the first resource to load.
+   * @return {@code true} if the listener has handled updating the target for the given exception,
+   *         {@code false} to allow Glide's request to update the target.
+   */
+  boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
+      boolean isFirstResource);
 
-    /**
-     * Called when a load completes successfully, immediately after
-     * {@link Target#onResourceReady(Object, com.bumptech.glide.request.animation.GlideAnimation)}.
-     *
-     * @param resource The resource that was loaded for the target.
-     * @param model The specific model that was used to load the image.
-     * @param target The target the model was loaded into.
-     * @param isFromMemoryCache True if the load completed synchronously (useful for determining whether or not to
-     *                          animate)
-     * @param isFirstResource True if this is the first resource to in this load to be loaded into the target. For
-     *                        example when loading a thumbnail and a fullsize image, this will be true for the first
-     *                        image to load and false for the second.
-     * @return True if the listener has handled setting the resource on the target (including any animations), false to
-     *         allow Glide's request to update the target (again including animations).
-     */
-    boolean onResourceReady(R resource, T model, Target<R> target, boolean isFromMemoryCache, boolean isFirstResource);
+  /**
+   * Called when a load completes successfully, immediately after {@link
+   * Target#onResourceReady(Object, com.bumptech.glide.request.transition.Transition)}.
+   *
+   * @param resource          The resource that was loaded for the target.
+   * @param model             The specific model that was used to load the image.
+   * @param target            The target the model was loaded into.
+   * @param dataSource        The {@link DataSource} the resource was loaded from.
+   * @param isFirstResource   {@code true} if this is the first resource to in this load to be
+   *                          loaded into the target. For example when loading a thumbnail and a
+   *                          full-sized image, this will be {@code true} for the first image to
+   *                          load and {@code false} for the second.
+   * @return {@code true} if the listener has handled setting the resource on the target,
+   *         {@code false} to allow Glide's request to update the target.
+   *         Setting the resource includes handling animations, be sure to take that into account.
+   */
+  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,
+      boolean isFirstResource);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
new file mode 100644
index 000000000..6e8aa1e65
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -0,0 +1,242 @@
+package com.bumptech.glide.request;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+
+/**
+ * The standard concrete implementation of {@link com.bumptech.glide.request.BaseRequestOptions}.
+ *
+ * <p> Uses with custom types, transformations, or options can subclass and customize. {@link
+ * com.bumptech.glide.request.BaseRequestOptions}. </p>
+ */
+@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
+public final class RequestOptions extends BaseRequestOptions<RequestOptions> {
+
+  private static RequestOptions skipMemoryCacheTrueOptions;
+  private static RequestOptions skipMemoryCacheFalseOptions;
+  private static RequestOptions fitCenterOptions;
+  private static RequestOptions centerCropOptions;
+  private static RequestOptions circleCropOptions;
+  private static RequestOptions noTransformOptions;
+  private static RequestOptions noAnimationOptions;
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
+   */
+  public static RequestOptions sizeMultiplierOf(float sizeMultiplier) {
+    return new RequestOptions().sizeMultiplier(sizeMultiplier);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
+   */
+  public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {
+    return new RequestOptions().diskCacheStrategy(diskCacheStrategy);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #priority(Priority)}} set.
+   */
+  public static RequestOptions priorityOf(@NonNull Priority priority) {
+    return new RequestOptions().priority(priority);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set.
+   */
+  public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
+    return new RequestOptions().placeholder(placeholder);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
+   */
+  public static RequestOptions placeholderOf(int placeholderId) {
+    return new RequestOptions().placeholder(placeholderId);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #error(Drawable)} set.
+   */
+  public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
+    return new RequestOptions().error(errorDrawable);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
+   */
+  public static RequestOptions errorOf(int errorId) {
+    return new RequestOptions().error(errorId);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set.
+   */
+  public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    if (skipMemoryCache) {
+      if (skipMemoryCacheTrueOptions == null) {
+        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoLock();
+      }
+      return skipMemoryCacheTrueOptions;
+    } else {
+      if (skipMemoryCacheFalseOptions == null) {
+        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoLock();
+      }
+      return skipMemoryCacheFalseOptions;
+    }
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #override(int, int)}} set.
+   */
+  public static RequestOptions overrideOf(int width, int height) {
+    return new RequestOptions().override(width, height);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} with {@link #override(int, int)} set where both the width and
+   * height are the given size.
+   */
+  public static RequestOptions overrideOf(int size) {
+    return overrideOf(size, size);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #signature} set.
+   */
+  public static RequestOptions signatureOf(@NonNull Key signature) {
+    return new RequestOptions().signature(signature);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #fitCenter(Context)} set.
+   */
+  public static RequestOptions fitCenterTransform(Context context) {
+    if (fitCenterOptions == null) {
+      fitCenterOptions = new RequestOptions()
+          .fitCenter(context.getApplicationContext())
+          .autoLock();
+    }
+    return fitCenterOptions;
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #circleCrop(Context)} set.
+   */
+  public static RequestOptions centerCropTransform(Context context) {
+    if (centerCropOptions == null) {
+      centerCropOptions = new RequestOptions()
+          .centerCrop(context.getApplicationContext())
+          .autoLock();
+    }
+    return centerCropOptions;
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop(Context)} set.
+   */
+  public static RequestOptions circleCropTransform(Context context) {
+    if (circleCropOptions == null) {
+      circleCropOptions = new RequestOptions()
+          .circleCrop(context.getApplicationContext())
+          .autoLock();
+    }
+    return circleCropOptions;
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #transform(Context, Transformation)} set.
+   */
+  public static RequestOptions bitmapTransform(Context context,
+      @NonNull Transformation<Bitmap> transformation) {
+    return new RequestOptions().transform(context, transformation);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
+   */
+  public static RequestOptions noTransform() {
+    if (noTransformOptions == null) {
+      noTransformOptions = new RequestOptions()
+          .dontTransform()
+          .autoLock();
+    }
+    return noTransformOptions;
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with the given {@link Option} set via
+   * {@link #set(Option, Object)}.
+   */
+  public static <T> RequestOptions option(@NonNull Option<T> option, @NonNull T value) {
+    return new RequestOptions().set(option, value);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #decode(Class)} set.
+   */
+  public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
+    return new RequestOptions().decode(resourceClass);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set.
+   */
+  public static RequestOptions formatOf(@NonNull DecodeFormat format) {
+    return new RequestOptions().format(format);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #frame(long)} set.
+   */
+  public static RequestOptions frameOf(long frameTimeMicros) {
+    return new RequestOptions().frame(frameTimeMicros);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set.
+   */
+  public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
+    return new RequestOptions().downsample(strategy);
+  }
+
+  /**
+   * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
+   * #encodeQuality(int)} called with the given quality.
+   */
+  public static RequestOptions encodeQualityOf(int quality) {
+    return new RequestOptions().encodeQuality(quality);
+  }
+
+  /**
+   * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
+   * #encodeFormat(android.graphics.Bitmap.CompressFormat)} called with the given format.
+   */
+  public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
+    return new RequestOptions().encodeFormat(format);
+  }
+
+  /**
+   * Returns a new {@link com.bumptech.glide.request.RequestOptions} with {@link #dontAnimate()}
+   * called.
+   */
+  public static RequestOptions noAnimation() {
+    if (noAnimationOptions == null) {
+      noAnimationOptions = new RequestOptions()
+          .dontAnimate()
+          .autoLock();
+    }
+    return noAnimationOptions;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java b/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
index 570477463..ed1ec1063 100644
--- a/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
+++ b/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
@@ -1,24 +1,26 @@
 package com.bumptech.glide.request;
 
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
- * A callback that listens for when a resource load completes successfully or fails due to an exception.
+ * A callback that listens for when a resource load completes successfully or fails due to an
+ * exception.
  */
 public interface ResourceCallback {
 
-    /**
-     * Called when a resource is successfully loaded.
-     *
-     * @param resource The loaded resource.
-     */
-    void onResourceReady(Resource<?> resource);
+  /**
+   * Called when a resource is successfully loaded.
+   *
+   * @param resource The loaded resource.
+   */
+  void onResourceReady(Resource<?> resource, DataSource dataSource);
 
-    /**
-     * Called when a resource fails to load successfully.
-     *
-     * @param e The exception that caused the failure, or null it the load failed for some reason other than an
-     *          exception.
-     */
-    void onException(Exception e);
+  /**
+   * Called when a resource fails to load successfully.
+   *
+   * @param e a non-null {@link GlideException}.
+   */
+  void onLoadFailed(GlideException e);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
new file mode 100644
index 000000000..3798a2300
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -0,0 +1,510 @@
+package com.bumptech.glide.request;
+
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.support.v4.content.res.ResourcesCompat;
+import android.support.v4.util.Pools;
+import android.util.Log;
+
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Util;
+import com.bumptech.glide.util.pool.FactoryPools;
+import com.bumptech.glide.util.pool.StateVerifier;
+
+/**
+ * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given
+ * {@link Target}.
+ *
+ * @param <R> The type of the resource that will be transcoded from the loaded resource.
+ */
+public final class SingleRequest<R> implements Request,
+    SizeReadyCallback,
+    ResourceCallback,
+    FactoryPools.Poolable {
+  /** Tag for logging internal events, not generally suitable for public use. */
+  private static final String TAG = "Request";
+  /** Tag for logging externally useful events (request completion, timing etc). */
+  private static final String GLIDE_TAG = "Glide";
+  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.simple(150,
+      new FactoryPools.Factory<SingleRequest<?>>() {
+        @Override
+        public SingleRequest<?> create() {
+          return new SingleRequest<Object>();
+        }
+      });
+
+  private enum Status {
+    /**
+     * Created but not yet running.
+     */
+    PENDING,
+    /**
+     * In the process of fetching media.
+     */
+    RUNNING,
+    /**
+     * Waiting for a callback given to the Target to be called to determine target dimensions.
+     */
+    WAITING_FOR_SIZE,
+    /**
+     * Finished loading media successfully.
+     */
+    COMPLETE,
+    /**
+     * Failed to load media, may be restarted.
+     */
+    FAILED,
+    /**
+     * Cancelled by the user, may not be restarted.
+     */
+    CANCELLED,
+    /**
+     * Cleared by the user with a placeholder set, may not be restarted.
+     */
+    CLEARED,
+    /**
+     * Temporarily paused by the system, may be restarted.
+     */
+    PAUSED,
+  }
+
+  private final String tag = String.valueOf(hashCode());
+  private final StateVerifier stateVerifier = StateVerifier.newInstance();
+
+  private RequestCoordinator requestCoordinator;
+  private GlideContext glideContext;
+  private Object model;
+  private Class<R> transcodeClass;
+  private BaseRequestOptions<?> requestOptions;
+  private int overrideWidth;
+  private int overrideHeight;
+  private Priority priority;
+  private Target<R> target;
+  private RequestListener<R> requestListener;
+  private Engine engine;
+  private TransitionFactory<? super R> animationFactory;
+  private Resource<R> resource;
+  private Engine.LoadStatus loadStatus;
+  private long startTime;
+  private Status status;
+  private Drawable errorDrawable;
+  private Drawable placeholderDrawable;
+  private Drawable fallbackDrawable;
+  private int width;
+  private int height;
+
+  public static <R> SingleRequest<R> obtain(
+      GlideContext glideContext,
+      Object model,
+      Class<R> transcodeClass,
+      BaseRequestOptions<?> requestOptions,
+      int overrideWidth,
+      int overrideHeight,
+      Priority priority,
+      Target<R> target,
+      RequestListener<R> requestListener,
+      RequestCoordinator requestCoordinator,
+      Engine engine,
+      TransitionFactory<? super R> animationFactory) {
+    @SuppressWarnings("unchecked") SingleRequest<R> request =
+        (SingleRequest<R>) POOL.acquire();
+    if (request == null) {
+      request = new SingleRequest<>();
+    }
+    request.init(
+        glideContext,
+        model,
+        transcodeClass,
+        requestOptions,
+        overrideWidth,
+        overrideHeight,
+        priority,
+        target,
+        requestListener,
+        requestCoordinator,
+        engine,
+        animationFactory);
+    return request;
+  }
+
+  private SingleRequest() {
+    // just create, instances are reused with recycle/init
+  }
+
+  private void init(
+      GlideContext glideContext,
+      Object model,
+      Class<R> transcodeClass,
+      BaseRequestOptions<?> requestOptions,
+      int overrideWidth,
+      int overrideHeight,
+      Priority priority,
+      Target<R> target,
+      RequestListener<R> requestListener,
+      RequestCoordinator requestCoordinator,
+      Engine engine,
+      TransitionFactory<? super R> animationFactory) {
+    this.glideContext = glideContext;
+    this.model = model;
+    this.transcodeClass = transcodeClass;
+    this.requestOptions = requestOptions;
+    this.overrideWidth = overrideWidth;
+    this.overrideHeight = overrideHeight;
+    this.priority = priority;
+    this.target = target;
+    this.requestListener = requestListener;
+    this.requestCoordinator = requestCoordinator;
+    this.engine = engine;
+    this.animationFactory = animationFactory;
+    status = Status.PENDING;
+  }
+
+  @Override
+  public StateVerifier getVerifier() {
+    return stateVerifier;
+  }
+
+  @Override
+  public void recycle() {
+    glideContext = null;
+    model = null;
+    transcodeClass = null;
+    requestOptions = null;
+    overrideWidth = -1;
+    overrideHeight = -1;
+    target = null;
+    requestListener = null;
+    requestCoordinator = null;
+    animationFactory = null;
+    loadStatus = null;
+    errorDrawable = null;
+    placeholderDrawable = null;
+    fallbackDrawable = null;
+    width = -1;
+    height = -1;
+    POOL.release(this);
+  }
+
+  @Override
+  public void begin() {
+    stateVerifier.throwIfRecycled();
+    startTime = LogTime.getLogTime();
+    if (model == null) {
+      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+        width = overrideWidth;
+        height = overrideHeight;
+      }
+      onLoadFailed(new GlideException("Received null model"));
+      return;
+    }
+
+    status = Status.WAITING_FOR_SIZE;
+    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+      onSizeReady(overrideWidth, overrideHeight);
+    } else {
+      target.getSize(this);
+    }
+
+    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
+        && canNotifyStatusChanged()) {
+      target.onLoadStarted(getPlaceholderDrawable());
+    }
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      logV("finished run method in " + LogTime.getElapsedMillis(startTime));
+    }
+  }
+
+  /**
+   * Cancels the current load but does not release any resources held by the request and continues
+   * to display the loaded resource if the load completed before the call to cancel.
+   *
+   * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
+   *
+   * @see #clear()
+   */
+  void cancel() {
+    stateVerifier.throwIfRecycled();
+    status = Status.CANCELLED;
+    if (loadStatus != null) {
+      loadStatus.cancel();
+      loadStatus = null;
+    }
+  }
+
+  /**
+   * Cancels the current load if it is in progress, clears any resources held onto by the request
+   * and replaces the loaded resource if the load completed with the placeholder.
+   *
+   * <p> Cleared requests can be restarted with a subsequent call to {@link #begin()} </p>
+   *
+   * @see #cancel()
+   */
+  @Override
+  public void clear() {
+    Util.assertMainThread();
+    if (status == Status.CLEARED) {
+      return;
+    }
+    cancel();
+    // Resource must be released before canNotifyStatusChanged is called.
+    if (resource != null) {
+      releaseResource(resource);
+    }
+    if (canNotifyStatusChanged()) {
+      target.onLoadCleared(getPlaceholderDrawable());
+    }
+    // Must be after cancel().
+    status = Status.CLEARED;
+  }
+
+  @Override
+  public boolean isPaused() {
+    return status == Status.PAUSED;
+  }
+
+  @Override
+  public void pause() {
+    clear();
+    status = Status.PAUSED;
+  }
+
+  private void releaseResource(Resource resource) {
+    engine.release(resource);
+    this.resource = null;
+  }
+
+  @Override
+  public boolean isRunning() {
+    return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
+  }
+
+  @Override
+  public boolean isComplete() {
+    return status == Status.COMPLETE;
+  }
+
+  @Override
+  public boolean isResourceSet() {
+    return isComplete();
+  }
+
+  @Override
+  public boolean isCancelled() {
+    return status == Status.CANCELLED || status == Status.CLEARED;
+  }
+
+  @Override
+  public boolean isFailed() {
+    return status == Status.FAILED;
+  }
+
+  private Drawable getErrorDrawable() {
+    if (errorDrawable == null) {
+      errorDrawable = requestOptions.getErrorPlaceholder();
+      if (errorDrawable == null && requestOptions.getErrorId() > 0) {
+        errorDrawable = loadDrawable(requestOptions.getErrorId());
+      }
+    }
+    return errorDrawable;
+  }
+
+  private Drawable getPlaceholderDrawable() {
+     if (placeholderDrawable == null) {
+      placeholderDrawable = requestOptions.getPlaceholderDrawable();
+      if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
+        placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
+      }
+    }
+    return placeholderDrawable;
+  }
+
+  private Drawable getFallbackDrawable() {
+    if (fallbackDrawable == null) {
+      fallbackDrawable = requestOptions.getFallbackDrawable();
+      if (fallbackDrawable == null && requestOptions.getFallbackId() > 0) {
+        fallbackDrawable = loadDrawable(requestOptions.getFallbackId());
+      }
+    }
+    return fallbackDrawable;
+  }
+
+  private Drawable loadDrawable(int resouceId) {
+    Resources resources = glideContext.getResources();
+    return ResourcesCompat.getDrawable(resources, resouceId, requestOptions.getTheme());
+  }
+
+  private void setErrorPlaceholder() {
+    if (!canNotifyStatusChanged()) {
+      return;
+    }
+
+    Drawable error = model == null ? getFallbackDrawable() : getErrorDrawable();
+    if (error == null) {
+      error = getPlaceholderDrawable();
+    }
+    target.onLoadFailed(error);
+  }
+
+  /**
+   * A callback method that should never be invoked directly.
+   */
+  @Override
+  public void onSizeReady(int width, int height) {
+    stateVerifier.throwIfRecycled();
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
+    }
+    if (status != Status.WAITING_FOR_SIZE) {
+      return;
+    }
+    status = Status.RUNNING;
+
+    float sizeMultiplier = requestOptions.getSizeMultiplier();
+    this.width = Math.round(sizeMultiplier * width);
+    this.height = Math.round(sizeMultiplier * height);
+
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
+    }
+    loadStatus = engine.load(
+        glideContext,
+        model,
+        requestOptions.getSignature(),
+        this.width,
+        this.height,
+        requestOptions.getResourceClass(),
+        transcodeClass,
+        priority,
+        requestOptions.getDiskCacheStrategy(),
+        requestOptions.getTransformations(),
+        requestOptions.isTransformationRequired(),
+        requestOptions.getOptions(),
+        requestOptions.isMemoryCacheable(),
+        this);
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
+    }
+  }
+
+  private boolean canSetResource() {
+    return requestCoordinator == null || requestCoordinator.canSetImage(this);
+  }
+
+  private boolean canNotifyStatusChanged() {
+    return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
+  }
+
+  private boolean isFirstReadyResource() {
+    return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
+  }
+
+  private void notifyLoadSuccess() {
+    if (requestCoordinator != null) {
+      requestCoordinator.onRequestSuccess(this);
+    }
+  }
+
+  /**
+   * A callback method that should never be invoked directly.
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  public void onResourceReady(Resource<?> resource, DataSource dataSource) {
+    stateVerifier.throwIfRecycled();
+    loadStatus = null;
+    if (resource == null) {
+      GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
+          + "object of " + transcodeClass + " inside, but instead got null.");
+      onLoadFailed(exception);
+      return;
+    }
+
+    Object received = resource.get();
+    if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
+      releaseResource(resource);
+      GlideException exception = new GlideException("Expected to receive an object of "
+          + transcodeClass + " but instead" + " got "
+          + (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
+          + "Resource{" + resource + "}."
+          + (received != null ? "" : " " + "To indicate failure return a null Resource "
+          + "object, rather than a Resource object containing null data."));
+      onLoadFailed(exception);
+      return;
+    }
+
+    if (!canSetResource()) {
+      releaseResource(resource);
+      // We can't put the status to complete before asking canSetResource().
+      status = Status.COMPLETE;
+      return;
+    }
+
+    onResourceReady((Resource<R>) resource, (R) received, dataSource);
+  }
+
+  /**
+   * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
+   *
+   * @param resource original {@link Resource}, never <code>null</code>
+   * @param result   object returned by {@link Resource#get()}, checked for type and never
+   *                 <code>null</code>
+   */
+  private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
+    // We must call isFirstReadyResource before setting status.
+    boolean isFirstResource = isFirstReadyResource();
+    status = Status.COMPLETE;
+    this.resource = resource;
+
+    if (glideContext.getLogLevel() <= Log.DEBUG) {
+      Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
+          + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
+          + LogTime.getElapsedMillis(startTime) + " ms");
+    }
+
+    if (requestListener == null
+        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
+      Transition<? super R> animation =
+          animationFactory.build(dataSource, isFirstResource);
+      target.onResourceReady(result, animation);
+    }
+
+    notifyLoadSuccess();
+  }
+
+  /**
+   * A callback method that should never be invoked directly.
+   */
+  @Override
+  public void onLoadFailed(GlideException e) {
+    stateVerifier.throwIfRecycled();
+    int logLevel = glideContext.getLogLevel();
+    if (logLevel <= Log.WARN) {
+      Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
+      if (logLevel <= Log.INFO) {
+        e.logRootCauses(GLIDE_TAG);
+      }
+    }
+
+    loadStatus = null;
+    status = Status.FAILED;
+    //TODO: what if this is a thumbnail request?
+    if (requestListener == null || !requestListener.onLoadFailed(e, model, target,
+        isFirstReadyResource())) {
+      setErrorPlaceholder();
+    }
+  }
+
+  private void logV(String message) {
+    Log.v(TAG, message + " this: " + tag);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index cecda35ba..195c24d69 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -1,151 +1,162 @@
 package com.bumptech.glide.request;
 
+import android.support.annotation.Nullable;
+
 /**
- * A coordinator that coordinates two individual {@link Request}s that load a small thumbnail version of an image and
- * the full size version of the image at the same time.
+ * A coordinator that coordinates two individual {@link Request}s that load a small thumbnail
+ * version of an image and the full size version of the image at the same time.
  */
-public class ThumbnailRequestCoordinator implements RequestCoordinator, Request {
-    private Request full;
-    private Request thumb;
-    private RequestCoordinator coordinator;
-
-    public ThumbnailRequestCoordinator() {
-        this(null);
-    }
-
-    public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
-        this.coordinator = coordinator;
-    }
-
-    public void setRequests(Request full, Request thumb) {
-        this.full = full;
-        this.thumb = thumb;
-    }
-
-    /**
-     *
-     * Returns true if the request is either the request loading the fullsize image or if the request loading the
-     * full size image has not yet completed.
-     *
-     * @param request {@inheritDoc}
-     */
-    @Override
-    public boolean canSetImage(Request request) {
-        return parentCanSetImage() && (request.equals(full) || !full.isResourceSet());
-    }
-
-    private boolean parentCanSetImage() {
-        return coordinator == null || coordinator.canSetImage(this);
-    }
-
-    /**
-     * Returns true if the request is the request loading the fullsize image and if neither the full nor the thumbnail
-     * image have completed sucessfully.
-     *
-     * @param request {@inheritDoc}.
-     */
-    @Override
-    public boolean canNotifyStatusChanged(Request request) {
-        return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
-    }
-
-    private boolean parentCanNotifyStatusChanged() {
-        return coordinator == null || coordinator.canNotifyStatusChanged(this);
-    }
-
-    @Override
-    public boolean isAnyResourceSet() {
-        return parentIsAnyResourceSet() || isResourceSet();
-    }
-
-    @Override
-    public void onRequestSuccess(Request request) {
-        if (request.equals(thumb)) {
-            return;
-        }
-        if (coordinator != null) {
-            coordinator.onRequestSuccess(this);
-        }
-        thumb.clear();
-    }
-
-    private boolean parentIsAnyResourceSet() {
-        return coordinator != null && coordinator.isAnyResourceSet();
-    }
-
-    /**
-     * Starts first the thumb request and then the full request.
-     */
-    @Override
-    public void begin() {
-        if (!thumb.isRunning()) {
-            thumb.begin();
-        }
-        if (!full.isRunning()) {
-            full.begin();
-        }
-    }
-
-    @Override
-    public void pause() {
-        full.pause();
-        thumb.pause();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void clear() {
-        thumb.clear();
-        full.clear();
-    }
-
-    @Override
-    public boolean isPaused() {
-        return full.isPaused();
-    }
-
-    /**
-     * Returns true if the full request is still running.
-     */
-    @Override
-    public boolean isRunning() {
-        return full.isRunning();
-    }
-
-    /**
-     * Returns true if the full request is complete.
-     */
-    @Override
-    public boolean isComplete() {
-        return full.isComplete() || thumb.isComplete();
-    }
-
-    @Override
-    public boolean isResourceSet() {
-        return full.isResourceSet() || thumb.isResourceSet();
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return full.isCancelled();
-    }
-
-    /**
-     * Returns true if the full request has failed.
-     */
-    @Override
-    public boolean isFailed() {
-        return full.isFailed();
-    }
-
-    /**
-     * {@inheritDoc}.
-     */
-    @Override
-    public void recycle() {
-        full.recycle();
-        thumb.recycle();
-    }
+public class ThumbnailRequestCoordinator implements RequestCoordinator,
+    Request {
+  private Request full;
+  private Request thumb;
+  @Nullable private RequestCoordinator coordinator;
+  private boolean isRunning;
+
+  public ThumbnailRequestCoordinator() {
+    this(null);
+  }
+
+  public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
+    this.coordinator = coordinator;
+  }
+
+  public void setRequests(Request full, Request thumb) {
+    this.full = full;
+    this.thumb = thumb;
+  }
+
+  /**
+   * Returns true if the request is either the request loading the fullsize image or if the request
+   * loading the full size image has not yet completed.
+   *
+   * @param request {@inheritDoc}
+   */
+  @Override
+  public boolean canSetImage(Request request) {
+    return parentCanSetImage() && (request.equals(full) || !full.isResourceSet());
+  }
+
+  private boolean parentCanSetImage() {
+    return coordinator == null || coordinator.canSetImage(this);
+  }
+
+  /**
+   * Returns true if the request is the request loading the fullsize image and if neither the full
+   * nor the thumbnail image have completed sucessfully.
+   *
+   * @param request {@inheritDoc}.
+   */
+  @Override
+  public boolean canNotifyStatusChanged(Request request) {
+    return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
+  }
+
+  private boolean parentCanNotifyStatusChanged() {
+    return coordinator == null || coordinator.canNotifyStatusChanged(this);
+  }
+
+  @Override
+  public boolean isAnyResourceSet() {
+    return parentIsAnyResourceSet() || isResourceSet();
+  }
+
+  @Override
+  public void onRequestSuccess(Request request) {
+    if (request.equals(thumb)) {
+      return;
+    }
+    if (coordinator != null) {
+      coordinator.onRequestSuccess(this);
+    }
+    // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
+    // as a layer in a cross fade for example. The only way we know the thumb is not being
+    // displayed and is therefore safe to clear is if the thumb request has not yet completed.
+    if (!thumb.isComplete()) {
+      thumb.clear();
+    }
+  }
+
+  private boolean parentIsAnyResourceSet() {
+    return coordinator != null && coordinator.isAnyResourceSet();
+  }
+
+  /**
+   * Starts first the thumb request and then the full request.
+   */
+  @Override
+  public void begin() {
+    isRunning = true;
+    if (!thumb.isRunning()) {
+      thumb.begin();
+    }
+    if (isRunning && !full.isRunning()) {
+      full.begin();
+    }
+  }
+
+  @Override
+  public void pause() {
+    isRunning = false;
+    full.pause();
+    thumb.pause();
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public void clear() {
+    isRunning = false;
+    thumb.clear();
+    full.clear();
+  }
+
+  @Override
+  public boolean isPaused() {
+    return full.isPaused();
+  }
+
+  /**
+   * Returns true if the full request is still running.
+   */
+  @Override
+  public boolean isRunning() {
+    return full.isRunning();
+  }
+
+  /**
+   * Returns true if the full request is complete.
+   */
+  @Override
+  public boolean isComplete() {
+    return full.isComplete() || thumb.isComplete();
+  }
+
+  @Override
+  public boolean isResourceSet() {
+    return full.isResourceSet() || thumb.isResourceSet();
+  }
+
+  @Override
+  public boolean isCancelled() {
+    return full.isCancelled();
+  }
+
+  /**
+   * Returns true if the full request has failed.
+   */
+  @Override
+  public boolean isFailed() {
+    return full.isFailed();
+  }
+
+  /**
+   * {@inheritDoc}.
+   */
+  @Override
+  public void recycle() {
+    full.recycle();
+    thumb.recycle();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java
deleted file mode 100644
index 5bd3305f3..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import android.content.Context;
-import android.graphics.drawable.Drawable;
-import android.view.animation.AlphaAnimation;
-import android.view.animation.Animation;
-
-/**
- * A factory class that produces a new {@link com.bumptech.glide.request.animation.GlideAnimation} that varies depending
- * on whether or not the drawable was loaded from the memory cache and whether or not the drawable is the first
- * image to be set on the target.
- *
- * <p>
- *     Resources are usually loaded from the memory cache just before the user can see the view,
- *     for example when the user changes screens or scrolls back and forth in a list. In those cases the user
- *     typically does not expect to see an animation. As a result, when the resource is loaded from the memory
- *     cache this factory produces an {@link com.bumptech.glide.request.animation.NoAnimation}.
- * </p>
- *
- * @param <T> The type of the {@link android.graphics.drawable.Drawable} that will be animated.
- */
-public class DrawableCrossFadeFactory<T extends Drawable> implements GlideAnimationFactory<T> {
-    private static final int DEFAULT_DURATION_MS = 300;
-    private final ViewAnimationFactory<T> animationFactory;
-    private final int duration;
-    private DrawableCrossFadeViewAnimation<T> animation;
-
-    public DrawableCrossFadeFactory() {
-        this(DEFAULT_DURATION_MS);
-    }
-
-    public DrawableCrossFadeFactory(int duration) {
-        this(new ViewAnimationFactory<T>(new DefaultAnimationFactory()), duration);
-    }
-
-    public DrawableCrossFadeFactory(Context context, int defaultAnimationId, int duration) {
-        this(new ViewAnimationFactory<T>(context, defaultAnimationId), duration);
-    }
-
-    public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
-        this(new ViewAnimationFactory<T>(defaultAnimation), duration);
-    }
-
-    DrawableCrossFadeFactory(ViewAnimationFactory<T> animationFactory, int duration) {
-        this.animationFactory = animationFactory;
-        this.duration = duration;
-    }
-
-    @Override
-    public GlideAnimation<T> build(boolean isFromMemoryCache, boolean isFirstResource) {
-        if (isFromMemoryCache) {
-            return NoAnimation.get();
-        }
-
-        if (animation == null) {
-            GlideAnimation<T> defaultAnimation = animationFactory.build(false, isFirstResource);
-            animation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
-        }
-
-        return animation;
-    }
-
-    private static class DefaultAnimationFactory implements ViewAnimation.AnimationFactory {
-
-        @Override
-        public Animation build() {
-            AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-            animation.setDuration(DEFAULT_DURATION_MS / 2);
-            return animation;
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimation.java b/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimation.java
deleted file mode 100644
index a721aa1c8..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimation.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.TransitionDrawable;
-
-/**
- * A cross fade {@link GlideAnimation} for {@link android.graphics.drawable.Drawable}s
- * that uses an {@link android.graphics.drawable.TransitionDrawable} to transition from an existing drawable
- * already visible on the target to a new drawable. If no existing drawable exists, this class can instead fall back
- * to a default animation that doesn't rely on {@link android.graphics.drawable.TransitionDrawable}.
- *
- * @param <T> The type of the {@link android.graphics.drawable.Drawable} that will be animated.
- */
-public class DrawableCrossFadeViewAnimation<T extends Drawable> implements GlideAnimation<T> {
-    private final GlideAnimation<T> defaultAnimation;
-    private final int duration;
-
-    /**
-     * Constructor that takes a default animation and a duration in milliseconds that the cross fade animation should
-     * last.
-     * @param duration The duration that the cross fade animation should run if there is something to cross fade from
-     *                 when a new {@link android.graphics.drawable.Drawable} is set.
-     */
-    public DrawableCrossFadeViewAnimation(GlideAnimation<T> defaultAnimation, int duration) {
-        this.defaultAnimation = defaultAnimation;
-        this.duration = duration;
-    }
-
-    /**
-     * Animates from the previous drawable to the current drawable in one of two ways.
-     *
-     * <ol>
-     *     <li>Using the default animation provided in the constructor if the previous drawable is null</li>
-     *     <li>Using the cross fade animation with the duration provided in the constructor if the previous
-     *     drawable is non null</li>
-     * </ol>
-     *
-     * @param current {@inheritDoc}
-     * @param adapter  {@inheritDoc}
-     * @return {@inheritDoc}
-     */
-    @Override
-    public boolean animate(T current, ViewAdapter adapter) {
-        Drawable previous = adapter.getCurrentDrawable();
-        if (previous != null) {
-            TransitionDrawable transitionDrawable = new TransitionDrawable(new Drawable[] { previous, current });
-            transitionDrawable.setCrossFadeEnabled(true);
-            transitionDrawable.startTransition(duration);
-            adapter.setDrawable(transitionDrawable);
-            return true;
-        } else {
-            defaultAnimation.animate(current, adapter);
-            return false;
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/GlideAnimation.java b/library/src/main/java/com/bumptech/glide/request/animation/GlideAnimation.java
deleted file mode 100644
index 9cf865e19..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/GlideAnimation.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import android.graphics.drawable.Drawable;
-import android.view.View;
-
-/**
- * An interface that allows a transformation to be applied to {@link android.view.View}s in
- * {@link com.bumptech.glide.request.target.Target}s in across resource types. Targets that wrap views will be able to
- * provide all of the necessary arguments and start the animation. Those that do not will be unable to provide the
- * necessary arguments and will therefore be forced to ignore the animation. This interface is a compromise that
- * allows view animations in Glide's complex world of arbitrary resource types and arbitrary target types.
- *
- * @param <R> The type of the resource that should be animated to.
- */
-public interface GlideAnimation<R> {
-
-    /**
-     * An interface wrapping a view that exposes the necessary methods to run the various types of android animations
-     * ({@link com.bumptech.glide.request.animation.ViewAnimation},
-     * {@link com.bumptech.glide.request.animation.ViewPropertyAnimation} and animated
-     * {@link android.graphics.drawable.Drawable}s).
-     */
-    interface ViewAdapter {
-        /**
-         * Returns the wrapped {@link android.view.View}.
-         */
-        View getView();
-
-        /**
-         * Returns the current drawable being displayed in the view, or null if no such drawable exists (or one cannot
-         * be retrieved).
-         */
-        Drawable getCurrentDrawable();
-
-        /**
-         * Sets the current drawable (usually an animated drawable) to display in the wrapped view.
-         *
-         * @param drawable The drawable to display in the wrapped view.
-         */
-        void setDrawable(Drawable drawable);
-    }
-
-    /**
-     * Animates from the previous {@link android.graphics.drawable.Drawable} that is currently being displayed in the
-     * given view, if not null, to the new resource that should be displayed in the view.
-     *
-     * @param current The new resource that will be displayed in the view.
-     * @param adapter The {@link com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter} wrapping a view that
-     *                can at least return an {@link android.view.View} from
-     *                {@link com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter#getView()}.
-     * @return True if int he process of running the animation the new resource was set on the view, false if the caller
-     * needs to manually set the current resource on the view.
-     */
-    boolean animate(R current, ViewAdapter adapter);
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/GlideAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/animation/GlideAnimationFactory.java
deleted file mode 100644
index 83ae6136a..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/GlideAnimationFactory.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-/**
- * A factory class that can produce different {@link com.bumptech.glide.request.animation.GlideAnimation}s based on the
- * state of the request.
- * @param <R> The type of resource that needs to be animated into the target.
- */
-public interface GlideAnimationFactory<R> {
-
-    /**
-     * Returns a new {@link com.bumptech.glide.request.animation.GlideAnimation}.
-     *
-     * @param isFromMemoryCache True if this will be an animation for a resource that was loaded from the memory cache.
-     * @param isFirstResource True if this is the first resource to be loaded into the target.
-     */
-    GlideAnimation<R> build(boolean isFromMemoryCache, boolean isFirstResource);
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/NoAnimation.java b/library/src/main/java/com/bumptech/glide/request/animation/NoAnimation.java
deleted file mode 100644
index aeec01d46..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/NoAnimation.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-/**
- * A simple {@link com.bumptech.glide.request.animation.GlideAnimation} that performs no actions.
- *
- * @param <R> animated resource type
- */
-public class NoAnimation<R> implements GlideAnimation<R> {
-    private static final NoAnimation<?> NO_ANIMATION = new NoAnimation<Object>();
-    @SuppressWarnings("rawtypes")
-    private static final GlideAnimationFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
-
-    /**
-     * A factory that always returns the same {@link com.bumptech.glide.request.animation.NoAnimation}.
-     */
-    public static class NoAnimationFactory<R> implements GlideAnimationFactory<R> {
-        @SuppressWarnings("unchecked")
-        @Override
-        public GlideAnimation<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
-            return (GlideAnimation<R>) NO_ANIMATION;
-        }
-    }
-
-    /**
-     * Returns an instance of a factory that produces {@link com.bumptech.glide.request.animation.NoAnimation}s.
-     */
-    @SuppressWarnings("unchecked")
-    public static <R> GlideAnimationFactory<R> getFactory() {
-        return (GlideAnimationFactory<R>) NO_ANIMATION_FACTORY;
-    }
-
-    /**
-     * Returns an instance of {@link com.bumptech.glide.request.animation.NoAnimation}.
-     */
-    @SuppressWarnings("unchecked")
-    public static <R> GlideAnimation<R> get() {
-        return (GlideAnimation<R>) NO_ANIMATION;
-    }
-
-    /**
-     * Performs no animation and always returns {@code false}.
-     */
-    @Override
-    public boolean animate(Object current, ViewAdapter adapter) {
-        return false;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimation.java b/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimation.java
deleted file mode 100644
index 7f62719db..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimation.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import android.view.View;
-import android.view.animation.Animation;
-
-/**
- * A {@link com.bumptech.glide.request.animation.GlideAnimation GlideAnimation} that can apply a
- * {@link android.view.animation.Animation Animation} to a {@link android.view.View View} using
- * {@link android.view.View#startAnimation(android.view.animation.Animation) View.startAnimation}.
- *
- * @param <R> The type of the resource displayed in the view that is animated
- */
-public class ViewAnimation<R> implements GlideAnimation<R> {
-
-    private final AnimationFactory animationFactory;
-
-    /**
-     * Constructs a new ViewAnimation that will start the given {@link android.view.animation.Animation}.
-     */
-    ViewAnimation(AnimationFactory animationFactory) {
-        this.animationFactory = animationFactory;
-    }
-
-    /**
-     * Always clears the current animation on the view using {@link android.view.View#clearAnimation()}, then
-     * starts the {@link android.view.animation.Animation} given in the constructor using
-     * {@link android.view.View#startAnimation(android.view.animation.Animation)} and then returns {@code false} because
-     * the animation does not actually set the current resource on the view.
-     *
-     * @param current {@inheritDoc}
-     * @param adapter {@inheritDoc}
-     * @return {@inheritDoc}
-     */
-    @Override
-    public boolean animate(R current, ViewAdapter adapter) {
-        View view = adapter.getView();
-        if (view != null) {
-            view.clearAnimation();
-            Animation animation = animationFactory.build();
-            view.startAnimation(animation);
-        }
-
-        return false;
-    }
-
-    interface AnimationFactory {
-        Animation build();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimationFactory.java
deleted file mode 100644
index df2761aa7..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimationFactory.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import android.content.Context;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-
-/**
- * A {@link com.bumptech.glide.request.animation.GlideAnimationFactory} that produces
- * {@link com.bumptech.glide.request.animation.ViewAnimation}s.
- *
- * @param <R> The type of the resource displayed in the view that is animated
- */
-public class ViewAnimationFactory<R> implements GlideAnimationFactory<R> {
-    private final ViewAnimation.AnimationFactory animationFactory;
-    private GlideAnimation<R> glideAnimation;
-
-    public ViewAnimationFactory(Animation animation) {
-        this(new ConcreteAnimationFactory(animation));
-    }
-
-    public ViewAnimationFactory(Context context, int animationId) {
-        this(new ResourceAnimationFactory(context, animationId));
-    }
-
-    ViewAnimationFactory(ViewAnimation.AnimationFactory animationFactory) {
-        this.animationFactory = animationFactory;
-    }
-
-    /**
-     * Returns a new {@link com.bumptech.glide.request.animation.GlideAnimation} for the given arguments. If
-     * isFromMemoryCache is {@code true} or isFirstImage is {@code false}, returns a
-     * {@link com.bumptech.glide.request.animation.NoAnimation} and otherwise returns a new
-     * {@link com.bumptech.glide.request.animation.ViewAnimation}.
-     *
-     * @param isFromMemoryCache {@inheritDoc}
-     * @param isFirstResource   {@inheritDoc}
-     */
-    @Override
-    public GlideAnimation<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
-        if (isFromMemoryCache || !isFirstResource) {
-            return NoAnimation.get();
-        }
-
-        if (glideAnimation == null) {
-            glideAnimation = new ViewAnimation<R>(animationFactory);
-        }
-
-        return glideAnimation;
-    }
-
-    private static class ConcreteAnimationFactory implements ViewAnimation.AnimationFactory {
-        private final Animation animation;
-
-        public ConcreteAnimationFactory(Animation animation) {
-            this.animation = animation;
-        }
-
-        @Override
-        public Animation build() {
-            return animation;
-        }
-    }
-
-    private static class ResourceAnimationFactory implements ViewAnimation.AnimationFactory {
-        private final Context context;
-        private final int animationId;
-
-        public ResourceAnimationFactory(Context context, int animationId) {
-            this.context = context.getApplicationContext();
-            this.animationId = animationId;
-        }
-
-        @Override
-        public Animation build() {
-            return AnimationUtils.loadAnimation(context, animationId);
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimation.java b/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimation.java
deleted file mode 100644
index 6b42e81f4..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimation.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-import android.view.View;
-
-/**
- * A {@link com.bumptech.glide.request.animation.GlideAnimation GlideAnimation} that accepts an interface
- * that can apply an animation like a {@link android.view.ViewPropertyAnimator}
- * or a {@link android.animation.ObjectAnimator} to an {@link View}.
- *
- * @param <R> The type of the resource displayed in the view that is animated
- */
-public class ViewPropertyAnimation<R> implements GlideAnimation<R> {
-
-    private final Animator animator;
-
-    /**
-     * Constructor for a view property animation that takes an
-     * {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} interface that can apply an animation
-     * to a view.
-     *
-     * @param animator The animator to use.
-     */
-    public ViewPropertyAnimation(Animator animator) {
-        this.animator = animator;
-    }
-
-    /**
-     * Always applies the {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} given in the
-     * constructor to the given view and returns {@code false} because the animator cannot set the new resource on
-     * the view.
-     *
-     * @param current {@inheritDoc}
-     * @param adapter {@inheritDoc}
-     * @return {@inheritDoc}
-     */
-    @Override
-    public boolean animate(R current, ViewAdapter adapter) {
-        final View view = adapter.getView();
-        if (view != null) {
-            animator.animate(adapter.getView());
-        }
-        return false;
-    }
-
-    /**
-     * An interface that allows an animation to be applied on or started from an {@link android.view.View}.
-     */
-    public interface Animator {
-        /**
-         * Starts an animation on the given {@link android.view.View}.
-         *
-         * @param view The view to animate.
-         */
-        void animate(View view);
-    }
-
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactory.java
deleted file mode 100644
index f8c5002fa..000000000
--- a/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactory.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package com.bumptech.glide.request.animation;
-
-/**
- * A {@link GlideAnimationFactory} that produces ViewPropertyAnimations.
- *
- * @param <R> The type of the resource displayed in the view that is animated
- */
-public class ViewPropertyAnimationFactory<R> implements GlideAnimationFactory<R> {
-    private final ViewPropertyAnimation.Animator animator;
-    private ViewPropertyAnimation<R> animation;
-
-    public ViewPropertyAnimationFactory(ViewPropertyAnimation.Animator animator) {
-        this.animator = animator;
-    }
-
-    /**
-     * Returns a new {@link GlideAnimation} for the given arguments. If
-     * isMemoryCache is {@code true} or isFirstImage is {@code false}, returns a
-     * {@link NoAnimation} and otherwise returns a new
-     * {@link ViewPropertyAnimation} for the
-     * {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} provided in the constructor.
-     */
-    @Override
-    public GlideAnimation<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
-        if (isFromMemoryCache || !isFirstResource) {
-            return NoAnimation.get();
-        }
-        if (animation == null) {
-            animation = new ViewPropertyAnimation<R>(animator);
-        }
-
-        return animation;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index 3dc220716..6928462ae 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -6,132 +6,119 @@
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
 
-import com.bumptech.glide.request.animation.GlideAnimation;
-
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
 
 /**
- * This class is used in order to display downloaded Bitmap inside an ImageView
- * of an AppWidget through RemoteViews.
+ * This class is used in order to display downloaded Bitmap inside an ImageView of an AppWidget
+ * through RemoteViews.
  *
- * <p>
- *     Note - For cancellation to work correctly, you must pass in the same instance of this class for every subsequent
- *     load.
- * </p>
+ * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
+ * for every subsequent load. </p>
  */
 public class AppWidgetTarget extends SimpleTarget<Bitmap> {
 
-    private final int[] widgetIds;
-    private final ComponentName componentName;
-    private final RemoteViews remoteViews;
-    private final Context context;
-    private final int viewId;
+  private final int[] widgetIds;
+  private final ComponentName componentName;
+  private final RemoteViews remoteViews;
+  private final Context context;
+  private final int viewId;
 
-    /**
-     * Constructor using an int array of widgetIds to get a handle on the Widget in order to update it.
-     *
-     * @param context     Context to use in the AppWidgetManager initialization.
-     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-     * @param viewId      The id of the ImageView view that will load the image.
-     * @param width       Desired width of the bitmap that will be loaded.(Need to be manually set
-     *                    because of RemoteViews limitations.)
-     * @param height      Desired height of the bitmap that will be loaded. (Need to be manually set
-     *                    because of RemoteViews limitations.)
-     * @param widgetIds   The int[] that contains the widget ids of an application.
-     */
-    public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width, int height,
-            int... widgetIds) {
-        super(width, height);
-        if (context == null) {
-            throw new NullPointerException("Context can not be null!");
-        }
-        if (widgetIds == null) {
-            throw new NullPointerException("WidgetIds can not be null!");
-        }
-        if (widgetIds.length == 0) {
-            throw new IllegalArgumentException("WidgetIds must have length > 0");
-        }
-        if (remoteViews == null) {
-            throw new NullPointerException("RemoteViews object can not be null!");
-        }
-        this.context = context;
-        this.remoteViews = remoteViews;
-        this.viewId = viewId;
-        this.widgetIds = widgetIds;
-        componentName = null;
+  /**
+   * Constructor using an int array of widgetIds to get a handle on the Widget in order to update
+   * it.
+   *
+   * @param context     Context to use in the AppWidgetManager initialization.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+   * @param viewId      The id of the ImageView view that will load the image.
+   * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be
+   *                    manually put because of RemoteViews limitations.)
+   * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be
+   *                    manually put because of RemoteViews limitations.)
+   * @param widgetIds   The int[] that contains the widget ids of an application.
+   */
+  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
+      int height, int... widgetIds) {
+    super(width, height);
+    if (widgetIds.length == 0) {
+      throw new IllegalArgumentException("WidgetIds must have length > 0");
     }
+    this.context = Preconditions.checkNotNull(context, "Context can not be null!");
+    this.remoteViews =
+        Preconditions.checkNotNull(remoteViews, "RemoteViews object can not be null!");
+    this.widgetIds = Preconditions.checkNotNull(widgetIds, "WidgetIds can not be null!");
+    this.viewId = viewId;
+    componentName = null;
+  }
 
-    /**
-     * Constructor using an int array of widgetIds to get a handle on the Widget in order to update it when an override
-     * width and height have been set been set.
-     *
-     * @param context     Context to use in the AppWidgetManager initialization.
-     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-     * @param viewId      The id of the ImageView view that will load the image.
-     * @param widgetIds   The int[] that contains the widget ids of an application.
-     */
-    public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int... widgetIds) {
-        this(context, remoteViews, viewId, INVALID_SIZE, INVALID_SIZE, widgetIds);
-    }
+  /**
+   * Constructor using an int array of widgetIds to get a handle on the Widget in order to update it
+   * that uses {@link #SIZE_ORIGINAL} as the target width and height.
+   *
+   * @param context     Context to use in the AppWidgetManager initialization.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+   * @param viewId      The id of the ImageView view that will load the image.
+   * @param widgetIds   The int[] that contains the widget ids of an application.
+   */
+  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int... widgetIds) {
+    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, widgetIds);
+  }
 
-    /**
-     * Constructor using a ComponentName to get a handle on the Widget in order to update it.
-     *
-     * @param context     Context to use in the AppWidgetManager initialization.
-     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-     * @param viewId      The id of the ImageView view that will load the image.
-     * @param width       Desired width of the bitmap that will be loaded.(Need to be manually set
-     *                    because of RemoteViews limitations.)
-     * @param height      Desired height of the bitmap that will be loaded. (Need to be manually set
-     *                    because of RemoteViews limitations.)
-     * @param componentName   The ComponentName that refers to our AppWidget.
-     */
-    public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width, int height,
-            ComponentName componentName) {
-        super(width, height);
-        if (context == null) {
-            throw new NullPointerException("Context can not be null!");
-        }
-        if (componentName == null) {
-            throw new NullPointerException("ComponentName can not be null!");
-        }
-        if (remoteViews == null) {
-            throw new NullPointerException("RemoteViews object can not be null!");
-        }
-        this.context = context;
-        this.remoteViews = remoteViews;
-        this.viewId = viewId;
-        this.componentName = componentName;
-        widgetIds = null;
-    }
+  /**
+   * Constructor using a ComponentName to get a handle on the Widget in order to update it.
+   *
+   * @param context       Context to use in the AppWidgetManager initialization.
+   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
+   *                      bitmap.
+   * @param viewId        The id of the ImageView view that will load the image.
+   * @param width         Desired width in pixels of the bitmap that will be loaded. (Needs to be
+   *                      manually put because of RemoteViews limitations.)
+   * @param height        Desired height in pixels of the bitmap that will be loaded. (Needs to be
+   *                      manually put because of RemoteViews limitations.)
+   * @param componentName The ComponentName that refers to our AppWidget.
+   */
+  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
+      int height, ComponentName componentName) {
+    super(width, height);
+    this.context = Preconditions.checkNotNull(context, "Context can not be null!");
+    this.remoteViews =
+        Preconditions.checkNotNull(remoteViews, "RemoteViews object can not be null!");
+    this.componentName =
+        Preconditions.checkNotNull(componentName, "ComponentName can not be null!");
+    this.viewId = viewId;
+    widgetIds = null;
+  }
 
-    /**
-     * Constructor using a ComponentName, when override has been set to get a handle on the Widget in order to update
-     * it.
-     *
-     * @param context     Context to use in the AppWidgetManager initialization.
-     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-     * @param viewId      The id of the ImageView view that will load the image.
-     * @param componentName   The ComponentName that refers to our AppWidget.
-     */
-    public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, ComponentName componentName) {
-        this(context, remoteViews, viewId, INVALID_SIZE, INVALID_SIZE, componentName);
-    }
+  /**
+   * Constructor using a ComponentName, when override has been put to get a handle on the Widget in
+   * order to update it that uses {@link #SIZE_ORIGINAL} as the target width and height.
+   *
+   * @param context       Context to use in the AppWidgetManager initialization.
+   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
+   *                      bitmap.
+   * @param viewId        The id of the ImageView view that will load the image.
+   * @param componentName The ComponentName that refers to our AppWidget.
+   */
+  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId,
+      ComponentName componentName) {
+    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, componentName);
+  }
 
-    /**
-     * Updates the AppWidget after the ImageView has loaded the Bitmap.
-     */
-    private void update() {
-        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this.context);
-        if (this.componentName != null) {
-            appWidgetManager.updateAppWidget(this.componentName, this.remoteViews);
-        } else {
-            appWidgetManager.updateAppWidget(this.widgetIds, this.remoteViews);
-        }
+  /**
+   * Updates the AppWidget after the ImageView has loaded the Bitmap.
+   */
+  private void update() {
+    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this.context);
+    if (this.componentName != null) {
+      appWidgetManager.updateAppWidget(this.componentName, this.remoteViews);
+    } else {
+      appWidgetManager.updateAppWidget(this.widgetIds, this.remoteViews);
     }
+  }
 
-    @Override
-    public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {
-        this.remoteViews.setImageViewBitmap(this.viewId, resource);
-        this.update();
-    }
+  @Override
+  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+    this.remoteViews.setImageViewBitmap(this.viewId, resource);
+    this.update();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
index 37169eca4..1c3e2407a 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
@@ -5,88 +5,60 @@
 import com.bumptech.glide.request.Request;
 
 /**
- * A base {@link Target} for loading {@link com.bumptech.glide.load.engine.Resource}s that provides basic or empty
- * implementations for most methods.
+ * A base {@link Target} for loading {@link com.bumptech.glide.load.engine.Resource}s that provides
+ * basic or empty implementations for most methods.
  *
- * <p>
- *     For maximum efficiency, clear this target when you have finished using or displaying the
- *     {@link com.bumptech.glide.load.engine.Resource} loaded into it using
- *     {@link com.bumptech.glide.Glide#clear(Target)}.
- * </p>
+ * <p> For maximum efficiency, clear this target when you have finished using or displaying the
+ * {@link com.bumptech.glide.load.engine.Resource} loaded into it using
+ * {@link com.bumptech.glide.RequestManager#clear(Target)}.</p>
  *
- * <p>
- *     For loading {@link com.bumptech.glide.load.engine.Resource}s into {@link android.view.View}s,
- *     {@link com.bumptech.glide.request.target.ViewTarget} or {@link com.bumptech.glide.request.target.ImageViewTarget}
- *     are preferable.
- * </p>
+ * <p> For loading {@link com.bumptech.glide.load.engine.Resource}s into {@link android.view.View}s,
+ * {@link com.bumptech.glide.request.target.ViewTarget} or
+ * {@link com.bumptech.glide.request.target.ImageViewTarget} are preferable.</p>
  *
  * @param <Z> The type of resource that will be received by this target.
  */
 public abstract class BaseTarget<Z> implements Target<Z> {
 
-    private Request request;
+  private Request request;
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void setRequest(Request request) {
-        this.request = request;
-    }
+  @Override
+  public void setRequest(Request request) {
+    this.request = request;
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Request getRequest() {
-        return request;
-    }
+  @Override
+  public Request getRequest() {
+    return request;
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onLoadCleared(Drawable placeholder) {
-        // Do nothing.
-    }
+  @Override
+  public void onLoadCleared(Drawable placeholder) {
+    // Do nothing.
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onLoadStarted(Drawable placeholder) {
-        // Do nothing.
-    }
+  @Override
+  public void onLoadStarted(Drawable placeholder) {
+    // Do nothing.
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onLoadFailed(Exception e, Drawable errorDrawable) {
-        // Do nothing.
-    }
+  @Override
+  public void onLoadFailed(Drawable errorDrawable) {
+    // Do nothing.
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onStart() {
-        // Do nothing.
-    }
+  @Override
+  public void onStart() {
+    // Do nothing.
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onStop() {
-        // Do nothing.
-    }
+  @Override
+  public void onStop() {
+    // Do nothing.
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onDestroy() {
-        // Do nothing.
-    }
+  @Override
+  public void onDestroy() {
+    // Do nothing.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
index 4d24b095c..e71d23779 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
@@ -4,24 +4,22 @@
 import android.widget.ImageView;
 
 /**
- * A {@link com.bumptech.glide.request.target.Target} that can display an {@link android.graphics.Bitmap} in an
- * {@link android.widget.ImageView}.
- *
- * @see GlideDrawableImageViewTarget
+ * A {@link com.bumptech.glide.request.target.Target} that can display an {@link
+ * android.graphics.Bitmap} in an {@link android.widget.ImageView}.
  */
 public class BitmapImageViewTarget extends ImageViewTarget<Bitmap> {
-    public BitmapImageViewTarget(ImageView view) {
-        super(view);
-    }
+  public BitmapImageViewTarget(ImageView view) {
+    super(view);
+  }
 
-    /**
-     * Sets the {@link android.graphics.Bitmap} on the view using
-     * {@link android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)}.
-     *
-     * @param resource The bitmap to display.
-     */
-    @Override
-    protected void setResource(Bitmap resource) {
-        view.setImageBitmap(resource);
-    }
+  /**
+   * Sets the {@link android.graphics.Bitmap} on the view using {@link
+   * android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)}.
+   *
+   * @param resource The bitmap to display.
+   */
+  @Override
+  protected void setResource(Bitmap resource) {
+    view.setImageBitmap(resource);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
new file mode 100644
index 000000000..c4b247964
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.request.target;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+
+/**
+ * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}.
+ */
+public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {
+  public BitmapThumbnailImageViewTarget(ImageView view) {
+    super(view);
+  }
+
+  @Override
+  protected Drawable getDrawable(Bitmap resource) {
+    return new BitmapDrawable(view.getResources(), resource);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
index 729830318..e9ab75e01 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
@@ -1,18 +1,20 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
 import android.widget.ImageView;
 
 /**
  * A target for display {@link Drawable} objects in {@link ImageView}s.
  */
 public class DrawableImageViewTarget extends ImageViewTarget<Drawable> {
-    public DrawableImageViewTarget(ImageView view) {
-        super(view);
-    }
 
-    @Override
-    protected void setResource(Drawable resource) {
-       view.setImageDrawable(resource);
-    }
+  public DrawableImageViewTarget(ImageView view) {
+    super(view);
+  }
+
+  @Override
+  protected void setResource(@Nullable Drawable resource) {
+    view.setImageDrawable(resource);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
new file mode 100644
index 000000000..416633f7c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.request.target;
+
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+
+/**
+ * Efficiently displays multiple Drawables loaded serially into a single {@link android.view.View}.
+ */
+public class DrawableThumbnailImageViewTarget extends ThumbnailImageViewTarget<Drawable> {
+  public DrawableThumbnailImageViewTarget(ImageView view) {
+    super(view);
+  }
+
+  @Override
+  protected Drawable getDrawable(Drawable resource) {
+    return resource;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
new file mode 100644
index 000000000..f58eceda3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -0,0 +1,227 @@
+package com.bumptech.glide.request.target;
+
+import android.annotation.TargetApi;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Matrix;
+import android.graphics.PorterDuff;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+
+import com.bumptech.glide.util.Preconditions;
+
+/**
+ * A wrapper drawable to square the wrapped drawable so that it expands to fill a square with
+ * exactly the given side length. The goal of this drawable is to ensure that square thumbnail
+ * drawables always match the size of the view they will be displayed in to avoid a costly
+ * requestLayout call. This class should not be used with views or drawables that are not square.
+ */
+public class FixedSizeDrawable extends Drawable {
+  private final Matrix matrix;
+  private final RectF wrappedRect;
+  private final RectF bounds;
+  private Drawable wrapped;
+  private State state;
+  private boolean mutated;
+
+  public FixedSizeDrawable(Drawable wrapped, int width, int height) {
+    this(new State(wrapped.getConstantState(), width, height), wrapped);
+  }
+
+  FixedSizeDrawable(State state, Drawable wrapped) {
+    this.state = Preconditions.checkNotNull(state);
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+
+    // We will do our own scaling.
+    wrapped.setBounds(0, 0, wrapped.getIntrinsicWidth(), wrapped.getIntrinsicHeight());
+
+    matrix = new Matrix();
+    wrappedRect = new RectF(0, 0, wrapped.getIntrinsicWidth(), wrapped.getIntrinsicHeight());
+    bounds = new RectF();
+  }
+
+  @Override
+  public void setBounds(int left, int top, int right, int bottom) {
+    super.setBounds(left, top, right, bottom);
+    bounds.set(left, top, right, bottom);
+    updateMatrix();
+  }
+
+  @Override
+  public void setBounds(Rect bounds) {
+    super.setBounds(bounds);
+    this.bounds.set(bounds);
+    updateMatrix();
+  }
+
+  private void updateMatrix() {
+    matrix.setRectToRect(wrappedRect, this.bounds, Matrix.ScaleToFit.CENTER);
+  }
+
+  @Override
+  public void setChangingConfigurations(int configs) {
+    wrapped.setChangingConfigurations(configs);
+  }
+
+  @Override
+  public int getChangingConfigurations() {
+    return wrapped.getChangingConfigurations();
+  }
+
+  @Override
+  public void setDither(boolean dither) {
+    wrapped.setDither(dither);
+  }
+
+  @Override
+  public void setFilterBitmap(boolean filter) {
+    wrapped.setFilterBitmap(filter);
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @Override
+  public Callback getCallback() {
+    return wrapped.getCallback();
+  }
+
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  @Override
+  public int getAlpha() {
+    return wrapped.getAlpha();
+  }
+
+  @Override
+  public void setColorFilter(int color, PorterDuff.Mode mode) {
+    wrapped.setColorFilter(color, mode);
+  }
+
+  @Override
+  public void clearColorFilter() {
+    wrapped.clearColorFilter();
+  }
+
+  @Override
+  public Drawable getCurrent() {
+    return wrapped.getCurrent();
+  }
+
+  @Override
+  public boolean setVisible(boolean visible, boolean restart) {
+    return wrapped.setVisible(visible, restart);
+  }
+
+  @Override
+  public int getIntrinsicWidth() {
+    return state.width;
+  }
+
+  @Override
+  public int getIntrinsicHeight() {
+    return state.height;
+  }
+
+  @Override
+  public int getMinimumWidth() {
+    return wrapped.getMinimumWidth();
+  }
+
+  @Override
+  public int getMinimumHeight() {
+    return wrapped.getMinimumHeight();
+  }
+
+  @Override
+  public boolean getPadding(Rect padding) {
+    return wrapped.getPadding(padding);
+  }
+
+  @Override
+  public void invalidateSelf() {
+    super.invalidateSelf();
+    wrapped.invalidateSelf();
+  }
+
+  @Override
+  public void unscheduleSelf(Runnable what) {
+    super.unscheduleSelf(what);
+    wrapped.unscheduleSelf(what);
+  }
+
+  @Override
+  public void scheduleSelf(Runnable what, long when) {
+    super.scheduleSelf(what, when);
+    wrapped.scheduleSelf(what, when);
+  }
+
+  @Override
+  public void draw(Canvas canvas) {
+    canvas.save();
+    canvas.concat(matrix);
+    wrapped.draw(canvas);
+    canvas.restore();
+  }
+
+  @Override
+  public void setAlpha(int i) {
+    wrapped.setAlpha(i);
+  }
+
+  @Override
+  public void setColorFilter(ColorFilter colorFilter) {
+    wrapped.setColorFilter(colorFilter);
+  }
+
+  @Override
+  public int getOpacity() {
+    return wrapped.getOpacity();
+  }
+
+  @Override
+  public Drawable mutate() {
+    if (!mutated && super.mutate() == this) {
+      wrapped = wrapped.mutate();
+      state = new State(state);
+      mutated = true;
+    }
+    return this;
+  }
+
+  @Override
+  public ConstantState getConstantState() {
+    return state;
+  }
+
+  static class State extends ConstantState {
+    private final ConstantState wrapped;
+    private final int width;
+    private final int height;
+
+    State(State other) {
+      this(other.wrapped, other.width, other.height);
+    }
+
+    State(ConstantState wrapped, int width, int height) {
+      this.wrapped = wrapped;
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public Drawable newDrawable() {
+      return new FixedSizeDrawable(this, wrapped.newDrawable());
+    }
+
+    @Override
+    public Drawable newDrawable(Resources res) {
+      return new FixedSizeDrawable(this, wrapped.newDrawable(res));
+    }
+
+    @Override
+    public int getChangingConfigurations() {
+      return 0;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/GlideDrawableImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/GlideDrawableImageViewTarget.java
deleted file mode 100644
index 93a0bcf62..000000000
--- a/library/src/main/java/com/bumptech/glide/request/target/GlideDrawableImageViewTarget.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import android.widget.ImageView;
-
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-import com.bumptech.glide.request.animation.GlideAnimation;
-
-/**
- * A {@link com.bumptech.glide.request.target.Target} that can display an {@link android.graphics.drawable.Drawable} in
- * an {@link android.widget.ImageView}.
- */
-public class GlideDrawableImageViewTarget extends ImageViewTarget<GlideDrawable> {
-    private static final float SQUARE_RATIO_MARGIN = 0.05f;
-    private int maxLoopCount;
-    private GlideDrawable resource;
-
-    /**
-     * Constructor for an {@link com.bumptech.glide.request.target.Target} that can display an
-     * {@link com.bumptech.glide.load.resource.drawable.GlideDrawable} in an {@link android.widget.ImageView}.
-     *
-     * @param view The view to display the drawable in.
-     */
-    public GlideDrawableImageViewTarget(ImageView view) {
-        this(view, GlideDrawable.LOOP_FOREVER);
-    }
-
-    /**
-     * Constructor for an {@link com.bumptech.glide.request.target.Target} that can display an
-     * {@link com.bumptech.glide.load.resource.drawable.GlideDrawable} in an {@link android.widget.ImageView}.
-     *
-     * @param view The view to display the drawable in.
-     * @param maxLoopCount A value to pass to to {@link com.bumptech.glide.load.resource.drawable.GlideDrawable}s
-     *                     indicating how many times they should repeat their animation (if they have one). See
-     *                     {@link com.bumptech.glide.load.resource.drawable.GlideDrawable#setLoopCount(int)}.
-     */
-    public GlideDrawableImageViewTarget(ImageView view, int maxLoopCount) {
-        super(view);
-        this.maxLoopCount = maxLoopCount;
-    }
-
-    /**
-     * {@inheritDoc}
-     * If no {@link com.bumptech.glide.request.animation.GlideAnimation} is given or if the animation does not set the
-     * {@link android.graphics.drawable.Drawable} on the view, the drawable is set using
-     * {@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
-     *
-     * @param resource {@inheritDoc}
-     * @param animation {@inheritDoc}
-     */
-    @Override
-    public void onResourceReady(GlideDrawable resource, GlideAnimation<? super GlideDrawable> animation) {
-        if (!resource.isAnimated()) {
-            //TODO: Try to generalize this to other sizes/shapes.
-            // This is a dirty hack that tries to make loading square thumbnails and then square full images less costly
-            // by forcing both the smaller thumb and the larger version to have exactly the same intrinsic dimensions.
-            // If a drawable is replaced in an ImageView by another drawable with different intrinsic dimensions,
-            // the ImageView requests a layout. Scrolling rapidly while replacing thumbs with larger images triggers
-            // lots of these calls and causes significant amounts of jank.
-            float viewRatio = view.getWidth() / (float) view.getHeight();
-            float drawableRatio = resource.getIntrinsicWidth() / (float) resource.getIntrinsicHeight();
-            if (Math.abs(viewRatio - 1f) <= SQUARE_RATIO_MARGIN
-                    && Math.abs(drawableRatio - 1f) <= SQUARE_RATIO_MARGIN) {
-                resource = new SquaringDrawable(resource, view.getWidth());
-            }
-        }
-        super.onResourceReady(resource, animation);
-        this.resource = resource;
-        resource.setLoopCount(maxLoopCount);
-        resource.start();
-    }
-
-    /**
-     * Sets the drawable on the view using
-     * {@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
-     *
-     * @param resource The {@link android.graphics.drawable.Drawable} to display in the view.
-     */
-    @Override
-    protected void setResource(GlideDrawable resource) {
-        view.setImageDrawable(resource);
-    }
-
-    @Override
-    public void onStart() {
-        if (resource != null) {
-            resource.start();
-        }
-    }
-
-    @Override
-    public void onStop() {
-        if (resource != null) {
-            resource.stop();
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index dbc0db2c9..85ed326a4 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -1,83 +1,115 @@
 package com.bumptech.glide.request.target;
 
+import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
 import android.widget.ImageView;
 
-import com.bumptech.glide.request.animation.GlideAnimation;
+import com.bumptech.glide.request.transition.Transition;
 
 /**
- * A base {@link com.bumptech.glide.request.target.Target} for displaying resources in
- * {@link android.widget.ImageView}s.
+ * A base {@link com.bumptech.glide.request.target.Target} for displaying resources in {@link
+ * android.widget.ImageView}s.
  *
- * @param <Z> The type of resource that this target will display in the wrapped {@link android.widget.ImageView}.
+ * @param <Z> The type of resource that this target will display in the wrapped {@link
+ *            android.widget.ImageView}.
  */
-public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z> implements GlideAnimation.ViewAdapter {
+public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z>
+    implements Transition.ViewAdapter {
 
-    public ImageViewTarget(ImageView view) {
-        super(view);
-    }
+  @Nullable
+  private Animatable animatable;
 
-    /**
-     * Returns the current {@link android.graphics.drawable.Drawable} being displayed in the view using
-     * {@link android.widget.ImageView#getDrawable()}.
-     */
-    @Override
-    public Drawable getCurrentDrawable() {
-        return view.getDrawable();
-    }
+  public ImageViewTarget(ImageView view) {
+    super(view);
+  }
 
-    /**
-     * Sets the given {@link android.graphics.drawable.Drawable} on the view using
-     * {@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
-     *
-     * @param drawable {@inheritDoc}
-     */
-    @Override
-    public void setDrawable(Drawable drawable) {
-        view.setImageDrawable(drawable);
-    }
+  /**
+   * Returns the current {@link android.graphics.drawable.Drawable} being displayed in the view
+   * using {@link android.widget.ImageView#getDrawable()}.
+   */
+  @Override
+  @Nullable
+  public Drawable getCurrentDrawable() {
+    return view.getDrawable();
+  }
 
-    /**
-     * Sets the given {@link android.graphics.drawable.Drawable} on the view using
-     * {@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
-     *
-     * @param placeholder {@inheritDoc}
-     */
-    @Override
-    public void onLoadStarted(Drawable placeholder) {
-        view.setImageDrawable(placeholder);
-    }
+  /**
+   * Sets the given {@link android.graphics.drawable.Drawable} on the view using {@link
+   * android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
+   *
+   * @param drawable {@inheritDoc}
+   */
+  @Override
+  public void setDrawable(Drawable drawable) {
+    view.setImageDrawable(drawable);
+  }
 
-    /**
-     * Sets the given {@link android.graphics.drawable.Drawable} on the view using
-     * {@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
-     *
-     * @param errorDrawable {@inheritDoc}
-     */
-    @Override
-    public void onLoadFailed(Exception e, Drawable errorDrawable) {
-        view.setImageDrawable(errorDrawable);
+  /**
+   * Sets the given {@link android.graphics.drawable.Drawable} on the view using {@link
+   * android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
+   *
+   * @param placeholder {@inheritDoc}
+   */
+  @Override
+  public void onLoadStarted(@Nullable Drawable placeholder) {
+    super.onLoadStarted(placeholder);
+    setResource(null);
+    setDrawable(placeholder);
+  }
+
+  /**
+   * Sets the given {@link android.graphics.drawable.Drawable} on the view using {@link
+   * android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
+   *
+   * @param errorDrawable {@inheritDoc}
+   */
+  @Override
+  public void onLoadFailed(@Nullable Drawable errorDrawable) {
+    super.onLoadFailed(errorDrawable);
+    setResource(null);
+    setDrawable(errorDrawable);
+  }
+
+  /**
+   * Sets the given {@link android.graphics.drawable.Drawable} on the view using {@link
+   * android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
+   *
+   * @param placeholder {@inheritDoc}
+   */
+  @Override
+  public void onLoadCleared(@Nullable Drawable placeholder) {
+    super.onLoadCleared(placeholder);
+    setResource(null);
+    setDrawable(placeholder);
+  }
+
+  @Override
+  public void onResourceReady(Z resource, @Nullable Transition<? super Z> transition) {
+    if (transition == null || !transition.transition(resource, this)) {
+      setResource(resource);
     }
 
-    /**
-     * Sets the given {@link android.graphics.drawable.Drawable} on the view using
-     * {@link android.widget.ImageView#setImageDrawable(android.graphics.drawable.Drawable)}.
-     *
-     * @param placeholder {@inheritDoc}
-     */
-    @Override
-    public void onLoadCleared(Drawable placeholder) {
-        view.setImageDrawable(placeholder);
+    if (resource instanceof Animatable) {
+      animatable = (Animatable) resource;
+      animatable.start();
     }
+  }
 
-    @Override
-    public void onResourceReady(Z resource, GlideAnimation<? super Z> glideAnimation) {
-        if (glideAnimation == null || !glideAnimation.animate(resource, this)) {
-            setResource(resource);
-        }
+  @Override
+  public void onStart() {
+    if (animatable != null) {
+      animatable.start();
     }
+  }
 
-    protected abstract void setResource(Z resource);
+  @Override
+  public void onStop() {
+    if (animatable != null) {
+      animatable.stop();
+    }
+  }
 
+  protected abstract void setResource(@Nullable Z resource);
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 97e84f377..33454b46a 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -4,25 +4,21 @@
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
 
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-
 /**
- * A factory responsible for producing the correct type of {@link com.bumptech.glide.request.target.Target} for a given
- * {@link android.view.View} subclass.
+ * A factory responsible for producing the correct type of
+ * {@link com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
  */
 public class ImageViewTargetFactory {
 
-    @SuppressWarnings("unchecked")
-    public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {
-        if (GlideDrawable.class.isAssignableFrom(clazz)) {
-            return (Target<Z>) new GlideDrawableImageViewTarget(view);
-        } else if (Bitmap.class.equals(clazz)) {
-            return (Target<Z>) new BitmapImageViewTarget(view);
-        } else if (Drawable.class.isAssignableFrom(clazz)) {
-            return (Target<Z>) new DrawableImageViewTarget(view);
-        } else {
-            throw new IllegalArgumentException("Unhandled class: " + clazz
-                    + ", try .as*(Class).transcode(ResourceTranscoder)");
-        }
+  @SuppressWarnings("unchecked")
+  public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {
+    if (Bitmap.class.equals(clazz)) {
+      return (Target<Z>) new BitmapImageViewTarget(view);
+    } else if (Drawable.class.isAssignableFrom(clazz)) {
+      return (Target<Z>) new DrawableImageViewTarget(view);
+    } else {
+      throw new IllegalArgumentException(
+          "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index ff4d4c314..ec889d0ad 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -7,84 +7,80 @@
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
 
-import com.bumptech.glide.request.animation.GlideAnimation;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
 
 /**
- * This class is used to display downloaded Bitmap inside an ImageView of a Notification through RemoteViews.
+ * This class is used to display downloaded Bitmap inside an ImageView of a Notification through
+ * RemoteViews.
  *
- * <p>
- *     Note - For cancellation to work correctly, you must pass in the same instance of this class for every subsequent
- *     load.
- * </p>
+ * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
+ * for every subsequent load. </p>
  */
 public class NotificationTarget extends SimpleTarget<Bitmap> {
 
-    private final RemoteViews remoteViews;
-    private final Context context;
-    private final int notificationId;
-    private final Notification notification;
-    private final int viewId;
+  private final RemoteViews remoteViews;
+  private final Context context;
+  private final int notificationId;
+  private final Notification notification;
+  private final int viewId;
 
-    /**
-     * Constructor using a Notification object and a notificationId to get a handle on the Notification in order to
-     * update it when an override width and height have been set.
-     *
-     * @param context     Context to use in the AppWidgetManager initialization.
-     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-     * @param viewId      The id of the ImageView view that will load the image.
-     * @param notification The Notification object that we want to update.
-     * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
-     */
-    public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, Notification notification,
-            int  notificationId) {
-        this(context, remoteViews, viewId, INVALID_SIZE, INVALID_SIZE, notification, notificationId);
-    }
+  /**
+   * Constructor using a Notification object and a notificationId to get a handle on the
+   * Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target width and
+   * height.
+   *
+   * @param context        Context to use in the AppWidgetManager initialization.
+   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
+   *                       bitmap.
+   * @param viewId         The id of the ImageView view that will load the image.
+   * @param notification   The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   */
+  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
+      Notification notification, int notificationId) {
+    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, notification, notificationId);
+  }
 
-    /**
-     * Constructor using a Notification object and a notificationId to get a handle on the Notification in order to
-     * update it.
-     *
-     * @param context     Context to use in the AppWidgetManager initialization.
-     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-     * @param viewId      The id of the ImageView view that will load the image.
-     * @param width       Desired width of the bitmap that will be loaded.(Need to be manually set
-     *                    because of RemoteViews limitations.)
-     * @param height      Desired height of the bitmap that will be loaded. (Need to be manually set
-     *                    because of RemoteViews limitations.)
-     * @param notification The Notification object that we want to update.
-     * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
-     */
-    public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, int width, int height,
-            Notification notification, int notificationId) {
-        super(width, height);
-        if (context == null) {
-            throw new NullPointerException("Context must not be null!");
-        }
-        if (notification == null) {
-            throw new NullPointerException("Notification object can not be null!");
-        }
-        if (remoteViews == null) {
-            throw new NullPointerException("RemoteViews object can not be null!");
-        }
-        this.context = context;
-        this.viewId = viewId;
-        this.notification = notification;
-        this.notificationId = notificationId;
-        this.remoteViews = remoteViews;
-    }
+  /**
+   * Constructor using a Notification object and a notificationId to get a handle on the
+   * Notification in order to update it.
+   *
+   * @param context        Context to use in the AppWidgetManager initialization.
+   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
+   *                       bitmap.
+   * @param viewId         The id of the ImageView view that will load the image.
+   * @param width          Desired width of the bitmap that will be loaded.(Need to be manually put
+   *                       because of RemoteViews limitations.)
+   * @param height         Desired height of the bitmap that will be loaded. (Need to be manually
+   *                       put because of RemoteViews limitations.)
+   * @param notification   The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   */
+  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, int width,
+      int height, Notification notification, int notificationId) {
+    super(width, height);
+    this.context = Preconditions.checkNotNull(context, "Context must not be null!");
+    this.notification =
+        Preconditions.checkNotNull(notification, "Notification object can not be null!");
+    this.remoteViews =
+        Preconditions.checkNotNull(remoteViews, "RemoteViews object can not be null!");
+    this.viewId = viewId;
+    this.notificationId = notificationId;
+  }
 
-    /**
-     * Updates the Notification after the Bitmap resource is loaded.
-     */
-    private void update() {
-        NotificationManager manager = (NotificationManager)
-                this.context.getSystemService(Context.NOTIFICATION_SERVICE);
-        manager.notify(this.notificationId, this.notification);
-    }
+  /**
+   * Updates the Notification after the Bitmap resource is loaded.
+   */
+  private void update() {
+    NotificationManager manager =
+        (NotificationManager) this.context.getSystemService(Context.NOTIFICATION_SERVICE);
+    manager.notify(this.notificationId, this.notification);
+  }
 
-    @Override
-    public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {
-        this.remoteViews.setImageViewBitmap(this.viewId, resource);
-        this.update();
-    }
+  @Override
+  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+    this.remoteViews.setImageViewBitmap(this.viewId, resource);
+    this.update();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
index a8a9b5a2d..7b9f884a9 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
@@ -1,33 +1,36 @@
 package com.bumptech.glide.request.target;
 
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.request.animation.GlideAnimation;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.request.transition.Transition;
 
 /**
- * A one time use {@link com.bumptech.glide.request.target.Target} class that loads a resource into memory and then
- * clears itself.
+ * A one time use {@link com.bumptech.glide.request.target.Target} class that loads a resource into
+ * memory and then clears itself.
  *
  * @param <Z> The type of resource that will be loaded into memory.
  */
 public final class PreloadTarget<Z> extends SimpleTarget<Z> {
 
-    /**
-     * Returns a PreloadTarget.
-     *
-     * @param width The width in pixels of the desired resource.
-     * @param height The height in pixels of the desired resource.
-     * @param <Z> The type of the desired resource.
-     */
-    public static <Z> PreloadTarget<Z> obtain(int width, int height) {
-        return new PreloadTarget<Z>(width, height);
-    }
+  private final RequestManager requestManager;
 
-    private PreloadTarget(int width, int height) {
-        super(width, height);
-    }
+  /**
+   * Returns a PreloadTarget.
+   *
+   * @param width  The width in pixels of the desired resource.
+   * @param height The height in pixels of the desired resource.
+   * @param <Z>    The type of the desired resource.
+   */
+  public static <Z> PreloadTarget<Z> obtain(RequestManager requestManager, int width, int height) {
+    return new PreloadTarget<>(requestManager, width, height);
+  }
 
-    @Override
-    public void onResourceReady(Z resource, GlideAnimation<? super Z> glideAnimation) {
-        Glide.clear(this);
-    }
+  private PreloadTarget(RequestManager requestManager, int width, int height) {
+    super(width, height);
+    this.requestManager = requestManager;
+  }
+
+  @Override
+  public void onResourceReady(Z resource, Transition<? super Z> transition) {
+    requestManager.clear(this);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index c6487e965..1199c6870 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -1,14 +1,16 @@
 package com.bumptech.glide.request.target;
 
+import com.bumptech.glide.util.Util;
+
 /**
- * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop) implementations
- * of non essential methods that allows the caller to specify an exact width/height. Typicaly use cases look something
- * like this:
+ * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop)
+ * implementations of non essential methods that allows the caller to specify an exact width/height.
+ * Typicaly use cases look something like this:
  * <pre>
  * <code>
  * Glide.load("http://somefakeurl.com/fakeImage.jpeg")
  *      .asBitmap()
- *      .fitCenter()
+ *      .withFitCenter()
  *      .into(new SimpleTarget<Bitmap>(250, 250) {
  *
  *          {@literal @Override}
@@ -24,48 +26,42 @@
  * @param <Z> The type of resource that this target will receive.
  */
 public abstract class SimpleTarget<Z> extends BaseTarget<Z> {
-    /** A constant indicating an invalid pixel size. */
-    protected static final int INVALID_SIZE = -1;
-
-    private final int width;
-    private final int height;
+  private final int width;
+  private final int height;
 
-    /**
-     * Constructor for the target that assumes you will have called
-     * {@link com.bumptech.glide.GenericRequestBuilder#override(int, int)} on the request builder this target is given
-     * to.
-     *
-     * <p>
-     *     Requests that load into this target will throw an {@link java.lang.IllegalArgumentException} if
-     *     {@link com.bumptech.glide.GenericRequestBuilder#override(int, int)} was not called on the request builder.
-     * </p>
-     */
-    public SimpleTarget() {
-        this(INVALID_SIZE, INVALID_SIZE);
-    }
+  /**
+   * Constructor for the target that uses {@link Target#SIZE_ORIGINAL} as the target width and
+   * height.
+   */
+  public SimpleTarget() {
+    this(SIZE_ORIGINAL, SIZE_ORIGINAL);
+  }
 
-    /**
-     * Constructor for the target that takes the desired dimensions of the decoded and/or transformed resource.
-     *
-     * @param width The width in pixels of the desired resource.
-     * @param height The height in pixels of the desired resource.
-     */
-    public SimpleTarget(int width, int height) {
-        this.width = width;
-        this.height = height;
-    }
+  /**
+   * Constructor for the target that takes the desired dimensions of the decoded and/or transformed
+   * resource.
+   *
+   * @param width  The width in pixels of the desired resource.
+   * @param height The height in pixels of the desired resource.
+   */
+  public SimpleTarget(int width, int height) {
+    this.width = width;
+    this.height = height;
+  }
 
-    /**
-     * Immediately calls the given callback with the sizes given in the constructor.
-     *
-     * @param cb {@inheritDoc}
-     */
-    @Override
-    public final void getSize(SizeReadyCallback cb) {
-        if (width <= 0 || height <= 0) {
-            throw new IllegalArgumentException("Width and height must both be > 0, but given width: " + width + " and"
-                    + " height: " + height + ", either provide dimensions in the constructor or call override()");
-        }
-        cb.onSizeReady(width, height);
+  /**
+   * Immediately calls the given callback with the sizes given in the constructor.
+   *
+   * @param cb {@inheritDoc}
+   */
+  @Override
+  public final void getSize(SizeReadyCallback cb) {
+    if (!Util.isValidDimensions(width, height)) {
+      throw new IllegalArgumentException(
+          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: "
+              + width + " and height: " + height + ", either provide dimensions in the constructor"
+              + " or call override()");
     }
+    cb.onSizeReady(width, height);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java b/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
index 22b41180d..2ff5b19a2 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
@@ -1,15 +1,17 @@
 package com.bumptech.glide.request.target;
 
 /**
- * A callback that must be called when the target has determined its size. For fixed size targets it can
- * be called synchronously.
+ * A callback that must be called when the target has determined its size. For fixed size targets it
+ * can be called synchronously.
  */
 public interface SizeReadyCallback {
-    /**
-     * A callback called on the main thread.
-     *
-     * @param width The width in pixels of the target.
-     * @param height The height in pixels of the target.
-     */
-    void onSizeReady(int width, int height);
+  /**
+   * A callback called on the main thread.
+   *
+   * @param width  The width in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate
+   *               that we want the resource at its original width.
+   * @param height The height in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate
+   *               that we want the resource at its original height.
+   */
+  void onSizeReady(int width, int height);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java
deleted file mode 100644
index d19bba0d4..000000000
--- a/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java
+++ /dev/null
@@ -1,179 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import android.annotation.TargetApi;
-import android.graphics.Canvas;
-import android.graphics.ColorFilter;
-import android.graphics.PorterDuff;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.os.Build;
-
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
-
-/**
- * A wrapper drawable to square the wrapped drawable so that it expands to fill a square with exactly the given side
- * length. The goal of this drawable is to ensure that square thumbnail drawables always match the size of the view
- * they will be displayed in to avoid a costly requestLayout call. This class should not be used with views or drawables
- * that are not square.
- */
-public class SquaringDrawable extends GlideDrawable {
-    private final GlideDrawable wrapped;
-    private final int side;
-
-    public SquaringDrawable(GlideDrawable wrapped, int side) {
-        this.wrapped = wrapped;
-        this.side = side;
-    }
-
-    @Override
-    public void setBounds(int left, int top, int right, int bottom) {
-        super.setBounds(left, top, right, bottom);
-        wrapped.setBounds(left, top, right, bottom);
-    }
-
-    @Override
-    public void setBounds(Rect bounds) {
-        super.setBounds(bounds);
-        wrapped.setBounds(bounds);
-    }
-
-    @Override
-    public void setChangingConfigurations(int configs) {
-        wrapped.setChangingConfigurations(configs);
-    }
-
-    @Override
-    public int getChangingConfigurations() {
-        return wrapped.getChangingConfigurations();
-    }
-
-    @Override
-    public void setDither(boolean dither) {
-        wrapped.setDither(dither);
-    }
-
-    @Override
-    public void setFilterBitmap(boolean filter) {
-        wrapped.setFilterBitmap(filter);
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    @Override
-    public Callback getCallback() {
-        return wrapped.getCallback();
-    }
-
-    @TargetApi(Build.VERSION_CODES.KITKAT)
-    @Override
-    public int getAlpha() {
-        return wrapped.getAlpha();
-    }
-
-    @Override
-    public void setColorFilter(int color, PorterDuff.Mode mode) {
-        wrapped.setColorFilter(color, mode);
-    }
-
-    @Override
-    public void clearColorFilter() {
-        wrapped.clearColorFilter();
-    }
-
-    @Override
-    public Drawable getCurrent() {
-        return wrapped.getCurrent();
-    }
-
-    @Override
-    public boolean setVisible(boolean visible, boolean restart) {
-        return wrapped.setVisible(visible, restart);
-    }
-
-    @Override
-    public int getIntrinsicWidth() {
-        return side;
-    }
-
-    @Override
-    public int getIntrinsicHeight() {
-        return side;
-    }
-
-    @Override
-    public int getMinimumWidth() {
-        return wrapped.getMinimumWidth();
-    }
-
-    @Override
-    public int getMinimumHeight() {
-        return wrapped.getMinimumHeight();
-    }
-
-    @Override
-    public boolean getPadding(Rect padding) {
-        return wrapped.getPadding(padding);
-    }
-
-    @Override
-    public void invalidateSelf() {
-        super.invalidateSelf();
-        wrapped.invalidateSelf();
-    }
-
-    @Override
-    public void unscheduleSelf(Runnable what) {
-        super.unscheduleSelf(what);
-        wrapped.unscheduleSelf(what);
-    }
-
-    @Override
-    public void scheduleSelf(Runnable what, long when) {
-        super.scheduleSelf(what, when);
-        wrapped.scheduleSelf(what, when);
-    }
-
-    @Override
-    public void draw(Canvas canvas) {
-        wrapped.draw(canvas);
-    }
-
-    @Override
-    public void setAlpha(int i) {
-        wrapped.setAlpha(i);
-    }
-
-    @Override
-    public void setColorFilter(ColorFilter colorFilter) {
-        wrapped.setColorFilter(colorFilter);
-    }
-
-    @Override
-    public int getOpacity() {
-        return wrapped.getOpacity();
-    }
-
-    @Override
-    public boolean isAnimated() {
-        return wrapped.isAnimated();
-    }
-
-    @Override
-    public void setLoopCount(int loopCount) {
-        wrapped.setLoopCount(loopCount);
-    }
-
-    @Override
-    public void start() {
-        wrapped.start();
-    }
-
-    @Override
-    public void stop() {
-        wrapped.stop();
-    }
-
-    @Override
-    public boolean isRunning() {
-        return wrapped.isRunning();
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 4613206fb..2245adace 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -1,92 +1,85 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
 
 import com.bumptech.glide.manager.LifecycleListener;
 import com.bumptech.glide.request.Request;
-import com.bumptech.glide.request.animation.GlideAnimation;
+import com.bumptech.glide.request.transition.Transition;
 
 /**
- * An interface that Glide can load a resource into and notify of relevant lifecycle events during a load.
+ * An interface that Glide can load a resource into and notify of relevant lifecycle events during a
+ * load.
  *
- * <p>
- *     The lifecycle events in this class are as follows:
- *     <ul>
- *         <li>onLoadStarted</li>
- *         <li>onResourceReady</li>
- *         <li>onLoadCleared</li>
- *         <li>onLoadFailed</li>
- *     </ul>
+ * <p> The lifecycle events in this class are as follows: <ul> <li>onLoadStarted</li>
+ * <li>onResourceReady</li> <li>onLoadCleared</li> <li>onLoadFailed</li> </ul>
  *
- *     The typical lifecycle is onLoadStarted -> onResourceReady or onLoadFailed -> onLoadCleared. However, there are no
- *     guarantees. onLoadStarted may not be called if the resource is in memory or if the load will fail because of a
- *     null model object. onLoadCleared similarly may never be called if the target is never cleared. See the docs for
- *     the individual methods for details.
- * </p>
+ * The typical lifecycle is onLoadStarted -> onResourceReady or onLoadFailed -> onLoadCleared.
+ * However, there are no guarantees. onLoadStarted may not be called if the resource is in memory or
+ * if the load will fail because of a null model object. onLoadCleared similarly may never be called
+ * if the target is never cleared. See the docs for the individual methods for details. </p>
  *
  * @param <R> The type of resource the target can display.
  */
 public interface Target<R> extends LifecycleListener {
+  /**
+   * Indicates that we want the resource in its original unmodified width and/or height.
+   */
+  int SIZE_ORIGINAL = Integer.MIN_VALUE;
 
-    /**
-     * A lifecycle callback that is called when a load is started.
-     *
-     * <p>
-     *     Note - This may not be called for every load, it is possible for example for loads to fail before the load
-     *     starts (when the model object is null).
-     * </p>
-     *
-     * <p>
-     *     Note - This method may be called multiple times before any other lifecycle method is called. Loads can be
-     *     paused and restarted due to lifecycle or connectivity events and each restart may cause a call here.
-     * </p>
-     *
-     * @param placeholder The placeholder drawable to optionally show, or null.
-     */
-    void onLoadStarted(Drawable placeholder);
+  /**
+   * A lifecycle callback that is called when a load is started.
+   *
+   * <p> Note - This may not be called for every load, it is possible for example for loads to fail
+   * before the load starts (when the model object is null). </p>
+   *
+   * <p> Note - This method may be called multiple times before any other lifecycle method is
+   * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
+   * restart may cause a call here. </p>
+   *
+   * @param placeholder The placeholder drawable to optionally show, or null.
+   */
+  void onLoadStarted(@Nullable Drawable placeholder);
 
-    /**
-     * A lifecycle callback that is called when a load fails.
-     *
-     * <p>
-     *     Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)} if the model
-     *     object is null.
-     * </p>
-     *
-     * @param e The exception causing the load to fail, or null if no exception occurred (usually because a decoder
-     *          simply returned null).
-     * @param errorDrawable The error drawable to optionally show, or null.
-     */
-    void onLoadFailed(Exception e, Drawable errorDrawable);
+  /**
+   * A lifecycle callback that is called when a load fails.
+   *
+   * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
+   * } if the model object is null. </p>
+   *
+   * @param errorDrawable The error drawable to optionally show, or null.
+   */
+  void onLoadFailed(@Nullable Drawable errorDrawable);
 
-    /**
-     * The method that will be called when the resource load has finished.
-     *
-     * @param resource the loaded resource.
-     */
-    void onResourceReady(R resource, GlideAnimation<? super R> glideAnimation);
+  /**
+   * The method that will be called when the resource load has finished.
+   *
+   * @param resource the loaded resource.
+   */
+  void onResourceReady(R resource, Transition<? super R> transition);
 
-    /**
-     * A lifecycle callback that is called when a load is cancelled and its resources are freed.
-     *
-     * @param placeholder The placeholder drawable to optionally show, or null.
-     */
-    void onLoadCleared(Drawable placeholder);
+  /**
+   * A lifecycle callback that is called when a load is cancelled and its resources are freed.
+   *
+   * @param placeholder The placeholder drawable to optionally show, or null.
+   */
+  void onLoadCleared(@Nullable Drawable placeholder);
 
-    /**
-     * A method to retrieve the size of this target.
-     *
-     * @param cb The callback that must be called when the size of the target has been determined
-     */
-    void getSize(SizeReadyCallback cb);
+  /**
+   * A method to retrieve the size of this target.
+   *
+   * @param cb The callback that must be called when the size of the target has been determined
+   */
+  void getSize(SizeReadyCallback cb);
 
-    /**
-     * Sets the current request for this target to retain, should not be called outside of Glide.
-     */
-    void setRequest(Request request);
+  /**
+   * Sets the current request for this target to retain, should not be called outside of Glide.
+   */
+  void setRequest(@Nullable Request request);
 
-    /**
-     * Retrieves the current request for this target, should not be called outside of Glide.
-     */
-    Request getRequest();
+  /**
+   * Retrieves the current request for this target, should not be called outside of Glide.
+   */
+  @Nullable
+  Request getRequest();
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
new file mode 100644
index 000000000..84306618b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.request.target;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+/**
+ * Avoids extra calls to {@link android.view.View#requestLayout} when loading more than once
+ * image into an {@link android.widget.ImageView} with fixed dimensions.
+ *
+ * <p>Typically it makes sense
+ * to use this class when loading multiple images with the {@link
+ * com.bumptech.glide.RequestBuilder#thumbnail(com.bumptech.glide.RequestBuilder)} API into views in
+ * a scrolling list like ListView, GridView, or RecyclerView.
+ *
+ * <p>{@link FixedSizeDrawable} may cause skewing or other undesireable behavior depending on
+ * your images, views, and scaling. If this occurs, consider {@link DrawableImageViewTarget} or
+ * {@link BitmapImageViewTarget} as alternatives.
+ *
+ * @param <T> The type of resource that will be displayed in the ImageView.
+ */
+public abstract class ThumbnailImageViewTarget<T> extends ImageViewTarget<T> {
+
+  public ThumbnailImageViewTarget(ImageView view) {
+    super(view);
+  }
+
+  @Override
+  protected void setResource(@Nullable T resource) {
+    ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
+    Drawable result = getDrawable(resource);
+    if (layoutParams != null && layoutParams.width > 0 && layoutParams.height > 0) {
+      result = new FixedSizeDrawable(result, layoutParams.width, layoutParams.height);
+    }
+
+    view.setImageDrawable(result);
+  }
+
+  protected abstract Drawable getDrawable(T resource);
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index dcf7f5d0e..336d4b069 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -1,225 +1,312 @@
 package com.bumptech.glide.request.target;
 
+import android.annotation.TargetApi;
 import android.content.Context;
+import android.graphics.Point;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.view.Display;
 import android.view.View;
-import android.view.ViewGroup;
+import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
 
 import com.bumptech.glide.request.Request;
+import com.bumptech.glide.util.Preconditions;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- * A base {@link Target} for loading {@link android.graphics.Bitmap}s into {@link View}s that provides default
- * implementations for most most methods and can determine the size of views using a
- * {@link android.view.ViewTreeObserver.OnDrawListener}.
+ * A base {@link Target} for loading {@link android.graphics.Bitmap}s into {@link View}s that
+ * provides default implementations for most most methods and can determine the size of views using
+ * a {@link android.view.ViewTreeObserver.OnDrawListener}.
  *
- * <p>
- *     To detect {@link View} reuse in {@link android.widget.ListView} or any {@link ViewGroup} that reuses views, this
- *     class uses the {@link View#setTag(Object)} method to store some metadata so that if a view is reused, any
- *     previous loads or resources from previous loads can be cancelled or reused.
- * </p>
+ * <p> To detect {@link View} reuse in {@link android.widget.ListView} or any {@link
+ * android.view.ViewGroup} that reuses views, this class uses the {@link View#setTag(Object)} method
+ * to store some metadata so that if a view is reused, any previous loads or resources from previous
+ * loads can be cancelled or reused. </p>
  *
- * <p>
- *     Any calls to {@link View#setTag(Object)}} on a View given to this class will result in excessive allocations and
- *     and/or {@link IllegalArgumentException}s. If you must call {@link View#setTag(Object)} on a view, consider
- *     using {@link BaseTarget} or {@link SimpleTarget} instead.
- * </p>
+ * <p> Any calls to {@link View#setTag(Object)}} on a View given to this class will result in
+ * excessive allocations and and/or {@link IllegalArgumentException}s. If you must call {@link
+ * View#setTag(Object)} on a view, consider using {@link BaseTarget} or {@link SimpleTarget}
+ * instead. </p>
+ *
+ * <p> Subclasses must call super in {@link #onLoadCleared(Drawable)} </p>
  *
  * @param <T> The specific subclass of view wrapped by this target.
  * @param <Z> The resource type this target will receive.
  */
 public abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {
-    private static final String TAG = "ViewTarget";
+  private static final String TAG = "ViewTarget";
+  private static boolean isTagUsedAtLeastOnce = false;
+  @Nullable private static Integer tagId = null;
 
-    protected final T view;
-    private final SizeDeterminer sizeDeterminer;
+  protected final T view;
+  private final SizeDeterminer sizeDeterminer;
 
-    public ViewTarget(T view) {
-        if (view == null) {
-            throw new NullPointerException("View must not be null!");
-        }
-        this.view = view;
-        sizeDeterminer = new SizeDeterminer(view);
+  public ViewTarget(T view) {
+    this.view = Preconditions.checkNotNull(view);
+    sizeDeterminer = new SizeDeterminer(view);
+  }
+
+  /**
+   * Returns the wrapped {@link android.view.View}.
+   */
+  public T getView() {
+    return view;
+  }
+
+  /**
+   * Determines the size of the view by first checking {@link android.view.View#getWidth()} and
+   * {@link android.view.View#getHeight()}. If one or both are zero, it then checks the view's
+   * {@link LayoutParams}. If one or both of the params width and height are less than or equal to
+   * zero, it then adds an {@link android.view.ViewTreeObserver.OnPreDrawListener} which waits until
+   * the view has been measured before calling the callback with the view's drawn width and height.
+   *
+   * @param cb {@inheritDoc}
+   */
+  @Override
+  public void getSize(SizeReadyCallback cb) {
+    sizeDeterminer.getSize(cb);
+  }
+
+  @Override
+  public void onLoadCleared(Drawable placeholder) {
+    super.onLoadCleared(placeholder);
+    sizeDeterminer.clearCallbacksAndListener();
+  }
+
+  /**
+   * Stores the request using {@link View#setTag(Object)}.
+   *
+   * @param request {@inheritDoc}
+   */
+  @Override
+  public void setRequest(@Nullable Request request) {
+    setTag(request);
+  }
+
+  /**
+   * Returns any stored request using {@link android.view.View#getTag()}.
+   *
+   * <p> For Glide to function correctly, Glide must be the only thing that calls {@link
+   * View#setTag(Object)}. If the tag is cleared or put to another object type, Glide will not be
+   * able to retrieve and cancel previous loads which will not only prevent Glide from reusing
+   * resource, but will also result in incorrect images being loaded and lots of flashing of images
+   * in lists. As a result, this will throw an {@link java.lang.IllegalArgumentException} if {@link
+   * android.view.View#getTag()}} returns a non null object that is not an {@link
+   * com.bumptech.glide.request.Request}. </p>
+   */
+  @Override
+  @Nullable
+  public Request getRequest() {
+    Object tag = getTag();
+    Request request = null;
+    if (tag != null) {
+      if (tag instanceof Request) {
+        request = (Request) tag;
+      } else {
+        throw new IllegalArgumentException(
+            "You must not call setTag() on a view Glide is targeting");
+      }
     }
+    return request;
+  }
+
+  @Override
+  public String toString() {
+    return "Target for: " + view;
+  }
+
+  private void setTag(@Nullable Object tag) {
+    if (tagId == null) {
+      isTagUsedAtLeastOnce = true;
+      view.setTag(tag);
+    } else {
+      view.setTag(tagId, tag);
+    }
+  }
+
+  @Nullable
+  private Object getTag() {
+    if (tagId == null) {
+      return view.getTag();
+    } else {
+      return view.getTag(tagId);
+    }
+  }
+
+  /**
+   * Sets the android resource id to use in conjunction with {@link View#setTag(int, Object)}
+   * to store temporary state allowing loads to be automatically cancelled and resources re-used
+   * in scrolling lists.
+   *
+   * <p>
+   *   If no tag id is set, Glide will use {@link View#setTag(Object)}.
+   * </p>
+   *
+   * <p>
+   *   Warning: prior to Android 4.0 tags were stored in a static map. Using this method prior
+   *   to Android 4.0 may cause memory leaks and isn't recommended. If you do use this method
+   *   on older versions, be sure to call {@link com.bumptech.glide.RequestManager#clear(View)} on
+   *   any view you start a load into to ensure that the static state is removed.
+   * </p>
+   *
+   * @param tagId The android resource to use.
+   */
+  public static void setTagId(int tagId) {
+      if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {
+          throw new IllegalArgumentException("You cannot set the tag id more than once or change"
+              + " the tag id after the first request has been made");
+      }
+      ViewTarget.tagId = tagId;
+  }
+
+  private static class SizeDeterminer {
+    // Some negative sizes (WRAP_CONTENT) are valid, 0 is never valid.
+    private static final int PENDING_SIZE = 0;
+    private final View view;
+    private final List<SizeReadyCallback> cbs = new ArrayList<>();
+
+    @Nullable private SizeDeterminerLayoutListener layoutListener;
+    @Nullable private Point displayDimens;
 
-    /**
-     * Returns the wrapped {@link android.view.View}.
-     */
-    public T getView() {
-        return view;
+    public SizeDeterminer(View view) {
+      this.view = view;
     }
 
-    /**
-     * Determines the size of the view by first checking {@link android.view.View#getWidth()} and
-     * {@link android.view.View#getHeight()}. If one or both are zero, it then checks the view's
-     * {@link android.view.ViewGroup.LayoutParams}. If one or both of the params width and height are less than or
-     * equal to zero, it then adds an {@link android.view.ViewTreeObserver.OnPreDrawListener} which waits until the view
-     * has been measured before calling the callback with the view's drawn width and height.
-     *
-     * @param cb {@inheritDoc}
-     */
-    @Override
-    public void getSize(SizeReadyCallback cb) {
-        sizeDeterminer.getSize(cb);
+    private void notifyCbs(int width, int height) {
+      for (SizeReadyCallback cb : cbs) {
+        cb.onSizeReady(width, height);
+      }
     }
 
-    /**
-     * Stores the request using {@link View#setTag(Object)}.
-     *
-     * @param request {@inheritDoc}
-     */
-    @Override
-    public void setRequest(Request request) {
-        view.setTag(request);
+    private void checkCurrentDimens() {
+      if (cbs.isEmpty()) {
+        return;
+      }
+
+      int currentWidth = getViewWidthOrParam();
+      int currentHeight = getViewHeightOrParam();
+      if (!isSizeValid(currentWidth) || !isSizeValid(currentHeight)) {
+        return;
+      }
+
+      notifyCbs(currentWidth, currentHeight);
+      clearCallbacksAndListener();
     }
 
-    /**
-     * Returns any stored request using {@link android.view.View#getTag()}.
-     *
-     * <p>
-     *     For Glide to function correctly, Glide must be the only thing that calls {@link View#setTag(Object)}. If the
-     *     tag is cleared or set to another object type, Glide will not be able to retrieve and cancel previous loads
-     *     which will not only prevent Glide from reusing resource, but will also result in incorrect images being
-     *     loaded and lots of flashing of images in lists. As a result, this will throw an
-     *     {@link java.lang.IllegalArgumentException} if {@link android.view.View#getTag()}} returns a non null object
-     *     that is not an {@link com.bumptech.glide.request.Request}.
-     * </p>
-     */
-    @Override
-    public Request getRequest() {
-        Object tag = view.getTag();
-        Request request = null;
-        if (tag != null) {
-            if (tag instanceof Request) {
-                request = (Request) tag;
-            } else {
-                throw new IllegalArgumentException("You must not call setTag() on a view Glide is targeting");
-            }
+    void getSize(SizeReadyCallback cb) {
+      int currentWidth = getViewWidthOrParam();
+      int currentHeight = getViewHeightOrParam();
+      if (isSizeValid(currentWidth) && isSizeValid(currentHeight)) {
+        cb.onSizeReady(currentWidth, currentHeight);
+      } else {
+        // We want to notify callbacks in the order they were added and we only expect one or two
+        // callbacks to
+        // be added a time, so a List is a reasonable choice.
+        if (!cbs.contains(cb)) {
+          cbs.add(cb);
         }
-        return request;
+        if (layoutListener == null) {
+          final ViewTreeObserver observer = view.getViewTreeObserver();
+          layoutListener = new SizeDeterminerLayoutListener(this);
+          observer.addOnPreDrawListener(layoutListener);
+        }
+      }
     }
 
-    @Override
-    public String toString() {
-        return "Target for: " + view;
+    void clearCallbacksAndListener() {
+      // Keep a reference to the layout listener and remove it here
+      // rather than having the observer remove itself because the observer
+      // we add the listener to will be almost immediately merged into
+      // another observer and will therefore never be alive. If we instead
+      // keep a reference to the listener and remove it here, we get the
+      // current view tree observer and should succeed.
+      ViewTreeObserver observer = view.getViewTreeObserver();
+      if (observer.isAlive()) {
+        observer.removeOnPreDrawListener(layoutListener);
+      }
+      layoutListener = null;
+      cbs.clear();
     }
 
-    private static class SizeDeterminer {
-        private final View view;
-        private final List<SizeReadyCallback> cbs = new ArrayList<SizeReadyCallback>();
-        private SizeDeterminerLayoutListener layoutListener;
+    private int getViewHeightOrParam() {
+      final LayoutParams layoutParams = view.getLayoutParams();
+      if (isSizeValid(view.getHeight())) {
+        return view.getHeight();
+      } else if (layoutParams != null) {
+        return getSizeForParam(layoutParams.height, true /*isHeight*/);
+      } else {
+        return PENDING_SIZE;
+      }
+    }
 
-        public SizeDeterminer(View view) {
-            this.view = view;
-        }
+    private int getViewWidthOrParam() {
+      final LayoutParams layoutParams = view.getLayoutParams();
+      if (isSizeValid(view.getWidth())) {
+        return view.getWidth();
+      } else if (layoutParams != null) {
+        return getSizeForParam(layoutParams.width, false /*isHeight*/);
+      } else {
+        return PENDING_SIZE;
+      }
+    }
 
-        private void notifyCbs(int width, int height) {
-            for (SizeReadyCallback cb : cbs) {
-                cb.onSizeReady(width, height);
-            }
-            cbs.clear();
-        }
+    private int getSizeForParam(int param, boolean isHeight) {
+      if (param == LayoutParams.WRAP_CONTENT) {
+        Point displayDimens = getDisplayDimens();
+        return isHeight ? displayDimens.y : displayDimens.x;
+      } else {
+        return param;
+      }
+    }
 
-        private void checkCurrentDimens() {
-            if (cbs.isEmpty()) {
-                return;
-            }
-
-            boolean calledCallback = true;
-            ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            if (isViewSizeValid()) {
-                notifyCbs(view.getWidth(), view.getHeight());
-            } else if (isLayoutParamsSizeValid()) {
-                notifyCbs(layoutParams.width, layoutParams.height);
-            } else {
-                calledCallback = false;
-            }
-
-            if (calledCallback) {
-                // Keep a reference to the layout listener and remove it here
-                // rather than having the observer remove itself because the observer
-                // we add the listener to will be almost immediately merged into
-                // another observer and will therefore never be alive. If we instead
-                // keep a reference to the listener and remove it here, we get the
-                // current view tree observer and should succeed.
-                ViewTreeObserver observer = view.getViewTreeObserver();
-                if (observer.isAlive()) {
-                    observer.removeOnPreDrawListener(layoutListener);
-                }
-                layoutListener = null;
-            }
-        }
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+    @SuppressWarnings("deprecation")
+    private Point getDisplayDimens() {
+      if (displayDimens != null) {
+        return displayDimens;
+      }
+      WindowManager windowManager =
+          (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
+      Display display = windowManager.getDefaultDisplay();
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+        displayDimens = new Point();
+        display.getSize(displayDimens);
+      } else {
+        displayDimens = new Point(display.getWidth(), display.getHeight());
+      }
+      return displayDimens;
+    }
 
-        public void getSize(SizeReadyCallback cb) {
-            ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            if (isViewSizeValid()) {
-                cb.onSizeReady(view.getWidth(), view.getHeight());
-            } else if (isLayoutParamsSizeValid()) {
-                cb.onSizeReady(layoutParams.width, layoutParams.height);
-            } else if (isUsingWrapContent()) {
-                WindowManager windowManager =
-                        (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
-                Display display = windowManager.getDefaultDisplay();
-                @SuppressWarnings("deprecation") final int width = display.getWidth(), height = display.getHeight();
-                if (Log.isLoggable(TAG, Log.WARN)) {
-                    Log.w(TAG, "Trying to load image into ImageView using WRAP_CONTENT, defaulting to screen"
-                            + " dimensions: [" + width + "x" + height + "]. Give the view an actual width and height "
-                            + " for better performance.");
-                }
-                cb.onSizeReady(width, height);
-            } else {
-                // We want to notify callbacks in the order they were added and we only expect one or two callbacks to
-                // be added a time, so a List is a reasonable choice.
-                if (!cbs.contains(cb)) {
-                    cbs.add(cb);
-                }
-                if (layoutListener == null) {
-                    final ViewTreeObserver observer = view.getViewTreeObserver();
-                    layoutListener = new SizeDeterminerLayoutListener(this);
-                    observer.addOnPreDrawListener(layoutListener);
-                }
-            }
-        }
+    private boolean isSizeValid(int size) {
+      return size > 0 || size == LayoutParams.WRAP_CONTENT;
+    }
 
-        private boolean isViewSizeValid() {
-            return view.getWidth() > 0 && view.getHeight() > 0;
-        }
+    private static class SizeDeterminerLayoutListener implements ViewTreeObserver
+        .OnPreDrawListener {
+      private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
-        private boolean isUsingWrapContent() {
-            final ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            return layoutParams != null && (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT
-                    || layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT);
-        }
+      public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
+        sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
+      }
 
-        private boolean isLayoutParamsSizeValid() {
-            final ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            return layoutParams != null && layoutParams.width > 0 && layoutParams.height > 0;
+      @Override
+      public boolean onPreDraw() {
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
         }
-
-        private static class SizeDeterminerLayoutListener implements ViewTreeObserver.OnPreDrawListener {
-            private final WeakReference<SizeDeterminer> sizeDeterminerRef;
-
-            public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
-                sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
-            }
-
-            @Override
-            public boolean onPreDraw() {
-                if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                    Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
-                }
-                SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
-                if (sizeDeterminer != null) {
-                    sizeDeterminer.checkCurrentDimens();
-                }
-                return true;
-            }
+        SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
+        if (sizeDeterminer != null) {
+          sizeDeterminer.checkCurrentDimens();
         }
+        return true;
+      }
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
new file mode 100644
index 000000000..e4e3a0d93
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -0,0 +1,94 @@
+package com.bumptech.glide.request.transition;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.view.animation.AlphaAnimation;
+import android.view.animation.Animation;
+
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A factory class that produces a new {@link Transition} that varies depending on whether or not
+ * the drawable was loaded from the memory cache and whether or not the drawable is the first image
+ * to be put on the target.
+ *
+ * <p> Resources are usually loaded from the memory cache just before the user can see the view, for
+ * example when the user changes screens or scrolls back and forth in a list. In those cases the
+ * user typically does not expect to see a transition. As a result, when the resource is loaded from
+ * the memory cache this factory produces an {@link NoTransition}. </p>
+ */
+public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
+  private static final int DEFAULT_DURATION_MS = 300;
+  private final ViewAnimationFactory<Drawable> viewAnimationFactory;
+  private final int duration;
+  private DrawableCrossFadeTransition firstResourceTransition;
+  private DrawableCrossFadeTransition secondResourceTransition;
+
+  public DrawableCrossFadeFactory() {
+    this(DEFAULT_DURATION_MS);
+  }
+
+  public DrawableCrossFadeFactory(int duration) {
+    this(new ViewAnimationFactory<Drawable>(
+        new DefaultViewTransitionAnimationFactory(duration)), duration);
+  }
+
+  public DrawableCrossFadeFactory(int defaultAnimationId, int duration) {
+    this(new ViewAnimationFactory<Drawable>(defaultAnimationId), duration);
+  }
+
+  public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
+    this(new ViewAnimationFactory<Drawable>(defaultAnimation), duration);
+  }
+
+  DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory, int duration) {
+    this.viewAnimationFactory = viewAnimationFactory;
+    this.duration = duration;
+  }
+
+  @Override
+  public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {
+    if (dataSource == DataSource.MEMORY_CACHE) {
+      return NoTransition.get();
+    } else if (isFirstResource) {
+      return getFirstResourceTransition(dataSource);
+    } else {
+      return getSecondResourceTransition(dataSource);
+    }
+  }
+
+  private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {
+      if (firstResourceTransition == null) {
+          Transition<Drawable> defaultAnimation =
+              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);
+          firstResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+      }
+      return firstResourceTransition;
+  }
+
+  private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {
+      if (secondResourceTransition == null) {
+          Transition<Drawable> defaultAnimation =
+              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);
+          secondResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+      }
+      return secondResourceTransition;
+  }
+
+  private static class DefaultViewTransitionAnimationFactory implements ViewTransition
+      .ViewTransitionAnimationFactory {
+
+    private final int duration;
+
+    DefaultViewTransitionAnimationFactory(int duration) {
+      this.duration = duration;
+    }
+
+    @Override
+    public Animation build(Context context) {
+      AlphaAnimation animation = new AlphaAnimation(0f, 1f);
+      animation.setDuration(duration);
+      return animation;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
new file mode 100644
index 000000000..2cbca19c7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.request.transition;
+
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
+
+/**
+ * A cross fade {@link Transition} for {@link android.graphics.drawable.Drawable}s that uses an
+ * {@link android.graphics.drawable.TransitionDrawable} to transition from an existing drawable
+ * already visible on the target to a new drawable. If no existing drawable exists, this class can
+ * instead fall back to a default animation that doesn't rely on {@link
+ * android.graphics.drawable.TransitionDrawable}.
+ */
+public class DrawableCrossFadeTransition implements Transition<Drawable> {
+  private final Transition<Drawable> defaultAnimation;
+  private final int duration;
+
+  /**
+   * Constructor that takes a default animation and a duration in milliseconds that the cross fade
+   * animation should last.
+   *
+   * @param duration The duration that the cross fade animation should run if there is something to
+   *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
+   */
+  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration) {
+    this.defaultAnimation = defaultAnimation;
+    this.duration = duration;
+  }
+
+  /**
+   * Animates from the previous drawable to the current drawable in one of two ways.
+   *
+   * <ol> <li>Using the default animation provided in the constructor if the previous drawable is
+   * null</li> <li>Using the cross fade animation with the duration provided in the constructor if
+   * the previous drawable is non null</li> </ol>
+   *
+   * @param current {@inheritDoc}
+   * @param adapter {@inheritDoc}
+   * @return {@inheritDoc}
+   */
+  @Override
+  public boolean transition(Drawable current, ViewAdapter adapter) {
+    Drawable previous = adapter.getCurrentDrawable();
+    if (previous != null) {
+      TransitionDrawable transitionDrawable =
+          new TransitionDrawable(new Drawable[] { previous, current });
+      transitionDrawable.setCrossFadeEnabled(true);
+      transitionDrawable.startTransition(duration);
+      adapter.setDrawable(transitionDrawable);
+      return true;
+    } else {
+      defaultAnimation.transition(current, adapter);
+      return false;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
new file mode 100644
index 000000000..5192b150b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -0,0 +1,50 @@
+package com.bumptech.glide.request.transition;
+
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A simple {@link Transition} that performs no actions.
+ *
+ * @param <R> the resource type that will be transitioned into a
+ * {@link com.bumptech.glide.request.target.Target}.
+ */
+public class NoTransition<R> implements Transition<R> {
+  private static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
+  @SuppressWarnings("rawtypes")
+  private static final TransitionFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
+
+  /**
+   * A factory that always returns the same {@link NoTransition}.
+   */
+  public static class NoAnimationFactory<R> implements TransitionFactory<R> {
+    @SuppressWarnings("unchecked")
+    @Override
+    public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+      return (Transition<R>) NO_ANIMATION;
+    }
+  }
+
+  /**
+   * Returns an instance of a factory that produces {@link NoTransition}s.
+   */
+  @SuppressWarnings("unchecked")
+  public static <R> TransitionFactory<R> getFactory() {
+    return (TransitionFactory<R>) NO_ANIMATION_FACTORY;
+  }
+
+  /**
+   * Returns an instance of {@link NoTransition}.
+   */
+  @SuppressWarnings("unchecked")
+  public static <R> Transition<R> get() {
+    return (Transition<R>) NO_ANIMATION;
+  }
+
+  /**
+   * Performs no animation and always returns {@code false}.
+   */
+  @Override
+  public boolean transition(Object current, ViewAdapter adapter) {
+    return false;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/Transition.java b/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
new file mode 100644
index 000000000..50debd7b9
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.request.transition;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import android.view.View;
+
+/**
+ * An interface that allows a transition to be applied to {@link android.view.View}s in {@link
+ * com.bumptech.glide.request.target.Target}s in across resource types. Targets that wrap views will
+ * be able to provide all of the necessary arguments and start the transition. Those that do not
+ * will be unable to provide the necessary arguments and will therefore be forced to ignore the
+ * transition. This interface is a compromise that allows view specific transition in Glide's
+ * complex world of arbitrary resource types and arbitrary target types.
+ *
+ * @param <R> The type of the resource whose entrance will be transitioned.
+ */
+public interface Transition<R> {
+
+  /**
+   * An interface wrapping a view that exposes the necessary methods to run the various types of
+   * android animations as transitions: ({@link ViewTransition}, {@link ViewPropertyTransition} and
+   * animated {@link android.graphics.drawable.Drawable}s).
+   */
+  interface ViewAdapter {
+    /**
+     * Returns the wrapped {@link android.view.View}.
+     */
+    View getView();
+
+    /**
+     * Returns the current drawable being displayed in the view, or null if no such drawable exists
+     * (or one cannot be retrieved).
+     */
+    @Nullable
+    Drawable getCurrentDrawable();
+
+    /**
+     * Sets the current drawable (usually an animated drawable) to display in the wrapped view.
+     *
+     * @param drawable The drawable to display in the wrapped view.
+     */
+    void setDrawable(Drawable drawable);
+  }
+
+  /**
+   * Animates from the previous {@link android.graphics.drawable.Drawable} that is currently being
+   * displayed in the given view, if not null, to the new resource that should be displayed in the
+   * view.
+   *
+   * @param current The new resource that will be displayed in the view.
+   * @param adapter The {@link Transition.ViewAdapter} wrapping a view that can at least return an
+   *                {@link android.view.View} from {@link Transition.ViewAdapter#getView()}.
+   * @return True if in the process of running the transition, the new resource was put on the view,
+   * false if the caller needs to manually put the current resource on the view.
+   */
+  boolean transition(R current, ViewAdapter adapter);
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
new file mode 100644
index 000000000..727b508a7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide.request.transition;
+
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A factory class that can produce different {@link Transition}s based on the state of the
+ * request.
+ *
+ * @param <R> The type of resource that needs to be animated into the target.
+ */
+public interface TransitionFactory<R> {
+
+  /**
+   * Returns a new {@link Transition}.
+   *
+   * @param dataSource      The {@link com.bumptech.glide.load.DataSource} the resource was loaded
+   *                        from.
+   * @param isFirstResource True if this is the first resource to be loaded into the target.
+   */
+  Transition<R> build(DataSource dataSource, boolean isFirstResource);
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
new file mode 100644
index 000000000..0aad3abef
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
@@ -0,0 +1,79 @@
+package com.bumptech.glide.request.transition;
+
+import android.content.Context;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A {@link TransitionFactory} that produces {@link ViewTransition}s.
+ *
+ * @param <R> The type of the resource that will be transitioned into a view.
+ */
+public class ViewAnimationFactory<R> implements TransitionFactory<R> {
+  private final ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
+  private Transition<R> transition;
+
+  public ViewAnimationFactory(Animation animation) {
+    this(new ConcreteViewTransitionAnimationFactory(animation));
+  }
+
+  public ViewAnimationFactory(int animationId) {
+    this(new ResourceViewTransitionAnimationFactory(animationId));
+  }
+
+  ViewAnimationFactory(
+      ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory) {
+    this.viewTransitionAnimationFactory = viewTransitionAnimationFactory;
+  }
+
+  /**
+   * Returns a new {@link Transition} for the given arguments. If isFromMemoryCache is {@code true}
+   * or isFirstImage is {@code false}, returns a {@link NoTransition} and otherwise returns a new
+   * {@link ViewTransition}.
+   *
+   * @param dataSource {@inheritDoc}
+   * @param isFirstResource   {@inheritDoc}
+   */
+  @Override
+  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+    if (dataSource == DataSource.MEMORY_CACHE || !isFirstResource) {
+      return NoTransition.get();
+    }
+
+    if (transition == null) {
+      transition = new ViewTransition<>(viewTransitionAnimationFactory);
+    }
+
+    return transition;
+  }
+
+  private static class ConcreteViewTransitionAnimationFactory implements ViewTransition
+      .ViewTransitionAnimationFactory {
+    private final Animation animation;
+
+    public ConcreteViewTransitionAnimationFactory(Animation animation) {
+      this.animation = animation;
+    }
+
+    @Override
+    public Animation build(Context context) {
+      return animation;
+    }
+  }
+
+  private static class ResourceViewTransitionAnimationFactory implements ViewTransition
+      .ViewTransitionAnimationFactory {
+    private final int animationId;
+
+    public ResourceViewTransitionAnimationFactory(int animationId) {
+      this.animationId = animationId;
+    }
+
+    @Override
+    public Animation build(Context context) {
+      return AnimationUtils.loadAnimation(context, animationId);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyAnimationFactory.java
new file mode 100644
index 000000000..ca8bdd548
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyAnimationFactory.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.request.transition;
+
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A {@link TransitionFactory} that produces ViewPropertyAnimations.
+ *
+ * @param <R> The type of the resource that will be transitioned into a view.
+ */
+public class ViewPropertyAnimationFactory<R> implements TransitionFactory<R> {
+  private final ViewPropertyTransition.Animator animator;
+  private ViewPropertyTransition<R> animation;
+
+  public ViewPropertyAnimationFactory(ViewPropertyTransition.Animator animator) {
+    this.animator = animator;
+  }
+
+  /**
+   * Returns a new {@link Transition} for the given arguments. If isMemoryCache is {@code true} or
+   * isFirstImage is {@code false}, returns a {@link NoTransition} and otherwise returns a new
+   * {@link ViewPropertyTransition} for the {@link ViewPropertyTransition.Animator} provided in the
+   * constructor.
+   */
+  @Override
+  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+    if (dataSource == DataSource.MEMORY_CACHE || !isFirstResource) {
+      return NoTransition.get();
+    }
+    if (animation == null) {
+      animation = new ViewPropertyTransition<>(animator);
+    }
+
+    return animation;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
new file mode 100644
index 000000000..e863a83be
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.request.transition;
+
+import android.view.View;
+
+/**
+ * A {@link Transition} that accepts an interface that can apply an animation like a {@link
+ * android.view.ViewPropertyAnimator} or a {@link android.animation.ObjectAnimator} that can be used
+ * to transition a resource into a {@link View}.
+ *
+ * @param <R> The type of the resource that will be transitioned into a view.
+ */
+public class ViewPropertyTransition<R> implements Transition<R> {
+
+  private final Animator animator;
+
+  /**
+   * Constructor for a view property animation that takes an {@link ViewPropertyTransition.Animator}
+   * interface that can apply a transition to a view.
+   *
+   * @param animator The animator to use.
+   */
+  public ViewPropertyTransition(Animator animator) {
+    this.animator = animator;
+  }
+
+  /**
+   * Always applies the {@link ViewPropertyTransition.Animator} given in the constructor to the
+   * given view and returns {@code false} because the animator cannot put the new resource on the
+   * view.
+   *
+   * @param current {@inheritDoc}
+   * @param adapter {@inheritDoc}
+   * @return {@inheritDoc}
+   */
+  @Override
+  public boolean transition(R current, ViewAdapter adapter) {
+    final View view = adapter.getView();
+    if (view != null) {
+      animator.animate(adapter.getView());
+    }
+    return false;
+  }
+
+  /**
+   * An interface that allows an animation to be applied on or started from an {@link
+   * android.view.View}.
+   */
+  public interface Animator {
+    /**
+     * Starts an animation on the given {@link android.view.View}.
+     *
+     * @param view The view to transition.
+     */
+    void animate(View view);
+  }
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java
new file mode 100644
index 000000000..c8a18cb6c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.request.transition;
+
+import android.content.Context;
+import android.view.View;
+import android.view.animation.Animation;
+
+/**
+ * A {@link Transition} that can apply a {@link android.view.animation.Animation Animation} to a
+ * {@link android.view.View View} using
+ * {@link android.view.View#startAnimation(android.view.animation.Animation)}.
+ *
+ * @param <R> The type of the resource that will be transitioned into a view.
+ */
+public class ViewTransition<R> implements Transition<R> {
+
+  private final ViewTransitionAnimationFactory viewTransitionAnimationFactory;
+
+  /**
+   * Constructs a new ViewAnimation that will start the given {@link android.view.animation
+   * .Animation}.
+   */
+  ViewTransition(ViewTransitionAnimationFactory viewTransitionAnimationFactory) {
+    this.viewTransitionAnimationFactory = viewTransitionAnimationFactory;
+  }
+
+  /**
+   * Always clears the current animation on the view using
+   * {@link android.view.View#clearAnimation()}, then starts the
+   * {@link android.view.animation.Animation} given in the constructor using
+   * {@link android.view.View#startAnimation(android.view.animation.Animation)} and then returns
+   * {@code false} because the animation does not actually put the current resource on the view.
+   *
+   * @param current {@inheritDoc}
+   * @param adapter {@inheritDoc}
+   * @return {@inheritDoc}
+   */
+  @Override
+  public boolean transition(R current, ViewAdapter adapter) {
+    View view = adapter.getView();
+    if (view != null) {
+      view.clearAnimation();
+      Animation animation = viewTransitionAnimationFactory.build(view.getContext());
+      view.startAnimation(animation);
+    }
+
+    return false;
+  }
+
+  interface ViewTransitionAnimationFactory {
+    Animation build(Context context);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 1ea2ca10c..0764fe285 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -10,54 +10,55 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
- * A utility class for obtaining a {@link com.bumptech.glide.load.Key} signature containing the application version
- * name using {@link android.content.pm.PackageInfo#versionCode}.
+ * A utility class for obtaining a {@link com.bumptech.glide.load.Key} signature containing the
+ * application version name using {@link android.content.pm.PackageInfo#versionCode}.
  */
 public final class ApplicationVersionSignature {
-    private static final ConcurrentHashMap<String, Key> PACKAGE_NAME_TO_KEY = new ConcurrentHashMap<String, Key>();
-
-    /**
-     * Returns the signature {@link com.bumptech.glide.load.Key} for version code of the Application of the given
-     * Context.
-     */
-    public static Key obtain(Context context) {
-        String packageName = context.getPackageName();
-        Key result = PACKAGE_NAME_TO_KEY.get(packageName);
-        if (result == null) {
-            Key toAdd = obtainVersionSignature(context);
-            result = PACKAGE_NAME_TO_KEY.putIfAbsent(packageName, toAdd);
-            // There wasn't a previous mapping, so toAdd is now the Key.
-            if (result == null) {
-                result = toAdd;
-            }
-        }
-
-        return result;
-    }
+  private static final ConcurrentHashMap<String, Key> PACKAGE_NAME_TO_KEY =
+      new ConcurrentHashMap<>();
 
-    // Visible for testing.
-    static void reset() {
-        PACKAGE_NAME_TO_KEY.clear();
+  /**
+   * Returns the signature {@link com.bumptech.glide.load.Key} for version code of the Application
+   * of the given Context.
+   */
+  public static Key obtain(Context context) {
+    String packageName = context.getPackageName();
+    Key result = PACKAGE_NAME_TO_KEY.get(packageName);
+    if (result == null) {
+      Key toAdd = obtainVersionSignature(context);
+      result = PACKAGE_NAME_TO_KEY.putIfAbsent(packageName, toAdd);
+      // There wasn't a previous mapping, so toAdd is now the Key.
+      if (result == null) {
+        result = toAdd;
+      }
     }
 
-    private static Key obtainVersionSignature(Context context) {
-        PackageInfo pInfo = null;
-        try {
-            pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-        } catch (PackageManager.NameNotFoundException e) {
-            // Should never happen.
-            e.printStackTrace();
-        }
-        final String versionCode;
-        if (pInfo != null) {
-            versionCode = String.valueOf(pInfo.versionCode);
-        } else {
-            versionCode = UUID.randomUUID().toString();
-        }
-        return new StringSignature(versionCode);
-    }
+    return result;
+  }
+
+  // Visible for testing.
+  static void reset() {
+    PACKAGE_NAME_TO_KEY.clear();
+  }
 
-    private ApplicationVersionSignature() {
-        // Empty for visibility.
+  private static Key obtainVersionSignature(Context context) {
+    PackageInfo pInfo = null;
+    try {
+      pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+    } catch (PackageManager.NameNotFoundException e) {
+      // Should never happen.
+      e.printStackTrace();
     }
+    final String versionCode;
+    if (pInfo != null) {
+      versionCode = String.valueOf(pInfo.versionCode);
+    } else {
+      versionCode = UUID.randomUUID().toString();
+    }
+    return new StringSignature(versionCode);
+  }
+
+  private ApplicationVersionSignature() {
+    // Empty for visibility.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
index c46c9149f..56d4c474d 100644
--- a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
@@ -2,25 +2,29 @@
 
 import com.bumptech.glide.load.Key;
 
-import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 
 /**
  * An empty key that is always equal to all other empty keys.
  */
 public final class EmptySignature implements Key {
-    private static final EmptySignature EMPTY_KEY = new EmptySignature();
+  private static final EmptySignature EMPTY_KEY = new EmptySignature();
 
-    public static EmptySignature obtain() {
-        return EMPTY_KEY;
-    }
+  public static EmptySignature obtain() {
+    return EMPTY_KEY;
+  }
 
-    private EmptySignature() {
-        // Empty.
-    }
+  private EmptySignature() {
+    // Empty.
+  }
 
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-        // Do nothing.
-    }
+  @Override
+  public String toString() {
+    return "EmptySignature";
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    // Do nothing.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index dbeb876de..37f15a62f 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -2,76 +2,72 @@
 
 import com.bumptech.glide.load.Key;
 
-import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
 /**
- * A unique signature based on metadata data from the media store that detects common changes to media store files like
- * edits, rotations, and temporary file replacement.
+ * A unique signature based on metadata data from the media store that detects common changes to
+ * media store files like edits, rotations, and temporary file replacement.
  */
 public class MediaStoreSignature implements Key {
-    private final String mimeType;
-    private final long dateModified;
-    private final int orientation;
+  private final String mimeType;
+  private final long dateModified;
+  private final int orientation;
 
-    /**
-     * Constructor for {@link com.bumptech.glide.signature.MediaStoreSignature}.
-     *
-     * @param mimeType The mime type of the media store media. Ok to default to empty string "". See
-     *      {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or
-     *      {@link android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}.
-     * @param dateModified The date modified time of the media store media. Ok to default to 0. See
-     *      {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or
-     *      {@link android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}.
-     * @param orientation The orientation of the media store media. Ok to default to 0. See
-     *      {@link android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
-     */
-    public MediaStoreSignature(String mimeType, long dateModified, int orientation) {
-        this.mimeType = mimeType;
-        this.dateModified = dateModified;
-        this.orientation = orientation;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
+  /**
+   * Constructor for {@link com.bumptech.glide.signature.MediaStoreSignature}.
+   *
+   * @param mimeType     The mime type of the media store media. Ok to default to empty string "".
+   *                     See {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or
+   *                     {@link android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}.
+   * @param dateModified The date modified time of the media store media. Ok to default to 0. See
+   *                     {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or
+   *                     {@link android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}.
+   * @param orientation  The orientation of the media store media. Ok to default to 0. See {@link
+   *                     android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
+   */
+  public MediaStoreSignature(String mimeType, long dateModified, int orientation) {
+    this.mimeType = mimeType;
+    this.dateModified = dateModified;
+    this.orientation = orientation;
+  }
 
-        MediaStoreSignature that = (MediaStoreSignature) o;
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
 
-        if (dateModified != that.dateModified) {
-            return false;
-        }
-        if (orientation != that.orientation) {
-            return false;
-        }
-        if (mimeType != null ? !mimeType.equals(that.mimeType) : that.mimeType != null) {
-            return false;
-        }
+    MediaStoreSignature that = (MediaStoreSignature) o;
 
-        return true;
+    if (dateModified != that.dateModified) {
+      return false;
     }
-
-    @Override
-    public int hashCode() {
-        int result = mimeType != null ? mimeType.hashCode() : 0;
-        result = 31 * result + (int) (dateModified ^ (dateModified >>> 32));
-        result = 31 * result + orientation;
-        return result;
+    if (orientation != that.orientation) {
+      return false;
     }
-
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-        byte[] data = ByteBuffer.allocate(12)
-                .putLong(dateModified)
-                .putInt(orientation)
-                .array();
-        messageDigest.update(data);
-        messageDigest.update(mimeType.getBytes(STRING_CHARSET_NAME));
+    if (mimeType != null ? !mimeType.equals(that.mimeType) : that.mimeType != null) {
+      return false;
     }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = mimeType != null ? mimeType.hashCode() : 0;
+    result = 31 * result + (int) (dateModified ^ (dateModified >>> 32));
+    result = 31 * result + orientation;
+    return result;
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    byte[] data = ByteBuffer.allocate(12).putLong(dateModified).putInt(orientation).array();
+    messageDigest.update(data);
+    messageDigest.update(mimeType.getBytes(CHARSET));
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
new file mode 100644
index 000000000..0637bcada
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
@@ -0,0 +1,50 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.util.Preconditions;
+
+import java.security.MessageDigest;
+
+/**
+ * Wraps an {@link java.lang.Object}, delegating {@link #equals(Object)} and {@link #hashCode()} to
+ * the wrapped Object and providing the bytes of the result of the Object's {@link #toString()}
+ * method to the {@link java.security.MessageDigest} in
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}.
+ *
+ * <p> The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
+ * key. </p>
+ */
+public final class ObjectKey implements Key {
+  private final Object object;
+
+  public ObjectKey(Object object) {
+    this.object = Preconditions.checkNotNull(object);
+  }
+
+  @Override
+  public String toString() {
+    return "ObjectKey{"
+        + "object=" + object
+        + '}';
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof ObjectKey) {
+      ObjectKey other = (ObjectKey) o;
+      return object.equals(other.object);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return object.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(object.toString().getBytes(CHARSET));
+  }
+}
+
diff --git a/library/src/main/java/com/bumptech/glide/signature/StringSignature.java b/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
index a5fa2c9f8..5492f2216 100644
--- a/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
@@ -1,44 +1,50 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.util.Preconditions;
 
-import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 
 /**
  * A unique Signature that wraps a String.
+ *
+ * TODO: remove this and replace with ObjectKey.
  */
 public class StringSignature implements Key {
-    private final String signature;
+  private final String signature;
 
-    public StringSignature(String signature) {
-        if (signature == null) {
-            throw new NullPointerException("Signature cannot be null!");
-        }
-        this.signature = signature;
+  public StringSignature(String signature) {
+    this.signature = Preconditions.checkNotNull(signature);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
     }
 
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
+    StringSignature that = (StringSignature) o;
 
-        StringSignature that = (StringSignature) o;
+    return signature.equals(that.signature);
+  }
 
-        return signature.equals(that.signature);
-    }
+  @Override
+  public int hashCode() {
+    return signature.hashCode();
+  }
 
-    @Override
-    public int hashCode() {
-        return signature.hashCode();
-    }
+  @Override
+  public String toString() {
+    return "StringSignature{"
+        + "signature='" + signature + '\''
+        + '}';
+  }
 
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-        messageDigest.update(signature.getBytes(STRING_CHARSET_NAME));
-    }
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(signature.getBytes(CHARSET));
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteArrayPool.java b/library/src/main/java/com/bumptech/glide/util/ByteArrayPool.java
deleted file mode 100644
index f89d5ff3b..000000000
--- a/library/src/main/java/com/bumptech/glide/util/ByteArrayPool.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package com.bumptech.glide.util;
-
-import android.util.Log;
-
-import java.util.Queue;
-
-/**
- * A pool for reusing byte arrays that produces and contains byte arrays of a fixed size.
- */
-public final class ByteArrayPool {
-    private static final String TAG = "ByteArrayPool";
-    // 64 KB.
-    private static final int TEMP_BYTES_SIZE = 64 * 1024;
-    // 512 KB.
-    private static final int MAX_SIZE = 2 * 1048 * 1024;
-    private static final int MAX_BYTE_ARRAY_COUNT = MAX_SIZE / TEMP_BYTES_SIZE;
-
-    private final Queue<byte[]> tempQueue = Util.createQueue(0);
-    private static final ByteArrayPool BYTE_ARRAY_POOL = new ByteArrayPool();
-
-    /**
-     * Returns a constant singleton byte array pool.
-     */
-    public static ByteArrayPool get() {
-        return BYTE_ARRAY_POOL;
-    }
-
-    private ByteArrayPool() {  }
-
-    /**
-     * Removes all byte arrays from the pool.
-     */
-    public void clear() {
-        synchronized (tempQueue) {
-            tempQueue.clear();
-        }
-    }
-
-    /**
-     * Returns a byte array by retrieving one from the pool if the pool is non empty or otherwise by creating a new
-     * byte array.
-     */
-    public byte[] getBytes() {
-        byte[] result;
-        synchronized (tempQueue) {
-            result = tempQueue.poll();
-        }
-        if (result == null) {
-            result = new byte[TEMP_BYTES_SIZE];
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Created temp bytes");
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Adds the given byte array to the pool if it is the correct size and the pool is not full and returns true if
-     * the byte array was added and false otherwise.
-     *
-     * @param bytes The bytes to try to add to the pool.
-     */
-    public boolean releaseBytes(byte[] bytes) {
-        if (bytes.length != TEMP_BYTES_SIZE) {
-            return false;
-        }
-
-        boolean accepted = false;
-        synchronized (tempQueue) {
-            if (tempQueue.size() < MAX_BYTE_ARRAY_COUNT) {
-                accepted = true;
-                tempQueue.offer(bytes);
-            }
-        }
-        return accepted;
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
new file mode 100644
index 000000000..72204c4b4
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -0,0 +1,196 @@
+package com.bumptech.glide.util;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Utilities for interacting with {@link java.nio.ByteBuffer}s.
+ */
+public final class ByteBufferUtil {
+  // 16 Kb
+  private static final int BUFFER_SIZE = 16384;
+  private static final AtomicReference<byte[]> BUFFER_REF = new AtomicReference<>();
+
+  private ByteBufferUtil() {
+    // Utility class.
+  }
+
+  public static ByteBuffer fromFile(File file) throws IOException {
+    RandomAccessFile raf = null;
+    FileChannel channel = null;
+    try {
+      raf = new RandomAccessFile(file, "r");
+      channel = raf.getChannel();
+      return channel.map(FileChannel.MapMode.READ_ONLY, 0, file.length()).load();
+    } finally {
+      if (channel != null) {
+        try {
+          channel.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+      if (raf != null) {
+        try {
+          raf.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+
+  public static void toFile(ByteBuffer buffer, File file) throws IOException {
+    RandomAccessFile raf = null;
+    FileChannel channel = null;
+    try {
+      raf = new RandomAccessFile(file, "rw");
+      channel = raf.getChannel();
+      channel.write(buffer);
+      channel.force(false /*metadata*/);
+      channel.close();
+      raf.close();
+    } finally {
+      if (channel != null) {
+        try {
+          channel.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+      if (raf != null) {
+        try {
+          raf.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+
+  public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOException {
+    SafeArray safeArray = getSafeArray(byteBuffer);
+    if (safeArray != null) {
+      os.write(safeArray.data, safeArray.offset, safeArray.offset + safeArray.limit);
+    } else {
+      byte[] buffer = BUFFER_REF.getAndSet(null);
+      if (buffer == null) {
+        buffer = new byte[BUFFER_SIZE];
+      }
+
+      while (byteBuffer.remaining() > 0) {
+        int toRead = Math.min(byteBuffer.remaining(), buffer.length);
+        byteBuffer.get(buffer, 0 /*dstOffset*/, toRead /*byteCount*/);
+        os.write(buffer, 0, toRead);
+      }
+
+      BUFFER_REF.set(buffer);
+    }
+  }
+
+  public static byte[] toBytes(ByteBuffer byteBuffer) {
+    final byte[] result;
+    SafeArray safeArray = getSafeArray(byteBuffer);
+    if (safeArray != null && safeArray.offset == 0 && safeArray.limit == safeArray.data.length) {
+      result = byteBuffer.array();
+    } else {
+      ByteBuffer toCopy = byteBuffer.asReadOnlyBuffer();
+      result = new byte[toCopy.limit()];
+      toCopy.position(0);
+      toCopy.get(result);
+    }
+    return result;
+  }
+
+  public static InputStream toStream(ByteBuffer buffer) {
+    return new ByteBufferStream(buffer);
+  }
+
+  private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
+    if (!byteBuffer.isReadOnly() && byteBuffer.hasArray()) {
+      return new SafeArray(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit());
+    }
+    return null;
+  }
+
+  static final class SafeArray {
+    private final int offset;
+    private final int limit;
+    private final byte[] data;
+
+    public SafeArray(byte[] data, int offset, int limit) {
+      this.data = data;
+      this.offset = offset;
+      this.limit = limit;
+    }
+  }
+
+  private static class ByteBufferStream extends InputStream {
+    private static final int UNSET = -1;
+    private final ByteBuffer byteBuffer;
+    private int markPos = UNSET;
+
+    public ByteBufferStream(ByteBuffer byteBuffer) {
+      this.byteBuffer = byteBuffer;
+    }
+
+    @Override
+    public int available() throws IOException {
+      return byteBuffer.remaining();
+    }
+
+    @Override
+    public int read() throws IOException {
+      if (!byteBuffer.hasRemaining()) {
+        return -1;
+      }
+      return byteBuffer.get();
+    }
+
+    @Override
+    public synchronized void mark(int readlimit) {
+      markPos = byteBuffer.position();
+    }
+
+    @Override
+    public boolean markSupported() {
+      return true;
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+      if (!byteBuffer.hasRemaining()) {
+        return -1;
+      }
+      int toRead = Math.min(byteCount, available());
+      byteBuffer.get(buffer, byteOffset, toRead);
+      return toRead;
+    }
+
+    @Override
+    public synchronized void reset() throws IOException {
+      if (markPos == UNSET) {
+        throw new IOException("Cannot reset to unset mark position");
+      }
+      // reset() was not implemented correctly in 4.0.4, so we track the mark position ourselves.
+      byteBuffer.position(markPos);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      if (!byteBuffer.hasRemaining()) {
+        return -1;
+      }
+
+      long toSkip = Math.min(byteCount, available());
+      byteBuffer.position((int) (byteBuffer.position() + toSkip));
+      return toSkip;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
new file mode 100644
index 000000000..eac7dfec4
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.util;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Uses the content length as the basis for the return value of {@link #available()} and verifies
+ * that at least content length bytes are returned from the various read methods.
+ */
+public final class ContentLengthInputStream extends FilterInputStream {
+  private static final String TAG = "ContentLengthStream";
+  private static final int UNKNOWN = -1;
+
+  private final long contentLength;
+  private int readSoFar;
+
+  public static InputStream obtain(InputStream other, String contentLengthHeader) {
+    return obtain(other, parseContentLength(contentLengthHeader));
+  }
+
+  public static InputStream obtain(InputStream other, long contentLength) {
+    return new ContentLengthInputStream(other, contentLength);
+  }
+
+  private static int parseContentLength(String contentLengthHeader) {
+    int result = UNKNOWN;
+    if (!TextUtils.isEmpty(contentLengthHeader)) {
+      try {
+        result = Integer.parseInt(contentLengthHeader);
+      } catch (NumberFormatException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
+        }
+      }
+    }
+    return result;
+  }
+
+  ContentLengthInputStream(InputStream in, long contentLength) {
+    super(in);
+    this.contentLength = contentLength;
+  }
+
+  @Override
+  public synchronized int available() throws IOException {
+    return (int) Math.max(contentLength - readSoFar, in.available());
+ }
+
+  @Override
+  public synchronized int read() throws IOException {
+    return checkReadSoFarOrThrow(super.read());
+  }
+
+  @Override
+  public int read(byte[] buffer) throws IOException {
+    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
+  }
+
+  @Override
+  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
+  }
+
+  private int checkReadSoFarOrThrow(int read) throws IOException {
+    if (read >= 0) {
+      readSoFar += read;
+    } else if (contentLength - readSoFar > 0) {
+      throw new IOException("Failed to read all expected data"
+          + ", expected: " + contentLength
+          + ", but read: " + readSoFar);
+    }
+    return read;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
index 344a2894f..c64b8572b 100644
--- a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
@@ -1,138 +1,133 @@
 package com.bumptech.glide.util;
 
-import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Queue;
 
 /**
- * An {@link java.io.InputStream} that catches {@link java.io.IOException}s during read and skip calls and stores them
- * so they can later be handled or thrown. This class is a workaround for a framework issue where exceptions during
- * reads while decoding bitmaps in {@link android.graphics.BitmapFactory} can return partially decoded bitmaps.
+ * An {@link java.io.InputStream} that catches {@link java.io.IOException}s during read and skip
+ * calls and stores them so they can later be handled or thrown. This class is a workaround for a
+ * framework issue where exceptions during reads while decoding bitmaps in {@link
+ * android.graphics.BitmapFactory} can return partially decoded bitmaps.
  *
  * See https://github.com/bumptech/glide/issues/126.
  */
 public class ExceptionCatchingInputStream extends InputStream {
 
-    private static final Queue<ExceptionCatchingInputStream> QUEUE = Util.createQueue(0);
-
-    private RecyclableBufferedInputStream wrapped;
-    private IOException exception;
-
-    public static ExceptionCatchingInputStream obtain(RecyclableBufferedInputStream toWrap) {
-        ExceptionCatchingInputStream result;
-        synchronized (QUEUE) {
-            result = QUEUE.poll();
-        }
-        if (result == null) {
-            result = new ExceptionCatchingInputStream();
-        }
-        result.setInputStream(toWrap);
-        return result;
-    }
-
-    // Exposed for testing.
-    static void clearQueue() {
-        while (!QUEUE.isEmpty()) {
-            QUEUE.remove();
-        }
-    }
-
-    ExceptionCatchingInputStream() {
-        // Do nothing.
-    }
-
-    void setInputStream(RecyclableBufferedInputStream toWrap) {
-        wrapped = toWrap;
-    }
-
-    @Override
-    public int available() throws IOException {
-        return wrapped.available();
-    }
-
-    @Override
-    public void close() throws IOException {
-        wrapped.close();
-    }
-
-    @Override
-    public void mark(int readlimit) {
-        wrapped.mark(readlimit);
-    }
-
-    @Override
-    public boolean markSupported() {
-        return wrapped.markSupported();
-    }
-
-    @Override
-    public int read(byte[] buffer) throws IOException {
-        int read;
-        try {
-            read = wrapped.read(buffer);
-        } catch (IOException e) {
-            exception = e;
-            read = -1;
-        }
-        return read;
-    }
-
-    @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
-        int read;
-        try {
-            read = wrapped.read(buffer, byteOffset, byteCount);
-        } catch (IOException e) {
-            exception = e;
-            read = -1;
-        }
-        return read;
-    }
-
-    @Override
-    public synchronized void reset() throws IOException {
-        wrapped.reset();
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-        long skipped;
-        try {
-            skipped = wrapped.skip(byteCount);
-        } catch (IOException e) {
-            exception = e;
-            skipped = 0;
-        }
-        return skipped;
-    }
-
-    @Override
-    public int read() throws IOException {
-        int result;
-        try {
-            result = wrapped.read();
-        } catch (IOException e) {
-            exception = e;
-            result = -1;
-        }
-        return result;
-    }
-
-    public void fixMarkLimit() {
-        wrapped.fixMarkLimit();
-    }
-
-    public IOException getException() {
-        return exception;
-    }
-
-    public void release() {
-        exception = null;
-        wrapped = null;
-        synchronized (QUEUE) {
-            QUEUE.offer(this);
-        }
-    }
+  private static final Queue<ExceptionCatchingInputStream> QUEUE = Util.createQueue(0);
+
+  private InputStream wrapped;
+  private IOException exception;
+
+  public static ExceptionCatchingInputStream obtain(InputStream toWrap) {
+    ExceptionCatchingInputStream result;
+    synchronized (QUEUE) {
+      result = QUEUE.poll();
+    }
+    if (result == null) {
+      result = new ExceptionCatchingInputStream();
+    }
+    result.setInputStream(toWrap);
+    return result;
+  }
+
+  // Exposed for testing.
+  static void clearQueue() {
+    while (!QUEUE.isEmpty()) {
+      QUEUE.remove();
+    }
+  }
+
+  ExceptionCatchingInputStream() {
+    // Do nothing.
+  }
+
+  void setInputStream(InputStream toWrap) {
+    wrapped = toWrap;
+  }
+
+  @Override
+  public int available() throws IOException {
+    return wrapped.available();
+  }
+
+  @Override
+  public void close() throws IOException {
+    wrapped.close();
+  }
+
+  @Override
+  public void mark(int readlimit) {
+    wrapped.mark(readlimit);
+  }
+
+  @Override
+  public boolean markSupported() {
+    return wrapped.markSupported();
+  }
+
+  @Override
+  public int read(byte[] buffer) throws IOException {
+    int read;
+    try {
+      read = wrapped.read(buffer);
+    } catch (IOException e) {
+      exception = e;
+      read = -1;
+    }
+    return read;
+  }
+
+  @Override
+  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    int read;
+    try {
+      read = wrapped.read(buffer, byteOffset, byteCount);
+    } catch (IOException e) {
+      exception = e;
+      read = -1;
+    }
+    return read;
+  }
+
+  @Override
+  public synchronized void reset() throws IOException {
+    wrapped.reset();
+  }
+
+  @Override
+  public long skip(long byteCount) throws IOException {
+    long skipped;
+    try {
+      skipped = wrapped.skip(byteCount);
+    } catch (IOException e) {
+      exception = e;
+      skipped = 0;
+    }
+    return skipped;
+  }
+
+  @Override
+  public int read() throws IOException {
+    int result;
+    try {
+      result = wrapped.read();
+    } catch (IOException e) {
+      exception = e;
+      result = -1;
+    }
+    return result;
+  }
+
+  public IOException getException() {
+    return exception;
+  }
+
+  public void release() {
+    exception = null;
+    wrapped = null;
+    synchronized (QUEUE) {
+      QUEUE.offer(this);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index f6b001385..c0b9a8940 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -11,20 +11,20 @@
  */
 public class FixedPreloadSizeProvider<T> implements ListPreloader.PreloadSizeProvider<T> {
 
-    private final int[] size;
+  private final int[] size;
 
-    /**
-     * Constructor for a PreloadSizeProvider with a fixed size.
-     *
-     * @param width  The width of the preload size in pixels.
-     * @param height The height of the preload size in pixels.
-     */
-    public FixedPreloadSizeProvider(int width, int height) {
-        this.size = new int[]{width, height};
-    }
+  /**
+   * Constructor for a PreloadSizeProvider with a fixed size.
+   *
+   * @param width  The width of the preload size in pixels.
+   * @param height The height of the preload size in pixels.
+   */
+  public FixedPreloadSizeProvider(int width, int height) {
+    this.size = new int[] { width, height };
+  }
 
-    @Override
-    public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
-        return Arrays.copyOf(this.size, this.size.length);
-    }
+  @Override
+  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
+    return Arrays.copyOf(this.size, this.size.length);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/LogTime.java b/library/src/main/java/com/bumptech/glide/util/LogTime.java
index c5eeb2035..834fc161d 100644
--- a/library/src/main/java/com/bumptech/glide/util/LogTime.java
+++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java
@@ -8,32 +8,32 @@
  * A class for logging elapsed real time in millis.
  */
 public final class LogTime {
-    private static final double MILLIS_MULTIPLIER =
-            Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT ? 1d / Math.pow(10, 6) : 1d;
+  private static final double MILLIS_MULTIPLIER =
+      Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT ? 1d / Math.pow(10, 6) : 1d;
 
-    private LogTime() {
-        // Utility class.
-    }
+  private LogTime() {
+    // Utility class.
+  }
 
-    /**
-     * Returns the current time in either millis or nanos depending on the api level to be used with
-     * {@link #getElapsedMillis(long)}.
-     */
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    public static long getLogTime() {
-        if (Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT) {
-            return SystemClock.elapsedRealtimeNanos();
-        } else {
-            return System.currentTimeMillis();
-        }
+  /**
+   * Returns the current time in either millis or nanos depending on the api level to be used with
+   * {@link #getElapsedMillis(long)}.
+   */
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  public static long getLogTime() {
+    if (Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT) {
+      return SystemClock.elapsedRealtimeNanos();
+    } else {
+      return System.currentTimeMillis();
     }
+  }
 
-    /**
-     * Returns the time elapsed since the given logTime in millis.
-     *
-     * @param logTime The start time of the event.
-     */
-    public static double getElapsedMillis(long logTime) {
-        return (getLogTime() - logTime) * MILLIS_MULTIPLIER;
-    }
+  /**
+   * Returns the time elapsed since the given logTime in millis.
+   *
+   * @param logTime The start time of the event.
+   */
+  public static double getElapsedMillis(long logTime) {
+    return (getLogTime() - logTime) * MILLIS_MULTIPLIER;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index fdc25d7c1..1377e3a15 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,169 +1,176 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.Nullable;
+
 import java.util.LinkedHashMap;
 import java.util.Map;
 
 /**
- * A general purpose size limited cache that evicts items using an LRU algorithm. By default every item is assumed to
- * have a size of one. Subclasses can override {@link #getSize(Object)}} to change the size on a per item basis.
+ * A general purpose size limited cache that evicts items using an LRU algorithm. By default every
+ * item is assumed to have a size of one. Subclasses can override {@link #getSize(Object)}} to
+ * change the size on a per item basis.
  *
  * @param <T> The type of the keys.
  * @param <Y> The type of the values.
  */
 public class LruCache<T, Y> {
-    private final LinkedHashMap<T, Y> cache = new LinkedHashMap<T, Y>(100, 0.75f, true);
-    private int maxSize;
-    private final int initialMaxSize;
-    private int currentSize = 0;
-
-    /**
-     * Constructor for LruCache.
-     *
-     * @param size The maximum size of the cache, the units must match the units used in {@link #getSize(Object)}.
-     */
-    public LruCache(int size) {
-        this.initialMaxSize = size;
-        this.maxSize = size;
-    }
-
-    /**
-     * Sets a size multiplier that will be applied to the size provided in the constructor to set the new size of the
-     * cache. If the new size is less than the current size, entries will be evicted until the current size is less
-     * than or equal to the new size.
-     *
-     * @param multiplier The multiplier to apply.
-     */
-    public void setSizeMultiplier(float multiplier) {
-        if (multiplier < 0) {
-            throw new IllegalArgumentException("Multiplier must be >= 0");
-        }
-        maxSize = Math.round(initialMaxSize * multiplier);
-        evict();
-    }
-
-    /**
-     * Returns the size of a given item, defaulting to one. The units must match those used in the size passed in to the
-     * constructor. Subclasses can override this method to return sizes in various units, usually bytes.
-     *
-     * @param item The item to get the size of.
-     */
-    protected int getSize(Y item) {
-        return 1;
+  private final LinkedHashMap<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
+  private final int initialMaxSize;
+  private int maxSize;
+  private int currentSize = 0;
+
+  /**
+   * Constructor for LruCache.
+   *
+   * @param size The maximum size of the cache, the units must match the units used in {@link
+   *             #getSize(Object)}.
+   */
+  public LruCache(int size) {
+    this.initialMaxSize = size;
+    this.maxSize = size;
+  }
+
+  /**
+   * Sets a size multiplier that will be applied to the size provided in the constructor to put the
+   * new size of the cache. If the new size is less than the current size, entries will be evicted
+   * until the current size is less than or equal to the new size.
+   *
+   * @param multiplier The multiplier to apply.
+   */
+  public synchronized void setSizeMultiplier(float multiplier) {
+    if (multiplier < 0) {
+      throw new IllegalArgumentException("Multiplier must be >= 0");
     }
-
-    /**
-     * A callback called whenever an item is evicted from the cache. Subclasses can override.
-     *
-     * @param key The key of the evicted item.
-     * @param item The evicted item.
-     */
-    protected void onItemEvicted(T key, Y item) {
-        // optional override
+    maxSize = Math.round(initialMaxSize * multiplier);
+    evict();
+  }
+
+  /**
+   * Returns the size of a given item, defaulting to one. The units must match those used in the
+   * size passed in to the constructor. Subclasses can override this method to return sizes in
+   * various units, usually bytes.
+   *
+   * @param item The item to get the size of.
+   */
+  protected int getSize(Y item) {
+    return 1;
+  }
+
+  /**
+   * A callback called whenever an item is evicted from the cache. Subclasses can override.
+   *
+   * @param key  The key of the evicted item.
+   * @param item The evicted item.
+   */
+  protected void onItemEvicted(T key, Y item) {
+    // optional override
+  }
+
+  /**
+   * Returns the current maximum size of the cache in bytes.
+   */
+  public synchronized int getMaxSize() {
+    return maxSize;
+  }
+
+  /**
+   * Returns the sum of the sizes of all items in the cache.
+   */
+  public synchronized int getCurrentSize() {
+    return currentSize;
+  }
+
+  /**
+   * Returns true if there is a value for the given key in the cache.
+   *
+   * @param key The key to check.
+   */
+
+  public synchronized boolean contains(T key) {
+    return cache.containsKey(key);
+  }
+
+  /**
+   * Returns the item in the cache for the given key or null if no such item exists.
+   *
+   * @param key The key to check.
+   */
+  @Nullable
+  public synchronized Y get(T key) {
+    return cache.get(key);
+  }
+
+  /**
+   * Adds the given item to the cache with the given key and returns any previous entry for the
+   * given key that may have already been in the cache.
+   *
+   * <p> If the size of the item is larger than the total cache size, the item will not be added to
+   * the cache and instead {@link #onItemEvicted(Object, Object)} will be called synchronously with
+   * the given key and item. </p>
+   *
+   * @param key  The key to add the item at.
+   * @param item The item to add.
+   */
+  public synchronized Y put(T key, Y item) {
+    final int itemSize = getSize(item);
+    if (itemSize >= maxSize) {
+      onItemEvicted(key, item);
+      return null;
     }
 
-    /**
-     * Returns the current maximum size of the cache in bytes.
-     */
-    public int getMaxSize() {
-        return maxSize;
+    final Y result = cache.put(key, item);
+    if (item != null) {
+      currentSize += getSize(item);
     }
-
-    /**
-     * Returns the sum of the sizes of all items in the cache.
-     */
-    public int getCurrentSize() {
-        return currentSize;
+    if (result != null) {
+      // TODO: should we call onItemEvicted here?
+      currentSize -= getSize(result);
     }
-
-    /**
-     * Returns true if there is a value for the given key in the cache.
-     *
-     * @param key The key to check.
-     */
-
-    public boolean contains(T key) {
-        return cache.containsKey(key);
+    evict();
+
+    return result;
+  }
+
+  /**
+   * Removes the item at the given key and returns the removed item if present, and null otherwise.
+   *
+   * @param key The key to remove the item at.
+   */
+  @Nullable
+  public synchronized Y remove(T key) {
+    final Y value = cache.remove(key);
+    if (value != null) {
+      currentSize -= getSize(value);
     }
-
-    /**
-     * Returns the item in the cache for the given key or null if no such item exists.
-     *
-     * @param key The key to check.
-     */
-    public Y get(T key) {
-        return cache.get(key);
+    return value;
+  }
+
+  /**
+   * Clears all items in the cache.
+   */
+  public void clearMemory() {
+    trimToSize(0);
+  }
+
+  /**
+   * Removes the least recently used items from the cache until the current size is less than the
+   * given size.
+   *
+   * @param size The size the cache should be less than.
+   */
+  protected synchronized void trimToSize(int size) {
+    Map.Entry<T, Y> last;
+    while (currentSize > size) {
+      last = cache.entrySet().iterator().next();
+      final Y toRemove = last.getValue();
+      currentSize -= getSize(toRemove);
+      final T key = last.getKey();
+      cache.remove(key);
+      onItemEvicted(key, toRemove);
     }
+  }
 
-    /**
-     * Adds the given item to the cache with the given key and returns any previous entry for the given key that may
-     * have already been in the cache.
-     *
-     * <p>
-     *     If the size of the item is larger than the total cache size, the item will not be added to the cache and
-     *     instead {@link #onItemEvicted(Object, Object)} will be called synchronously with the given key and item.
-     * </p>
-     *
-     * @param key The key to add the item at.
-     * @param item The item to add.
-     */
-    public Y put(T key, Y item) {
-        final int itemSize = getSize(item);
-        if (itemSize >= maxSize) {
-            onItemEvicted(key, item);
-            return null;
-        }
-
-        final Y result = cache.put(key, item);
-        if (item != null) {
-            currentSize += getSize(item);
-        }
-        if (result != null) {
-            // TODO: should we call onItemEvicted here?
-            currentSize -= getSize(result);
-        }
-        evict();
-
-        return result;
-    }
-
-    /**
-     * Removes the item at the given key and returns the removed item if present, and null otherwise.
-     *
-     * @param key The key to remove the item at.
-     */
-    public Y remove(T key) {
-        final Y value = cache.remove(key);
-        if (value != null) {
-            currentSize -= getSize(value);
-        }
-        return value;
-    }
-
-    /**
-     * Clears all items in the cache.
-     */
-    public void clearMemory() {
-        trimToSize(0);
-    }
-
-    /**
-     * Removes the least recently used items from the cache until the current size is less than the given size.
-     *
-     * @param size The size the cache should be less than.
-     */
-    protected void trimToSize(int size) {
-        Map.Entry<T, Y> last;
-        while (currentSize > size) {
-            last = cache.entrySet().iterator().next();
-            final Y toRemove = last.getValue();
-            currentSize -= getSize(toRemove);
-            final T key = last.getKey();
-            cache.remove(key);
-            onItemEvicted(key, toRemove);
-        }
-    }
-
-    private void evict() {
-        trimToSize(maxSize);
-    }
+  private void evict() {
+    trimToSize(maxSize);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
new file mode 100644
index 000000000..bec16fa67
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
@@ -0,0 +1,89 @@
+package com.bumptech.glide.util;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Prevents {@link InputStream InputStreams} from overflowing their buffer by reading data past
+ * their read limit.
+ */
+public class MarkEnforcingInputStream extends FilterInputStream {
+  private static final int UNSET = Integer.MIN_VALUE;
+  private static final int END_OF_STREAM = -1;
+
+  private int availableBytes = UNSET;
+
+  public MarkEnforcingInputStream(InputStream in) {
+    super(in);
+  }
+
+  @Override
+  public void mark(int readlimit) {
+    super.mark(readlimit);
+    availableBytes = readlimit;
+  }
+
+  @Override
+  public int read() throws IOException {
+    if (getBytesToRead(1) == END_OF_STREAM) {
+      return END_OF_STREAM;
+    }
+
+    int result = super.read();
+    updateAvailableBytesAfterRead(1 /* bytesRead */);
+    return result;
+  }
+
+  @Override
+  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    int toRead = (int) getBytesToRead(byteCount);
+    if (toRead == END_OF_STREAM) {
+      return END_OF_STREAM;
+    }
+
+    int read = super.read(buffer, byteOffset, toRead);
+    updateAvailableBytesAfterRead(read);
+    return read;
+  }
+
+  @Override
+  public void reset() throws IOException {
+    super.reset();
+    availableBytes = UNSET;
+  }
+
+  @Override
+  public long skip(long byteCount) throws IOException {
+    long toSkip = getBytesToRead(byteCount);
+    if (toSkip == END_OF_STREAM) {
+      return END_OF_STREAM;
+    }
+
+    long read = super.skip(toSkip);
+    updateAvailableBytesAfterRead(read);
+    return read;
+  }
+
+  @Override
+  public int available() throws IOException {
+    return availableBytes == UNSET ? super.available()
+        : Math.min(availableBytes, super.available());
+  }
+
+  private long getBytesToRead(long targetByteCount) {
+    if (availableBytes == 0) {
+      return END_OF_STREAM;
+    } else if (availableBytes != UNSET && targetByteCount > availableBytes) {
+      return availableBytes;
+    } else {
+      return targetByteCount;
+    }
+  }
+
+  private void updateAvailableBytesAfterRead(long bytesRead) {
+    if (availableBytes != UNSET && bytesRead != END_OF_STREAM) {
+      availableBytes -= bytesRead;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index 42c5eb739..de27683b6 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -4,55 +4,69 @@
  * A key of two {@link Class}es to be used in hashed collections.
  */
 public class MultiClassKey {
-    private Class<?> first;
-    private Class<?> second;
+  private Class<?> first;
+  private Class<?> second;
+  private Class<?> third;
 
-    public MultiClassKey() {
-        // leave them null
-    }
+  public MultiClassKey() {
+    // leave them null
+  }
 
-    public MultiClassKey(Class<?> first, Class<?> second) {
-        set(first, second);
-    }
+  public MultiClassKey(Class<?> first, Class<?> second) {
+    set(first, second);
+  }
 
-    public void set(Class<?> first, Class<?> second) {
-        this.first = first;
-        this.second = second;
-    }
+  public MultiClassKey(Class<?> first, Class<?> second, Class<?> third) {
+    set(first, second, third);
+  }
 
-    @Override
-    public String toString() {
-        return "MultiClassKey{"
-                + "first=" + first
-                + ", second=" + second
-                + '}';
-    }
+  public void set(Class<?> first, Class<?> second) {
+    set(first, second, null);
+  }
 
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
-
-        MultiClassKey that = (MultiClassKey) o;
-
-        if (!first.equals(that.first)) {
-            return false;
-        }
-        if (!second.equals(that.second)) {
-            return false;
-        }
-
-        return true;
+  public void set(Class<?> first, Class<?> second, Class<?> third) {
+    this.first = first;
+    this.second = second;
+    this.third = third;
+  }
+
+  @Override
+  public String toString() {
+    return "MultiClassKey{" + "first=" + first + ", second=" + second + '}';
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
     }
 
-    @Override
-    public int hashCode() {
-        int result = first.hashCode();
-        result = 31 * result + second.hashCode();
-        return result;
+    MultiClassKey that = (MultiClassKey) o;
+
+    if (!first.equals(that.first)) {
+      return false;
+    }
+    if (!second.equals(that.second)) {
+      return false;
+    }
+    if (third == null && that.third != null) {
+      return false;
     }
+    if (third != null && !third.equals(that.third)) {
+      return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = first.hashCode();
+    result = 31 * result + second.hashCode();
+    result = 31 * result + (third != null ? third.hashCode() : 0);
+    return result;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/Preconditions.java b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
new file mode 100644
index 000000000..8356ab943
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
@@ -0,0 +1,46 @@
+package com.bumptech.glide.util;
+
+import android.text.TextUtils;
+
+import java.util.Collection;
+
+/**
+ * Contains common assertions.
+ */
+public final class Preconditions {
+
+  private Preconditions() {
+    // Utility class.
+  }
+
+  public static void checkArgument(boolean expression, String message) {
+    if (!expression) {
+      throw new IllegalArgumentException(message);
+    }
+  }
+
+  public static <T> T checkNotNull(T arg) {
+    return checkNotNull(arg, "Argument must not be null");
+  }
+
+  public static <T> T checkNotNull(T arg, String message) {
+    if (arg == null) {
+      throw new NullPointerException(message);
+    }
+    return arg;
+  }
+
+  public static String checkNotEmpty(String string) {
+    if (TextUtils.isEmpty(string)) {
+      throw new IllegalArgumentException("Must not be null or empty");
+    }
+    return string;
+  }
+
+  public static <T extends Collection<Y>, Y> T checkNotEmpty(T collection) {
+    if (collection.isEmpty()) {
+      throw new IllegalArgumentException("Must not be empty.");
+    }
+    return collection;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index cc0743fe7..762d49765 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -5,144 +5,177 @@
 import android.os.Build;
 import android.os.Looper;
 
+import com.bumptech.glide.request.target.Target;
+
 import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
 import java.util.Queue;
 
 /**
  * A collection of assorted utility classes.
  */
 public final class Util {
-    private static final char[] HEX_CHAR_ARRAY = "0123456789abcdef".toCharArray();
-    // 32 bytes from sha-256 -> 64 hex chars.
-    private static final char[] SHA_256_CHARS = new char[64];
-    // 20 bytes from sha-1 -> 40 chars.
-    private static final char[] SHA_1_CHARS = new char[40];
-
-    private Util() {
-        // Utility class.
+  private static final char[] HEX_CHAR_ARRAY = "0123456789abcdef".toCharArray();
+  // 32 bytes from sha-256 -> 64 hex chars.
+  private static final char[] SHA_256_CHARS = new char[64];
+
+  private Util() {
+    // Utility class.
+  }
+
+  /**
+   * Returns the hex string of the given byte array representing a SHA256 hash.
+   */
+  public static String sha256BytesToHex(byte[] bytes) {
+    synchronized (SHA_256_CHARS) {
+      return bytesToHex(bytes, SHA_256_CHARS);
     }
-
-    /**
-     * Returns the hex string of the given byte array representing a SHA256 hash.
-     */
-    public static String sha256BytesToHex(byte[] bytes) {
-        return bytesToHex(bytes, SHA_256_CHARS);
+  }
+
+  // Taken from:
+  // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
+  // /9655275#9655275
+  private static String bytesToHex(byte[] bytes, char[] hexChars) {
+    int v;
+    for (int j = 0; j < bytes.length; j++) {
+      v = bytes[j] & 0xFF;
+      hexChars[j * 2] = HEX_CHAR_ARRAY[v >>> 4];
+      hexChars[j * 2 + 1] = HEX_CHAR_ARRAY[v & 0x0F];
     }
-
-    /**
-     * Returns the hex string of the given byte array representing a SHA1 hash.
-     */
-    public static String sha1BytesToHex(byte[] bytes) {
-        return bytesToHex(bytes, SHA_1_CHARS);
+    return new String(hexChars);
+  }
+
+  /**
+   * Returns the allocated byte size of the given bitmap.
+   *
+   * @see #getBitmapByteSize(android.graphics.Bitmap)
+   * @deprecated Use {@link #getBitmapByteSize(android.graphics.Bitmap)} instead. Scheduled to be
+   * removed in Glide 4.0.
+   */
+  @Deprecated
+  public static int getSize(Bitmap bitmap) {
+    return getBitmapByteSize(bitmap);
+  }
+
+  /**
+   * Returns the in memory size of the given {@link Bitmap} in bytes.
+   */
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  public static int getBitmapByteSize(Bitmap bitmap) {
+    // The return value of getAllocationByteCount silently changes for recycled bitmaps from the
+    // internal buffer size to row bytes * height. To avoid random inconsistencies in caches, we
+    // instead assert here.
+    if (bitmap.isRecycled()) {
+      throw new IllegalStateException("Cannot obtain size for recycled Bitmap: " + bitmap
+          + "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig());
     }
-
-    // Taken from:
-    // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java/9655275#9655275
-    private static String bytesToHex(byte[] bytes, char[] hexChars) {
-        int v;
-        for (int j = 0; j < bytes.length; j++) {
-            v = bytes[j] & 0xFF;
-            hexChars[j * 2] = HEX_CHAR_ARRAY[v >>> 4];
-            hexChars[j * 2 + 1] = HEX_CHAR_ARRAY[v & 0x0F];
-        }
-        return new String(hexChars);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148.
+      try {
+        return bitmap.getAllocationByteCount();
+      } catch (NullPointerException e) {
+        // Do nothing.
+      }
     }
-
-    /**
-     * Returns the allocated byte size of the given bitmap.
-     *
-     * @see #getBitmapByteSize(android.graphics.Bitmap)
-     *
-     * @deprecated Use {@link #getBitmapByteSize(android.graphics.Bitmap)} instead. Scheduled to be removed in Glide
-     * 4.0.
-     */
-    @Deprecated
-    public static int getSize(Bitmap bitmap) {
-        return getBitmapByteSize(bitmap);
+    return bitmap.getHeight() * bitmap.getRowBytes();
+  }
+
+  /**
+   * Returns the in memory size of {@link android.graphics.Bitmap} with the given width, height, and
+   * {@link android.graphics.Bitmap.Config}.
+   */
+  public static int getBitmapByteSize(int width, int height, Bitmap.Config config) {
+    return width * height * getBytesPerPixel(config);
+  }
+
+  private static int getBytesPerPixel(Bitmap.Config config) {
+    // A bitmap by decoding a gif has null "config" in certain environments.
+    if (config == null) {
+      config = Bitmap.Config.ARGB_8888;
     }
 
-    /**
-     * Returns the in memory size of the given {@link Bitmap} in bytes.
-     */
-    @TargetApi(Build.VERSION_CODES.KITKAT)
-    public static int getBitmapByteSize(Bitmap bitmap) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148.
-            try {
-                return bitmap.getAllocationByteCount();
-            } catch (NullPointerException e) {
-                // Do nothing.
-            }
-        }
-        return bitmap.getHeight() * bitmap.getRowBytes();
+    int bytesPerPixel;
+    switch (config) {
+      case ALPHA_8:
+        bytesPerPixel = 1;
+        break;
+      case RGB_565:
+      case ARGB_4444:
+        bytesPerPixel = 2;
+        break;
+      case ARGB_8888:
+      default:
+        bytesPerPixel = 4;
     }
-
-    /**
-     * Returns the in memory size of {@link android.graphics.Bitmap} with the given width, height, and
-     * {@link android.graphics.Bitmap.Config}.
-     */
-    public static int getBitmapByteSize(int width, int height, Bitmap.Config config) {
-        return width * height * getBytesPerPixel(config);
-    }
-
-    private static int getBytesPerPixel(Bitmap.Config config) {
-        // A bitmap by decoding a gif has null "config" in certain environments.
-        if (config == null) {
-            config = Bitmap.Config.ARGB_8888;
-        }
-
-        int bytesPerPixel;
-        switch (config) {
-            case ALPHA_8:
-                bytesPerPixel = 1;
-                break;
-            case RGB_565:
-            case ARGB_4444:
-                bytesPerPixel = 2;
-                break;
-            case ARGB_8888:
-            default:
-                bytesPerPixel = 4;
-        }
-        return bytesPerPixel;
+    return bytesPerPixel;
+  }
+
+  /**
+   * Returns true if width and height are both > 0 and/or equal to {@link Target#SIZE_ORIGINAL}.
+   */
+  public static boolean isValidDimensions(int width, int height) {
+    return isValidDimension(width) && isValidDimension(height);
+  }
+
+  private static boolean isValidDimension(int dimen) {
+    return dimen > 0 || dimen == Target.SIZE_ORIGINAL;
+  }
+
+  /**
+   * Throws an {@link java.lang.IllegalArgumentException} if called on a thread other than the main
+   * thread.
+   */
+  public static void assertMainThread() {
+    if (!isOnMainThread()) {
+      throw new IllegalArgumentException("You must call this method on the main thread");
     }
-
-    /**
-     * Throws an {@link java.lang.IllegalArgumentException} if called on a thread other than the main thread.
-     */
-    public static void assertMainThread() {
-        if (!isOnMainThread()) {
-            throw new IllegalArgumentException("You must call this method on the main thread");
-        }
-    }
-
-    /**
-     * Throws an {@link java.lang.IllegalArgumentException} if called on the main thread.
-     */
-    public static void assertBackgroundThread() {
-        if (!isOnBackgroundThread()) {
-            throw new IllegalArgumentException("YOu must call this method on a background thread");
-        }
-    }
-
-    /**
-     * Returns {@code true} if called on the main thread, {@code false} otherwise.
-     */
-    public static boolean isOnMainThread() {
-        return Looper.myLooper() == Looper.getMainLooper();
-    }
-
-    /**
-     * Returns {@code true} if called on the main thread, {@code false} otherwise.
-     */
-    public static boolean isOnBackgroundThread() {
-        return !isOnMainThread();
-    }
-
-    /**
-     * Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation.
-     */
-    public static <T> Queue<T> createQueue(int size) {
-        return new ArrayDeque<T>(size);
+  }
+
+  /**
+   * Throws an {@link java.lang.IllegalArgumentException} if called on the main thread.
+   */
+  public static void assertBackgroundThread() {
+    if (!isOnBackgroundThread()) {
+      throw new IllegalArgumentException("You must call this method on a background thread");
     }
+  }
+
+  /**
+   * Returns {@code true} if called on the main thread, {@code false} otherwise.
+   */
+  public static boolean isOnMainThread() {
+    return Looper.myLooper() == Looper.getMainLooper();
+  }
+
+  /**
+   * Returns {@code true} if called on the main thread, {@code false} otherwise.
+   */
+  public static boolean isOnBackgroundThread() {
+    return !isOnMainThread();
+  }
+
+  /**
+   * Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation.
+   */
+  public static <T> Queue<T> createQueue(int size) {
+    return new ArrayDeque<>(size);
+  }
+
+  /**
+   * Returns a copy of the given list that is safe to iterate over and perform actions that may
+   * modify the original list.
+   *
+   * <p> See #303 and #375. </p>
+   */
+  public static <T> List<T> getSnapshot(Collection<T> other) {
+      // toArray creates a new ArrayList internally and this way we can guarantee entries will not
+      // be null. See #322.
+      List<T> result = new ArrayList<T>(other.size());
+      for (T item : other) {
+          result.add(item);
+      }
+      return result;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index 477708be0..5677b391d 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -3,85 +3,87 @@
 import android.view.View;
 
 import com.bumptech.glide.ListPreloader;
-import com.bumptech.glide.request.animation.GlideAnimation;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.ViewTarget;
+import com.bumptech.glide.request.transition.Transition;
 
 import java.util.Arrays;
 
 /**
- * A {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} that will extract the preload size from a given
- * {@link android.view.View}.
+ * A {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} that will extract the preload size
+ * from a given {@link android.view.View}.
  *
  * @param <T> The type of the model the size should be provided for.
  */
-public class ViewPreloadSizeProvider<T> implements ListPreloader.PreloadSizeProvider<T>, SizeReadyCallback {
-    private int[] size;
-    // We need to keep a strong reference to the Target so that it isn't garbage collected due to a weak reference
-    // while we're waiting to get its size.
-    @SuppressWarnings("unused")
-    private SizeViewTarget viewTarget;
+public class ViewPreloadSizeProvider<T> implements ListPreloader.PreloadSizeProvider<T>,
+    SizeReadyCallback {
+  private int[] size;
+  // We need to keep a strong reference to the Target so that it isn't garbage collected due to a
+  // weak reference
+  // while we're waiting to get its size.
+  @SuppressWarnings("unused")
+  private SizeViewTarget viewTarget;
 
-    /**
-     * Constructor that does nothing by default and requires users to call {@link #setView(android.view.View)} when a
-     * View is available to initialize the dimensions returned by this class.
-     */
-    public ViewPreloadSizeProvider() {
-        // This constructor is intentionally empty. Nothing special is needed here.
-    }
+  /**
+   * Constructor that does nothing by default and requires users to call {@link
+   * #setView(android.view.View)} when a View is available to registerComponents the dimensions
+   * returned by this class.
+   */
+  public ViewPreloadSizeProvider() {
+    // This constructor is intentionally empty. Nothing special is needed here.
+  }
 
-    /**
-     * Constructor that will extract the preload size from a given {@link android.view.View}.
-     *
-     * @param view A not null View the size will be extracted from async using an {@link android.view.ViewTreeObserver
-     *             .OnPreDrawListener}
-     */
-    public ViewPreloadSizeProvider(View view) {
-        setView(view);
-    }
+  /**
+   * Constructor that will extract the preload size from a given {@link android.view.View}.
+   *
+   * @param view A not null View the size will be extracted from async using an {@link
+   *             android.view.ViewTreeObserver .OnPreDrawListener}
+   */
+  public ViewPreloadSizeProvider(View view) {
+    setView(view);
+  }
 
-    @Override
-    public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
-        if (size == null) {
-            return null;
-        } else {
-            return Arrays.copyOf(this.size, this.size.length);
-        }
+  @Override
+  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
+    if (size == null) {
+      return null;
+    } else {
+      return Arrays.copyOf(this.size, this.size.length);
     }
+  }
 
-    @Override
-    public void onSizeReady(int width, int height) {
-        this.size = new int[]{width, height};
-        viewTarget = null;
-    }
+  @Override
+  public void onSizeReady(int width, int height) {
+    this.size = new int[] { width, height };
+    viewTarget = null;
+  }
 
-    /**
-     * Sets the {@link android.view.View} the size will be extracted.
-     *
-     * <p>
-     *     Note - only the first call to this method will be obeyed, subsequent requests will be ignored.
-     * </p>
-     *
-     * @param view A not null View the size will be extracted async with an {@link android.view.ViewTreeObserver
-     *             .OnPreDrawListener}
-     */
-    public void setView(View view) {
-        if (this.size != null || viewTarget != null) {
-            return;
-        }
-        this.viewTarget = new SizeViewTarget(view, this);
+  /**
+   * Sets the {@link android.view.View} the size will be extracted.
+   *
+   * <p> Note - only the first call to this method will be obeyed, subsequent requests will be
+   * ignored. </p>
+   *
+   * @param view A not null View the size will be extracted async with an {@link
+   *             android.view.ViewTreeObserver .OnPreDrawListener}
+   */
+  public void setView(View view) {
+    if (this.size != null || viewTarget != null) {
+      return;
     }
+    this.viewTarget = new SizeViewTarget(view, this);
+  }
 
-    private static final class SizeViewTarget extends ViewTarget<View, Object> {
+  private static final class SizeViewTarget extends ViewTarget<View, Object> {
 
-        public SizeViewTarget(View view, SizeReadyCallback callback) {
-            super(view);
-            getSize(callback);
-        }
+    public SizeViewTarget(View view, SizeReadyCallback callback) {
+      super(view);
+      getSize(callback);
+    }
 
-        @Override
-        public void onResourceReady(Object resource, GlideAnimation glideAnimation) {
-            // Do nothing
-        }
+    @Override
+    public void onResourceReady(Object resource, Transition transition) {
+      // Do nothing
     }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
new file mode 100644
index 000000000..87c9d71fc
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -0,0 +1,163 @@
+package com.bumptech.glide.util.pool;
+
+import android.support.v4.util.Pools.Pool;
+import android.support.v4.util.Pools.SimplePool;
+import android.support.v4.util.Pools.SynchronizedPool;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provides implementations of {@link Pool} never return {@code null}, log when new instances are
+ * created, and that can use the {@link com.bumptech.glide.util.pool.FactoryPools.Poolable}
+ * interface to ensure objects aren't used while inside the pool.
+ */
+public final class FactoryPools {
+  private static final String TAG = "FactoryPools";
+  private static final int DEFAULT_POOL_SIZE = 20;
+  private static final Resetter<Object> EMPTY_RESETTER = new Resetter<Object>() {
+    @Override
+    public void reset(Object object) {
+      // Do nothing.
+    }
+  };
+
+  private FactoryPools() { }
+
+  /**
+   * Returns a non-thread safe {@link Pool} that never returns {@code null} from
+   * {@link Pool#acquire()} and that contains objects of the type created by the given
+   * {@link Factory} with the given maximum size.
+   *
+   * <p>If the pool is empty when {@link Pool#acquire()} is called, the given {@link Factory} will
+   * be used to create a new instance.
+   *
+   * @param <T> The type of object the pool will contains.
+   */
+  public static <T extends Poolable> Pool<T> simple(int size, Factory<T> factory) {
+    return build(new SimplePool<T>(size), factory);
+  }
+
+  /**
+   * Returns a new thread safe {@link Pool} that never returns {@code null} from
+   * {@link Pool#acquire()} and that contains objects of the type created by the given
+   * {@link Factory} with the given maximum size.
+   *
+   * <p>If the pool is empty when {@link Pool#acquire()} is called, the given {@link Factory} will
+   * be used to create a new instance.
+   *
+   * @param <T> The type of object the pool will contains.
+   */
+  public static <T extends Poolable> Pool<T> threadSafe(int size, Factory<T> factory) {
+    return build(new SynchronizedPool<T>(size), factory);
+  }
+
+  /**
+   * Returns a new {@link Pool} that never returns {@code null} and that contains {@link List Lists}
+   * of a specific generic type with a standard maximum size of 20.
+   *
+   * <p>If the pool is empty when {@link Pool#acquire()} is called, a new {@link List} will be
+   * created.
+   *
+   * @param <T> The type of object that the {@link List Lists} will contain.
+   */
+  public static <T> Pool<List<T>> threadSafeList() {
+    return threadSafeList(DEFAULT_POOL_SIZE);
+  }
+
+  /**
+   * Returns a new thread safe {@link Pool} that never returns {@code null} and that contains
+   * {@link List Lists} of a specific generic type with the given maximum size.
+   *
+   * <p>If the pool is empty when {@link Pool#acquire()} is called, a new {@link List} will be
+   * created.
+   *
+   * @param <T> The type of object that the {@link List Lists} will contain.
+   */
+  public static <T> Pool<List<T>> threadSafeList(int size) {
+    return build(new SynchronizedPool<List<T>>(size), new Factory<List<T>>() {
+      @Override
+      public List<T> create() {
+        return new ArrayList<>();
+      }
+    }, new Resetter<List<T>>() {
+      @Override
+      public void reset(List<T> object) {
+        object.clear();
+      }
+    });
+  }
+
+  private static <T extends Poolable> Pool<T> build(Pool<T> pool, Factory<T> factory) {
+    return build(pool, factory, FactoryPools.<T>emptyResetter());
+  }
+
+  private static <T> Pool<T> build(Pool<T> pool, Factory<T> factory,
+      Resetter<T> resetter) {
+    return new FactoryPool<>(pool, factory, resetter);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Resetter<T> emptyResetter() {
+    return (Resetter<T>) EMPTY_RESETTER;
+  }
+
+  /**
+   * Creates new instances of the given type.
+   */
+  public interface Factory<T> {
+    T create();
+  }
+
+  /**
+   * Resets state when objects are returned to the pool.
+   */
+  public interface Resetter<T> {
+    void reset(T object);
+  }
+
+  /**
+   * Allows additional verification to catch errors caused by using objects while they are in
+   * an object pool.
+   */
+  public interface Poolable {
+    StateVerifier getVerifier();
+  }
+
+  private static final class FactoryPool<T> implements Pool<T> {
+    private final Factory<T> factory;
+    private final Resetter<T> resetter;
+    private final Pool<T> pool;
+
+    FactoryPool(Pool<T> pool, Factory<T> factory, Resetter<T> resetter) {
+      this.pool = pool;
+      this.factory = factory;
+      this.resetter = resetter;
+    }
+
+    @Override
+    public T acquire() {
+      T result = pool.acquire();
+      if (result == null) {
+        result = factory.create();
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Created new " + result.getClass());
+        }
+      }
+      if (result instanceof Poolable) {
+        ((Poolable) result).getVerifier().setRecycled(false /*isRecycled*/);
+      }
+      return result;
+    }
+
+    @Override
+    public boolean release(T instance) {
+      if (instance instanceof Poolable) {
+        ((Poolable) instance).getVerifier().setRecycled(true /*isRecycled*/);
+      }
+      resetter.reset(instance);
+      return pool.release(instance);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
new file mode 100644
index 000000000..b5268c68b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -0,0 +1,69 @@
+package com.bumptech.glide.util.pool;
+
+/**
+ * Verifies that the job is not in the recycled state.
+ */
+public abstract class StateVerifier {
+  private static final boolean DEBUG = false;
+
+  /**
+   * Creates a new {@link StateVerifier} instance.
+   */
+  public static StateVerifier newInstance() {
+    if (DEBUG) {
+      return new DebugStateVerifier();
+    } else {
+      return new DefaultStateVerifier();
+    }
+  }
+
+  private StateVerifier() { }
+
+  /**
+   * Throws an exception if we believe our object is recycled and inactive (ie is currently in an
+   * object pool).
+   */
+  public abstract void throwIfRecycled();
+
+  /**
+   * Sets whether or not our objet is recycled.
+   */
+  abstract void setRecycled(boolean isRecycled);
+
+  private static class DefaultStateVerifier extends StateVerifier {
+    private volatile boolean isReleased;
+
+    @Override
+    public void throwIfRecycled() {
+      if (isReleased) {
+        throw new IllegalStateException("Already released");
+      }
+    }
+
+    @Override
+    public void setRecycled(boolean isRecycled) {
+      this.isReleased = isRecycled;
+    }
+  }
+
+  private static class DebugStateVerifier extends StateVerifier {
+    // Keeps track of the stack trace where our state was set to recycled.
+    private volatile RuntimeException recycledAtStackTraceException;
+
+    @Override
+    public void throwIfRecycled() {
+      if (recycledAtStackTraceException != null) {
+        throw new IllegalStateException("Already released", recycledAtStackTraceException);
+      }
+    }
+
+    @Override
+    void setRecycled(boolean isRecycled) {
+      if (isRecycled) {
+        this.recycledAtStackTraceException = new RuntimeException("Released");
+      } else {
+        this.recycledAtStackTraceException = null;
+      }
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
new file mode 100644
index 000000000..01bdd28b8
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -0,0 +1,774 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
+import static com.bumptech.glide.request.RequestOptions.placeholderOf;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Matchers.notNull;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.res.AssetFileDescriptor;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.media.MediaMetadataRetriever;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ParcelFileDescriptor;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.testutil.TestResourceUtil;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
+import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.res.builder.RobolectricPackageManager;
+import org.robolectric.shadows.ShadowBitmap;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Tests for the {@link Glide} interface and singleton.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = {
+    GlideTest.ShadowFileDescriptorContentResolver.class,
+    GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
+    GlideTest.MutableShadowBitmap.class })
+public class GlideTest {
+  private Target target = null;
+  private ImageView imageView;
+  private RequestManager requestManager;
+
+  @Before
+  public void setUp() throws Exception {
+    Glide.tearDown();
+
+    RobolectricPackageManager pm =
+        (RobolectricPackageManager) RuntimeEnvironment.application.getPackageManager();
+    ApplicationInfo info =
+        pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
+    info.metaData = new Bundle();
+    info.metaData.putString(SetupModule.class.getName(), "GlideModule");
+
+    // Ensure that target's size ready callback will be called synchronously.
+    target = mock(Target.class);
+    imageView = new ImageView(RuntimeEnvironment.application);
+    imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+    doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
+
+    Handler bgHandler = mock(Handler.class);
+    when(bgHandler.post(isA(Runnable.class))).thenAnswer(new Answer<Boolean>() {
+      @Override
+      public Boolean answer(InvocationOnMock invocation) throws Throwable {
+        Runnable runnable = (Runnable) invocation.getArguments()[0];
+        runnable.run();
+        return true;
+      }
+    });
+
+    Lifecycle lifecycle = mock(Lifecycle.class);
+    RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
+    requestManager = new RequestManager(getContext(), lifecycle, treeNode);
+    requestManager.resumeRequests();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @Test
+  public void testCanSetMemoryCategory() {
+    MemoryCache memoryCache = mock(MemoryCache.class);
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+
+    MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+    Glide glide =
+        new GlideBuilder(getContext()).setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
+            .createGlide();
+    glide.setMemoryCategory(memoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+  }
+
+  @Test
+  public void testClearMemory() {
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+    MemoryCache memoryCache = mock(MemoryCache.class);
+
+    Glide glide =
+        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
+            .createGlide();
+
+    glide.clearMemory();
+
+    verify(bitmapPool).clearMemory();
+    verify(memoryCache).clearMemory();
+  }
+
+  @Test
+  public void testTrimMemory() {
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+    MemoryCache memoryCache = mock(MemoryCache.class);
+
+    Glide glide =
+        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
+            .createGlide();
+
+    final int level = 123;
+
+    glide.trimMemory(level);
+
+    verify(bitmapPool).trimMemory(eq(level));
+    verify(memoryCache).trimMemory(eq(level));
+  }
+
+  @Test
+  public void testFileDefaultLoaderWithInputStream() throws Exception {
+    registerFailFactory(File.class, ParcelFileDescriptor.class);
+    runTestFileDefaultLoader();
+  }
+
+  @Test
+  public void testFileDefaultLoaderWithFileDescriptor() throws Exception {
+    registerFailFactory(File.class, InputStream.class);
+    runTestFileDefaultLoader();
+  }
+
+  @Test
+  public void testFileDefaultLoader() {
+    runTestFileDefaultLoader();
+  }
+
+  private void runTestFileDefaultLoader() {
+    File file = new File("fake");
+    mockUri(Uri.fromFile(file));
+
+    requestManager.load(file).into(target);
+    requestManager.load(file).into(imageView);
+
+    verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
+    verify(target).setRequest((Request) notNull());
+
+    assertNotNull(imageView.getDrawable());
+  }
+
+  @Test
+  public void testUrlDefaultLoader() throws MalformedURLException {
+    URL url = new URL("http://www.google.com");
+
+    requestManager.load(url).into(target);
+    requestManager.load(url).into(imageView);
+
+    verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
+    verify(target).setRequest((Request) notNull());
+
+    assertNotNull(imageView.getDrawable());
+  }
+
+  @Test
+  public void testAsBitmapOption() {
+    Uri uri = Uri.parse("content://something/else");
+    mockUri(uri);
+
+    requestManager.asBitmap().load(uri).into(target);
+
+    verify(target).onResourceReady(isA(Bitmap.class), isA(Transition.class));
+  }
+
+  @Test
+  public void testToBytesOption() {
+    Uri uri = Uri.parse("content://something/else");
+    mockUri(uri);
+
+    requestManager.as(byte[].class).apply(decodeTypeOf(Bitmap.class)).load(uri).into(target);
+
+    verify(target).onResourceReady(isA(byte[].class), isA(Transition.class));
+  }
+
+  @Test
+  public void testUriDefaultLoaderWithInputStream() throws Exception {
+    registerFailFactory(Uri.class, ParcelFileDescriptor.class);
+    runTestUriDefaultLoader();
+  }
+
+  @Test
+  public void testUriDefaultLoaderWithFileDescriptor() throws Exception {
+    registerFailFactory(Uri.class, InputStream.class);
+    runTestUriDefaultLoader();
+  }
+
+  @Test
+  public void testUriDefaultLoader() {
+    runTestUriDefaultLoader();
+  }
+
+  private void runTestUriDefaultLoader() {
+    Uri uri = Uri.parse("content://test/something");
+    mockUri(uri);
+
+    requestManager.load(uri).into(target);
+    requestManager.load(uri).into(imageView);
+
+    verify(target).onResourceReady(notNull(), isA(Transition.class));
+    verify(target).setRequest((Request) notNull());
+
+    assertNotNull(imageView.getDrawable());
+  }
+
+  @Test
+  public void testStringDefaultLoaderWithUrl() {
+    runTestStringDefaultLoader("http://www.google.com");
+  }
+
+  @Test
+  public void testFileStringDefaultLoaderWithInputStream() throws Exception {
+    registerFailFactory(String.class, ParcelFileDescriptor.class);
+    runTestFileStringDefaultLoader();
+  }
+
+  @Test
+  public void testFileStringDefaultLoaderWithFileDescriptor() throws Exception {
+    registerFailFactory(String.class, ParcelFileDescriptor.class);
+    runTestFileStringDefaultLoader();
+  }
+
+  @Test
+  public void testFileStringDefaultLoader() {
+    runTestFileStringDefaultLoader();
+  }
+
+  private void runTestFileStringDefaultLoader() {
+    String path = "/some/random/path";
+    mockUri(Uri.fromFile(new File(path)));
+    runTestStringDefaultLoader(path);
+  }
+
+  @Test
+  public void testUriStringDefaultLoaderWithInputStream() throws Exception {
+    registerFailFactory(String.class, ParcelFileDescriptor.class);
+    runTestUriStringDefaultLoader();
+  }
+
+  @Test
+  public void testUriStringDefaultLoaderWithFileDescriptor() throws Exception {
+    registerFailFactory(String.class, InputStream.class);
+    runTestUriStringDefaultLoader();
+  }
+
+  @Test
+  public void testUriStringDefaultLoader() {
+    runTestUriStringDefaultLoader();
+  }
+
+  private void runTestUriStringDefaultLoader() {
+    String stringUri = "content://some/random/uri";
+    mockUri(Uri.parse(stringUri));
+    runTestStringDefaultLoader(stringUri);
+  }
+
+  private void runTestStringDefaultLoader(String string) {
+    requestManager.load(string).listener(new RequestListener<Drawable>() {
+      @Override
+      public boolean onLoadFailed(GlideException e, Object model, Target target,
+          boolean isFirstResource) {
+        throw new RuntimeException("Load failed");
+      }
+
+      @Override
+      public boolean onResourceReady(Drawable resource, Object model, Target target,
+          DataSource dataSource, boolean isFirstResource) {
+        return false;
+      }
+    }).into(target);
+    requestManager.load(string).into(imageView);
+
+    verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
+    verify(target).setRequest((Request) notNull());
+
+    assertNotNull(imageView.getDrawable());
+  }
+
+  @Test
+  public void testIntegerDefaultLoaderWithInputStream() throws Exception {
+    registerFailFactory(Integer.class, ParcelFileDescriptor.class);
+    runTestIntegerDefaultLoader();
+  }
+
+  @Test
+  public void testIntegerDefaultLoaderWithFileDescriptor() throws Exception {
+    registerFailFactory(Integer.class, InputStream.class);
+    runTestIntegerDefaultLoader();
+  }
+
+  @Test
+  public void testIntegerDefaultLoader() {
+    runTestIntegerDefaultLoader();
+  }
+
+  private void runTestIntegerDefaultLoader() {
+    int integer = android.R.drawable.star_on;
+    mockUri("android.resource://" + "android" + "/drawable/star_on");
+
+    requestManager.load(integer).into(target);
+    requestManager.load(integer).into(imageView);
+
+    verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
+    verify(target).setRequest((Request) notNull());
+
+    assertNotNull(imageView.getDrawable());
+  }
+
+  @Test
+  public void testByteArrayDefaultLoader() {
+    byte[] bytes = new byte[10];
+    requestManager.load(bytes).into(target);
+    requestManager.load(bytes).into(imageView);
+
+    verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
+    verify(target).setRequest((Request) notNull());
+
+    assertNotNull(imageView.getDrawable());
+  }
+
+
+  @Test(expected = Exception.class)
+  public void testUnregisteredModelThrowsException() {
+    Float unregistered = 0.5f;
+    requestManager.load(unregistered).into(target);
+  }
+
+  @Test
+  @SuppressWarnings("unchecked")
+  public void testNonDefaultModelWithRegisteredFactoryDoesNotThrow() {
+    registerMockStreamModelLoader(Float.class);
+
+    requestManager.load(0.5f).into(target);
+  }
+
+  @Test
+  public void testReceivesGif() throws IOException {
+    String fakeUri = "content://fake";
+    InputStream testGifData = openResource("test.gif");
+    mockUri(Uri.parse(fakeUri), testGifData);
+
+    requestManager.asGif().load(fakeUri).into(target);
+
+    verify(target).onResourceReady(isA(GifDrawable.class), isA(Transition.class));
+  }
+
+  @Test
+  public void testReceivesGifBytes() throws IOException {
+    String fakeUri = "content://fake";
+    InputStream testGifData = openResource("test.gif");
+    mockUri(Uri.parse(fakeUri), testGifData);
+
+    requestManager.as(byte[].class).apply(decodeTypeOf(GifDrawable.class)).load(fakeUri)
+        .into(target);
+
+    verify(target).onResourceReady(isA(byte[].class), isA(Transition.class));
+  }
+
+  @Test
+  public void testReceivesBitmapBytes() {
+    String fakeUri = "content://fake";
+    mockUri(fakeUri);
+    requestManager.as(byte[].class).apply(decodeTypeOf(Bitmap.class)).load(fakeUri).into(target);
+
+    verify(target).onResourceReady(isA(byte[].class), isA(Transition.class));
+  }
+
+  @Test
+  public void testReceivesThumbnails() {
+    String full = mockUri("content://full");
+    String thumb = mockUri("content://thumb");
+    requestManager
+        .load(full)
+        .thumbnail(requestManager.load(thumb))
+        .into(target);
+
+    verify(target, times(2)).onResourceReady(isA(Drawable.class), isA(Transition.class));
+  }
+
+  @Test
+  public void testReceivesRecursiveThumbnails() {
+    requestManager.load(mockUri("content://first")).thumbnail(
+        requestManager.load(mockUri("content://second")).thumbnail(
+            requestManager.load(mockUri("content://third")).thumbnail(
+                requestManager.load(mockUri("content://fourth")))))
+        .into(target);
+    verify(target, times(4)).onResourceReady(isA(Drawable.class), isA(Transition.class));
+  }
+
+  @Test
+  public void testReceivesRecursiveThumbnailWithPercentage() {
+    requestManager.load(mockUri("content://first"))
+        .thumbnail(requestManager.load(mockUri("content://second")).thumbnail(0.5f))
+        .into(target);
+    verify(target, times(3)).onResourceReady(isA(Drawable.class), isA(Transition.class));
+  }
+
+  @Test
+  public void testNullModelInGenericImageLoadDoesNotThrow() {
+    requestManager.load(null).into(target);
+  }
+
+  @Test
+  public void testNullModelInGenericVideoLoadDoesNotThrow() {
+    requestManager.load(null).into(target);
+  }
+
+  @Test
+  public void testNullModelInGenericLoadDoesNotThrow() {
+    requestManager.load(null).into(target);
+  }
+
+  @Test
+  public void testNullModelDoesNotThrow() {
+    Drawable drawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(null)
+        .apply(placeholderOf(drawable))
+        .into(target);
+
+    verify(target).onLoadFailed(eq(drawable));
+  }
+
+  @Test
+  public void testNullModelPrefersErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.GREEN);
+    Drawable error = new ColorDrawable(Color.RED);
+
+    requestManager
+        .load(null)
+        .apply(placeholderOf(placeholder)
+            .error(error))
+        .into(target);
+
+    verify(target).onLoadFailed(eq(error));
+  }
+
+  @Test
+  public void testNullModelPrefersFallbackDrwaable() {
+    Drawable placeholder = new ColorDrawable(Color.GREEN);
+    Drawable error = new ColorDrawable(Color.RED);
+    Drawable fallback = new ColorDrawable(Color.BLUE);
+
+    requestManager
+        .load(null)
+        .apply(placeholderOf(placeholder)
+            .error(error)
+            .fallback(fallback))
+        .into(target);
+
+    verify(target).onLoadFailed(eq(fallback));
+  }
+
+  @Test
+  public void testByteData() {
+    byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };
+    requestManager.load(data).into(target);
+  }
+
+  @Test
+  public void testClone() throws IOException {
+    Target firstTarget = mock(Target.class);
+    doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
+    Target secondTarget = mock(Target.class);
+    doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(isA(SizeReadyCallback.class));
+    RequestBuilder<Drawable> firstRequest = Glide.with(getContext())
+        .load(mockUri("content://first"));
+
+    firstRequest.into(firstTarget);
+
+    firstRequest.clone()
+        .apply(placeholderOf(new ColorDrawable(Color.RED)))
+        .into(secondTarget);
+
+    verify(firstTarget).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
+    verify(secondTarget).onResourceReady(notNull(), isA(Transition.class));
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource)
+      throws Exception {
+    DataFetcher<Z> failFetcher = mock(DataFetcher.class);
+    doAnswer(new Util.CallDataReady(null))
+        .when(failFetcher)
+        .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
+    when(failFetcher.getDataClass()).thenReturn(failResource);
+    ModelLoader<T, Z> failLoader = mock(ModelLoader.class);
+    when(failLoader.buildLoadData(isA(failModel), anyInt(), anyInt(), isA(Options.class)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), failFetcher));
+    when(failLoader.handles(isA(failModel))).thenReturn(true);
+    ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
+    when(failFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
+        .thenReturn(failLoader);
+
+    Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
+  }
+
+  private String mockUri(String uriString) {
+    return mockUri(Uri.parse(uriString), null);
+  }
+
+  private String mockUri(Uri uri) {
+    return mockUri(uri, null);
+  }
+
+  private String mockUri(Uri uri, InputStream is) {
+    if (is == null) {
+      is = new ByteArrayInputStream(new byte[0]);
+    }
+    ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
+    ShadowFileDescriptorContentResolver shadowContentResolver =
+        (ShadowFileDescriptorContentResolver) ShadowExtractor.extract(contentResolver);
+    shadowContentResolver.registerInputStream(uri, is);
+
+    AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
+    ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
+    when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
+
+    shadowContentResolver.registerAssetFileDescriptor(uri, assetFileDescriptor);
+    return uri.toString();
+  }
+
+  private Context getContext() {
+    return RuntimeEnvironment.application;
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
+    ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
+    ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
+    when(modelLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
+        .thenReturn(modelLoader);
+
+    Glide.get(RuntimeEnvironment.application).getRegistry()
+        .prepend(modelClass, InputStream.class, modelLoaderFactory);
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ModelLoader<T, InputStream> mockStreamModelLoader(final Class<T> modelClass) {
+    ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);
+    DataFetcher<InputStream> fetcher = mock(DataFetcher.class);
+    try {
+      doAnswer(new Util.CallDataReady(new ByteArrayInputStream(new byte[0]))).when(fetcher)
+          .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
+    } catch (Exception e) {
+      // Do nothing.
+    }
+    when(fetcher.getDataClass()).thenReturn(InputStream.class);
+    when(modelLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
+    when(modelLoader.handles(isA(modelClass))).thenReturn(true);
+
+    return modelLoader;
+  }
+
+  private InputStream openResource(String imageName) throws IOException {
+    return TestResourceUtil.openResource(getClass(), imageName);
+  }
+
+  private static class CallSizeReady implements Answer<Void> {
+    private int width;
+    private int height;
+
+    public CallSizeReady() {
+      this(100, 100);
+    }
+
+    public CallSizeReady(int width, int height) {
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public Void answer(InvocationOnMock invocation) throws Throwable {
+      SizeReadyCallback cb = (SizeReadyCallback) invocation.getArguments()[0];
+      cb.onSizeReady(width, height);
+      return null;
+    }
+  }
+
+  public static class SetupModule implements GlideModule {
+
+    @Override
+    public void applyOptions(Context context, GlideBuilder builder) {
+      // Run all tasks on the main thread so they complete synchronously.
+      GlideExecutor executor = mock(GlideExecutor.class);
+      doAnswer(new Answer<Void>() {
+        @Override
+        public Void answer(InvocationOnMock invocation) throws Throwable {
+          Runnable runnable = (Runnable) invocation.getArguments()[0];
+          runnable.run();
+          return null;
+        }
+      }).when(executor).execute(isA(Runnable.class));
+
+      DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
+      when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
+
+      builder.setMemoryCache(mock(MemoryCache.class)).setDiskCache(diskCacheFactory)
+          .setResizeExecutor(executor).setDiskCacheExecutor(executor);
+    }
+
+    @Override
+    public void registerComponents(Context context, Registry registry) {
+      registerMockModelLoader(GlideUrl.class, InputStream.class,
+          new ByteArrayInputStream(new byte[0]), registry);
+      registerMockModelLoader(File.class, InputStream.class,
+          new ByteArrayInputStream(new byte[0]), registry);
+      registerMockModelLoader(File.class, ParcelFileDescriptor.class,
+          mock(ParcelFileDescriptor.class), registry);
+      registerMockModelLoader(File.class, ByteBuffer.class,
+          ByteBuffer.allocate(10), registry);
+    }
+
+    private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
+          Y loadedData, Registry registry) {
+      DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
+      when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
+      try {
+        doAnswer(new Util.CallDataReady<>(loadedData))
+            .when(mockStreamFetcher)
+            .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+      ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
+      when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
+          .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
+      when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
+      ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
+      when(mockUrlLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
+          .thenReturn(mockUrlLoader);
+
+      registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
+    }
+  }
+
+  // TODO: Extending ShadowContentResolver results in exceptions because of some state issues
+  // where we seem to get one content resolver shadow in one part of the test and a different one in
+  // a different part of the test. Each one ends up with different registered uris, which causes
+  // tests to fail. We shouldn't need to do this, but using static maps seems to fix the issue.
+  @Implements(value = ContentResolver.class)
+  public static class ShadowFileDescriptorContentResolver {
+    private static final Map<Uri, AssetFileDescriptor> URI_TO_FILE_DESCRIPTOR = new HashMap<>();
+    private static final Map<Uri, InputStream> URI_TO_INPUT_STREAMS = new HashMap<>();
+
+    @Resetter
+    public static void reset() {
+      URI_TO_INPUT_STREAMS.clear();
+      URI_TO_FILE_DESCRIPTOR.clear();
+    }
+
+    public void registerInputStream(Uri uri, InputStream inputStream) {
+      URI_TO_INPUT_STREAMS.put(uri, inputStream);
+    }
+
+    public void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
+      URI_TO_FILE_DESCRIPTOR.put(uri, assetFileDescriptor);
+    }
+
+    @Implementation
+    public InputStream openInputStream(Uri uri) {
+      if (!URI_TO_INPUT_STREAMS.containsKey(uri)) {
+        throw new IllegalArgumentException(
+            "You must first register an InputStream for uri: " + uri);
+      }
+      return URI_TO_INPUT_STREAMS.get(uri);
+    }
+
+    @Implementation
+    public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String type) {
+      if (!URI_TO_FILE_DESCRIPTOR.containsKey(uri)) {
+        throw new IllegalArgumentException(
+            "You must first register an AssetFileDescriptor for " + "uri: " + uri);
+      }
+      return URI_TO_FILE_DESCRIPTOR.get(uri);
+    }
+  }
+
+  @Implements(Bitmap.class)
+  public static class MutableShadowBitmap extends ShadowBitmap {
+
+    @Implementation
+    public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
+      Bitmap bitmap = ShadowBitmap.createBitmap(width, height, config);
+      Shadows.shadowOf(bitmap).setMutable(true);
+      return bitmap;
+    }
+  }
+
+  @Implements(MediaMetadataRetriever.class)
+  public static class ShadowMediaMetadataRetriever {
+
+    @Implementation
+    @SuppressWarnings("unused")
+    public Bitmap getFrameAtTime() {
+      Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+      Shadows.shadowOf(bitmap).appendDescription(" from MediaMetadataRetriever");
+      return bitmap;
+    }
+  }
+}
+
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
new file mode 100644
index 000000000..34d04e635
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -0,0 +1,379 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.verification.VerificationMode;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ListPreloaderTest {
+
+  @Mock private RequestBuilder<Bitmap> request;
+  @Mock private RequestManager requestManager;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testGetItemsIsCalledIncreasing() {
+    final AtomicBoolean called = new AtomicBoolean(false);
+    final AtomicInteger calledCount = new AtomicInteger();
+
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        called.set(true);
+        final int count = calledCount.getAndIncrement();
+        assertEquals(11 + count, position);
+        return super.getPreloadItems(position);
+      }
+    };
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 1, 10, 30);
+    assertEquals(10, calledCount.get());
+  }
+
+  @Test
+  public void testGetItemsIsCalledInOrderIncreasing() {
+    final int toPreload = 10;
+    final List<Object> objects = new ArrayList<>();
+    for (int i = 0; i < toPreload; i++) {
+      objects.add(i);
+    }
+
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+
+      public int expectedPosition;
+
+      @Override
+      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+        return new int[] { 10, 10 };
+      }
+
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        return objects.subList(position - 11, position + 1 - 11);
+      }
+
+      @Override
+      public RequestBuilder<Bitmap> getPreloadRequestBuilder(Object item) {
+        assertEquals(objects.get(expectedPosition), item);
+        expectedPosition++;
+        return mock(RequestBuilder.class);
+      }
+    };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);
+    preloader.onScroll(null, 1, 10, 20);
+  }
+
+  @Test
+  public void testGetItemsIsCalledDecreasing() {
+    final AtomicBoolean called = new AtomicBoolean(false);
+    final AtomicInteger calledCount = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        // Ignore the preload caused from us starting at the end
+        if (position >= 40) {
+          return Collections.emptyList();
+        }
+        final int count = calledCount.getAndIncrement();
+        called.set(true);
+        assertEquals(28 - count, position);
+        return super.getPreloadItems(position);
+      }
+    };
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 30, 10, 40);
+    preloader.onScroll(null, 29, 10, 40);
+    assertTrue(called.get());
+  }
+
+  @Test
+  public void testGetItemsIsCalledInOrderDecreasing() {
+    final int toPreload = 10;
+    final List<Object> objects = new ArrayList<>();
+    for (int i = 0; i < toPreload; i++) {
+      objects.add(new Object());
+    }
+
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      int expectedPosition = toPreload - 1;
+
+      @Override
+      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+        return new int[] { 10, 10 };
+      }
+
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        if (position == 40) {
+          return null;
+        }
+        return objects.subList(position, position + 1);
+      }
+
+      @Override
+      public RequestBuilder<Bitmap> getPreloadRequestBuilder(Object item) {
+        assertEquals(objects.get(expectedPosition), item);
+        expectedPosition--;
+        return mock(RequestBuilder.class);
+      }
+    };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);
+    preloader.onScroll(null, 30, 10, 10);
+    preloader.onScroll(null, 29, 10, 10);
+  }
+
+  @Test
+  public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
+    final AtomicBoolean called = new AtomicBoolean(false);
+    final AtomicInteger calledCount = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        called.set(true);
+        final int count = calledCount.getAndIncrement();
+        assertEquals(26 + count, position);
+        return super.getPreloadItems(position);
+      }
+    };
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 16, 10, 30);
+    assertTrue(called.get());
+  }
+
+  @Test
+  public void testGetItemsIsNeverCalledWithStartLessThanZero() {
+    final AtomicBoolean called = new AtomicBoolean(false);
+    final AtomicInteger calledCount = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        if (position >= 17) {
+          return Collections.emptyList();
+        }
+        called.set(true);
+        final int count = calledCount.getAndIncrement();
+        assertEquals(5 - count, position);
+        return super.getPreloadItems(position);
+      }
+    };
+
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 7, 10, 30);
+    preloader.onScroll(null, 6, 10, 30);
+    assertTrue(called.get());
+  }
+
+  @Test
+  public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
+    final AtomicInteger called = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        final int current = called.getAndIncrement();
+        assertEquals(11 + current, position);
+        return super.getPreloadItems(position);
+      }
+    };
+
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 1, 10, 30);
+    preloader.onScroll(null, 4, 10, 30);
+
+    assertEquals(13, called.get());
+  }
+
+  @Test
+  public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
+    final AtomicInteger called = new AtomicInteger();
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        if (position >= 20) {
+          return Collections.emptyList();
+        }
+        final int current = called.getAndIncrement();
+        assertEquals(19 - current, position);
+        return super.getPreloadItems(position);
+      }
+    };
+
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+    preloader.onScroll(null, 21, 10, 30);
+    preloader.onScroll(null, 20, 10, 30);
+    preloader.onScroll(null, 17, 10, 30);
+    assertEquals(13, called.get());
+  }
+
+  @Test
+  public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException {
+    final List<Object> objects = new ArrayList<>();
+    objects.add(new Object());
+    objects.add(new Object());
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      public int expectedPosition = (1 + 10) * 2;
+
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        return objects;
+      }
+
+      @Override
+      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+        assertEquals(expectedPosition / 2, adapterPostion);
+        assertEquals(expectedPosition % 2, itemPosition);
+        expectedPosition++;
+        return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
+      }
+
+      @Override
+      public RequestBuilder getPreloadRequestBuilder(Object item) {
+        return request;
+      }
+    };
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+    Iterable<Integer> expected = Arrays.asList(10, 11, 20, 21, 10, 11, 20, 21);
+
+    preloader.onScroll(null, 1, 10, 1 + 10 + 2);
+
+    List<Integer> allValues = getTagetsSizes(request, times(4));
+    assertEquals(expected, allValues);
+  }
+
+  @Test
+  public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException {
+    final List<Object> objects = new ArrayList<>();
+    objects.add(new Object());
+    objects.add(new Object());
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      int expectedPosition = objects.size() * 2 - 1;
+
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        return objects;
+      }
+
+      @Override
+      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+        assertEquals(expectedPosition / 2, adapterPostion);
+        assertEquals(expectedPosition % 2, itemPosition);
+        expectedPosition--;
+        return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
+      }
+
+      @Override
+      public RequestBuilder getPreloadRequestBuilder(Object item) {
+        return request;
+      }
+    };
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+    Iterable<Integer> expected = Arrays.asList(20, 21, 10, 11, 20, 21, 10, 11);
+
+    preloader.onScroll(null, 3, 2, 3 + 2);
+    preloader.onScroll(null, 2, 2, 3 + 2);
+
+    List<Integer> allValues = getTagetsSizes(request, times(4));
+    assertEquals(expected, allValues);
+  }
+
+  private List<Integer> getTagetsSizes(RequestBuilder<?> requestBuilder, VerificationMode mode) {
+    ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
+    ArgumentCaptor<Target> targetArgumentCaptor = ArgumentCaptor.forClass(Target.class);
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
+    for (Target target : targetArgumentCaptor.getAllValues()) {
+      target.getSize(cb);
+    }
+    verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
+    return integerArgumentCaptor.getAllValues();
+  }
+
+  @Test
+  public void testItemsArePreloadedWithGlide() {
+    final List<Object> objects = new ArrayList<>();
+    objects.add(new Object());
+    objects.add(new Object());
+    final HashSet<Object> loadedObjects = new HashSet<>();
+    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @Override
+      public List<Object> getPreloadItems(int position) {
+        return objects.subList(position - 11, position - 10);
+      }
+
+      @Override
+      public RequestBuilder getPreloadRequestBuilder(Object item) {
+        loadedObjects.add(item);
+        return super.getPreloadRequestBuilder(item);
+      }
+    };
+    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
+        preloaderAdapter, preloaderAdapter, 10);
+
+    preloader.onScroll(null, 1, 10, 13);
+    assertThat(loadedObjects).containsAllIn(objects);
+  }
+
+  private static class ListPreloaderAdapter implements ListPreloader.PreloadModelProvider<Object>,
+      ListPreloader.PreloadSizeProvider<Object> {
+
+    public ListPreloaderAdapter() {
+    }
+
+    @Override
+    public List<Object> getPreloadItems(int position) {
+      ArrayList<Object> result = new ArrayList<>(1);
+      Collections.fill(result, new Object());
+      return result;
+    }
+
+    @Override
+    public RequestBuilder getPreloadRequestBuilder(Object item) {
+      return mock(RequestBuilder.class);
+    }
+
+    @Override
+    public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+      return new int[] { 100, 100 };
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
new file mode 100644
index 000000000..f08fae2af
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -0,0 +1,115 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.widget.ImageView;
+
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.BackgroundUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@SuppressWarnings("unchecked")
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class RequestBuilderTest {
+  @Mock GlideContext glideContext;
+  @Mock RequestManager requestManager;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfContextIsNull() {
+    new RequestBuilder(null /*context*/, requestManager, Object.class);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsWhenGlideAnimationFactoryIsNull() {
+    getNullModelRequest().transition(null);
+  }
+
+  @Test
+  public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
+    getNullModelRequest().into(mock(Target.class));
+  }
+
+  @Test
+  public void testAddsNewRequestToRequestTracker() {
+    Target target = mock(Target.class);
+    getNullModelRequest().into(target);
+
+    verify(requestManager).track(eq(target), isA(Request.class));
+  }
+
+  @Test
+  public void testRemovesPreviousRequestFromRequestTracker() {
+    Request previous = mock(Request.class);
+    Target target = mock(Target.class);
+    when(target.getRequest()).thenReturn(previous);
+
+    getNullModelRequest().into(target);
+
+    verify(requestManager).clear(eq(target));
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfGivenNullTarget() {
+    getNullModelRequest().into((Target) null);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfGivenNullView() {
+    getNullModelRequest().into((ImageView) null);
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
+    final ImageView imageView = new ImageView(RuntimeEnvironment.application);
+    testInBackground(new BackgroundUtil.BackgroundTester() {
+      @Override
+      public void runTest() throws Exception {
+        getNullModelRequest().into(imageView);
+
+      }
+    });
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
+    final Target target = mock(Target.class);
+    testInBackground(new BackgroundUtil.BackgroundTester() {
+      @Override
+      public void runTest() throws Exception {
+        getNullModelRequest().into(target);
+      }
+    });
+  }
+
+  private RequestBuilder getNullModelRequest() {
+    when(glideContext.buildImageViewTarget(isA(ImageView.class), isA(Class.class)))
+        .thenReturn(mock(Target.class));
+    when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
+    when(requestManager.getDefaultRequestOptions())
+        .thenReturn((BaseRequestOptions) new RequestOptions());
+    return new RequestBuilder(glideContext, requestManager, Object.class)
+        .load((Object) null);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
new file mode 100644
index 000000000..0e171262f
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -0,0 +1,151 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+
+import com.bumptech.glide.manager.ConnectivityMonitor;
+import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.manager.RequestTracker;
+import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.GlideShadowLooper;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
+public class RequestManagerTest {
+  @Mock Lifecycle lifecycle = mock(Lifecycle.class);
+  @Mock RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
+
+  private RequestManager manager;
+  private ConnectivityMonitor connectivityMonitor;
+  private RequestTracker requestTracker;
+  private ConnectivityListener connectivityListener;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    connectivityMonitor = mock(ConnectivityMonitor.class);
+    ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
+    when(factory.build(isA(Context.class), isA(ConnectivityMonitor.ConnectivityListener.class)))
+        .thenAnswer(new Answer<ConnectivityMonitor>() {
+          @Override
+          public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
+            connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
+            return connectivityMonitor;
+          }
+        });
+    requestTracker = mock(RequestTracker.class);
+    manager = new RequestManager(RuntimeEnvironment.application, lifecycle, treeNode,
+        requestTracker, factory);
+  }
+
+  @Test
+  public void testPauseRequestsPausesRequests() {
+    manager.pauseRequests();
+
+    verify(requestTracker).pauseRequests();
+  }
+
+  @Test
+  public void testResumeRequestsResumesRequests() {
+    manager.resumeRequests();
+
+    verify(requestTracker).resumeRequests();
+  }
+
+  @Test
+  public void testPausesRequestsOnStop() {
+    manager.onStart();
+    manager.onStop();
+
+    verify(requestTracker).pauseRequests();
+  }
+
+  @Test
+  public void testResumesRequestsOnStart() {
+    manager.onStart();
+
+    verify(requestTracker).resumeRequests();
+  }
+
+  @Test
+  public void testClearsRequestsOnDestroy() {
+    manager.onDestroy();
+
+    verify(requestTracker).clearRequests();
+  }
+
+  @Test
+  public void testAddsConnectivityMonitorToLifecycleWhenConstructed() {
+    verify(lifecycle).addListener(eq(connectivityMonitor));
+  }
+
+  @Test
+  public void testAddsSelfToLifecycleWhenConstructed() {
+    verify(lifecycle).addListener(eq(manager));
+  }
+
+  @Test
+  public void testRestartsRequestOnConnected() {
+    connectivityListener.onConnectivityChanged(true);
+
+    verify(requestTracker).restartRequests();
+  }
+
+  @Test
+  public void testDoesNotRestartRequestsOnDisconnected() {
+    connectivityListener.onConnectivityChanged(false);
+
+    verify(requestTracker, never()).restartRequests();
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrowsIfResumeCalledOnBackgroundThread() throws InterruptedException {
+    testInBackground(new BackgroundUtil.BackgroundTester() {
+      @Override
+      public void runTest() throws Exception {
+        manager.resumeRequests();
+      }
+    });
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrowsIfPauseCalledOnBackgroundThread() throws InterruptedException {
+    testInBackground(new BackgroundUtil.BackgroundTester() {
+      @Override
+      public void runTest() throws Exception {
+        manager.pauseRequests();
+      }
+    });
+  }
+
+  @Test
+  public void testDelegatesIsPausedToRequestTracker() {
+    when(requestTracker.isPaused()).thenReturn(true);
+    assertTrue(manager.isPaused());
+    when(requestTracker.isPaused()).thenReturn(false);
+    assertFalse(manager.isPaused());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
new file mode 100644
index 000000000..a8a46640a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -0,0 +1,124 @@
+package com.bumptech.glide.load;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(JUnit4.class)
+public class MultiTransformationTest {
+
+  @Mock Transformation<Object> first;
+  @Mock Transformation<Object> second;
+  @Mock Resource<Object> initial;
+  @Mock Resource<Object> firstTransformed;
+  @Mock Resource<Object> secondTransformed;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testAppliesTransformationsInOrder() {
+    final int width = 584;
+    final int height = 768;
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
+    when(first.transform(eq(initial), eq(width), eq(height))).thenReturn(firstTransformed);
+
+    when(second.transform(eq(firstTransformed), eq(width), eq(height)))
+        .thenReturn(secondTransformed);
+
+    assertEquals(secondTransformed, transformation.transform(initial, width, height));
+  }
+
+  @Test
+  public void testInitialResourceIsNotRecycled() {
+    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
+
+    MultiTransformation<Object> transformation = new MultiTransformation(first);
+
+    transformation.transform(initial, 123, 456);
+
+    verify(initial, never()).recycle();
+  }
+
+  @Test
+  public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformations() {
+    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
+    transformation.transform(initial, 1111, 2222);
+
+    verify(initial, never()).recycle();
+  }
+
+  @Test
+  public void
+  testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
+    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(any(Resource.class), anyInt(), anyInt()))
+        .thenReturn(mock(Resource.class));
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
+    transformation.transform(initial, 1, 2);
+
+    verify(initial, never()).recycle();
+  }
+
+  @Test
+  public void testFinalResourceIsNotRecycled() {
+    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first);
+
+    transformation.transform(mock(Resource.class), 111, 222);
+
+    verify(firstTransformed, never()).recycle();
+  }
+
+  @Test
+  public void testIntermediateResourcesAreRecycled() {
+    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
+    when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(secondTransformed);
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
+
+    transformation.transform(mock(Resource.class), 233, 454);
+
+    verify(firstTransformed).recycle();
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    doAnswer(new Util.WriteDigest("first")).when(first)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertSame(new MultiTransformation<>(first), new MultiTransformation<>(first));
+
+    doAnswer(new Util.WriteDigest("second")).when(second)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertDifferent(new MultiTransformation<>(first),
+        new MultiTransformation<>(second));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
new file mode 100644
index 000000000..7205db1dc
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load;
+
+import com.google.common.testing.EqualsTester;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class OptionsTest {
+
+  @Test
+  public void testEquals() {
+    Option<Object> firstOption = Option.memory("firstKey");
+    Object firstValue = new Object();
+    Option<Object> secondOption = Option.memory("secondKey");
+    Object secondValue = new Object();
+    new EqualsTester()
+        .addEqualityGroup(new Options(), new Options())
+        .addEqualityGroup(
+            new Options().set(firstOption, firstValue),
+            new Options().set(firstOption, firstValue)
+        )
+        .addEqualityGroup(
+            new Options().set(secondOption, secondValue),
+            new Options().set(secondOption, secondValue)
+        )
+        .addEqualityGroup(
+            new Options().set(firstOption, firstValue).set(secondOption, secondValue),
+            new Options().set(firstOption, firstValue).set(secondOption, secondValue)
+        ).testEquals();
+  }
+
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
new file mode 100644
index 000000000..a682ff139
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -0,0 +1,50 @@
+package com.bumptech.glide.load.data;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.testutil.TestResourceUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ExifOrientationStreamTest {
+  private LruByteArrayPool byteArrayPool;
+
+  private InputStream openOrientationExample(boolean isLandscape, int item) {
+    String filePrefix = isLandscape ? "Landscape" : "Portrait";
+    return TestResourceUtil.openResource(getClass(),
+        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
+  }
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruByteArrayPool();
+  }
+
+  @Test
+  public void testIncludesGivenExifOrientation() throws IOException {
+    for (int i = 0; i < 8; i++) {
+      for (int j = 0; j < 8; j++) {
+        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
+        InputStream wrapped = new ExifOrientationStream(toWrap, i);
+        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
+        assertThat(parser.getOrientation()).isEqualTo(i);
+
+        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
+        wrapped = new ExifOrientationStream(toWrap, i);
+        parser = new ImageHeaderParser(wrapped, byteArrayPool);
+        assertThat(parser.getOrientation()).isEqualTo(i);
+      }
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
new file mode 100644
index 000000000..4e2b4636f
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
@@ -0,0 +1,73 @@
+package com.bumptech.glide.load.data;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.AssetFileDescriptor;
+import android.content.res.AssetManager;
+import android.os.ParcelFileDescriptor;
+
+import com.bumptech.glide.Priority;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class FileDescriptorAssetPathFetcherTest {
+
+  @Mock AssetManager assetManager;
+  @Mock AssetFileDescriptor assetFileDescriptor;
+  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+
+  private FileDescriptorAssetPathFetcher fetcher;
+  private ParcelFileDescriptor expected;
+  private String assetPath;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    assetPath = "/some/asset/path";
+    fetcher = new FileDescriptorAssetPathFetcher(assetManager, assetPath);
+    expected = mock(ParcelFileDescriptor.class);
+    when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(expected);
+    when(assetManager.openFd(eq(assetPath))).thenReturn(assetFileDescriptor);
+  }
+
+  @Test
+  public void testOpensInputStreamForPathWithAssetManager() throws Exception {
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onDataReady(eq(expected));
+  }
+
+  @Test
+  public void testClosesOpenedInputStreamOnCleanup() throws Exception {
+    fetcher.loadData(Priority.NORMAL, callback);
+    fetcher.cleanup();
+
+    verify(expected).close();
+  }
+
+  @Test
+  public void testDoesNothingOnCleanupIfNoDataLoaded() throws IOException {
+    fetcher.cleanup();
+    verify(expected, never()).close();
+  }
+
+  @Test
+  public void testDoesNothingOnCancel() throws Exception {
+    fetcher.loadData(Priority.NORMAL, callback);
+    fetcher.cancel();
+    verify(expected, never()).close();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
new file mode 100644
index 000000000..0d9fbc268
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -0,0 +1,244 @@
+package com.bumptech.glide.load.data;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.Headers;
+import com.bumptech.glide.testutil.TestUtil;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Tests {@link com.bumptech.glide.load.data.HttpUrlFetcher} against server responses. Tests for
+ * behavior (connection/disconnection/options) should go in
+ * {@link com.bumptech.glide.load.data.HttpUrlFetcherTest}, response handling should go here.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class HttpUrlFetcherServerTest {
+  private static final String DEFAULT_PATH = "/fakepath";
+  private static final int TIMEOUT_TIME_MS = 300;
+
+  @Mock DataFetcher.DataCallback<InputStream> callback;
+
+  private MockWebServer mockWebServer;
+  private boolean defaultFollowRedirects;
+  private ArgumentCaptor<InputStream> streamCaptor;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    defaultFollowRedirects = HttpURLConnection.getFollowRedirects();
+    HttpURLConnection.setFollowRedirects(false);
+    mockWebServer = new MockWebServer();
+    mockWebServer.start();
+
+    streamCaptor = ArgumentCaptor.forClass(InputStream.class);
+  }
+
+  @After
+  public void tearDown() throws IOException {
+    HttpURLConnection.setFollowRedirects(defaultFollowRedirects);
+    mockWebServer.shutdown();
+  }
+
+  @Test
+  public void testReturnsInputStreamOnStatusOk() throws Exception {
+    String expected = "fakedata";
+    mockWebServer.enqueue(new MockResponse().setBody(expected).setResponseCode(200));
+    HttpUrlFetcher fetcher = getFetcher();
+    fetcher.loadData(Priority.HIGH, callback);
+    verify(callback).onDataReady(streamCaptor.capture());
+    TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+  }
+
+  @Test
+  public void testHandlesRedirect301s() throws Exception {
+    String expected = "fakedata";
+    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
+        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
+    getFetcher().loadData(Priority.LOW, callback);
+    verify(callback).onDataReady(streamCaptor.capture());
+    TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+  }
+
+  @Test
+  public void testHandlesRedirect302s() throws Exception {
+    String expected = "fakedata";
+    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
+        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
+    getFetcher().loadData(Priority.LOW, callback);
+    verify(callback).onDataReady(streamCaptor.capture());
+    TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+  }
+
+  @Test
+  public void testHandlesRelativeRedirects() throws Exception {
+    String expected = "fakedata";
+    mockWebServer
+        .enqueue(new MockResponse().setResponseCode(301).setHeader("Location", "/redirect"));
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
+    getFetcher().loadData(Priority.NORMAL, callback);
+    verify(callback).onDataReady(streamCaptor.capture());
+    TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+
+    mockWebServer.takeRequest();
+    RecordedRequest second = mockWebServer.takeRequest();
+    assertThat(second.getPath()).endsWith("/redirect");
+  }
+
+  @Test
+  public void testHandlesUpToFiveRedirects() throws Exception {
+    int numRedirects = 4;
+    String expected = "redirectedData";
+    String redirectBase = "/redirect";
+    for (int i = 0; i < numRedirects; i++) {
+      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
+          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+    }
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
+
+    getFetcher().loadData(Priority.NORMAL, callback);
+    verify(callback).onDataReady(streamCaptor.capture());
+    TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+
+    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
+    for (int i = 0; i < numRedirects; i++) {
+      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
+    }
+  }
+
+  @Test
+  public void testFailsOnRedirectLoops() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
+        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
+        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+
+    getFetcher().loadData(Priority.IMMEDIATE, callback);
+
+    verify(callback).onLoadFailed(isA(IOException.class));
+  }
+
+  @Test
+  public void testFailsIfRedirectLocationIsNotPresent() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(301));
+
+    getFetcher().loadData(Priority.NORMAL, callback);
+
+    verify(callback).onLoadFailed(isA(IOException.class));
+  }
+
+  @Test
+  public void testFailsIfRedirectLocationIsPresentAndEmpty() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(301).setHeader("Location", ""));
+
+    getFetcher().loadData(Priority.NORMAL, callback);
+
+    verify(callback).onLoadFailed(isA(IOException.class));
+  }
+
+  @Test
+  public void testFailsIfStatusCodeIsNegativeOne() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
+    getFetcher().loadData(Priority.LOW, callback);
+
+    verify(callback).onLoadFailed(isA(IOException.class));
+  }
+
+  @Test
+  public void testFailsAfterTooManyRedirects() throws Exception {
+    for (int i = 0; i < 10; i++) {
+      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
+          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+    }
+    getFetcher().loadData(Priority.NORMAL, callback);
+
+    verify(callback).onLoadFailed(isA(IOException.class));
+  }
+
+  @Test
+  public void testFailsIfStatusCodeIs500() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(500));
+    getFetcher().loadData(Priority.NORMAL, callback);
+
+    verify(callback).onLoadFailed(isA(IOException.class));
+  }
+
+  @Test
+  public void testFailsIfStatusCodeIs400() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(400));
+    getFetcher().loadData(Priority.LOW, callback);
+
+    verify(callback).onLoadFailed(isA(IOException.class));
+  }
+
+  @Test
+  public void testSetsReadTimeout() throws Exception {
+    MockWebServer tempWebServer = new MockWebServer();
+    tempWebServer.enqueue(
+        new MockResponse().setBody("test").throttleBody(1, TIMEOUT_TIME_MS, TimeUnit.MILLISECONDS));
+    tempWebServer.start();
+
+    try {
+      getFetcher().loadData(Priority.HIGH, callback);
+    } finally {
+      tempWebServer.shutdown();
+      // shutdown() called before any enqueue() blocks until it times out.
+      mockWebServer.enqueue(new MockResponse().setResponseCode(200));
+    }
+
+    verify(callback).onLoadFailed(isA(IOException.class));
+  }
+
+  @Test
+  public void testAppliesHeadersInGlideUrl() throws Exception {
+    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
+    String headerField = "field";
+    String headerValue = "value";
+    Map<String, String> headersMap = new HashMap<>();
+    headersMap.put(headerField, headerValue);
+    Headers headers = mock(Headers.class);
+    when(headers.getHeaders()).thenReturn(headersMap);
+
+    getFetcher(headers).loadData(Priority.HIGH, callback);
+
+    assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
+  }
+
+  private HttpUrlFetcher getFetcher() {
+    return getFetcher(Headers.DEFAULT);
+  }
+
+  private HttpUrlFetcher getFetcher(Headers headers) {
+    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    return new HttpUrlFetcher(new GlideUrl(url, headers), TIMEOUT_TIME_MS,
+        HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
new file mode 100644
index 000000000..7f70a4a82
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -0,0 +1,119 @@
+package com.bumptech.glide.load.data;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.model.GlideUrl;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class HttpUrlFetcherTest {
+  @Mock HttpURLConnection urlConnection;
+  @Mock HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
+  @Mock GlideUrl glideUrl;
+  @Mock InputStream stream;
+  @Mock DataFetcher.DataCallback<InputStream> callback;
+
+  private static final int TIMEOUT_MS = 100;
+  private HttpUrlFetcher fetcher;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    URL url = new URL("http://www.google.com");
+
+    when(connectionFactory.build(eq(url))).thenReturn(urlConnection);
+    when(urlConnection.getInputStream()).thenReturn(stream);
+    when(urlConnection.getResponseCode()).thenReturn(200);
+    when(glideUrl.toURL()).thenReturn(url);
+
+    fetcher = new HttpUrlFetcher(glideUrl, TIMEOUT_MS, connectionFactory);
+  }
+
+  @Test
+  public void testSetsReadTimeout() throws IOException {
+    fetcher.loadData(Priority.HIGH, callback);
+    verify(urlConnection).setReadTimeout(eq(TIMEOUT_MS));
+  }
+
+  @Test
+  public void testSetsConnectTimeout() throws IOException {
+    fetcher.loadData(Priority.IMMEDIATE, callback);
+    verify(urlConnection).setConnectTimeout(eq(TIMEOUT_MS));
+  }
+
+  @Test
+  public void testReturnsNullIfCancelledBeforeConnects() throws IOException {
+    InputStream notExpected = new ByteArrayInputStream(new byte[0]);
+    when(urlConnection.getInputStream()).thenReturn(notExpected);
+
+    fetcher.cancel();
+    fetcher.loadData(Priority.LOW, callback);
+    verify(callback).onDataReady(isNull(InputStream.class));
+  }
+
+  @Test
+  public void testDisconnectsUrlOnCleanup() throws IOException {
+    fetcher.loadData(Priority.HIGH, callback);
+    fetcher.cleanup();
+
+    verify(urlConnection).disconnect();
+  }
+
+  @Test
+  public void testDoesNotThrowIfCleanupCalledBeforeStarted() {
+    fetcher.cleanup();
+  }
+
+  @Test
+  public void testDoesNotThrowIfCancelCalledBeforeStart() {
+    fetcher.cancel();
+  }
+
+  @Test
+  public void testCancelDoesNotDisconnectIfAlreadyConnected()
+      throws IOException {
+    fetcher.loadData(Priority.HIGH, callback);
+    fetcher.cancel();
+
+    verify(urlConnection, never()).disconnect();
+  }
+
+  @Test
+  public void testClosesStreamInCleanupIfNotNull() throws IOException {
+    fetcher.loadData(Priority.HIGH, callback);
+    fetcher.cleanup();
+
+    verify(stream).close();
+  }
+
+  @Test
+  public void testClosesStreamBeforeDisconnectingConnection() throws IOException {
+    fetcher.loadData(Priority.NORMAL, callback);
+    fetcher.cleanup();
+
+    InOrder order = inOrder(stream, urlConnection);
+    order.verify(stream).close();
+    order.verify(urlConnection).disconnect();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
new file mode 100644
index 000000000..af261f814
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -0,0 +1,86 @@
+package com.bumptech.glide.load.data;
+
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.net.Uri;
+
+import com.bumptech.glide.Priority;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.Closeable;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class LocalUriFetcherTest {
+  private TestLocalUriFetcher fetcher;
+  @Mock DataFetcher.DataCallback<Closeable> callback;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    fetcher = new TestLocalUriFetcher(RuntimeEnvironment.application, Uri.parse("content://empty"));
+  }
+
+  @Test
+  public void testClosesDataOnCleanup() throws Exception {
+    fetcher.loadData(Priority.NORMAL, callback);
+    fetcher.cleanup();
+
+    verify(fetcher.closeable).close();
+  }
+
+  @Test
+  public void testDoesNotCloseNullData() throws IOException {
+    fetcher.cleanup();
+
+    verify(fetcher.closeable, never()).close();
+  }
+
+  @Test
+  public void testHandlesExceptionOnClose() throws Exception {
+    fetcher.loadData(Priority.NORMAL, callback);
+
+    doThrow(new IOException("Test")).when(fetcher.closeable).close();
+    fetcher.cleanup();
+    verify(fetcher.closeable).close();
+  }
+
+  private static class TestLocalUriFetcher extends LocalUriFetcher<Closeable> {
+    final Closeable closeable = mock(Closeable.class);
+
+    public TestLocalUriFetcher(Context context, Uri uri) {
+      super(context, uri);
+    }
+
+    @Override
+    protected Closeable loadResource(Uri uri, ContentResolver contentResolver)
+        throws FileNotFoundException {
+      return closeable;
+    }
+
+    @Override
+    protected void close(Closeable data) throws IOException {
+      data.close();
+    }
+
+    @Override
+    public Class<Closeable> getDataClass() {
+      return Closeable.class;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
new file mode 100644
index 000000000..2f57e9cc1
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.load.data;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.AssetManager;
+
+import com.bumptech.glide.Priority;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class StreamAssetPathFetcherTest {
+  @Mock AssetManager assetManager;
+  @Mock InputStream expected;
+  @Mock DataFetcher.DataCallback<InputStream> callback;
+
+  private StreamAssetPathFetcher fetcher;
+  private String assetPath;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    assetPath = "/some/asset/path";
+    fetcher = new StreamAssetPathFetcher(assetManager, assetPath);
+    when(assetManager.open(eq(assetPath))).thenReturn(expected);
+  }
+
+  @Test
+  public void testOpensInputStreamForPathWithAssetManager() throws Exception {
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onDataReady(eq(expected));
+  }
+
+  @Test
+  public void testClosesOpenedInputStreamOnCleanup() throws Exception {
+    fetcher.loadData(Priority.NORMAL, callback);
+    fetcher.cleanup();
+
+    verify(expected).close();
+  }
+
+  @Test
+  public void testDoesNothingOnCleanupIfNoDataLoaded() throws IOException {
+    fetcher.cleanup();
+    verify(expected, never()).close();
+  }
+
+  @Test
+  public void testDoesNothingOnCancel() throws Exception {
+    fetcher.loadData(Priority.NORMAL, callback);
+    fetcher.cancel();
+    verify(expected, never()).close();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
new file mode 100644
index 000000000..0b0673dc3
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -0,0 +1,66 @@
+package com.bumptech.glide.load.data.mediastore;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNotNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.net.Uri;
+import android.provider.MediaStore;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.data.DataFetcher;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ThumbFetcherTest {
+
+  @Mock ThumbnailStreamOpener opener;
+  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock InputStream expected;
+
+  private ThumbFetcher fetcher;
+  private Uri uri;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
+    fetcher = new ThumbFetcher(RuntimeEnvironment.application, uri, opener);
+  }
+
+  @Test
+  public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
+    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+
+    fetcher.loadData(Priority.LOW, callback);
+    verify(callback).onDataReady(isNotNull(InputStream.class));
+  }
+
+  @Test
+  public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
+    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+
+    fetcher.loadData(Priority.HIGH, callback);
+
+    fetcher.cleanup();
+    verify(expected).close();
+  }
+
+  @Test
+  public void testDoesNotThrowIfCleanupWithNullInputStream() {
+    fetcher.cleanup();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
new file mode 100644
index 000000000..a6f9070da
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -0,0 +1,132 @@
+package com.bumptech.glide.load.data.mediastore;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.provider.MediaStore;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.fakes.RoboCursor;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ThumbnailStreamOpenerTest {
+  private Harness harness;
+
+  @Before
+  public void setUp() {
+    harness = new Harness();
+  }
+
+  @Test
+  public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
+    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri))).thenReturn(null);
+    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+  }
+
+  @Test
+  public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
+    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
+        .thenReturn(new MatrixCursor(new String[1]));
+    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+  }
+
+  @Test
+  public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
+    MatrixCursor cursor = new MatrixCursor(new String[1]);
+    cursor.addRow(new Object[] { "" });
+    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
+        .thenReturn(cursor);
+    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+  }
+
+  @Test
+  public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
+    when(harness.service.get(anyString())).thenReturn(harness.file);
+    when(harness.service.exists(eq(harness.file))).thenReturn(false);
+    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+  }
+
+  @Test
+  public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
+    when(harness.service.get(anyString())).thenReturn(harness.file);
+    when(harness.service.length(eq(harness.file))).thenReturn(0L);
+    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+  }
+
+  @Test
+  public void testClosesCursor() throws FileNotFoundException {
+    harness.get().open(RuntimeEnvironment.application, harness.uri);
+    assertTrue(harness.cursor.isClosed());
+  }
+
+  @Test
+  public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundException {
+    InputStream expected = new ByteArrayInputStream(new byte[0]);
+    Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
+        .registerInputStream(harness.uri, expected);
+    assertEquals(expected, harness.get().open(RuntimeEnvironment.application, harness.uri));
+  }
+
+  @Test
+  public void testVideoQueryReturnsVideoCursor() {
+    Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
+    ThumbFetcher.VideoThumbnailQuery query = new ThumbFetcher.VideoThumbnailQuery();
+    RoboCursor testCursor = new RoboCursor();
+    Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
+        .setCursor(queryUri, testCursor);
+    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+  }
+
+  @Test
+  public void testImageQueryReturnsImageCurosr() {
+    Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
+    ThumbFetcher.ImageThumbnailQuery query = new ThumbFetcher.ImageThumbnailQuery();
+    RoboCursor testCursor = new RoboCursor();
+    Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
+        .setCursor(queryUri, testCursor);
+    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+  }
+
+  private static class Harness {
+    MatrixCursor cursor = new MatrixCursor(new String[1]);
+    File file = new File("fake/uri");
+    Uri uri = Uri.fromFile(file);
+    ThumbnailQuery query = mock(ThumbnailQuery.class);
+    FileService service = mock(FileService.class);
+    ByteArrayPool byteArrayPool = new LruByteArrayPool();
+
+    public Harness() {
+      cursor.addRow(new String[] { file.getAbsolutePath() });
+      when(query.query(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(cursor);
+      when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
+      when(service.exists(eq(file))).thenReturn(true);
+      when(service.length(eq(file))).thenReturn(1L);
+    }
+
+    public ThumbnailStreamOpener get() {
+      return new ThumbnailStreamOpener(service, query, byteArrayPool);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
new file mode 100644
index 000000000..b9790640b
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -0,0 +1,58 @@
+package com.bumptech.glide.load.data.resource;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.AssetFileDescriptor;
+import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
+import com.bumptech.glide.tests.ContentResolverShadow;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.internal.ShadowExtractor;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
+public class FileDescriptorLocalUriFetcherTest {
+
+  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testLoadsFileDescriptor() throws Exception {
+    final Context context = RuntimeEnvironment.application;
+    final Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+
+    AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
+    ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
+    when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
+    shadow.registerFileDescriptor(uri, assetFileDescriptor);
+
+    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onDataReady(eq(parcelFileDescriptor));
+  }
+
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
new file mode 100644
index 000000000..ee8f8d922
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.load.data.resource;
+
+import static org.mockito.Matchers.isNotNull;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.StreamLocalUriFetcher;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class StreamLocalUriFetcherTest {
+  @Mock DataFetcher.DataCallback<InputStream> callback;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testLoadsInputStream() throws Exception {
+    final Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onDataReady(isNotNull(InputStream.class));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
new file mode 100644
index 000000000..33ea85ac1
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util.WriteDigest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(JUnit4.class)
+public class DataCacheKeyTest {
+
+  @Mock Key firstKey;
+  @Mock Key firstSignature;
+  @Mock Key secondKey;
+  @Mock Key secondSignature;
+
+  @Before
+  public void setUp() throws UnsupportedEncodingException {
+    MockitoAnnotations.initMocks(this);
+    doAnswer(new WriteDigest("firstKey")).when(firstKey)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new WriteDigest("firstSignature")).when(firstSignature)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new WriteDigest("secondKey")).when(secondKey)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new WriteDigest("secondSignature")).when(secondSignature)
+        .updateDiskCacheKey(any(MessageDigest.class));
+  }
+
+  @Test
+  public void testDiffersIfIdDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
+    DataCacheKey second = new DataCacheKey(secondKey, firstSignature);
+
+    KeyAssertions.assertDifferent(first, second);
+  }
+
+  @Test
+  public void testDiffersIfSignatureDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
+    DataCacheKey second = new DataCacheKey(firstKey, secondSignature);
+
+    KeyAssertions.assertDifferent(first, second);
+  }
+
+  @Test
+  public void testSameIfIdAndSignatureAreTheSame()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
+    DataCacheKey second = new DataCacheKey(firstKey, firstSignature);
+
+    KeyAssertions.assertSame(first, second);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
new file mode 100644
index 000000000..1987cc797
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -0,0 +1,494 @@
+package com.bumptech.glide.load.engine;
+
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.os.Handler;
+import android.support.v4.util.Pools;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.request.ResourceCallback;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class EngineJobTest {
+  private EngineJobHarness harness;
+
+  @Before
+  public void setUp() {
+    harness = new EngineJobHarness();
+  }
+
+  @Test
+  public void testOnResourceReadyPassedToCallbacks() throws Exception {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    ShadowLooper.runUiThreadTasks();
+    verify(harness.cb).onResourceReady(eq(harness.engineResource), eq(harness.dataSource));
+  }
+
+  @Test
+  public void testListenerNotifiedJobCompleteOnOnResourceReady() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    ShadowLooper.runUiThreadTasks();
+
+    verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));
+  }
+
+  @Test
+  public void testNotifiesAllCallbacksOnReady() {
+    MultiCbHarness harness = new MultiCbHarness();
+    harness.job.start(harness.decodeJob);
+    harness.job.onResourceReady(harness.resource, harness.dataSource);
+    for (ResourceCallback cb : harness.cbs) {
+      verify(cb).onResourceReady(eq(harness.engineResource), eq(harness.dataSource));
+    }
+  }
+
+  @Test
+  public void testNotifiesAllCallbacksOnException() {
+    MultiCbHarness harness = new MultiCbHarness();
+    harness.job.start(harness.decodeJob);
+    GlideException exception = new GlideException("test");
+    harness.job.onLoadFailed(exception);
+    for (ResourceCallback cb : harness.cbs) {
+      verify(cb).onLoadFailed(eq(exception));
+    }
+  }
+
+  @Test
+  public void testAcquiresResourceOncePerCallback() {
+    MultiCbHarness harness = new MultiCbHarness();
+    harness.job.start(harness.decodeJob);
+    harness.job.onResourceReady(harness.resource, harness.dataSource);
+
+    // Acquired once and then released while notifying.
+    InOrder order = inOrder(harness.engineResource);
+    order.verify(harness.engineResource, times(harness.numCbs + 1)).acquire();
+    order.verify(harness.engineResource, times(1)).release();
+  }
+
+  @Test
+  public void testListenerNotifiedJobCompleteOnException() {
+    harness = new EngineJobHarness();
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onLoadFailed(new GlideException("test"));
+    ShadowLooper.runUiThreadTasks();
+    verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
+  }
+
+  @Test
+  public void testResourceIsCacheableWhenIsCacheableOnReady() {
+    harness.isCacheable = true;
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    ShadowLooper.runUiThreadTasks();
+    verify(harness.factory).build(anyResource(), eq(harness.isCacheable));
+  }
+
+  @Test
+  public void testResourceIsCacheableWhenNotIsCacheableOnReady() {
+    harness.isCacheable = false;
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    ShadowLooper.runUiThreadTasks();
+    verify(harness.factory).build(anyResource(), eq(harness.isCacheable));
+  }
+
+  @Test
+  public void testListenerNotifiedOfCancelOnCancel() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.cancel();
+
+    verify(harness.listener).onEngineJobCancelled(eq(job), eq(harness.key));
+  }
+
+  @Test
+  public void testOnResourceReadyNotDeliveredAfterCancel() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.cancel();
+
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    ShadowLooper.runUiThreadTasks();
+    verify(harness.cb, never()).onResourceReady(anyResource(), isADataSource());
+  }
+
+  @Test
+  public void testOnExceptionNotDeliveredAfterCancel() {
+    harness = new EngineJobHarness();
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.cancel();
+
+    job.onLoadFailed(new GlideException("test"));
+
+    ShadowLooper.runUiThreadTasks();
+    verify(harness.cb, never()).onLoadFailed(any(GlideException.class));
+  }
+
+  @Test
+  public void testRemovingAllCallbacksCancelsRunner() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.removeCallback(harness.cb);
+
+    assertTrue(job.isCancelled());
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  public void removingSomeCallbacksDoesNotCancelRunner() {
+    EngineJob job = harness.getJob();
+    job.addCallback(mock(ResourceCallback.class));
+    job.removeCallback(harness.cb);
+
+    assertFalse(job.isCancelled());
+  }
+
+  @Test
+  public void testResourceIsAcquiredOncePerConsumerAndOnceForCache() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    // Once while notifying and once for single callback.
+    verify(harness.engineResource, times(2)).acquire();
+  }
+
+  @Test
+  public void testDoesNotNotifyCancelledIfCompletes() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));
+  }
+
+  @Test
+  public void testDoesNotNotifyCancelledIfAlreadyCancelled() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.cancel();
+    job.cancel();
+
+    verify(harness.listener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));
+  }
+
+  @Test
+  public void testDoesNotNotifyCancelledIfReceivedException() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onLoadFailed(new GlideException("test"));
+
+    verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
+    verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
+  }
+
+  @Test
+  public void testReleasesResourceIfCancelledOnReady() {
+    ShadowLooper shadowLooper = Shadows.shadowOf(harness.mainHandler.getLooper());
+    shadowLooper.pause();
+
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+    job.cancel();
+    shadowLooper.runOneTask();
+
+    verify(harness.resource).recycle();
+  }
+
+  @Test
+  public void testDoesNotAcquireOnceForMemoryCacheIfNotCacheable() {
+    harness.isCacheable = false;
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    verify(harness.engineResource, times(2)).acquire();
+  }
+
+  @Test
+  public void testNotifiesNewCallbackOfResourceIfCallbackIsAddedDuringOnResourceReady() {
+    final EngineJob<Object> job = harness.getJob();
+    final ResourceCallback existingCallback = mock(ResourceCallback.class);
+    final ResourceCallback newCallback = mock(ResourceCallback.class);
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        job.addCallback(newCallback);
+        return null;
+      }
+    }).when(existingCallback).onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(existingCallback);
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    verify(newCallback).onResourceReady(eq(harness.engineResource), eq(harness.dataSource));
+  }
+
+  @Test
+  public void testNotifiesNewCallbackOfExceptionIfCallbackIsAddedDuringOnException() {
+    harness = new EngineJobHarness();
+    final EngineJob job = harness.getJob();
+    final ResourceCallback existingCallback = mock(ResourceCallback.class);
+    final ResourceCallback newCallback = mock(ResourceCallback.class);
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        job.addCallback(newCallback);
+        return null;
+      }
+    }).when(existingCallback).onLoadFailed(any(GlideException.class));
+
+    GlideException exception = new GlideException("test");
+    job.addCallback(existingCallback);
+    job.start(harness.decodeJob);
+    job.onLoadFailed(exception);
+
+    verify(newCallback).onLoadFailed(eq(exception));
+  }
+
+  @Test
+  public void testRemovingCallbackDuringOnResourceReadyIsIgnoredIfCallbackHasAlreadyBeenCalled() {
+    final EngineJob<Object> job = harness.getJob();
+    final ResourceCallback cb = mock(ResourceCallback.class);
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        job.removeCallback(cb);
+        return null;
+      }
+    }).when(cb).onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(cb);
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    verify(cb, times(1)).onResourceReady(anyResource(), isADataSource());
+  }
+
+  @Test
+  public void testRemovingCallbackDuringOnExceptionIsIgnoredIfCallbackHasAlreadyBeenCalled() {
+    harness = new EngineJobHarness();
+    final EngineJob<Object> job = harness.getJob();
+    final ResourceCallback cb = mock(ResourceCallback.class);
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        job.removeCallback(cb);
+        return null;
+      }
+    }).when(cb).onLoadFailed(any(GlideException.class));
+
+    GlideException exception = new GlideException("test");
+    job.addCallback(cb);
+    job.start(harness.decodeJob);
+    job.onLoadFailed(exception);
+
+    verify(cb, times(1)).onLoadFailed(eq(exception));
+  }
+
+  @Test
+  public void
+  testRemovingCallbackDuringOnResourceReadyPreventsCallbackFromBeingCalledIfNotYetCalled() {
+    final EngineJob<Object> job = harness.getJob();
+    final ResourceCallback notYetCalled = mock(ResourceCallback.class);
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        job.removeCallback(notYetCalled);
+        return null;
+      }
+    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(notYetCalled);
+    job.start(harness.decodeJob);
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());
+  }
+
+  @Test
+  public void
+  testRemovingCallbackDuringOnResourceReadyPreventsResourceFromBeingAcquiredForCallback() {
+    final EngineJob<Object> job = harness.getJob();
+    final ResourceCallback notYetCalled = mock(ResourceCallback.class);
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        job.removeCallback(notYetCalled);
+        return null;
+      }
+    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(notYetCalled);
+    job.start(harness.decodeJob);
+
+    job.onResourceReady(harness.resource, harness.dataSource);
+
+    // Once for notifying, once for called.
+    verify(harness.engineResource, times(2)).acquire();
+  }
+
+  @Test
+  public void testRemovingCallbackDuringOnExceptionPreventsCallbackFromBeingCalledIfNotYetCalled() {
+    harness = new EngineJobHarness();
+    final EngineJob<Object> job = harness.getJob();
+    final ResourceCallback called = mock(ResourceCallback.class);
+    final ResourceCallback notYetCalled = mock(ResourceCallback.class);
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        job.removeCallback(notYetCalled);
+        return null;
+      }
+    }).when(called).onLoadFailed(any(GlideException.class));
+
+    job.addCallback(called);
+    job.addCallback(notYetCalled);
+    job.start(harness.decodeJob);
+    job.onLoadFailed(new GlideException("test"));
+
+    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());
+  }
+
+  @Test
+  public void testCancelsDecodeJobOnCancel() {
+    EngineJob<Object> job = harness.getJob();
+    job.start(harness.decodeJob);
+    job.cancel();
+
+    verify(harness.decodeJob).cancel();
+  }
+
+  @Test
+  public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
+    EngineJob<Object> job = harness.getJob();
+    job.reschedule(harness.decodeJob);
+
+    verify(harness.sourceService).execute(eq(harness.decodeJob));
+  }
+
+  @Test
+  public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
+    EngineJob<Object> job = harness.getJob();
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
+    job.start(harness.decodeJob);
+
+    verify(harness.diskCacheService).execute(eq(harness.decodeJob));
+  }
+
+  @Test
+  public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSoureOnlyOnStart() {
+    EngineJob<Object> job = harness.getJob();
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    job.start(harness.decodeJob);
+
+    verify(harness.sourceService).execute(eq(harness.decodeJob));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static class MultiCbHarness {
+    Key key = mock(Key.class);
+    Resource<Object> resource = mock(Resource.class);
+    EngineResource<Object> engineResource = mock(EngineResource.class);
+    EngineJobListener listener = mock(EngineJobListener.class);
+    boolean isCacheable = true;
+    int numCbs = 10;
+    List<ResourceCallback> cbs = new ArrayList<>();
+    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    EngineJob<Object> job;
+    GlideExecutor diskCacheService = mock(GlideExecutor.class);
+    GlideExecutor sourceService = mock(GlideExecutor.class);
+    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    DataSource dataSource = DataSource.LOCAL;
+
+    public MultiCbHarness() {
+      when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
+      job = new EngineJob<>(diskCacheService, sourceService, listener, pool, factory)
+          .init(key, isCacheable);
+      for (int i = 0; i < numCbs; i++) {
+        cbs.add(mock(ResourceCallback.class));
+      }
+      for (ResourceCallback cb : cbs) {
+        job.addCallback(cb);
+      }
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private static class EngineJobHarness {
+    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    Key key = mock(Key.class);
+    Handler mainHandler = new Handler();
+    ResourceCallback cb = mock(ResourceCallback.class);
+    Resource<Object> resource = mock(Resource.class);
+    EngineResource<Object> engineResource = mock(EngineResource.class);
+    EngineJobListener listener = mock(EngineJobListener.class);
+    GlideExecutor diskCacheService = mock(GlideExecutor.class);
+    GlideExecutor sourceService = mock(GlideExecutor.class);
+    boolean isCacheable = true;
+    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    DataSource dataSource = DataSource.DATA_DISK_CACHE;
+
+    public EngineJob<Object> getJob() {
+      when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
+      EngineJob result = new EngineJob(diskCacheService, sourceService, listener, pool, factory)
+          .init(key, isCacheable);
+      result.addCallback(cb);
+      return result;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
new file mode 100644
index 000000000..e2c13d0e7
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -0,0 +1,154 @@
+package com.bumptech.glide.load.engine;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
+
+/**
+ * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object)
+ * equals} and SHA-1 disk cache key are different on any difference in ID or existence of a certain
+ * workflow part. Also checking whether the equals method is symmetric.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class EngineKeyTest {
+  private Harness harness;
+
+  @Before
+  public void setUp() {
+    harness = new Harness();
+  }
+
+  private static class Harness {
+    String id = "testId";
+    int width = 1;
+    int height = 2;
+    Class resourceClass = Object.class;
+    Class transcodeClass = Integer.class;
+    Key signature = mock(Key.class);
+    Transformation<Object> transformation = mock(Transformation.class);
+    Options options = new Options();
+
+    public Harness() {
+      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
+          .updateDiskCacheKey(any(MessageDigest.class));
+    }
+
+    public EngineKey build() {
+      return new EngineKey(id, signature, width, height,
+          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
+          resourceClass, transcodeClass, options);
+    }
+  }
+
+  @Test
+  public void testIsIdenticalWithSameArguments() {
+    assertEquals(harness.build(), harness.build());
+  }
+
+  @Test
+  public void testDiffersIfIdDiffers() throws Exception {
+    EngineKey first = harness.build();
+    harness.id = harness.id + "2";
+    EngineKey second = harness.build();
+
+    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
+  }
+
+  @Test
+  public void testDiffersIfHeightDiffers() throws Exception {
+    EngineKey first = harness.build();
+    harness.height += 1;
+    EngineKey second = harness.build();
+
+    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
+  }
+
+  @Test
+  public void testDiffersIfWidthDiffers() throws Exception {
+    EngineKey first = harness.build();
+    harness.width += 1;
+    EngineKey second = harness.build();
+
+    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
+  }
+
+  @Test
+  public void testDiffersIfSignatureDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    EngineKey first = harness.build();
+    Key signature = mock(Key.class);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        MessageDigest digest = (MessageDigest) invocationOnMock.getArguments()[0];
+        digest.update("signature".getBytes("UTF-8"));
+        return null;
+      }
+    }).when(signature).updateDiskCacheKey(any(MessageDigest.class));
+    harness.signature = signature;
+    EngineKey second = harness.build();
+
+    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
+  }
+
+  @Test
+  public void testDiffersIfResourceClassDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    EngineKey first = harness.build();
+    harness.resourceClass = Long.class;
+    EngineKey second = harness.build();
+    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
+  }
+
+  @Test
+  public void testDiffersIfTranscodeClassDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    EngineKey first = harness.build();
+    harness.transcodeClass = Long.class;
+    EngineKey second = harness.build();
+    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
+  }
+
+  @Test
+  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {
+    EngineKey first = harness.build();
+
+    Transformation<Object> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other")).when(other)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    harness.transformation = other;
+    EngineKey second = harness.build();
+    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
+  }
+
+  @Test
+  public void testDiffersIfOptionsDiffer() throws NoSuchAlgorithmException {
+    EngineKey first = harness.build();
+    harness.options = new Options();
+    harness.options.set(Option.memory("fakeKey"), "someValue");
+    EngineKey second = harness.build();
+    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
new file mode 100644
index 000000000..1f328c03d
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -0,0 +1,154 @@
+package com.bumptech.glide.load.engine;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.Key;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class EngineResourceTest {
+  private EngineResource<Object> engineResource;
+  private EngineResource.ResourceListener listener;
+  private Key cacheKey = mock(Key.class);
+  private Resource<Object> resource;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    resource = mock(Resource.class);
+    engineResource = new EngineResource<>(resource, true /*isMemoryCacheable*/);
+    listener = mock(EngineResource.ResourceListener.class);
+    engineResource.setResourceListener(cacheKey, listener);
+  }
+
+  @Test
+  public void testCanAcquireAndRelease() {
+    engineResource.acquire();
+    engineResource.release();
+
+    verify(listener).onResourceReleased(cacheKey, engineResource);
+  }
+
+  @Test
+  public void testCanAcquireMultipleTimesAndRelease() {
+    engineResource.acquire();
+    engineResource.acquire();
+    engineResource.release();
+    engineResource.release();
+
+    verify(listener).onResourceReleased(eq(cacheKey), eq(engineResource));
+  }
+
+  @Test
+  public void testDelegatesGetToWrappedResource() {
+    Object expected = new Object();
+    when(resource.get()).thenReturn(expected);
+    assertEquals(expected, engineResource.get());
+  }
+
+  @Test
+  public void testDelegatesGetSizeToWrappedResource() {
+    int expectedSize = 1234;
+    when(resource.getSize()).thenReturn(expectedSize);
+    assertEquals(expectedSize, engineResource.getSize());
+  }
+
+  @Test
+  public void testRecyclesWrappedResourceWhenRecycled() {
+    engineResource.acquire();
+    engineResource.release();
+    engineResource.recycle();
+    verify(resource).recycle();
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void testThrowsIfRecycledTwice() {
+    engineResource.recycle();
+    engineResource.recycle();
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void testThrowsIfReleasedBeforeAcquired() {
+    engineResource.release();
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void testThrowsIfRecycledWhileAcquired() {
+    engineResource.acquire();
+    engineResource.recycle();
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void testThrowsIfAcquiredAfterRecycled() {
+    engineResource.recycle();
+    engineResource.acquire();
+  }
+
+  @Test
+  public void testThrowsIfAcquiredOnBackgroundThread() throws InterruptedException {
+    Thread otherThread = new Thread(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          engineResource.acquire();
+        } catch (IllegalThreadStateException e) {
+          return;
+        }
+        fail("Failed to receive expected IllegalThreadStateException");
+      }
+    });
+    otherThread.start();
+    otherThread.join();
+  }
+
+  @Test
+  public void testThrowsIfReleasedOnBackgroundThread() throws InterruptedException {
+    engineResource.acquire();
+    Thread otherThread = new Thread(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          engineResource.release();
+        } catch (IllegalThreadStateException e) {
+          return;
+        }
+        fail("Failed to receive expected IllegalThreadStateException");
+      }
+    });
+    otherThread.start();
+    otherThread.join();
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void testThrowsIfReleasedMoreThanAcquired() {
+    engineResource.acquire();
+    engineResource.release();
+    engineResource.release();
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfWrappedResourceIsNull() {
+    new EngineResource<>(null, false);
+  }
+
+  @Test
+  public void testCanSetAndGetIsCacheable() {
+    engineResource = new EngineResource<>(mock(Resource.class), true);
+    assertTrue(engineResource.isCacheable());
+    engineResource = new EngineResource<>(mock(Resource.class), false);
+    assertFalse(engineResource.isCacheable());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
new file mode 100644
index 000000000..8cbe62361
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -0,0 +1,502 @@
+package com.bumptech.glide.load.engine;
+
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.GlideShadowLooper;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { GlideShadowLooper.class })
+public class EngineTest {
+  private EngineTestHarness harness;
+
+  @Before
+  public void setUp() {
+    harness = new EngineTestHarness();
+  }
+
+  @Test
+  public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
+    harness.doLoad();
+
+    verify(harness.job).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void testCallbackIsAddedToNewEngineJobWithNoExistingLoad() {
+    harness.doLoad();
+
+    verify(harness.job).addCallback(eq(harness.cb));
+  }
+
+  @Test
+  public void testLoadStatusIsReturnedForNewLoad() {
+    assertNotNull(harness.doLoad());
+  }
+
+  @Test
+  public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
+    Engine.LoadStatus loadStatus = harness.doLoad();
+    loadStatus.cancel();
+
+    verify(harness.job).removeCallback(eq(harness.cb));
+  }
+
+  @Test
+  public void testNewRunnerIsAddedToRunnersMap() {
+    harness.doLoad();
+
+    assertThat(harness.jobs).containsKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
+    harness.doLoad();
+    harness.doLoad();
+
+    verify(harness.job, times(1)).start(any(DecodeJob.class));
+  }
+
+  @Test
+  @SuppressWarnings("unchecked")
+  public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
+    harness.doLoad();
+
+    ResourceCallback newCallback = mock(ResourceCallback.class);
+    harness.cb = newCallback;
+    harness.doLoad();
+
+    verify(harness.job).addCallback(eq(newCallback));
+  }
+
+  @Test
+  public void testLoadStatusIsReturnedForExistingJob() {
+    harness.doLoad();
+    Engine.LoadStatus loadStatus = harness.doLoad();
+
+    assertNotNull(loadStatus);
+  }
+
+  @Test
+  public void testResourceIsReturnedFromActiveResourcesIfPresent() {
+    harness.activeResources
+        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testResourceIsNotReturnedFromActiveResourcesIfRefIsCleared() {
+    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
+
+    harness.doLoad();
+
+    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());
+  }
+
+  @Test
+  public void testKeyIsRemovedFromActiveResourcesIfRefIsCleared() {
+    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
+
+    harness.doLoad();
+
+    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testResourceIsAcquiredIfReturnedFromActiveResources() {
+    harness.activeResources
+        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+
+    harness.doLoad();
+
+    verify(harness.resource).acquire();
+  }
+
+  @Test
+  public void testNewLoadIsNotStartedIfResourceIsActive() {
+    harness.activeResources
+        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void testNullLoadStatusIsReturnedIfResourceIsActive() {
+    harness.activeResources
+        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+
+    assertNull(harness.doLoad());
+  }
+
+  @Test
+  public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+    EngineResource other = mock(EngineResource.class);
+    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());
+  }
+
+  @Test
+  public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
+    harness.activeResources
+        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+
+    harness.isMemoryCacheable = false;
+    harness.doLoad();
+
+    verify(harness.resource, never()).acquire();
+    verify(harness.job).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void testCacheIsCheckedIfMemoryCacheable() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testCacheIsNotCheckedIfNotMemoryCacheable() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.isMemoryCacheable = false;
+    harness.doLoad();
+
+    verify(harness.job).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void testResourceIsReturnedFromCacheIfPresent() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testHandlesNonEngineResourcesFromCacheIfPresent() {
+    final Object expected = new Object();
+    Resource fromCache = mock(Resource.class);
+    when(fromCache.get()).thenReturn(expected);
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Resource resource = (Resource) invocationOnMock.getArguments()[0];
+        assertEquals(expected, resource.get());
+        return null;
+      }
+    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(anyResource(), isADataSource());
+  }
+
+  @Test
+  public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    assertEquals(harness.resource, harness.activeResources.get(harness.cacheKey).get());
+  }
+
+  @Test
+  public void testResourceIsAcquiredIfReturnedFromCache() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.resource).acquire();
+  }
+
+  @Test
+  public void testNewLoadIsNotStartedIfResourceIsCached() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
+
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void testNullLoadStatusIsReturnedForCachedResource() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
+
+    Engine.LoadStatus loadStatus = harness.doLoad();
+    assertNull(loadStatus);
+  }
+
+  @Test
+  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
+    harness.doLoad();
+
+    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+
+    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testEngineIsSetAsResourceListenerOnJobComplete() {
+    harness.doLoad();
+
+    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+
+    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.engine));
+  }
+
+  @Test
+  public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
+    harness.doLoad();
+
+    harness.engine.onEngineJobComplete(harness.cacheKey, null);
+  }
+
+  @Test
+  public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
+    when(harness.resource.isCacheable()).thenReturn(true);
+    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+
+    WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
+    assertThat(harness.resource).isEqualTo(resourceRef.get());
+  }
+
+  @Test
+  public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
+    harness.engine.onEngineJobComplete(harness.cacheKey, null);
+    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
+    when(harness.resource.isCacheable()).thenReturn(false);
+    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
+    harness.doLoad();
+
+    harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
+    harness.doLoad();
+
+    harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    assertEquals(harness.job, harness.jobs.get(harness.cacheKey));
+  }
+
+  @Test
+  public void testResourceIsAddedToCacheOnReleased() {
+    final Object expected = new Object();
+    when(harness.resource.isCacheable()).thenReturn(true);
+    when(harness.resource.get()).thenReturn(expected);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
+        assertEquals(expected, resource.get());
+        return null;
+      }
+    }).when(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
+
+    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+
+
+    verify(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
+  }
+
+  @Test
+  public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
+    when(harness.resource.isCacheable()).thenReturn(false);
+    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+
+    verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
+  }
+
+  @Test
+  public void testResourceIsRecycledIfNotCacheableWhenReleased() {
+    when(harness.resource.isCacheable()).thenReturn(false);
+    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+    verify(harness.resourceRecycler).recycle(eq(harness.resource));
+  }
+
+  @Test
+  public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
+    harness.activeResources
+        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+
+    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
+
+    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testEngineAddedAsListenerToMemoryCache() {
+    verify(harness.cache).setResourceRemovedListener(eq(harness.engine));
+  }
+
+  @Test
+  public void testResourceIsRecycledWhenRemovedFromCache() {
+    harness.engine.onResourceRemoved(harness.resource);
+    verify(harness.resourceRecycler).recycle(eq(harness.resource));
+  }
+
+  @Test
+  public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
+    harness.doLoad();
+
+    assertThat(harness.jobs).containsEntry(harness.cacheKey, harness.job);
+  }
+
+  @Test
+  public void testKeyFactoryIsGivenNecessaryArguments() {
+    harness.doLoad();
+
+    verify(harness.keyFactory)
+        .buildKey(eq(harness.model), eq(harness.signature), eq(harness.width), eq(harness.height),
+            eq(harness.transformations), eq(Object.class), eq(Object.class), eq(harness.options));
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArguments() {
+    harness.doLoad();
+
+    verify(harness.engineJobFactory).build(eq(harness.cacheKey), eq(true) /*isMemoryCacheable*/);
+  }
+
+  @Test
+  public void testReleaseReleasesEngineResource() {
+    EngineResource<Object> engineResource = mock(EngineResource.class);
+    harness.engine.release(engineResource);
+    verify(engineResource).release();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfAskedToReleaseNonEngineResource() {
+    harness.engine.release(mock(Resource.class));
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
+    BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
+      @Override
+      public void runTest() throws Exception {
+        harness.doLoad();
+      }
+    });
+  }
+
+  @SuppressWarnings("unchecked")
+  private static class EngineTestHarness {
+    EngineKey cacheKey = mock(EngineKey.class);
+    EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
+    ResourceCallback cb = mock(ResourceCallback.class);
+    EngineResource resource = mock(EngineResource.class);
+    Map<Key, EngineJob> jobs = new HashMap<>();
+    Map<Key, WeakReference<EngineResource<?>>> activeResources = new HashMap<>();
+
+    int width = 100;
+    int height = 100;
+
+    Object model = new Object();
+    MemoryCache cache = mock(MemoryCache.class);
+    EngineJob job;
+    Engine engine;
+    Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
+    Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
+    ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
+    Key signature = mock(Key.class);
+    Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+    Options options = new Options();
+    GlideContext glideContext = mock(GlideContext.class);
+    boolean isMemoryCacheable = true;
+
+    public EngineTestHarness() {
+      when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
+          eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);
+
+      job = mock(EngineJob.class);
+
+      engine = new Engine(cache, mock(DiskCache.Factory.class), mock(GlideExecutor.class),
+          mock(GlideExecutor.class), jobs, keyFactory, activeResources, engineJobFactory,
+          decodeJobFactory, resourceRecycler);
+    }
+
+    public Engine.LoadStatus doLoad() {
+      when(engineJobFactory.build(eq(cacheKey), anyBoolean())).thenReturn(job);
+      return engine.load(glideContext,
+          model,
+          signature,
+          width,
+          height,
+          Object.class,
+          Object.class,
+          Priority.HIGH,
+          DiskCacheStrategy.ALL,
+          transformations,
+          false /*isTransformationRequired*/,
+          options,
+          isMemoryCacheable,
+          cb);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
new file mode 100644
index 000000000..fe8c252b1
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -0,0 +1,137 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.signature.StringSignature;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(JUnit4.class)
+public class ResourceCacheKeyTest {
+
+  private Factory factory;
+
+  @Before
+  public void setUp() {
+    factory = new Factory();
+  }
+
+  @Test
+  public void testIdenticalWithSameArguments()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    KeyAssertions.assertSame(factory.build(), factory.build());
+  }
+
+  @Test
+  public void testDifferIfSourceKeyDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    mutateAndAssertDifferent(new FactoryMutation() {
+      @Override
+      public void mutate(Factory factory) {
+        factory.sourceKey = new StringSignature("secondKey");
+      }
+    });
+  }
+
+  @Test
+  public void testDiffersIfSignatureDiffers() {
+    mutateAndAssertDifferent(new FactoryMutation() {
+      @Override
+      public void mutate(Factory factory) {
+        factory.signature = new StringSignature("secondSignature");
+      }
+    });
+  }
+
+  @Test
+  public void testDiffersIfWidthDiffers() {
+    mutateAndAssertDifferent(new FactoryMutation() {
+      @Override
+      public void mutate(Factory factory) {
+        factory.width = factory.width * 2;
+      }
+    });
+  }
+
+  @Test
+  public void testDiffersIfHeightDiffers() {
+    mutateAndAssertDifferent(new FactoryMutation() {
+      @Override
+      public void mutate(Factory factory) {
+        factory.height = factory.height * 2;
+      }
+    });
+  }
+
+  @Test
+  public void tesDiffersIfTransformationDiffers() {
+    mutateAndAssertDifferent(new FactoryMutation() {
+      @Override
+      public void mutate(Factory factory) {
+        factory.transformation = mock(Transformation.class);
+        doAnswer(new Util.WriteDigest("otherTransformation")).when(factory.transformation)
+            .updateDiskCacheKey(any(MessageDigest.class));
+      }
+    });
+  }
+
+  @Test
+  public void testDiffersIfResourceDiffers() {
+    mutateAndAssertDifferent(new FactoryMutation() {
+      @Override
+      public void mutate(Factory factory) {
+        factory.resourceClass = Integer.class;
+      }
+    });
+  }
+
+  interface FactoryMutation {
+    void mutate(Factory factory);
+  }
+
+  private void mutateAndAssertDifferent(FactoryMutation mutation) {
+    ResourceCacheKey original = factory.build();
+    mutation.mutate(factory);
+    ResourceCacheKey mutated = factory.build();
+
+    try {
+      KeyAssertions.assertDifferent(original, mutated);
+    } catch (NoSuchAlgorithmException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  static class Factory {
+    Key sourceKey = new StringSignature("sourceKey");
+    Key signature = new StringSignature("signature");
+    int width = 100;
+    int height = 100;
+    Transformation<?> transformation = mock(Transformation.class);
+    Class<?> resourceClass = Object.class;
+    Options options = new Options();
+
+    Factory() {
+      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
+          .updateDiskCacheKey(any(MessageDigest.class));
+    }
+
+    ResourceCacheKey build() {
+      return new ResourceCacheKey(sourceKey, signature, width, height, transformation,
+          resourceClass, options);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
new file mode 100644
index 000000000..9d4257b6d
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.os.Looper;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ResourceRecyclerTest {
+
+  private ResourceRecycler recycler;
+
+  @Before
+  public void setUp() {
+    recycler = new ResourceRecycler();
+  }
+
+  @Test
+  public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
+    Resource resource = mock(Resource.class);
+    Shadows.shadowOf(Looper.getMainLooper()).pause();
+    recycler.recycle(resource);
+    verify(resource).recycle();
+  }
+
+  @Test
+  public void testDoesNotRecycleChildResourceSynchronously() {
+    Resource parent = mock(Resource.class);
+    final Resource child = mock(Resource.class);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        recycler.recycle(child);
+        return null;
+      }
+    }).when(parent).recycle();
+
+    Shadows.shadowOf(Looper.getMainLooper()).pause();
+
+    recycler.recycle(parent);
+
+    verify(parent).recycle();
+    verify(child, never()).recycle();
+
+    Shadows.shadowOf(Looper.getMainLooper()).runOneTask();
+
+    verify(child).recycle();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
new file mode 100644
index 000000000..e81521160
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
@@ -0,0 +1,74 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import com.google.common.testing.EqualsTester;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.AttributeStrategy.Key;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class AttributeStrategyKeyTest {
+
+  private AttributeStrategy.KeyPool keyPool;
+
+  @Before
+  public void setUp() {
+    keyPool = mock(AttributeStrategy.KeyPool.class);
+  }
+
+  @Test
+  public void testEquality() {
+    Key first = new Key(keyPool);
+    first.init(100, 100, Bitmap.Config.ARGB_4444);
+    Key second = new Key(keyPool);
+    second.init(100, 100, Bitmap.Config.ARGB_4444);
+
+    Key third = new Key(keyPool);
+    third.init(200, 100, Bitmap.Config.ARGB_4444);
+
+    Key fourth = new Key(keyPool);
+    fourth.init(100, 200, Bitmap.Config.ARGB_4444);
+
+    Key fifth = new Key(keyPool);
+    fifth.init(100, 100, Bitmap.Config.RGB_565);
+
+    new EqualsTester().addEqualityGroup(first, second).addEqualityGroup(third)
+        .addEqualityGroup(fourth).addEqualityGroup(fifth).testEquals();
+  }
+
+  @Test
+  public void testReturnsSelfToPoolOnOffer() {
+    Key key = new Key(keyPool);
+    key.offer();
+
+    verify(keyPool).offer(eq(key));
+  }
+
+  @Test
+  public void testInitSetsAttributes() {
+    Key key = new Key(keyPool);
+    key.init(100, 100, Bitmap.Config.ARGB_4444);
+
+    Key other = new Key(keyPool);
+    other.init(200, 200, Bitmap.Config.RGB_565);
+
+    assertNotEquals(key, other);
+
+    key.init(200, 200, Bitmap.Config.RGB_565);
+
+    assertEquals(key, other);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
new file mode 100644
index 000000000..9fc1f1eb2
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -0,0 +1,108 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+import android.graphics.Bitmap;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowBitmap;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class AttributeStrategyTest {
+
+  private AttributeStrategy strategy;
+
+  @Before
+  public void setUp() throws Exception {
+    strategy = new AttributeStrategy();
+  }
+
+  @Test
+  public void testIGetNullIfNoMatchingBitmapExists() {
+    assertNull(strategy.get(100, 100, Bitmap.Config.ARGB_8888));
+  }
+
+  @Test
+  public void testICanAddAndGetABitmapOfTheSameSizeAndDimensions() {
+    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    strategy.put(bitmap);
+    assertEquals(bitmap,
+        strategy.get(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888));
+  }
+
+  @Test
+  public void testICantGetABitmapOfTheSameDimensionsButDifferentConfigs() {
+    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    strategy.put(bitmap);
+    assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
+  }
+
+  @Test
+  public void testICantGetABitmapOfTheSameDimensionsAndSizeButDifferentConfigs() {
+    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+    strategy.put(bitmap);
+    assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
+  }
+
+  @Test
+  public void testICantGetABitmapOfDifferentWidths() {
+    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    strategy.put(bitmap);
+    assertNull(strategy.get(99, 100, Bitmap.Config.ARGB_8888));
+  }
+
+  @Test
+  public void testICantGetABitmapOfDifferentHeights() {
+    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    strategy.put(bitmap);
+    assertNull(strategy.get(100, 99, Bitmap.Config.ARGB_8888));
+  }
+
+  @Test
+  public void testICantGetABitmapOfDifferentDimensionsButTheSameSize() {
+    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    strategy.put(bitmap);
+    assertNull(strategy.get(50, 200, Bitmap.Config.ARGB_8888));
+  }
+
+  @Test
+  public void testMultipleBitmapsOfDifferentAttributesCanBeAddedAtOnce() {
+    Bitmap first = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    Bitmap second = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap third = ShadowBitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);
+
+    strategy.put(first);
+    strategy.put(second);
+    strategy.put(third);
+
+    assertEquals(first, strategy.get(100, 100, Bitmap.Config.RGB_565));
+    assertEquals(second, strategy.get(100, 100, Bitmap.Config.ARGB_8888));
+    assertEquals(third, strategy.get(120, 120, Bitmap.Config.RGB_565));
+  }
+
+  @Test
+  public void testLeastRecentlyUsedAttributeSetIsRemovedFirst() {
+    final Bitmap leastRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    final Bitmap other = ShadowBitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);
+    final Bitmap mostRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    strategy.get(100, 100, Bitmap.Config.ALPHA_8);
+    strategy.get(1000, 1000, Bitmap.Config.RGB_565);
+    strategy.get(100, 100, Bitmap.Config.ARGB_8888);
+
+    strategy.put(other);
+    strategy.put(leastRecentlyUsed);
+    strategy.put(mostRecentlyUsed);
+
+    Bitmap removed = strategy.removeLast();
+    assertEquals(
+        "Expected=" + strategy.logBitmap(leastRecentlyUsed) + " got=" + strategy.logBitmap(removed),
+        leastRecentlyUsed, removed);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
new file mode 100644
index 000000000..ab9604ddc
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
@@ -0,0 +1,121 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GroupedLinkedMapTest {
+
+    private GroupedLinkedMap<Key, Object> map;
+
+    @Before
+    public void setUp() {
+        map = new GroupedLinkedMap<Key, Object>();
+    }
+
+    @Test
+    public void testReturnsNullForGetWithNoBitmap() {
+        assertNull(map.get(mock(Key.class)));
+    }
+
+    @Test
+    public void testCanAddAndRemoveABitmap() {
+        Key key = new Key("key", 1, 1);
+        Object expected = new Object();
+
+        map.put(key, expected);
+
+        assertThat(map.get(key)).isEqualTo(expected);
+    }
+
+    @Test
+    public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
+        Key key = new Key("key", 1, 1);
+        Integer value = 20;
+
+        int numToAdd = 10;
+
+        for (int i = 0; i < numToAdd; i++) {
+            map.put(key, new Integer(value));
+        }
+
+        for (int i = 0; i < numToAdd; i++) {
+            assertThat(map.get(key)).isEqualTo(value);
+        }
+    }
+
+    @Test
+    public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
+        Key firstKey = new Key("key", 1, 1);
+        Integer firstValue = 10;
+        map.put(firstKey, firstValue);
+        map.put(firstKey, new Integer(firstValue));
+
+        Key secondKey = new Key("key", 2, 2);
+        Integer secondValue = 20;
+        map.put(secondKey, secondValue);
+
+        map.get(firstKey);
+
+        assertThat(map.removeLast()).isEqualTo(secondValue);
+    }
+
+    @Test
+    public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
+        Key firstKey = new Key("key", 1, 1);
+        Integer firstValue = 10;
+
+        map.put(firstKey, firstValue);
+        map.put(firstKey, new Integer(firstValue));
+
+        map.get(firstKey);
+
+        Integer secondValue = 20;
+        map.put(new Key("key", 2, 2), secondValue);
+
+        assertThat(map.removeLast()).isEqualTo(secondValue);
+    }
+
+    private static class Key implements Poolable {
+
+        private final String key;
+        private final int width;
+        private final int height;
+
+        public Key(String key, int width, int height) {
+            this.key = key;
+            this.width = width;
+            this.height = height;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof Key) {
+                Key other = (Key) o;
+                return key.equals(other.key) && width == other.width && height == other.height;
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = key != null ? key.hashCode() : 0;
+            result = 31 * result + width;
+            result = 31 * result + height;
+            return result;
+        }
+
+        @Override
+        public void offer() {
+            // Do nothing.
+        }
+    }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
new file mode 100644
index 000000000..f48d297dd
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -0,0 +1,111 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.DEFAULT, sdk = 18)
+public class LruArrayPoolTest {
+  private static final int MAX_SIZE = 10;
+  private static final Class ARRAY_CLASS = byte[].class;
+  private static final ArrayAdapterInterface ADAPTER = new ByteArrayAdapter();
+  private LruArrayPool pool;
+
+  @Before
+  public void setUp() throws Exception {
+    pool = new LruArrayPool(MAX_SIZE);
+  }
+
+  @Test
+  public void testNewPoolIsEmpty() {
+    assertEquals(pool.getCurrentSize(), 0);
+  }
+
+  @Test
+  public void testICanAddAndGetValidArray() {
+    int size = 758;
+    int value = 564;
+    fillPool(pool, size - 1, value);
+    pool.put(createArray(ARRAY_CLASS, size, value), ARRAY_CLASS);
+    Object array = pool.get(size, ARRAY_CLASS);
+    assertNotNull(array);
+    assertTrue(ADAPTER.getArrayLength(array) >= size);
+    assertTrue(array.getClass() == ARRAY_CLASS);
+    assertTrue(((byte[]) array)[0] == (byte) 0);
+  }
+
+  @Test
+  public void testItIsSizeLimited() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 1);
+    assertTrue(pool.getCurrentSize() <= MAX_SIZE);
+  }
+
+  @Test
+  public void testArrayLargerThanPoolIsNotAdded() {
+    pool = new LruArrayPool(MAX_SIZE);
+    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0),
+        ARRAY_CLASS);
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testClearMemoryRemovesAllArrays() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0);
+    pool.clearMemory();
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
+    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
+      testTrimMemory(MAX_SIZE, trimLevel, 0);
+    }
+  }
+
+  private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
+    pool = new LruArrayPool(MAX_SIZE);
+    fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
+    pool.trimMemory(trimLevel);
+    assertEquals("Failed level=" + trimLevel, expectedSize, pool.getCurrentSize());
+  }
+
+  private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
+    for (int i = 0; i < arrayCount; i++) {
+      pool.put(createArray(ARRAY_CLASS, arrayLength, 10), ARRAY_CLASS);
+    }
+  }
+
+  private Object createArray(Class type, int size, int value) {
+    Object array = null;
+    if (type.equals(int[].class)) {
+      array = new int[size];
+      Arrays.fill((int[]) array, value);
+    } else if (type.equals(byte[].class)) {
+      array = new byte[size];
+      Arrays.fill((byte[]) array, (byte) value);
+    }
+    return array;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
new file mode 100644
index 000000000..14b51fedc
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -0,0 +1,271 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowBitmap;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class LruBitmapPoolTest {
+  private static final int MAX_SIZE = 10;
+  private static final Set<Bitmap.Config> ALLOWED_CONFIGS =
+      Collections.singleton(Bitmap.Config.ARGB_8888);
+  private MockStrategy strategy;
+  private LruBitmapPool pool;
+
+  @Before
+  public void setUp() throws Exception {
+    strategy = new MockStrategy();
+    pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);
+  }
+
+  @Test
+  public void testICanAddAndGetABitmap() {
+    fillPool(pool, 1);
+    pool.put(createMutableBitmap());
+    assertNotNull(pool.get(100, 100, Bitmap.Config.ARGB_8888));
+  }
+
+  @Test
+  public void testImmutableBitmapsAreNotAdded() {
+    Bitmap bitmap = createMutableBitmap();
+    Shadows.shadowOf(bitmap).setMutable(false);
+    pool.put(bitmap);
+    assertThat(strategy.bitmaps).isEmpty();
+  }
+
+  @Test
+  public void testItIsSizeLimited() {
+    fillPool(pool, MAX_SIZE + 2);
+    assertEquals(2, strategy.numRemoves);
+  }
+
+  @Test
+  public void testBitmapLargerThanPoolIsNotAdded() {
+    strategy = new MockStrategy() {
+      @Override
+      public int getSize(Bitmap bitmap) {
+        return 4;
+      }
+    };
+    pool = new LruBitmapPool(3, strategy, ALLOWED_CONFIGS);
+    pool.put(createMutableBitmap());
+    assertEquals(0, strategy.numRemoves);
+    assertEquals(0, strategy.numPuts);
+  }
+
+  @Test
+  public void testClearMemoryRemovesAllBitmaps() {
+    fillPool(pool, MAX_SIZE);
+    pool.clearMemory();
+
+    assertEquals(MAX_SIZE, strategy.numRemoves);
+  }
+
+  @Test
+  public void testEvictedBitmapsAreRecycled() {
+    fillPool(pool, MAX_SIZE);
+    List<Bitmap> bitmaps = new ArrayList<>(MAX_SIZE);
+    for (Bitmap b : strategy.bitmaps) {
+      bitmaps.add(b);
+    }
+
+    pool.clearMemory();
+
+    for (Bitmap b : bitmaps) {
+      assertTrue(b.isRecycled());
+    }
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);
+  }
+
+  @Test
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {
+    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {
+      testTrimMemory(MAX_SIZE, trimLevel, MAX_SIZE);
+    }
+  }
+
+  @Test
+  public void testPassesArgb888ToStrategyAsConfigForRequestsWithNullConfigsOnGet() {
+    LruPoolStrategy strategy = mock(LruPoolStrategy.class);
+    LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);
+
+    Bitmap expected = createMutableBitmap();
+    when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);
+    Bitmap result = pool.get(100, 100, null);
+
+    assertEquals(expected, result);
+  }
+
+  @Test
+  public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetDirty() {
+    LruPoolStrategy strategy = mock(LruPoolStrategy.class);
+    LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);
+
+    Bitmap expected = createMutableBitmap();
+    when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);
+    Bitmap result = pool.getDirty(100, 100, null);
+
+    assertEquals(expected, result);
+  }
+
+  private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
+    MockStrategy strategy = new MockStrategy();
+    LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);
+    fillPool(pool, fillSize);
+    pool.trimMemory(trimLevel);
+    assertEquals("Failed level=" + trimLevel, expectedSize, strategy.numRemoves);
+  }
+
+  @Test
+  public void testCanIncreaseSizeDynamically() {
+    int sizeMultiplier = 2;
+    pool.setSizeMultiplier(2);
+    fillPool(pool, MAX_SIZE * sizeMultiplier);
+
+    assertEquals(0, strategy.numRemoves);
+  }
+
+  @Test
+  public void testCanDecreaseSizeDynamically() {
+    fillPool(pool, MAX_SIZE);
+    assertEquals(0, strategy.numRemoves);
+
+    float sizeMultiplier = 0.5f;
+    pool.setSizeMultiplier(sizeMultiplier);
+
+    assertEquals(Math.round(MAX_SIZE * sizeMultiplier), strategy.numRemoves);
+  }
+
+  @Test
+  public void testCanResetSizeDynamically() {
+    int sizeMultiplier = 2;
+    pool.setSizeMultiplier(sizeMultiplier);
+    fillPool(pool, MAX_SIZE * sizeMultiplier);
+
+    pool.setSizeMultiplier(1);
+
+    assertEquals(Math.round(MAX_SIZE * sizeMultiplier) - MAX_SIZE, strategy.numRemoves);
+  }
+
+  @Test
+  public void testCanGetCurrentMaxSize() {
+    assertEquals(MAX_SIZE, pool.getMaxSize());
+  }
+
+  @Test
+  public void testMaxSizeChangesAfterSizeMultiplier() {
+    pool.setSizeMultiplier(2);
+    assertEquals(2 * MAX_SIZE, pool.getMaxSize());
+  }
+
+  @Test
+  public void testBitmapsWithDisallowedConfigsAreIgnored() {
+    pool = new LruBitmapPool(100, strategy, Collections.singleton(Bitmap.Config.ARGB_4444));
+
+    Bitmap bitmap = createMutableBitmap(Bitmap.Config.RGB_565);
+    pool.put(bitmap);
+
+    assertEquals(0, strategy.numPuts);
+  }
+
+  @Test
+  public void testBitmapsWithAllowedNullConfigsAreAllowed() {
+    pool = new LruBitmapPool(100, strategy, Collections.<Bitmap.Config>singleton(null));
+
+    Bitmap bitmap = createMutableBitmap();
+    Shadows.shadowOf(bitmap).setConfig(null);
+
+    pool.put(bitmap);
+
+    assertEquals(1, strategy.numPuts);
+  }
+
+  private void fillPool(LruBitmapPool pool, int fillCount) {
+    for (int i = 0; i < fillCount; i++) {
+      pool.put(createMutableBitmap());
+    }
+  }
+
+  private Bitmap createMutableBitmap() {
+    return createMutableBitmap(Bitmap.Config.ARGB_8888);
+  }
+
+  private Bitmap createMutableBitmap(Bitmap.Config config) {
+    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, config);
+    Shadows.shadowOf(bitmap).setMutable(true);
+    return bitmap;
+
+  }
+
+  private static class MockStrategy implements LruPoolStrategy {
+    private LinkedList<Bitmap> bitmaps = new LinkedList<>();
+    private int numRemoves;
+    private int numPuts;
+
+    @Override
+    public void put(Bitmap bitmap) {
+      numPuts++;
+      bitmaps.add(bitmap);
+    }
+
+    @Override
+    public Bitmap get(int width, int height, Bitmap.Config config) {
+      return bitmaps.removeLast();
+    }
+
+    @Override
+    public Bitmap removeLast() {
+      numRemoves++;
+      return bitmaps.removeLast();
+    }
+
+    @Override
+    public String logBitmap(Bitmap bitmap) {
+      return null;
+    }
+
+    @Override
+    public String logBitmap(int width, int height, Bitmap.Config config) {
+      return null;
+    }
+
+    @Override
+    public int getSize(Bitmap bitmap) {
+      return 1;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
new file mode 100644
index 000000000..c56ff320e
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -0,0 +1,43 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import com.google.common.testing.EqualsTester;
+
+import android.graphics.Bitmap;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class SizeConfigStrategyTest {
+
+    @Mock SizeConfigStrategy.KeyPool pool;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+    }
+
+    @Test
+    public void testKeyEquals() {
+        new EqualsTester()
+                .addEqualityGroup(
+                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
+                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
+                )
+                .addEqualityGroup(
+                        new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888)
+                )
+                .addEqualityGroup(
+                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565)
+                )
+                .addEqualityGroup(
+                        new SizeConfigStrategy.Key(pool, 100, null /*config*/)
+                )
+                .testEquals();
+
+    }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
new file mode 100644
index 000000000..79385ce31
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
@@ -0,0 +1,62 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import com.google.common.testing.EqualsTester;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.SizeStrategy.Key;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SizeStrategyKeyTest {
+
+  private SizeStrategy.KeyPool keyPool;
+
+  @Before
+  public void setUp() {
+    keyPool = mock(SizeStrategy.KeyPool.class);
+  }
+
+  @Test
+  public void testEquality() {
+    Key first = new Key(keyPool);
+    first.init(100);
+    Key second = new Key(keyPool);
+    second.init(100);
+    Key third = new Key(keyPool);
+    third.init(50);
+
+    new EqualsTester().addEqualityGroup(first, second).addEqualityGroup(third).testEquals();
+  }
+
+  @Test
+  public void testReturnsSelfToPoolOnOffer() {
+    Key key = new Key(keyPool);
+    key.offer();
+
+    verify(keyPool).offer(eq(key));
+  }
+
+  @Test
+  public void testInitSetsSize() {
+    Key key = new Key(keyPool);
+    key.init(100);
+
+    Key other = new Key(keyPool);
+    other.init(200);
+
+    assertNotEquals(key, other);
+
+    key.init(200);
+
+    assertEquals(key, other);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
new file mode 100644
index 000000000..a1ecd5953
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -0,0 +1,126 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.File;
+import java.io.IOException;
+import java.security.MessageDigest;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DiskLruCacheWrapperTest {
+  private DiskLruCacheWrapper cache;
+  private byte[] data;
+  private StringKey key;
+
+  @Before
+  public void setUp() {
+    File dir = RuntimeEnvironment.application.getCacheDir();
+    cache = new DiskLruCacheWrapper(dir, 10 * 1024 * 1024);
+    key = new StringKey("test" + Math.random());
+    data = new byte[] { 1, 2, 3, 4, 5, 6 };
+  }
+
+  @Test
+  public void testCanInsertAndGet() throws IOException {
+    cache.put(key, new DiskCache.Writer() {
+      @Override
+      public boolean write(File file) {
+        try {
+          Util.writeFile(file, data);
+        } catch (IOException e) {
+          fail(e.toString());
+        }
+        return true;
+      }
+    });
+
+    byte[] received = Util.readFile(cache.get(key), data.length);
+
+    assertArrayEquals(data, received);
+  }
+
+  @Test
+  public void testDoesNotCommitIfWriterReturnsFalse() {
+    cache.put(key, new DiskCache.Writer() {
+      @Override
+      public boolean write(File file) {
+        return false;
+      }
+    });
+
+    assertNull(cache.get(key));
+  }
+
+  @Test
+  public void testDoesNotCommitIfWriterWritesButReturnsFalse() {
+    cache.put(key, new DiskCache.Writer() {
+      @Override
+      public boolean write(File file) {
+        try {
+          Util.writeFile(file, data);
+        } catch (IOException e) {
+          fail(e.toString());
+        }
+        return false;
+      }
+    });
+
+    assertNull(cache.get(key));
+  }
+
+  @Test
+  public void testEditIsAbortedIfWriterThrows() throws IOException {
+    try {
+      cache.put(key, new DiskCache.Writer() {
+        @Override
+        public boolean write(File file) {
+          throw new RuntimeException("test");
+        }
+      });
+    } catch (RuntimeException e) {
+      // Expected.
+    }
+
+    cache.put(key, new DiskCache.Writer() {
+      @Override
+      public boolean write(File file) {
+        try {
+          Util.writeFile(file, data);
+        } catch (IOException e) {
+          fail(e.toString());
+        }
+        return true;
+      }
+    });
+
+    byte[] received = Util.readFile(cache.get(key), data.length);
+
+    assertArrayEquals(data, received);
+  }
+
+  private static class StringKey implements Key {
+    private final String key;
+
+    public StringKey(String key) {
+      this.key = key;
+    }
+
+    @Override
+    public void updateDiskCacheKey(MessageDigest messageDigest) {
+      messageDigest.update(key.getBytes());
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
new file mode 100644
index 000000000..57ce35ebb
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -0,0 +1,353 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.util.LruCache;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class LruCacheTest {
+  // 1MB
+  private static final int SIZE = 2;
+  private LruCache<String, Object> cache;
+  private CacheListener listener;
+  private String currentKey;
+
+  @Before
+  public void setUp() throws Exception {
+    currentKey = "";
+    listener = mock(CacheListener.class);
+    cache = new TestLruCache(SIZE, listener);
+    when(listener.getSize(anyObject())).thenReturn(1);
+  }
+
+  @Test
+  public void testCanAddAndRetrieveItem() {
+    String key = getKey();
+    Object object = new Object();
+
+    cache.put(key, object);
+
+    assertEquals(object, cache.get(key));
+  }
+
+  @Test
+  public void testCanPutNullItemWithoutChangingSize() {
+    String key = getKey();
+    cache.put(key, null);
+
+    for (int i = 0; i < SIZE; i++) {
+      cache.put(getKey(), new Object());
+    }
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testReplacingNonNullItemWithNullItemDecreasesSize() {
+    String key = getKey();
+    cache.put(key, new Object());
+    cache.put(key, null);
+
+    for (int i = 0; i < SIZE; i++) {
+      cache.put(getKey(), new Object());
+    }
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testReplacingNullItemWIthNullItemIncreasesSize() {
+    String key = getKey();
+    cache.put(key, null);
+    cache.put(key, new Object());
+
+    for (int i = 0; i < SIZE; i++) {
+      cache.put(getKey(), new Object());
+    }
+
+    verify(listener).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testReplacingNonNullItemWithNonNullItemUpdatesSize() {
+    String key = getKey();
+    cache.put(key, new Object());
+    cache.put(key, new Object());
+
+    for (int i = 0; i < SIZE; i++) {
+      cache.put(getKey(), new Object());
+    }
+
+    verify(listener).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testCacheContainsAddedBitmap() {
+    final String key = getKey();
+    cache.put(key, new Object());
+    assertTrue(cache.contains(key));
+  }
+
+  @Test
+  public void testEmptyCacheDoesNotContainKey() {
+    assertFalse(cache.contains(getKey()));
+  }
+
+  @Test
+  public void testItIsSizeLimited() {
+    for (int i = 0; i < SIZE; i++) {
+      cache.put(getKey(), new Object());
+    }
+    verify(listener, never()).onItemRemoved(anyObject());
+    cache.put(getKey(), new Object());
+    verify(listener).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testLeastRecentlyAddKeyEvictedFirstIfGetsAreEqual() {
+    Object first = new Object();
+    cache.put(getKey(), first);
+    cache.put(getKey(), new Object());
+    cache.put(getKey(), new Object());
+
+    verify(listener).onItemRemoved(eq(first));
+    verify(listener, times(1)).onItemRemoved(any(Object.class));
+  }
+
+  @Test
+  public void testLeastRecentlyUsedKeyEvictedFirst() {
+    String mostRecentlyUsedKey = getKey();
+    Object mostRecentlyUsedObject = new Object();
+    String leastRecentlyUsedKey = getKey();
+    Object leastRecentlyUsedObject = new Object();
+
+    cache.put(mostRecentlyUsedKey, mostRecentlyUsedObject);
+    cache.put(leastRecentlyUsedKey, leastRecentlyUsedObject);
+
+    cache.get(mostRecentlyUsedKey);
+    cache.put(getKey(), new Object());
+
+    verify(listener).onItemRemoved(eq(leastRecentlyUsedObject));
+    verify(listener, times(1)).onItemRemoved(any(Object.class));
+  }
+
+  @Test
+  public void testItemLargerThanCacheIsImmediatelyEvicted() {
+    Object tooLarge = new Object();
+    when(listener.getSize(eq(tooLarge))).thenReturn(SIZE + 1);
+    cache.put(getKey(), tooLarge);
+
+    verify(listener).onItemRemoved(eq(tooLarge));
+  }
+
+  @Test
+  public void testItemLargerThanCacheDoesNotCauseAdditionalEvictions() {
+    cache.put(getKey(), new Object());
+
+    Object tooLarge = new Object();
+    when(listener.getSize(eq(tooLarge))).thenReturn(SIZE + 1);
+
+    cache.put(getKey(), tooLarge);
+
+    verify(listener, times(1)).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testClearMemoryRemovesAllItems() {
+    String first = getKey();
+    String second = getKey();
+    cache.put(first, new Object());
+    cache.put(second, new Object());
+
+    cache.clearMemory();
+
+    assertFalse(cache.contains(first));
+    assertFalse(cache.contains(second));
+  }
+
+  @Test
+  public void testCanPutSameItemMultipleTimes() {
+    String key = getKey();
+    Object value = new Object();
+    for (int i = 0; i < SIZE * 2; i++) {
+      cache.put(key, value);
+    }
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testCanIncreaseSizeDynamically() {
+    int sizeMultiplier = 2;
+    cache.setSizeMultiplier(sizeMultiplier);
+    for (int i = 0; i < SIZE * sizeMultiplier; i++) {
+      cache.put(getKey(), new Object());
+    }
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testCanDecreaseSizeDynamically() {
+    for (int i = 0; i < SIZE; i++) {
+      cache.put(getKey(), new Object());
+    }
+    verify(listener, never()).onItemRemoved(anyObject());
+
+    cache.setSizeMultiplier(0.5f);
+
+    verify(listener).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testCanResetSizeDynamically() {
+    int sizeMultiplier = 2;
+    cache.setSizeMultiplier(sizeMultiplier);
+    for (int i = 0; i < SIZE * sizeMultiplier; i++) {
+      cache.put(getKey(), new Object());
+    }
+
+    cache.setSizeMultiplier(1);
+
+    verify(listener, times(sizeMultiplier)).onItemRemoved(anyObject());
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfMultiplierLessThanZero() {
+    cache.setSizeMultiplier(-1);
+  }
+
+  @Test
+  public void testCanHandleZeroAsMultiplier() {
+    for (int i = 0; i < SIZE; i++) {
+      cache.put(getKey(), new Object());
+    }
+    cache.setSizeMultiplier(0);
+
+    verify(listener, times(SIZE)).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testCanRemoveKeys() {
+    String key = getKey();
+    Object value = new Object();
+    cache.put(key, value);
+    cache.remove(key);
+
+    assertNull(cache.get(key));
+    assertFalse(cache.contains(key));
+  }
+
+  @Test
+  public void testDecreasesSizeWhenRemovesKey() {
+    String key = getKey();
+    Object value = new Object();
+    cache.put(key, value);
+    for (int i = 0; i < SIZE - 1; i++) {
+      cache.put(key, value);
+    }
+    cache.remove(key);
+    cache.put(key, value);
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testDoesNotCallListenerWhenRemovesKey() {
+    String key = getKey();
+    cache.put(key, new Object());
+    cache.remove(key);
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void testGetMaxSizeReturnsCurrentMaxSizeOfCache() {
+    assertEquals(SIZE, cache.getMaxSize());
+  }
+
+  @Test
+  public void testGetMaxSizeChangesIfMaxSizeChanges() {
+    int multiplier = 2;
+    cache.setSizeMultiplier(multiplier);
+
+    assertEquals(SIZE * multiplier, cache.getMaxSize());
+  }
+
+  @Test
+  public void getCurrentSizeReturnsZeroForEmptyCache() {
+    assertEquals(0, cache.getCurrentSize());
+  }
+
+  @Test
+  public void testGetCurrentSizeIncreasesAsSizeIncreases() {
+    cache.put(getKey(), new Object());
+    assertEquals(1, cache.getCurrentSize());
+    cache.put(getKey(), new Object());
+    assertEquals(2, cache.getCurrentSize());
+  }
+
+  @Test
+  public void testGetCurrentSizeDoesNotChangeWhenSizeMultiplierChangesIfNoItemsAreEvicted() {
+    cache.put(getKey(), new Object());
+    assertEquals(1, cache.getCurrentSize());
+    cache.setSizeMultiplier(2);
+    assertEquals(1, cache.getCurrentSize());
+  }
+
+  @Test
+  public void testGetCurrentSizeChangesIfItemsAreEvictedWhenSizeMultiplierChanges() {
+    for (int i = 0; i < SIZE; i++) {
+      cache.put(getKey(), new Object());
+    }
+    assertEquals(SIZE, cache.getCurrentSize());
+    cache.setSizeMultiplier(0.5f);
+    assertEquals(SIZE / 2, cache.getCurrentSize());
+  }
+
+  private String getKey() {
+    currentKey += "1";
+    return currentKey;
+  }
+
+  private interface CacheListener {
+    public void onItemRemoved(Object item);
+
+    public int getSize(Object item);
+  }
+
+  private static class TestLruCache extends LruCache<String, Object> {
+    private final CacheListener listener;
+
+    public TestLruCache(int size, CacheListener listener) {
+      super(size);
+      this.listener = listener;
+    }
+
+    @Override
+    protected void onItemEvicted(String key, Object item) {
+      listener.onItemRemoved(item);
+    }
+
+    @Override
+    protected int getSize(Object item) {
+      return listener.getSize(item);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
new file mode 100644
index 000000000..4944d2564
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -0,0 +1,119 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.ComponentCallbacks2;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.Resource;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.security.MessageDigest;
+
+@RunWith(JUnit4.class)
+public class LruResourceCacheTest {
+  private static class TrimClearMemoryCacheHarness {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource first = mock(Resource.class);
+    Resource second = mock(Resource.class);
+
+    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    public TrimClearMemoryCacheHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      resourceCache.put(new MockKey(), first);
+      resourceCache.put(new MockKey(), second);
+      resourceCache.setResourceRemovedListener(listener);
+    }
+  }
+
+  @Test
+  public void testTrimMemoryBackground() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+
+    verify(harness.listener).onResourceRemoved(eq(harness.first));
+    verify(harness.listener).onResourceRemoved(eq(harness.second));
+  }
+
+  @Test
+  public void testTrimMemoryModerate() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryUiHidden() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource resource = mock(Resource.class);
+    when(resource.getSize()).thenReturn(200);
+
+    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    resourceCache.setResourceRemovedListener(listener);
+    resourceCache.put(new MockKey(), resource);
+
+    verify(listener).onResourceRemoved(eq(resource));
+  }
+
+  @Test
+  public void testSizeIsBasedOnResource() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource first = getResource(50);
+    MockKey firstKey = new MockKey();
+    resourceCache.put(firstKey, first);
+    Resource second = getResource(50);
+    MockKey secondKey = new MockKey();
+    resourceCache.put(secondKey, second);
+
+    assertTrue(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+
+    Resource third = getResource(50);
+    MockKey thirdKey = new MockKey();
+    resourceCache.put(thirdKey, third);
+
+    assertFalse(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+    assertTrue(resourceCache.contains(thirdKey));
+  }
+
+  private Resource getResource(int size) {
+    Resource resource = mock(Resource.class);
+    when(resource.getSize()).thenReturn(size);
+    return resource;
+  }
+
+  private static class MockKey implements Key {
+    @Override
+    public void updateDiskCacheKey(MessageDigest messageDigest) {
+      messageDigest.update(toString().getBytes(CHARSET));
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
new file mode 100644
index 000000000..d22bf9fa9
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -0,0 +1,187 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.Range;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.os.Build;
+
+import com.bumptech.glide.tests.Util;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowActivityManager;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class MemorySizeCalculatorTest {
+  private MemorySizeHarness harness;
+  private int initialSdkVersion;
+
+  @Before
+  public void setUp() {
+    initialSdkVersion = Build.VERSION.SDK_INT;
+    harness = new MemorySizeHarness();
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
+  }
+
+  @Test
+  public void testDefaultMemoryCacheSizeIsTwiceScreenSize() {
+    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());
+
+    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
+
+    assertThat(memoryCacheSize).isEqualTo(harness.getScreenSize() * harness.memoryCacheScreens);
+  }
+
+  @Test
+  public void testCanSetCustomMemoryCacheSize() {
+    harness.memoryCacheScreens = 9.5f;
+    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());
+
+    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
+
+    assertThat(memoryCacheSize).isEqualTo(harness.getScreenSize() * harness.memoryCacheScreens);
+  }
+
+  @Test
+  public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
+    final int memoryClassBytes =
+        Math.round(harness.getScreenSize() * harness.memoryCacheScreens * harness.sizeMultiplier);
+
+    Shadows.shadowOf(harness.activityManager).setMemoryClass(memoryClassBytes / (1024 * 1024));
+
+    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
+
+    assertThat((float) memoryCacheSize)
+        .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
+  }
+
+  @Test
+  public void testDefaultBitmapPoolSize() {
+    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());
+
+    float bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
+
+    assertThat(bitmapPoolSize).isEqualTo(harness.getScreenSize() * harness.bitmapPoolScreens);
+  }
+
+  @Test
+  public void testCanSetCustomBitmapPoolSize() {
+    harness.bitmapPoolScreens = 2f;
+    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());
+
+    float bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
+
+    assertThat(bitmapPoolSize).isEqualTo(harness.getScreenSize() * harness.bitmapPoolScreens);
+  }
+
+  @Test
+  public void testDefaultBitmapPoolSizeIsLimitedByMemoryClass() {
+    final int memoryClassBytes =
+        Math.round(harness.getScreenSize() * harness.bitmapPoolScreens * harness.sizeMultiplier);
+
+    Shadows.shadowOf(harness.activityManager).setMemoryClass(memoryClassBytes / (1024 * 1024));
+
+    int bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
+
+    assertThat((float) bitmapPoolSize)
+        .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
+  }
+
+  @Test
+  public void testCumulativePoolAndMemoryCacheSizeAreLimitedByMemoryClass() {
+    final int memoryClassBytes = Math.round(
+        harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens)
+            * harness.sizeMultiplier);
+    Shadows.shadowOf(harness.activityManager).setMemoryClass(memoryClassBytes / (1024 * 1024));
+
+    int memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
+    int bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
+
+    assertThat((float) memoryCacheSize + bitmapPoolSize)
+        .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
+  }
+
+  @Test
+  public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices() {
+    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass() / 2);
+    final int normalMemoryCacheSize = harness.getCalculator().getMemoryCacheSize();
+    final int normalBitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
+
+    Util.setSdkVersionInt(10);
+
+    // Keep the bitmap pool size constant, even though normally it would change.
+    harness.byteArrayPoolSizeBytes *= 2;
+    final int smallMemoryCacheSize = harness.getCalculator().getMemoryCacheSize();
+    final int smallBitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
+
+    assertThat(smallMemoryCacheSize).isLessThan(normalMemoryCacheSize);
+    assertThat(smallBitmapPoolSize).isLessThan(normalBitmapPoolSize);
+  }
+
+  @Test
+  public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
+    ShadowActivityManager activityManager = Shadows.shadowOf(harness.activityManager);
+    activityManager.setMemoryClass(getLargeEnoughMemoryClass());
+
+    Util.setSdkVersionInt(10);
+
+    int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
+    assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
+  }
+
+  private int getLargeEnoughMemoryClass() {
+    float totalScreenBytes =
+        harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens);
+    float totalBytes = totalScreenBytes + harness.byteArrayPoolSizeBytes;
+    // Memory class is in mb, not bytes!
+    float totalMb = totalBytes / (1024 * 1024);
+    float memoryClassMb = totalMb / harness.sizeMultiplier;
+    return (int) Math.ceil(memoryClassMb);
+  }
+
+  private static class MemorySizeHarness {
+    int pixelSize = 500;
+    int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
+    float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;
+    float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;
+    float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
+    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.ARRAY_POOL_SIZE_BYTES;
+    ActivityManager activityManager =
+        (ActivityManager) RuntimeEnvironment.application.getSystemService(Context.ACTIVITY_SERVICE);
+    MemorySizeCalculator.ScreenDimensions screenDimensions =
+        mock(MemorySizeCalculator.ScreenDimensions.class);
+
+    public MemorySizeCalculator getCalculator() {
+      when(screenDimensions.getWidthPixels()).thenReturn(pixelSize);
+      when(screenDimensions.getHeightPixels()).thenReturn(pixelSize);
+      return new MemorySizeCalculator.Builder(RuntimeEnvironment.application)
+          .setMemoryCacheScreens(memoryCacheScreens)
+          .setBitmapPoolScreens(bitmapPoolScreens)
+          .setMaxSizeMultiplier(sizeMultiplier)
+          .setActivityManager(activityManager)
+          .setScreenDimensions(screenDimensions)
+          .setArrayPoolSize(byteArrayPoolSizeBytes)
+          .build();
+    }
+
+    public int getScreenSize() {
+      return pixelSize * pixelSize * bytesPerPixel;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
new file mode 100644
index 000000000..738bcd951
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
@@ -0,0 +1,59 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static org.junit.Assert.assertTrue;
+
+import com.bumptech.glide.load.Key;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.security.MessageDigest;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class SafeKeyGeneratorTest {
+  private SafeKeyGenerator keyGenerator;
+  private int nextId;
+
+  @Before
+  public void setUp() throws Exception {
+    nextId = 0;
+    keyGenerator = new SafeKeyGenerator();
+  }
+
+  @Test
+  public void testKeysAreValidForDiskCache() {
+    final Pattern diskCacheRegex = Pattern.compile("[a-z0-9_-]{64}");
+    for (int i = 0; i < 1000; i++) {
+      String key = getRandomKeyFromGenerator();
+      Matcher matcher = diskCacheRegex.matcher(key);
+      assertTrue(key, matcher.matches());
+    }
+  }
+
+  private String getRandomKeyFromGenerator() {
+    return keyGenerator.getSafeKey(new MockKey(getNextId()));
+  }
+
+  private String getNextId() {
+    return String.valueOf(nextId++);
+  }
+
+  private static class MockKey implements Key {
+    private String id;
+
+    public MockKey(String id) {
+      this.id = id;
+    }
+
+    @Override
+    public void updateDiskCacheKey(MessageDigest messageDigest) {
+      messageDigest.update(id.getBytes(CHARSET));
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
new file mode 100644
index 000000000..1a6f5d9cd
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -0,0 +1,64 @@
+package com.bumptech.glide.load.engine.executor;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GlideExecutorTest {
+
+  @Test
+  public void testLoadsAreExecutedInOrder() throws InterruptedException {
+    final List<Integer> resultPriorities = Collections.synchronizedList(new ArrayList<Integer>());
+    GlideExecutor executor = new GlideExecutor(1);
+    for (int i = 5; i > 0; i--) {
+      executor.execute(new MockRunnable(i, new MockRunnable.OnRun() {
+        @Override
+        public void onRun(int priority) {
+          resultPriorities.add(priority);
+        }
+      }));
+    }
+
+    executor.shutdown();
+    executor.awaitTermination(500, TimeUnit.MILLISECONDS);
+
+    // Since no jobs are queued, the first item added will be run immediately, regardless of
+    // priority.
+    assertThat(resultPriorities).containsExactly(5, 1, 2, 3, 4).inOrder();
+  }
+
+  private static class MockRunnable implements Runnable,
+      Comparable<MockRunnable> {
+    private final int priority;
+    private final OnRun onRun;
+
+    @Override
+    public int compareTo(MockRunnable another) {
+      return priority - another.priority;
+    }
+
+    public interface OnRun {
+      void onRun(int priority);
+    }
+
+    public MockRunnable(int priority, OnRun onRun) {
+      this.priority = priority;
+      this.onRun = onRun;
+    }
+
+    @Override
+    public void run() {
+      onRun.onRun(priority);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
new file mode 100644
index 000000000..a5f045618
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -0,0 +1,334 @@
+package com.bumptech.glide.load.engine.prefill;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.os.Handler;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.tests.Util.CreateBitmap;
+import com.bumptech.glide.util.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapPreFillRunnerTest {
+  @Mock BitmapPreFillRunner.Clock clock;
+  @Mock BitmapPool pool;
+  @Mock MemoryCache cache;
+  @Mock Handler mainHandler;
+  private List<Bitmap> addedBitmaps = new ArrayList<>();
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    doAnswer(new AddBitmapPoolAnswer(addedBitmaps)).when(pool).put(any(Bitmap.class));
+    when(pool.getDirty(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new CreateBitmap());
+    when(cache.put(any(Key.class), any(Resource.class)))
+        .thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));
+  }
+
+  private BitmapPreFillRunner getHandler(Map<PreFillType, Integer> allocationOrder) {
+    return new BitmapPreFillRunner(pool, cache, new PreFillQueue(allocationOrder), clock,
+        mainHandler);
+  }
+
+  @Test
+  public void testAllocatesABitmapPerSizeInAllocationOrder() {
+    PreFillType size = new PreFillType.Builder(100).setConfig(Bitmap.Config.ARGB_8888).build();
+    final int toAdd = 3;
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, toAdd);
+    BitmapPreFillRunner handler = getHandler(allocationOrder);
+    handler.run();
+
+    Bitmap expected = Bitmap.createBitmap(size.getWidth(), size.getHeight(), size.getConfig());
+    // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
+    // assertThat(addedBitmaps).containsExactly(expected, expected, expected);
+  }
+
+  @Test
+  public void testAllocatesBitmapsInOrderGivenByAllocationOrder() {
+    PreFillType smallWidth =
+        new PreFillType.Builder(50, 100).setConfig(Bitmap.Config.ARGB_8888).build();
+    PreFillType smallHeight =
+        new PreFillType.Builder(100, 50).setConfig(Bitmap.Config.RGB_565).build();
+
+    PreFillType[] expectedOrder =
+        new PreFillType[] { smallWidth, smallHeight, smallWidth, smallHeight, };
+
+    HashMap<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(smallWidth, 2);
+    allocationOrder.put(smallHeight, 2);
+    BitmapPreFillRunner handler = getHandler(allocationOrder);
+    handler.run();
+
+    Bitmap[] expectedBitmaps = new Bitmap[expectedOrder.length];
+    for (int i = 0; i < expectedBitmaps.length; i++) {
+      PreFillType current = expectedOrder[i];
+      expectedBitmaps[i] =
+          Bitmap.createBitmap(current.getWidth(), current.getHeight(), current.getConfig());
+    }
+
+    Bitmap current = addedBitmaps.get(0);
+    for (int i = 1; i < addedBitmaps.size(); i++) {
+      assertNotEquals(current, addedBitmaps.get(i));
+      current = addedBitmaps.get(i);
+    }
+
+    assertThat(addedBitmaps).hasSize(4);
+  }
+
+  @Test
+  public void testStopsAllocatingBitmapsUntilNextIdleCallIfAllocationsTakeLongerThanLimit() {
+    PreFillType size = new PreFillType.Builder(1).setConfig(Bitmap.Config.ARGB_8888).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, 3);
+    when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+    BitmapPreFillRunner handler = getHandler(allocationOrder);
+    handler.run();
+
+    assertThat(addedBitmaps).hasSize(1);
+
+    handler.run();
+
+    assertThat(addedBitmaps).hasSize(3);
+  }
+
+  @Test
+  public void testPreFillHandlerDoesNotPostIfHasNoBitmapsToAllocate() {
+    BitmapPreFillRunner handler = getHandler(new HashMap<PreFillType, Integer>());
+    handler.run();
+    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyInt());
+  }
+
+  @Test
+  public void testPreFillHandlerPostsIfHasBitmapsToAllocateAfterRunning() {
+    PreFillType size = new PreFillType.Builder(1).setConfig(Bitmap.Config.ARGB_8888).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, 2);
+    BitmapPreFillRunner handler = getHandler(allocationOrder);
+    when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+
+    handler.run();
+    verify(mainHandler).postDelayed(eq(handler), anyLong());
+  }
+
+  @Test
+  public void testPreFillHandlerPostsWithBackoffIfHasBitmapsToAllocateAfterRunning() {
+    PreFillType size = new PreFillType.Builder(1).setConfig(Bitmap.Config.ARGB_8888).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, 100);
+
+    BitmapPreFillRunner handler = getHandler(allocationOrder);
+    when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+
+    handler.run();
+    verify(mainHandler).postDelayed(eq(handler), eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS));
+
+    when(clock.now()).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS).thenReturn(
+        BitmapPreFillRunner.MAX_DURATION_MS
+            + BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO);
+
+    handler.run();
+
+    verify(mainHandler).postDelayed(eq(handler),
+        eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO));
+
+    when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+    handler.run();
+    when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+    handler.run();
+    when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+    handler.run();
+    when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+    handler.run();
+
+    verify(mainHandler, atLeastOnce())
+        .postDelayed(eq(handler), eq(BitmapPreFillRunner.MAX_BACKOFF_MS));
+  }
+
+  @Test
+  public void testPreFillHandlerDoesNotPostIfHasBitmapsButIsCancelled() {
+    PreFillType size = new PreFillType.Builder(1).setConfig(Bitmap.Config.ARGB_8888).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, 2);
+
+    BitmapPreFillRunner handler = getHandler(allocationOrder);
+    when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+    handler.cancel();
+    handler.run();
+
+    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyLong());
+  }
+
+  @Test
+  public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));
+
+    PreFillType size =
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+            .build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, 1);
+
+    getHandler(allocationOrder).run();
+
+    verify(cache).put(any(Key.class), any(Resource.class));
+    verify(pool, never()).put(any(Bitmap.class));
+    // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
+    // assertThat(addedBitmaps).containsExactly(bitmap);
+  }
+
+  @Test
+  public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(cache.getMaxSize()).thenReturn(0);
+
+    PreFillType size =
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+            .build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, 1);
+
+    getHandler(allocationOrder).run();
+
+    verify(cache, never()).put(any(Key.class), any(Resource.class));
+    // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
+    // verify(pool).put(eq(bitmap));
+    // assertThat(addedBitmaps).containsExactly(bitmap);
+  }
+
+  @Test
+  public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);
+
+    PreFillType size =
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+            .build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, 1);
+
+    getHandler(allocationOrder).run();
+
+    verify(cache, never()).put(any(Key.class), any(Resource.class));
+    // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
+    //verify(pool).put(eq(bitmap));
+    //assertThat(addedBitmaps).containsExactly(bitmap);
+  }
+
+  @Test
+  public void testDoesAGetFromPoolBeforeAddingForEachSize() {
+    Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+    PreFillType firstSize =
+        new PreFillType.Builder(first.getWidth(), first.getHeight()).setConfig(first.getConfig())
+            .build();
+
+    Bitmap second = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
+    PreFillType secondSize =
+        new PreFillType.Builder(second.getWidth(), second.getHeight()).setConfig(second.getConfig())
+            .build();
+
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(firstSize, 1);
+    allocationOrder.put(secondSize, 1);
+
+    getHandler(allocationOrder).run();
+
+    InOrder firstOrder = inOrder(pool);
+    firstOrder.verify(pool).getDirty(eq(first.getWidth()), eq(first.getHeight()),
+        eq(first.getConfig()));
+    // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
+    // firstOrder.verify(pool).put(eq(first));
+
+    InOrder secondOrder = inOrder(pool);
+    secondOrder.verify(pool)
+        .getDirty(eq(second.getWidth()), eq(second.getHeight()), eq(second.getConfig()));
+    // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
+    // secondOrder.verify(pool).put(eq(second));
+  }
+
+  @Test
+  public void testDoesNotGetMoreThanOncePerSize() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+    PreFillType size =
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+            .build();
+
+    final int numBitmaps = 5;
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(size, numBitmaps);
+
+    getHandler(allocationOrder).run();
+
+    InOrder order = inOrder(pool);
+    order.verify(pool).getDirty(eq(bitmap.getWidth()), eq(bitmap.getHeight()),
+        eq(bitmap.getConfig()));
+    // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
+    // order.verify(pool, times(numBitmaps)).put(eq(bitmap));
+  }
+
+  private static class AddBitmapPoolAnswer implements Answer<Void> {
+    private List<Bitmap> bitmaps;
+
+    public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
+      this.bitmaps = bitmaps;
+    }
+
+    @Override
+    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+      Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
+      bitmaps.add(bitmap);
+      return null;
+    }
+  }
+
+  private static class AddBitmapCacheAnswer implements Answer<Resource<?>> {
+    private List<Bitmap> bitmaps;
+
+    public AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
+      this.bitmaps = bitmaps;
+    }
+
+    @Override
+    public Resource<?> answer(InvocationOnMock invocationOnMock) throws Throwable {
+      BitmapResource resource = (BitmapResource) invocationOnMock.getArguments()[1];
+      bitmaps.add(resource.get());
+      return null;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
new file mode 100644
index 000000000..a308dae93
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -0,0 +1,289 @@
+package com.bumptech.glide.load.engine.prefill;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.Range;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.tests.Util.CreateBitmap;
+import com.bumptech.glide.util.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapPreFillerTest {
+  private static final int DEFAULT_BITMAP_WIDTH = 100;
+  private static final int DEFAULT_BITMAP_HEIGHT = 50;
+
+  private static final int BITMAPS_IN_POOL = 10;
+  private static final int BITMAPS_IN_CACHE = 10;
+
+  private final Bitmap.Config defaultBitmapConfig = PreFillType.DEFAULT_CONFIG;
+  private final Bitmap defaultBitmap =
+      Bitmap.createBitmap(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT, defaultBitmapConfig);
+  private final int defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
+  private final int poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
+  private final int cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
+
+  @Mock BitmapPool pool;
+  @Mock MemoryCache cache;
+  private BitmapPreFiller bitmapPreFiller;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(pool.getMaxSize()).thenReturn(poolSize);
+    when(pool.getDirty(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new CreateBitmap());
+    when(cache.getMaxSize()).thenReturn(cacheSize);
+
+    bitmapPreFiller = new BitmapPreFiller(cache, pool, DecodeFormat.DEFAULT);
+  }
+
+  @Test
+  public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build() });
+
+    assertEquals(BITMAPS_IN_POOL + BITMAPS_IN_CACHE, allocationOrder.getSize());
+  }
+
+  @Test
+  public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
+    PreFillType[] sizes = new PreFillType[] {
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build(),
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build(),
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+            .setConfig(defaultBitmapConfig).build(), };
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(sizes);
+
+    int byteSize = 0;
+    while (!allocationOrder.isEmpty()) {
+      PreFillType current = allocationOrder.remove();
+      byteSize +=
+          Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
+    }
+
+    int expectedSize = 0;
+    int maxSize = poolSize + cacheSize;
+    for (PreFillType current : sizes) {
+      int currentSize =
+          Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
+      expectedSize += currentSize * (maxSize / (3 * currentSize));
+    }
+
+    assertEquals(expectedSize, byteSize);
+  }
+
+  @Test
+  public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build(),
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build(),
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+            .setConfig(defaultBitmapConfig).build() });
+
+    int byteSize = 0;
+    while (!allocationOrder.isEmpty()) {
+      PreFillType current = allocationOrder.remove();
+      byteSize +=
+          Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
+    }
+
+    assertThat(byteSize).isIn(Range.atMost(poolSize + cacheSize));
+  }
+
+  @Test
+  public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).setWeight(4).build(),
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build(),
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
+            .setConfig(defaultBitmapConfig).setWeight(3).build() });
+
+    int byteSize = 0;
+    while (!allocationOrder.isEmpty()) {
+      PreFillType current = allocationOrder.remove();
+      byteSize +=
+          Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
+    }
+
+    assertThat(byteSize).isIn(Range.atMost(poolSize + cacheSize));
+  }
+
+  @Test
+  public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build() });
+
+    while (!allocationOrder.isEmpty()) {
+      PreFillType size = allocationOrder.remove();
+      assertEquals(DEFAULT_BITMAP_WIDTH, size.getWidth());
+      assertEquals(DEFAULT_BITMAP_HEIGHT, size.getHeight());
+      assertEquals(defaultBitmapConfig, size.getConfig());
+    }
+  }
+
+  @Test
+  public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
+    PreFillType smallWidth =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build();
+    PreFillType smallHeight =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+            .setConfig(defaultBitmapConfig).build();
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+
+    int numSmallWidth = 0, numSmallHeight = 0;
+    while (!allocationOrder.isEmpty()) {
+      PreFillType current = allocationOrder.remove();
+      if (smallWidth.equals(current)) {
+        numSmallWidth++;
+      } else if (smallHeight.equals(current)) {
+        numSmallHeight++;
+      } else {
+        fail("Unexpected size, size: " + current);
+      }
+    }
+
+    assertEquals(numSmallWidth, numSmallHeight);
+  }
+
+  @Test
+  public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualWeights() {
+    PreFillType smallWidth =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build();
+    PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+        .setConfig(defaultBitmapConfig).build();
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, normal });
+
+    int numSmallWidth = 0, numNormal = 0;
+    while (!allocationOrder.isEmpty()) {
+      PreFillType current = allocationOrder.remove();
+      if (smallWidth.equals(current)) {
+        numSmallWidth++;
+      } else if (normal.equals(current)) {
+        numNormal++;
+      } else {
+        fail("Unexpected size, size: " + current);
+      }
+    }
+
+    assertEquals(2 * numNormal, numSmallWidth);
+  }
+
+  @Test
+  public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequalWeights() {
+    PreFillType doubleWeight =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).setWeight(2).build();
+    PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+        .setConfig(defaultBitmapConfig).build();
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { doubleWeight, normal });
+
+    int numDoubleWeight = 0, numNormal = 0;
+    while (!allocationOrder.isEmpty()) {
+      PreFillType current = allocationOrder.remove();
+      if (doubleWeight.equals(current)) {
+        numDoubleWeight++;
+      } else if (normal.equals(current)) {
+        numNormal++;
+      } else {
+        fail("Unexpected size, size: " + current);
+      }
+    }
+
+    assertEquals(2 * numNormal, numDoubleWeight);
+  }
+
+  @Test
+  public void testAllocationOrderRoundRobinsDifferentSizes() {
+    when(pool.getMaxSize()).thenReturn(defaultBitmapSize);
+    when(cache.getMaxSize()).thenReturn(defaultBitmapSize);
+    PreFillType smallWidth =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig).build();
+    PreFillType smallHeight =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+            .setConfig(defaultBitmapConfig).build();
+
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+
+    List<PreFillType> attributes = new ArrayList<>();
+    while (!allocationOrder.isEmpty()) {
+      attributes.add(allocationOrder.remove());
+    }
+
+    // Either width, height, width, height or height, width, height, width.
+    try {
+      assertThat(attributes).containsExactly(smallWidth, smallHeight, smallWidth, smallHeight)
+          .inOrder();
+    } catch (AssertionError e) {
+      assertThat(attributes).containsExactly(smallHeight, smallWidth, smallHeight, smallWidth)
+          .inOrder();
+    }
+  }
+
+  @Test
+  public void testSetsConfigOnBuildersToDefaultIfNotSet() {
+    PreFillType.Builder builder = mock(PreFillType.Builder.class);
+    when(builder.build())
+        .thenReturn(new PreFillType.Builder(100).setConfig(Bitmap.Config.RGB_565).build());
+
+    bitmapPreFiller.preFill(builder);
+
+    InOrder order = inOrder(builder);
+    order.verify(builder).setConfig(DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
+        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
+    order.verify(builder).build();
+  }
+
+  @Test
+  public void testDoesNotSetConfigOnBuildersIfConfigIsAlreadySet() {
+    PreFillType.Builder builder = mock(PreFillType.Builder.class);
+
+    when(builder.getConfig()).thenReturn(Bitmap.Config.ARGB_4444);
+    when(builder.build())
+        .thenReturn(new PreFillType.Builder(100).setConfig(Bitmap.Config.ARGB_4444).build());
+    bitmapPreFiller.preFill(builder);
+
+    verify(builder, never()).setConfig(any(Bitmap.Config.class));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
new file mode 100644
index 000000000..26f2469a3
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
@@ -0,0 +1,76 @@
+package com.bumptech.glide.load.engine.prefill;
+
+import static org.junit.Assert.assertEquals;
+
+import com.google.common.testing.EqualsTester;
+
+import android.graphics.Bitmap;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class PreFillTypeTest {
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfSizeIsZero() {
+    new PreFillType.Builder(0);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfWidthIsZero() {
+    new PreFillType.Builder(0, 100);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfHeightIsZero() {
+    new PreFillType.Builder(100, 0);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfWeightIsZero() {
+    new PreFillType.Builder(100).setWeight(0);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testConstructorThrowsIfConfigIsNull() {
+    new PreFillType(100, 100, null, 1);
+  }
+
+  @Test
+  public void testGetWidthReturnsGivenWidth() {
+    int width = 500;
+    assertEquals(width, new PreFillType(width, 100, Bitmap.Config.ARGB_4444, 1).getWidth());
+  }
+
+  @Test
+  public void testGetHeightReturnsGivenHeight() {
+    int height = 123;
+    assertEquals(height, new PreFillType(100, height, Bitmap.Config.ARGB_4444, 1).getHeight());
+  }
+
+  @Test
+  public void testGetConfigReturnsGivenConfig() {
+    Bitmap.Config config = Bitmap.Config.ARGB_8888;
+    assertEquals(config, new PreFillType(100, 100, config, 1).getConfig());
+  }
+
+  @Test
+  public void testGetWeightReturnsGivenWeight() {
+    int weight = 400;
+    assertEquals(weight, new PreFillType(100, 100, Bitmap.Config.ARGB_4444, weight).getWeight());
+  }
+
+  @Test
+  public void testEquality() {
+    new EqualsTester().addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1),
+        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1))
+        .addEqualityGroup(new PreFillType(200, 100, Bitmap.Config.ARGB_4444, 1))
+        .addEqualityGroup(new PreFillType(100, 200, Bitmap.Config.ARGB_4444, 1))
+        .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_8888, 1))
+        .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 2)).testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
new file mode 100644
index 000000000..4df23384d
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
@@ -0,0 +1,47 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import android.content.res.AssetManager;
+import android.net.Uri;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class AssetUriLoaderTest {
+  private static final int IMAGE_SIDE = 10;
+
+  @Mock AssetUriLoader.AssetFetcherFactory<Object> factory;
+  @Mock DataFetcher<Object> fetcher;
+  private AssetUriLoader<Object> loader;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    loader = new AssetUriLoader<>(RuntimeEnvironment.application.getAssets(), factory);
+  }
+
+  @Test
+  public void testHandlesAssetUris() {
+    Uri assetUri = Uri.parse("file:///android_asset/assetName");
+    when(factory.buildFetcher(any(AssetManager.class), eq("assetName"))).thenReturn(fetcher);
+    assertTrue(loader.handles(assetUri));
+    assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,
+        new Options()).fetcher);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
new file mode 100644
index 000000000..580bc669d
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
@@ -0,0 +1,60 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import java.io.IOException;
+
+@RunWith(JUnit4.class)
+public class ByteArrayLoaderTest {
+
+  @Mock ByteArrayLoader.Converter<Object> converter;
+  @Mock DataFetcher.DataCallback<Object> callback;
+  private ByteArrayLoader<Object> loader;
+  private Options options;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    loader = new ByteArrayLoader<>(converter);
+    options = new Options();
+  }
+
+  @Test
+  public void testCanHandleByteArray() {
+    byte[] data = new byte[10];
+    DataFetcher<Object> fetcher = loader.buildLoadData(data, -1, -1, options).fetcher;
+    assertNotNull(fetcher);
+  }
+
+  @Test
+  public void testFetcherReturnsObjectReceivedFromConverter() throws IOException {
+    byte[] data = "fake".getBytes();
+    Object expected = new Object();
+    when(converter.convert(eq(data))).thenReturn(expected);
+
+    loader.buildLoadData(data, 10, 10, options).fetcher.loadData(Priority.HIGH, callback);
+    verify(callback).onDataReady(eq(expected));
+  }
+
+  @Test
+  public void testFetcherRetrunsDataClassFromConverter() {
+    when(converter.getDataClass()).thenReturn(Object.class);
+    assertEquals(Object.class,
+        loader.buildLoadData(new byte[10], 10, 10, options).fetcher.getDataClass());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
new file mode 100644
index 000000000..7593eaccb
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -0,0 +1,118 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
+import com.google.common.testing.EqualsTester;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GlideUrlTest {
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfGivenURLIsNull() {
+    new GlideUrl((URL) null);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfGivenStringUrlIsNull() {
+    new GlideUrl((String) null);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfGivenStringURLIsEmpty() {
+    new GlideUrl("");
+  }
+
+  @Test
+  public void testCanCompareGlideUrlsCreatedWithDifferentTypes() throws MalformedURLException {
+    String stringUrl = "http://www.google.com";
+    URL url = new URL(stringUrl);
+
+    assertEquals(new GlideUrl(stringUrl), new GlideUrl(url));
+  }
+
+  @Test
+  public void testCanCompareHashcodeOfGlideUrlsCreatedWithDifferentTypes()
+      throws MalformedURLException {
+    String stringUrl = "http://nytimes.com";
+    URL url = new URL(stringUrl);
+
+    assertEquals(new GlideUrl(stringUrl).hashCode(), new GlideUrl(url).hashCode());
+  }
+
+  @Test
+  public void testProducesEquivalentUrlFromString() throws MalformedURLException {
+    String stringUrl = "http://www.google.com";
+    GlideUrl glideUrl = new GlideUrl(stringUrl);
+
+    URL url = glideUrl.toURL();
+    assertEquals(stringUrl, url.toString());
+  }
+
+  @Test
+  public void testProducesEquivalentStringFromURL() throws MalformedURLException {
+    String expected = "http://www.washingtonpost.com";
+    URL url = new URL(expected);
+    GlideUrl glideUrl = new GlideUrl(url);
+
+    assertEquals(expected, glideUrl.toStringUrl());
+  }
+
+  @Test
+  public void testIssue133() throws MalformedURLException {
+    // u00e0=à
+    final String original = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
+        + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";
+
+    final String escaped = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
+        + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";
+
+    GlideUrl glideUrlFromString = new GlideUrl(original);
+    assertEquals(escaped, glideUrlFromString.toURL().toString());
+
+    GlideUrl glideUrlFromEscapedString = new GlideUrl(escaped);
+    assertEquals(escaped, glideUrlFromEscapedString.toURL().toString());
+
+    GlideUrl glideUrlFromUrl = new GlideUrl(new URL(original));
+    assertEquals(escaped, glideUrlFromUrl.toURL().toString());
+
+    GlideUrl glideUrlFromEscapedUrl = new GlideUrl(new URL(escaped));
+    assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());
+  }
+
+  @Test
+  public void testEquals() throws MalformedURLException {
+    Headers headers = mock(Headers.class);
+    Headers otherHeaders = mock(Headers.class);
+    String url = "http://www.google.com";
+    String otherUrl = "http://mail.google.com";
+    new EqualsTester()
+        .addEqualityGroup(
+            new GlideUrl(url),
+            new GlideUrl(url),
+            new GlideUrl(new URL(url)),
+            new GlideUrl(new URL(url))
+        )
+        .addEqualityGroup(
+            new GlideUrl(otherUrl),
+            new GlideUrl(new URL(otherUrl))
+        )
+        .addEqualityGroup(
+            new GlideUrl(url, headers),
+            new GlideUrl(new URL(url), headers)
+        )
+        .addEqualityGroup(
+            new GlideUrl(url, otherHeaders),
+            new GlideUrl(new URL(url), otherHeaders)
+        ).testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
new file mode 100644
index 000000000..8e0269c4e
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -0,0 +1,292 @@
+package com.bumptech.glide.load.model;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.google.common.testing.EqualsTester;
+
+import com.bumptech.glide.load.model.LazyHeaders.Builder;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Map;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class LazyHeadersTest {
+
+  @Test
+  public void testIncludesEagerHeaders() {
+    Map<String, String> headers = new Builder()
+        .addHeader("key", "value")
+        .build()
+        .getHeaders();
+    assertThat(headers).containsEntry("key", "value");
+  }
+
+  @Test
+  public void testIncludesLazyHeaders() {
+    LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+    when(factory.buildHeader()).thenReturn("value");
+    Map<String, String> headers = new Builder()
+        .addHeader("key", factory)
+        .build()
+        .getHeaders();
+
+    assertThat(headers).containsEntry("key", "value");
+  }
+
+  @Test
+  public void testMultipleEagerValuesAreSeparatedByCommas() {
+    Map<String, String> headers = new Builder()
+        .addHeader("key", "first")
+        .addHeader("key", "second")
+        .build()
+        .getHeaders();
+
+    assertThat(headers).containsEntry("key", "first,second");
+  }
+
+  @Test
+  public void testMultipleLazyValuesAreSeparatedByCommas() {
+    LazyHeaderFactory first = mock(LazyHeaderFactory.class);
+    when(first.buildHeader()).thenReturn("first");
+    LazyHeaderFactory second = mock(LazyHeaderFactory.class);
+    when(second.buildHeader()).thenReturn("second");
+
+    Map<String, String> headers = new Builder()
+        .addHeader("key", first)
+        .addHeader("key", second)
+        .build()
+        .getHeaders();
+    assertThat(headers).containsEntry("key", "first,second");
+  }
+
+  @Test
+  public void testMixedEagerAndLazyValuesAreIncluded() {
+    LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+    when(factory.buildHeader()).thenReturn("first");
+    Map<String, String> headers = new Builder()
+        .addHeader("key", factory)
+        .addHeader("key", "second")
+        .build()
+        .getHeaders();
+
+    assertThat(headers).containsEntry("key", "first,second");
+
+    headers = new Builder()
+        .addHeader("key", "second")
+        .addHeader("key", factory)
+        .build()
+        .getHeaders();
+
+    assertThat(headers).containsEntry("key", "second,first");
+  }
+
+  @Test
+  public void testCanAddMultipleKeys() {
+    LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+    when(factory.buildHeader()).thenReturn("lazy");
+    Map<String, String> headers = new Builder()
+        .addHeader("first", factory)
+        .addHeader("second", "eager")
+        .build()
+        .getHeaders();
+
+    assertThat(headers).containsEntry("first", "lazy");
+    assertThat(headers).containsEntry("second", "eager");
+  }
+
+  @Test
+  public void testUpdatingBuilderAfterBuildingDoesNotModifyOriginalHeaders() {
+    Builder builder = new Builder();
+    builder.addHeader("key", "firstValue");
+    builder.addHeader("otherKey", "otherValue");
+    LazyHeaders first = builder.build();
+
+    LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+    when(factory.buildHeader()).thenReturn("otherValue");
+    builder.addHeader("key", "secondValue");
+    builder.setHeader("otherKey", factory);
+    LazyHeaders second = builder.build();
+
+    assertThat(first.getHeaders()).isNotEqualTo(second.getHeaders());
+
+    assertThat(first.getHeaders()).containsEntry("key", "firstValue");
+    assertThat(first.getHeaders()).containsEntry("otherKey", "otherValue");
+
+    assertThat(second.getHeaders()).containsEntry("key", "firstValue,secondValue");
+    assertThat(second.getHeaders()).containsEntry("otherKey", "otherValue");
+  }
+
+  @Test
+  public void testSetHeaderReplacesExistingHeaders() {
+    Builder builder = new Builder();
+    builder.addHeader("key", "first")
+        .addHeader("key", "second")
+        .setHeader("key", "third");
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("key", "third");
+  }
+
+  @Test
+  public void testSetHeaderWithNullStringRemovesExistingHeader() {
+    Builder builder = new Builder();
+    builder.addHeader("key", "first")
+        .addHeader("key", "second")
+        .setHeader("key", (String) null);
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("key");
+  }
+
+  @Test
+  public void testSetHeaderWithNullLazyHeaderFactoryRemovesExistingHeader() {
+    Builder builder = new Builder();
+    builder.addHeader("key", "first")
+        .addHeader("key", "second")
+        .setHeader("key", (LazyHeaderFactory) null);
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("key");
+  }
+
+  @Test
+  public void testAddingEncodingHeaderReplacesDefaultThenAppends() {
+    Builder builder = new Builder();
+    builder.addHeader("Accept-Encoding", "false");
+
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("Accept-Encoding", "false");
+
+    builder.addHeader("Accept-Encoding", "true");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("Accept-Encoding", "false,true");
+  }
+
+  @Test
+  public void testRemovingAndAddingEncodingHeaderReplacesDefaultThenAppends() {
+    Builder builder = new Builder();
+    builder.setHeader("Accept-Encoding", (String) null);
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("Accept-Encoding");
+
+    builder.addHeader("Accept-Encoding", "false");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("Accept-Encoding", "false");
+
+    builder.addHeader("Accept-Encoding", "true");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("Accept-Encoding", "false,true");
+  }
+
+  @Test
+  public void testAddingUserAgentHeaderReplacesDefaultThenAppends() {
+    Builder builder = new Builder();
+    builder.addHeader("User-Agent", "false");
+
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("User-Agent", "false");
+
+    builder.addHeader("User-Agent", "true");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("User-Agent", "false,true");
+  }
+
+  @Test
+  public void testRemovingAndAddingUserAgentHeaderReplacesDefaultThenAppends() {
+    Builder builder = new Builder();
+    builder.setHeader("User-Agent", (String) null);
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("User-Agent");
+
+    builder.addHeader("User-Agent", "false");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("User-Agent", "false");
+
+    builder.addHeader("User-Agent", "true");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("User-Agent", "false,true");
+  }
+
+  @Test
+  public void testEquals() {
+    LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
+    LazyHeaderFactory secondLazyFactory = mock(LazyHeaderFactory.class);
+    new EqualsTester()
+        .addEqualityGroup(
+            new Builder().build(),
+            new Builder().build()
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", "value").build(),
+            new Builder().addHeader("key", "value").build()
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", "value").addHeader("key", "value").build()
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", firstLazyFactory).build(),
+            new Builder().addHeader("key", firstLazyFactory).build()
+        )
+        .addEqualityGroup(
+            new Builder()
+                .addHeader("key", firstLazyFactory)
+                .addHeader("key", firstLazyFactory)
+                .build()
+        )
+        .addEqualityGroup(
+            new Builder()
+                .addHeader("firstKey", "value")
+                .addHeader("secondKey", firstLazyFactory)
+                .build(),
+            new Builder()
+                .addHeader("secondKey", firstLazyFactory)
+                .addHeader("firstKey", "value")
+                .build()
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", "secondValue")
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("secondKey", "value")
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", secondLazyFactory)
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("secondKey", firstLazyFactory)
+        )
+        .addEqualityGroup(
+            new Builder()
+                .addHeader("firstKey", "firstValue")
+                .addHeader("secondKey", "secondValue")
+                .build(),
+            new Builder()
+                .addHeader("firstKey", "firstValue")
+                .addHeader("secondKey", "secondValue")
+                .build(),
+            new Builder()
+                .addHeader("secondKey", "secondValue")
+                .addHeader("firstKey", "firstValue")
+                .build()
+        )
+        .addEqualityGroup(
+            new Builder()
+                .addHeader("firstKey", firstLazyFactory)
+                .addHeader("secondKey", secondLazyFactory)
+                .build(),
+            new Builder()
+                .addHeader("firstKey", firstLazyFactory)
+                .addHeader("secondKey", secondLazyFactory)
+                .build(),
+            new Builder()
+                .addHeader("secondKey", secondLazyFactory)
+                .addHeader("firstKey", firstLazyFactory)
+                .build()
+        )
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
new file mode 100644
index 000000000..0d323dfbb
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+
+import com.google.common.testing.EqualsTester;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ModelCacheTest {
+
+  private ModelCache<Object, Object> cache;
+
+  @Before
+  public void setUp() {
+    cache = new ModelCache<>(10);
+  }
+
+  @Test
+  public void testModelKeyEquivalence() {
+    new EqualsTester().addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 200),
+        ModelCache.ModelKey.get(14f, 100, 200))
+        .addEqualityGroup(ModelCache.ModelKey.get(13f, 100, 200))
+        .addEqualityGroup(ModelCache.ModelKey.get(14f, 200, 200))
+        .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 300)).testEquals();
+  }
+
+  @Test
+  public void testCanSetAndGetModel() {
+    Object model = new Object();
+    int width = 10;
+    int height = 20;
+    Object result = new Object();
+    cache.put(model, width, height, result);
+    assertEquals(result, cache.get(model, width, height));
+  }
+
+  @Test
+  public void testCanSetAndGetMultipleResultsWithDifferentDimensionsForSameObject() {
+    Object model = new Object();
+    int firstWidth = 10, firstHeight = 20;
+    Object firstResult = new Object();
+    int secondWidth = 30, secondHeight = 40;
+    Object secondResult = new Object();
+
+    cache.put(model, firstWidth, firstHeight, firstResult);
+    cache.put(model, secondWidth, secondHeight, secondResult);
+
+    assertEquals(firstResult, cache.get(model, firstWidth, firstHeight));
+    assertEquals(secondResult, cache.get(model, secondWidth, secondHeight));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
new file mode 100644
index 000000000..3664fcce2
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -0,0 +1,315 @@
+package com.bumptech.glide.load.model;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.support.v4.util.Pools.Pool;
+
+import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
+import com.bumptech.glide.util.pool.FactoryPools;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class MultiModelLoaderFactoryTest {
+
+  @Mock ModelLoaderFactory<String, String> firstFactory;
+  @Mock ModelLoader<String, String> firstModelLoader;
+  @Mock MultiModelLoaderFactory.Factory multiModelLoaderFactory;
+  @Mock ModelLoaderFactory<String, String> secondFactory;
+  @Mock ModelLoader<String, String> secondModelLoader;
+
+  @Rule public ExpectedException exception = ExpectedException.none();
+
+  private Pool<List<Exception>> exceptionListPool;
+  private MultiModelLoaderFactory multiFactory;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    exceptionListPool = FactoryPools.threadSafeList();
+
+    multiFactory = new MultiModelLoaderFactory(RuntimeEnvironment.application, exceptionListPool,
+            multiModelLoaderFactory);
+    when(firstFactory.build(anyContext(), eq(multiFactory))).thenReturn(firstModelLoader);
+    when(secondFactory.build(anyContext(), eq(multiFactory))).thenReturn(secondModelLoader);
+  }
+
+  @Test
+  public void testAppend_addsModelLoaderForModelClass() {
+    multiFactory.append(String.class, String.class, firstFactory);
+
+    List<ModelLoader<String, ?>> modelLoaders = multiFactory.build(String.class);
+    assertThat(modelLoaders).containsExactly(firstModelLoader);
+  }
+
+  @Test
+  public void testAppend_addsModelLoaderForModelAndDataClass() {
+    multiFactory.append(String.class, String.class, firstFactory);
+
+    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);
+    assertThat(modelLoader).isEqualTo(firstModelLoader);
+  }
+
+  @Test
+  public void testPrepend_addsModelLoaderForModelClass() {
+    multiFactory.prepend(String.class, String.class, firstFactory);
+
+    List<ModelLoader<String, ?>> modelLoaders = multiFactory.build(String.class);
+    assertThat(modelLoaders).containsExactly(firstModelLoader);
+  }
+
+  @Test
+  public void testPrepend_addsModelLoaderForModelAndDataClass() {
+    multiFactory.prepend(String.class, String.class, firstFactory);
+
+    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);
+    assertThat(modelLoader).isEqualTo(firstModelLoader);
+  }
+
+  @Test
+  public void testReplace_addsModelLoaderForModelClass() {
+    multiFactory.replace(String.class, String.class, firstFactory);
+
+    List<ModelLoader<String, ?>> modelLoaders = multiFactory.build(String.class);
+    assertThat(modelLoaders).containsExactly(firstModelLoader);
+  }
+
+  @Test
+  public void testReplace_addsModelLoaderForModelAndDataClasses() {
+    multiFactory.replace(String.class, String.class, firstFactory);
+
+    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);
+    assertThat(modelLoader).isEqualTo(firstModelLoader);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  public void testReplace_returnsPreviouslyRegisteredFactories_withModelAndDataClasses() {
+    ModelLoaderFactory<String, String> firstOtherFactory = mock(ModelLoaderFactory.class);
+    ModelLoaderFactory<String, String> secondOtherFactory = mock(ModelLoaderFactory.class);
+    multiFactory.append(String.class, String.class, firstOtherFactory);
+    multiFactory.append(String.class, String.class, secondOtherFactory);
+
+    List<ModelLoaderFactory<String, String>> removed =
+        multiFactory.replace(String.class, String.class, firstFactory);
+    assertThat(removed).containsExactly(firstOtherFactory, secondOtherFactory);
+  }
+
+  @Test
+  public void testReplace_removesPreviouslyRegisteredFactories_withModelAndDataClasses() {
+    appendFactoryFor(String.class, String.class);
+    appendFactoryFor(String.class, String.class);
+
+    multiFactory.replace(String.class, String.class, firstFactory);
+
+    List<ModelLoader<String, ?>> modelLoaders = multiFactory.build(String.class);
+    assertThat(modelLoaders).containsExactly(firstModelLoader);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  public void testRemove_returnsPreviouslyRegisteredFactories_withModelAndDataClasses() {
+    ModelLoaderFactory<String, String> other = mock(ModelLoaderFactory.class);
+    multiFactory.append(String.class, String.class, other);
+    multiFactory.append(String.class, String.class, firstFactory);
+
+    List<ModelLoaderFactory<String, String>> removed =
+        multiFactory.remove(String.class, String.class);
+    assertThat(removed).containsExactly(firstFactory, other);
+  }
+
+  @Test
+  public void testRemove_removesPreviouslyRegisteredFactories_withModelAndDataClasses() {
+    appendFactoryFor(String.class, String.class);
+    appendFactoryFor(String.class, String.class);
+
+    multiFactory.remove(String.class, String.class);
+
+    List<ModelLoader<String, ?>> modelLoaders = multiFactory.build(String.class);
+    assertThat(modelLoaders).isEmpty();
+  }
+
+  @Test
+  public void testBuild_withModelClass_returnsMultipleModelLoaders_ofGivenModelAndDataClasses() {
+    ModelLoader<String, String> otherLoader = appendFactoryFor(String.class, String.class);
+    multiFactory.append(String.class, String.class, firstFactory);
+
+    List<ModelLoader<String, ?>> modelLoaders = multiFactory.build(String.class);
+    assertThat(modelLoaders).containsExactly(otherLoader, firstModelLoader);
+  }
+
+  @Test
+  public void
+  testBuild_withModelClass_returnsMultipleModelLoaders_ofGivenModelClassWithDifferentDataClasses() {
+    ModelLoader<String, Integer> otherLoader = appendFactoryFor(String.class, Integer.class);
+    multiFactory.append(String.class, String.class, firstFactory);
+
+    List<ModelLoader<String, ?>> modelLoaders = multiFactory.build(String.class);
+    assertThat(modelLoaders).containsExactly(otherLoader, firstModelLoader);
+  }
+
+  @Test
+  public void testBuild_withModelClass_excludesModelLoadersForOtherModelClasses() {
+    multiFactory.append(String.class, String.class, firstFactory);
+    List<ModelLoader<Integer, ?>> modelLoaders = multiFactory.build(Integer.class);
+    assertThat(modelLoaders).doesNotContain(firstModelLoader);
+  }
+
+  @Test
+  public void
+  testBuild_withModelAndDataClasses_returnsMultipleModelLoaders_ofGivenModelAndDataClasses() {
+    ModelLoader<String, String> otherLoader = appendFactoryFor(String.class, String.class);
+    multiFactory.append(String.class, String.class, firstFactory);
+
+    List<ModelLoader<String, String>> modelLoaders = buildModelLoaders(String.class, String.class);
+    assertThat(modelLoaders).containsExactly(otherLoader, firstModelLoader);
+  }
+
+  @Test
+  public void testBuild_withModelAndDataClasses_excludesModelLoadersForOtherDataClasses() {
+    multiFactory.append(String.class, String.class, firstFactory);
+
+    exception.expect(NoModelLoaderAvailableException.class);
+    multiFactory.build(String.class, Integer.class);
+  }
+
+  @Test
+  public void testBuild_withModelAndDataClasses_excludesModelLoadersForOtherModelClasses() {
+    multiFactory.append(String.class, String.class, firstFactory);
+
+    exception.expect(NoModelLoaderAvailableException.class);
+    multiFactory.build(Integer.class, String.class);
+  }
+
+  @Test
+  public void testBuild_withModelClass_doesNotMatchSubclassesOfModelClass() {
+    ModelLoader<String, Object> subclass = appendFactoryFor(String.class, Object.class);
+    List<ModelLoader<Object, ?>> modelLoaders = multiFactory.build(Object.class);
+    assertThat(modelLoaders).doesNotContain(subclass);
+  }
+
+  @Test
+  public void testBuild_withModelClass_matchesSuperclassesOfModelClass() {
+    ModelLoader<Object, Object> superclass = appendFactoryFor(Object.class, Object.class);
+    List<ModelLoader<String, ?>> modelLoaders = multiFactory.build(String.class);
+    assertThat(modelLoaders).contains(superclass);
+  }
+
+  @Test
+  public void testBuild_withModelAndDataClass_doesNotMatchSubclassesOfModelClass() {
+    appendFactoryFor(String.class, Object.class);
+    exception.expect(NoModelLoaderAvailableException.class);
+    multiFactory.build(Object.class, Object.class);
+  }
+
+  @Test
+  public void testBuild_withModelAndDataClass_doesNotMatchSubclassesOfDataClass() {
+    appendFactoryFor(Object.class, String.class);
+    exception.expect(NoModelLoaderAvailableException.class);
+    multiFactory.build(Object.class, Object.class);
+  }
+
+  @Test
+  public void testBuild_withModelAndDataClass_doesMatchSuperclassesOfModelClass() {
+    ModelLoader<Object, Object> firstSuperClass = appendFactoryFor(Object.class, Object.class);
+    ModelLoader<Object, Object> secondSuperClass = appendFactoryFor(Object.class, Object.class);
+    List<ModelLoader<String, Object>> modelLoaders = buildModelLoaders(String.class, Object.class);
+    assertThat(modelLoaders).containsExactly(firstSuperClass, secondSuperClass);
+  }
+
+  @Test
+  public void testBuild_withModelAndDataClass_matchesSuperclassesOfDataClass() {
+    ModelLoader<Object, Object> firstSuperClass = appendFactoryFor(Object.class, Object.class);
+    ModelLoader<Object, Object> secondSuperClass = appendFactoryFor(Object.class, Object.class);
+    List<ModelLoader<Object, String>> modelLoaders = buildModelLoaders(Object.class, String.class);
+    assertThat(modelLoaders).containsExactly(firstSuperClass, secondSuperClass);
+  }
+
+  @Test
+  public void testBuild_withModelAndDataClass_matchesSuperclassOfModelAndDataClass() {
+    ModelLoader<Object, Object> firstSuperclass = appendFactoryFor(Object.class, Object.class);
+    ModelLoader<Object, Object> secondSuperclass = appendFactoryFor(Object.class, Object.class);
+    List<ModelLoader<String, String>> modelLoaders = buildModelLoaders(String.class, String.class);
+    assertThat(modelLoaders).containsExactly(firstSuperclass, secondSuperclass);
+  }
+
+  @Test
+  public void testBuild_respectsAppendOrder() {
+    ModelLoader<String, String> first = appendFactoryFor(String.class, String.class);
+    ModelLoader<String, String> second = appendFactoryFor(String.class, String.class);
+    ModelLoader<String, String> third = appendFactoryFor(String.class, String.class);
+    List<ModelLoader<String, String>> modelLoaders = buildModelLoaders(String.class, String.class);
+    assertThat(modelLoaders).containsExactly(first, second, third).inOrder();
+  }
+
+  @Test
+  public void testBuild_respectsPrependOrder() {
+    ModelLoader<String, String> first = prependFactoryFor(String.class, String.class);
+    ModelLoader<String, String> second = prependFactoryFor(String.class, String.class);
+    ModelLoader<String, String> third = prependFactoryFor(String.class, String.class);
+    List<ModelLoader<String, String>> modelLoaders = buildModelLoaders(String.class, String.class);
+    assertThat(modelLoaders).containsExactly(third, second, first).inOrder();
+  }
+
+  @SuppressWarnings("unchecked")
+  private <X, Y> List<ModelLoader<X, Y>> buildModelLoaders(Class<X> modelClass,
+      Class<Y> dataClass) {
+    ArgumentCaptor<List> captor = ArgumentCaptor.forClass(List.class);
+    multiFactory.build(modelClass, dataClass);
+    verify(multiModelLoaderFactory).build(captor.capture(), eq(exceptionListPool));
+
+    List<ModelLoader> captured = captor.getValue();
+    List<ModelLoader<X, Y>> result = new ArrayList<>(captured.size());
+    for (ModelLoader modelLoader : captured) {
+      result.add(modelLoader);
+    }
+    return result;
+  }
+
+  private <X, Y> ModelLoader<X, Y> appendFactoryFor(Class<X> modelClass, Class<Y> dataClass) {
+    return registerFactoryFor(modelClass, dataClass, true /*append*/);
+  }
+
+  private <X, Y> ModelLoader<X, Y> prependFactoryFor(Class<X> modelClass, Class<Y> dataClass) {
+    return registerFactoryFor(modelClass, dataClass, false /*append*/);
+  }
+
+  @SuppressWarnings("unchecked")
+  private <X, Y> ModelLoader<X, Y> registerFactoryFor(Class<X> modelClass, Class<Y> dataClass,
+      boolean append) {
+    ModelLoaderFactory<X, Y> factory = mock(ModelLoaderFactory.class);
+    ModelLoader<X, Y> loader = mock(ModelLoader.class);
+    when(factory.build(anyContext(), eq(multiFactory))).thenReturn(loader);
+    if (append) {
+      multiFactory.append(modelClass, dataClass, factory);
+    } else {
+      multiFactory.prepend(modelClass, dataClass, factory);
+    }
+    return loader;
+  }
+
+  private static Context anyContext() {
+    return any(Context.class);
+  }
+}
+
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
new file mode 100644
index 000000000..492e029dc
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.load.model;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.net.Uri;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+/**
+ * Tests for the {@link com.bumptech.glide.load.model.ResourceLoader} class.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ResourceLoaderTest {
+
+  @Mock ModelLoader<Uri, Object> uriLoader;
+  @Mock DataFetcher<Object> fetcher;
+  @Mock Key key;
+  private Options options;
+
+  private ResourceLoader<Object> loader;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    options = new Options();
+
+    loader = new ResourceLoader<>(RuntimeEnvironment.application, uriLoader);
+  }
+
+  @Test
+  public void testCanHandleId() {
+    int id = android.R.drawable.star_off;
+    Uri contentUri = Uri.parse("android.resource://android/drawable/star_off");
+    when(uriLoader.buildLoadData(eq(contentUri), anyInt(), anyInt(), any(Options.class)))
+        .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
+
+    assertTrue(loader.handles(id));
+    assertEquals(fetcher, loader.buildLoadData(id, 100, 100, new Options()).fetcher);
+  }
+
+    @Test
+    public void testDoesNotThrowOnInvalidOrMissingId() {
+      assertThat(loader.buildLoadData(1234, 0, 0, options)).isNull();
+      verify(uriLoader, never()).buildLoadData(any(Uri.class), anyInt(), anyInt(),
+          any(Options.class));
+    }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
new file mode 100644
index 000000000..184012b38
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -0,0 +1,48 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.util.ByteBufferUtil;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class StreamEncoderTest {
+  private StreamEncoder encoder;
+  private File file;
+
+  @Before
+  public void setUp() {
+    encoder = new StreamEncoder(new LruByteArrayPool());
+    file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+  }
+
+  @After
+  public void tearDown() {
+    file.delete();
+  }
+
+  @Test
+  public void testWritesDataFromInputStreamToOutputStream() throws IOException {
+    String fakeData = "SomeRandomFakeData";
+    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes());
+    encoder.encode(is, file, new Options());
+
+    byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
+
+    assertEquals(fakeData, new String(data));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
new file mode 100644
index 000000000..d8cd64909
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
@@ -0,0 +1,152 @@
+package com.bumptech.glide.load.model;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import android.net.Uri;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Tests for the {@link com.bumptech.glide.load.model.StringLoader} class.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class StringLoaderTest {
+  // Not a magic number, just an arbitrary non zero value.
+  private static final int IMAGE_SIDE = 100;
+
+  @Mock ModelLoader<Uri, Object> uriLoader;
+  @Mock DataFetcher<Object> fetcher;
+  @Mock Key key;
+
+  private StringLoader<Object> loader;
+  private Options options;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+
+    options = new Options();
+    when(uriLoader.handles(any(Uri.class))).thenReturn(true);
+    loader = new StringLoader<>(uriLoader);
+  }
+
+  @Test
+  public void testHandlesPaths() throws IOException {
+    // TODO on windows it will fail with schema being the drive letter (C:\... -> C)
+    assumeTrue(!Util.isWindows());
+
+    File f = RuntimeEnvironment.application.getCacheDir();
+    Uri expected = Uri.fromFile(f);
+    when(uriLoader.buildLoadData(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
+
+    assertTrue(loader.handles(f.getAbsolutePath()));
+    assertEquals(fetcher,
+        loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testCanHandleComplexFilePaths() {
+    assumeTrue(!Util.isWindows());
+
+    String testPath =
+        "/storage/emulated/0/DCIM/Camera/IMG_20140520_100001:nopm:.jpg,mimeType=image/jpeg,"
+            + "2448x3264,orientation=0,date=Tue";
+    Uri expected = Uri.fromFile(new File(testPath));
+    when(uriLoader.buildLoadData(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
+
+    assertTrue(loader.handles(testPath));
+    assertEquals(fetcher, loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testHandlesFileUris() throws IOException {
+    File f = RuntimeEnvironment.application.getCacheDir();
+
+    Uri expected = Uri.fromFile(f);
+    when(uriLoader.buildLoadData(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
+
+    assertTrue(loader.handles(f.getAbsolutePath()));
+    assertEquals(fetcher,
+        loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testHandlesResourceUris() throws IOException {
+    Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
+
+    when(uriLoader.buildLoadData(eq(resourceUri), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
+
+    assertTrue(loader.handles(resourceUri.toString()));
+    assertEquals(fetcher,
+        loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testHandlesHttp() {
+    String url = "http://www.google.com";
+
+    Uri expected = Uri.parse(url);
+    when(uriLoader.buildLoadData(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
+
+    assertTrue(loader.handles(url));
+    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testHandlesHttps() {
+    String url = "https://www.google.com";
+
+    Uri expected = Uri.parse(url);
+    when(uriLoader.buildLoadData(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
+
+    assertTrue(loader.handles(url));
+    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testHandlesContent() {
+    String content = "content://com.bumptech.glide";
+
+    Uri expected = Uri.parse(content);
+    when(uriLoader.buildLoadData(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
+
+    assertTrue(loader.handles(content));
+    assertEquals(fetcher, loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testGetResourceFetcher_withEmptyString_returnsNull() {
+    assertThat(loader.buildLoadData("", IMAGE_SIDE, IMAGE_SIDE, options)).isNull();
+    assertThat(loader.buildLoadData("    ", IMAGE_SIDE, IMAGE_SIDE, options)).isNull();
+    assertThat(loader.buildLoadData("  \n", IMAGE_SIDE, IMAGE_SIDE, options)).isNull();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
new file mode 100644
index 000000000..47fcd5457
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -0,0 +1,82 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Tests for the {@link UriLoader} class.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class UriLoaderTest {
+  // Not a magic number, just arbitrary non zero.
+  private static final int IMAGE_SIDE = 120;
+
+  @Mock DataFetcher<Object> localUriFetcher;
+  @Mock UriLoader.LocalUriFetcherFactory<Object> factory;
+  private UriLoader<Object> loader;
+  private Options options;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+
+    options = new Options();
+    loader = new UriLoader<>(RuntimeEnvironment.application, factory);
+  }
+
+  @Test
+  public void testHandlesFileUris() throws IOException {
+    Uri fileUri = Uri.fromFile(new File("f"));
+    when(factory.build(anyContext(), eq(fileUri))).thenReturn(localUriFetcher);
+
+    assertTrue(loader.handles(fileUri));
+    assertEquals(localUriFetcher,
+        loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testHandlesResourceUris() throws IOException {
+    Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
+    when(factory.build(anyContext(), eq(resourceUri))).thenReturn(localUriFetcher);
+
+    assertTrue(loader.handles(resourceUri));
+    assertEquals(localUriFetcher,
+        loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+  }
+
+  @Test
+  public void testHandlesContentUris() {
+    Uri contentUri = Uri.parse("content://com.bumptech.glide");
+    when(factory.build(anyContext(), eq(contentUri))).thenReturn(localUriFetcher);
+
+    assertTrue(loader.handles(contentUri));
+    assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
+        options).fetcher);
+  }
+
+  private static Context anyContext() {
+    return any(Context.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
new file mode 100644
index 000000000..16d54a573
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -0,0 +1,150 @@
+package com.bumptech.glide.load.model.stream;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelCache;
+import com.bumptech.glide.load.model.ModelLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BaseGlideUrlLoaderTest {
+
+  @Mock ModelCache<Object, GlideUrl> modelCache;
+  @Mock ModelLoader<GlideUrl, InputStream> wrapped;
+  @Mock DataFetcher<InputStream> fetcher;
+  private TestLoader urlLoader;
+  private Options options;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    options = new Options();
+    urlLoader = new TestLoader(wrapped, modelCache);
+  }
+
+  @Test
+  public void testReturnsNullIfUrlIsNull() {
+    urlLoader.resultUrl = null;
+    assertNull(urlLoader.buildLoadData(new Object(), 100, 100, options));
+  }
+
+  @Test
+  public void testReturnsNullIfUrlIsEmpty() {
+    urlLoader.resultUrl = "    ";
+    assertNull(urlLoader.buildLoadData(new Object(), 100, 100, options));
+  }
+
+  @Test
+  public void testReturnsUrlFromCacheIfPresent() {
+    Object model = new Object();
+    int width = 100;
+    int height = 200;
+    GlideUrl expectedUrl = mock(GlideUrl.class);
+    when(modelCache.get(eq(model), eq(width), eq(height))).thenReturn(expectedUrl);
+
+    when(wrapped.buildLoadData(eq(expectedUrl), eq(width), eq(height), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
+
+    assertEquals(fetcher, urlLoader.buildLoadData(model, width, height, options).fetcher);
+  }
+
+  @Test
+  public void testBuildsNewUrlIfNotPresentInCache() {
+    int width = 10;
+    int height = 11;
+
+    urlLoader.resultUrl = "fakeUrl";
+    when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
+        .thenAnswer(new Answer<ModelLoader.LoadData<InputStream>>() {
+          @Override
+          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock)
+              throws Throwable {
+            GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
+            assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
+            return new ModelLoader.LoadData<>(mock(Key.class), fetcher);
+
+          }
+        });
+    assertEquals(fetcher,
+        urlLoader.buildLoadData(new GlideUrl(urlLoader.resultUrl), width, height, options).fetcher);
+  }
+
+  @Test
+  public void testAddsNewUrlToCacheIfNotPresentInCache() {
+    urlLoader.resultUrl = "fakeUrl";
+    Object model = new Object();
+    int width = 400;
+    int height = 500;
+
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
+        assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
+        return null;
+      }
+    }).when(modelCache).put(eq(model), eq(width), eq(height), any(GlideUrl.class));
+
+    urlLoader.buildLoadData(model, width, height, options);
+
+    verify(modelCache).put(eq(model), eq(width), eq(height), any(GlideUrl.class));
+  }
+
+  @Test
+  public void testDoesNotInteractWithModelCacheIfNull() {
+    TestLoader urlLoader = new TestLoader(wrapped, null);
+    urlLoader.resultUrl = "fakeUrl";
+
+    int width = 456;
+    int height = 789;
+
+    when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
+
+    assertEquals(fetcher, urlLoader.buildLoadData(new Object(), width, height, options).fetcher);
+  }
+
+  private class TestLoader extends BaseGlideUrlLoader<Object> {
+    public String resultUrl;
+
+    public TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+        ModelCache<Object, GlideUrl> modelCache) {
+      super(concreteLoader, modelCache);
+    }
+
+    @Override
+    protected String getUrl(Object model, int width, int height, Options options) {
+      return resultUrl;
+    }
+
+    @Override
+    public boolean handles(Object model) {
+      return true;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
new file mode 100644
index 000000000..35dc69180
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.model.stream;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.HttpUrlFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.InputStream;
+
+@RunWith(JUnit4.class)
+public class HttpGlideUrlLoaderTest {
+  private HttpGlideUrlLoader loader;
+  private GlideUrl model;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    loader = new HttpGlideUrlLoader();
+    model = mock(GlideUrl.class);
+  }
+
+  @Test
+  public void testReturnsValidFetcher() {
+    DataFetcher<InputStream> result = loader.buildLoadData(model, 100, 100, new Options()).fetcher;
+    assertThat(result).isInstanceOf(HttpUrlFetcher.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
new file mode 100644
index 000000000..369696786
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
@@ -0,0 +1,74 @@
+package com.bumptech.glide.load.model.stream;
+
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+
+import android.net.Uri;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.InputStream;
+import java.net.MalformedURLException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class HttpUriLoaderTest {
+  private static final int IMAGE_SIDE = 100;
+  private static final Options OPTIONS = new Options();
+
+  @Mock ModelLoader<GlideUrl, InputStream> urlLoader;
+  private HttpUriLoader loader;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    loader = new HttpUriLoader(urlLoader);
+  }
+
+  @Test
+  public void testHandlesHttpUris() throws MalformedURLException {
+    Uri httpUri = Uri.parse("http://www.google.com");
+    loader.buildLoadData(httpUri, IMAGE_SIDE, IMAGE_SIDE, OPTIONS);
+
+    assertTrue(loader.handles(httpUri));
+    verify(urlLoader)
+        .buildLoadData(eq(new GlideUrl(httpUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE),
+            eq(OPTIONS));
+  }
+
+  @Test
+  public void testHandlesHttpsUris() throws MalformedURLException {
+    Uri httpsUri = Uri.parse("https://www.google.com");
+    loader.buildLoadData(httpsUri, IMAGE_SIDE, IMAGE_SIDE, OPTIONS);
+
+    assertTrue(loader.handles(httpsUri));
+    verify(urlLoader)
+        .buildLoadData(eq(new GlideUrl(httpsUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE),
+            eq(OPTIONS));
+  }
+
+  // Test for https://github.com/bumptech/glide/issues/71.
+  @Test
+  public void testHandlesMostlyInvalidHttpUris() {
+    Uri mostlyInvalidHttpUri = Uri.parse(
+        "http://myserver_url.com:80http://myserver_url.com/webapp/images/no_image.png?size=100");
+
+    assertTrue(loader.handles(mostlyInvalidHttpUri));
+    loader.buildLoadData(mostlyInvalidHttpUri, IMAGE_SIDE, IMAGE_SIDE, OPTIONS);
+    verify(urlLoader)
+        .buildLoadData(eq(new GlideUrl(mostlyInvalidHttpUri.toString())), eq(IMAGE_SIDE),
+            eq(IMAGE_SIDE), eq(OPTIONS));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
new file mode 100644
index 000000000..a20a7b2db
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.load.resource;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SimpleResourceTest {
+  private Anything object;
+  private SimpleResource resource;
+
+  @Before
+  public void setUp() {
+    object = new Anything();
+    resource = new SimpleResource(object);
+  }
+
+  @Test
+  public void testReturnsGivenObject() {
+    assertEquals(object, resource.get());
+  }
+
+  @Test
+  public void testReturnsGivenObjectMultipleTimes() {
+    assertEquals(object, resource.get());
+    assertEquals(object, resource.get());
+    assertEquals(object, resource.get());
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfGivenNullData() {
+    new SimpleResource<>(null);
+  }
+
+  private static class Anything {
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
new file mode 100644
index 000000000..ce38270a9
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -0,0 +1,39 @@
+package com.bumptech.glide.load.resource;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(JUnit4.class)
+public class UnitTransformationTest {
+
+  @Test
+  public void testReturnsGivenResource() {
+    Resource resource = mock(Resource.class);
+    UnitTransformation transformation = UnitTransformation.get();
+    assertEquals(resource, transformation.transform(resource, 10, 10));
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    KeyAssertions.assertSame(UnitTransformation.get(), UnitTransformation.get());
+
+    Transformation<Object> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other")).when(other)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertDifferent(UnitTransformation.get(), other);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
new file mode 100644
index 000000000..15d6e505b
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapDrawableResourceTest {
+  private BitmapDrawableResourceHarness harness;
+
+  @Before
+  public void setUp() {
+    harness = new BitmapDrawableResourceHarness();
+  }
+
+  @Test
+  public void testReturnsGivenBitmapFromGet() {
+    assertEquals(harness.bitmap, harness.create().get().getBitmap());
+  }
+
+  @Test
+  public void testReturnsDifferentDrawableEachTime() {
+    BitmapDrawableResource resource = harness.create();
+    BitmapDrawable first = resource.get();
+    BitmapDrawable second = resource.get();
+
+    assertNotSame(first, second);
+  }
+
+  @Test
+  public void testReturnsSizeFromGivenBitmap() {
+    assertEquals(harness.bitmap.getHeight() * harness.bitmap.getRowBytes(),
+        harness.create().getSize());
+  }
+
+  @Test
+  public void testBitmapIsReturnedToPoolOnRecycle() {
+    harness.create().recycle();
+
+    verify(harness.bitmapPool).put(eq(harness.bitmap));
+  }
+
+  private static class BitmapDrawableResourceHarness {
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    public BitmapDrawableResource create() {
+      return new BitmapDrawableResource(
+          new BitmapDrawable(RuntimeEnvironment.application.getResources(), bitmap), bitmapPool);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
new file mode 100644
index 000000000..78ba2efc9
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -0,0 +1,125 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapDrawableTransformationTest {
+
+  @Mock BitmapPool bitmapPool;
+  @Mock Transformation<Bitmap> wrapped;
+  @Mock Resource<BitmapDrawable> drawableResourceToTransform;
+  @Mock BitmapDrawable drawableToTransform;
+
+  private BitmapDrawableTransformation transformation;
+  private Bitmap bitmapToTransform;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
+    when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);
+    transformation = new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool,
+        wrapped);
+  }
+
+  @Test
+  public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {
+    int outWidth = 123;
+    int outHeight = 456;
+    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))
+        .thenAnswer(new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) throws Throwable {
+            return invocation.getArguments()[0];
+          }
+        });
+
+    Resource<BitmapDrawable> transformed = transformation.transform(drawableResourceToTransform,
+        outWidth, outHeight);
+
+    assertThat(transformed).isEqualTo(drawableResourceToTransform);
+  }
+
+  @Test
+  public void testReturnsNewResourceIfTransformationDoesTransform() {
+    int outWidth = 999;
+    int outHeight = 555;
+
+    Bitmap transformedBitmap = Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.RGB_565);
+    Resource<Bitmap> transformedBitmapResource = mock(Resource.class);
+    when(transformedBitmapResource.get()).thenReturn(transformedBitmap);
+    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))
+        .thenReturn(transformedBitmapResource);
+
+    Resource<BitmapDrawable> transformed =
+        transformation.transform(drawableResourceToTransform, outWidth, outHeight);
+
+    assertThat(transformed.get().getBitmap()).isEqualTo(transformedBitmap);
+  }
+
+  @Test
+  public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
+    int outWidth = 332;
+    int outHeight = 111;
+    Resource<Bitmap> transformed = mock(Resource.class);
+    when(transformed.get())
+        .thenReturn(Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.ARGB_8888));
+    when(wrapped.transform(any(Resource.class), anyInt(), anyInt()))
+        .thenReturn(transformed);
+
+    transformation.transform(drawableResourceToTransform, outWidth, outHeight);
+    ArgumentCaptor<Resource> captor = ArgumentCaptor.forClass(Resource.class);
+
+    verify(wrapped).transform(captor.capture(), eq(outWidth), eq(outHeight));
+
+    assertThat(captor.getValue().get()).isEqualTo(bitmapToTransform);
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertSame(transformation,
+        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, wrapped));
+
+    Transformation<Bitmap> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other")).when(other)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertDifferent(transformation,
+        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, other));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
new file mode 100644
index 000000000..60e3e3db7
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -0,0 +1,157 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.ByteBufferUtil;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
+
+import java.io.File;
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = {
+    BitmapEncoderTest.AlphaShadowBitmap.class })
+public class BitmapEncoderTest {
+  private EncoderHarness harness;
+
+  @Before
+  public void setUp() {
+    harness = new EncoderHarness();
+  }
+
+  @After
+  public void tearDown() {
+    harness.tearDown();
+  }
+
+  @Test
+  public void testBitmapIsEncoded() throws IOException {
+    String fakeBytes = harness.encode();
+
+    assertContains(fakeBytes, Shadows.shadowOf(harness.bitmap).getDescription());
+  }
+
+  @Test
+  public void testBitmapIsEncodedWithGivenQuality() throws IOException {
+    int quality = 7;
+    harness.setQuality(quality);
+
+    String fakeBytes = harness.encode();
+
+    assertContains(fakeBytes, String.valueOf(quality));
+  }
+
+  @Test
+  public void testEncoderObeysNonNullCompressFormat() throws IOException {
+    Bitmap.CompressFormat format = Bitmap.CompressFormat.WEBP;
+    harness.setFormat(format);
+
+    String fakeBytes = harness.encode();
+
+    assertContains(fakeBytes, format.toString());
+  }
+
+  @Test
+  public void testEncoderEncodesJpegWithNullFormatAndBitmapWithoutAlpha() throws IOException {
+    harness.setFormat(null);
+    harness.bitmap.setHasAlpha(false);
+
+    String fakeBytes = harness.encode();
+
+    assertContains(fakeBytes, Bitmap.CompressFormat.JPEG.toString());
+  }
+
+  @Test
+  public void testEncoderEncodesPngWithNullFormatAndBitmapWithAlpha() throws IOException {
+    harness.setFormat(null);
+    harness.bitmap.setHasAlpha(true);
+
+    String fakeBytes = harness.encode();
+
+    assertContains(fakeBytes, Bitmap.CompressFormat.PNG.toString());
+  }
+
+  @Test
+  public void testReturnsTrueFromWrite() {
+    BitmapEncoder encoder = new BitmapEncoder();
+    assertTrue(encoder.encode(harness.resource, harness.file, harness.options));
+  }
+
+  @Test
+  public void testEncodeStrategy_alwaysReturnsTransformed() {
+    BitmapEncoder encoder = new BitmapEncoder();
+    assertEquals(EncodeStrategy.TRANSFORMED, encoder.getEncodeStrategy(harness.options));
+  }
+
+  private static void assertContains(String string, String expected) {
+    assertThat(string).contains(expected);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static class EncoderHarness {
+    Resource<Bitmap> resource = mock(Resource.class);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Options options = new Options();
+    File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+
+    public EncoderHarness() {
+      when(resource.get()).thenReturn(bitmap);
+    }
+
+    public void setQuality(int quality) {
+      options.set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+    }
+
+    public void setFormat(Bitmap.CompressFormat format) {
+      options.set(BitmapEncoder.COMPRESSION_FORMAT, format);
+    }
+
+    public String encode() throws IOException {
+      BitmapEncoder encoder = new BitmapEncoder();
+      encoder.encode(resource, file, options);
+      byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
+      return new String(data);
+    }
+
+    public void tearDown() {
+      file.delete();
+    }
+  }
+
+  @Implements(Bitmap.class)
+  public static class AlphaShadowBitmap extends ShadowBitmap {
+    private boolean hasAlpha;
+
+    @SuppressWarnings("unused")
+    @Implementation
+    public void setHasAlpha(boolean hasAlpha) {
+      this.hasAlpha = hasAlpha;
+    }
+
+    @SuppressWarnings("unused")
+    @Implementation
+    public boolean hasAlpha() {
+      return hasAlpha;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
new file mode 100644
index 000000000..b6d8a8b43
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import android.graphics.Bitmap;
+import android.os.Build;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+//TODO: add a test for bitmap size using getAllocationByteSize when robolectric supports kitkat.
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapResourceTest {
+  private int currentBuildVersion;
+  private BitmapResourceHarness harness;
+
+  @Before
+  public void setUp() {
+    currentBuildVersion = Build.VERSION.SDK_INT;
+    harness = new BitmapResourceHarness();
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(currentBuildVersion);
+  }
+
+  @Test
+  public void testCanGetBitmap() {
+    assertEquals(harness.bitmap, harness.resource.get());
+  }
+
+  @Test
+  public void testSizeIsBasedOnDimensPreKitKat() {
+    Util.setSdkVersionInt(18);
+    assertEquals(harness.bitmap.getWidth() * harness.bitmap.getHeight() * 4,
+        harness.resource.getSize());
+  }
+
+  @Test
+  public void testPutsBitmapInPoolOnRecycle() {
+    harness.resource.recycle();
+
+    verify(harness.bitmapPool).put(eq(harness.bitmap));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfBitmapIsNull() {
+    new BitmapResource(null, mock(BitmapPool.class));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfBitmapPoolIsNull() {
+    new BitmapResource(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565), null);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfBitmapAndBitmapPoolAreNull() {
+    new BitmapResource(null, null);
+  }
+
+  private static class BitmapResourceHarness {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+    BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
new file mode 100644
index 000000000..e53f0180a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -0,0 +1,196 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.security.MessageDigest;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapTransformationTest {
+
+  @Mock
+  private BitmapPool bitmapPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testReturnsGivenResourceWhenBitmapNotTransformed() {
+    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+      @Override
+      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+
+      @Override
+      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
+        return toTransform;
+      }
+    };
+
+    Resource<Bitmap> resource = mockResource(100, 100);
+    assertEquals(resource, transformation.transform(resource, 1, 1));
+  }
+
+  @Test
+  public void testReturnsNewResourceWhenBitmapTransformed() {
+    final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+      @Override
+      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+
+      @Override
+      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth,
+          int outHeight) {
+        return transformed;
+      }
+    };
+
+    Resource<Bitmap> resource = mockResource(1, 2);
+    assertNotSame(resource, transformation.transform(resource, 100, 100));
+  }
+
+  @Test
+  public void testPassesGivenArgumentsToTransform() {
+    final int expectedWidth = 13;
+    final int expectedHeight = 148;
+    final Resource<Bitmap> resource = mockResource(223, 4123);
+    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+      @Override
+      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+
+      @Override
+      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
+        assertEquals(bitmapPool, pool);
+        assertEquals(resource.get(), toTransform);
+        assertEquals(expectedWidth, outWidth);
+        assertEquals(expectedHeight, outHeight);
+        return resource.get();
+      }
+    };
+
+    transformation.transform(resource, expectedWidth, expectedHeight);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfGivenInvalidWidth() {
+    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+
+      @Override
+      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+
+      @Override
+      protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
+        return null;
+      }
+    };
+    transformation.transform(mock(Resource.class), -1, 100);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfGivenInvalidHeight() {
+    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+
+      @Override
+      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+
+      @Override
+      protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
+        return null;
+      }
+
+    };
+    transformation.transform(mock(Resource.class), 100, -1);
+  }
+
+  @Test
+  public void testReturnsNullIfTransformReturnsNull() {
+    BitmapTransformation transform = new BitmapTransformation(bitmapPool) {
+
+      @Override
+      public void updateDiskCacheKey(MessageDigest messageDigest) {  }
+
+      @Override
+      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
+        return null;
+      }
+    };
+
+    Resource<Bitmap> resource = mockResource(100, 100);
+    assertNull(transform.transform(resource, 100, 100));
+  }
+
+  @Test
+  public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {
+    SizeTrackingTransform transform = new SizeTrackingTransform();
+
+    int expectedWidth = 200;
+    Resource<Bitmap> resource = mockResource(expectedWidth, 300);
+    transform.transform(resource, Target.SIZE_ORIGINAL, 500);
+
+    assertEquals(expectedWidth, transform.givenWidth);
+  }
+
+  @Test
+  public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
+    SizeTrackingTransform transform = new SizeTrackingTransform();
+
+    int expectedHeight = 500;
+    Resource<Bitmap> resource = mockResource(123, expectedHeight);
+    transform.transform(resource, 444, expectedHeight);
+
+    assertEquals(expectedHeight, transform.givenHeight);
+  }
+
+  @SuppressWarnings("unchecked")
+  private Resource<Bitmap> mockResource(int width, int height) {
+    Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+    Resource<Bitmap> resource = mock(Resource.class);
+    when(resource.get()).thenReturn(bitmap);
+    return resource;
+  }
+
+  private class SizeTrackingTransform extends BitmapTransformation {
+    int givenWidth;
+    int givenHeight;
+
+    public SizeTrackingTransform() {
+      super(bitmapPool);
+    }
+
+    @Override
+    protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
+        int outHeight) {
+      givenWidth = outWidth;
+      givenHeight = outHeight;
+      return null;
+    }
+
+    @Override
+    public void updateDiskCacheKey(MessageDigest messageDigest) { }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
new file mode 100644
index 000000000..53359e2f7
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -0,0 +1,146 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class CenterCropTest {
+  @Mock Resource<Bitmap> resource;
+  @Mock BitmapPool pool;
+  @Mock Transformation<Bitmap> transformation;
+
+  private CenterCrop centerCrop;
+  private int bitmapWidth;
+  private int bitmapHeight;
+  private Bitmap bitmap;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    bitmapWidth = 100;
+    bitmapHeight = 100;
+    bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
+    when(resource.get()).thenReturn(bitmap);
+
+    when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Util.CreateBitmap());
+
+    centerCrop = new CenterCrop(pool);
+  }
+
+  @Test
+  public void testDoesNotPutNullBitmapAcquiredFromPool() {
+    reset(pool);
+    when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(null);
+
+    centerCrop.transform(resource, 100, 100);
+
+    verify(pool, never()).put(any(Bitmap.class));
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfMatchesSizeExactly() {
+    Resource<Bitmap> result =
+        centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
+    centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testDoesNotRecycleGivenResource() {
+    centerCrop.transform(resource, 50, 50);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
+    Shadows.shadowOf(bitmap).setConfig(null);
+
+    centerCrop.transform(resource, 10, 10);
+
+    verify(pool).get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888));
+    verify(pool, never()).get(anyInt(), anyInt(), (Bitmap.Config) isNull());
+  }
+
+  @Test
+  public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarget() {
+    int expectedWidth = 75;
+    int expectedHeight = 74;
+
+    for (int[] dimens : new int[][] { new int[] { 800, 200 }, new int[] { 450, 100 },
+        new int[] { 78, 78 } }) {
+      Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
+      when(resource.get()).thenReturn(toTransform);
+
+      Resource<Bitmap> result =
+          centerCrop.transform(resource, expectedWidth, expectedHeight);
+      Bitmap transformed = result.get();
+      assertEquals(expectedWidth, transformed.getWidth());
+      assertEquals(expectedHeight, transformed.getHeight());
+    }
+  }
+
+  @Test
+  public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarget() {
+    int expectedWidth = 100;
+    int expectedHeight = 100;
+
+    for (int[] dimens : new int[][] { new int[] { 50, 90 }, new int[] { 150, 2 },
+        new int[] { 78, 78 } }) {
+      Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
+      when(resource.get()).thenReturn(toTransform);
+
+      Resource<Bitmap> result =
+          centerCrop.transform(resource, expectedWidth, expectedHeight);
+      Bitmap transformed = result.get();
+      assertEquals(expectedWidth, transformed.getWidth());
+      assertEquals(expectedHeight, transformed.getHeight());
+    }
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    KeyAssertions.assertSame(centerCrop, new CenterCrop(pool));
+
+    doAnswer(new Util.WriteDigest("other")).when(transformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertDifferent(centerCrop, transformation);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
new file mode 100644
index 000000000..63bd65c10
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -0,0 +1,117 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.when;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Rect;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class CircleCropTest {
+  @Mock private BitmapPool bitmapPool;
+
+  private CircleCrop circleCrop;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Util.CreateBitmap());
+    circleCrop = new CircleCrop(RuntimeEnvironment.application);
+  }
+
+  @Test
+  public void testTransform_withSquare() {
+    Bitmap redSquare = createSolidRedBitmap(50, 50);
+    Bitmap result = circleCrop.transform(bitmapPool, redSquare, 50, 50);
+    Bitmap expected = createBitmapWithRedCircle(50, 50);
+
+    assertSamePixels(expected, result);
+  }
+
+  @Test
+  public void testTransform_reusesBitmap() {
+    Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+    when(bitmapPool.get(50, 50, Bitmap.Config.ARGB_8888)).thenReturn(toReuse);
+
+    Bitmap redSquare = createSolidRedBitmap(50, 50);
+    Bitmap result = circleCrop.transform(bitmapPool, redSquare, 50, 50);
+
+    assertEquals(toReuse, result);
+  }
+
+  @Test
+  public void testTransform_withWideRectangle() {
+    Bitmap redWideRectangle = createSolidRedBitmap(100, 50);
+    Bitmap result = circleCrop.transform(bitmapPool, redWideRectangle, 80, 50);
+    Bitmap expected = createBitmapWithRedCircle(80, 50);
+
+    assertSamePixels(expected, result);
+  }
+
+  @Test
+  public void testTransform_withNarrowRectangle() {
+    Bitmap redNarrowRectangle = createSolidRedBitmap(20, 50);
+    Bitmap result = circleCrop.transform(bitmapPool, redNarrowRectangle, 40, 80);
+    Bitmap expected = createBitmapWithRedCircle(40, 80);
+
+    assertSamePixels(expected, result);
+  }
+
+  private void assertSamePixels(Bitmap expected, Bitmap actual) {
+    assertEquals(expected.getWidth(), actual.getWidth());
+    assertEquals(expected.getHeight(), actual.getHeight());
+    assertEquals(expected.getConfig(), actual.getConfig());
+    for (int y = 0; y < expected.getHeight(); y++) {
+      for (int x = 0; x < expected.getWidth(); x++) {
+        assertEquals(expected.getPixel(x, y), actual.getPixel(x, y));
+      }
+    }
+  }
+
+  @TargetApi(12)
+  private Bitmap createBitmapWithRedCircle(int width, int height) {
+    Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+    result.setHasAlpha(true);
+    Canvas canvas = new Canvas(result);
+    Paint paint = new Paint();
+    paint.setColor(Color.RED);
+
+    int minEdge = Math.min(width, height);
+    float radius = minEdge / 2f;
+    int left = (width - minEdge) / 2;
+    int top = (height - minEdge) / 2;
+
+    canvas.drawCircle(left + radius, top + radius, radius, paint);
+    return result;
+  }
+
+  private Bitmap createSolidRedBitmap(int width, int height) {
+    Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+    Canvas canvas = new Canvas(result);
+    Paint paint = new Paint();
+    paint.setColor(Color.RED);
+    Rect rect = new Rect(0, 0, width, height);
+    canvas.drawRect(rect, paint);
+    return result;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
new file mode 100644
index 000000000..f68d1e556
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DownsampleStrategyTest {
+
+  @Test
+  public void testAtMost_withSourceSmallerInOneDimensions_returnsScaleFactorForLargestDimension() {
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(100, 200, 200, 200)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(200, 100, 200, 200)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(270, 480, 724, 440)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(400, 200, 200, 200)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(800, 200, 200, 200)).isEqualTo(1 / 4f);
+  }
+
+  @Test
+  public void testAtMost_withSourceExactlyEqualToRequested_returnsScaleFactorOfOne() {
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(1234, 452, 1234, 452)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(341, 122, 341, 122)).isEqualTo(1f);
+  }
+
+  @Test
+  public void testAtMost_withSourceLessThanTwiceRequestedSize_returnsScaleFactorOfTwo() {
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(150, 150, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(101, 101, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(199, 199, 100, 100)).isEqualTo(1 / 2f);
+  }
+
+  @Test
+  public void testAtMost_withSourceGreaterThanRequestedSize_returnsPowerOfTwoScaleFactor() {
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(200, 200, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(300, 300, 100, 100)).isEqualTo(1 / 4f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(400, 400, 100, 100)).isEqualTo(1 / 4f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(1000, 200, 100, 100)).isEqualTo(1 / 16f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(1000, 1000, 100, 100)).isEqualTo(1 / 16f);
+  }
+
+  @Test
+  public void testAtMost_withSourceGreaterInOneDimension_returnsScaleFactorOfLargestDimension() {
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(101, 200, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(199, 200, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(400, 200, 100, 100)).isEqualTo(1 / 4f);
+    assertThat(DownsampleStrategy.AT_MOST.getScaleFactor(1000, 400, 100, 100)).isEqualTo(1 / 16f);
+  }
+
+  @Test
+  public void testAtLeast_withSourceSmallerInOneDimension_returnsScaleFactorOfOne() {
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(100, 200, 200, 200)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(200, 100, 200, 200)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(270, 480, 724, 440)).isEqualTo(1f);
+  }
+
+  @Test
+  public void testAtLeast_withSourceExactlyEqualToRequested_returnsScaleFactorOfOne() {
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(1234, 452, 1234, 452)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(341, 122, 341, 122)).isEqualTo(1f);
+  }
+
+  @Test
+  public void testAtLeast_withSourceLessThanTwiceRequestedSize_returnsScaleFactorOfOne() {
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(150, 150, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(101, 101, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(199, 199, 100, 100)).isEqualTo(1f);
+  }
+
+  @Test
+  public void testAtLeast_withSourceGreaterThanRequestedSize_returnsPowerOfTwoScaleFactor() {
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(200, 200, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(300, 300, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(400, 400, 100, 100)).isEqualTo(1 / 4f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(1000, 200, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(1000, 1000, 100, 100)).isEqualTo(1 / 8f);
+  }
+
+  @Test
+  public void testAtLeast_withSourceGreaterInOneDimension_returnsScaleFactorOfSmallestDimension() {
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(101, 200, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(199, 200, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(400, 200, 100, 100)).isEqualTo(1 / 2f);
+    assertThat(DownsampleStrategy.AT_LEAST.getScaleFactor(1000, 400, 100, 100)).isEqualTo(1 / 4f);
+  }
+
+  @Test
+  public void testCenterInside_scalesImageToFitWithinRequestedBounds() {
+    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 200, 300, 300))
+        .isEqualTo(300 / 200f);
+    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(270, 480, 724, 440))
+        .isEqualTo(440 / 480f);
+    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+  }
+
+  @Test
+  public void testCenterOutside_scalesImageToFitAroundRequestedBounds() {
+    assertThat(DownsampleStrategy.CENTER_OUTSIDE.getScaleFactor(100, 200, 300, 300))
+        .isEqualTo(300 / 100f);
+    assertThat(DownsampleStrategy.CENTER_OUTSIDE.getScaleFactor(270, 480, 724, 440))
+        .isEqualTo(724 / 270f);
+    assertThat(DownsampleStrategy.CENTER_OUTSIDE.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+  }
+
+  @Test
+  public void testNone_alwaysReturnsOne() {
+    assertThat(DownsampleStrategy.NONE.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.NONE.getScaleFactor(200, 200, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.NONE.getScaleFactor(100, 100, 200, 200)).isEqualTo(1f);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
new file mode 100644
index 000000000..c88e3081a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -0,0 +1,194 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.collect.Range.closed;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.util.DisplayMetrics;
+
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 19, shadows = AllocationSizeBitmap.class)
+public class DownsamplerTest {
+  @Mock private BitmapPool bitmapPool;
+  @Mock private ByteArrayPool byteArrayPool;
+  private Downsampler downsampler;
+  private Options options;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+    options = new Options();
+    DisplayMetrics displayMetrics =
+        RuntimeEnvironment.application.getResources().getDisplayMetrics();
+    when(byteArrayPool.get(anyInt()))
+        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+    downsampler = new Downsampler(displayMetrics, bitmapPool, byteArrayPool);
+  }
+
+  @Test
+  public void testAlwaysArgb8888() throws IOException {
+    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
+
+    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_ARGB_8888);
+    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
+    assertEquals(Bitmap.Config.ARGB_8888, result.get().getConfig());
+  }
+
+  @Test
+  public void testPreferRgb565() throws IOException {
+    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
+
+    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_RGB_565);
+    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
+    assertEquals(Bitmap.Config.RGB_565, result.get().getConfig());
+  }
+
+  @Test
+  public void testCalculateScaling_withInvalidSourceSizes_doesNotCrash() {
+    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_MOST, 0, 0);
+    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.AT_MOST, -1, -1);
+    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_LEAST, 0, 0);
+    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.CENTER_OUTSIDE, -1, -1);
+  }
+
+  @Test
+  public void testCalculateScaling_withAtMost() {
+    DownsampleStrategy strategy = DownsampleStrategy.AT_MOST;
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
+    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
+    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
+    runScaleTest(300, 300, 100, 100, strategy, 75, 75);
+    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
+    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
+    runScaleTest(801, 100, 100, 100, strategy, 50, 6);
+    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
+    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
+  }
+
+  @Test
+  public void testCalculateScaling_withAtLeast() {
+    DownsampleStrategy strategy = DownsampleStrategy.AT_LEAST;
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
+    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
+    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
+    runScaleTest(300, 300, 100, 100, strategy, 150, 150);
+    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
+    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
+    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
+    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
+    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
+  }
+
+  @Test
+  public void testCalculateScaling_withCenterInside() {
+    DownsampleStrategy strategy = DownsampleStrategy.CENTER_INSIDE;
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
+    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
+    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
+    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
+    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
+    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
+    runScaleTest(801, 100, 100, 100, strategy, 100, 13);
+    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
+    runScaleTest(87, 78, 100, 100, strategy, 100, 90);
+  }
+
+  @Test
+  public void testCalculateScaling_withCenterOutside() {
+    DownsampleStrategy strategy = DownsampleStrategy.CENTER_OUTSIDE;
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
+    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
+    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
+    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
+    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
+    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
+    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
+    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
+    runScaleTest(87, 78, 100, 100, strategy, 112, 100);
+  }
+
+  @Test
+  public void testCalculateScaling_withNone() {
+    DownsampleStrategy strategy = DownsampleStrategy.NONE;
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
+    runScaleTest(200, 200, 100, 100, strategy, 200, 200);
+    runScaleTest(400, 400, 100, 100, strategy, 400, 400);
+    runScaleTest(300, 300, 100, 100, strategy, 300, 300);
+    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
+    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
+    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
+    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
+    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
+  }
+
+  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
+      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
+        options);
+    assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
+  }
+
+  private static void assertSize(int sourceWidth, int sourceHeight, int expectedWidth,
+      int expectedHeight, BitmapFactory.Options options) {
+    float sampleSize = Math.max(1, options.inSampleSize);
+    int downsampledWidth = (int) ((sourceWidth / sampleSize) + 0.5f);
+    int downsampledHeight = (int) ((sourceHeight / sampleSize) + 0.5f);
+
+    float scaleFactor = options.inScaled && options.inTargetDensity > 0 && options.inDensity > 0
+        ? options.inTargetDensity / (float) options.inDensity : 1f;
+    int scaledWidth = (int) Math.ceil(downsampledWidth * scaleFactor);
+    int scaledHeight = (int) Math.ceil(downsampledHeight * scaleFactor);
+
+    assertThat(scaledWidth).isIn(closed(expectedWidth, expectedWidth + 1));
+    assertThat(scaledHeight).isIn(closed(expectedHeight, expectedHeight + 1));
+  }
+
+  private InputStream compressBitmap(Bitmap bitmap, Bitmap.CompressFormat compressFormat)
+      throws FileNotFoundException {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(compressFormat, 100, os);
+    return new ByteArrayInputStream(os.toByteArray());
+  }
+
+  // Robolectric doesn't implement getAllocationByteCount correctly.
+  @Implements(Bitmap.class)
+  public static class AllocationSizeBitmap extends ShadowBitmap {
+
+    @Implementation
+    public int getAllocationByteCount() {
+      return getWidth() * getHeight() * (getConfig() == Bitmap.Config.ARGB_8888 ? 4 : 2);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
new file mode 100644
index 000000000..a140022d8
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -0,0 +1,100 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowCanvas;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { FitCenterTest.DrawNothingCanvas.class })
+public class FitCenterTest {
+
+  @Mock Resource<Bitmap> resource;
+  @Mock Transformation<Bitmap> transformation;
+  private BitmapPool pool;
+  private FitCenter fitCenter;
+  private int bitmapWidth;
+  private int bitmapHeight;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    bitmapWidth = 100;
+    bitmapHeight = 100;
+    Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
+    when(resource.get()).thenReturn(bitmap);
+
+    pool = new BitmapPoolAdapter();
+
+    fitCenter = new FitCenter(pool);
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfMatchesSizeExactly() {
+    Resource<Bitmap> result =
+        fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
+    fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testDoesNotRecycleGivenResource() {
+    fitCenter.transform(resource, 50, 50);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    KeyAssertions.assertSame(fitCenter, new FitCenter(pool));
+
+    doAnswer(new Util.WriteDigest("other")).when(transformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertDifferent(fitCenter, transformation);
+  }
+
+  @Implements(Canvas.class)
+  public static final class DrawNothingCanvas extends ShadowCanvas {
+
+    @Implementation
+    @Override
+    public void drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
new file mode 100644
index 000000000..705246076
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
@@ -0,0 +1,229 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
+import com.bumptech.glide.testutil.TestResourceUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.Util;
+
+import java.io.ByteArrayInputStream;
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ImageHeaderParserTest {
+
+  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
+      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
+          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
+
+  private LruByteArrayPool byteArrayPool;
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruByteArrayPool();
+  }
+
+  @Test
+  public void testCanParsePngType() throws IOException {
+    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
+    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.PNG, parser.getType());
+      }
+    });
+  }
+
+  @Test
+  public void testCanParsePngWithAlpha() throws IOException {
+    for (int i = 3; i <= 6; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(ImageHeaderParser parser) throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType());
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParsePngWithoutAlpha() throws IOException {
+    for (int i = 0; i < 3; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(ImageHeaderParser parser) throws IOException {
+          assertEquals(ImageType.PNG, parser.getType());
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParseJpegType() throws IOException {
+    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType());
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseGifType() throws IOException {
+    byte[] data = new byte[] { 'G', 'I', 'F' };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.GIF, parser.getType());
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
+    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType());
+      }
+    });
+  }
+
+  // Test for #286.
+  @Test
+  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
+    byte[] data =
+        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(-1, parser.getOrientation());
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownForEmptyData() throws IOException {
+    runTest(new byte[0], new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType());
+      }
+    });
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialReads() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is), byteArrayPool);
+    assertThat(parser.getOrientation()).isEqualTo(6);
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialSkips() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is), byteArrayPool);
+    assertThat(parser.getOrientation()).isEqualTo(6);
+  }
+
+  @Test
+  public void testHandlesSometimesZeroSkips() throws IOException {
+    InputStream is = new ByteArrayInputStream(
+        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
+    ImageHeaderParser parser =
+        new ImageHeaderParser(new SometimesZeroSkipInputStream(is), byteArrayPool);
+    assertEquals(ImageType.PNG, parser.getType());
+  }
+
+  private interface ParserTestCase {
+    void run(ImageHeaderParser parser) throws IOException;
+  }
+
+  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
+    InputStream is = new ByteArrayInputStream(data);
+    ImageHeaderParser parser = new ImageHeaderParser(is, new LruByteArrayPool());
+    test.run(parser);
+
+    ByteBuffer buffer = ByteBuffer.wrap(data);
+    parser = new ImageHeaderParser(buffer, new LruByteArrayPool());
+    test.run(parser);
+  }
+
+  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
+    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
+    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
+    result[result.length - 1] = (byte) bitDepth;
+    return result;
+  }
+
+  private static class SometimesZeroSkipInputStream extends FilterInputStream {
+    boolean returnZeroFlag = true;
+
+    protected SometimesZeroSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      final long result;
+      if (returnZeroFlag) {
+        result = 0;
+      } else {
+        result = super.skip(byteCount);
+      }
+      returnZeroFlag = !returnZeroFlag;
+      return result;
+    }
+  }
+
+  private static class PartialSkipInputStream extends FilterInputStream {
+
+    protected PartialSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+        long toActuallySkip = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallySkip = 1;
+        }
+        return super.skip(toActuallySkip);
+    }
+  }
+
+  private static class PartialReadInputStream extends FilterInputStream {
+
+    protected PartialReadInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        int toActuallyRead = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallyRead = 1;
+        }
+        return super.read(buffer, byteOffset, toActuallyRead);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
new file mode 100644
index 000000000..c8edbaeac
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -0,0 +1,291 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class RecyclableBufferedInputStreamTest {
+
+  private static final int DATA_SIZE = 30;
+  private static final int BUFFER_SIZE = 10;
+
+  private RecyclableBufferedInputStream stream;
+  private byte[] data;
+  private LruByteArrayPool byteArrayPool;
+
+  @Before
+  public void setUp() {
+    data = new byte[DATA_SIZE];
+    for (int i = 0; i < DATA_SIZE; i++) {
+      data[i] = (byte) i;
+    }
+
+    byteArrayPool = new LruByteArrayPool();
+    InputStream wrapped = new ByteArrayInputStream(data);
+    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);
+  }
+
+  @Test
+  public void testReturnsTrueForMarkSupported() {
+    assertTrue(stream.markSupported());
+  }
+
+  @Test
+  public void testCanReadIndividualBytes() throws IOException {
+    for (int i = 0; i < data.length; i++) {
+      assertEquals(i, stream.read());
+    }
+    assertEquals(-1, stream.read());
+  }
+
+  @Test
+  public void testCanReadBytesInBulkLargerThanBufferSize() throws IOException {
+    byte[] buffer = new byte[DATA_SIZE];
+    assertEquals(DATA_SIZE, stream.read(buffer, 0, DATA_SIZE));
+    for (int i = 0; i < DATA_SIZE; i++) {
+      assertEquals(i, buffer[i]);
+    }
+  }
+
+  @Test
+  public void testCanReadBytesInBulkSmallerThanBufferSize() throws IOException {
+    int toRead = BUFFER_SIZE / 2;
+    byte[] buffer = new byte[toRead];
+    assertEquals(toRead, stream.read(buffer, 0, toRead));
+    for (int i = 0; i < toRead; i++) {
+      assertEquals(i, buffer[i]);
+    }
+  }
+
+  @Test
+  public void testReadingZeroBytesIntoBufferReadsZeroBytes() throws IOException {
+    // Make sure the next value is not 0.
+    stream.read();
+    byte[] buffer = new byte[BUFFER_SIZE];
+    assertEquals(0, stream.read(buffer, 0, 0));
+
+    for (int i = 0; i < BUFFER_SIZE; i++) {
+      assertEquals(0, buffer[i]);
+    }
+  }
+
+  @Test
+  public void testCanReadIntoBufferLargerThanDataSize() throws IOException {
+    int toRead = DATA_SIZE * 2;
+    byte[] buffer = new byte[toRead];
+    assertEquals(DATA_SIZE, stream.read(buffer, 0, toRead));
+    for (int i = 0; i < DATA_SIZE; i++) {
+      assertEquals(i, buffer[i]);
+    }
+    for (int i = DATA_SIZE; i < toRead; i++) {
+      assertEquals(0, buffer[i]);
+    }
+  }
+
+  @Test
+  public void testCanReadBytesInBulkWithLimit() throws IOException {
+    int toRead = BUFFER_SIZE / 2;
+    byte[] buffer = new byte[BUFFER_SIZE];
+    assertEquals(toRead, stream.read(buffer, 0, toRead));
+
+    // 0, 1, 2, 3, 4, 0, 0, 0, 0, 0
+    for (int i = 0; i < toRead; i++) {
+      assertEquals(i, buffer[i]);
+    }
+    for (int i = toRead; i < BUFFER_SIZE; i++) {
+      assertEquals(0, buffer[i]);
+    }
+  }
+
+  @Test
+  public void testCanReadBytesInBulkWithOffset() throws IOException {
+    int toRead = BUFFER_SIZE / 2;
+    byte[] buffer = new byte[BUFFER_SIZE];
+    assertEquals(toRead, stream.read(buffer, BUFFER_SIZE - toRead, toRead));
+    // 0, 0, 0, 0, 0, 0, 1, 2, 3, 4
+    for (int i = 0; i < toRead; i++) {
+      assertEquals(0, buffer[i]);
+    }
+    for (int i = toRead; i < BUFFER_SIZE; i++) {
+      assertEquals(i - toRead, buffer[i]);
+    }
+  }
+
+  @Test
+  public void testCanReadBytesInBulkWhenSomeButNotAllBytesAreInBuffer() throws IOException {
+    stream.read();
+    byte[] buffer = new byte[BUFFER_SIZE];
+    assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
+    for (int i = 1; i < BUFFER_SIZE + 1; i++) {
+      assertEquals(i, buffer[i - 1]);
+    }
+  }
+
+  @Test
+  public void testCanSkipBytes() throws IOException {
+    int toSkip = data.length / 2;
+    assertEquals(toSkip, stream.skip(toSkip));
+    for (int i = toSkip; i < data.length; i++) {
+      assertEquals(i, stream.read());
+    }
+    assertEquals(-1, stream.read());
+  }
+
+  @Test
+  public void testSkipReturnsZeroIfSkipByteCountIsZero() throws IOException {
+    assertEquals(0, stream.skip(0));
+    assertEquals(0, stream.read());
+  }
+
+  @Test
+  public void testSkipReturnsZeroIfSkipByteCountIsNegative() throws IOException {
+    assertEquals(0, stream.skip(-13));
+    assertEquals(0, stream.read());
+  }
+
+  @Test
+  public void testCloseClosesWrappedStream() throws IOException {
+    InputStream wrapped = mock(InputStream.class);
+    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool);
+    stream.close();
+    verify(wrapped).close();
+  }
+
+  @Test
+  public void testCanSafelyBeClosedMultipleTimes() throws IOException {
+    InputStream wrapped = mock(InputStream.class);
+    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool);
+    stream.close();
+    stream.close();
+    stream.close();
+
+    verify(wrapped, times(1)).close();
+  }
+
+  @Test
+  public void testCanMarkAndReset() throws IOException {
+    byte[] buffer = new byte[BUFFER_SIZE];
+    stream.mark(BUFFER_SIZE);
+    assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
+    for (int i = 0; i < BUFFER_SIZE; i++) {
+      assertEquals(i, buffer[i]);
+    }
+    Arrays.fill(buffer, (byte) 0);
+    stream.reset();
+
+    assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
+    for (int i = 0; i < BUFFER_SIZE; i++) {
+      assertEquals(i, buffer[i]);
+    }
+  }
+
+  @Test
+  public void testCanResetRepeatedlyAfterMarking() throws IOException {
+    byte[] buffer = new byte[BUFFER_SIZE];
+    stream.mark(BUFFER_SIZE);
+    for (int repeat = 0; repeat < 10; repeat++) {
+      assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
+      for (int i = 0; i < BUFFER_SIZE; i++) {
+        assertEquals(i, buffer[i]);
+      }
+      stream.reset();
+    }
+  }
+
+  @Test
+  public void testCanMarkInMiddleOfBufferAndStillReadUpToBufferLengthBeforeResetting()
+      throws IOException {
+    int markPos = BUFFER_SIZE / 2;
+    for (int i = 0; i < markPos; i++) {
+      stream.read();
+    }
+    stream.mark(BUFFER_SIZE);
+
+    for (int i = 0; i < BUFFER_SIZE; i++) {
+      stream.read();
+    }
+
+    stream.reset();
+    assertEquals(markPos, stream.read());
+  }
+
+  @Test
+  public void testAvailableReturnsWrappedAvailableIfNoBytesRead() throws IOException {
+    assertEquals(DATA_SIZE, stream.available());
+  }
+
+  @Test
+  public void testAvailableIncludesDataInBufferAndWrappedAvailableIfBytesRead() throws IOException {
+    stream.read();
+    assertEquals(DATA_SIZE - 1, stream.available());
+  }
+
+  @Test(expected = IOException.class)
+  public void testCloseThrowsIfWrappedStreamThrowsOnClose() throws IOException {
+    InputStream wrapped = mock(InputStream.class);
+    doThrow(new IOException()).when(wrapped).close();
+    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool);
+    stream.close();
+  }
+
+  @Test(expected = IOException.class)
+  public void testAvailableThrowsIfStreamIsClosed() throws IOException {
+    stream.close();
+    stream.available();
+  }
+
+  @Test(expected = IOException.class)
+  public void testReadThrowsIfStreamIsClosed() throws IOException {
+    stream.close();
+    stream.read();
+  }
+
+  @Test(expected = IOException.class)
+  public void testReadBulkThrowsIfStreamIsClosed() throws IOException {
+    stream.close();
+    stream.read(new byte[1], 0, 1);
+  }
+
+  @Test(expected = IOException.class)
+  public void testResetThrowsIfStreamIsClosed() throws IOException {
+    stream.close();
+    stream.reset();
+  }
+
+  @Test(expected = IOException.class)
+  public void testSkipThrowsIfStreamIsClosed() throws IOException {
+    stream.close();
+    stream.skip(10);
+  }
+
+  @Test(expected = RecyclableBufferedInputStream.InvalidMarkException.class)
+  public void testResetThrowsIfMarkNotSet() throws IOException {
+    stream.reset();
+  }
+
+  @Test(expected = RecyclableBufferedInputStream.InvalidMarkException.class)
+  public void testResetThrowsIfMarkIsInvalid() throws IOException {
+    stream.mark(1);
+    stream.read(new byte[BUFFER_SIZE], 0, BUFFER_SIZE);
+    stream.read();
+    stream.reset();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
new file mode 100644
index 000000000..24bd56cad
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -0,0 +1,468 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.Range;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.Matrix;
+import android.media.ExifInterface;
+import android.os.Build;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
+
+@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = {
+    TransformationUtilsTest.AlphaShadowBitmap.class })
+public class TransformationUtilsTest {
+
+  @Mock BitmapPool bitmapPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Util.CreateBitmap());
+  }
+
+  @Test
+  public void testFitCenterWithWideBitmap() {
+    final int maxSide = 500;
+
+    Bitmap wide = Bitmap.createBitmap(2000, 100, Bitmap.Config.ARGB_8888);
+
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, wide, maxSide, maxSide);
+
+    assertHasOriginalAspectRatio(wide, transformed);
+    assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+  }
+
+  @Test
+  public void testFitCenterWithSmallWideBitmap() {
+    final int maxSide = 500;
+
+    Bitmap smallWide = Bitmap.createBitmap(400, 40, Bitmap.Config.ARGB_8888);
+
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, smallWide, maxSide, maxSide);
+
+    assertHasOriginalAspectRatio(smallWide, transformed);
+    assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+  }
+
+  @Test
+  public void testFitCenterWithTallBitmap() {
+    final int maxSide = 500;
+
+    Bitmap tall = Bitmap.createBitmap(65, 3000, Bitmap.Config.ARGB_8888);
+
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, tall, maxSide, maxSide);
+
+    assertHasOriginalAspectRatio(tall, transformed);
+    assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+  }
+
+  @Test
+  public void testFitCenterWithSmallTallBitmap() {
+    final int maxSide = 500;
+
+    Bitmap smallTall = Bitmap.createBitmap(10, 400, Bitmap.Config.ARGB_8888);
+
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, smallTall, maxSide, maxSide);
+
+    assertHasOriginalAspectRatio(smallTall, transformed);
+    assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+  }
+
+  @Test
+  public void testFitCenterWithSquareBitmap() {
+    final int maxSide = 500;
+
+    Bitmap square = Bitmap.createBitmap(600, 600, Bitmap.Config.ARGB_8888);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, square, maxSide, maxSide);
+
+    assertHasOriginalAspectRatio(square, transformed);
+    assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+  }
+
+  @Test
+  public void testFitCenterWithTooSmallSquareBitmap() {
+    final int maxSide = 500;
+
+    Bitmap smallSquare = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, smallSquare, maxSide, maxSide);
+
+    assertHasOriginalAspectRatio(smallSquare, transformed);
+    assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+  }
+
+  // Test for Issue #195.
+  @Test
+  public void testFitCenterUsesFloorInsteadOfRoundingForOutputBitmapSize() {
+    Bitmap toTransform = Bitmap.createBitmap(1230, 1640, Bitmap.Config.RGB_565);
+
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toTransform, 1075, 1366);
+
+    assertEquals(1024, transformed.getWidth());
+    assertEquals(1366, transformed.getHeight());
+  }
+
+  @Test
+  public void testFitCenterReturnsGivenBitmapIfGivenBitmapMatchesExactly() {
+    Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth(),
+        toFit.getHeight());
+    assertTrue(toFit == transformed);
+  }
+
+  @Test
+  public void testFitCenterReturnsGivenBitmapIfGivenBitmapWidthMatchesExactly() {
+    Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
+    Bitmap transformed =
+        TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth(), toFit.getHeight() * 2);
+    assertTrue(toFit == transformed);
+  }
+
+  @Test
+  public void testFitCenterReturnsGivenBitmapIfGivenBitmapHeightMatchesExactly() {
+    Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
+    Bitmap transformed =
+        TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth() * 2, toFit.getHeight());
+    assertTrue(toFit == transformed);
+  }
+
+  @Test
+  public void testCenterCropReturnsGivenBitmapIfGivenBitmapExactlyMatchesGivenDimensions() {
+    Bitmap toCrop = Bitmap.createBitmap(200, 300, Bitmap.Config.ARGB_8888);
+    Bitmap transformed = TransformationUtils
+        .centerCrop(bitmapPool, toCrop, toCrop.getWidth(), toCrop.getHeight());
+
+    // Robolectric incorrectly implements equals() for Bitmaps, we want the original object not
+    // just an equivalent.
+    assertTrue(toCrop == transformed);
+  }
+
+  @Test
+  public void testFitCenterHandlesBitmapsWithNullConfigs() {
+    Bitmap toFit = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    Shadows.shadowOf(toFit).setConfig(null);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toFit, 50, 50);
+    assertEquals(Bitmap.Config.ARGB_8888, transformed.getConfig());
+  }
+
+  @Test
+  public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+    reset(bitmapPool);
+    when(bitmapPool.get(eq(50), eq(50), eq(Bitmap.Config.ARGB_8888)))
+        .thenReturn(toReuse);
+
+    toReuse.setHasAlpha(false);
+    toTransform.setHasAlpha(true);
+
+    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform, toReuse.getWidth(),
+        toReuse.getHeight());
+
+    assertEquals(toReuse, result);
+    assertTrue(result.hasAlpha());
+  }
+
+  @Test
+  public void
+  testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+    reset(bitmapPool);
+    when(bitmapPool.get(eq(50), eq(50), eq(Bitmap.Config.ARGB_8888))).thenReturn(toReuse);
+
+    toReuse.setHasAlpha(true);
+    toTransform.setHasAlpha(false);
+
+    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform, toReuse.getWidth(),
+        toReuse.getHeight());
+
+    assertEquals(toReuse, result);
+    assertFalse(result.hasAlpha());
+  }
+
+  @Test
+  public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    toTransform.setHasAlpha(true);
+
+    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform,
+        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+
+    assertTrue(result.hasAlpha());
+  }
+
+  @Test
+  public void testCenterCropHandlesBitmapsWithNullConfigs() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    Shadows.shadowOf(toTransform).setConfig(null);
+
+    Bitmap transformed = TransformationUtils.centerCrop(bitmapPool, toTransform, 50, 50);
+
+    assertEquals(Bitmap.Config.ARGB_8888, transformed.getConfig());
+  }
+
+  @Test
+  public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    toTransform.setHasAlpha(false);
+
+    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform,
+        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+
+    assertFalse(result.hasAlpha());
+  }
+
+  @Test
+  public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+    reset(bitmapPool);
+    when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
+        .thenReturn(toReuse);
+
+    toReuse.setHasAlpha(false);
+    toTransform.setHasAlpha(true);
+
+    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform, toReuse.getWidth(),
+        toReuse.getHeight());
+
+    assertEquals(toReuse, result);
+    assertTrue(result.hasAlpha());
+  }
+
+  @Test
+  public void
+  testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+    reset(bitmapPool);
+    when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
+        .thenReturn(toReuse);
+
+    toReuse.setHasAlpha(true);
+    toTransform.setHasAlpha(false);
+
+    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform, toReuse.getWidth(),
+        toReuse.getHeight());
+
+    assertEquals(toReuse, result);
+    assertFalse(result.hasAlpha());
+  }
+
+  @Test
+  public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    toTransform.setHasAlpha(true);
+
+    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform,
+        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+
+    assertTrue(result.hasAlpha());
+  }
+
+  @Test
+  public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
+    Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    toTransform.setHasAlpha(false);
+
+    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform,
+        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+
+    assertFalse(result.hasAlpha());
+  }
+
+  private static void assertHasOriginalAspectRatio(Bitmap original, Bitmap transformed) {
+    double originalAspectRatio = (double) original.getWidth() / (double) original.getHeight();
+    double transformedAspectRatio =
+        (double) transformed.getWidth() / (double) transformed.getHeight();
+
+    assertThat(transformedAspectRatio)
+        .isIn(Range.open(originalAspectRatio - 0.05f, originalAspectRatio + 0.05f));
+  }
+
+  private static void assertBitmapFitsExactlyWithinBounds(int maxSide, Bitmap bitmap) {
+    final int width = bitmap.getWidth();
+    final int height = bitmap.getHeight();
+
+    assertThat(width).isIn(Range.atMost(maxSide));
+    assertThat(height).isIn(Range.atMost(maxSide));
+
+    assertTrue("one side must match maxSide", width == maxSide || height == maxSide);
+  }
+
+  @Test
+  public void testGetExifOrientationDegrees() {
+    assertEquals(0,
+        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_NORMAL));
+    assertEquals(90,
+        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSPOSE));
+    assertEquals(90,
+        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_90));
+    assertEquals(180,
+        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_180));
+    assertEquals(180,
+        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_FLIP_VERTICAL));
+    assertEquals(270,
+        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSVERSE));
+    assertEquals(270,
+        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_270));
+  }
+
+  @Test
+  public void testRotateImage() {
+    Bitmap toRotate = Bitmap.createBitmap(2, 2, Bitmap.Config.ARGB_8888);
+
+    Bitmap zero = TransformationUtils.rotateImage(toRotate, 0);
+    assertTrue(toRotate == zero);
+
+    Bitmap ninety = TransformationUtils.rotateImage(toRotate, 90);
+    assertTrue(Shadows.shadowOf(ninety).getDescription().contains("rotate=90.0"));
+    assertEquals(toRotate.getWidth(), toRotate.getHeight());
+  }
+
+  @Test
+  public void testRotateImageExifReturnsGivenBitmapIfRotationIsNormal() {
+    Bitmap toRotate = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
+    // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want
+    // not just an identical Bitmap, but our original Bitmap object back.
+    Bitmap rotated =
+        TransformationUtils.rotateImageExif(bitmapPool, toRotate, ExifInterface.ORIENTATION_NORMAL);
+    assertTrue(toRotate == rotated);
+  }
+
+  @Test
+  public void testRotateImageExifReturnsGivenBitmapIfRotationIsUndefined() {
+    Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want
+    // not just an identical Bitmap, but our original Bitmap object back.
+    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
+        ExifInterface.ORIENTATION_UNDEFINED);
+    assertTrue(toRotate == rotated);
+  }
+
+  @Test
+  public void testRotateImageExifReturnsGivenBitmapIfOrientationIsInvalid() {
+    Bitmap toRotate = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
+    // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want
+    // not just an identical Bitmap, but our original Bitmap object back.
+    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate, -1);
+    assertTrue(toRotate == rotated);
+  }
+
+  @Test
+  public void testRotateImageExifHandlesBitmapsWithNullConfigs() {
+    Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    Shadows.shadowOf(toRotate).setConfig(null);
+    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
+        ExifInterface.ORIENTATION_ROTATE_180);
+    assertEquals(Bitmap.Config.ARGB_8888, rotated.getConfig());
+  }
+
+  @Test
+  public void testInitializeMatrixSetsScaleIfFlipHorizontal() {
+    Matrix matrix = mock(Matrix.class);
+    TransformationUtils
+        .initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_HORIZONTAL, matrix);
+    verify(matrix).setScale(-1, 1);
+  }
+
+  @Test
+  public void testInitializeMatrixSetsScaleAndRotateIfFlipVertical() {
+    Matrix matrix = mock(Matrix.class);
+    TransformationUtils
+        .initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_VERTICAL, matrix);
+    verify(matrix).setRotate(180);
+    verify(matrix).postScale(-1, 1);
+  }
+
+  @Test
+  public void testInitializeMatrixSetsScaleAndRotateIfTranspose() {
+    Matrix matrix = mock(Matrix.class);
+    TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_TRANSPOSE, matrix);
+    verify(matrix).setRotate(90);
+    verify(matrix).postScale(-1, 1);
+  }
+
+  @Test
+  public void testInitializeMatrixSetsScaleAndRotateIfTransverse() {
+    Matrix matrix = mock(Matrix.class);
+    TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_TRANSVERSE, matrix);
+    verify(matrix).setRotate(-90);
+    verify(matrix).postScale(-1, 1);
+  }
+
+  @Test
+  public void testInitializeMatrixSetsRotateOnRotation() {
+    Matrix matrix = mock(Matrix.class);
+    TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_90, matrix);
+    verify(matrix).setRotate(90);
+    TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_180, matrix);
+    verify(matrix).setRotate(180);
+    TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_270, matrix);
+    verify(matrix).setRotate(-90);
+  }
+
+  @Implements(Bitmap.class)
+  public static class AlphaShadowBitmap extends ShadowBitmap {
+
+    private boolean hasAlpha;
+
+    @Implementation
+    public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
+      // Robolectric doesn't match the framework behavior with null configs, so we have to do so
+      // here.
+      Preconditions.checkNotNull("Config must not be null");
+      return ShadowBitmap.createBitmap(width, height, config);
+    }
+
+    @Implementation
+    public void setHasAlpha(boolean hasAlpha) {
+      this.hasAlpha = hasAlpha;
+    }
+
+    @Implementation
+    public boolean hasAlpha() {
+      return hasAlpha;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
new file mode 100644
index 000000000..b1716d3ac
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
@@ -0,0 +1,100 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.ParcelFileDescriptor;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class VideoBitmapDecoderTest {
+  @Mock private ParcelFileDescriptor resource;
+  @Mock private VideoBitmapDecoder.MediaMetadataRetrieverFactory factory;
+  @Mock private MediaMetadataRetriever retriever;
+  @Mock private BitmapPool bitmapPool;
+  private VideoBitmapDecoder decoder;
+  private Options options;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    when(factory.build()).thenReturn(retriever);
+    decoder = new VideoBitmapDecoder(bitmapPool, factory);
+    options = new Options();
+  }
+
+  @Test
+  public void testReturnsRetrievedFrameForResource() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime()).thenReturn(expected);
+
+    FileDescriptor toSet = FileDescriptor.in;
+    when(resource.getFileDescriptor()).thenReturn(toSet);
+    Resource<Bitmap> result = decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).setDataSource(eq(toSet));
+    assertEquals(expected, result.get());
+  }
+
+  @Test
+  public void testReleasesMediaMetadataRetriever() throws IOException {
+    decoder.decode(resource, 1, 2, options);
+
+    verify(retriever).release();
+  }
+
+  @Test
+  public void testClosesResource() throws IOException {
+    decoder.decode(resource, 1, 2, options);
+
+    verify(resource).close();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
+    options.set(VideoBitmapDecoder.TARGET_FRAME, -5L);
+    new VideoBitmapDecoder(bitmapPool, factory).decode(resource, 100, 100, options);
+  }
+
+  @Test
+  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
+    long frame = 5;
+    options.set(VideoBitmapDecoder.TARGET_FRAME, frame);
+    decoder = new VideoBitmapDecoder(bitmapPool, factory);
+
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(frame);
+    verify(retriever, never()).getFrameAtTime();
+  }
+
+  @Test
+  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
+    decoder = new VideoBitmapDecoder(bitmapPool, factory);
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime();
+    verify(retriever, never()).getFrameAtTime(anyLong());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
new file mode 100644
index 000000000..012e4a8f9
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.load.resource.bytes;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class BytesResourceTest {
+
+  @Test
+  public void testReturnsGivenBytes() {
+    byte[] bytes = new byte[0];
+    BytesResource resource = new BytesResource(bytes);
+
+    assertEquals(bytes, resource.get());
+  }
+
+  @Test
+  public void testReturnsSizeOfGivenBytes() {
+    byte[] bytes = new byte[123];
+    BytesResource resource = new BytesResource(bytes);
+
+    assertEquals(bytes.length, resource.getSize());
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfGivenNullBytes() {
+    new BytesResource(null);
+  }
+
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
new file mode 100644
index 000000000..f95f8bd10
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -0,0 +1,110 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.drawable.Drawable;
+
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DrawableResourceTest {
+  private TestDrawable drawable;
+  private DrawableResource<TestDrawable> resource;
+
+  @Before
+  public void setUp() {
+    drawable = mock(TestDrawable.class);
+    resource = new DrawableResource<TestDrawable>(drawable) {
+      @Override
+      public Class<TestDrawable> getResourceClass() {
+        return TestDrawable.class;
+      }
+
+      @Override
+      public int getSize() {
+        return 0;
+      }
+
+      @Override
+      public void recycle() {
+      }
+    };
+  }
+
+  @Test
+  public void testDoesNotReturnOriginalDrawableOnGet() {
+    when(drawable.getConstantState()).thenReturn(mock(Drawable.ConstantState.class));
+    assertNotEquals(drawable, resource.get());
+  }
+
+  @Test
+  public void testReturnsNewDrawableOnGet() {
+    GifDrawable expected = mock(GifDrawable.class);
+    Drawable.ConstantState constantState = mock(Drawable.ConstantState.class);
+    when(constantState.newDrawable()).thenReturn(expected);
+    when(drawable.getConstantState()).thenReturn(constantState);
+
+    assertEquals(expected, resource.get());
+
+    verify(drawable).getConstantState();
+    verify(constantState).newDrawable();
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfDrawableIsNull() {
+    new DrawableResource<TestDrawable>(null) {
+      @Override
+      public Class<TestDrawable> getResourceClass() {
+        return TestDrawable.class;
+      }
+
+      @Override
+      public int getSize() {
+        return 0;
+      }
+
+      @Override
+      public void recycle() {
+
+      }
+    };
+  }
+
+  /**
+   * Just to have a type to test with which is not directly Drawable
+   */
+  private static class TestDrawable extends Drawable {
+    @Override
+    public void draw(Canvas canvas) {
+
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+
+    }
+
+    @Override
+    public int getOpacity() {
+      return 0;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
new file mode 100644
index 000000000..508316e05
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.resource.file;
+
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.File;
+import java.io.IOException;
+
+@RunWith(JUnit4.class)
+public class FileDecoderTest {
+
+  private FileDecoder decoder;
+  private Options options;
+
+  @Before
+  public void setUp() {
+    decoder = new FileDecoder();
+    options = new Options();
+  }
+
+  @Test
+  public void testReturnsGivenFileAsResource() throws IOException {
+    File expected = new File("testFile");
+    Resource<File> decoded = decoder.decode(expected, 1, 1, options);
+
+    assertEquals(expected, decoded.get());
+  }
+}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
similarity index 50%
rename from library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
rename to library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
index 54bab1508..1cfb5408b 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
@@ -12,17 +12,17 @@
 @RunWith(JUnit4.class)
 public class FileResourceTest {
 
-    private File file;
-    private FileResource resource;
+  private File file;
+  private FileResource resource;
 
-    @Before
-    public void setUp() {
-        file = new File("Test");
-        resource = new FileResource(file);
-    }
+  @Before
+  public void setUp() {
+    file = new File("Test");
+    resource = new FileResource(file);
+  }
 
-    @Test
-    public void testReturnsGivenFile() {
-        assertEquals(file, resource.get());
-    }
-}
\ No newline at end of file
+  @Test
+  public void testReturnsGivenFile() {
+    assertEquals(file, resource.get());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
new file mode 100644
index 000000000..257e50e75
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -0,0 +1,141 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.gifdecoder.GifHeader;
+import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.tests.GlideShadowLooper;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
+public class ByteBufferGifDecoderTest {
+  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+  static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+
+  private ByteBufferGifDecoder decoder;
+  private GifHeader gifHeader;
+  private Options options;
+
+  @Mock BitmapPool bitmapPool;
+  @Mock GifHeaderParser parser;
+  @Mock GifDecoder gifDecoder;
+  @Mock ByteBufferGifDecoder.GifHeaderParserPool parserPool;
+  @Mock ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    gifHeader = Mockito.spy(new GifHeader());
+    when(parser.parseHeader()).thenReturn(gifHeader);
+    when(parserPool.obtain(isA(ByteBuffer.class))).thenReturn(parser);
+
+    when(decoderFactory.build(isA(GifDecoder.BitmapProvider.class),
+        eq(gifHeader), isA(ByteBuffer.class), anyInt()))
+        .thenReturn(gifDecoder);
+
+    options = new Options();
+    decoder =
+        new ByteBufferGifDecoder(
+            RuntimeEnvironment.application,
+            bitmapPool,
+            new LruArrayPool(ARRAY_POOL_SIZE_BYTES),
+            parserPool,
+            decoderFactory);
+  }
+
+  @Test
+  public void testDoesNotHandleStreamIfEnabledButNotAGif() throws IOException {
+    assertThat(decoder.handles(ByteBuffer.allocate(0), options)).isFalse();
+  }
+
+  @Test
+  public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOException {
+    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();
+  }
+
+  @Test
+  public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {
+    options.set(ByteBufferGifDecoder.DISABLE_ANIMATION, false);
+    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();
+  }
+
+  @Test
+  public void testDoesNotHandleStreamIfDisabled() throws IOException {
+    options.set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isFalse();
+  }
+
+  @Test
+  public void testReturnsNullIfParsedHeaderHasZeroFrames() throws IOException {
+    when(gifHeader.getNumFrames()).thenReturn(0);
+
+    assertNull(decoder.decode(ByteBuffer.allocate(10), 100, 100, options));
+  }
+
+  @Test
+  public void testReturnsNullIfParsedHeaderHasFormatError() {
+    when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_FORMAT_ERROR);
+
+    assertNull(decoder.decode(ByteBuffer.allocate(10), 100, 100, options));
+  }
+
+  @Test
+  public void testReturnsNullIfParsedHeaderHasOpenError() {
+    when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OPEN_ERROR);
+
+    assertNull(decoder.decode(ByteBuffer.allocate(10), 100, 100, options));
+  }
+
+  @Test
+  public void testReturnsParserToPool() throws IOException {
+    decoder.decode(ByteBuffer.allocate(10), 100, 100, options);
+    verify(parserPool).release(eq(parser));
+  }
+
+  @Test
+  public void testReturnsParserToPoolWhenParserThrows() {
+    when(parser.parseHeader()).thenThrow(new RuntimeException("Test"));
+    try {
+      decoder.decode(ByteBuffer.allocate(10), 100, 100, options);
+      fail("Failed to receive expected exception");
+    } catch (RuntimeException e) {
+      // Expected.
+    }
+
+    verify(parserPool).release(eq(parser));
+  }
+
+  @Test
+  public void testReturnsNullIfGifDecoderFailsToDecodeFirstFrame() {
+    when(gifHeader.getNumFrames()).thenReturn(1);
+    when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);
+    when(gifDecoder.getNextFrame()).thenReturn(null);
+
+    assertNull(decoder.decode(ByteBuffer.allocate(10), 100, 100, options));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
new file mode 100644
index 000000000..c83dd1740
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
@@ -0,0 +1,44 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GifDrawableResourceTest {
+  private GifDrawable drawable;
+  private GifDrawableResource resource;
+
+  @Before
+  public void setUp() {
+    drawable = mock(GifDrawable.class);
+    resource = new GifDrawableResource(drawable);
+  }
+
+  @Test
+  public void testReturnsSizeFromDrawable() {
+    final int size = 2134;
+    when(drawable.getSize()).thenReturn(size);
+
+    assertEquals(size, resource.getSize());
+  }
+
+  @Test
+  public void testStopsAndThenRecyclesDrawableWhenRecycled() {
+    resource.recycle();
+
+    InOrder inOrder = inOrder(drawable);
+    inOrder.verify(drawable).stop();
+    inOrder.verify(drawable).recycle();
+  }
+
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
new file mode 100644
index 000000000..d838b7efa
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -0,0 +1,588 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.gif.GifDrawableTest.BitmapTrackingShadowCanvas;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadows.ShadowCanvas;
+
+import java.util.HashSet;
+import java.util.Set;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18,
+    shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
+public class GifDrawableTest {
+  private GifDrawable drawable;
+  private int frameHeight;
+  private int frameWidth;
+  private Bitmap firstFrame;
+  private int initialSdkVersion;
+
+  @Mock private Drawable.Callback cb;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private GifFrameLoader frameLoader;
+  @Mock private Paint paint;
+  @Mock private Transformation<Bitmap> transformation;
+
+  private static Paint isAPaint() {
+    return isA(Paint.class);
+  }
+
+  private static Rect isARect() {
+    return isA(Rect.class);
+  }
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    frameWidth = 120;
+    frameHeight = 450;
+    firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
+    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);
+    when(frameLoader.getWidth()).thenReturn(frameWidth);
+    when(frameLoader.getHeight()).thenReturn(frameHeight);
+    when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
+    when(frameLoader.getCurrentIndex()).thenReturn(0);
+    drawable.setCallback(cb);
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
+  }
+
+  @Test
+  public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
+    Canvas canvas = new Canvas();
+    drawable.draw(canvas);
+
+    BitmapTrackingShadowCanvas shadowCanvas =
+        (BitmapTrackingShadowCanvas) ShadowExtractor.extract(canvas);
+    assertThat(shadowCanvas.getDrawnBitmaps()).containsExactly(firstFrame);
+  }
+
+  @Test
+  public void testDoesDrawCurrentFrameIfOneIsAvailable() {
+    Canvas canvas = mock(Canvas.class);
+    Bitmap currentFrame = Bitmap.createBitmap(100123, 123141, Bitmap.Config.ARGB_4444);
+    when(frameLoader.getCurrentFrame()).thenReturn(currentFrame);
+
+    drawable.draw(canvas);
+    verify(canvas).drawBitmap(eq(currentFrame), (Rect) isNull(), isARect(), isAPaint());
+    verify(canvas, never()).drawBitmap(eq(firstFrame), (Rect) isNull(), isARect(), isAPaint());
+  }
+
+  @Test
+  public void testRequestsNextFrameOnStart() {
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    verify(frameLoader).subscribe(eq(drawable));
+  }
+
+  @Test
+  public void testRequestsNextFrameOnStartWithoutCallToSetVisible() {
+    drawable.start();
+
+    verify(frameLoader).subscribe(eq(drawable));
+  }
+
+  @Test
+  public void testDoesNotRequestNextFrameOnStartIfGotCallToSetVisibleWithVisibleFalse() {
+    drawable.setVisible(false, false);
+    drawable.start();
+
+    verify(frameLoader, never()).subscribe(eq(drawable));
+  }
+
+  @Test
+  public void testDoesNotRequestNextFrameOnStartIfHasSingleFrame() {
+    when(frameLoader.getFrameCount()).thenReturn(1);
+    drawable.setVisible(true, false);
+    drawable.start();
+
+    verify(frameLoader, never()).subscribe(eq(drawable));
+  }
+
+  @Test
+  public void testInvalidatesSelfOnStartIfHasSingleFrame() {
+    when(frameLoader.getFrameCount()).thenReturn(1);
+    drawable.setVisible(true, false);
+    drawable.start();
+
+    verify(cb).invalidateDrawable(eq(drawable));
+  }
+
+  @Test
+  public void testShouldInvalidateSelfOnRun() {
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    verify(cb).invalidateDrawable(eq(drawable));
+  }
+
+  @Test
+  public void testShouldNotScheduleItselfIfAlreadyRunning() {
+    drawable.setVisible(true, true);
+    drawable.start();
+    drawable.start();
+
+    verify(frameLoader, times(1)).subscribe(eq(drawable));
+  }
+
+  @Test
+  public void testReturnsFalseFromIsRunningWhenNotRunning() {
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testReturnsTrueFromIsRunningWhenRunning() {
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    assertTrue(drawable.isRunning());
+  }
+
+  @Test
+  public void testInvalidatesSelfWhenFrameReady() {
+    drawable.setIsRunning(true);
+    drawable.onFrameReady();
+
+    verify(cb).invalidateDrawable(eq(drawable));
+  }
+
+  @Test
+  public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfHasNoCallback() {
+    drawable.setIsRunning(true);
+    drawable.setCallback(null);
+    drawable.onFrameReady();
+
+    verify(frameLoader).unsubscribe(eq(drawable));
+  }
+
+  @Test
+  public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+    drawable.setIsRunning(true);
+    drawable.setCallback(null);
+    drawable.onFrameReady();
+
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testDoesNotStopWhenCurrentFrameFinishesIfHasNoCallbackAndIsPreHoneycomb() {
+    Util.setSdkVersionInt(10);
+
+    drawable.setIsRunning(true);
+    drawable.setCallback(null);
+    drawable.onFrameReady();
+
+    assertTrue(drawable.isRunning());
+  }
+
+  @Test
+  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+    drawable.setIsRunning(true);
+    drawable.setCallback(null);
+    drawable.onFrameReady();
+
+    verify(frameLoader).unsubscribe(eq(drawable));
+  }
+
+  @Test
+  public void testSetsIsRunningFalseOnStop() {
+    drawable.start();
+    drawable.stop();
+
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testStopsOnSetVisibleFalse() {
+    drawable.start();
+
+    drawable.setVisible(false, true);
+
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testStartsOnSetVisibleTrueIfRunning() {
+    drawable.start();
+    drawable.setVisible(false, false);
+    drawable.setVisible(true, true);
+
+    assertTrue(drawable.isRunning());
+  }
+
+  @Test
+  public void testDoesNotStartOnVisibleTrueIfNotRunning() {
+    drawable.setVisible(true, true);
+
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testDoesNotStartOnSetVisibleIfStartedAndStopped() {
+    drawable.start();
+    drawable.stop();
+    drawable.setVisible(true, true);
+
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testDoesNotImmediatelyRunIfStartedWhileNotVisible() {
+    drawable.setVisible(false, false);
+    drawable.start();
+
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testGetOpacityReturnsTransparent() {
+    assertEquals(PixelFormat.TRANSPARENT, drawable.getOpacity());
+  }
+
+  @Test
+  public void testReturnsFrameCountFromDecoder() {
+    int expected = 4;
+    when(frameLoader.getFrameCount()).thenReturn(expected);
+
+    assertEquals(expected, drawable.getFrameCount());
+  }
+
+  @Test
+  public void testReturnsDefaultFrameIndex() {
+    final int expected = -1;
+
+    when(frameLoader.getCurrentIndex()).thenReturn(expected);
+
+    assertEquals(expected, drawable.getFrameIndex());
+  }
+
+  @Test
+  public void testReturnsNonDefaultFrameIndex() {
+    final int expected = 100;
+
+    when(frameLoader.getCurrentIndex()).thenReturn(expected);
+
+    assertEquals(expected, drawable.getFrameIndex());
+  }
+
+  @Test
+  public void testRecycleCallsClearOnFrameManager() {
+    drawable.recycle();
+
+    verify(frameLoader).clear();
+  }
+
+  @Test
+  public void testIsNotRecycledIfNotRecycled() {
+    assertFalse(drawable.isRecycled());
+  }
+
+  @Test
+  public void testIsRecycledAfterRecycled() {
+    drawable.recycle();
+
+    assertTrue(drawable.isRecycled());
+  }
+
+  @Test
+  public void testReturnsNonNullConstantState() {
+    assertNotNull(drawable.getConstantState());
+  }
+
+  @Test
+  public void testReturnsSizeFromFrameLoader() {
+    int size = 1243;
+    when(frameLoader.getSize()).thenReturn(size);
+
+    assertThat(drawable.getSize()).isEqualTo(size);
+  }
+
+  @Test
+  public void testReturnsNewDrawableFromConstantState() {
+    Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    drawable =
+        new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
+            transformation, 100, 100, firstFrame);
+
+    assertNotNull(drawable.getConstantState().newDrawable());
+    assertNotNull(
+        drawable.getConstantState().newDrawable(RuntimeEnvironment.application.getResources()));
+  }
+
+  @Test
+  public void testReturnsFrameWidthAndHeightForIntrinsicDimensions() {
+    assertEquals(frameWidth, drawable.getIntrinsicWidth());
+    assertEquals(frameHeight, drawable.getIntrinsicHeight());
+  }
+
+  @Test
+  public void testLoopsASingleTimeIfLoopCountIsSetToOne() {
+    final int loopCount = 1;
+    final int frameCount = 2;
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(loopCount);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testLoopsForeverIfLoopCountIsSetToLoopForever() {
+    final int loopCount = 40;
+    final int frameCount = 2;
+
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(GifDrawable.LOOP_FOREVER);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+  }
+
+  @Test
+  public void testLoopsOnceIfLoopCountIsSetToOneWithThreeFrames() {
+    final int loopCount = 1;
+    final int frameCount = 3;
+
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(loopCount);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testLoopsThreeTimesIfLoopCountIsSetToThree() {
+    final int loopCount = 3;
+    final int frameCount = 2;
+
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(loopCount);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testCallingStartResetsLoopCounter() {
+    when(frameLoader.getFrameCount()).thenReturn(2);
+    drawable.setLoopCount(1);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    drawable.onFrameReady();
+    when(frameLoader.getCurrentIndex()).thenReturn(1);
+    drawable.onFrameReady();
+
+    drawable.start();
+
+    when(frameLoader.getCurrentIndex()).thenReturn(0);
+    drawable.onFrameReady();
+    when(frameLoader.getCurrentIndex()).thenReturn(1);
+    drawable.onFrameReady();
+
+    // 4 onFrameReady(), 2 start()
+    verify(cb, times(4 + 2)).invalidateDrawable(eq(drawable));
+    assertFalse(drawable.isRunning());
+  }
+
+  @Test
+  public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
+    final int initialLoopCount = 1;
+    final int frameCount = 2;
+
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(initialLoopCount);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(initialLoopCount, frameCount);
+
+    final int newLoopCount = 2;
+
+    drawable.setLoopCount(newLoopCount);
+    drawable.start();
+
+    runLoops(newLoopCount, frameCount);
+
+    int numStarts = 2;
+    int expectedFrames = (initialLoopCount + newLoopCount) * frameCount + numStarts;
+    verify(cb, times(expectedFrames)).invalidateDrawable(eq(drawable));
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfGivenLoopCountLessThanZeroAndNotInfinite() {
+    drawable.setLoopCount(-2);
+  }
+
+  @Test
+  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
+    final int frameCount = 3;
+    final int loopCount = 2;
+    when(frameLoader.getLoopCount()).thenReturn(loopCount);
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+  }
+
+  @Test
+  public void testDoesNotDrawFrameAfterRecycle() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
+    drawable.setVisible(true, true);
+    drawable.start();
+    when(frameLoader.getCurrentFrame()).thenReturn(bitmap);
+    drawable.onFrameReady();
+    drawable.recycle();
+    Canvas canvas = mock(Canvas.class);
+    drawable.draw(canvas);
+    verify(canvas, never()).drawBitmap(eq(bitmap), isARect(), isARect(), isAPaint());
+  }
+
+  @Test
+  public void testSetsFrameTransformationOnFrameManager() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    drawable.setFrameTransformation(transformation, bitmap);
+
+    verify(frameLoader).setFrameTransformation(eq(transformation), eq(bitmap));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfConstructedWithNullFirstFrame() {
+    new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
+        transformation, 100, 100, null);
+  }
+
+  @Test
+  public void testAppliesGravityOnDrawAfterBoundsChange() {
+    Rect bounds = new Rect(0, 0, frameWidth * 2, frameHeight * 2);
+    drawable.setBounds(bounds);
+
+    Canvas canvas = mock(Canvas.class);
+    drawable.draw(canvas);
+
+    verify(canvas).drawBitmap(isA(Bitmap.class), (Rect) isNull(), eq(bounds), eq(paint));
+  }
+
+  @Test
+  public void testSetAlphaSetsAlphaOnPaint() {
+    int alpha = 100;
+    drawable.setAlpha(alpha);
+    verify(paint).setAlpha(eq(alpha));
+  }
+
+  @Test
+  public void testSetColorFilterSetsColorFilterOnPaint() {
+    ColorFilter colorFilter = new ColorFilter();
+    drawable.setColorFilter(colorFilter);
+    verify(paint).setColorFilter(eq(colorFilter));
+  }
+
+  @Test
+  public void testReturnsCurrentTransformationInGetFrameTransformation() {
+    Transformation<Bitmap> newTransformation = mock(Transformation.class);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    drawable.setFrameTransformation(newTransformation, bitmap);
+
+    verify(frameLoader).setFrameTransformation(eq(newTransformation), eq(bitmap));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfCreatedWithNullState() {
+    new GifDrawable(null);
+  }
+
+  private void verifyRanLoops(int loopCount, int frameCount) {
+    // 1 for invalidate in start().
+    verify(cb, times(1 + loopCount * frameCount)).invalidateDrawable(eq(drawable));
+  }
+
+  private void runLoops(int loopCount, int frameCount) {
+    for (int loop = 0; loop < loopCount; loop++) {
+      for (int frame = 0; frame < frameCount; frame++) {
+        when(frameLoader.getCurrentIndex()).thenReturn(frame);
+        drawable.onFrameReady();
+      }
+    }
+  }
+
+  /**
+   * Keeps track of the set of Bitmaps drawn to the canvas.
+   */
+  @Implements(Canvas.class)
+  public static class BitmapTrackingShadowCanvas extends ShadowCanvas {
+    private final Set<Bitmap> drawnBitmaps = new HashSet<>();
+
+    @Implementation
+    public void drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) {
+      drawnBitmaps.add(bitmap);
+    }
+
+    public Iterable<Bitmap> getDrawnBitmaps() {
+      return drawnBitmaps;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
new file mode 100644
index 000000000..120ad07a1
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -0,0 +1,82 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.UnitTransformation;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GifDrawableTransformationTest {
+  @Mock Transformation<Bitmap> wrapped;
+  @Mock BitmapPool bitmapPool;
+
+  GifDrawableTransformation transformation;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    transformation = new GifDrawableTransformation(wrapped, bitmapPool);
+  }
+
+  @Test
+  public void testSetsTransformationAsFrameTransformation() {
+    Resource<GifDrawable> resource = mock(Resource.class);
+    GifDrawable gifDrawable = mock(GifDrawable.class);
+    Transformation<Bitmap> unitTransformation = UnitTransformation.get();
+    when(gifDrawable.getFrameTransformation()).thenReturn(unitTransformation);
+    when(gifDrawable.getIntrinsicWidth()).thenReturn(500);
+    when(gifDrawable.getIntrinsicHeight()).thenReturn(500);
+    when(resource.get()).thenReturn(gifDrawable);
+
+    Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(gifDrawable.getFirstFrame()).thenReturn(firstFrame);
+
+    final int width = 123;
+    final int height = 456;
+    Bitmap expectedBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+    Resource<Bitmap> expectedResource = mock(Resource.class);
+    when(expectedResource.get()).thenReturn(expectedBitmap);
+    when(wrapped.transform(isA(Resource.class), anyInt(), anyInt())).thenReturn(expectedResource);
+
+    transformation.transform(resource, width, height);
+
+    verify(gifDrawable).setFrameTransformation(isA(Transformation.class), eq(expectedBitmap));
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    doAnswer(new Util.WriteDigest("first")).when(wrapped)
+        .updateDiskCacheKey(isA(MessageDigest.class));
+    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped, bitmapPool));
+
+    Transformation<Bitmap> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other")).when(other)
+        .updateDiskCacheKey(isA(MessageDigest.class));
+    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other, bitmapPool));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
new file mode 100644
index 000000000..759a88013
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -0,0 +1,265 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.common.testing.EqualsTester;
+
+import android.graphics.Bitmap;
+import android.os.Handler;
+import android.os.Message;
+
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.resource.gif.GifFrameLoader.DelayTarget;
+import com.bumptech.glide.load.resource.gif.GifFrameLoader.FrameCallback;
+import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
+import com.bumptech.glide.util.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.nio.ByteBuffer;
+import java.util.UUID;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GifFrameLoaderTest {
+
+  @Mock GifFrameLoader.FrameCallback callback;
+  @Mock GifDecoder gifDecoder;
+  @Mock Handler handler;
+  @Mock Transformation<Bitmap> transformation;
+  @Mock RequestManager requestManager;
+  private GifFrameLoader loader;
+  private RequestBuilder<Bitmap> requestBuilder;
+  private Bitmap firstFrame;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(handler.obtainMessage(anyInt(), isA(DelayTarget.class))).thenReturn(mock(Message.class));
+
+    firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+    ByteBuffer byteBuffer = ByteBuffer.allocate(10);
+    when(gifDecoder.getData()).thenReturn(byteBuffer);
+
+    requestBuilder = mock(RequestBuilder.class, new ReturnsSelfAnswer());
+
+    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder, handler,
+        requestBuilder, transformation, firstFrame);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  public void testSetFrameTransformationSetsTransformationOnRequestBuilder() {
+    Transformation<Bitmap> transformation = mock(Transformation.class);
+    loader.setFrameTransformation(transformation, firstFrame);
+
+    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testSetFrameTransformationThrowsIfGivenNullTransformation() {
+    loader.setFrameTransformation(null, null);
+  }
+
+  @Test
+  public void testReturnsSizeFromGifDecoderAndCurrentFrame() {
+    int decoderByteSize = 123456;
+    when(gifDecoder.getByteSize()).thenReturn(decoderByteSize);
+    assertThat(loader.getSize()).isEqualTo(decoderByteSize + Util.getBitmapByteSize(firstFrame));
+  }
+
+  @Test
+  public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
+    loader.subscribe(callback);
+
+    verify(requestBuilder).into(isA(Target.class));
+  }
+
+  @Test
+  public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingLoad() {
+    loader.subscribe(callback);
+
+    InOrder order = inOrder(gifDecoder, requestBuilder);
+    order.verify(gifDecoder).advance();
+    order.verify(requestBuilder).apply(isA(BaseRequestOptions.class));
+    order.verify(requestBuilder).into(isA(Target.class));
+  }
+
+  @Test
+  public void testGetCurrentFrameReturnsFirstFrameWHenNoLoadHasCompleted() {
+    assertThat(loader.getCurrentFrame()).isEqualTo(firstFrame);
+  }
+
+  @Test
+  public void testGetCurrentFrameReturnsCurrentBitmapAfterLoadHasCompleted() {
+    final Bitmap result = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    DelayTarget target = mock(DelayTarget.class);
+    when(target.getResource()).thenReturn(result);
+    loader.onFrameReady(target);
+
+    assertEquals(result, loader.getCurrentFrame());
+  }
+
+  @Test
+  public void testStartDoesNotStartIfAlreadyRunning() {
+    loader.subscribe(callback);
+    loader.subscribe(mock(FrameCallback.class));
+
+    verify(requestBuilder, times(1)).into(isA(Target.class));
+  }
+
+  @Test
+  public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
+    loader.onFrameReady(mock(DelayTarget.class));
+
+    verify(requestBuilder, never()).into(isA(Target.class));
+  }
+
+  @Test
+  public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
+    loader.subscribe(callback);
+    loader.unsubscribe(callback);
+    loader.subscribe(callback);
+
+    verify(requestBuilder, times(1)).into(isA(Target.class));
+  }
+
+  @Test
+  public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
+    loader.subscribe(callback);
+    loader.unsubscribe(callback);
+
+    loader.onFrameReady(mock(DelayTarget.class));
+    loader.subscribe(callback);
+
+    verify(requestBuilder, times(2)).into(isA(Target.class));
+  }
+
+  @Test
+  public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
+    loader.subscribe(callback);
+    loader.onFrameReady(mock(DelayTarget.class));
+
+    verify(requestBuilder, times(2)).into(isA(Target.class));
+  }
+
+  @Test
+  public void testOnFrameReadyClearsPreviousFrame() {
+    // Force the loader to create a real Handler.
+    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
+        null /*handler*/, requestBuilder, transformation, firstFrame);
+
+    DelayTarget previous = mock(DelayTarget.class);
+    Request previousRequest = mock(Request.class);
+    when(previous.getRequest()).thenReturn(previousRequest);
+    when(previous.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+
+    DelayTarget current = mock(DelayTarget.class);
+    when(current.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
+    loader.onFrameReady(previous);
+    loader.onFrameReady(current);
+
+    verify(requestManager).clear(eq(previous));
+  }
+
+  @Test
+  public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
+     // Force the loader to create a real Handler.
+    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager,
+        gifDecoder, null /*handler*/, requestBuilder, transformation, firstFrame);
+
+    DelayTarget previous = mock(DelayTarget.class);
+    Request previousRequest = mock(Request.class);
+    when(previous.getRequest()).thenReturn(previousRequest);
+    when(previous.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+
+    DelayTarget current = mock(DelayTarget.class);
+    when(current.getResource()).thenReturn(null);
+    loader.onFrameReady(previous);
+    loader.onFrameReady(current);
+
+    verify(previousRequest, never()).clear();
+  }
+
+  @Test
+  public void testDelayTargetSendsMessageWithHandlerDelayed() {
+    long targetTime = 1234;
+    DelayTarget delayTarget = new DelayTarget(handler, 1, targetTime);
+    delayTarget.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+    /*glideAnimation*/);
+    verify(handler).sendMessageAtTime(isA(Message.class), eq(targetTime));
+  }
+
+  @Test
+  public void testDelayTargetSetsResourceOnResourceReady() {
+    DelayTarget delayTarget = new DelayTarget(handler, 1, 1);
+    Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
+    delayTarget.onResourceReady(expected, null /*glideAnimation*/);
+
+    assertEquals(expected, delayTarget.getResource());
+  }
+
+  @Test
+  public void testClearsCompletedLoadOnFrameReadyIfCleared() {
+    // Force the loader to create a real Handler.
+    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
+        null /*handler*/, requestBuilder, transformation, firstFrame);
+    loader.clear();
+    DelayTarget delayTarget = mock(DelayTarget.class);
+    Request request = mock(Request.class);
+    when(delayTarget.getRequest()).thenReturn(request);
+
+    loader.onFrameReady(delayTarget);
+
+    verify(requestManager).clear(eq(delayTarget));
+  }
+
+  @Test
+  public void
+  testDoesNotReturnResourceForCompletedFrameInGetCurrentFrameIfLoadCompletesWhileCleared() {
+    loader.clear();
+    DelayTarget delayTarget = mock(DelayTarget.class);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(delayTarget.getResource()).thenReturn(bitmap);
+
+    loader.onFrameReady(delayTarget);
+
+    assertNull(loader.getCurrentFrame());
+  }
+
+  @Test
+  public void testFrameSignatureEquality() {
+    UUID first = UUID.randomUUID();
+    new EqualsTester().addEqualityGroup(new GifFrameLoader.FrameSignature(first),
+        new GifFrameLoader.FrameSignature(first))
+        .addEqualityGroup(new GifFrameLoader.FrameSignature()).testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
new file mode 100644
index 000000000..2a4c28460
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
@@ -0,0 +1,50 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GifFrameResourceDecoderTest {
+  private GifDecoder gifDecoder;
+  private GifFrameResourceDecoder resourceDecoder;
+  private Options options;
+
+  @Before
+  public void setUp() {
+    gifDecoder = mock(GifDecoder.class);
+    resourceDecoder = new GifFrameResourceDecoder(mock(BitmapPool.class));
+    options = new Options();
+  }
+
+  @Test
+  public void testReturnsFrameFromGifDecoder() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+    when(gifDecoder.getNextFrame()).thenReturn(expected);
+
+    assertEquals(expected, resourceDecoder.decode(gifDecoder, 100, 100, options).get());
+  }
+
+  @Test
+  public void testReturnsNullIfGifDecoderReturnsNullFrame() {
+    when(gifDecoder.getNextFrame()).thenReturn(null);
+
+    assertNull(resourceDecoder.decode(gifDecoder, 100, 100, options));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
new file mode 100644
index 000000000..bd4efeda5
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -0,0 +1,60 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class StreamGifDecoderTest {
+  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+
+  @Mock
+  ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
+  private StreamGifDecoder decoder;
+  private Options options;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    decoder = new StreamGifDecoder(byteBufferDecoder, new LruByteArrayPool());
+    options = new Options();
+  }
+
+  @Test
+  public void testDoesNotHandleStreamIfEnabledButNotAGif() throws IOException {
+    assertThat(decoder.handles(new ByteArrayInputStream(new byte[0]), options)).isFalse();
+  }
+
+  @Test
+  public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOException {
+    assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isTrue();
+  }
+
+  @Test
+  public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {
+    options.set(StreamGifDecoder.DISABLE_ANIMATION, false);
+    assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isTrue();
+  }
+
+  @Test
+  public void testDoesNotHandleStreamIfDisabled() throws IOException {
+    options.set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isFalse();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
new file mode 100644
index 000000000..41fea2adc
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.load.resource.transcode;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.engine.Resource;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapBytesTranscoderTest {
+  private BitmapBytesTranscoderHarness harness;
+
+  @Before()
+  public void setUp() {
+    harness = new BitmapBytesTranscoderHarness();
+  }
+
+  @Test
+  public void testReturnsBytesOfGivenBitmap() {
+    String transcodedDescription = harness.getTranscodedDescription();
+    assertThat(transcodedDescription).startsWith(harness.description);
+  }
+
+  @Test
+  public void testUsesGivenQuality() {
+    harness.quality = 66;
+    String transcodedDescription = harness.getTranscodedDescription();
+    assertThat(transcodedDescription).contains(String.valueOf(harness.quality));
+  }
+
+  @Test
+  public void testUsesGivenFormat() {
+    for (Bitmap.CompressFormat format : Bitmap.CompressFormat.values()) {
+      harness.compressFormat = format;
+      String transcodedDescription = harness.getTranscodedDescription();
+      assertThat(transcodedDescription).contains(format.name());
+    }
+  }
+
+  @Test
+  public void testBitampResourceIsRecycled() {
+    harness.getTranscodedDescription();
+
+    verify(harness.bitmapResource).recycle();
+  }
+
+  @SuppressWarnings("unchecked")
+  private static class BitmapBytesTranscoderHarness {
+    Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
+    int quality = 100;
+    final String description = "TestDescription";
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    Resource<Bitmap> bitmapResource = mock(Resource.class);
+
+    public BitmapBytesTranscoderHarness() {
+      when(bitmapResource.get()).thenReturn(bitmap);
+      Shadows.shadowOf(bitmap).setDescription(description);
+    }
+
+    public String getTranscodedDescription() {
+      BitmapBytesTranscoder transcoder = new BitmapBytesTranscoder(compressFormat, quality);
+      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource);
+
+      return new String(bytesResource.get());
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
new file mode 100644
index 000000000..cb975b03f
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.load.resource.transcode;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapDrawableTranscoderTest {
+  private BitmapDrawableTranscoder transcoder;
+
+  @Before
+  public void setUp() {
+    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources(),
+        mock(BitmapPool.class));
+  }
+
+  @Test
+  public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Resource<Bitmap> resource = mock(Resource.class);
+    when(resource.get()).thenReturn(expected);
+
+    Resource<BitmapDrawable> transcoded = transcoder.transcode(resource);
+
+    assertEquals(expected, transcoded.get().getBitmap());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
new file mode 100644
index 000000000..70e2a185a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -0,0 +1,43 @@
+package com.bumptech.glide.load.resource.transcode;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.nio.ByteBuffer;
+
+@RunWith(JUnit4.class)
+public class GifDrawableBytesTranscoderTest {
+  private GifDrawableBytesTranscoder transcoder;
+  private GifDrawable gifDrawable;
+  private Resource<GifDrawable> resource;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    gifDrawable = mock(GifDrawable.class);
+    resource = mock(Resource.class);
+    when(resource.get()).thenReturn(gifDrawable);
+    transcoder = new GifDrawableBytesTranscoder();
+  }
+
+  @Test
+  public void testReturnsBytesOfGivenGifDrawable() {
+    for (String fakeData : new String[] { "test", "1235asfklaw3", "@$@#" }) {
+      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes());
+      when(gifDrawable.getBuffer()).thenReturn(expected);
+
+      Resource<byte[]> transcoded = transcoder.transcode(resource);
+
+      assertArrayEquals(expected.array(), transcoded.get());
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
new file mode 100644
index 000000000..2219e7720
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
@@ -0,0 +1,48 @@
+package com.bumptech.glide.load.resource.transcode;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.File;
+
+@RunWith(JUnit4.class)
+public class TranscoderRegistryTest {
+  private TranscoderRegistry factories;
+
+  @Before
+  public void setUp() {
+    factories = new TranscoderRegistry();
+  }
+
+  @Test
+  public void testReturnsUnitDecoderIfClassesAreIdentical() {
+    assertEquals(UnitTranscoder.get(), factories.get(Object.class, Object.class));
+  }
+
+  @Test
+  public void testCanRegisterAndRetreiveResouceTranscoder() {
+    ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
+    factories.register(File.class, String.class, transcoder);
+
+    assertEquals(transcoder, factories.get(File.class, String.class));
+  }
+
+  @Test
+  public void testDoesNotThrowIfRequestCanBeSatisfiedByUnitTranscoder() {
+    // Assignable from.
+    assertNotNull(factories.get(Integer.class, Number.class));
+    // Equal to.
+    assertNotNull(factories.get(Integer.class, Integer.class));
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfNoTranscoderRegistered() {
+    factories.get(File.class, Integer.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
new file mode 100644
index 000000000..19a33cfb9
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.load.resource.transcode;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.engine.Resource;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class UnitTranscoderTest {
+
+  @Test
+  public void testReturnsTheGivenResource() {
+    Resource resource = mock(Resource.class);
+    ResourceTranscoder<Object, Object> unitTranscoder = UnitTranscoder.get();
+
+    assertEquals(resource, unitTranscoder.transcode(resource));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java b/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
new file mode 100644
index 000000000..d1a14b0a1
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
@@ -0,0 +1,38 @@
+package com.bumptech.glide.manager;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ConnectivityMonitorFactoryTest {
+  private ConnectivityMonitorFactory factory;
+
+  @Before
+  public void setUp() {
+    factory = new ConnectivityMonitorFactory();
+  }
+
+  @Test
+  public void testReturnsDefaultConnectivityMonitorWhenHasPermission() {
+    ShadowApplication.getInstance().grantPermissions("android.permission.ACCESS_NETWORK_STATE");
+    ConnectivityMonitor connectivityMonitor = factory.build(RuntimeEnvironment.application,
+        mock(ConnectivityMonitor.ConnectivityListener.class));
+    assertThat(connectivityMonitor).isInstanceOf(DefaultConnectivityMonitor.class);
+  }
+
+  @Test
+  public void testReturnsNullConnectivityMonitorWhenDoesNotHavePermission() {
+    ConnectivityMonitor connectivityMonitor = factory.build(RuntimeEnvironment.application,
+        mock(ConnectivityMonitor.ConnectivityListener.class));
+    assertThat(connectivityMonitor).isInstanceOf(NullConnectivityMonitor.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
new file mode 100644
index 000000000..44ac8726f
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -0,0 +1,149 @@
+package com.bumptech.glide.manager;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+import org.robolectric.shadows.ShadowConnectivityManager;
+import org.robolectric.shadows.ShadowNetworkInfo;
+
+import java.util.List;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DefaultConnectivityMonitorTest {
+  private ConnectivityMonitor.ConnectivityListener listener;
+  private DefaultConnectivityMonitor monitor;
+
+  @Before
+  public void setUp() {
+    listener = mock(ConnectivityMonitor.ConnectivityListener.class);
+    monitor = new DefaultConnectivityMonitor(RuntimeEnvironment.application, listener);
+  }
+
+  @Test
+  public void testRegistersReceiverOnStart() {
+    monitor.onStart();
+
+    assertThat(getConnectivityReceivers()).hasSize(1);
+  }
+
+  @Test
+  public void testDoesNotRegisterTwiceOnStart() {
+    monitor.onStart();
+    monitor.onStart();
+
+    assertThat(getConnectivityReceivers()).hasSize(1);
+  }
+
+  @Test
+  public void testUnregistersReceiverOnStop() {
+    monitor.onStart();
+    monitor.onStop();
+
+    assertThat(getConnectivityReceivers()).isEmpty();
+  }
+
+  @Test
+  public void testHandlesUnregisteringTwiceInARow() {
+    monitor.onStop();
+    monitor.onStop();
+
+    assertThat(getConnectivityReceivers()).isEmpty();
+  }
+
+  @Test
+  public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
+    ConnectivityHarness harness = new ConnectivityHarness();
+    harness.connect();
+
+    monitor.onStart();
+    harness.broadcast();
+
+    verify(listener, never()).onConnectivityChanged(anyBoolean());
+  }
+
+  @Test
+  public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
+    ConnectivityHarness harness = new ConnectivityHarness();
+    harness.connect();
+
+    monitor.onStart();
+    harness.disconnect();
+    harness.broadcast();
+
+    verify(listener).onConnectivityChanged(eq(false));
+  }
+
+  @Test
+  public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
+    ConnectivityHarness harness = new ConnectivityHarness();
+    harness.disconnect();
+
+    monitor.onStart();
+    harness.connect();
+    harness.broadcast();
+
+    verify(listener).onConnectivityChanged(eq(true));
+  }
+
+  @Test
+  public void testDoesNotNotifyListenerWhenNotRegistered() {
+    ConnectivityHarness harness = new ConnectivityHarness();
+    harness.disconnect();
+
+    monitor.onStart();
+    monitor.onStop();
+    harness.connect();
+    harness.broadcast();
+
+    verify(listener, never()).onConnectivityChanged(anyBoolean());
+  }
+
+  private List<BroadcastReceiver> getConnectivityReceivers() {
+    Intent connectivity = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
+    return ShadowApplication.getInstance().getReceiversForIntent(connectivity);
+  }
+
+  private static class ConnectivityHarness {
+    private final ShadowConnectivityManager shadowConnectivityManager;
+
+    public ConnectivityHarness() {
+      ConnectivityManager connectivityManager = (ConnectivityManager) RuntimeEnvironment.application
+          .getSystemService(Context.CONNECTIVITY_SERVICE);
+      shadowConnectivityManager = Shadows.shadowOf(connectivityManager);
+    }
+
+    public void disconnect() {
+      shadowConnectivityManager.setActiveNetworkInfo(null);
+    }
+
+    public void connect() {
+      NetworkInfo networkInfo =
+          ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.CONNECTED, 0, 0, true, true);
+      shadowConnectivityManager.setActiveNetworkInfo(networkInfo);
+    }
+
+    public void broadcast() {
+      Intent connected = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
+      ShadowApplication.getInstance().sendBroadcast(connected);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
new file mode 100644
index 000000000..b1feae1f1
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.manager;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentPagerAdapter;
+import android.support.v4.view.ViewPager;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+import com.bumptech.glide.Glide;
+
+/**
+ * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
+ */
+class Issue117Activity extends FragmentActivity {
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    ViewPager viewPager = new ViewPager(this);
+    viewPager.setId(View.generateViewId());
+    setContentView(viewPager, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+        ViewGroup.LayoutParams.MATCH_PARENT));
+    viewPager.setAdapter(new Issue117Adapter(getSupportFragmentManager()));
+  }
+
+  private static class Issue117Adapter extends FragmentPagerAdapter {
+
+    public Issue117Adapter(FragmentManager fm) {
+      super(fm);
+    }
+
+    @Override
+    public Fragment getItem(int position) {
+      return new Issue117Fragment();
+    }
+
+    @Override
+    public int getCount() {
+      return 1;
+    }
+  }
+
+  public static class Issue117Fragment extends Fragment {
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+        Bundle savedInstanceState) {
+      return new Issue117ImageView(getActivity());
+    }
+  }
+
+  public static class Issue117ImageView extends ImageView {
+    public Issue117ImageView(Context context) {
+      super(context);
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+      super.onAttachedToWindow();
+      Glide.with(getContext()).asDrawable().load(android.R.drawable.ic_menu_rotate).into(this);
+    }
+  }
+}
+
diff --git a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java b/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
new file mode 100644
index 000000000..bcc1f9bea
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
@@ -0,0 +1,126 @@
+package com.bumptech.glide.manager;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class LifecycleTest {
+
+  private ActivityFragmentLifecycle lifecycle;
+  private LifecycleListener listener;
+
+  @Before
+  public void setUp() {
+    lifecycle = new ActivityFragmentLifecycle();
+    listener = mock(LifecycleListener.class);
+  }
+
+  @Test
+  public void testNotifiesAddedListenerOnStart() {
+    lifecycle.addListener(listener);
+    lifecycle.onStart();
+    verify(listener).onStart();
+  }
+
+  @Test
+  public void testNotifiesAddedListenerOfStartIfStarted() {
+    lifecycle.onStart();
+    lifecycle.addListener(listener);
+    verify(listener).onStart();
+  }
+
+  @Test
+  public void testDoesNotNotifyAddedListenerOfStartIfDestroyed() {
+    lifecycle.onStart();
+    lifecycle.onStop();
+    lifecycle.onDestroy();
+    lifecycle.addListener(listener);
+
+    verify(listener, never()).onStart();
+  }
+
+  @Test
+  public void testDoesNotNotifyListenerOfStartIfStartedThenStopped() {
+    lifecycle.onStart();
+    lifecycle.onStop();
+    lifecycle.addListener(listener);
+    verify(listener, never()).onStart();
+  }
+
+  @Test
+  public void testNotifiesAddedListenerOnStop() {
+    lifecycle.onStart();
+    lifecycle.addListener(listener);
+    lifecycle.onStop();
+    verify(listener).onStop();
+  }
+
+  @Test
+  public void testNotifiesAddedListenerOfStopIfStopped() {
+    lifecycle.onStop();
+    lifecycle.addListener(listener);
+    verify(listener).onStop();
+  }
+
+  @Test
+  public void testDoesNotNotifyAddedListenerOfStopIfDestroyed() {
+    lifecycle.onStart();
+    lifecycle.onStop();
+    lifecycle.onDestroy();
+    lifecycle.addListener(listener);
+    verify(listener, never()).onStop();
+  }
+
+  @Test
+  public void testDoesNotNotifyListenerOfStopIfStoppedThenStarted() {
+    lifecycle.onStop();
+    lifecycle.onStart();
+    lifecycle.addListener(listener);
+    verify(listener, never()).onStop();
+  }
+
+  @Test
+  public void testNotifiesAddedListenerOnDestroy() {
+    lifecycle.addListener(listener);
+    lifecycle.onDestroy();
+    verify(listener).onDestroy();
+  }
+
+  @Test
+  public void testNotifiesAddedListenerOfDestroyIfDestroyed() {
+    lifecycle.onDestroy();
+    lifecycle.addListener(listener);
+    verify(listener).onDestroy();
+  }
+
+  @Test
+  public void testNotifiesMultipleListeners() {
+    lifecycle.onStart();
+    int toNotify = 20;
+    List<LifecycleListener> listeners = new ArrayList<>();
+    for (int i = 0; i < toNotify; i++) {
+      listeners.add(mock(LifecycleListener.class));
+    }
+    for (LifecycleListener lifecycleListener : listeners) {
+      lifecycle.addListener(lifecycleListener);
+    }
+    lifecycle.onStop();
+    lifecycle.onDestroy();
+    for (LifecycleListener lifecycleListener : listeners) {
+      verify(lifecycleListener).onStart();
+      verify(lifecycleListener).onStop();
+      verify(lifecycleListener).onDestroy();
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
new file mode 100644
index 000000000..1d863c384
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -0,0 +1,293 @@
+package com.bumptech.glide.manager;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.app.Activity;
+import android.support.v4.app.FragmentActivity;
+
+import com.bumptech.glide.RequestManager;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.exceptions.base.MockitoAssertionError;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.ActivityController;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class RequestManagerFragmentTest {
+  private static final String TAG = "tag";
+  private Harness[] harnesses;
+
+  @Before
+  public void setUp() {
+    harnesses = new Harness[] { new RequestManagerHarness(), new SupportRequestManagerHarness() };
+  }
+
+  @Test
+  public void testSupportCanSetAndGetRequestManager() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        RequestManager manager = mock(RequestManager.class);
+        harness.setRequestManager(manager);
+        assertEquals(manager, harness.getManager());
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsLifecycle() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        assertEquals(harness.getHarnessLifecycle(), harness.getFragmentLifecycle());
+      }
+    });
+  }
+
+  @Test
+  public void testDoesNotAddNullRequestManagerToLifecycleWhenSet() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        harness.setRequestManager(null);
+        verify(harness.getHarnessLifecycle(), never()).addListener(any(LifecycleListener.class));
+      }
+    });
+  }
+
+  @Test
+  public void testCallsLifecycleStart() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        harness.getController().start();
+
+        verify(harness.getHarnessLifecycle()).onStart();
+      }
+    });
+  }
+
+  @Test
+  public void testCallsRequestManagerStop() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        harness.getController().start().resume().pause().stop();
+
+        verify(harness.getHarnessLifecycle()).onStop();
+      }
+    });
+  }
+
+  @Test
+  public void testCallsRequestManagerDestroy() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        harness.getController().start().resume().pause().stop().destroy();
+
+        verify(harness.getHarnessLifecycle()).onDestroy();
+      }
+    });
+  }
+
+  @Test
+  public void testCallsRequestManagerOnLowMemory() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        RequestManager requestManager = mock(RequestManager.class);
+        harness.setRequestManager(requestManager);
+        harness.onLowMemory();
+        verify(requestManager).onLowMemory();
+      }
+    });
+  }
+
+  @Test
+  public void testNonSupportFragmentCallsOnTrimMemory() {
+    RequestManagerHarness requestManagerHarness = new RequestManagerHarness();
+    int level = 100;
+    RequestManager requestManager = mock(RequestManager.class);
+    requestManagerHarness.setRequestManager(requestManager);
+    requestManagerHarness.onTrimMemory(level);
+    verify(requestManager).onTrimMemory(eq(level));
+  }
+
+  @Test
+  public void testOnLowMemoryCallOnNullRequestManagerDoesNotCrash() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        harness.onLowMemory();
+      }
+    });
+  }
+
+  @Test
+  public void testOnTrimMemoryCallOnNullRequestManagerDoesNotCrash() {
+    runTest(new TestCase() {
+      @Override
+      public void runTest(Harness harness) {
+        harness.onTrimMemory(100 /*level*/);
+      }
+    });
+  }
+
+  private void runTest(TestCase testCase) {
+    for (Harness harness : harnesses) {
+      try {
+        testCase.runTest(harness);
+      } catch (MockitoAssertionError e) {
+        throw new Error("Failed to get expected call on " + harness, e);
+      }
+    }
+  }
+
+  private interface TestCase {
+    public void runTest(Harness harness);
+  }
+
+  private interface Harness {
+    RequestManager getManager();
+
+    void setRequestManager(RequestManager manager);
+
+    ActivityFragmentLifecycle getHarnessLifecycle();
+
+    ActivityFragmentLifecycle getFragmentLifecycle();
+
+    ActivityController getController();
+
+    void onLowMemory();
+
+    void onTrimMemory(int level);
+  }
+
+  private static class RequestManagerHarness implements Harness {
+    private final ActivityController<Activity> controller;
+    private final RequestManagerFragment fragment;
+    private final ActivityFragmentLifecycle lifecycle = mock(ActivityFragmentLifecycle.class);
+
+    public RequestManagerHarness() {
+      fragment = new RequestManagerFragment(lifecycle);
+      controller = Robolectric.buildActivity(Activity.class).create();
+      controller.get()
+          .getFragmentManager()
+          .beginTransaction()
+          .add(fragment, TAG)
+          .commit();
+      controller.get()
+          .getFragmentManager()
+          .executePendingTransactions();
+    }
+
+    @Override
+    public String toString() {
+      return "DefaultHarness";
+    }
+
+    @Override
+    public RequestManager getManager() {
+      return fragment.getRequestManager();
+    }
+
+    @Override
+    public void setRequestManager(RequestManager requestManager) {
+      fragment.setRequestManager(requestManager);
+    }
+
+    @Override
+    public ActivityFragmentLifecycle getHarnessLifecycle() {
+      return lifecycle;
+    }
+
+    @Override
+    public ActivityFragmentLifecycle getFragmentLifecycle() {
+      return fragment.getLifecycle();
+    }
+
+    @Override
+    public ActivityController getController() {
+      return controller;
+    }
+
+    @Override
+    public void onLowMemory() {
+      fragment.onLowMemory();
+    }
+
+    @Override
+    public void onTrimMemory(int level) {
+      fragment.onTrimMemory(level);
+    }
+  }
+
+  private static class SupportRequestManagerHarness implements Harness {
+    private final SupportRequestManagerFragment supportFragment;
+    private final ActivityController<FragmentActivity> supportController;
+    private final ActivityFragmentLifecycle lifecycle = mock(ActivityFragmentLifecycle.class);
+
+    public SupportRequestManagerHarness() {
+      supportFragment = new SupportRequestManagerFragment(lifecycle);
+      supportController = Robolectric.buildActivity(FragmentActivity.class).create();
+
+      supportController.get()
+          .getSupportFragmentManager()
+          .beginTransaction()
+          .add(supportFragment, TAG)
+          .commit();
+      supportController.get().getSupportFragmentManager().executePendingTransactions();
+    }
+
+    @Override
+    public String toString() {
+      return "SupportHarness";
+    }
+
+    @Override
+    public RequestManager getManager() {
+      return supportFragment.getRequestManager();
+    }
+
+    @Override
+    public void setRequestManager(RequestManager manager) {
+      supportFragment.setRequestManager(manager);
+    }
+
+    @Override
+    public ActivityFragmentLifecycle getHarnessLifecycle() {
+      return lifecycle;
+    }
+
+    @Override
+    public ActivityFragmentLifecycle getFragmentLifecycle() {
+      return supportFragment.getLifecycle();
+    }
+
+    @Override
+    public ActivityController getController() {
+      return supportController;
+    }
+
+    @Override
+    public void onLowMemory() {
+      supportFragment.onLowMemory();
+    }
+
+    @Override
+    public void onTrimMemory(int level) {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
new file mode 100644
index 000000000..0dd3828d3
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -0,0 +1,448 @@
+package com.bumptech.glide.manager;
+
+import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.os.Build;
+import android.os.Looper;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.ActivityController;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
+public class RequestManagerRetrieverTest {
+  private static final String PARENT_TAG = "parent";
+  private RetrieverHarness[] harnesses;
+  private RequestManagerRetriever retriever;
+  private int initialSdkVersion;
+
+  @Before
+  public void setUp() {
+    retriever = new RequestManagerRetriever();
+
+    harnesses =
+        new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+    Util.setSdkVersionInt(18);
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
+
+    Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
+    assertThat(retriever.pendingRequestManagerFragments).isEmpty();
+    assertThat(retriever.pendingSupportRequestManagerFragments).isEmpty();
+  }
+
+  @Test
+  public void testCreatesNewFragmentIfNoneExists() {
+    for (RetrieverHarness harness : harnesses) {
+      harness.doGet();
+
+      Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
+      assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));
+    }
+  }
+
+  @Test
+  public void testReturnsNewManagerIfNoneExists() {
+    for (RetrieverHarness harness : harnesses) {
+      assertNotNull(harness.doGet());
+    }
+  }
+
+  @Test
+  public void testReturnsExistingRequestManagerIfExists() {
+    for (RetrieverHarness harness : harnesses) {
+      RequestManager requestManager = mock(RequestManager.class);
+
+      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);
+
+      assertEquals(requestManager, harness.doGet());
+    }
+  }
+
+  @Test
+  public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
+    for (RetrieverHarness harness : harnesses) {
+      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
+
+      assertNotNull(harness.doGet());
+    }
+  }
+
+  @Test
+  public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
+    for (RetrieverHarness harness : harnesses) {
+      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
+      RequestManager first = harness.doGet();
+      RequestManager second = harness.doGet();
+
+      assertEquals(first, second);
+    }
+  }
+
+  @Test
+  public void testHasValidTag() {
+    assertEquals(RequestManagerRetriever.class.getPackage().getName(),
+        RequestManagerRetriever.FRAGMENT_TAG);
+  }
+
+  @Test
+  public void testCanGetRequestManagerFromActivity() {
+    Activity activity = Robolectric.buildActivity(Activity.class).create().start().get();
+    RequestManager manager = retriever.get(activity);
+    assertEquals(manager, retriever.get(activity));
+  }
+
+  @Test
+  public void testSupportCanGetRequestManagerFromActivity() {
+    FragmentActivity fragmentActivity =
+        Robolectric.buildActivity(FragmentActivity.class).create().start().get();
+    RequestManager manager = retriever.get(fragmentActivity);
+    assertEquals(manager, retriever.get(fragmentActivity));
+  }
+
+  @Test
+  public void testCanGetRequestManagerFromFragment() {
+    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
+    android.app.Fragment fragment = new android.app.Fragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, PARENT_TAG).commit();
+    activity.getFragmentManager().executePendingTransactions();
+
+    RequestManager manager = retriever.get(fragment);
+    assertEquals(manager, retriever.get(fragment));
+  }
+
+  @Test
+  public void testSupportCanGetRequestManagerFromFragment() {
+    FragmentActivity activity =
+        Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
+    Fragment fragment = new Fragment();
+    activity.getSupportFragmentManager().beginTransaction().add(fragment, PARENT_TAG).commit();
+    activity.getSupportFragmentManager().executePendingTransactions();
+
+    RequestManager manager = retriever.get(fragment);
+    assertEquals(manager, retriever.get(fragment));
+  }
+
+  @Test
+  public void testCanGetRequestManagerFromDetachedFragment() {
+    helpTestCanGetRequestManagerFromDetachedFragment();
+  }
+
+  @Test
+  public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
+    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
+    helpTestCanGetRequestManagerFromDetachedFragment();
+  }
+
+  private void helpTestCanGetRequestManagerFromDetachedFragment() {
+    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
+    android.app.Fragment fragment = new android.app.Fragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, PARENT_TAG).detach(fragment)
+        .commit();
+    activity.getFragmentManager().executePendingTransactions();
+
+    assertTrue(fragment.isDetached());
+    retriever.get(fragment);
+  }
+
+  @Test
+  public void testSupportCanGetRequestManagerFromDetachedFragment() {
+    helpTestSupportCanGetRequestManagerFromDetachedFragment();
+  }
+
+  @Test
+  public void testSupportCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
+    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
+    helpTestSupportCanGetRequestManagerFromDetachedFragment();
+  }
+
+  private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
+    FragmentActivity activity =
+        Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
+    Fragment fragment = new Fragment();
+    activity.getSupportFragmentManager().beginTransaction().add(fragment, PARENT_TAG)
+        .detach(fragment).commit();
+    activity.getSupportFragmentManager().executePendingTransactions();
+
+    assertTrue(fragment.isDetached());
+    retriever.get(fragment);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfFragmentNotAttached() {
+    android.app.Fragment fragment = new android.app.Fragment();
+    retriever.get(fragment);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfSupportFragmentNotAttached() {
+    Fragment fragment = new Fragment();
+    retriever.get(fragment);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfActivityDestroyed() {
+    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    harness.getController().pause().stop().destroy();
+    harness.doGet();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfFragmentActivityDestroyed() {
+    SupportRetrieverHarness harness = new SupportRetrieverHarness();
+    harness.getController().pause().stop().destroy();
+    harness.doGet();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfGivenNullContext() {
+    retriever.get((Context) null);
+  }
+
+  @Test
+  public void testChecksIfContextIsFragmentActivity() {
+    SupportRetrieverHarness harness = new SupportRetrieverHarness();
+    RequestManager requestManager = harness.doGet();
+
+    assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
+  }
+
+  @Test
+  public void testChecksIfContextIsActivity() {
+    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RequestManager requestManager = harness.doGet();
+
+    assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
+  }
+
+  @Test
+  public void testHandlesContextWrappersForActivities() {
+    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RequestManager requestManager = harness.doGet();
+    ContextWrapper contextWrapper = new ContextWrapper((Context) harness.getController().get());
+
+    assertEquals(requestManager, retriever.get(contextWrapper));
+  }
+
+  @Test
+  public void testHandlesContextWrappersForApplication() {
+    ContextWrapper contextWrapper = new ContextWrapper(RuntimeEnvironment.application);
+    RequestManager requestManager = retriever.get(RuntimeEnvironment.application);
+
+    assertEquals(requestManager, retriever.get(contextWrapper));
+  }
+
+  @Test
+  public void testReturnsNonNullManagerIfGivenApplicationContext() {
+    assertNotNull(retriever.get(RuntimeEnvironment.application));
+  }
+
+  @Test
+  public void testApplicationRequestManagerIsNotPausedWhenRetrieved() {
+    RequestManager manager = retriever.get(RuntimeEnvironment.application);
+    assertFalse(manager.isPaused());
+  }
+
+  @Test
+  public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
+    RequestManager manager = retriever.get(RuntimeEnvironment.application);
+    manager.pauseRequests();
+    manager = retriever.get(RuntimeEnvironment.application);
+    assertTrue(manager.isPaused());
+  }
+
+  @Test
+  public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread()
+      throws InterruptedException {
+    testInBackground(new BackgroundUtil.BackgroundTester() {
+      @Override
+      public void runTest() throws Exception {
+        retriever.get(RuntimeEnvironment.application);
+      }
+    });
+  }
+
+  // See Issue #117: https://github.com/bumptech/glide/issues/117.
+  @Test
+  public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
+    // Robolectric by default runs messages posted to the main looper synchronously, the
+    // framework does not. We post
+    // to the main thread here to work around an issue caused by a recursive method call so we
+    // need (and reasonably
+    // expect) our message to not run immediately
+    Shadows.shadowOf(Looper.getMainLooper()).pause();
+    Robolectric.buildActivity(Issue117Activity.class).create().start().resume().visible();
+  }
+
+  @Test
+  public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
+    Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
+    Activity activity = mock(Activity.class);
+    when(activity.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
+    when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());
+
+    assertNotNull(retriever.get(activity));
+  }
+
+  @Test
+  public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
+    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
+    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
+    Activity spyActivity = Mockito.spy(activity);
+    when(spyActivity.isDestroyed()).thenThrow(new NoSuchMethodError());
+
+    assertNotNull(retriever.get(spyActivity));
+  }
+
+  @Test
+  public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
+    Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
+    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
+    android.app.Fragment fragment = new android.app.Fragment();
+
+    activity.getFragmentManager().beginTransaction().add(fragment, "test").commit();
+    android.app.Fragment spyFragment = Mockito.spy(fragment);
+    when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());
+
+    assertNotNull(retriever.get(spyFragment));
+  }
+
+  @Test
+  public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
+    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
+    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
+    android.app.Fragment fragment = new android.app.Fragment();
+
+    activity.getFragmentManager().beginTransaction().add(fragment, "test").commit();
+    android.app.Fragment spyFragment = Mockito.spy(fragment);
+    when(spyFragment.getChildFragmentManager()).thenThrow(new NoSuchMethodError());
+
+    assertNotNull(retriever.get(spyFragment));
+  }
+
+  private interface RetrieverHarness {
+
+    public ActivityController getController();
+
+    public RequestManager doGet();
+
+    public boolean hasFragmentWithTag(String tag);
+
+    public void addFragmentWithTag(String tag, RequestManager manager);
+  }
+
+  public class DefaultRetrieverHarness implements RetrieverHarness {
+    private final ActivityController<Activity> controller =
+        Robolectric.buildActivity(Activity.class);
+    private final android.app.Fragment parent;
+
+    public DefaultRetrieverHarness() {
+      this.parent = new android.app.Fragment();
+
+      controller.create();
+      controller.get().getFragmentManager().beginTransaction().add(parent, PARENT_TAG)
+          .commitAllowingStateLoss();
+      controller.get().getFragmentManager().executePendingTransactions();
+      controller.start().resume();
+    }
+
+    @Override
+    public ActivityController getController() {
+      return controller;
+    }
+
+    @Override
+    public RequestManager doGet() {
+      return retriever.get(controller.get());
+    }
+
+    @Override
+    public boolean hasFragmentWithTag(String tag) {
+      return null != controller
+          .get()
+          .getFragmentManager()
+          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
+    }
+
+    @Override
+    public void addFragmentWithTag(String tag, RequestManager requestManager) {
+      RequestManagerFragment fragment = new RequestManagerFragment();
+      fragment.setRequestManager(requestManager);
+      controller.get().getFragmentManager().beginTransaction()
+          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
+      controller.get().getFragmentManager().executePendingTransactions();
+    }
+  }
+
+  public class SupportRetrieverHarness implements RetrieverHarness {
+    private final ActivityController<FragmentActivity> controller =
+        Robolectric.buildActivity(FragmentActivity.class);
+    private final Fragment parent;
+
+    public SupportRetrieverHarness() {
+      this.parent = new Fragment();
+
+      controller.create();
+      controller.get().getSupportFragmentManager().beginTransaction().add(parent, PARENT_TAG)
+          .commitAllowingStateLoss();
+      controller.get().getSupportFragmentManager().executePendingTransactions();
+      controller.start().resume();
+    }
+
+    @Override
+    public ActivityController getController() {
+      return controller;
+    }
+
+    @Override
+    public RequestManager doGet() {
+      return retriever.get(controller.get());
+    }
+
+    @Override
+    public boolean hasFragmentWithTag(String tag) {
+      return controller.get().getSupportFragmentManager()
+          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG) != null;
+    }
+
+    @Override
+    public void addFragmentWithTag(String tag, RequestManager manager) {
+      SupportRequestManagerFragment fragment = new SupportRequestManagerFragment();
+      fragment.setRequestManager(manager);
+      controller.get().getSupportFragmentManager().beginTransaction()
+          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
+      controller.get().getSupportFragmentManager().executePendingTransactions();
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
new file mode 100644
index 000000000..2110a1613
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -0,0 +1,358 @@
+package com.bumptech.glide.manager;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.request.Request;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+@RunWith(JUnit4.class)
+public class RequestTrackerTest {
+  private RequestTracker tracker;
+
+  @Before
+  public void setUp() {
+    tracker = new RequestTracker();
+  }
+
+  @Test
+  public void testClearsAddedRequestsOnDestroy() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+
+    tracker.clearRequests();
+
+    verify(request).clear();
+    verify(request).recycle();
+  }
+
+  @Test
+  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsFalse() {
+    assertThat(tracker.clearRemoveAndRecycle(null)).isFalse();
+  }
+
+  @Test
+  public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
+    Request request = mock(Request.class);
+
+    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
+
+    verify(request, never()).clear();
+    verify(request, never()).recycle();
+  }
+
+  @Test
+  public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+
+    assertThat(tracker.clearRemoveAndRecycle(request)).isTrue();
+    verify(request).clear();
+    verify(request).recycle();
+  }
+
+  @Test
+  public void testClearRemoveAndRecyle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+    tracker.clearRemoveAndRecycle(request);
+    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
+
+    verify(request, times(1)).clear();
+    verify(request, times(1)).recycle();
+  }
+
+  @Test
+  public void testCanAddAndRemoveRequest() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+    tracker.clearRemoveAndRecycle(request);
+
+    tracker.clearRequests();
+
+    verify(request, times(1)).clear();
+  }
+
+  @Test
+  public void testCanAddMultipleRequests() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.clearRequests();
+
+    verify(first).clear();
+    verify(second).clear();
+  }
+
+  @Test
+  public void testPausesInProgressRequestsWhenPaused() {
+    Request request = mock(Request.class);
+    when(request.isRunning()).thenReturn(true);
+    tracker.addRequest(request);
+
+    tracker.pauseRequests();
+
+    verify(request).pause();
+  }
+
+  @Test
+  public void testDoesNotClearCompleteRequestsWhenPaused() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+
+    when(request.isComplete()).thenReturn(true);
+    tracker.pauseRequests();
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void testStartsRequestOnRun() {
+    Request request = mock(Request.class);
+    tracker.runRequest(request);
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void testDoesNotStartRequestOnRunIfPaused() {
+    Request request = mock(Request.class);
+    tracker.pauseRequests();
+    tracker.runRequest(request);
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void testStartsRequestAddedWhenPausedWhenResumed() {
+    Request request = mock(Request.class);
+    tracker.pauseRequests();
+    tracker.runRequest(request);
+    tracker.resumeRequests();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void testDoesNotClearFailedRequestsWhenPaused() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(true);
+    tracker.addRequest(request);
+
+    tracker.pauseRequests();
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void testRestartsStoppedRequestWhenResumed() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void testDoesNotRestartCompletedRequestsWhenResumed() {
+    Request request = mock(Request.class);
+    when(request.isComplete()).thenReturn(true);
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void testDoesRestartFailedRequestsWhenResumed() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(true);
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void testDoesNotStartStartedRequestsWhenResumed() {
+    Request request = mock(Request.class);
+    when(request.isRunning()).thenReturn(true);
+    tracker.addRequest(request);
+
+    tracker.resumeRequests();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void testAvoidsConcurrentModificationWhenResuming() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).begin();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.resumeRequests();
+  }
+
+  @Test
+  public void testAvoidsConcurrentModificationWhenPausing() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    when(first.isRunning()).thenReturn(true);
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.pauseRequests();
+  }
+
+  @Test
+  public void testAvoidsConcurrentModificationWhenClearing() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.clearRequests();
+  }
+
+  @Test
+  public void testAvoidsConcurrentModificationWhenRestarting() {
+    Request first = mock(Request.class);
+    Request second = mock(Request.class);
+
+    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();
+
+    tracker.addRequest(mock(Request.class));
+    tracker.addRequest(first);
+    tracker.addRequest(second);
+
+    tracker.restartRequests();
+  }
+
+  @Test
+  public void testRestartsFailedRequestRestart() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(true);
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void testPausesAndRestartsNotYetFinishedRequestsOnRestart() {
+    Request request = mock(Request.class);
+    when(request.isComplete()).thenReturn(false);
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    verify(request).pause();
+    verify(request).begin();
+  }
+
+  @Test
+  public void testDoesNotBeginFailedRequestOnRestartIfPaused() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(true);
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void testPausesFailedRequestOnRestartIfPaused() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(true);
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+
+    tracker.restartRequests();
+    verify(request).pause();
+  }
+
+  @Test
+  public void testDoesNotBeginIncompleteRequestsOnRestartIfPaused() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(false);
+    when(request.isComplete()).thenReturn(false);
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+    tracker.restartRequests();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void testPausesIncompleteRequestsOnRestartIfPaused() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(false);
+    when(request.isComplete()).thenReturn(false);
+    tracker.pauseRequests();
+    tracker.addRequest(request);
+    tracker.restartRequests();
+
+    verify(request).pause();
+  }
+
+  @Test
+  public void testReturnsTrueFromIsPausedWhenPaused() {
+    tracker.pauseRequests();
+    assertTrue(tracker.isPaused());
+  }
+
+  @Test
+  public void testReturnsFalseFromIsPausedWhenResumed() {
+    tracker.resumeRequests();
+    assertFalse(tracker.isPaused());
+  }
+
+  private class ClearAndRemoveRequest implements Answer<Void> {
+
+    private Request toRemove;
+
+    public ClearAndRemoveRequest(Request toRemove) {
+      this.toRemove = toRemove;
+    }
+
+    @Override
+    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+      tracker.clearRemoveAndRecycle(toRemove);
+      return null;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
new file mode 100644
index 000000000..ab71f9d20
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -0,0 +1,158 @@
+package com.bumptech.glide.module;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ManifestParserTest {
+  private static final String MODULE_VALUE = "GlideModule";
+
+  @Mock
+  Context context;
+  private ManifestParser parser;
+  private ApplicationInfo applicationInfo;
+
+  @Before
+  public void setUp() throws PackageManager.NameNotFoundException {
+    MockitoAnnotations.initMocks(this);
+    applicationInfo = new ApplicationInfo();
+    applicationInfo.metaData = new Bundle();
+
+    String packageName = "com.bumptech.test";
+    when(context.getPackageName()).thenReturn(packageName);
+
+    PackageManager pm = mock(PackageManager.class);
+    when(pm.getApplicationInfo(eq(packageName), eq(PackageManager.GET_META_DATA)))
+        .thenReturn(applicationInfo);
+    when(context.getPackageManager()).thenReturn(pm);
+
+    parser = new ManifestParser(context);
+  }
+
+  @Test
+  public void testParse_returnsEmptyListIfNoModulesListed() {
+    assertThat(parser.parse()).isEmpty();
+  }
+
+  @Test
+  public void testParse_withSingleValidModuleName_returnsListContainingModule() {
+    addModuleToManifest(TestModule1.class);
+
+    List<GlideModule> modules = parser.parse();
+    assertThat(modules).hasSize(1);
+    assertThat(modules.get(0)).isInstanceOf(TestModule1.class);
+  }
+
+  @Test
+  public void testParse_withMultipleValidModuleNames_returnsListContainingModules() {
+    addModuleToManifest(TestModule1.class);
+    addModuleToManifest(TestModule2.class);
+
+    List<GlideModule> modules = parser.parse();
+    assertThat(modules).hasSize(2);
+
+    assertThat(modules).contains(new TestModule1());
+    assertThat(modules).contains(new TestModule2());
+  }
+
+  @Test
+  public void testParse_withValidModuleName_ignoresMetadataWithoutGlideModuleValue() {
+    applicationInfo.metaData.putString(TestModule1.class.getName(), MODULE_VALUE + "test");
+
+    assertThat(parser.parse()).isEmpty();
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrows_whenModuleNameNotFound() {
+    addToManifest("fakeClassName");
+
+    parser.parse();
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrows_whenClassInManifestIsNotAModule() {
+    addModuleToManifest(InvalidClass.class);
+
+    parser.parse();
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrows_whenPackageNameNotFound() {
+    when(context.getPackageName()).thenReturn("fakePackageName");
+
+    parser.parse();
+  }
+
+  private void addModuleToManifest(Class<?> moduleClass) {
+    addToManifest(moduleClass.getName());
+  }
+
+  private void addToManifest(String key) {
+    applicationInfo.metaData.putString(key, MODULE_VALUE);
+  }
+
+  public static class InvalidClass {
+  }
+
+  public static class TestModule1 implements GlideModule {
+    @Override
+    public void applyOptions(Context context, GlideBuilder builder) {
+    }
+
+    @Override
+    public void registerComponents(Context context, Registry registry) {
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      return o instanceof TestModule1;
+    }
+
+    @Override
+    public int hashCode() {
+      return super.hashCode();
+    }
+  }
+
+  public static class TestModule2 implements GlideModule {
+
+    @Override
+    public void applyOptions(Context context, GlideBuilder builder) {
+    }
+
+    @Override
+    public void registerComponents(Context context, Registry registry) {
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      return o instanceof TestModule2;
+    }
+
+    @Override
+    public int hashCode() {
+      return super.hashCode();
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
new file mode 100644
index 000000000..dad0d87eb
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
@@ -0,0 +1,142 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.Transformation;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class BaseRequestOptionsTest {
+
+  private TestOptions options;
+  @Mock private Transformation<Bitmap> transformation;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    options = new TestOptions();
+  }
+
+  @Test
+  public void testIsTransformationRequired_byDefault_isFalse() {
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationSet_byDefault_isFalse() {
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_byDefault_isTrue() {
+    assertThat(options.isTransformationAllowed()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
+    TestOptions other = new TestOptions();
+    other.transform(Bitmap.class, transformation);
+    options.apply(other);
+    assertThat(options.isTransformationSet()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationAllowed()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testApplyingDontTransform_overridesTransformations() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingTransformation_overridesDontTransform() {
+    options.dontTransform();
+    options.transform(RuntimeEnvironment.application, transformation);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingOptions_withDontTransform_overridesTransformations() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    TestOptions other = new TestOptions();
+    other.dontTransform();
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingOptions_withTransformation_overridesDontTransform() {
+    options.dontTransform();
+    TestOptions other = new TestOptions();
+    other.transform(RuntimeEnvironment.application, transformation);
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationSet()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
+    options.dontTransform();
+    options.apply(new TestOptions());
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    options.apply(new TestOptions());
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  private static class TestOptions extends BaseRequestOptions<TestOptions> {
+    // Empty.
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
new file mode 100644
index 000000000..fb73a052b
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -0,0 +1,354 @@
+package com.bumptech.glide.request;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import android.os.Handler;
+
+import com.bumptech.glide.request.target.SizeReadyCallback;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class RequestFutureTargetTest {
+  private int width;
+  private int height;
+  private RequestFutureTarget<Object> future;
+  private Request request;
+  private Handler handler;
+  private RequestFutureTarget.Waiter waiter;
+
+  @Before
+  public void setUp() {
+    width = 100;
+    height = 100;
+    handler = mock(Handler.class);
+    waiter = mock(RequestFutureTarget.Waiter.class);
+    future = new RequestFutureTarget<>(handler, width, height, false, waiter);
+    request = mock(Request.class);
+    future.setRequest(request);
+  }
+
+  @Test
+  public void testCallsSizeReadyCallbackOnGetSize() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    future.getSize(cb);
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testReturnsFalseForDoneBeforeDone() {
+    assertFalse(future.isDone());
+  }
+
+  @Test
+  public void testReturnsTrueFromIsDoneIfDone() {
+    future.onResourceReady(new Object(), null);
+    assertTrue(future.isDone());
+  }
+
+  @Test
+  public void testReturnsFalseForIsCancelledBeforeCancelled() {
+    assertFalse(future.isCancelled());
+  }
+
+  @Test
+  public void testReturnsTrueFromCancelIfNotYetDone() {
+    assertTrue(future.cancel(false));
+  }
+
+  @Test
+  public void testClearsRequestOnMainThreadIfNotYetDoneOnCancel() {
+    future.cancel(true);
+
+    verify(handler).post(eq(future));
+  }
+
+  @Test
+  public void testClearsOnMainThreadWhenClearCalled() {
+    future.cancel(false);
+
+    verify(handler).post(eq(future));
+  }
+
+  @Test
+  public void testDoesNotRepeatedlyClearRequestOnMainThreadIfCancelledRepeatedly() {
+    future.cancel(true);
+    future.cancel(true);
+
+    verify(handler, times(1)).post(any(Runnable.class));
+  }
+
+  @Test
+  public void testClearsRequestOnRun() {
+    future.run();
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void testDoesNotClearRequestIfCancelledAfterDone() {
+    future.onResourceReady(new Object(), null);
+    future.cancel(true);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void testReturnsTrueFromDoneIfCancelled() {
+    future.cancel(true);
+    assertTrue(future.isDone());
+  }
+
+  @Test
+  public void testReturnsFalseFromIsCancelledIfCancelledAfterDone() {
+    future.onResourceReady(new Object(), null);
+    future.cancel(true);
+
+    assertFalse(future.isCancelled());
+  }
+
+  @Test
+  public void testReturnsTrueFromCancelIfCancelled() {
+    future.cancel(true);
+    assertTrue(future.isCancelled());
+  }
+
+  @Test
+  public void testReturnsFalseFromCancelIfDone() {
+    future.onResourceReady(new Object(), null);
+    assertFalse(future.cancel(true));
+  }
+
+  @Test
+  public void testReturnsResourceOnGetIfAlreadyDone()
+      throws ExecutionException, InterruptedException {
+    Object expected = new Object();
+    future.onResourceReady(expected, null);
+
+    assertEquals(expected, future.get());
+  }
+
+  @Test
+  public void testReturnsResourceOnGetWithTimeoutIfAlreadyDone()
+      throws InterruptedException, ExecutionException, TimeoutException {
+    Object expected = new Object();
+    future.onResourceReady(expected, null);
+
+    assertEquals(expected, future.get(100, TimeUnit.MILLISECONDS));
+  }
+
+  @Test(expected = CancellationException.class)
+  public void testThrowsCancellationExceptionIfCancelledBeforeGet()
+      throws ExecutionException, InterruptedException {
+    future.cancel(true);
+    future.get();
+  }
+
+  @Test(expected = CancellationException.class)
+  public void testThrowsCancellationExceptionIfCancelledBeforeGetWithTimeout()
+      throws InterruptedException, ExecutionException, TimeoutException {
+    future.cancel(true);
+    future.get(100, TimeUnit.MILLISECONDS);
+  }
+
+  @Test(expected = ExecutionException.class)
+  public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGet()
+      throws ExecutionException, InterruptedException {
+    future.onLoadFailed(null);
+    future.get();
+  }
+
+  @Test(expected = ExecutionException.class)
+  public void testThrowsExecutionExceptionOnGetIfExceptionWithNullValueBeforeGet()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    future.onLoadFailed(null);
+    future.get(100, TimeUnit.MILLISECONDS);
+  }
+
+  @Test(expected = ExecutionException.class)
+  public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGetWithTimeout()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    future.onLoadFailed(null);
+    future.get(100, TimeUnit.MILLISECONDS);
+  }
+
+  @Test(expected = TimeoutException.class)
+  public void testThrowsTimeoutExceptionOnGetIfFailedToReceiveResourceInTime()
+      throws InterruptedException, ExecutionException, TimeoutException {
+    future.get(1, TimeUnit.MILLISECONDS);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsExceptionIfGetCalledOnMainThread()
+      throws ExecutionException, InterruptedException {
+    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future.get();
+  }
+
+  @Test(expected = InterruptedException.class)
+  public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting()
+      throws InterruptedException, ExecutionException {
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Thread.currentThread().interrupt();
+        return null;
+      }
+    }).when(waiter).waitForTimeout(eq(future), anyLong());
+
+    future.get();
+  }
+
+  @Test(expected = ExecutionException.class)
+  public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
+      throws ExecutionException, InterruptedException {
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        future.onLoadFailed(null);
+        return null;
+      }
+    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    future.get();
+  }
+
+  @Test(expected = CancellationException.class)
+  public void testThrowsCancellationExceptionIfCancelledWhileWaiting()
+      throws ExecutionException, InterruptedException {
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        future.cancel(false);
+        return null;
+      }
+    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    future.get();
+  }
+
+  @Test(expected = TimeoutException.class)
+  public void testThrowsTimeoutExceptionIfFinishesWaitingWithTimeoutAndDoesNotReceiveResult()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    future.get(1, TimeUnit.MILLISECONDS);
+  }
+
+  @Test(expected = AssertionError.class)
+  public void testThrowsAssertionErrorIfFinishesWaitingWithoutTimeoutAndDoesNotReceiveResult()
+      throws ExecutionException, InterruptedException {
+    future.get();
+  }
+
+  @Test
+  public void testNotifiesAllWhenLoadFails() {
+    future.onLoadFailed(null);
+    verify(waiter).notifyAll(eq(future));
+  }
+
+  @Test
+  public void testNotifiesAllWhenResourceReady() {
+    future.onResourceReady(null, null);
+    verify(waiter).notifyAll(eq(future));
+  }
+
+  @Test
+  public void testNotifiesAllOnCancelIfNotCancelled() {
+    future.cancel(false);
+    verify(waiter).notifyAll(eq(future));
+  }
+
+  @Test
+  public void testDoesNotNotifyAllOnSecondCancel() {
+    future.cancel(true);
+    verify(waiter).notifyAll(eq(future));
+    future.cancel(true);
+    verify(waiter, times(1)).notifyAll(eq(future));
+  }
+
+  @Test
+  public void testReturnsResourceIfReceivedWhileWaiting()
+      throws ExecutionException, InterruptedException {
+    final Object expected = new Object();
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        future.onResourceReady(expected, null);
+        return null;
+      }
+    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    assertEquals(expected, future.get());
+  }
+
+  @Test
+  public void testWaitsForeverIfNoTimeoutSet() throws InterruptedException {
+    try {
+      future.get();
+    } catch (ExecutionException e) {
+      throw new RuntimeException(e);
+    } catch (AssertionError e) {
+      // Expected.
+    }
+    verify(waiter).waitForTimeout(eq(future), eq(0L));
+  }
+
+  @Test
+  public void testWaitsForGivenTimeoutMillisIfTimeoutSet() throws InterruptedException {
+    long timeout = 1234;
+    try {
+      future.get(1234, TimeUnit.MILLISECONDS);
+    } catch (InterruptedException | ExecutionException e) {
+      throw new RuntimeException(e);
+    } catch (TimeoutException e) {
+      // Expected.
+    }
+
+    verify(waiter).waitForTimeout(eq(future), eq(timeout));
+  }
+
+  @Test
+  public void testConvertsOtherTimeUnitsToMillisForWaiter() throws InterruptedException {
+    long timeoutSeconds = 10;
+    try {
+      future.get(timeoutSeconds, TimeUnit.SECONDS);
+    } catch (InterruptedException | ExecutionException e) {
+      throw new RuntimeException(e);
+    } catch (TimeoutException e) {
+      // Expected.
+    }
+
+    verify(waiter).waitForTimeout(eq(future), eq(TimeUnit.SECONDS.toMillis(timeoutSeconds)));
+  }
+
+  @Test
+  public void testDoesNotWaitIfGivenTimeOutEqualToZero() throws InterruptedException {
+    try {
+      future.get(0, TimeUnit.MILLISECONDS);
+    } catch (InterruptedException | ExecutionException e) {
+      throw new RuntimeException(e);
+    } catch (TimeoutException e) {
+      // Expected.
+    }
+
+    verify(waiter, never()).waitForTimeout(eq(future), anyLong());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
new file mode 100644
index 000000000..43af5105f
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -0,0 +1,817 @@
+package com.bumptech.glide.request;
+
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.request.transition.TransitionFactory;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class SingleRequestTest {
+  private RequestHarness harness;
+
+  /**
+   * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
+   * Both are in the middle of the hierarchy having multiple descendants and ancestors.
+   */
+  @SuppressWarnings("unchecked")
+  private static class RequestHarness {
+    Engine engine = mock(Engine.class);
+    Number model = 123456;
+    Target<List> target = mock(Target.class);
+    Resource<List> resource = mock(Resource.class);
+    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
+    Drawable placeholderDrawable = null;
+    Drawable errorDrawable = null;
+    Drawable fallbackDrawable = null;
+    RequestListener<List> requestListener = mock(RequestListener.class);
+    TransitionFactory<List> factory = mock(TransitionFactory.class);
+    int overrideWidth = -1;
+    int overrideHeight = -1;
+    List result = new ArrayList();
+    GlideContext glideContext = mock(GlideContext.class);
+    Key signature = mock(Key.class);
+    Priority priority = Priority.HIGH;
+
+    Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
+
+    public RequestHarness() {
+      when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
+      when(resource.get()).thenReturn(result);
+    }
+
+    public SingleRequest<List> getRequest() {
+       RequestOptions requestOptions = new RequestOptions()
+        .error(errorDrawable)
+        .placeholder(placeholderDrawable)
+        .fallback(fallbackDrawable)
+        .override(overrideWidth, overrideHeight)
+        .priority(priority)
+        .signature(signature);
+      return SingleRequest
+          .obtain(glideContext, model, List.class, requestOptions, overrideWidth, overrideHeight,
+              priority, target, requestListener, requestCoordinator, engine, factory);
+    }
+  }
+
+  @Before
+  public void setUp() {
+    harness = new RequestHarness();
+  }
+
+  @Test
+  public void testIsNotCompleteBeforeReceivingResource() {
+    SingleRequest<List> request = harness.getRequest();
+
+    assertFalse(request.isComplete());
+  }
+
+  @Test
+  public void testCanHandleNullResources() {
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onResourceReady(null, DataSource.LOCAL);
+
+    assertTrue(request.isFailed());
+    verify(harness.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),
+        eq(harness.target), anyBoolean());
+  }
+
+  @Test
+  public void testCanHandleEmptyResources() {
+    SingleRequest<List> request = harness.getRequest();
+    when(harness.resource.get()).thenReturn(null);
+
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
+
+    assertTrue(request.isFailed());
+    verify(harness.engine).release(eq(harness.resource));
+    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(harness.target), anyBoolean());
+  }
+
+  @Test
+  public void testCanHandleNonConformingResources() {
+    SingleRequest<List> request = harness.getRequest();
+    when(((Resource) (harness.resource)).get())
+        .thenReturn("Invalid mocked String, this should be a List");
+
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    assertTrue(request.isFailed());
+    verify(harness.engine).release(eq(harness.resource));
+    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(harness.target), anyBoolean());
+  }
+
+  @Test
+  public void testIsNotFailedAfterClear() {
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
+    request.clear();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsPausedAfterPause() {
+    SingleRequest<List> request = harness.getRequest();
+    request.pause();
+
+    assertTrue(request.isPaused());
+  }
+
+  @Test
+  public void testIsNotCancelledAfterPause() {
+    SingleRequest<List> request = harness.getRequest();
+    request.pause();
+
+    assertFalse(request.isCancelled());
+  }
+
+  @Test
+  public void testIsNotPausedAfterBeginningWhilePaused() {
+    SingleRequest<List> request = harness.getRequest();
+    request.pause();
+    request.begin();
+
+    assertFalse(request.isPaused());
+    assertTrue(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotFailedAfterBegin() {
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
+    request.begin();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsCompleteAfterReceivingResource() {
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
+
+    assertTrue(request.isComplete());
+  }
+
+  @Test
+  public void testIsNotCompleteAfterClear() {
+    SingleRequest<List> request = harness.getRequest();
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
+    request.clear();
+
+    assertFalse(request.isComplete());
+  }
+
+  @Test
+  public void testIsCancelledAfterClear() {
+    SingleRequest<List> request = harness.getRequest();
+    request.clear();
+
+    assertTrue(request.isCancelled());
+  }
+
+  @Test
+  public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
+    SingleRequest<List> request = harness.getRequest();
+    request.clear();
+    request.clear();
+
+    verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
+    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        Request request = (Request) invocation.getArguments()[0];
+        assertFalse(request.isComplete());
+        return true;
+      }
+    }).when(requestCoordinator).canSetImage(any(Request.class));
+
+    harness.requestCoordinator = requestCoordinator;
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(requestCoordinator).canSetImage(eq(request));
+  }
+
+  @Test
+  public void testIsNotFailedWithoutException() {
+    SingleRequest<List> request = harness.getRequest();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsFailedAfterException() {
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onLoadFailed(new GlideException("test"));
+    assertTrue(request.isFailed());
+  }
+
+  @Test
+  public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+    request.onSizeReady(100, 100);
+    request.onSizeReady(100, 100);
+
+    verify(harness.engine, times(1))
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
+            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
+            eq(harness.transformations), anyBoolean(), any(Options.class),
+            anyBoolean(), any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testIsFailedAfterNoResultAndNullException() {
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onLoadFailed(new GlideException("test"));
+    assertTrue(request.isFailed());
+  }
+
+  @Test
+  public void testEngineLoadCancelledOnCancel() {
+    Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
+
+    when(harness.engine
+       .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
+          eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
+          eq(harness.transformations), anyBoolean(), any(Options.class),
+          anyBoolean(), any(ResourceCallback.class)))
+        .thenReturn(loadStatus);
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    request.onSizeReady(100, 100);
+    request.cancel();
+
+    verify(loadStatus).cancel();
+  }
+
+  @Test
+  public void testResourceIsRecycledOnClear() {
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
+    request.clear();
+
+    verify(harness.engine).release(eq(harness.resource));
+  }
+
+  @Test
+  public void testPlaceholderDrawableIsSet() {
+    Drawable expected = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    harness.placeholderDrawable = expected;
+    harness.target = target;
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    assertEquals(expected, target.currentPlaceholder);
+  }
+
+  @Test
+  public void testErrorDrawableIsSetOnLoadFailed() {
+    Drawable expected = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    harness.errorDrawable = expected;
+    harness.target = target;
+    SingleRequest<List> request = harness.getRequest();
+
+    request.onLoadFailed(new GlideException("test"));
+
+    assertEquals(expected, target.currentPlaceholder);
+  }
+
+  @Test
+  public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    harness.placeholderDrawable = placeholder;
+    harness.target = target;
+    harness.model = null;
+    SingleRequest<List> request = harness.getRequest();
+
+    request.begin();
+
+    assertEquals(placeholder, target.currentPlaceholder);
+  }
+
+  @Test
+  public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
+
+    MockTarget target = new MockTarget();
+
+    harness.placeholderDrawable = placeholder;
+    harness.errorDrawable = errorPlaceholder;
+    harness.target = target;
+    harness.model = null;
+    SingleRequest<List> request = harness.getRequest();
+
+    request.begin();
+
+    assertEquals(errorPlaceholder, target.currentPlaceholder);
+  }
+
+
+  @Test
+  public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
+    Drawable fallback = new ColorDrawable(Color.BLUE);
+
+    MockTarget target = new MockTarget();
+    harness.placeholderDrawable = placeholder;
+    harness.errorDrawable = errorPlaceholder;
+    harness.fallbackDrawable = fallback;
+    harness.target = target;
+    harness.model = null;
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+    assertEquals(fallback, target.currentPlaceholder);
+  }
+
+
+  @Test
+  public void testIsNotRunningBeforeRunCalled() {
+    assertFalse(harness.getRequest().isRunning());
+  }
+
+  @Test
+  public void testIsRunningAfterRunCalled() {
+    Request request = harness.getRequest();
+    request.begin();
+    assertTrue(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterComplete() {
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterFailing() {
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+    request.onLoadFailed(new GlideException("test"));
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterClear() {
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+    request.clear();
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testCallsTargetOnResourceReadyIfNoRequestListener() {
+    harness.requestListener = null;
+    SingleRequest<List> request = harness.getRequest();
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
+
+    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
+  }
+
+  @Test
+  public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
+    SingleRequest<List> request = harness.getRequest();
+    when(harness.requestListener
+        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
+            anyBoolean())).thenReturn(false);
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
+
+    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
+  }
+
+  @Test
+  public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
+    SingleRequest<List> request = harness.getRequest();
+    when(harness.requestListener
+        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
+            anyBoolean())).thenReturn(true);
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
+
+    verify(harness.target, never()).onResourceReady(any(List.class), anyTransition());
+  }
+
+  @Test
+  public void testCallsTargetOnExceptionIfNoRequestListener() {
+    harness.requestListener = null;
+    SingleRequest<List> request = harness.getRequest();
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(harness.target).onLoadFailed(eq(harness.errorDrawable));
+  }
+
+  @Test
+  public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
+    SingleRequest<List> request = harness.getRequest();
+    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(harness.target), anyBoolean()))
+        .thenReturn(false);
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(harness.target).onLoadFailed(eq(harness.errorDrawable));
+  }
+
+  @Test
+  public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
+    SingleRequest<List> request = harness.getRequest();
+    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(harness.target), anyBoolean()))
+        .thenReturn(true);
+
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(harness.target, never()).onLoadFailed(any(Drawable.class));
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithResourceResult() {
+    SingleRequest<List> request = harness.getRequest();
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(harness.requestListener)
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithModel() {
+    SingleRequest<List> request = harness.getRequest();
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(harness.requestListener)
+        .onResourceReady(any(List.class), eq(harness.model), isAListTarget(), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithTarget() {
+    SingleRequest<List> request = harness.getRequest();
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(harness.requestListener)
+        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
+    final SingleRequest<List> request = harness.getRequest();
+
+    when(harness.engine
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), any(ResourceCallback.class)))
+        .thenAnswer(new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) throws Throwable {
+            request.onResourceReady(harness.resource, DataSource.MEMORY_CACHE);
+            return null;
+          }
+        });
+
+    request.begin();
+    request.onSizeReady(100, 100);
+    verify(harness.requestListener)
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
+            eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void
+  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
+    SingleRequest<List> request = harness.getRequest();
+    request.onSizeReady(100, 100);
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
+
+    verify(harness.requestListener)
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
+            eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
+    harness.requestCoordinator = null;
+    SingleRequest<List> request = harness.getRequest();
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(harness.requestListener)
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
+            eq(true));
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
+    SingleRequest<List> request = harness.getRequest();
+    when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(harness.requestListener)
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
+            eq(true));
+  }
+
+  @Test
+  public void
+  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
+    SingleRequest<List> request = harness.getRequest();
+    when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(harness.requestListener)
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
+            isADataSource(), eq(false));
+  }
+
+  @Test
+  public void testTargetIsCalledWithAnimationFromFactory() {
+    SingleRequest<List> request = harness.getRequest();
+    Transition<List> transition = mockTransition();
+    when(harness.factory.build(any(DataSource.class), anyBoolean())).thenReturn(transition);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(harness.target).onResourceReady(eq(harness.result), eq(transition));
+  }
+
+  @Test
+  public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
+    harness.overrideWidth = -1;
+    harness.overrideHeight = 100;
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.target).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
+    harness.overrideHeight = -1;
+    harness.overrideWidth = 100;
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.target).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
+    harness.overrideWidth = 100;
+    harness.overrideHeight = 100;
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
+    harness.overrideWidth = 1;
+    harness.overrideHeight = 2;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
+    harness.errorDrawable = new ColorDrawable(Color.RED);
+    SingleRequest<List> request = harness.getRequest();
+    when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(harness.target, never()).onLoadFailed(any(Drawable.class));
+  }
+
+  @Test
+  public void testCanReRunCancelledRequests() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    when(harness.engine
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
+            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
+            eq(harness.transformations), anyBoolean(), any(Options.class),
+            anyBoolean(), any(ResourceCallback.class)))
+        .thenAnswer(new CallResourceCallback(harness.resource));
+    SingleRequest<List> request = harness.getRequest();
+
+    request.begin();
+    request.cancel();
+    request.begin();
+
+    verify(harness.target, times(2)).onResourceReady(eq(harness.result), anyTransition());
+  }
+
+  @Test
+  public void testResourceOnlyReceivesOneGetOnResourceReady() {
+    SingleRequest<List> request = harness.getRequest();
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
+
+    verify(harness.resource, times(1)).get();
+  }
+
+  @Test
+  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
+    SingleRequest<List> request = harness.getRequest();
+    request.cancel();
+    request.onSizeReady(100, 100);
+
+    verify(harness.engine, never())
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> mockTransition() {
+    return mock(Transition.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Target<List> isAListTarget() {
+    return isA(Target.class);
+  }
+
+  private static GlideException isAGlideException() {
+    return isA(GlideException.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> anyTransition() {
+    return any(Transition.class);
+  }
+
+  private static class CallResourceCallback implements Answer {
+
+    private Resource resource;
+
+    public CallResourceCallback(Resource resource) {
+      this.resource = resource;
+    }
+
+    @Override
+    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      ResourceCallback cb =
+          (ResourceCallback) invocationOnMock.getArguments()[invocationOnMock.getArguments().length
+              - 1];
+      cb.onResourceReady(resource, DataSource.REMOTE);
+      return null;
+    }
+  }
+
+  private static class CallSizeReady implements Answer {
+
+    private int width;
+    private int height;
+
+    public CallSizeReady(int width, int height) {
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      SizeReadyCallback cb = (SizeReadyCallback) invocationOnMock.getArguments()[0];
+      cb.onSizeReady(width, height);
+      return null;
+    }
+  }
+
+  private static class MockTarget implements Target<List> {
+    private Drawable currentPlaceholder;
+
+    @Override
+    public void onLoadCleared(Drawable placeholder) {
+      currentPlaceholder = placeholder;
+    }
+
+    @Override
+    public void onLoadStarted(Drawable placeholder) {
+      currentPlaceholder = placeholder;
+
+    }
+
+    @Override
+    public void onLoadFailed(Drawable errorDrawable) {
+      currentPlaceholder = errorDrawable;
+
+    }
+
+    @Override
+    public void onResourceReady(List resource, Transition<? super List> transition) {
+      currentPlaceholder = null;
+    }
+
+
+    @Override
+    public void getSize(SizeReadyCallback cb) {
+    }
+
+    @Override
+    public void setRequest(Request request) {
+    }
+
+    @Override
+    public Request getRequest() {
+      return null;
+    }
+
+    @Override
+    public void onStart() {
+    }
+
+    @Override
+    public void onStop() {
+
+    }
+
+    @Override
+    public void onDestroy() {
+
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
new file mode 100644
index 000000000..0b982933f
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -0,0 +1,333 @@
+package com.bumptech.glide.request;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+@RunWith(JUnit4.class)
+public class ThumbnailRequestCoordinatorTest {
+  private Request full;
+  private Request thumb;
+  private ThumbnailRequestCoordinator coordinator;
+  private RequestCoordinator parent;
+
+  @Before
+  public void setUp() {
+    full = mock(Request.class);
+    thumb = mock(Request.class);
+    parent = mock(RequestCoordinator.class);
+    coordinator = new ThumbnailRequestCoordinator();
+    coordinator.setRequests(full, thumb);
+  }
+
+  @Test
+  public void testIsRunningIsFalseIfNeitherRequestIsRunning() {
+    assertFalse(coordinator.isRunning());
+  }
+
+  @Test
+  public void testIsRunningIsTrueIfFullIsRunning() {
+    when(full.isRunning()).thenReturn(true);
+    assertTrue(coordinator.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningIfFullIsNotRunningButThumbIs() {
+    when(full.isRunning()).thenReturn(false);
+    when(thumb.isRunning()).thenReturn(true);
+    assertFalse(coordinator.isRunning());
+  }
+
+  @Test
+  public void testStartsFullOnRunIfNotRunning() {
+    when(full.isRunning()).thenReturn(false);
+    coordinator.begin();
+
+    verify(full).begin();
+  }
+
+  @Test
+  public void testStartsThumbOnRunIfNotRunning() {
+    when(thumb.isRunning()).thenReturn(false);
+    coordinator.begin();
+
+    verify(thumb).begin();
+  }
+
+  @Test
+  public void testDoesNotStartFullOnRunIfRunning() {
+    when(full.isRunning()).thenReturn(true);
+    coordinator.begin();
+
+    verify(full, never()).begin();
+  }
+
+  @Test
+  public void testDoesNotStartThumbOnRunIfRunning() {
+    when(thumb.isRunning()).thenReturn(true);
+    coordinator.begin();
+
+    verify(thumb, never()).begin();
+  }
+
+  @Test
+  public void testDoesNotStartFullIfClearedByThumb() {
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocation) throws Throwable {
+        coordinator.clear();
+
+        return null;
+      }
+    }).when(thumb).begin();
+
+    coordinator.begin();
+
+    verify(full, never()).begin();
+  }
+
+  @Test
+  public void testCallsClearOnRequestsWhenCleared() {
+    coordinator.clear();
+    InOrder order = inOrder(thumb, full);
+    order.verify(thumb).clear();
+    order.verify(full).clear();
+  }
+
+  @Test
+  public void testRecyclesRequestsWhenRecycled() {
+    coordinator.recycle();
+    verify(thumb).recycle();
+    verify(full).recycle();
+  }
+
+  @Test
+  public void testIsPausedWhenFullIsPaused() {
+    when(full.isPaused()).thenReturn(true);
+    assertTrue(coordinator.isPaused());
+  }
+
+  @Test
+  public void testPausesBothRequestsWhenPaused() {
+    coordinator.pause();
+    verify(full).pause();
+    verify(thumb).pause();
+  }
+
+  @Test
+  public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
+    coordinator = new ThumbnailRequestCoordinator();
+    coordinator.setRequests(full, thumb);
+    assertTrue(coordinator.canSetImage(full));
+  }
+
+  @Test
+  public void testCanSetImageReturnsTrueForFullRequestIfParentAllowsSetImage() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canSetImage(eq(coordinator))).thenReturn(true);
+    assertTrue(coordinator.canSetImage(full));
+  }
+
+  @Test
+  public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImage() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canSetImage(eq(coordinator))).thenReturn(false);
+    assertFalse(coordinator.canSetImage(full));
+  }
+
+  @Test
+  public void
+  testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
+    when(full.isResourceSet()).thenReturn(false);
+    assertTrue(coordinator.canSetImage(thumb));
+  }
+
+  @Test
+  public void testCanSetImageReturnsFalseForThumbRequestIfParentIsNullAndFullHasResourceSet() {
+    when(full.isResourceSet()).thenReturn(true);
+    assertFalse(coordinator.canSetImage(thumb));
+  }
+
+  @Test
+  public void testCanNotSetImageForThumbIfNotAllowedByParentAndFullDoesNotHaveResourceSet() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canSetImage(eq(coordinator))).thenReturn(false);
+    when(full.isResourceSet()).thenReturn(false);
+    assertFalse(coordinator.canSetImage(thumb));
+  }
+
+  @Test
+  public void testCanNotifyStatusChangedIfFullAndNoRequestsAreComplete() {
+    assertTrue(coordinator.canNotifyStatusChanged(full));
+  }
+
+  @Test
+  public void testCanNotNotifyStatusChangedIfThumb() {
+    assertFalse(coordinator.canNotifyStatusChanged(thumb));
+  }
+
+  @Test
+  public void testCanNotNotifyStatusChangedIfFullHasResourceSet() {
+    when(full.isResourceSet()).thenReturn(true);
+    assertFalse(coordinator.canNotifyStatusChanged(full));
+  }
+
+  @Test
+  public void testCanNotNotifyStatusChangedIfThumbHasResourceSet() {
+    when(thumb.isResourceSet()).thenReturn(true);
+    assertFalse(coordinator.canNotifyStatusChanged(full));
+  }
+
+  @Test
+  public void testCanNotNotifyStatusChangedIfParentHasResourceSet() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+    assertFalse(coordinator.canNotifyStatusChanged(full));
+  }
+
+  @Test
+  public void testCanNotifyStatusChangedIfParentAllowsNotify() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(true);
+    assertTrue(coordinator.canNotifyStatusChanged(full));
+  }
+
+  @Test
+  public void testCanNotNotifyStatusChangedIfParentDoesNotAllowNotify() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(false);
+    assertFalse(coordinator.canNotifyStatusChanged(full));
+  }
+
+  @Test
+  public void testIsAnyResourceSetIsFalseIfNeitherRequestHasResourceSet() {
+    when(full.isResourceSet()).thenReturn(false);
+    when(thumb.isResourceSet()).thenReturn(false);
+    assertFalse(coordinator.isAnyResourceSet());
+  }
+
+  @Test
+  public void testIsAnyResourceSetIsTrueIfFullHasResourceSet() {
+    when(full.isResourceSet()).thenReturn(true);
+    when(thumb.isResourceSet()).thenReturn(false);
+    assertTrue(coordinator.isAnyResourceSet());
+  }
+
+  @Test
+  public void testIsAnyResourceSetIsTrueIfThumbHasResourceSet() {
+    when(full.isResourceSet()).thenReturn(false);
+    when(thumb.isResourceSet()).thenReturn(true);
+    assertTrue(coordinator.isAnyResourceSet());
+  }
+
+  @Test
+  public void testIsAnyResourceSetIsTrueIfParentIsNonNullAndParentHasResourceSet() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+
+    when(parent.isAnyResourceSet()).thenReturn(true);
+    when(full.isResourceSet()).thenReturn(false);
+    when(thumb.isResourceSet()).thenReturn(false);
+
+    assertTrue(coordinator.isAnyResourceSet());
+  }
+
+  @Test
+  public void testIsNotCompleteIfNeitherRequestIsComplete() {
+    assertFalse(coordinator.isComplete());
+  }
+
+  @Test
+  public void testIsCompleteIfFullIsComplete() {
+    when(full.isComplete()).thenReturn(true);
+    assertTrue(coordinator.isComplete());
+  }
+
+  @Test
+  public void testIsCompleteIfThumbIsComplete() {
+    when(thumb.isComplete()).thenReturn(true);
+    assertTrue(coordinator.isComplete());
+  }
+
+  @Test
+  public void testIsResourceSetIsFalseIfNeitherRequestHasResourceSet() {
+    assertFalse(coordinator.isResourceSet());
+  }
+
+  @Test
+  public void testIsResourceSetIsTrueIfFullRequestHasResourceSet() {
+    when(full.isResourceSet()).thenReturn(true);
+    assertTrue(coordinator.isResourceSet());
+  }
+
+  @Test
+  public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
+    when(thumb.isResourceSet()).thenReturn(true);
+    assertTrue(coordinator.isResourceSet());
+  }
+
+  @Test
+  public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
+    coordinator.onRequestSuccess(full);
+    verify(thumb).clear();
+  }
+
+  @Test
+  public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    coordinator.onRequestSuccess(full);
+    verify(parent).onRequestSuccess(eq(coordinator));
+  }
+
+  @Test
+  public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    coordinator.onRequestSuccess(full);
+    verify(thumb).clear();
+  }
+
+  @Test
+  public void testDoesNotClearThumbOnThumbRequestComplete() {
+    coordinator.onRequestSuccess(thumb);
+    verify(thumb, never()).clear();
+  }
+
+  @Test
+  public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
+      when(thumb.isComplete()).thenReturn(true);
+      coordinator.onRequestSuccess(full);
+      verify(thumb, never()).clear();
+  }
+
+  @Test
+  public void testDoesNotNotifyParentOnThumbRequestComplete() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    coordinator.onRequestSuccess(thumb);
+
+    verify(parent, never()).onRequestSuccess(any(Request.class));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
new file mode 100644
index 000000000..8a13ace4b
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -0,0 +1,147 @@
+package com.bumptech.glide.request.target;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import android.appwidget.AppWidgetManager;
+import android.content.ComponentName;
+import android.graphics.Bitmap;
+import android.widget.RemoteViews;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadows.ShadowAppWidgetManager;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = AppWidgetTargetTest
+    .UpdateShadowAppWidgetManager.class)
+public class AppWidgetTargetTest {
+
+  private UpdateShadowAppWidgetManager shadowManager;
+  private RemoteViews views;
+  private int viewId;
+
+  @Before
+  public void setUp() {
+    shadowManager = (UpdateShadowAppWidgetManager) ShadowExtractor
+        .extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
+    viewId = 1234;
+    views = mock(RemoteViews.class);
+  }
+
+  @Test
+  public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName() {
+    ComponentName componentName = mock(ComponentName.class);
+    AppWidgetTarget target =
+        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    target.onResourceReady(bitmap, null /*glideAnimation*/);
+
+    verify(views).setImageViewBitmap(eq(viewId), eq(bitmap));
+  }
+
+  @Test
+  public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
+    ComponentName componentName = mock(ComponentName.class);
+    AppWidgetTarget target =
+        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+
+    target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+    /*glideAnimation*/);
+
+    assertEquals(componentName, shadowManager.updatedComponentName);
+    assertEquals(views, shadowManager.updatedRemoteViews);
+  }
+
+  @Test
+  public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
+    int[] widgetIds = new int[] { 1 };
+    AppWidgetTarget target =
+        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
+    target.onResourceReady(bitmap, null /*glideAnimation*/);
+
+    verify(views).setImageViewBitmap(eq(viewId), eq(bitmap));
+  }
+
+  @Test
+  public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
+    int[] widgetIds = new int[] { 1 };
+    AppWidgetTarget target =
+        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+
+    target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
+    /*glideAnimation*/);
+
+    assertThat(widgetIds).isEqualTo(shadowManager.updatedWidgetIds);
+    assertEquals(views, shadowManager.updatedRemoteViews);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsWhenGivenNullContextWithWidgetIds() {
+    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, 1 /*widgetIds*/);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsWhenGivenNullContextWithComponentName() {
+    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, mock(ComponentName.class));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
+    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId, 1
+    /*widgetIds*/);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
+    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId,
+        mock(ComponentName.class));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsWhenGivenNullWidgetIds() {
+    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (int[]) null /*widgetIds*/);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsWhenGivenEmptyWidgetIds() {
+    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsWhenGivenNullComponentName() {
+    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (ComponentName) null);
+  }
+
+  @Implements(AppWidgetManager.class)
+  public static class UpdateShadowAppWidgetManager extends ShadowAppWidgetManager {
+    public int[] updatedWidgetIds;
+    public RemoteViews updatedRemoteViews;
+    public ComponentName updatedComponentName;
+
+    @Implementation
+    public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
+      updatedWidgetIds = appWidgetIds;
+      updatedRemoteViews = views;
+    }
+
+    @Implementation
+    public void updateAppWidget(ComponentName componentName, RemoteViews views) {
+      updatedComponentName = componentName;
+      updatedRemoteViews = views;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
new file mode 100644
index 000000000..7689e0d9a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.request.target;
+
+import static org.junit.Assert.assertEquals;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.widget.ImageView;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class BitmapImageViewTargetTest {
+
+  private ImageView view;
+  private BitmapImageViewTarget target;
+
+  @Before
+  public void setUp() {
+    view = new ImageView(RuntimeEnvironment.application);
+    target = new BitmapImageViewTarget(view);
+  }
+
+  @Test
+  public void testSetsBitmapOnViewInSetResource() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 75, Bitmap.Config.RGB_565);
+    target.setResource(bitmap);
+    assertEquals(bitmap, ((BitmapDrawable) view.getDrawable()).getBitmap());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
new file mode 100644
index 000000000..238151560
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
@@ -0,0 +1,60 @@
+package com.bumptech.glide.request.target;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ImageViewTargetFactoryTest {
+  private ImageViewTargetFactory factory;
+  private ImageView view;
+
+  @Before
+  public void setUp() {
+    factory = new ImageViewTargetFactory();
+    view = new ImageView(RuntimeEnvironment.application);
+  }
+
+  @Test
+  public void testReturnsTargetForBitmaps() {
+    Bitmap bitmap = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+    Target<Bitmap> target = factory.buildTarget(view, Bitmap.class);
+    target.onResourceReady(bitmap, null);
+    assertThat(target).isInstanceOf(BitmapImageViewTarget.class);
+  }
+
+  @Test
+  public void testReturnsTargetForBitmapDrawables() {
+    BitmapDrawable drawable = new BitmapDrawable(RuntimeEnvironment.application.getResources(),
+        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
+
+    Target target = factory.buildTarget(view, BitmapDrawable.class);
+    target.onResourceReady(drawable, null);
+    assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
+  }
+
+  @Test
+  public void testReturnsTargetForDrawables() {
+    Target<Drawable> target = factory.buildTarget(view, Drawable.class);
+    target.onResourceReady(new ColorDrawable(Color.RED), null);
+    assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsForUnknownType() {
+    factory.buildTarget(view, Object.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
new file mode 100644
index 000000000..c734c8baf
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -0,0 +1,119 @@
+package com.bumptech.glide.request.target;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+
+import com.bumptech.glide.request.transition.Transition;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ImageViewTargetTest {
+
+  private ImageView view;
+  private TestTarget target;
+  private ColorDrawable drawable;
+
+  @Before
+  public void setUp() {
+    view = new ImageView(RuntimeEnvironment.application);
+    target = new TestTarget(view);
+    drawable = new ColorDrawable(Color.RED);
+  }
+
+  @Test
+  public void testReturnsCurrentDrawable() {
+    view.setImageDrawable(drawable);
+
+    assertEquals(drawable, target.getCurrentDrawable());
+  }
+
+  @Test
+  public void testSetsDrawableSetsDrawableOnView() {
+    target.setDrawable(drawable);
+
+    assertEquals(drawable, view.getDrawable());
+  }
+
+  @Test
+  public void testSetsDrawableOnLoadStarted() {
+    target.onLoadStarted(drawable);
+
+    assertEquals(drawable, view.getDrawable());
+  }
+
+  @Test
+  public void testSetDrawableOnLoadFailed() {
+    target.onLoadFailed(drawable);
+
+    assertEquals(drawable, view.getDrawable());
+  }
+
+  @Test
+  public void testSetsDrawableOnLoadCleared() {
+    target.onLoadCleared(drawable);
+
+    assertEquals(drawable, view.getDrawable());
+  }
+
+  @Test
+  public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
+    Transition<Drawable> animation = mock(Transition.class);
+    when(animation.transition(any(Drawable.class), eq(target))).thenReturn(false);
+    Drawable resource = new ColorDrawable(Color.GRAY);
+    target.onResourceReady(resource, animation);
+
+    assertEquals(resource, target.resource);
+  }
+
+  @Test
+  public void testDoesNotSetDrawableOnViewInOnResourceReadyWhenAnimationReturnsTrue() {
+    Drawable resource = new ColorDrawable(Color.RED);
+    Transition<Drawable> animation = mock(Transition.class);
+    when(animation.transition(eq(resource), eq(target))).thenReturn(true);
+    target.onResourceReady(resource, animation);
+
+    assertNull(target.resource);
+  }
+
+  @Test
+  public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
+    Drawable placeholder = new ColorDrawable(Color.BLACK);
+    view.setImageDrawable(placeholder);
+
+    Transition<Drawable> animation = mock(Transition.class);
+
+    target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
+
+    verify(animation).transition(eq(placeholder), eq(target));
+  }
+
+  private static class TestTarget extends ImageViewTarget<Drawable> {
+    public Drawable resource;
+
+    public TestTarget(ImageView view) {
+      super(view);
+    }
+
+    @Override
+    protected void setResource(Drawable resource) {
+      this.resource = resource;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
new file mode 100644
index 000000000..1a0dfc8d1
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.request.target;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.widget.RemoteViews;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadows.ShadowNotificationManager;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = NotificationTargetTest
+    .UpdateShadowNotificationManager.class)
+public class NotificationTargetTest {
+
+  private UpdateShadowNotificationManager shadowManager;
+  private RemoteViews remoteViews;
+  private int viewId;
+  private Notification notification;
+  private int notificationId;
+  private NotificationTarget target;
+
+  @Before
+  public void setUp() {
+    NotificationManager notificationManager = (NotificationManager) RuntimeEnvironment.application
+        .getSystemService(Context.NOTIFICATION_SERVICE);
+    shadowManager = (UpdateShadowNotificationManager) ShadowExtractor.extract(notificationManager);
+
+    remoteViews = mock(RemoteViews.class);
+    viewId = 123;
+    notification = mock(Notification.class);
+    notificationId = 456;
+
+
+    target =
+        new NotificationTarget(RuntimeEnvironment.application, remoteViews, viewId, 100 /*width*/,
+            100 /*height*/, notification, notificationId);
+  }
+
+  @Test
+  public void testSetsBitmapOnRemoteViewsWithGivenImageIdOnResourceReady() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    target.onResourceReady(bitmap, null /*glideAnimation*/);
+    verify(remoteViews).setImageViewBitmap(eq(viewId), eq(bitmap));
+  }
+
+  @Test
+  public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourceReady() {
+    target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+    /*glideAnimation*/);
+
+    assertEquals(notificationId, shadowManager.updatedNotificationId);
+    assertEquals(notification, shadowManager.updatedNotification);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfContextIsNull() {
+    new NotificationTarget(null /*context*/, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
+        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+  }
+
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfNotificationIsNull() {
+    new NotificationTarget(RuntimeEnvironment.application, mock(RemoteViews.class), 123 /*viewId*/,
+        100 /*width*/, 100 /*height*/, null /*notification*/, 456 /*notificationId*/);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfRemoteViewsIsNull() {
+    new NotificationTarget(RuntimeEnvironment.application, null /*remoteViews*/, 123 /*viewId*/,
+        100 /*width*/,
+        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+  }
+
+  @Implements(NotificationManager.class)
+  public static class UpdateShadowNotificationManager extends ShadowNotificationManager {
+    int updatedNotificationId;
+    Notification updatedNotification;
+
+    @Implementation
+    public void notify(int notificationId, Notification notification) {
+      updatedNotificationId = notificationId;
+      updatedNotification = notification;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
new file mode 100644
index 000000000..5a6674534
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
@@ -0,0 +1,49 @@
+package com.bumptech.glide.request.target;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.request.Request;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class PreloadTargetTest {
+
+  @Mock RequestManager requestManager;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testCallsSizeReadyWithGivenDimensions() {
+    int width = 1234;
+    int height = 456;
+    PreloadTarget<Object> target = PreloadTarget.obtain(requestManager, width, height);
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testClearsTargetInOnResourceReady() {
+    Request request = mock(Request.class);
+    PreloadTarget<Object> target = PreloadTarget.obtain(requestManager, 100, 100);
+    target.setRequest(request);
+    target.onResourceReady(new Object(), null);
+
+    verify(requestManager).clear(eq(target));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
new file mode 100644
index 000000000..4ceda7c64
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -0,0 +1,66 @@
+package com.bumptech.glide.request.target;
+
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.request.transition.Transition;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SimpleTargetTest {
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsOnGetSizeIfGivenWidthIsLessThanZero() {
+    getTarget(-1, 1).getSize(mock(SizeReadyCallback.class));
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsOnGetSizeIfGivenWidthIsEqualToZero() {
+    getTarget(0, 1).getSize(mock(SizeReadyCallback.class));
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsOnGetSizeIfGivenHeightIsLessThanZero() {
+    getTarget(1, -1).getSize(mock(SizeReadyCallback.class));
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {
+    getTarget(1, 0).getSize(mock(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCanBeConstructedWithoutDimensions() {
+    getTarget();
+  }
+
+  @Test
+  public void testConstructorDoesNotThrowWithSizeOriginal() {
+    getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+  }
+
+  @Test
+  public void testGetSizeDoesNotThrowWithSizeOriginal() {
+    getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));
+  }
+
+  private SimpleTarget<Object> getTarget() {
+    return new SimpleTarget<Object>() {
+      @Override
+      public void onResourceReady(Object resource, Transition<? super Object> transition) {
+        // Do nothing.
+      }
+    };
+  }
+
+  private SimpleTarget<Object> getTarget(int width, int height) {
+    return new SimpleTarget<Object>(width, height) {
+      @Override
+      public void onResourceReady(Object resource, Transition<? super Object> transition) {
+        // Do nothing.
+      }
+    };
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
new file mode 100644
index 000000000..3debccfcd
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -0,0 +1,491 @@
+package com.bumptech.glide.request.target;
+
+import static android.view.ViewGroup.LayoutParams;
+import static android.view.ViewTreeObserver.OnPreDrawListener;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadows.ShadowDisplay;
+import org.robolectric.shadows.ShadowView;
+import org.robolectric.shadows.ShadowViewTreeObserver;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { ViewTargetTest.SizedShadowView.class,
+    ViewTargetTest.PreDrawShadowViewTreeObserver.class })
+public class ViewTargetTest {
+  private View view;
+  private ViewTarget target;
+  private SizedShadowView shadowView;
+  private PreDrawShadowViewTreeObserver shadowObserver;
+
+  @Before
+  public void setUp() {
+    view = new View(RuntimeEnvironment.application);
+    target = new TestViewTarget(view);
+
+    shadowView = (SizedShadowView) ShadowExtractor.extract(view);
+    shadowObserver =
+        (PreDrawShadowViewTreeObserver) ShadowExtractor.extract(view.getViewTreeObserver());
+  }
+
+  @Test
+  public void testReturnsWrappedView() {
+    assertEquals(view, target.getView());
+  }
+
+  @Test
+  public void testReturnsNullFromGetRequestIfNoRequestSet() {
+    assertNull(target.getRequest());
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfViewTagIsNotRequestObject() {
+    view.setTag(new Object());
+    target.getRequest();
+  }
+
+  @Test
+  public void testCanSetAndRetrieveRequest() {
+    Request request = mock(Request.class);
+
+    target.setRequest(request);
+
+    assertEquals(request, target.getRequest());
+  }
+
+  @Test
+  public void testRetrievesRequestFromPreviousTargetForView() {
+    Request request = mock(Request.class);
+
+    target.setRequest(request);
+
+    ViewTarget<View, Object> second = new TestViewTarget(view);
+
+    assertEquals(request, second.getRequest());
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
+    int dimens = 333;
+    shadowView.setWidth(dimens);
+    shadowView.setHeight(dimens);
+
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet() {
+    int dimens = 444;
+    LayoutParams layoutParams = new LayoutParams(dimens, dimens);
+    view.setLayoutParams(layoutParams);
+
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  private void setDisplayDimens(Integer width, Integer height) {
+    WindowManager windowManager =
+        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
+    ShadowDisplay shadowDisplay = Shadows.shadowOf(windowManager.getDefaultDisplay());
+    if (width != null) {
+      shadowDisplay.setWidth(width);
+    }
+
+    if (height != null) {
+      shadowDisplay.setHeight(height);
+    }
+  }
+
+  private void setDisplayWidth(int width) {
+    setDisplayDimens(width, null);
+  }
+
+  private void setDisplayHeight(int height) {
+    setDisplayDimens(null, height);
+  }
+
+  @Test
+  public void testBothParamsWrapContent() {
+    LayoutParams layoutParams =
+        new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(layoutParams);
+
+    int width = 123;
+    int height = 456;
+    setDisplayDimens(width, height);
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testWrapContentWidthWithValidHeight() {
+    int displayWidth = 500;
+    setDisplayWidth(displayWidth);
+
+    int height = 100;
+    LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
+    view.setLayoutParams(params);
+
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(displayWidth), eq(height));
+  }
+
+  @Test
+  public void testWrapContentHeightWithValidWidth() {
+    int displayHeight = 700;
+    setDisplayHeight(displayHeight);
+    int width = 100;
+    LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(width), eq(displayHeight));
+  }
+
+  @Test
+  public void testWrapContentWidthWithMatchParentHeight() {
+    int displayWidth = 1234;
+    setDisplayWidth(displayWidth);
+
+    LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int height = 32;
+    shadowView.setHeight(height);
+
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(displayWidth), eq(height));
+  }
+
+  @Test
+  public void testWrapContentHeightWithMatchParentWidth() {
+    int displayHeight = 5812;
+    setDisplayHeight(displayHeight);
+
+    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int width = 32;
+    shadowView.setWidth(width);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(displayHeight));
+  }
+
+  @Test
+  public void testMatchParentWidthAndHeight() {
+    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int width = 32;
+    int height = 45;
+    shadowView.setWidth(width);
+    shadowView.setHeight(height);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    int width = 12;
+    int height = 32;
+    shadowView.setWidth(width);
+    shadowView.setHeight(height);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbacksAreCalledInOrderPreDraw() {
+    SizeReadyCallback[] cbs = new SizeReadyCallback[25];
+    for (int i = 0; i < cbs.length; i++) {
+      cbs[i] = mock(SizeReadyCallback.class);
+      target.getSize(cbs[i]);
+    }
+
+    int width = 100, height = 111;
+    shadowView.setWidth(width);
+    shadowView.setHeight(height);
+    shadowObserver.fireOnPreDrawListeners();
+
+    InOrder order = inOrder((Object[]) cbs);
+    for (SizeReadyCallback cb : cbs) {
+      order.verify(cb).onSizeReady(eq(width), eq(height));
+    }
+  }
+
+  @Test
+  public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+    target.getSize(cb);
+
+    view.setLayoutParams(new LayoutParams(100, 100));
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testDoesNotAddMultipleListenersIfMultipleCallbacksAreAdded() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+    target.getSize(cb2);
+    assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
+  }
+
+  @Test
+  public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+
+    view.setLayoutParams(new LayoutParams(100, 100));
+    shadowObserver.fireOnPreDrawListeners();
+
+    assertThat(shadowObserver.getPreDrawListeners()).hasSize(0);
+
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    view.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+    target.getSize(cb2);
+
+    view.setLayoutParams(new LayoutParams(100, 100));
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb2).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+    assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    int width = 689;
+    int height = 354;
+    LayoutParams layoutParams = new LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    LayoutParams layoutParams = new LayoutParams(1234, 4123);
+    view.setLayoutParams(layoutParams);
+    shadowObserver.fireOnPreDrawListeners();
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
+    SizeReadyCallback firstCb = mock(SizeReadyCallback.class);
+    SizeReadyCallback secondCb = mock(SizeReadyCallback.class);
+    target.getSize(firstCb);
+    target.getSize(secondCb);
+
+    int width = 68;
+    int height = 875;
+    LayoutParams layoutParams = new LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    shadowObserver.fireOnPreDrawListeners();
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(firstCb, times(1)).onSizeReady(eq(width), eq(height));
+    verify(secondCb, times(1)).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    target.getSize(cb);
+
+    int width = 1;
+    int height = 2;
+    LayoutParams layoutParams = new LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    shadowObserver.setIsAlive(false);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfGivenNullView() {
+    new TestViewTarget(null);
+  }
+
+  @Implements(ViewTreeObserver.class)
+  public static class PreDrawShadowViewTreeObserver extends ShadowViewTreeObserver {
+    private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
+    private boolean isAlive = true;
+
+    @SuppressWarnings("unused")
+    @Implementation
+    public void addOnPreDrawListener(OnPreDrawListener listener) {
+      checkIsAlive();
+      preDrawListeners.add(listener);
+    }
+
+    @SuppressWarnings("unused")
+    @Implementation
+    public void removeOnPreDrawListener(OnPreDrawListener listener) {
+      checkIsAlive();
+      preDrawListeners.remove(listener);
+    }
+
+    @Implementation
+    public boolean isAlive() {
+      return isAlive;
+    }
+
+    private void checkIsAlive() {
+      if (!isAlive()) {
+        throw new IllegalStateException("ViewTreeObserver is not alive!");
+      }
+    }
+
+    public void setIsAlive(boolean isAlive) {
+      this.isAlive = isAlive;
+    }
+
+    public void fireOnPreDrawListeners() {
+      for (OnPreDrawListener listener : preDrawListeners) {
+        listener.onPreDraw();
+      }
+    }
+
+    public List<OnPreDrawListener> getPreDrawListeners() {
+      return preDrawListeners;
+    }
+  }
+
+  @Implements(View.class)
+  public static class SizedShadowView extends ShadowView {
+    private int width;
+    private int height;
+
+    public void setWidth(int width) {
+      this.width = width;
+    }
+
+    public void setHeight(int height) {
+      this.height = height;
+    }
+
+    @Implementation
+    public int getWidth() {
+      return width;
+    }
+
+    @Implementation
+    public int getHeight() {
+      return height;
+    }
+  }
+
+  private static class TestViewTarget extends ViewTarget<View, Object> {
+
+    public TestViewTarget(View view) {
+      super(view);
+    }
+
+    @Override
+    public void onLoadStarted(Drawable placeholder) {
+
+    }
+
+    @Override
+    public void onLoadFailed(Drawable errorDrawable) {
+
+    }
+
+    @Override
+    public void onResourceReady(Object resource, Transition transition) {
+
+    }
+
+    @Override
+    public void onLoadCleared(Drawable placeholder) {
+
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
new file mode 100644
index 000000000..b6fa33ac8
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -0,0 +1,47 @@
+package com.bumptech.glide.request.transition;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Mockito.mock;
+
+import android.graphics.drawable.Drawable;
+
+import com.bumptech.glide.load.DataSource;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DrawableCrossFadeFactoryTest {
+
+  private DrawableCrossFadeFactory factory;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
+    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/);
+  }
+
+  @Test
+  public void testReturnsNoAnimationIfFromMemoryCache() {
+    assertEquals(NoTransition.<Drawable>get(),
+        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
+  }
+
+  @Test
+  public void testReturnsReturnsAnimationIfNotFromMemoryCacheAndIsFirstResource() {
+    assertNotEquals(NoTransition.<Drawable>get(),
+        factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
+  }
+
+  @Test
+  public void testReturnsAnimationIfNotFromMemocyCacheAndNotIsFirstResource() {
+    assertNotEquals(NoTransition.<Drawable>get(),
+        factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
new file mode 100644
index 000000000..78861713d
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -0,0 +1,79 @@
+package com.bumptech.glide.request.transition;
+
+import static com.bumptech.glide.request.transition.Transition.ViewAdapter;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
+import android.widget.ImageView;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DrawableCrossFadeViewAnimationTest {
+  private CrossFadeHarness harness;
+
+  @Before
+  public void setup() {
+    harness = new CrossFadeHarness();
+  }
+
+  @Test
+  public void testStartsDefaultAnimationIfNoPreviousDrawableIsNotSet() {
+    when(harness.adapter.getView()).thenReturn(harness.view);
+    harness.animation.transition(harness.current, harness.adapter);
+    verify(harness.defaultAnimation).transition(eq(harness.current), eq(harness.adapter));
+  }
+
+  @Test
+  public void testIgnoresNullViews() {
+    when(harness.adapter.getView()).thenReturn(null);
+    harness.animation.transition(harness.current, harness.adapter);
+  }
+
+  @Test
+  public void testReturnsFalseIfStartsDefaultAnimation() {
+    assertFalse(harness.animation.transition(harness.current, harness.adapter));
+  }
+
+  @Test
+  public void testSetsTransitionDrawableIfPreviousIsNotNull() {
+    Drawable previous = new ColorDrawable(Color.WHITE);
+    when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
+    harness.animation.transition(harness.current, harness.adapter);
+
+    verify(harness.adapter).setDrawable(any(TransitionDrawable.class));
+  }
+
+  @Test
+  public void testReturnsTrueIfSetsTransitionDrawable() {
+    Drawable previous = new ColorDrawable(Color.RED);
+    when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
+    assertTrue(harness.animation.transition(harness.current, harness.adapter));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static class CrossFadeHarness {
+    Drawable current = new ColorDrawable(Color.GRAY);
+    ViewAdapter adapter = mock(ViewAdapter.class);
+    ImageView view = mock(ImageView.class);
+    Transition<Drawable> defaultAnimation = mock(Transition.class);
+    int duration = 200;
+    DrawableCrossFadeTransition animation =
+        new DrawableCrossFadeTransition(defaultAnimation, duration);
+  }
+}
+
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
new file mode 100644
index 000000000..54ebaff3c
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
@@ -0,0 +1,59 @@
+package com.bumptech.glide.request.transition;
+
+import static com.bumptech.glide.request.transition.Transition.ViewAdapter;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.view.animation.Animation;
+import android.widget.ImageView;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ViewAnimationTest {
+  private ViewTransition<Object> viewAnimation;
+  private ViewAdapter adapter;
+  private ImageView view;
+  private ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
+
+  @SuppressWarnings("unchecked")
+  @Before
+  public void setUp() {
+    viewTransitionAnimationFactory = mock(ViewTransition.ViewTransitionAnimationFactory.class);
+    view = mock(ImageView.class);
+    adapter = mock(ViewAdapter.class);
+    when(adapter.getView()).thenReturn(view);
+    viewAnimation = new ViewTransition<>(viewTransitionAnimationFactory);
+  }
+
+  @Test
+  public void testClearsAnimationOnAnimate() {
+    viewAnimation.transition(null, adapter);
+
+    verify(view).clearAnimation();
+  }
+
+  @Test
+  public void testAlwaysReturnsFalse() {
+    assertFalse(viewAnimation.transition(null, adapter));
+  }
+
+  @Test
+  public void testStartsAnimationOnAnimate() {
+    Animation animation = mock(Animation.class);
+    when(viewTransitionAnimationFactory.build(any(Context.class))).thenReturn(animation);
+    viewAnimation.transition(null, adapter);
+    verify(view).clearAnimation();
+    verify(view).startAnimation(eq(animation));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
new file mode 100644
index 000000000..52f429f4e
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.request.transition;
+
+import static com.bumptech.glide.request.transition.Transition.ViewAdapter;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.view.View;
+import android.widget.ImageView;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ViewPropertyAnimationTest {
+  private ViewPropertyTransition.Animator animator;
+  private ViewPropertyTransition<Object> animation;
+
+  @Before
+  public void setUp() {
+    animator = mock(ViewPropertyTransition.Animator.class);
+    animation = new ViewPropertyTransition<>(animator);
+  }
+
+  @Test
+  public void testAlwaysReturnsFalse() {
+    assertFalse(animation.transition(new Object(), mock(ViewAdapter.class)));
+  }
+
+  @Test
+  public void testCallsAnimatorWithGivenView() {
+    ImageView view = new ImageView(RuntimeEnvironment.application);
+    ViewAdapter adapter = mock(ViewAdapter.class);
+    when(adapter.getView()).thenReturn(view);
+    animation.transition(new Object(), adapter);
+
+    verify(animator).animate(eq(view));
+  }
+
+  @Test
+  public void testDoesNotCallAnimatorIfGivenAdapterWithNullView() {
+    ViewAdapter adapter = mock(ViewAdapter.class);
+    animation.transition(new Object(), adapter);
+
+    verify(animator, never()).animate(any(View.class));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
new file mode 100644
index 000000000..2d680b57e
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.request.transition;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.DataSource;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ViewPropertyViewTransitionAnimationFactoryTest {
+
+  private ViewPropertyAnimationFactory<Object> factory;
+
+  @Before
+  public void setUp() {
+    ViewPropertyTransition.Animator animator = mock(ViewPropertyTransition.Animator.class);
+    factory = new ViewPropertyAnimationFactory<>(animator);
+  }
+
+  @Test
+  public void testReturnsNoAnimationIfFromMemoryCache() {
+    assertEquals(NoTransition.get(),
+        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
+  }
+
+  @Test
+  public void testReturnsNoAnimationIfNotFirstResource() {
+    assertEquals(NoTransition.get(),
+        factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
+  }
+
+  @Test
+  public void testReturnsAnimationIfNotFromMemoryCacheAndFirstResource() {
+    assertNotEquals(NoTransition.get(),
+        factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
new file mode 100644
index 000000000..d7f433788
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.request.transition;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.view.View;
+import android.view.animation.Animation;
+
+import com.bumptech.glide.load.DataSource;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ViewTransitionAnimationFactoryTest {
+  private ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
+  private ViewAnimationFactory factory;
+
+  @Before
+  public void setUp() {
+    viewTransitionAnimationFactory = mock(ViewTransition.ViewTransitionAnimationFactory.class);
+    factory = new ViewAnimationFactory(viewTransitionAnimationFactory);
+  }
+
+  @Test
+  public void testFactoryReturnsNoAnimationIfFromMemoryCache() {
+    Transition<Object> animation =
+        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/);
+    assertEquals(NoTransition.get(), animation);
+    verify(viewTransitionAnimationFactory, never()).build(RuntimeEnvironment.application);
+  }
+
+  @Test
+  public void testFactoryReturnsNoAnimationIfNotFirstResource() {
+    Transition<Object> animation =
+        factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/);
+    assertEquals(NoTransition.get(), animation);
+    verify(viewTransitionAnimationFactory, never()).build(RuntimeEnvironment.application);
+  }
+
+  @Test
+  public void testFactoryReturnsActualAnimationIfNotIsFromMemoryCacheAndIsFirstResource() {
+    Transition<Object> transition =
+        factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/);
+
+    Animation animation = mock(Animation.class);
+    when(viewTransitionAnimationFactory.build(any(Context.class))).thenReturn(animation);
+
+    Transition.ViewAdapter adapter = mock(Transition.ViewAdapter.class);
+    View view = mock(View.class);
+    when(adapter.getView()).thenReturn(view);
+    transition.transition(new Object(), adapter);
+
+    verify(view).startAnimation(eq(animation));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
new file mode 100644
index 000000000..2d92de3d4
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -0,0 +1,84 @@
+package com.bumptech.glide.resize.load;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.testutil.TestResourceUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ExifTest {
+
+  private LruByteArrayPool byteArrayPool;
+
+  private InputStream open(String imageName) throws IOException {
+    return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
+  }
+
+  private void assertOrientation(String filePrefix, int expectedOrientation) {
+    InputStream is = null;
+    try {
+      is = open(filePrefix + "_" + expectedOrientation + ".jpg");
+      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),
+          expectedOrientation);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Do nothing.
+        }
+      }
+    }
+  }
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruByteArrayPool();
+  }
+
+  @Test
+  public void testIssue387() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
+  }
+
+  @Test
+  public void testLandscape() throws IOException {
+    for (int i = 1; i <= 8; i++) {
+      assertOrientation("Landscape", i);
+    }
+  }
+
+  @Test
+  public void testPortrait() throws IOException {
+    for (int i = 1; i <= 8; i++) {
+      assertOrientation("Portrait", i);
+    }
+  }
+
+  @Test
+  public void testHandlesInexactSizesInByteArrayPools() {
+    for (int i = 1; i <= 8; i++) {
+      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+      assertOrientation("Portrait", i);
+    }
+    for (int i = 1; i <= 8; i++) {
+      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+      assertOrientation("Landscape", i);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
new file mode 100644
index 000000000..3d444fd17
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.signature;
+
+import static org.junit.Assert.assertNotNull;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyAssertions;
+
+import org.junit.After;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ApplicationVersionSignatureTest {
+
+  @After
+  public void tearDown() {
+    ApplicationVersionSignature.reset();
+  }
+
+  @Test
+  public void testCanGetKeyForSignature() {
+    Key key = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
+      throws NoSuchAlgorithmException, UnsupportedEncodingException {
+    Key first = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
+    Key second = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
+    KeyAssertions.assertSame(first, second);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
new file mode 100644
index 000000000..46b41c9ba
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -0,0 +1,50 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyAssertions;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(JUnit4.class)
+public class MediaStoreSignatureTest {
+
+  @Test
+  public void testSignaturesDifferIfMimeTypeDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    MediaStoreSignature first = new MediaStoreSignature("first", 100, 1);
+    MediaStoreSignature second = new MediaStoreSignature("second", 100, 1);
+
+    KeyAssertions.assertDifferent(first, second);
+  }
+
+  @Test
+  public void testSignaturesDifferIfDateModifiedDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
+    MediaStoreSignature second = new MediaStoreSignature("mimeType", 999, 1);
+
+    KeyAssertions.assertDifferent(first, second);
+  }
+
+  @Test
+  public void testSignaturesDifferIfOrientationDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
+    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 9);
+
+    KeyAssertions.assertDifferent(first, second);
+  }
+
+  @Test
+  public void testSignaturesAreTheSameIfAllArgsAreTheSame()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
+    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 1);
+
+    KeyAssertions.assertSame(first, second);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
new file mode 100644
index 000000000..2012092af
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyAssertions;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(JUnit4.class)
+public class ObjectKeyTest {
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    Object object = new Object();
+    KeyAssertions.assertSame(new ObjectKey(object), new ObjectKey(object));
+    KeyAssertions.assertDifferent(new ObjectKey(object), new ObjectKey(new Object()));
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java
new file mode 100644
index 000000000..463d17cca
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyAssertions;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(JUnit4.class)
+public class StringSignatureTest {
+
+  @Test
+  public void testStringSignatureIsNotEqualIfStringDiffers()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    StringSignature first = new StringSignature("first");
+    StringSignature second = new StringSignature("second");
+
+    KeyAssertions.assertDifferent(first, second);
+  }
+
+  @Test
+  public void testStringSignatureIsEqualIfStringIsTheSame()
+      throws UnsupportedEncodingException, NoSuchAlgorithmException {
+    StringSignature first = new StringSignature("signature");
+    StringSignature second = new StringSignature("signature");
+
+    KeyAssertions.assertSame(first, second);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java b/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
new file mode 100644
index 000000000..796a09240
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.tests;
+
+public class BackgroundUtil {
+  public interface BackgroundTester {
+    public void runTest() throws Exception;
+  }
+
+  public static void testInBackground(BackgroundTester test) throws InterruptedException {
+    TestThread thread = new TestThread(test);
+    thread.start();
+    thread.join();
+    if (thread.exception != null) {
+      throw new RuntimeException(thread.exception);
+    }
+  }
+
+  private static class TestThread extends Thread {
+    private Exception exception;
+    private BackgroundTester test;
+
+    public TestThread(BackgroundTester test) {
+      this.test = test;
+    }
+
+    @Override
+    public void run() {
+      super.run();
+      try {
+        test.runTest();
+      } catch (Exception e) {
+        exception = e;
+      }
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
new file mode 100644
index 000000000..aa6adc361
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
@@ -0,0 +1,31 @@
+package com.bumptech.glide.tests;
+
+import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
+import android.net.Uri;
+
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowContentResolver;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@Implements(ContentResolver.class)
+public class ContentResolverShadow extends ShadowContentResolver {
+  private Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+
+  public void registerFileDescriptor(Uri uri, AssetFileDescriptor fileDescriptor) {
+    fileDescriptorMap.put(uri, fileDescriptor);
+  }
+
+  @Implementation
+  public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode) {
+    AssetFileDescriptor fileDescriptor = fileDescriptorMap.get(uri);
+    if (fileDescriptor != null) {
+      return fileDescriptor;
+    } else {
+      return null;
+    }
+  }
+}
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
similarity index 79%
rename from library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLog.java
rename to library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
index 6a11cac63..f0ed18b27 100644
--- a/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLog.java
+++ b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
@@ -14,8 +14,8 @@
 @Implements(Log.class)
 public class GlideShadowLog extends ShadowLog {
 
-    @Implementation
-    public static boolean isLoggable(String tag, int level) {
-        return true;
-    }
+  @Implementation
+  public static boolean isLoggable(String tag, int level) {
+    return true;
+  }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
similarity index 64%
rename from library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLooper.java
rename to library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
index de96aa137..c41e4a6f7 100644
--- a/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -10,10 +10,10 @@
 import org.robolectric.shadows.ShadowLooper;
 
 @Implements(Looper.class)
-public class GlideShadowLooper extends ShadowLooper  {
+public class GlideShadowLooper extends ShadowLooper {
 
-    @Implementation
-    public static MessageQueue myQueue() {
-        return mock(MessageQueue.class);
-    }
+  @Implementation
+  public static MessageQueue myQueue() {
+    return mock(MessageQueue.class);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
new file mode 100644
index 000000000..80d7dc3a9
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.tests;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.testing.EqualsTester;
+
+import com.bumptech.glide.load.Key;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+public class KeyAssertions {
+
+  public static void assertSame(Key first, Key second) throws NoSuchAlgorithmException {
+    assertSameOrdered(first, second);
+    assertSameOrdered(second, first);
+  }
+
+  private static void assertSameOrdered(Key first, Key second) throws NoSuchAlgorithmException {
+    new EqualsTester()
+        .addEqualityGroup(first, second)
+        .testEquals();
+
+    assertThat(getDigest(first)).isEqualTo(getDigest(second));
+  }
+
+  public static void assertDifferent(Key first, Key second) throws NoSuchAlgorithmException {
+    assertDifferent(first, second, true);
+    assertDifferent(second, first, true);
+  }
+
+  public static void assertDifferent(Key first, Key second, boolean checkDiskCacheKey)
+      throws NoSuchAlgorithmException {
+    new EqualsTester()
+        .addEqualityGroup(first)
+        .addEqualityGroup(second)
+        .testEquals();
+
+    if (checkDiskCacheKey) {
+      MessageDigest firstDigest = MessageDigest.getInstance("SHA-1");
+      first.updateDiskCacheKey(firstDigest);
+      MessageDigest secondDigest = MessageDigest.getInstance("SHA-1");
+      second.updateDiskCacheKey(secondDigest);
+
+      assertThat(getDigest(first)).isNotEqualTo(getDigest(second));
+    }
+  }
+
+  private static byte[] getDigest(Key key) throws NoSuchAlgorithmException {
+    MessageDigest md = MessageDigest.getInstance("SHA-1");
+    key.updateDiskCacheKey(md);
+    return md.digest();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/src/test/java/com/bumptech/glide/tests/Util.java
new file mode 100644
index 000000000..ab333bec8
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/tests/Util.java
@@ -0,0 +1,136 @@
+package com.bumptech.glide.tests;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.RETURNS_DEFAULTS;
+
+import android.graphics.Bitmap;
+import android.os.Build;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.engine.Resource;
+
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.util.ReflectionHelpers;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.MessageDigest;
+
+// FIXME move to testutil module
+public class Util {
+
+  public static String getExpectedClassId(Class clazz) {
+    return clazz.getSimpleName() + "." + clazz.getPackage().getName();
+  }
+
+  public static DataSource isADataSource() {
+    return isA(DataSource.class);
+  }
+
+  public static Resource<?> anyResource() {
+    return any(Resource.class);
+  }
+
+  public static boolean isWindows() {
+    return System.getProperty("os.name").startsWith("Windows");
+  }
+
+  public static void writeFile(File file, byte[] data) throws IOException {
+    OutputStream out = new FileOutputStream(file);
+    try {
+      out.write(data);
+      out.flush();
+      out.close();
+    } finally {
+      try {
+        out.close();
+      } catch (IOException ex) {
+        // Do nothing.
+      }
+    }
+  }
+
+  public static byte[] readFile(File file, int expectedLength) throws IOException {
+    InputStream is = new FileInputStream(file);
+    byte[] result = new byte[expectedLength];
+    try {
+      assertEquals(expectedLength, is.read(result));
+      assertEquals(-1, is.read());
+    } finally {
+      try {
+        is.close();
+      } catch (IOException e) {
+        // Do nothing.
+      }
+    }
+    return result;
+  }
+
+  public static void setSdkVersionInt(int version) {
+    ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", version);
+  }
+
+  public static class WriteDigest implements Answer<Void> {
+    private String toWrite;
+
+    public WriteDigest(String toWrite) {
+      this.toWrite = toWrite;
+    }
+
+    @Override
+    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+      MessageDigest md = (MessageDigest) invocationOnMock.getArguments()[0];
+      md.update(toWrite.getBytes());
+      return null;
+    }
+  }
+
+  public static class ReturnsSelfAnswer implements Answer<Object> {
+
+    public Object answer(InvocationOnMock invocation) throws Throwable {
+      Object mock = invocation.getMock();
+      if (invocation.getMethod().getReturnType().isInstance(mock)) {
+        return mock;
+      } else {
+        return RETURNS_DEFAULTS.answer(invocation);
+      }
+    }
+  }
+
+  public static class CallDataReady<T> implements Answer<Void> {
+
+    private T data;
+
+    public CallDataReady(T data) {
+      this.data = data;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+      DataFetcher.DataCallback<T> callback =
+          (DataFetcher.DataCallback<T>) invocationOnMock.getArguments()[1];
+      callback.onDataReady(data);
+      return null;
+    }
+  }
+
+  public static class CreateBitmap implements Answer<Bitmap> {
+
+    @Override
+    public Bitmap answer(InvocationOnMock invocation) throws Throwable {
+      int width = (Integer) invocation.getArguments()[0];
+      int height = (Integer) invocation.getArguments()[1];
+      Bitmap.Config config = (Bitmap.Config) invocation.getArguments()[2];
+      return Bitmap.createBitmap(width, height, config);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
new file mode 100644
index 000000000..84d01d0b0
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -0,0 +1,134 @@
+package com.bumptech.glide.util;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ContentLengthInputStreamTest {
+  @Mock InputStream wrapped;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testAvailable_withZeroReadsAndValidContentLength_returnsContentLength()
+      throws IOException {
+    int value = 123356;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(value));
+
+    assertThat(is.available()).isEqualTo(value);
+  }
+
+  @Test
+  public void testAvailable_withNullContentLength_returnsWrappedAvailable()
+      throws IOException {
+    InputStream is = ContentLengthInputStream.obtain(wrapped, null /*contentLengthHeader*/);
+    int expected = 1234;
+    when(wrapped.available()).thenReturn(expected);
+
+    assertThat(is.available()).isEqualTo(expected);
+  }
+
+  @Test
+  public void testAvailable_withInvalidContentLength_returnsWrappedAvailable() throws IOException {
+    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
+    int expected = 567;
+    when(wrapped.available()).thenReturn(expected);
+
+    assertThat(is.available()).isEqualTo(expected);
+  }
+
+  @Test
+  public void testAvailable_withRead_returnsContentLengthOffsetByRead() throws IOException {
+    int contentLength = 999;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    when(wrapped.read()).thenReturn(1);
+
+    assertThat(is.read()).isEqualTo(1);
+    assertThat(is.available()).isEqualTo(contentLength - 1);
+  }
+
+  @Test
+  public void testAvailable_handlesReadValueOfZero() throws IOException {
+    int contentLength = 999;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    when(wrapped.read()).thenReturn(0);
+
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.available()).isEqualTo(contentLength);
+  }
+
+  @Test
+  public void testAvailable_withReadBytes_returnsContentLengthOffsetByNumberOfBytes()
+      throws IOException {
+    int contentLength = 678;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    int read = 100;
+    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(read);
+
+    assertThat(is.read(new byte[500], 0, 0)).isEqualTo(read);
+    assertThat(is.available()).isEqualTo(contentLength - read);
+  }
+
+  @Test
+  public void testRead_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOException()
+      throws IOException {
+    int contentLength = 1;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    when(wrapped.read()).thenReturn(-1);
+
+    try {
+      is.read();
+      fail("Failed to throw expected exception");
+    } catch (IOException e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOException()
+      throws IOException {
+    int contentLength = 2;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
+
+    try {
+      is.read(new byte[10], 0, 0);
+      fail("Failed to throw expected exception");
+    } catch (IOException e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testRead_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow() throws IOException {
+    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
+    when(wrapped.read()).thenReturn(-1);
+    is.read();
+  }
+
+  @Test
+  public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow()
+      throws IOException {
+    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
+    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
+    is.read(new byte[10], 0, 0);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
new file mode 100644
index 000000000..8a07d5a27
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
@@ -0,0 +1,175 @@
+package com.bumptech.glide.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.SocketTimeoutException;
+
+@RunWith(JUnit4.class)
+public class ExceptionCatchingInputStreamTest {
+
+  private RecyclableBufferedInputStream wrapped;
+  private ExceptionCatchingInputStream is;
+
+  @Before
+  public void setUp() throws Exception {
+    wrapped = mock(RecyclableBufferedInputStream.class);
+    is = new ExceptionCatchingInputStream();
+    is.setInputStream(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    ExceptionCatchingInputStream.clearQueue();
+  }
+
+  @Test
+  public void testReturnsWrappedAvailable() throws IOException {
+    when(wrapped.available()).thenReturn(25);
+    assertEquals(25, is.available());
+  }
+
+  @Test
+  public void testCallsCloseOnWrapped() throws IOException {
+    is.close();
+    verify(wrapped).close();
+  }
+
+  @Test
+  public void testCallsMarkOnWrapped() {
+    int toMark = 50;
+    is.mark(toMark);
+    verify(wrapped).mark(eq(toMark));
+  }
+
+  @Test
+  public void testReturnsWrappedMarkSupported() {
+    when(wrapped.markSupported()).thenReturn(true);
+    assertTrue(is.markSupported());
+  }
+
+  @Test
+  public void testCallsReadByteArrayOnWrapped() throws IOException {
+    byte[] buffer = new byte[100];
+    when(wrapped.read(eq(buffer))).thenReturn(buffer.length);
+    assertEquals(buffer.length, is.read(buffer));
+  }
+
+  @Test
+  public void testCallsReadArrayWithOffsetAndCountOnWrapped() throws IOException {
+    int offset = 5;
+    int count = 100;
+    byte[] buffer = new byte[105];
+
+    when(wrapped.read(eq(buffer), eq(offset), eq(count))).thenReturn(count);
+    assertEquals(count, is.read(buffer, offset, count));
+  }
+
+  @Test
+  public void testCallsReadOnWrapped() throws IOException {
+    when(wrapped.read()).thenReturn(1);
+    assertEquals(1, is.read());
+  }
+
+  @Test
+  public void testCallsResetOnWrapped() throws IOException {
+    is.reset();
+    verify(wrapped).reset();
+  }
+
+  @Test
+  public void testCallsSkipOnWrapped() throws IOException {
+    long toSkip = 67;
+    long expected = 55;
+    when(wrapped.skip(eq(toSkip))).thenReturn(expected);
+    assertEquals(expected, is.skip(toSkip));
+  }
+
+  @Test
+  public void testCatchesExceptionOnRead() throws IOException {
+    IOException expected = new SocketTimeoutException();
+    when(wrapped.read()).thenThrow(expected);
+    int read = is.read();
+
+    assertEquals(-1, read);
+    assertEquals(expected, is.getException());
+  }
+
+  @Test
+  public void testCatchesExceptionOnReadBuffer() throws IOException {
+    IOException exception = new SocketTimeoutException();
+    when(wrapped.read(any(byte[].class))).thenThrow(exception);
+
+    int read = is.read(new byte[0]);
+    assertEquals(-1, read);
+    assertEquals(exception, is.getException());
+  }
+
+  @Test
+  public void testCatchesExceptionOnReadBufferWithOffsetAndCount() throws IOException {
+    IOException exception = new SocketTimeoutException();
+    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenThrow(exception);
+
+    int read = is.read(new byte[0], 10, 100);
+    assertEquals(-1, read);
+    assertEquals(exception, is.getException());
+  }
+
+  @Test
+  public void testCatchesExceptionOnSkip() throws IOException {
+    IOException exception = new SocketTimeoutException();
+    when(wrapped.skip(anyLong())).thenThrow(exception);
+
+    long skipped = is.skip(100);
+    assertEquals(0, skipped);
+    assertEquals(exception, is.getException());
+  }
+
+  @Test
+  public void testExceptionIsNotSetInitially() {
+    assertNull(is.getException());
+  }
+
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void testResetsExceptionToNullOnRelease() throws IOException {
+    IOException exception = new SocketTimeoutException();
+    when(wrapped.read()).thenThrow(exception);
+    is.read();
+    is.release();
+    assertNull(is.getException());
+  }
+
+  @Test
+  public void testCanReleaseAnObtainFromPool() {
+    is.release();
+    InputStream fromPool = ExceptionCatchingInputStream.obtain(wrapped);
+    assertEquals(is, fromPool);
+  }
+
+  @Test
+  public void testCanObtainNewStreamFromPool() throws IOException {
+    InputStream fromPool = ExceptionCatchingInputStream.obtain(wrapped);
+    when(wrapped.read()).thenReturn(1);
+    int read = fromPool.read();
+    assertEquals(1, read);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java b/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
new file mode 100644
index 000000000..89cab6985
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.util;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class FixedPreloadSizeProviderTest {
+
+  @Test
+  public void testReturnsGivenSize() {
+    int width = 500;
+    int height = 1234;
+    FixedPreloadSizeProvider<Object> provider = new FixedPreloadSizeProvider<>(width, height);
+
+    int[] size = provider.getPreloadSize(new Object(), 0, 0);
+
+    assertThat(size).asList().containsExactly(width, height);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
new file mode 100644
index 000000000..16d5d0187
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -0,0 +1,170 @@
+package com.bumptech.glide.util;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class MarkEnforcingInputStreamTest {
+  // An arbitrary number > 0.
+  private static final int MARK_LIMIT = 5;
+  // Another arbitrary number > MARK_LIMIT.
+  private static final int DATA_SIZE = MARK_LIMIT + 1;
+
+  @Test
+  public void testReturnsByte_whenReadsUpToMarkLimit_withMoreBytesAvailable() throws IOException {
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
+    is.mark(MARK_LIMIT);
+
+    for (int i = 0; i < MARK_LIMIT; i++) {
+      assertThat(is.read()).isAtLeast(0);
+    }
+  }
+
+  @Test
+  public void testReturnsByte_whenReadsUpToMarkLimit_withNoMoreBytesAvailable() throws IOException {
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[MARK_LIMIT]));
+
+    for (int i = 0; i < MARK_LIMIT; i++) {
+      assertThat(is.read()).isAtLeast(0);
+    }
+  }
+
+  @Test
+  public void testReturnsEndOfStream_whenReadsSingleBytePastMarkLimit() throws IOException {
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
+
+    is.mark(MARK_LIMIT);
+    for (int i = 0; i < MARK_LIMIT; i++) {
+      assertThat(is.read()).isAtLeast(0);
+    }
+
+    assertEquals(-1, is.read());
+  }
+
+  @Test
+  public void
+  testOverridesByteCount_whenReadBufferLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
+      throws IOException {
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
+
+    is.mark(MARK_LIMIT);
+    byte[] buffer = new byte[DATA_SIZE];
+    assertEquals(MARK_LIMIT, is.read(buffer));
+  }
+
+  @Test
+  public void
+  testReturnsEndOfStream_whenReadBufferLargerThanMarkLimit_withZeroBytesRemainingInMarkLimit()
+      throws IOException {
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
+    is.mark(MARK_LIMIT);
+
+    byte[] buffer = new byte[MARK_LIMIT];
+    assertEquals(MARK_LIMIT, is.read(buffer));
+    assertEquals(-1, is.read(buffer));
+  }
+
+  @Test
+  public void testDoesNotReadIntoBuffer_withZeroBytesRemainingInMarkLimit() throws IOException {
+    byte[] expected = new byte[MARK_LIMIT];
+    for (int i = 0; i < MARK_LIMIT; i++) {
+      expected[i] = (byte) (i + 1);
+    }
+    byte[] buffer = new byte[MARK_LIMIT];
+    System.arraycopy(expected, 0, buffer, 0, MARK_LIMIT);
+
+    // All zeros.
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
+    is.mark(MARK_LIMIT);
+    for (int i = 0; i < MARK_LIMIT; i++) {
+      assertThat(is.read()).isAtLeast(0);
+    }
+
+    assertEquals(-1, is.read(buffer));
+
+    assertThat(buffer).isEqualTo(expected);
+  }
+
+  @Test
+  public void testResetUnsetsLimit() throws IOException {
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
+    is.mark(MARK_LIMIT);
+
+    for (int i = 0; i < MARK_LIMIT; i++) {
+      assertThat(is.read()).isAtLeast(0);
+    }
+
+    is.reset();
+
+    for (int i = 0; i < DATA_SIZE; i++) {
+      assertThat(is.read()).isAtLeast(0);
+    }
+  }
+
+  @Test
+  public void
+  testOverridesByteCount_whenSkipCountLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
+      throws IOException {
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
+    is.mark(MARK_LIMIT);
+
+    assertEquals(MARK_LIMIT, is.skip(DATA_SIZE));
+  }
+
+  @Test
+  public void testReturnsEndOfStream_whenSkipping_withZeroBytesRemainingInMarkLimit()
+      throws IOException {
+    MarkEnforcingInputStream is =
+        new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
+    is.mark(MARK_LIMIT);
+
+    assertEquals(MARK_LIMIT, is.skip(DATA_SIZE));
+    assertEquals(-1, is.skip(1));
+  }
+
+  @Test
+  public void testReturnsStreamAvailable_whenMarkIsNotSet() throws IOException {
+    ByteArrayInputStream wrapped = new ByteArrayInputStream(new byte[MARK_LIMIT]);
+    MarkEnforcingInputStream is = new MarkEnforcingInputStream(wrapped);
+
+    assertEquals(wrapped.available(), is.available());
+  }
+
+  @Test
+  public void testReturnsStreamAvailable_whenMarkIsSet_withMarkGreaterThanStreamAvailable()
+      throws IOException {
+    ByteArrayInputStream wrapped = new ByteArrayInputStream(new byte[MARK_LIMIT]);
+    MarkEnforcingInputStream is = new MarkEnforcingInputStream(wrapped);
+    is.mark(wrapped.available() + 1);
+
+    assertEquals(wrapped.available(), is.available());
+  }
+
+  @Test
+  public void testReturnsMarkLimitAsAvailable_whenMarkIsSet_withMarkLessThanStreamAvailable()
+      throws IOException {
+    ByteArrayInputStream wrapped = new ByteArrayInputStream(new byte[MARK_LIMIT]);
+    MarkEnforcingInputStream is = new MarkEnforcingInputStream(wrapped);
+    int expected = wrapped.available() - 1;
+    is.mark(expected);
+
+    assertEquals(expected, is.available());
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/UtilTest.java b/library/src/test/java/com/bumptech/glide/util/UtilTest.java
new file mode 100644
index 000000000..64f89ff8a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/UtilTest.java
@@ -0,0 +1,74 @@
+package com.bumptech.glide.util;
+
+import static org.junit.Assert.assertEquals;
+
+import android.graphics.Bitmap;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class UtilTest {
+
+  @Test
+  public void testReturnsCorrectBitmapSizeForDifferentDimensions() {
+    int width = 100;
+    int height = 100;
+    Bitmap.Config config = Bitmap.Config.ARGB_8888;
+
+    int initialSize = Util.getBitmapByteSize(width, height, config);
+    int sizeOne = Util.getBitmapByteSize(width * 2, height, config);
+    int sizeTwo = Util.getBitmapByteSize(width, height * 2, config);
+
+    assertEquals(4 * width * height, initialSize);
+    assertEquals(2 * initialSize, sizeOne);
+    assertEquals(2 * initialSize, sizeTwo);
+  }
+
+  @Test
+  public void testReturnsCorrectBitmapSizeForAlpha8Bitmap() {
+    int width = 110;
+    int height = 43;
+
+    int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ALPHA_8);
+    assertEquals(width * height, size);
+  }
+
+  @Test
+  public void testReturnsCorrectBitmapSizeForRgb565() {
+    int width = 34;
+    int height = 1444;
+
+    int size = Util.getBitmapByteSize(width, height, Bitmap.Config.RGB_565);
+    assertEquals(width * height * 2, size);
+  }
+
+  @Test
+  public void testReturnsCorrectBitmapSizeForARGB4444() {
+    int width = 4454;
+    int height = 1235;
+
+    int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_4444);
+    assertEquals(width * height * 2, size);
+  }
+
+  @Test
+  public void testReturnsCorrectBitmapSizeForARGB8888() {
+    int width = 943;
+    int height = 3584;
+
+    int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_8888);
+    assertEquals(width * height * 4, size);
+  }
+
+  @Test
+  public void testReturnsLargestSizeForNullConfig() {
+    int width = 999;
+    int height = 41324;
+    int size = Util.getBitmapByteSize(width, height, null);
+    assertEquals(width * height * 4, size);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
new file mode 100644
index 000000000..81ed47525
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.util;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ViewPreloadSizeProviderTest {
+
+  private View view;
+  private ViewPreloadSizeProvider<Object> provider;
+
+  @Before
+  public void setUp() {
+    view = new View(RuntimeEnvironment.application);
+    provider = new ViewPreloadSizeProvider<>();
+  }
+
+  @Test
+  public void testReturnsNullFromGetPreloadSizeBeforeHasSize() {
+    assertNull(provider.getPreloadSize(new Object(), 0, 0));
+  }
+
+  @Test
+  public void testReturnsValidSizeFromGetPreloadSizeAfterHasSize() {
+    int width = 4123;
+    int height = 342;
+    provider.onSizeReady(width, height);
+
+    int[] size = provider.getPreloadSize(new Object(), 0, 0);
+    assertThat(size).asList().containsExactly(width, height);
+  }
+
+  @Test
+  public void testDoesNotObtainSizeFromViewOnceSizeIsSet() {
+    int width = 123;
+    int height = 456;
+    provider.onSizeReady(width, height);
+    view.setLayoutParams(new ViewGroup.LayoutParams(1, 1));
+
+    provider.setView(view);
+
+    int[] size = provider.getPreloadSize(new Object(), 0, 0);
+    assertThat(size).asList().containsExactly(width, height);
+  }
+
+  @Test
+  public void testCanObtainFixedSizeFromView() {
+    int width = 123;
+    int height = 456;
+    view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+
+    provider.setView(view);
+
+    int[] size = provider.getPreloadSize(new Object(), 0, 0);
+    assertThat(size).asList().containsExactly(width, height);
+  }
+
+  @Test
+  public void testIgnoresNewViewIfAlreadyWaitingOnSizeOfAnotherView() {
+    provider.setView(view);
+
+    View newView = new View(RuntimeEnvironment.application);
+    newView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+    provider.setView(newView);
+
+    assertNull(provider.getPreloadSize(new Object(), 0, 0));
+  }
+
+  @Test
+  public void testCanObtainSizeFromViewWhenGivenViewInConstructor() {
+    int width = 100;
+    int height = 200;
+    view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+
+    provider = new ViewPreloadSizeProvider<>(view);
+
+    int[] size = provider.getPreloadSize(new Object(), 0, 0);
+    assertThat(size).asList().containsExactly(width, height);
+  }
+}
diff --git a/library/src/test/java/javax/microedition/khronos/opengles/GL.java b/library/src/test/java/javax/microedition/khronos/opengles/GL.java
new file mode 100644
index 000000000..40792a85f
--- /dev/null
+++ b/library/src/test/java/javax/microedition/khronos/opengles/GL.java
@@ -0,0 +1,9 @@
+package javax.microedition.khronos.opengles;
+
+/**
+ * TODO: Figure out why this is necessary and remove it.
+ * See: https://github.com/robolectric/robolectric-gradle-plugin/issues/145
+ */
+public interface GL {
+}
+
diff --git a/library/src/androidTest/resources/exif-orientation-examples b/library/src/test/resources/exif-orientation-examples
similarity index 100%
rename from library/src/androidTest/resources/exif-orientation-examples
rename to library/src/test/resources/exif-orientation-examples
diff --git a/library/src/test/resources/issue387_rotated_jpeg.jpg b/library/src/test/resources/issue387_rotated_jpeg.jpg
new file mode 100644
index 000000000..5852dac00
Binary files /dev/null and b/library/src/test/resources/issue387_rotated_jpeg.jpg differ
diff --git a/library/src/androidTest/resources/org.robolectric.Config.properties b/library/src/test/resources/org.robolectric.Config.properties
similarity index 100%
rename from library/src/androidTest/resources/org.robolectric.Config.properties
rename to library/src/test/resources/org.robolectric.Config.properties
diff --git a/library/src/test/resources/short_exif_sample.jpg b/library/src/test/resources/short_exif_sample.jpg
new file mode 100644
index 000000000..80f8ebd49
Binary files /dev/null and b/library/src/test/resources/short_exif_sample.jpg differ
diff --git a/library/src/androidTest/resources/test.gif b/library/src/test/resources/test.gif
similarity index 100%
rename from library/src/androidTest/resources/test.gif
rename to library/src/test/resources/test.gif
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index b4b13e7b3..aec235f5e 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -2,23 +2,32 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
+    compile(project(':integration:recyclerview')) {
+        transitive = false
+    }
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
     compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
+    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.flickr'
-        minSdkVersion MIN_SDK_VERSION as int
+        minSdkVersion 11
         targetSdkVersion TARGET_SDK_VERSION as int
 
         versionCode 1
         versionName '1.0.0'
     }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
 }
 
 task run(type: Exec, dependsOn: 'installDebug') {
diff --git a/samples/flickr/flickr.iml b/samples/flickr/flickr.iml
deleted file mode 100644
index 1a9333d82..000000000
--- a/samples/flickr/flickr.iml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":samples:flickr" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.samples" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":samples:flickr" />
-      </configuration>
-    </facet>
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="SELECTED_BUILD_VARIANT" value="debug" />
-        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
-        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
-        <option name="ALLOW_USER_CONFIGURATION" value="false" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
-        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
-      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
-      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" exported="" name="appcompat-v7-19.1.0" level="project" />
-    <orderEntry type="library" exported="" name="support-v4-19.1.0" level="project" />
-    <orderEntry type="library" exported="" name="library-1.0.7" level="project" />
-    <orderEntry type="module" module-name="library" exported="" />
-    <orderEntry type="module" module-name="disklrucache" exported="" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/samples/flickr/lint.xml b/samples/flickr/lint.xml
new file mode 100644
index 000000000..5c710c8c7
--- /dev/null
+++ b/samples/flickr/lint.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore"/>
+</lint>
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index 242d2cd15..1a6e4a6ff 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -1,28 +1,36 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-  package="com.bumptech.glide.samples.flickr">
+          package="com.bumptech.glide.samples.flickr">
 
-  <uses-permission android:name="android.permission.INTERNET" />
-  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
-  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
-  <application android:label="@string/app_name"
-               android:icon="@drawable/ic_launcher"
-               android:allowBackup="false"
-               android:theme="@style/Theme.AppCompat">
+    <uses-sdk android:minSdkVersion="10"
+      android:targetSdkVersion="22" />
 
-      <activity android:name=".FlickrSearchActivity"
-                android:label="@string/app_name"
-                android:launchMode="singleTask"
-                android:windowSoftInputMode="stateHidden|adjustResize" >
-        <intent-filter>
-            <action android:name="android.intent.action.MAIN" />
-            <category android:name="android.intent.category.LAUNCHER" />
-        </intent-filter>
-      </activity>
+    <application
+        android:label="@string/app_name"
+        android:icon="@android:drawable/sym_def_app_icon"
+        android:allowBackup="false"
+        android:theme="@style/Theme.AppCompat">
 
-    <activity android:name=".FullscreenActivity" />
+        <activity
+            android:name=".FlickrSearchActivity"
+            android:label="@string/app_name"
+            android:launchMode="singleTask"
+            android:windowSoftInputMode="stateHidden|adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
 
-  </application>
+        <activity android:name=".FullscreenActivity"/>
+
+        <meta-data
+            android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
+            android:value="GlideModule"/>
+    </application>
 
 </manifest>
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
new file mode 100644
index 000000000..e965d395e
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.samples.flickr;
+
+import android.content.Context;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.samples.flickr.api.Photo;
+
+import java.io.InputStream;
+
+/**
+ * {@link com.bumptech.glide.module.GlideModule} for the Flickr sample app.
+ */
+public class FlickrGlideModule implements GlideModule {
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index 9df6d1853..708f68e3a 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -2,46 +2,61 @@
 
 import android.content.Context;
 
-import com.bumptech.glide.load.model.GenericLoaderFactory;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
 import java.io.InputStream;
+import java.util.List;
 
 /**
- * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
- * Engine to download the image and resize it in memory before saving the resized version
- * directly to the disk cache.
+ * An implementation of ModelStreamLoader that leverages the StreamOpener class and the
+ * ExecutorService backing the Engine to download the image and resize it in memory before saving
+ * the resized version directly to the disk cache.
  */
 public class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
 
-    /**
-     * The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<Photo, InputStream> {
-        private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
+  /**
+   * The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s.
+   */
+  public static class Factory implements ModelLoaderFactory<Photo, InputStream> {
+    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
 
-        @Override
-        public ModelLoader<Photo, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new FlickrModelLoader(context, modelCache);
-        }
-
-        @Override
-        public void teardown() {
-        }
-    }
-
-    public FlickrModelLoader(Context context, ModelCache<Photo, GlideUrl> modelCache) {
-        super(context, modelCache);
+    @Override
+    public ModelLoader<Photo, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
+          modelCache);
     }
 
     @Override
-    protected String getUrl(Photo model, int width, int height) {
-        return Api.getPhotoURL(model, width, height);
+    public void teardown() {
     }
+  }
+
+  public FlickrModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader,
+      ModelCache<Photo, GlideUrl> modelCache) {
+    super(urlLoader, modelCache);
+  }
+
+  @Override
+  public boolean handles(Photo model) {
+    return true;
+  }
+
+  @Override
+  protected String getUrl(Photo model, int width, int height, Options options) {
+    return Api.getPhotoURL(model, width, height);
+  }
+
+  @Override
+  protected List<String> getAlternateUrls(Photo photo, int width, int height, Options options) {
+    return Api.getAlternateUrls(photo, width, height);
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 34dff7198..de9b10705 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -1,183 +1,224 @@
 package com.bumptech.glide.samples.flickr;
 
+import static com.bumptech.glide.GenericTransitionOptions.withNoTransition;
+import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
+import static com.bumptech.glide.request.RequestOptions.priorityOf;
+
 import android.content.Intent;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.BaseAdapter;
-import android.widget.GridView;
 import android.widget.ImageView;
 
-import com.bumptech.glide.DrawableRequestBuilder;
-import com.bumptech.glide.GenericRequestBuilder;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.FixedPreloadSizeProvider;
 
-import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
- * A fragment that shows square image thumbnails whose size is determined by the framgent's arguments in a grid
- * pattern.
+ * A fragment that shows square image thumbnails whose size is determined by the framgent's
+ * arguments in a grid pattern.
  */
 public class FlickrPhotoGrid extends Fragment implements PhotoViewer {
-    private static final String STATE_POSITION_INDEX = "state_position_index";
-
-    private static final String IMAGE_SIZE_KEY = "image_size";
-    private static final String PRELOAD_KEY = "preload";
-    private static final String THUMBNAIL_KEY = "thumbnail";
-
-    private PhotoAdapter adapter;
-    private List<Photo> currentPhotos;
-    private int photoSize;
-    private GridView grid;
-    private boolean thumbnail;
-    private DrawableRequestBuilder<Photo> fullRequest;
-    private DrawableRequestBuilder<Photo> thumbnailRequest;
-    private DrawableRequestBuilder<Photo> preloadRequest;
-
-    public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean thumbnail) {
-        FlickrPhotoGrid photoGrid = new FlickrPhotoGrid();
-        Bundle args = new Bundle();
-        args.putInt(IMAGE_SIZE_KEY, size);
-        args.putInt(PRELOAD_KEY, preloadCount);
-        args.putBoolean(THUMBNAIL_KEY, thumbnail);
-        photoGrid.setArguments(args);
-        return photoGrid;
+  private static final String STATE_POSITION_INDEX = "state_position_index";
+
+  private static final String IMAGE_SIZE_KEY = "image_size";
+  private static final String PRELOAD_KEY = "preload";
+  private static final String THUMBNAIL_KEY = "thumbnail";
+
+  private PhotoAdapter adapter;
+  private List<Photo> currentPhotos;
+  private int photoSize;
+  private RecyclerView grid;
+  private boolean thumbnail;
+  private RequestBuilder<Drawable> fullRequest;
+  private RequestBuilder<Drawable> thumbnailRequest;
+  private RequestBuilder<Drawable> preloadRequest;
+  private GridLayoutManager layoutManager;
+
+  public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean thumbnail) {
+    FlickrPhotoGrid photoGrid = new FlickrPhotoGrid();
+    Bundle args = new Bundle();
+    args.putInt(IMAGE_SIZE_KEY, size);
+    args.putInt(PRELOAD_KEY, preloadCount);
+    args.putBoolean(THUMBNAIL_KEY, thumbnail);
+    photoGrid.setArguments(args);
+    return photoGrid;
+  }
+
+  @Override
+  public View onCreateView(LayoutInflater inflater, ViewGroup container,
+      Bundle savedInstanceState) {
+    Bundle args = getArguments();
+    photoSize = args.getInt(IMAGE_SIZE_KEY);
+    thumbnail = args.getBoolean(THUMBNAIL_KEY);
+
+    fullRequest = Glide.with(this)
+        .asDrawable()
+        .transition(withNoTransition())
+        .apply(centerCropTransform(getActivity()));
+
+    thumbnailRequest = Glide.with(this)
+        .asDrawable()
+        .transition(withNoTransition())
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
+            .centerCrop(getActivity())
+            .override(Api.SQUARE_THUMB_SIZE));
+
+    preloadRequest =
+        thumbnail ? thumbnailRequest.clone().apply(priorityOf(Priority.HIGH)) : fullRequest;
+
+    final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
+
+    final int gridMargin = getResources().getDimensionPixelOffset(R.dimen.grid_margin);
+    int spanCount = getResources().getDisplayMetrics().widthPixels / (photoSize + (2 * gridMargin));
+    grid = (RecyclerView) result.findViewById(R.id.flickr_photo_grid);
+    layoutManager = new GridLayoutManager(getActivity(), spanCount);
+    grid.setLayoutManager(layoutManager);
+
+    grid.addItemDecoration(new RecyclerView.ItemDecoration() {
+      @Override
+      public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
+          RecyclerView.State state) {
+        outRect.set(gridMargin, gridMargin, gridMargin, gridMargin);
+      }
+    });
+    grid.setRecyclerListener(new RecyclerView.RecyclerListener() {
+      @Override
+      public void onViewRecycled(RecyclerView.ViewHolder holder) {
+        PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
+        Glide.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
+      }
+    });
+
+    int heightCount = getResources().getDisplayMetrics().heightPixels / photoSize;
+    grid.getRecycledViewPool().setMaxRecycledViews(0, spanCount * heightCount * 2);
+    grid.setItemViewCacheSize(0);
+    adapter = new PhotoAdapter();
+    grid.setAdapter(adapter);
+
+    FixedPreloadSizeProvider<Photo> preloadSizeProvider =
+        new FixedPreloadSizeProvider<>(photoSize, photoSize);
+    RecyclerViewPreloader<Photo> preloader = new RecyclerViewPreloader<>(Glide.with(this), adapter,
+        preloadSizeProvider, args.getInt(PRELOAD_KEY));
+    grid.addOnScrollListener(preloader);
+
+    if (currentPhotos != null) {
+      adapter.setPhotos(currentPhotos);
     }
 
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        Bundle args = getArguments();
-        photoSize = args.getInt(IMAGE_SIZE_KEY);
-        thumbnail = args.getBoolean(THUMBNAIL_KEY);
-
-        fullRequest = Glide.with(this)
-                .from(Photo.class)
-                .centerCrop()
-                .crossFade(R.anim.fade_in, 150);
-
-        thumbnailRequest = Glide.with(this)
-                .from(Photo.class)
-                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
-                .override(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
-
-        preloadRequest = thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
-
-        final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
-
-        grid = (GridView) result.findViewById(R.id.images);
-        grid.setColumnWidth(photoSize);
-        adapter = new PhotoAdapter();
-        grid.setAdapter(adapter);
-
-        final FixedPreloadSizeProvider<Photo> preloadSizeProvider =
-                new FixedPreloadSizeProvider<Photo>(photoSize, photoSize);
-        final ListPreloader<Photo> preloader =
-                new ListPreloader<Photo>(adapter, preloadSizeProvider, args.getInt(PRELOAD_KEY));
-        grid.setOnScrollListener(preloader);
-
-        if (currentPhotos != null) {
-            adapter.setPhotos(currentPhotos);
-        }
+    if (savedInstanceState != null) {
+      int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
+      grid.scrollToPosition(index);
+    }
 
-        if (savedInstanceState != null) {
-            int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
-            grid.setSelection(index);
-        }
+    return result;
+  }
 
-        return result;
+  @Override
+  public void onSaveInstanceState(Bundle outState) {
+    super.onSaveInstanceState(outState);
+    if (grid != null) {
+      int index = layoutManager.findFirstVisibleItemPosition();
+      outState.putInt(STATE_POSITION_INDEX, index);
     }
+  }
 
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        if (grid != null) {
-            int index = grid.getFirstVisiblePosition();
-            outState.putInt(STATE_POSITION_INDEX, index);
-        }
+  @Override
+  public void onPhotosUpdated(List<Photo> photos) {
+    currentPhotos = photos;
+    if (adapter != null) {
+      adapter.setPhotos(currentPhotos);
+    }
+  }
+
+  private class PhotoAdapter extends RecyclerView.Adapter<PhotoViewHolder> implements
+      ListPreloader.PreloadModelProvider<Photo> {
+    private final LayoutInflater inflater;
+    private List<Photo> photos = Collections.emptyList();
+
+    public PhotoAdapter() {
+      this.inflater = LayoutInflater.from(getActivity());
+    }
+
+    public void setPhotos(List<Photo> photos) {
+      this.photos = photos;
+      notifyDataSetChanged();
     }
 
     @Override
-    public void onPhotosUpdated(List<Photo> photos) {
-        currentPhotos = photos;
-        if (adapter != null) {
-            adapter.setPhotos(currentPhotos);
-        }
+    public int getItemViewType(int position) {
+      return 0;
     }
 
-    private class PhotoAdapter extends BaseAdapter implements ListPreloader.PreloadModelProvider<Photo> {
-        private List<Photo> photos = new ArrayList<Photo>(0);
-        private final LayoutInflater inflater;
+    @Override
+    public PhotoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      View view = inflater.inflate(R.layout.flickr_photo_grid_item, parent, false);
+      ViewGroup.LayoutParams params = view.getLayoutParams();
+      params.width = photoSize;
+      params.height = photoSize;
+      return new PhotoViewHolder(view);
+    }
 
-        public PhotoAdapter() {
-            this.inflater = LayoutInflater.from(getActivity());
-        }
+    @Override
+    public void onBindViewHolder(PhotoViewHolder holder, int position) {
+      final Photo current = photos.get(position);
 
-        public void setPhotos(List<Photo> photos) {
-            this.photos = photos;
-            notifyDataSetChanged();
-        }
+      fullRequest.load(current)
+          .thumbnail(thumbnail ? thumbnailRequest.load(current) : null)
+          .into(holder.imageView);
 
+      holder.imageView.setOnClickListener(new View.OnClickListener() {
         @Override
-        public int getCount() {
-            return photos.size();
+        public void onClick(View view) {
+          Intent intent = FullscreenActivity.getIntent(getActivity(), current);
+          startActivity(intent);
         }
+      });
+    }
 
-        @Override
-        public Object getItem(int i) {
-            return photos.get(i);
-        }
+    @Override
+    public long getItemId(int i) {
+      return RecyclerView.NO_ID;
+    }
 
-        @Override
-        public long getItemId(int i) {
-            return 0;
-        }
+    @Override
+    public int getItemCount() {
+      return photos.size();
+    }
 
-        @Override
-        public View getView(int position, View view, ViewGroup container) {
-            final Photo current = photos.get(position);
-            final ImageView imageView;
-            if (view == null) {
-                imageView = (ImageView) inflater.inflate(R.layout.flickr_photo_grid_item, container, false);
-                ViewGroup.LayoutParams params = imageView.getLayoutParams();
-                params.width = photoSize;
-                params.height = photoSize;
-            } else {
-                imageView = (ImageView) view;
-            }
-
-            fullRequest
-                    .load(current)
-                    .thumbnail(thumbnail ? thumbnailRequest.load(current) : null)
-                    .into(imageView);
-
-            imageView.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                    Intent intent = FullscreenActivity.getIntent(getActivity(), current);
-                    startActivity(intent);
-                }
-            });
-
-            return imageView;
-        }
+    @Override
+    public List<Photo> getPreloadItems(int position) {
+      return photos.subList(position, position + 1);
+    }
 
-        @Override
-        public List<Photo> getPreloadItems(int position) {
-            return photos.subList(position, position + 1);
-        }
+    @Override
+    public RequestBuilder getPreloadRequestBuilder(Photo item) {
+      return preloadRequest.load(item);
+    }
+  }
 
-        @Override
-        public GenericRequestBuilder getPreloadRequestBuilder(Photo item) {
-            return preloadRequest.load(item);
-        }
+  private static class PhotoViewHolder extends RecyclerView.ViewHolder {
+    private final ImageView imageView;
+
+    public PhotoViewHolder(View itemView) {
+      super(itemView);
+      imageView = (ImageView) itemView;
     }
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index 286c817ab..8c4496714 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -1,182 +1,194 @@
 package com.bumptech.glide.samples.flickr;
 
+import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
+import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
+
 import android.content.Intent;
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.BaseAdapter;
 import android.widget.ImageView;
-import android.widget.ListView;
 import android.widget.TextView;
 
-import com.bumptech.glide.DrawableRequestBuilder;
-import com.bumptech.glide.GenericRequestBuilder;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
 
-import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
  * A fragment that shows cropped image thumbnails half the width of the screen in a scrolling list.
  */
 public class FlickrPhotoList extends Fragment implements PhotoViewer {
-    private static final int PRELOAD_AHEAD_ITEMS = 5;
-    private static final String STATE_POSITION_INDEX = "state_position_index";
-    private static final String STATE_POSITION_OFFSET = "state_position_offset";
-    private FlickrPhotoListAdapter adapter;
-    private List<Photo> currentPhotos;
-    private ListView list;
-    private DrawableRequestBuilder<Photo> fullRequest;
-    private DrawableRequestBuilder<Photo> thumbRequest;
-    private ViewPreloadSizeProvider<Photo> preloadSizeProvider;
-
-    public static FlickrPhotoList newInstance() {
-        return new FlickrPhotoList();
+  private static final int PRELOAD_AHEAD_ITEMS = 5;
+  private static final String STATE_POSITION_INDEX = "state_position_index";
+  private static final String STATE_POSITION_OFFSET = "state_position_offset";
+  private FlickrPhotoListAdapter adapter;
+  private List<Photo> currentPhotos;
+  private RecyclerView list;
+  private RequestBuilder<Drawable> fullRequest;
+  private RequestBuilder<Drawable> thumbRequest;
+  private ViewPreloadSizeProvider<Photo> preloadSizeProvider;
+  private LinearLayoutManager layoutManager;
+
+  public static FlickrPhotoList newInstance() {
+    return new FlickrPhotoList();
+  }
+
+  @Override
+  public void onPhotosUpdated(List<Photo> photos) {
+    currentPhotos = photos;
+    if (adapter != null) {
+      adapter.setPhotos(currentPhotos);
     }
-
-    @Override
-    public void onPhotosUpdated(List<Photo> photos) {
-        currentPhotos = photos;
-        if (adapter != null) {
-            adapter.setPhotos(currentPhotos);
-        }
+  }
+
+  @Override
+  public View onCreateView(LayoutInflater inflater, ViewGroup container,
+      Bundle savedInstanceState) {
+    final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
+
+    list = (RecyclerView) result.findViewById(R.id.flickr_photo_list);
+    layoutManager = new LinearLayoutManager(getActivity());
+    list.setLayoutManager(layoutManager);
+    adapter = new FlickrPhotoListAdapter();
+    list.setAdapter(adapter);
+
+    preloadSizeProvider = new ViewPreloadSizeProvider<>();
+    RecyclerViewPreloader<Photo> preloader = new RecyclerViewPreloader<>(Glide.with(this), adapter,
+        preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
+    list.addOnScrollListener(preloader);
+    list.setItemViewCacheSize(0);
+
+    if (currentPhotos != null) {
+      adapter.setPhotos(currentPhotos);
     }
 
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
-        list = (ListView) result.findViewById(R.id.flickr_photo_list);
-        adapter = new FlickrPhotoListAdapter();
-        list.setAdapter(adapter);
-
-        preloadSizeProvider = new ViewPreloadSizeProvider<Photo>();
-        ListPreloader<Photo> preloader = new ListPreloader<Photo>(adapter, preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
-        list.setOnScrollListener(preloader);
-
-        if (currentPhotos != null) {
-            adapter.setPhotos(currentPhotos);
-        }
-
-        fullRequest = Glide.with(FlickrPhotoList.this)
-                .from(Photo.class)
-                .placeholder(new ColorDrawable(Color.GRAY))
-                .centerCrop();
+    final RequestManager requestManager = Glide.with(this);
+    fullRequest = requestManager
+        .asDrawable()
+        .apply(centerCropTransform(getActivity())
+            .placeholder(new ColorDrawable(Color.GRAY)));
+
+    thumbRequest = requestManager
+        .asDrawable()
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
+            .override(Api.SQUARE_THUMB_SIZE))
+        .transition(withCrossFade());
+
+    list.setRecyclerListener(new RecyclerView.RecyclerListener() {
+      @Override
+      public void onViewRecycled(RecyclerView.ViewHolder holder) {
+        PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
+        requestManager.clear(vh.imageView);
+      }
+    });
+
+    if (savedInstanceState != null) {
+      int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
+      int offset = savedInstanceState.getInt(STATE_POSITION_OFFSET);
+      layoutManager.scrollToPositionWithOffset(index, offset);
+    }
 
-        thumbRequest = Glide.with(FlickrPhotoList.this)
-                .from(Photo.class)
-                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
-                .override(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
+    return result;
+  }
+
+  @Override
+  public void onSaveInstanceState(Bundle outState) {
+    super.onSaveInstanceState(outState);
+    if (list != null) {
+      int index = layoutManager.findFirstVisibleItemPosition();
+      View topView = list.getChildAt(0);
+      int offset = topView != null ? topView.getTop() : 0;
+      outState.putInt(STATE_POSITION_INDEX, index);
+      outState.putInt(STATE_POSITION_OFFSET, offset);
+    }
+  }
 
-        if (savedInstanceState != null) {
-            int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
-            int offset = savedInstanceState.getInt(STATE_POSITION_OFFSET);
-            list.setSelectionFromTop(index, offset);
-        }
+  private class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
+      implements ListPreloader.PreloadModelProvider<Photo> {
+    private final LayoutInflater inflater;
+    private List<Photo> photos = Collections.emptyList();
 
-        return result;
+    public FlickrPhotoListAdapter() {
+      this.inflater = LayoutInflater.from(getActivity());
     }
 
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        if (list != null) {
-            int index = list.getFirstVisiblePosition();
-            View topView = list.getChildAt(0);
-            int offset = topView != null ? topView.getTop() : 0;
-            outState.putInt(STATE_POSITION_INDEX, index);
-            outState.putInt(STATE_POSITION_OFFSET, offset);
-        }
+    public void setPhotos(List<Photo> photos) {
+      this.photos = photos;
+      notifyDataSetChanged();
     }
 
-    private static class ViewHolder {
-        private final TextView titleText;
-        private final ImageView imageView;
-
-        public ViewHolder(ImageView imageView, TextView titleText) {
-            this.imageView = imageView;
-            this.titleText = titleText;
-        }
+    @Override
+    public PhotoTitleViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      View view = inflater.inflate(R.layout.flickr_photo_list_item, parent, false);
+      PhotoTitleViewHolder vh = new PhotoTitleViewHolder(view);
+      preloadSizeProvider.setView(vh.imageView);
+      return vh;
     }
 
-    private class FlickrPhotoListAdapter extends BaseAdapter implements ListPreloader.PreloadModelProvider<Photo> {
-        private final LayoutInflater inflater;
-        private List<Photo> photos = new ArrayList<Photo>(0);
+    @Override
+    public void onBindViewHolder(PhotoTitleViewHolder holder, int position) {
+      final Photo current = photos.get(position);
+      fullRequest.load(current)
+          .thumbnail(thumbRequest.load(current))
+          .into(holder.imageView);
 
-        public FlickrPhotoListAdapter() {
-            this.inflater = LayoutInflater.from(getActivity());
+      holder.imageView.setOnClickListener(new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+          Intent intent = FullscreenActivity.getIntent(getActivity(), current);
+          startActivity(intent);
         }
+      });
 
-        public void setPhotos(List<Photo> photos) {
-            this.photos = photos;
-            notifyDataSetChanged();
-        }
+      holder.titleView.setText(current.getTitle());
+    }
 
-        @Override
-        public int getCount() {
-            return photos.size();
-        }
+    @Override
+    public long getItemId(int i) {
+      return RecyclerView.NO_ID;
+    }
 
-        @Override
-        public Object getItem(int i) {
-            return null;
-        }
+    @Override
+    public int getItemCount() {
+      return photos.size();
+    }
 
-        @Override
-        public long getItemId(int i) {
-            return 0;
-        }
+    @Override
+    public List<Photo> getPreloadItems(int position) {
+      return photos.subList(position, position + 1);
+    }
 
-        @Override
-        public View getView(int position, View view, ViewGroup container) {
-            final Photo current = photos.get(position);
-            final ViewHolder viewHolder;
-            if (view == null) {
-                view = inflater.inflate(R.layout.flickr_photo_list_item, container, false);
-                final ImageView imageView = (ImageView) view.findViewById(R.id.photo_view);
-                TextView titleView = (TextView) view.findViewById(R.id.title_view);
-                viewHolder = new ViewHolder(imageView, titleView);
-                view.setTag(viewHolder);
-                preloadSizeProvider.setView(imageView);
-            } else {
-                viewHolder = (ViewHolder) view.getTag();
-            }
-
-            fullRequest
-                    .thumbnail(thumbRequest.load(current))
-                    .load(current)
-                    .into(viewHolder.imageView);
-
-            viewHolder.imageView.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                    Intent intent = FullscreenActivity.getIntent(getActivity(), current);
-                    startActivity(intent);
-                }
-            });
-
-            viewHolder.titleText.setText(current.getTitle());
-            return view;
-        }
+    @Override
+    public RequestBuilder getPreloadRequestBuilder(Photo item) {
+      return fullRequest.thumbnail(thumbRequest.load(item)).load(item);
+    }
+  }
 
-        @Override
-        public List<Photo> getPreloadItems(int position) {
-            return photos.subList(position, position + 1);
-        }
+  private static class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
+    private final TextView titleView;
+    private final ImageView imageView;
 
-        @Override
-        public GenericRequestBuilder getPreloadRequestBuilder(Photo item) {
-            return fullRequest
-                    .thumbnail(thumbRequest.load(item))
-                    .load(item);
-        }
+    public PhotoTitleViewHolder(View itemView) {
+      super(itemView);
+      imageView = (ImageView) itemView.findViewById(R.id.photo_view);
+      titleView = (TextView) itemView.findViewById(R.id.title_view);
     }
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index 66fba9810..163c9d220 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -12,18 +12,16 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.app.FragmentTransaction;
+import android.support.v4.view.MenuItemCompat;
 import android.support.v4.view.ViewPager;
-import android.support.v7.app.ActionBar;
-import android.support.v7.app.ActionBarActivity;
+import android.support.v7.app.AppCompatActivity;
 import android.text.TextUtils;
 import android.util.Log;
-import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.view.inputmethod.EditorInfo;
-import android.widget.Button;
-import android.widget.EditText;
+import android.widget.SearchView;
 import android.widget.TextView;
 
 import com.bumptech.glide.Glide;
@@ -31,10 +29,13 @@
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
+import com.bumptech.glide.samples.flickr.api.Query;
+import com.bumptech.glide.samples.flickr.api.RecentQuery;
+import com.bumptech.glide.samples.flickr.api.SearchQuery;
 
 import java.io.File;
-import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -43,347 +44,331 @@
 import java.util.concurrent.ExecutionException;
 
 /**
- * An activity that allows users to search for images on Flickr and that contains a series of fragments that display
- * retrieved image thumbnails.
+ * An activity that allows users to search for images on Flickr and that contains a series of
+ * fragments that display retrieved image thumbnails.
  */
-public class FlickrSearchActivity extends ActionBarActivity {
-    private static final String TAG = "FlickrSearchActivity";
-    private static final String STATE_SEARCH_STRING = "state_search_string";
-
-    private EditText searchText;
-    private View searching;
-    private TextView searchTerm;
-    private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
-    private List<Photo> currentPhotos = new ArrayList<Photo>();
-    private View searchLoading;
-    private String currentSearchString;
-    private final SearchListener searchListener = new SearchListener();
-    private BackgroundThumbnailFetcher backgroundThumbnailFetcher;
-    private HandlerThread backgroundThread;
-    private Handler backgroundHandler;
-
-    private enum Page {
-        SMALL,
-        MEDIUM,
-        LIST
+public class FlickrSearchActivity extends AppCompatActivity
+    implements SearchView.OnQueryTextListener {
+  private static final String TAG = "FlickrSearchActivity";
+  private static final String STATE_QUERY = "state_search_string";
+
+  private final QueryListener queryListener = new QueryListener();
+  private View searching;
+  private TextView searchTerm;
+  private Set<PhotoViewer> photoViewers = new HashSet<>();
+  private List<Photo> currentPhotos = new ArrayList<>();
+  private View searchLoading;
+  private BackgroundThumbnailFetcher backgroundThumbnailFetcher;
+  private HandlerThread backgroundThread;
+  private Handler backgroundHandler;
+  private SearchView searchView;
+  private Query currentQuery;
+
+  private enum Page {
+    SMALL,
+    MEDIUM,
+    LIST
+  }
+
+  private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {
+    {
+      put(Page.SMALL, R.string.small);
+      put(Page.MEDIUM, R.string.medium);
+      put(Page.LIST, R.string.list);
     }
-
-    private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() { {
-        put(Page.SMALL, R.string.small);
-        put(Page.MEDIUM, R.string.medium);
-        put(Page.LIST, R.string.list);
-    } };
-
-    @Override
-    public void onAttachFragment(Fragment fragment) {
-        super.onAttachFragment(fragment);
-        if (fragment instanceof PhotoViewer) {
-            PhotoViewer photoViewer = (PhotoViewer) fragment;
-            photoViewer.onPhotosUpdated(currentPhotos);
-            if (!photoViewers.contains(photoViewer)) {
-                photoViewers.add(photoViewer);
-            }
-        }
+  };
+
+  @Override
+  public void onAttachFragment(Fragment fragment) {
+    super.onAttachFragment(fragment);
+    if (fragment instanceof PhotoViewer) {
+      PhotoViewer photoViewer = (PhotoViewer) fragment;
+      photoViewer.onPhotosUpdated(currentPhotos);
+      if (!photoViewers.contains(photoViewer)) {
+        photoViewers.add(photoViewer);
+      }
     }
-
-    /** Called when the activity is first created. */
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        Glide.get(this).register(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
-        backgroundThread = new HandlerThread("BackgroundThumbnailHandlerThread");
-        backgroundThread.start();
-        backgroundHandler = new Handler(backgroundThread.getLooper());
-
-        setContentView(R.layout.flickr_search_activity);
-        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
-                .detectAll()
-                .penaltyLog()
-                .build());
-        searching = findViewById(R.id.searching);
-        searchLoading = findViewById(R.id.search_loading);
-        searchTerm = (TextView) findViewById(R.id.search_term);
-
-        searchText = (EditText) findViewById(R.id.search_text);
-        searchText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
-            @Override
-            public boolean onEditorAction(TextView textView, int actionId, KeyEvent keyEvent) {
-                if (actionId == EditorInfo.IME_ACTION_SEARCH) {
-                    executeSearch();
-                    return true;
-                }
-                return false;
-            }
-        });
-
-        final Button search = (Button) findViewById(R.id.search);
-        search.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                executeSearch();
-            }
-        });
-
-        final ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
-        pager.setPageMargin(50);
-        pager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
-            @Override
-            public void onPageScrolled(int i, float v, int i2) { }
-
-            @Override
-            public void onPageSelected(int position) {
-                getSupportActionBar().getTabAt(position).select();
-            }
-
-            @Override
-            public void onPageScrollStateChanged(int i) { }
-        });
-
-
-        final ActionBar actionBar = getSupportActionBar();
-        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
-
-        for (Page page : Page.values()) {
-            final int textId = PAGE_TO_TITLE.get(page);
-            actionBar.addTab(actionBar.newTab().setText(textId).setTabListener(new TabListener(pager)));
-        }
-
-        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager()));
-
-        Api.get(this).registerSearchListener(searchListener);
-        if (savedInstanceState != null) {
-            String savedSearchString = savedInstanceState.getString(STATE_SEARCH_STRING);
-            if (!TextUtils.isEmpty(savedSearchString)) {
-                executeSearch(savedSearchString);
-            }
-        }
-
-        final Resources res = getResources();
-        int smallGridSize = res.getDimensionPixelSize(R.dimen.small_photo_side);
-        int mediumGridSize = res.getDimensionPixelSize(R.dimen.medium_photo_side);
-        int listHeightSize = res.getDimensionPixelSize(R.dimen.flickr_list_item_height);
-        int screenWidth = getScreenWidth();
-
-        // Weight values determined experimentally by measuring the number of incurred GCs while scrolling through
-        // the various photo grids/lists.
-        Glide.get(this).preFillBitmapPool(
-                new PreFillType.Builder(smallGridSize).setWeight(1),
-                new PreFillType.Builder(mediumGridSize).setWeight(1),
-                new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
+  }
+
+  @Override
+  public boolean onCreateOptionsMenu(Menu menu) {
+    MenuInflater menuInflater = getMenuInflater();
+    menuInflater.inflate(R.menu.search_activity, menu);
+
+    searchView =
+        (SearchView) MenuItemCompat.getActionView(menu.findItem(R.id.search));
+    searchView.setSubmitButtonEnabled(true);
+    searchView.setIconified(false);
+    searchView.setOnQueryTextListener(this);
+
+    return true;
+  }
+
+  @Override
+  public boolean onQueryTextSubmit(String query) {
+    executeSearch(query);
+    searchView.setQuery("", false /*submit*/);
+    return true;
+  }
+
+  @Override
+  public boolean onQueryTextChange(String newText) {
+    return false;
+  }
+
+  /**
+   * Called when the activity is first created.
+   */
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+        .detectAll()
+        .penaltyLog()
+        .build());
+
+    backgroundThread = new HandlerThread("BackgroundThumbnailHandlerThread");
+    backgroundThread.start();
+    backgroundHandler = new Handler(backgroundThread.getLooper());
+
+    setContentView(R.layout.flickr_search_activity);
+    searching = findViewById(R.id.searching);
+    searchLoading = findViewById(R.id.search_loading);
+    searchTerm = (TextView) findViewById(R.id.search_term);
+
+    Resources res = getResources();
+    ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
+    pager.setPageMargin(res.getDimensionPixelOffset(R.dimen.page_margin));
+    pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager()));
+
+    Api.get(this).registerSearchListener(queryListener);
+    if (savedInstanceState != null) {
+      Query savedQuery = savedInstanceState.getParcelable(STATE_QUERY);
+      if (savedQuery != null) {
+        executeQuery(savedQuery);
+      }
+    } else {
+      executeQuery(RecentQuery.get());
     }
 
-    private int getScreenWidth() {
-        return getResources().getDisplayMetrics().widthPixels;
+    int smallGridSize = res.getDimensionPixelSize(R.dimen.small_photo_side);
+    int mediumGridSize = res.getDimensionPixelSize(R.dimen.medium_photo_side);
+    int listHeightSize = res.getDimensionPixelSize(R.dimen.flickr_list_item_height);
+    int screenWidth = getScreenWidth();
+
+    if (savedInstanceState == null) {
+      // Weight values determined experimentally by measuring the number of incurred GCs while
+      // scrolling through the various photo grids/lists.
+      Glide.get(this).preFillBitmapPool(new PreFillType.Builder(smallGridSize).setWeight(1),
+          new PreFillType.Builder(mediumGridSize).setWeight(1),
+          new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
     }
+  }
 
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        if (!TextUtils.isEmpty(currentSearchString)) {
-            outState.putString(STATE_SEARCH_STRING, currentSearchString);
-        }
-    }
+  private int getScreenWidth() {
+    return getResources().getDisplayMetrics().widthPixels;
+  }
 
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        Api.get(this).unregisterSearchListener(searchListener);
-        if (backgroundThumbnailFetcher != null) {
-            backgroundThumbnailFetcher.cancel();
-            backgroundThumbnailFetcher = null;
-            backgroundThread.quit();
-            backgroundThread = null;
-        }
+  @Override
+  protected void onSaveInstanceState(Bundle outState) {
+    super.onSaveInstanceState(outState);
+    if (currentQuery != null) {
+      outState.putParcelable(STATE_QUERY, currentQuery);
     }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Override
-    public void onTrimMemory(int level) {
-        super.onTrimMemory(level);
-        Glide.get(this).trimMemory(level);
+  }
+
+  @Override
+  protected void onDestroy() {
+    super.onDestroy();
+    Api.get(this).unregisterSearchListener(queryListener);
+    if (backgroundThumbnailFetcher != null) {
+      backgroundThumbnailFetcher.cancel();
+      backgroundThumbnailFetcher = null;
+      backgroundThread.quit();
+      backgroundThread = null;
     }
-
-    @Override
-    public void onLowMemory() {
-        super.onLowMemory();
-        Glide.get(this).clearMemory();
+  }
+
+  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+  @Override
+  public void onTrimMemory(int level) {
+    super.onTrimMemory(level);
+    Glide.get(this).trimMemory(level);
+  }
+
+  @Override
+  public void onLowMemory() {
+    super.onLowMemory();
+    Glide.get(this).clearMemory();
+  }
+
+  private void executeSearch(String searchString) {
+    Query query = TextUtils.isEmpty(searchString) ? null : new SearchQuery(searchString);
+    executeQuery(query);
+  }
+
+  private void executeQuery(Query query) {
+    currentQuery = query;
+    if (query == null) {
+      queryListener.onSearchCompleted(null, Collections.<Photo>emptyList());
+      return;
     }
 
-    private void executeSearch() {
-        String searchString = searchText.getText().toString();
-        searchText.getText().clear();
-        executeSearch(searchString);
-    }
+    searching.setVisibility(View.VISIBLE);
+    searchLoading.setVisibility(View.VISIBLE);
+    searchTerm.setText(getString(R.string.searching_for, currentQuery.getDescription()));
 
-    private void executeSearch(String searchString) {
-        currentSearchString = searchString;
+    Api.get(this).query(currentQuery);
+  }
 
-        if (TextUtils.isEmpty(searchString)) {
-            return;
-        }
-
-        searching.setVisibility(View.VISIBLE);
-        searchLoading.setVisibility(View.VISIBLE);
-        searchTerm.setText(getString(R.string.searching_for, currentSearchString));
+  private class QueryListener implements Api.QueryListener {
+    @Override
+    public void onSearchCompleted(Query query, List<Photo> photos) {
+      if (!isCurrentQuery(query)) {
+        return;
+      }
 
-        Api.get(this).search(currentSearchString);
-    }
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Search completed, got " + photos.size() + " results");
+      }
+      searching.setVisibility(View.INVISIBLE);
 
-    private static class TabListener implements ActionBar.TabListener {
-        private final ViewPager pager;
+      for (PhotoViewer viewer : photoViewers) {
+        viewer.onPhotosUpdated(photos);
+      }
 
-        public TabListener(ViewPager pager) {
-            this.pager = pager;
-        }
+      if (backgroundThumbnailFetcher != null) {
+        backgroundThumbnailFetcher.cancel();
+      }
 
-        @Override
-        public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
-            pager.setCurrentItem(tab.getPosition());
-        }
+      backgroundThumbnailFetcher =
+          new BackgroundThumbnailFetcher(FlickrSearchActivity.this, photos);
+      backgroundHandler.post(backgroundThumbnailFetcher);
 
-        @Override
-        public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) { }
+      currentPhotos = photos;
+    }
 
-        @Override
-        public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) { }
+    private boolean isCurrentQuery(Query query) {
+      return currentQuery != null && currentQuery.equals(query);
     }
 
-    private class SearchListener implements Api.SearchListener {
-        @Override
-        public void onSearchCompleted(String searchString, List<Photo> photos) {
-            if (!TextUtils.equals(currentSearchString, searchString)) {
-                return;
-            }
+    @Override
+    public void onSearchFailed(Query query, Exception e) {
+      if (!isCurrentQuery(query)) {
+        return;
+      }
+
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Search failed", e);
+      }
+      searching.setVisibility(View.VISIBLE);
+      searchLoading.setVisibility(View.INVISIBLE);
+      searchTerm.setText(getString(R.string.search_failed, currentQuery.getDescription()));
+    }
+  }
 
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Search completed, got " + photos.size() + " results");
-            }
-            searching.setVisibility(View.INVISIBLE);
+  private class FlickrPagerAdapter extends FragmentPagerAdapter {
 
-            for (PhotoViewer viewer : photoViewers) {
-                viewer.onPhotosUpdated(photos);
-            }
+    private int mLastPosition = -1;
+    private Fragment mLastFragment;
 
-            if (backgroundThumbnailFetcher != null) {
-                backgroundThumbnailFetcher.cancel();
-            }
+    public FlickrPagerAdapter(FragmentManager fm) {
+      super(fm);
+    }
 
-            backgroundThumbnailFetcher = new BackgroundThumbnailFetcher(FlickrSearchActivity.this, photos);
-            backgroundHandler.post(backgroundThumbnailFetcher);
+    @Override
+    public Fragment getItem(int position) {
+      return pageToFragment(position);
+    }
 
-            currentPhotos = photos;
+    @Override
+    public void setPrimaryItem(ViewGroup container, int position, Object object) {
+      super.setPrimaryItem(container, position, object);
+      if (position != mLastPosition) {
+        if (mLastPosition >= 0) {
+          Glide.with(mLastFragment).pauseRequests();
         }
-
-        @Override
-        public void onSearchFailed(String searchString, Exception e) {
-            if (!TextUtils.equals(currentSearchString, searchString)) {
-                return;
-            }
-
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Search failed", e);
-            }
-            searching.setVisibility(View.VISIBLE);
-            searchLoading.setVisibility(View.INVISIBLE);
-            searchTerm.setText(getString(R.string.search_failed, currentSearchString));
+        Fragment current = (Fragment) object;
+        mLastPosition = position;
+        mLastFragment = current;
+        if (current.isAdded()) {
+          Glide.with(current).resumeRequests();
         }
+      }
     }
 
-    private class FlickrPagerAdapter extends FragmentPagerAdapter {
-
-        private int mLastPosition = -1;
-        private Fragment mLastFragment;
-
-        public FlickrPagerAdapter(FragmentManager fm) {
-            super(fm);
-        }
+    @Override
+    public int getCount() {
+      return Page.values().length;
+    }
 
-        @Override
-        public Fragment getItem(int position) {
-            return pageToFragment(position);
-        }
+    @Override
+    public CharSequence getPageTitle(int position) {
+      Page page = Page.values()[position];
+      int titleId = PAGE_TO_TITLE.get(page);
+      return getString(titleId);
+    }
 
-        @Override
-        public void setPrimaryItem(ViewGroup container, int position, Object object) {
-            super.setPrimaryItem(container, position, object);
-            if (position != mLastPosition) {
-                if (mLastPosition >= 0) {
-                    Glide.with(mLastFragment).pauseRequests();
-                }
-                Fragment current = (Fragment) object;
-                mLastPosition = position;
-                mLastFragment = current;
-                if (current.isAdded()) {
-                    Glide.with(current).resumeRequests();
-                }
-            }
-        }
+    private Fragment pageToFragment(int position) {
+      Page page = Page.values()[position];
+      if (page == Page.SMALL) {
+        int pageSize = getPageSize(R.dimen.small_photo_side);
+        return FlickrPhotoGrid.newInstance(pageSize, 15, false /*thumbnail*/);
+      } else if (page == Page.MEDIUM) {
+        int pageSize = getPageSize(R.dimen.medium_photo_side);
+        return FlickrPhotoGrid.newInstance(pageSize, 10, true /*thumbnail*/);
+      } else if (page == Page.LIST) {
+        return FlickrPhotoList.newInstance();
+      } else {
+        throw new IllegalArgumentException("No fragment class for page=" + page);
+      }
+    }
 
-        @Override
-        public int getCount() {
-            return Page.values().length;
-        }
+    private int getPageSize(int id) {
+      return getResources().getDimensionPixelSize(id);
+    }
+  }
 
-        private Fragment pageToFragment(int position) {
-            Page page = Page.values()[position];
-            if (page == Page.SMALL) {
-                int pageSize = getPageSize(R.dimen.small_photo_side);
-                return FlickrPhotoGrid.newInstance(pageSize, 30, false /*thumbnail*/);
-            } else if (page == Page.MEDIUM) {
-                int pageSize = getPageSize(R.dimen.medium_photo_side);
-                return FlickrPhotoGrid.newInstance(pageSize, 10, true /*thumbnail*/);
-            } else if (page == Page.LIST) {
-                return FlickrPhotoList.newInstance();
-            } else {
-                throw new IllegalArgumentException("No fragment class for page=" + page);
-            }
-        }
+  private static class BackgroundThumbnailFetcher implements Runnable {
+    private boolean isCancelled;
+    private Context context;
+    private List<Photo> photos;
 
-        private int getPageSize(int id) {
-            return getResources().getDimensionPixelSize(id);
-        }
+    public BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
+      this.context = context;
+      this.photos = photos;
     }
 
-    private static class BackgroundThumbnailFetcher implements Runnable {
-        private boolean isCancelled;
-        private Context context;
-        private List<Photo> photos;
-
-        public BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
-            this.context = context;
-            this.photos = photos;
-        }
+    public void cancel() {
+      isCancelled = true;
+    }
 
-        public void cancel() {
-            isCancelled = true;
+    @Override
+    public void run() {
+      Process.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
+      for (Photo photo : photos) {
+        if (isCancelled) {
+          return;
         }
 
-        @Override
-        public void run() {
-            Process.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
-            for (Photo photo : photos) {
-                if (isCancelled) {
-                    return;
-                }
-
-                FutureTarget<File> futureTarget = Glide.with(context)
-                        .load(photo)
-                        .downloadOnly(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
-
-                try {
-                    futureTarget.get();
-                } catch (InterruptedException e) {
-                    if (Log.isLoggable(TAG, Log.DEBUG)) {
-                        Log.d(TAG, "Interrupted waiting for background downloadOnly", e);
-                    }
-                } catch (ExecutionException e) {
-                    if (Log.isLoggable(TAG, Log.DEBUG)) {
-                        Log.d(TAG, "Got ExecutionException waiting for background downloadOnly", e);
-                    }
-                }
-                Glide.clear(futureTarget);
-            }
-
+        FutureTarget<File> futureTarget = Glide.with(context)
+            .downloadOnly()
+            .load(photo)
+            .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
+
+        try {
+          futureTarget.get();
+        } catch (InterruptedException e) {
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Interrupted waiting for background downloadOnly", e);
+          }
+        } catch (ExecutionException e) {
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Got ExecutionException waiting for background downloadOnly", e);
+          }
         }
+        Glide.with(context).clear(futureTarget);
+      }
     }
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index 58087bec1..ab474658f 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.samples.flickr;
 
+
+import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
+
 import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
@@ -13,23 +16,24 @@
  * A simple activity for viewing a single photo.
  */
 public class FullscreenActivity extends FragmentActivity {
-    private static final String ARG_PHOTO = "photo";
-
-    public static Intent getIntent(Context context, Photo photo) {
-        Intent intent = new Intent(context, FullscreenActivity.class);
-        intent.putExtra(ARG_PHOTO, photo);
-        return intent;
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.fullscreen_activity);
-        ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);
-        Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);
-        Glide.with(this)
-                .load(photo)
-                .fitCenter()
-                .into(fullscreenView);
-    }
+  private static final String ARG_PHOTO = "photo";
+
+  public static Intent getIntent(Context context, Photo photo) {
+    Intent intent = new Intent(context, FullscreenActivity.class);
+    intent.putExtra(ARG_PHOTO, photo);
+    return intent;
+  }
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.fullscreen_activity);
+    ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);
+    Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);
+
+    Glide.with(this)
+        .load(photo)
+        .apply(fitCenterTransform(this))
+        .into(fullscreenView);
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
index 1dca45142..b91230272 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
@@ -5,13 +5,14 @@
 import java.util.List;
 
 /**
- * An interface for an object that displays {@link com.bumptech.glide.samples.flickr.api.Photo} objects.
+ * An interface for an object that displays {@link com.bumptech.glide.samples.flickr.api.Photo}
+ * objects.
  */
 public interface PhotoViewer {
-    /**
-     * Called whenever new {@link com.bumptech.glide.samples.flickr.api.Photo}s are loaded.
-     *
-     * @param photos The loaded photos.
-     */
-    public void onPhotosUpdated(List<Photo> photos);
+  /**
+   * Called whenever new {@link com.bumptech.glide.samples.flickr.api.Photo}s are loaded.
+   *
+   * @param photos The loaded photos.
+   */
+  public void onPhotosUpdated(List<Photo> photos);
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
new file mode 100644
index 000000000..1560cf82e
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.samples.flickr;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.widget.ImageView;
+
+/**
+ * An always square {@link ImageView}.
+ */
+public final class SquareImageView extends ImageView {
+
+  public SquareImageView(Context context) {
+    super(context);
+  }
+
+  public SquareImageView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+  }
+
+  public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {
+    super(context, attrs, defStyleAttr);
+  }
+
+  @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+  public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
+    super(context, attrs, defStyleAttr, defStyleRes);
+  }
+
+  @Override
+  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    super.onMeasure(widthMeasureSpec, widthMeasureSpec);
+  }
+}
+
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index 8d32281df..e31424079 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -1,21 +1,14 @@
 package com.bumptech.glide.samples.flickr.api;
 
 import android.content.Context;
-import android.text.TextUtils;
-import android.util.Log;
 import android.util.SparseArray;
 
 import com.android.volley.DefaultRetryPolicy;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
-import com.android.volley.Response;
-import com.android.volley.VolleyError;
 import com.android.volley.toolbox.StringRequest;
 import com.android.volley.toolbox.Volley;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
+import com.bumptech.glide.util.LruCache;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -27,165 +20,219 @@
  * A class for interfacing with Flickr's http API.
  */
 public class Api {
-    private static Api api;
-    private static final String TAG = "FlickrApi";
-    private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
-    private static final String SIGNED_API_URL = "https://api.flickr.com/services/rest/?method=%s&format=json&api_key="
-            + API_KEY;
-    //incomplete size independent url for photos that can be cached per photo
-    private static final String CACHEABLE_PHOTO_URL = "http://farm%s.staticflickr.com/%s/%s_%s_";
-
-    private static final SparseArray<String> EDGE_TO_SIZE_KEY = new SparseArray<String>() { {
-        put(75, "s");
-        put(100, "t");
-        put(150, "q");
-        put(240, "m");
-        put(320, "n");
-        put(640, "z");
-        put(1024, "b");
-    } };
-    private static final List<Integer> SORTED_SIZE_KEYS = new ArrayList<Integer>(EDGE_TO_SIZE_KEY.size());
-    static {
-        for (int i = 0; i < EDGE_TO_SIZE_KEY.size(); i++) {
-            SORTED_SIZE_KEYS.add(EDGE_TO_SIZE_KEY.keyAt(i));
-        }
-        Collections.sort(SORTED_SIZE_KEYS);
+  private static Api api;
+  private static final String TAG = "FlickrApi";
+  private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
+  private static final String SIGNED_API_URL =
+      "https://api.flickr.com/services/rest/?method=%s&format=json&api_key=" + API_KEY;
+  // Incomplete size independent url for photos that can be cached per photo
+  private static final String CACHEABLE_PHOTO_URL = "http://farm%s.staticflickr.com/%s/%s_%s_";
+  private static final int MAX_URLS_TO_CACHE = 2000;
+  private static final LruCache<UrlCacheKey, String> CACHED_URLS =
+      new LruCache<>(MAX_URLS_TO_CACHE);
+  private static final int MAX_ITEMS_PER_PAGE = 300;
+  private static final String PER_PAGE = "&per_page=" + MAX_ITEMS_PER_PAGE;
+
+  private static final SparseArray<String> EDGE_TO_SIZE_KEY = new SparseArray<String>() {
+    {
+      put(75, "s");
+      put(100, "t");
+      put(150, "q");
+      put(240, "m");
+      put(320, "n");
+      put(640, "z");
+      put(1024, "b");
+    }
+  };
+  private static final List<Integer> SORTED_SIZE_KEYS =
+      new ArrayList<>(EDGE_TO_SIZE_KEY.size());
+
+
+  static {
+    for (int i = 0; i < EDGE_TO_SIZE_KEY.size(); i++) {
+      SORTED_SIZE_KEYS.add(EDGE_TO_SIZE_KEY.keyAt(i));
     }
+    Collections.sort(SORTED_SIZE_KEYS);
+  }
 
-    public static final int SQUARE_THUMB_SIZE = SORTED_SIZE_KEYS.get(0);
+  public static final int SQUARE_THUMB_SIZE = SORTED_SIZE_KEYS.get(0);
 
-    private static String getSizeKey(int width, int height) {
-        final int largestEdge = Math.max(width, height);
+  private static String getSizeKey(int width, int height) {
+    final int largestEdge = Math.max(width, height);
 
-        String result = EDGE_TO_SIZE_KEY.get(SORTED_SIZE_KEYS.get(SORTED_SIZE_KEYS.size() - 1));
-        for (int edge : SORTED_SIZE_KEYS) {
-            if (largestEdge <= edge) {
-                result = EDGE_TO_SIZE_KEY.get(edge);
-                break;
-            }
+    String result = EDGE_TO_SIZE_KEY.get(SORTED_SIZE_KEYS.get(SORTED_SIZE_KEYS.size() - 1));
+    for (int edge : SORTED_SIZE_KEYS) {
+      if (largestEdge <= edge) {
+        result = EDGE_TO_SIZE_KEY.get(edge);
+        break;
+      }
+    }
+    return result;
+  }
+
+  private static List<String> getLargerSizeKeys(int width, int height) {
+    final int largestEdge = Math.max(width, height);
+
+    boolean isFirstLargest = true;
+    List<String> result = new ArrayList<>();
+    for (int edge : SORTED_SIZE_KEYS) {
+      if (largestEdge <= edge) {
+        if (isFirstLargest) {
+          isFirstLargest = false;
+        } else {
+          result.add(EDGE_TO_SIZE_KEY.get(edge));
         }
-        return result;
+      }
     }
+    return result;
 
-    public static String getCacheableUrl(Photo photo) {
-        return String.format(CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(), photo.getSecret());
-    }
+  }
 
-    public static String getPhotoURL(Photo photo, int width, int height) {
-        return getPhotoUrl(photo, getSizeKey(width, height));
-    }
+  public static String getCacheableUrl(Photo photo) {
+    return String.format(CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(),
+        photo.getSecret());
+  }
 
-    private static String getUrlForMethod(String method) {
-        return String.format(SIGNED_API_URL, method);
-    }
+  public static String getPhotoURL(Photo photo, int width, int height) {
+    return getPhotoUrl(photo, getSizeKey(width, height));
+  }
 
-    private static String getSearchUrl(String text) {
-        return getUrlForMethod("flickr.photos.search") + "&text=" + text + "&per_page=300";
+  public static List<String> getAlternateUrls(Photo photo, int width, int height) {
+    List<String> result = new ArrayList<>();
+    for (String sizeKey : getLargerSizeKeys(width, height)) {
+      result.add(getPhotoUrl(photo, sizeKey));
     }
-
-    private static String getPhotoUrl(Photo photo, String sizeKey) {
-        return photo.getPartialUrl() + sizeKey + ".jpg";
+    return result;
+  }
+
+  private static String getUrlForMethod(String method) {
+    return String.format(SIGNED_API_URL, method);
+  }
+
+  private static String getPhotoUrl(Photo photo, String sizeKey) {
+    UrlCacheKey entry = new UrlCacheKey(photo, sizeKey);
+    String result = CACHED_URLS.get(entry);
+    if (result == null) {
+      result = photo.getPartialUrl() + sizeKey + ".jpg";
+      CACHED_URLS.put(entry, result);
     }
+    return result;
+  }
+
+  static String getSearchUrl(String text) {
+    return getUrlForMethod("flickr.photos.search") + "&text=" + text + PER_PAGE;
+  }
+
+  static String getRecentUrl() {
+    return getUrlForMethod("flickr.photos.getRecent" + PER_PAGE);
+  }
 
+  /**
+   * An interface for listening for search results from the Flickr API.
+   */
+  public interface QueryListener {
     /**
-     * An interface for listening for search results from the Flickr API.
+     * Called when a search completes successfully.
+     *
+     * @param query  The query used to obtain the results.
+     * @param photos A list of images that were found for the given search term.
      */
-    public interface SearchListener {
-        /**
-         * Called when a search completes successfully.
-         *
-         * @param searchString The term that was searched for.
-         * @param photos A list of images that were found for the given search term.
-         */
-        public void onSearchCompleted(String searchString, List<Photo> photos);
-
-        /**
-         * Called when a search fails.
-         *
-         * @param searchString The term that was searched for.
-         * @param e The exception that caused the search to fail.
-         */
-        public void onSearchFailed(String searchString, Exception e);
-    }
-
-    public static Api get(Context context) {
-        if (api == null) {
-            api = new Api(context);
-        }
-        return api;
-    }
+    void onSearchCompleted(Query query, List<Photo> photos);
 
-    private final RequestQueue requestQueue;
-    private final Set<SearchListener> searchListeners = new HashSet<SearchListener>();
-    private SearchResult lastSearchResult;
+    /**
+     * Called when a search fails.
+     *
+     * @param query The query we attempted to obtain results for.
+     * @param e     The exception that caused the search to fail.
+     */
+    void onSearchFailed(Query query, Exception e);
+  }
 
-    protected Api(Context context) {
-        this.requestQueue = Volley.newRequestQueue(context.getApplicationContext());
+  public static Api get(Context context) {
+    if (api == null) {
+      api = new Api(context);
     }
-
-    public void registerSearchListener(SearchListener searchListener) {
-        searchListeners.add(searchListener);
+    return api;
+  }
+
+  private final RequestQueue requestQueue;
+  private final Set<QueryListener> queryListeners = new HashSet<QueryListener>();
+  private QueryResult lastQueryResult;
+
+  protected Api(Context context) {
+    this.requestQueue = Volley.newRequestQueue(context.getApplicationContext());
+    QueryListener queryListener = new QueryListener() {
+      @Override
+      public void onSearchCompleted(Query query, List<Photo> photos) {
+        lastQueryResult = new QueryResult(query, photos);
+      }
+
+      @Override
+      public void onSearchFailed(Query query, Exception e) {
+        lastQueryResult = null;
+      }
+    };
+    queryListeners.add(queryListener);
+  }
+
+  public void registerSearchListener(QueryListener queryListener) {
+    queryListeners.add(queryListener);
+  }
+
+  public void unregisterSearchListener(QueryListener queryListener) {
+    queryListeners.remove(queryListener);
+  }
+
+  public void query(Query query) {
+    if (lastQueryResult != null && lastQueryResult.query.equals(query)) {
+      for (QueryListener listener : queryListeners) {
+        listener.onSearchCompleted(lastQueryResult.query, lastQueryResult.results);
+      }
+      return;
     }
 
-    public void unregisterSearchListener(SearchListener searchListener) {
-        searchListeners.remove(searchListener);
+    FlickrQueryResponseListener responseListener
+        = new FlickrQueryResponseListener(new PhotoJsonStringParser(), query, queryListeners);
+    StringRequest request = new StringRequest(Request.Method.GET, query.getUrl(),
+        responseListener, responseListener);
+    request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3,
+        DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
+    requestQueue.add(request);
+  }
+
+  private static class QueryResult {
+    private final Query query;
+    private final List<Photo> results;
+
+    public QueryResult(Query query, List<Photo> results) {
+      this.query = query;
+      this.results = results;
     }
+  }
 
-    public void search(final String text) {
-        if (lastSearchResult != null && TextUtils.equals(lastSearchResult.searchString, text)) {
-            for (SearchListener listener : searchListeners) {
-                listener.onSearchCompleted(lastSearchResult.searchString, lastSearchResult.results);
-            }
-            return;
-        }
+  private static final class UrlCacheKey {
+    private final Photo photo;
+    private final String sizeKey;
 
-        StringRequest request = new StringRequest(Request.Method.GET, getSearchUrl(text),
-                new Response.Listener<String>() {
-            @Override
-            public void onResponse(String response) {
-                try {
-                    //cut out initial flickJsonApi(
-                    JSONObject searchResults = new JSONObject(response.substring(14, response.length() - 1));
-                    JSONArray photos = searchResults.getJSONObject("photos").getJSONArray("photo");
-                    List<Photo> results = new ArrayList<Photo>(photos.length());
-                    for (int i = 0; i < photos.length(); i++) {
-                        results.add(new Photo(photos.getJSONObject(i)));
-                    }
-                    lastSearchResult = new SearchResult(text, results);
-                    for (SearchListener listener : searchListeners) {
-                        listener.onSearchCompleted(text, results);
-                    }
-                } catch (JSONException e) {
-                    for (SearchListener listener : searchListeners) {
-                        listener.onSearchFailed(text, e);
-                    }
-                    if (Log.isLoggable(TAG, Log.ERROR)) {
-                        Log.e(TAG, "Search failed response=" + response, e);
-                    }
-                }
-            }
-        }, new Response.ErrorListener() {
-            @Override
-            public void onErrorResponse(VolleyError error) {
-                for (SearchListener listener : searchListeners) {
-                    listener.onSearchFailed(text, error);
-                }
-            }
-        });
-        request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3,
-                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
-        requestQueue.add(request);
+    private UrlCacheKey(Photo photo, String sizeKey) {
+      this.photo = photo;
+      this.sizeKey = sizeKey;
     }
 
-    private static class SearchResult {
-        private final String searchString;
-        private final List<Photo> results;
-
-        public SearchResult(String searchString, List<Photo> results) {
-
-            this.searchString = searchString;
-            this.results = results;
-        }
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof UrlCacheKey) {
+        UrlCacheKey other = (UrlCacheKey) o;
+        return photo.equals(other.photo) && sizeKey.equals(other.sizeKey);
+      }
+      return false;
+    }
 
+    @Override
+    public int hashCode() {
+      int result = photo.hashCode();
+      result = 31 * result + sizeKey.hashCode();
+      return result;
     }
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
new file mode 100644
index 000000000..cdc081bf3
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import com.android.volley.Response;
+import com.android.volley.VolleyError;
+
+import org.json.JSONException;
+
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * Handles photo list responses and errors from Flickr API calls.
+ */
+final class FlickrQueryResponseListener implements Response.Listener<String>,
+    Response.ErrorListener {
+  private final PhotoJsonStringParser parser;
+  private final Query query;
+  private final Collection<Api.QueryListener> listeners;
+
+  FlickrQueryResponseListener(PhotoJsonStringParser parser, Query query,
+      Collection<Api.QueryListener> listeners) {
+    this.parser = parser;
+    this.query = query;
+    this.listeners = listeners;
+  }
+
+  @Override
+  public void onResponse(String response) {
+    try {
+      notifySuccess(parser.parse(response));
+    } catch (JSONException e) {
+      notifyFailed(e);
+    }
+  }
+
+  @Override
+  public void onErrorResponse(VolleyError error) {
+    notifyFailed(error);
+  }
+
+  private void notifySuccess(List<Photo> results) {
+    for (Api.QueryListener listener : listeners) {
+      listener.onSearchCompleted(query, results);
+    }
+  }
+
+  private void notifyFailed(Exception e) {
+    for (Api.QueryListener listener : listeners) {
+      listener.onSearchFailed(query, e);
+    }
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index f015fc355..36cb19ab6 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -10,133 +10,133 @@
  * A POJO representing a JSON object returned from Flickr's api representing a single image.
  */
 public class Photo implements Parcelable {
-    public static final Creator<Photo> CREATOR = new Creator<Photo>() {
-        @Override
-        public Photo createFromParcel(Parcel parcel) {
-            return new Photo(parcel);
-        }
-
-        @Override
-        public Photo[] newArray(int i) {
-            return new Photo[i];
-        }
-    };
-
-    private final String id;
-    private final String owner;
-    private final String title;
-    private final String server;
-    private final String farm;
-    private final String secret;
-    private String partialUrl = null;
-
-
-    public Photo(JSONObject jsonPhoto) throws JSONException {
-        this.id = jsonPhoto.getString("id");
-        this.owner = jsonPhoto.getString("owner");
-        this.title = jsonPhoto.optString("title", "");
-        this.server = jsonPhoto.getString("server");
-        this.farm = jsonPhoto.getString("farm");
-        this.secret = jsonPhoto.getString("secret");
-    }
-
-    private Photo(Parcel in) {
-        id = in.readString();
-        owner = in.readString();
-        title = in.readString();
-        server = in.readString();
-        farm = in.readString();
-        secret = in.readString();
+  public static final Creator<Photo> CREATOR = new Creator<Photo>() {
+    @Override
+    public Photo createFromParcel(Parcel parcel) {
+      return new Photo(parcel);
     }
 
     @Override
-    public void writeToParcel(Parcel parcel, int i) {
-        parcel.writeString(id);
-        parcel.writeString(owner);
-        parcel.writeString(title);
-        parcel.writeString(server);
-        parcel.writeString(farm);
-        parcel.writeString(secret);
+    public Photo[] newArray(int i) {
+      return new Photo[i];
     }
-
-    public String getPartialUrl() {
-        if (partialUrl == null) {
-            partialUrl = Api.getCacheableUrl(this);
-        }
-        return partialUrl;
+  };
+
+  private final String id;
+  private final String owner;
+  private final String title;
+  private final String server;
+  private final String farm;
+  private final String secret;
+  private String partialUrl = null;
+
+
+  public Photo(JSONObject jsonPhoto) throws JSONException {
+    this.id = jsonPhoto.getString("id");
+    this.owner = jsonPhoto.getString("owner");
+    this.title = jsonPhoto.optString("title", "");
+    this.server = jsonPhoto.getString("server");
+    this.farm = jsonPhoto.getString("farm");
+    this.secret = jsonPhoto.getString("secret");
+  }
+
+  private Photo(Parcel in) {
+    id = in.readString();
+    owner = in.readString();
+    title = in.readString();
+    server = in.readString();
+    farm = in.readString();
+    secret = in.readString();
+  }
+
+  @Override
+  public void writeToParcel(Parcel parcel, int i) {
+    parcel.writeString(id);
+    parcel.writeString(owner);
+    parcel.writeString(title);
+    parcel.writeString(server);
+    parcel.writeString(farm);
+    parcel.writeString(secret);
+  }
+
+  public String getPartialUrl() {
+    if (partialUrl == null) {
+      partialUrl = Api.getCacheableUrl(this);
     }
-
-    public String getId() {
-        return id;
+    return partialUrl;
+  }
+
+  public String getId() {
+    return id;
+  }
+
+  public String getTitle() {
+    return title;
+  }
+
+  public String getServer() {
+    return server;
+  }
+
+  public String getFarm() {
+    return farm;
+  }
+
+  public String getSecret() {
+    return secret;
+  }
+
+  @Override
+  public String toString() {
+    return getPartialUrl();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
     }
-
-    public String getTitle() {
-        return title;
+    if (o == null || getClass() != o.getClass()) {
+      return false;
     }
 
-    public String getServer() {
-        return server;
-    }
+    Photo photo = (Photo) o;
 
-    public String getFarm() {
-        return farm;
+    if (!farm.equals(photo.farm)) {
+      return false;
     }
-
-    public String getSecret() {
-        return secret;
+    if (!id.equals(photo.id)) {
+      return false;
     }
-
-    @Override
-    public String toString() {
-        return getPartialUrl();
+    if (!owner.equals(photo.owner)) {
+      return false;
     }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
-
-        Photo photo = (Photo) o;
-
-        if (!farm.equals(photo.farm)) {
-            return false;
-        }
-        if (!id.equals(photo.id)) {
-            return false;
-        }
-        if (!owner.equals(photo.owner)) {
-            return false;
-        }
-        if (!secret.equals(photo.secret)) {
-            return false;
-        }
-        if (!server.equals(photo.server)) {
-            return false;
-        }
-        if (!title.equals(photo.title)) {
-            return false;
-        }
-
-        return true;
+    if (!secret.equals(photo.secret)) {
+      return false;
     }
-
-    @Override
-    public int hashCode() {
-        int result = id.hashCode();
-        result = 31 * result + owner.hashCode();
-        result = 31 * result + title.hashCode();
-        result = 31 * result + server.hashCode();
-        result = 31 * result + farm.hashCode();
-        result = 31 * result + secret.hashCode();
-        return result;
+    if (!server.equals(photo.server)) {
+      return false;
     }
-
-    @Override
-    public int describeContents() {
-        return 0;
+    if (!title.equals(photo.title)) {
+      return false;
     }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = id.hashCode();
+    result = 31 * result + owner.hashCode();
+    result = 31 * result + title.hashCode();
+    result = 31 * result + server.hashCode();
+    result = 31 * result + farm.hashCode();
+    result = 31 * result + secret.hashCode();
+    return result;
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
new file mode 100644
index 000000000..50522b63e
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Parses a list of {@link Photo} objects from a Flickr API response string containing JSON data.
+ */
+final class PhotoJsonStringParser {
+  private static final int FLICKR_API_PREFIX_LENGTH = 14;
+
+  List<Photo> parse(String response) throws JSONException {
+    JSONObject searchResults =
+        new JSONObject(response.substring(FLICKR_API_PREFIX_LENGTH, response.length() - 1));
+    JSONArray photos = searchResults.getJSONObject("photos").getJSONArray("photo");
+    List<Photo> results = new ArrayList<>(photos.length());
+    for (int i = 0, size = photos.length(); i < size; i++) {
+      results.add(new Photo(photos.getJSONObject(i)));
+    }
+
+    return results;
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Query.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Query.java
new file mode 100644
index 000000000..877f5aa14
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Query.java
@@ -0,0 +1,11 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import android.os.Parcelable;
+
+/** An interface representing a query in Flickr's API that returns a list of photos. */
+public interface Query extends Parcelable {
+  /** A user facing description of the query. */
+  String getDescription();
+  /** The url to use to execute the query. */
+  String getUrl();
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
new file mode 100644
index 000000000..b3442f26b
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
@@ -0,0 +1,45 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import android.os.Parcel;
+
+/** Query wusing flickr's recent API. */
+public final class RecentQuery implements Query {
+  public static final Creator<RecentQuery> CREATOR = new Creator<RecentQuery>() {
+    @Override
+    public RecentQuery createFromParcel(Parcel source) {
+      return RECENT_QUERY;
+    }
+
+    @Override
+    public RecentQuery[] newArray(int size) {
+      return new RecentQuery[size];
+    }
+  };
+  private static final RecentQuery RECENT_QUERY = new RecentQuery();
+
+  public static RecentQuery get() {
+    return RECENT_QUERY;
+  }
+
+  private RecentQuery() {
+    // Singleton.
+  }
+
+  @Override
+  public String getDescription() {
+    return "Recent";
+  }
+
+  @Override
+  public String getUrl() {
+    return Api.getRecentUrl();
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) { }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
new file mode 100644
index 000000000..0d36aaf24
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
@@ -0,0 +1,62 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import android.os.Parcel;
+
+/** Wraps a search query string. */
+public final class SearchQuery implements Query {
+  public static final Creator<SearchQuery> CREATOR = new Creator<SearchQuery>() {
+    @Override
+    public SearchQuery createFromParcel(Parcel source) {
+      return new SearchQuery(source);
+    }
+
+    @Override
+    public SearchQuery[] newArray(int size) {
+      return new SearchQuery[size];
+    }
+  };
+
+  private final String queryString;
+
+  public SearchQuery(String queryString) {
+    this.queryString = queryString;
+  }
+
+  private SearchQuery(Parcel in) {
+    queryString = in.readString();
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(queryString);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public String getDescription() {
+    return queryString;
+  }
+
+  @Override
+  public String getUrl() {
+    return Api.getSearchUrl(queryString);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof SearchQuery) {
+      SearchQuery other = (SearchQuery) o;
+      return queryString.equals(other.queryString);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return queryString.hashCode();
+  }
+}
diff --git a/samples/flickr/src/main/res/anim/fade_in.xml b/samples/flickr/src/main/res/anim/fade_in.xml
deleted file mode 100644
index 15ffe1739..000000000
--- a/samples/flickr/src/main/res/anim/fade_in.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<alpha xmlns:android="http://schemas.android.com/apk/res/android"
-	android:interpolator="@android:anim/linear_interpolator"
-	android:fromAlpha="0.0"
-	android:toAlpha="1.0"
-	android:duration="150"
-/>
-
diff --git a/samples/flickr/src/main/res/drawable-hdpi/ic_launcher.png b/samples/flickr/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 96a442e5b..000000000
Binary files a/samples/flickr/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/flickr/src/main/res/drawable-ldpi/ic_launcher.png b/samples/flickr/src/main/res/drawable-ldpi/ic_launcher.png
deleted file mode 100644
index 99238729d..000000000
Binary files a/samples/flickr/src/main/res/drawable-ldpi/ic_launcher.png and /dev/null differ
diff --git a/samples/flickr/src/main/res/drawable-mdpi/ic_launcher.png b/samples/flickr/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index 359047dfa..000000000
Binary files a/samples/flickr/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/flickr/src/main/res/drawable-xhdpi/ic_launcher.png b/samples/flickr/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 71c6d760f..000000000
Binary files a/samples/flickr/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_grid.xml b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
index 6fb72e221..dd069be64 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
@@ -1,14 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-<GridView xmlns:android="http://schemas.android.com/apk/res/android"
-  android:id="@+id/images"
-  android:cacheColorHint="#00000000"
-  android:fadingEdge="none"
-  android:scrollingCache="false"
-  android:numColumns="auto_fit"
-  android:horizontalSpacing="10dp"
-  android:verticalSpacing="10dp"
-  android:gravity="center"
-  android:layout_gravity="center"
-  android:stretchMode="columnWidth"
-  android:layout_width="fill_parent"
-  android:layout_height="fill_parent" />
+<android.support.v7.widget.RecyclerView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingTop="10dp"
+    android:id="@+id/flickr_photo_grid" />
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
index 2b6e2223c..5a53ad9fd 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-
-<ImageView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:scaleType="centerCrop"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:contentDescription="@string/image_description" />
+<com.bumptech.glide.samples.flickr.SquareImageView
+       xmlns:android="http://schemas.android.com/apk/res/android"
+       android:scaleType="centerCrop"
+       android:layout_width="fill_parent"
+       android:layout_height="fill_parent"
+       android:contentDescription="@string/image_description"/>
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_list.xml b/samples/flickr/src/main/res/layout/flickr_photo_list.xml
index b84429318..13723e059 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_list.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_list.xml
@@ -1,10 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-
-<ListView xmlns:android="http://schemas.android.com/apk/res/android"
-  android:id="@+id/flickr_photo_list"
-  android:layout_width="fill_parent"
-  android:layout_height="fill_parent"
-  android:cacheColorHint="#00000000"
-  android:scrollingCache="false">
-</ListView>
+<android.support.v7.widget.RecyclerView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:id="@+id/flickr_photo_list" />
 
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_list_item.xml b/samples/flickr/src/main/res/layout/flickr_photo_list_item.xml
index b2b9e27f7..8c5bc8cb6 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_list_item.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_list_item.xml
@@ -1,23 +1,25 @@
 <?xml version="1.0" encoding="utf-8"?>
 
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-  android:orientation="horizontal"
-  android:layout_width="fill_parent"
-  android:layout_height="@dimen/flickr_list_item_height"
-  android:padding="10dp">
-  <ImageView
-    android:id="@+id/photo_view"
-    android:layout_width="0dp"
-    android:layout_height="fill_parent"
-    android:layout_weight="1"
-    android:scaleType="centerCrop"
-    android:contentDescription="@string/image_description" />
-  <TextView
-    android:id="@+id/title_view"
-    android:layout_width="0dp"
-    android:layout_height="fill_parent"
-    android:layout_weight="1"
-    android:layout_margin="10dp"
-    android:gravity="center"
-    android:textSize="16sp"/>
-</LinearLayout>
\ No newline at end of file
+              android:orientation="horizontal"
+              android:layout_width="fill_parent"
+              android:layout_height="@dimen/flickr_list_item_height"
+              android:padding="10dp">
+
+    <ImageView
+        android:id="@+id/photo_view"
+        android:layout_width="0dp"
+        android:layout_height="fill_parent"
+        android:layout_weight="1"
+        android:scaleType="centerCrop"
+        android:contentDescription="@string/image_description"/>
+
+    <TextView
+        android:id="@+id/title_view"
+        android:layout_width="0dp"
+        android:layout_height="fill_parent"
+        android:layout_weight="1"
+        android:layout_margin="10dp"
+        android:gravity="center"
+        android:textSize="16sp"/>
+</LinearLayout>
diff --git a/samples/flickr/src/main/res/layout/flickr_search_activity.xml b/samples/flickr/src/main/res/layout/flickr_search_activity.xml
index 2572dbabf..a4b216c7e 100644
--- a/samples/flickr/src/main/res/layout/flickr_search_activity.xml
+++ b/samples/flickr/src/main/res/layout/flickr_search_activity.xml
@@ -1,41 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
 <merge xmlns:android="http://schemas.android.com/apk/res/android">
-  <LinearLayout
-    android:orientation="vertical"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent">
-    <LinearLayout
-      android:layout_width="fill_parent"
-      android:layout_height="wrap_content"
-      android:layout_margin="10dp"
-      android:orientation="horizontal">
-      <EditText
-        android:id="@+id/search_text"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:layout_marginRight="10dp"
-        android:layout_weight="1"
-        android:cursorVisible="true"
-        android:textSize="16sp"
-        android:singleLine="true"
-        android:inputType="text"
-        android:imeOptions="actionSearch" />
-      <Button
-        android:id="@+id/search"
-        android:layout_width="wrap_content"
-        android:minWidth="50dp"
-        android:layout_height="40dp"
-        android:text="@string/search" />
-    </LinearLayout>
-    <FrameLayout
-      android:layout_width="fill_parent"
-      android:layout_height="0dp"
-      android:layout_weight="1">
-      <android.support.v4.view.ViewPager
+
+    <android.support.v4.view.ViewPager
         android:id="@+id/view_pager"
         android:layout_width="fill_parent"
-        android:layout_height="fill_parent" />
-      <LinearLayout
+        android:layout_height="fill_parent">
+
+        <android.support.v4.view.PagerTabStrip
+                android:id="@+id/pager_tab_strip"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_gravity="top" />
+
+    </android.support.v4.view.ViewPager>
+
+    <LinearLayout
         android:id="@+id/searching"
         android:layout_width="fill_parent"
         android:layout_height="fill_parent"
@@ -44,20 +23,19 @@
         android:layout_gravity="center"
         android:gravity="center"
         android:orientation="vertical">
+
         <TextView
-          android:id="@+id/search_term"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:gravity="center"
-          android:textSize="16sp"
-          android:layout_marginBottom="10dp"/>
+            android:id="@+id/search_term"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:gravity="center"
+            android:textSize="16sp"
+            android:layout_marginBottom="10dp"/>
+
         <ProgressBar
-          android:id="@+id/search_loading"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:indeterminate="true" />
-      </LinearLayout>
-    </FrameLayout>
-  </LinearLayout>
+            android:id="@+id/search_loading"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:indeterminate="true"/>
+    </LinearLayout>
 </merge>
-
diff --git a/samples/flickr/src/main/res/layout/fullscreen_activity.xml b/samples/flickr/src/main/res/layout/fullscreen_activity.xml
index d4523c18a..9a70b0655 100644
--- a/samples/flickr/src/main/res/layout/fullscreen_activity.xml
+++ b/samples/flickr/src/main/res/layout/fullscreen_activity.xml
@@ -2,4 +2,6 @@
 <ImageView xmlns:android="http://schemas.android.com/apk/res/android"
            android:id="@+id/fullscreen_view"
            android:layout_width="match_parent"
-           android:layout_height="match_parent" />
+           android:layout_height="match_parent"
+           android:contentDescription="@string/fullscreen_description"
+           />
diff --git a/samples/flickr/src/main/res/menu/search_activity.xml b/samples/flickr/src/main/res/menu/search_activity.xml
new file mode 100644
index 000000000..23c1dfa0a
--- /dev/null
+++ b/samples/flickr/src/main/res/menu/search_activity.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto">
+<item android:id="@+id/search"
+      android:title="@string/search"
+      android:icon="@android:drawable/ic_menu_search"
+      app:showAsAction="collapseActionView|ifRoom"
+      app:actionViewClass="android.widget.SearchView" />
+</menu>
diff --git a/samples/flickr/src/main/res/values/colors.xml b/samples/flickr/src/main/res/values/colors.xml
index c29689367..c9e3de8f5 100644
--- a/samples/flickr/src/main/res/values/colors.xml
+++ b/samples/flickr/src/main/res/values/colors.xml
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-  <color name="translucent_black">#B0000000</color>
-</resources>
\ No newline at end of file
+    <color name="translucent_black">#B0000000</color>
+</resources>
diff --git a/samples/flickr/src/main/res/values/dimens.xml b/samples/flickr/src/main/res/values/dimens.xml
index 5fa6e89fd..0f5cf0099 100644
--- a/samples/flickr/src/main/res/values/dimens.xml
+++ b/samples/flickr/src/main/res/values/dimens.xml
@@ -1,6 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-  <dimen name="medium_photo_side">110dp</dimen>
-  <dimen name="small_photo_side">55dp</dimen>
-  <dimen name="flickr_list_item_height">170dp</dimen>
-</resources>
\ No newline at end of file
+    <dimen name="medium_photo_side">110dp</dimen>
+    <dimen name="small_photo_side">55dp</dimen>
+    <dimen name="flickr_list_item_height">170dp</dimen>
+    <dimen name="grid_margin">5dp</dimen>
+    <dimen name="page_margin">8dp</dimen>
+</resources>
+
diff --git a/samples/flickr/src/main/res/values/strings.xml b/samples/flickr/src/main/res/values/strings.xml
index bd4f925ab..18cb322e1 100644
--- a/samples/flickr/src/main/res/values/strings.xml
+++ b/samples/flickr/src/main/res/values/strings.xml
@@ -8,4 +8,5 @@
   <string name="medium">Medium</string>
   <string name="list">List</string>
   <string name="image_description">An image from the list of results for a search query</string>
+  <string name="fullscreen_description">Full screen view of an image</string>
 </resources>
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
new file mode 100644
index 000000000..30b337cf4
--- /dev/null
+++ b/samples/gallery/build.gradle
@@ -0,0 +1,33 @@
+apply plugin: 'com.android.application'
+
+dependencies {
+    compile project(':library')
+    compile(project(':integration:recyclerview')) {
+        transitive = false
+    }
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.samples.gallery'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionCode 1
+        versionName "1.0"
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+task run(type: Exec, dependsOn: 'installDebug') {
+    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.gallery/.MainActivity'
+}
diff --git a/samples/gallery/lint.xml b/samples/gallery/lint.xml
new file mode 100644
index 000000000..5c710c8c7
--- /dev/null
+++ b/samples/gallery/lint.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore"/>
+</lint>
diff --git a/samples/gallery/src/main/AndroidManifest.xml b/samples/gallery/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..7a38c3fb1
--- /dev/null
+++ b/samples/gallery/src/main/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.samples.gallery">
+
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+
+  <uses-sdk
+        android:minSdkVersion="10"
+        android:targetSdkVersion="22" />
+
+  <application
+          android:label="@string/app_name"
+          android:icon="@android:drawable/sym_def_app_icon"
+          android:allowBackup="false">
+    <activity android:name=".MainActivity"
+              android:label="@string/app_name">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
new file mode 100644
index 000000000..35e1376fd
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.samples.gallery;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.content.Loader;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
+
+import java.util.List;
+
+/**
+ * Displays media store data in a recycler view.
+ */
+public class HorizontalGalleryFragment extends Fragment
+    implements LoaderManager.LoaderCallbacks<List<MediaStoreData>> {
+
+  private RecyclerView recyclerView;
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    getLoaderManager().initLoader(R.id.loader_id_media_store_data, null, this);
+  }
+
+  @Override
+  public View onCreateView(LayoutInflater inflater, ViewGroup container,
+      Bundle savedInstanceState) {
+    View result = inflater.inflate(R.layout.recycler_view, container, false);
+    recyclerView = (RecyclerView) result.findViewById(R.id.recycler_view);
+    GridLayoutManager layoutManager = new GridLayoutManager(getActivity(), 1);
+    layoutManager.setOrientation(RecyclerView.HORIZONTAL);
+    recyclerView.setLayoutManager(layoutManager);
+    recyclerView.setHasFixedSize(true);
+
+    return result;
+  }
+
+  @Override
+  public Loader<List<MediaStoreData>> onCreateLoader(int i, Bundle bundle) {
+    return new MediaStoreDataLoader(getActivity());
+  }
+
+  @Override
+  public void onLoadFinished(Loader<List<MediaStoreData>> loader,
+      List<MediaStoreData> mediaStoreData) {
+    RequestManager requestManager = Glide.with(this);
+    RecyclerAdapter adapter =
+        new RecyclerAdapter(getActivity(), mediaStoreData, requestManager);
+    RecyclerViewPreloader<MediaStoreData> preloader =
+        new RecyclerViewPreloader<>(requestManager, adapter, adapter, 3);
+    recyclerView.addOnScrollListener(preloader);
+    recyclerView.setAdapter(adapter);
+  }
+
+  @Override
+  public void onLoaderReset(Loader<List<MediaStoreData>> loader) {
+    // Do nothing.
+  }
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
new file mode 100644
index 000000000..4c7c3e509
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.samples.gallery;
+
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.MemoryCategory;
+
+/**
+ * Displays a {@link HorizontalGalleryFragment}.
+ */
+public class MainActivity extends FragmentActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main_activity);
+        Glide.get(this).setMemoryCategory(MemoryCategory.HIGH);
+    }
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
new file mode 100644
index 000000000..8663eafdd
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
@@ -0,0 +1,88 @@
+package com.bumptech.glide.samples.gallery;
+
+import android.net.Uri;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * A data model containing data for a single media item.
+ */
+public class MediaStoreData implements Parcelable {
+  public static final Creator<MediaStoreData> CREATOR = new Creator<MediaStoreData>() {
+    @Override
+    public MediaStoreData createFromParcel(Parcel parcel) {
+      return new MediaStoreData(parcel);
+    }
+
+    @Override
+    public MediaStoreData[] newArray(int i) {
+      return new MediaStoreData[i];
+    }
+  };
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public final long rowId;
+  public final Uri uri;
+  public final String mimeType;
+  public final long dateModified;
+  public final int orientation;
+  public final Type type;
+  public final long dateTaken;
+
+  public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
+      int orientation, Type type) {
+    this.rowId = rowId;
+    this.uri = uri;
+    this.dateModified = dateModified;
+    this.mimeType = mimeType;
+    this.orientation = orientation;
+    this.type = type;
+    this.dateTaken = dateTaken;
+  }
+
+  MediaStoreData(Parcel in) {
+    rowId = in.readLong();
+    uri = Uri.parse(in.readString());
+    mimeType = in.readString();
+    dateTaken = in.readLong();
+    dateModified = in.readLong();
+    orientation = in.readInt();
+    type = Type.valueOf(in.readString());
+  }
+
+  @Override
+  public void writeToParcel(Parcel parcel, int i) {
+    parcel.writeLong(rowId);
+    parcel.writeString(uri.toString());
+    parcel.writeString(mimeType);
+    parcel.writeLong(dateTaken);
+    parcel.writeLong(dateModified);
+    parcel.writeInt(orientation);
+    parcel.writeString(type.name());
+  }
+
+  @Override
+  public String toString() {
+    return "MediaStoreData{"
+        + "rowId=" + rowId
+        + ", uri=" + uri
+        + ", mimeType='" + mimeType + '\''
+        + ", dateModified=" + dateModified
+        + ", orientation=" + orientation
+        + ", type=" + type
+        + ", dateTaken=" + dateTaken
+        + '}';
+  }
+
+  /**
+   * The type of data.
+   */
+  public enum Type {
+    VIDEO,
+    IMAGE,
+  }
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
new file mode 100644
index 000000000..e8d2bb95c
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
@@ -0,0 +1,166 @@
+package com.bumptech.glide.samples.gallery;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.MediaStore;
+import android.support.v4.content.AsyncTaskLoader;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+
+/**
+ * Loads metadata from the media store for images and videos.
+ */
+public class MediaStoreDataLoader extends AsyncTaskLoader<List<MediaStoreData>> {
+  private static final String[] IMAGE_PROJECTION =
+      new String[] {
+          MediaStore.Images.ImageColumns._ID,
+          MediaStore.Images.ImageColumns.DATE_TAKEN,
+          MediaStore.Images.ImageColumns.DATE_MODIFIED,
+          MediaStore.Images.ImageColumns.MIME_TYPE,
+          MediaStore.Images.ImageColumns.ORIENTATION,
+      };
+
+  private static final String[] VIDEO_PROJECTION =
+      new String[] {
+          MediaStore.Video.VideoColumns._ID,
+          MediaStore.Video.VideoColumns.DATE_TAKEN,
+          MediaStore.Video.VideoColumns.DATE_MODIFIED,
+          MediaStore.Video.VideoColumns.MIME_TYPE,
+          "0 AS " + MediaStore.Images.ImageColumns.ORIENTATION,
+      };
+
+  private List<MediaStoreData> cached;
+  private boolean observerRegistered = false;
+  private final ForceLoadContentObserver forceLoadContentObserver = new ForceLoadContentObserver();
+
+  public MediaStoreDataLoader(Context context) {
+    super(context);
+  }
+
+  @Override
+  public void deliverResult(List<MediaStoreData> data) {
+    if (!isReset() && isStarted()) {
+      super.deliverResult(data);
+    }
+  }
+
+  @Override
+  protected void onStartLoading() {
+    if (cached != null) {
+      deliverResult(cached);
+    }
+    if (takeContentChanged() || cached == null) {
+      forceLoad();
+    }
+    registerContentObserver();
+  }
+
+  @Override
+  protected void onStopLoading() {
+    cancelLoad();
+  }
+
+  @Override
+  protected void onReset() {
+    super.onReset();
+
+    onStopLoading();
+    cached = null;
+    unregisterContentObserver();
+  }
+
+  @Override
+  protected void onAbandon() {
+    super.onAbandon();
+    unregisterContentObserver();
+  }
+
+  @Override
+  public List<MediaStoreData> loadInBackground() {
+    List<MediaStoreData> data = queryImages();
+    data.addAll(queryVideos());
+    Collections.sort(data, new Comparator<MediaStoreData>() {
+      @Override
+      public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2) {
+        return Long.valueOf(mediaStoreData2.dateTaken).compareTo(mediaStoreData.dateTaken);
+      }
+    });
+    return data;
+  }
+
+  private List<MediaStoreData> queryImages() {
+    return query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, IMAGE_PROJECTION,
+        MediaStore.Images.ImageColumns.DATE_TAKEN, MediaStore.Images.ImageColumns._ID,
+        MediaStore.Images.ImageColumns.DATE_TAKEN, MediaStore.Images.ImageColumns.DATE_MODIFIED,
+        MediaStore.Images.ImageColumns.MIME_TYPE, MediaStore.Images.ImageColumns.ORIENTATION,
+        MediaStoreData.Type.IMAGE);
+  }
+
+  private List<MediaStoreData> queryVideos() {
+    return query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, VIDEO_PROJECTION,
+        MediaStore.Video.VideoColumns.DATE_TAKEN, MediaStore.Video.VideoColumns._ID,
+        MediaStore.Video.VideoColumns.DATE_TAKEN, MediaStore.Video.VideoColumns.DATE_MODIFIED,
+        MediaStore.Video.VideoColumns.MIME_TYPE, MediaStore.Images.ImageColumns.ORIENTATION,
+        MediaStoreData.Type.VIDEO);
+  }
+
+  private List<MediaStoreData> query(Uri contentUri, String[] projection, String sortByCol,
+      String idCol, String dateTakenCol, String dateModifiedCol, String mimeTypeCol,
+      String orientationCol, MediaStoreData.Type type) {
+    final List<MediaStoreData> data = new ArrayList<MediaStoreData>();
+    Cursor cursor = getContext().getContentResolver()
+        .query(contentUri, projection, null, null, sortByCol + " DESC");
+
+    if (cursor == null) {
+      return data;
+    }
+
+    try {
+      final int idColNum = cursor.getColumnIndexOrThrow(idCol);
+      final int dateTakenColNum = cursor.getColumnIndexOrThrow(dateTakenCol);
+      final int dateModifiedColNum = cursor.getColumnIndexOrThrow(dateModifiedCol);
+      final int mimeTypeColNum = cursor.getColumnIndex(mimeTypeCol);
+      final int orientationColNum = cursor.getColumnIndexOrThrow(orientationCol);
+
+      while (cursor.moveToNext()) {
+        long id = cursor.getLong(idColNum);
+        long dateTaken = cursor.getLong(dateTakenColNum);
+        String mimeType = cursor.getString(mimeTypeColNum);
+        long dateModified = cursor.getLong(dateModifiedColNum);
+        int orientation = cursor.getInt(orientationColNum);
+
+        data.add(new MediaStoreData(id, Uri.withAppendedPath(contentUri, Long.toString(id)),
+            mimeType, dateTaken, dateModified, orientation, type));
+      }
+    } finally {
+      cursor.close();
+    }
+
+    return data;
+  }
+
+  private void registerContentObserver() {
+    if (!observerRegistered) {
+      ContentResolver cr = getContext().getContentResolver();
+      cr.registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, false,
+          forceLoadContentObserver);
+      cr.registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, false,
+          forceLoadContentObserver);
+
+      observerRegistered = true;
+    }
+  }
+
+  private void unregisterContentObserver() {
+    if (observerRegistered) {
+      observerRegistered = false;
+
+      getContext().getContentResolver().unregisterContentObserver(forceLoadContentObserver);
+    }
+  }
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
new file mode 100644
index 000000000..1b26904ad
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -0,0 +1,157 @@
+package com.bumptech.glide.samples.gallery;
+
+import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
+import static com.bumptech.glide.request.RequestOptions.signatureOf;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Point;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.v7.widget.RecyclerView;
+import android.view.Display;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import android.widget.ImageView;
+
+import com.bumptech.glide.ListPreloader;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.signature.MediaStoreSignature;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Displays {@link com.bumptech.glide.samples.gallery.MediaStoreData} in a recycler view.
+ */
+class RecyclerAdapter extends RecyclerView.Adapter
+    implements ListPreloader.PreloadSizeProvider<MediaStoreData>,
+    ListPreloader.PreloadModelProvider<MediaStoreData> {
+
+  private final List<MediaStoreData> data;
+  private final int screenWidth;
+  private final RequestBuilder<Drawable> requestBuilder;
+
+  private int[] actualDimensions;
+
+  RecyclerAdapter(Context context, List<MediaStoreData> data, RequestManager requestManager) {
+    this.data = data;
+    requestBuilder = requestManager
+        .asDrawable()
+        .apply(fitCenterTransform(context));
+
+    setHasStableIds(true);
+
+    screenWidth = getWidth(context);
+  }
+
+  @Override
+  public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
+    final View view = LayoutInflater.from(viewGroup.getContext())
+        .inflate(R.layout.recycler_item, viewGroup, false);
+    view.getLayoutParams().width = screenWidth;
+
+    if (actualDimensions == null) {
+      view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
+        @Override
+        public boolean onPreDraw() {
+          if (actualDimensions == null) {
+            actualDimensions = new int[] { view.getWidth(), view.getHeight() };
+          }
+          view.getViewTreeObserver().removeOnPreDrawListener(this);
+          return true;
+        }
+      });
+    }
+
+    return new ListViewHolder(view);
+  }
+
+  @Override
+  public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {
+    MediaStoreData current = data.get(position);
+
+    final ListViewHolder vh = (ListViewHolder) viewHolder;
+
+    Key signature =
+        new MediaStoreSignature(current.mimeType, current.dateModified, current.orientation);
+
+    requestBuilder
+        .clone()
+        .apply(signatureOf(signature))
+        .load(current.uri)
+        .into(vh.image);
+  }
+
+  @Override
+  public long getItemId(int position) {
+    return data.get(position).rowId;
+  }
+
+  @Override
+  public int getItemCount() {
+    return data.size();
+  }
+
+  @Override
+  public int getItemViewType(int position) {
+    return 0;
+  }
+
+  @Override
+  public List<MediaStoreData> getPreloadItems(int position) {
+    return Collections.singletonList(data.get(position));
+  }
+
+  @Override
+  public RequestBuilder getPreloadRequestBuilder(MediaStoreData item) {
+    MediaStoreSignature signature =
+        new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
+    return requestBuilder
+        .clone()
+        .apply(signatureOf(signature))
+        .load(item.uri);
+  }
+
+  @Override
+  public int[] getPreloadSize(MediaStoreData item, int adapterPosition, int perItemPosition) {
+    return actualDimensions;
+  }
+
+  // Display#getSize(Point)
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+  @SuppressWarnings("deprecation")
+  private static int getWidth(Context context) {
+    WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    Display display = wm.getDefaultDisplay();
+
+    final int result;
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+      Point size = new Point();
+      display.getSize(size);
+      result = size.x;
+    } else {
+      result = display.getWidth();
+    }
+    return result;
+  }
+
+  /**
+   * ViewHolder containing views to display individual {@link
+   * com.bumptech.glide.samples.gallery.MediaStoreData}.
+   */
+  public static final class ListViewHolder extends RecyclerView.ViewHolder {
+
+    private final ImageView image;
+
+    public ListViewHolder(View itemView) {
+      super(itemView);
+      image = (ImageView) itemView.findViewById(R.id.image);
+    }
+  }
+}
diff --git a/samples/gallery/src/main/res/layout/main_activity.xml b/samples/gallery/src/main/res/layout/main_activity.xml
new file mode 100644
index 000000000..18c1a634f
--- /dev/null
+++ b/samples/gallery/src/main/res/layout/main_activity.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
+    <fragment
+            android:name="com.bumptech.glide.samples.gallery.HorizontalGalleryFragment"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:id="@+id/horizontal_gallery_fragment"/>
+</merge>
diff --git a/samples/gallery/src/main/res/layout/recycler_item.xml b/samples/gallery/src/main/res/layout/recycler_item.xml
new file mode 100644
index 000000000..84eb858dd
--- /dev/null
+++ b/samples/gallery/src/main/res/layout/recycler_item.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ImageView xmlns:android="http://schemas.android.com/apk/res/android"
+   android:id="@+id/image"
+   android:paddingLeft="5dp"
+   android:paddingRight="5dp"
+   android:layout_width="match_parent"
+   android:layout_height="match_parent"
+   android:contentDescription="@string/image_content_description"/>
diff --git a/samples/gallery/src/main/res/layout/recycler_view.xml b/samples/gallery/src/main/res/layout/recycler_view.xml
new file mode 100644
index 000000000..2136175aa
--- /dev/null
+++ b/samples/gallery/src/main/res/layout/recycler_view.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<android.support.v7.widget.RecyclerView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/recycler_view"
+    android:paddingBottom="20dp"
+    android:paddingTop="20dp"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent" />
diff --git a/samples/gallery/src/main/res/values/ids.xml b/samples/gallery/src/main/res/values/ids.xml
new file mode 100644
index 000000000..6187e3ee6
--- /dev/null
+++ b/samples/gallery/src/main/res/values/ids.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <item type="id" name="loader_id_media_store_data" />
+</resources>
diff --git a/samples/gallery/src/main/res/values/strings.xml b/samples/gallery/src/main/res/values/strings.xml
new file mode 100644
index 000000000..c1e016007
--- /dev/null
+++ b/samples/gallery/src/main/res/values/strings.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="app_name">gallery</string>
+  <string name="image_content_description">Photo</string>
+</resources>
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index 0cd221353..54054fe42 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -2,12 +2,16 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
-    compile 'com.google.code.gson:gson:2.2.4'
+    compile(project(':integration:recyclerview')) {
+        transitive = false
+    }
+    compile 'com.google.code.gson:gson:2.3'
+    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
@@ -16,6 +20,11 @@ android {
         versionCode 1
         versionName '1.0.0'
     }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
 }
 
 task run(type: Exec, dependsOn: 'installDebug') {
diff --git a/samples/giphy/giphy.iml b/samples/giphy/giphy.iml
deleted file mode 100644
index c5aebf930..000000000
--- a/samples/giphy/giphy.iml
+++ /dev/null
@@ -1,90 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":samples:giphy" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.samples" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":samples:giphy" />
-      </configuration>
-    </facet>
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="SELECTED_BUILD_VARIANT" value="debug" />
-        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
-        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
-        <option name="ALLOW_USER_CONFIGURATION" value="false" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
-        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
-      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
-      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" exported="" name="gson-2.2.4" level="project" />
-    <orderEntry type="library" exported="" name="support-v4-19.1.0" level="project" />
-    <orderEntry type="module" module-name="library" exported="" />
-    <orderEntry type="module" module-name="disklrucache" exported="" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/samples/giphy/lint.xml b/samples/giphy/lint.xml
new file mode 100644
index 000000000..95a2ab036
--- /dev/null
+++ b/samples/giphy/lint.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+</lint>
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index c5dbccb8f..4fa0d5d60 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -1,24 +1,32 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.bumptech.glide.samples.giphy" >
-    <uses-permission android:name="android.permission.INTERNET" />
+          package="com.bumptech.glide.samples.giphy">
+
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <uses-sdk android:minSdkVersion="14"
+      android:targetSdkVersion="22" />
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@android:drawable/sym_def_app_icon"
         android:largeHeap="true"
         android:label="@string/app_name"
-        android:theme="@style/AppTheme" >
+        android:theme="@style/AppTheme">
         <activity
             android:name=".MainActivity"
-            android:label="@string/app_name" >
+            android:label="@string/app_name">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
+                <action android:name="android.intent.action.MAIN"/>
 
-                <category android:name="android.intent.category.LAUNCHER" />
+                <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
-        <activity android:name=".FullscreenActivity" />
+        <activity android:name=".FullscreenActivity"/>
+
+        <meta-data
+            android:name="com.bumptech.glide.samples.giphy.GiphyGlideModule"
+            android:value="GlideModule"/>
     </application>
 
 </manifest>
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index eb61bbe36..b7c0de95a 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -19,195 +19,184 @@
  * A java wrapper for Giphy's http api based on https://github.com/Giphy/GiphyAPI.
  */
 public final class Api {
-    private static volatile Api api = null;
-    private static final String BETA_KEY = "dc6zaTOxFJmzC";
-    private static final String BASE_URL = "http://api.giphy.com";
-    private static final String SEARCH_PATH = "/v1/gifs/search";
-    private static final String TRENDING_PATH = "/v1/gifs/trending";
-    private final Handler bgHandler;
-    private final Handler mainHandler;
-    private final HashSet<Monitor> monitors = new HashSet<Monitor>();
-
-    private static String signUrl(String url) {
-        return url + "&api_key=" + BETA_KEY;
-    }
-
-    private static String getSearchUrl(String query, int limit, int offset) {
-        return signUrl(BASE_URL + SEARCH_PATH + "?q=" + query + "&limit=" + limit + "&offset=" + offset);
-    }
-
-    private static String getTrendingUrl(int limit, int offset) {
-        return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + limit + "&offset=" + offset);
-    }
-
+  private static volatile Api api = null;
+  private static final String BETA_KEY = "dc6zaTOxFJmzC";
+  private static final String BASE_URL = "https://api.giphy.com/";
+  private static final String SEARCH_PATH = "v1/gifs/search";
+  private static final String TRENDING_PATH = "v1/gifs/trending";
+  private final Handler bgHandler;
+  private final Handler mainHandler;
+  private final HashSet<Monitor> monitors = new HashSet<Monitor>();
+
+  private static String signUrl(String url) {
+    return url + "&api_key=" + BETA_KEY;
+  }
+
+  private static String getSearchUrl(String query, int limit, int offset) {
+    return signUrl(
+        BASE_URL + SEARCH_PATH + "?q=" + query + "&limit=" + limit + "&offset=" + offset);
+  }
+
+  private static String getTrendingUrl(int limit, int offset) {
+    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + limit + "&offset=" + offset);
+  }
+
+  /**
+   * An interface for listening for search results.
+   */
+  public interface Monitor {
     /**
-     * An interface for listening for search results.
+     * Called when a search completes.
+     *
+     * @param result The results returned from Giphy's search api.
      */
-    public interface Monitor {
-        /**
-         * Called when a search completes.
-         *
-         * @param result The results returned from Giphy's search api.
-         */
-        public void onSearchComplete(SearchResult result);
-    }
+    void onSearchComplete(SearchResult result);
+  }
 
-    public static Api get() {
+  public static Api get() {
+    if (api == null) {
+      synchronized (Api.class) {
         if (api == null) {
-            synchronized (Api.class) {
-                if (api == null) {
-                    api = new Api();
-                }
-            }
+          api = new Api();
         }
-        return api;
-    }
-
-    private Api() {
-        HandlerThread bgThread = new HandlerThread("api_thread");
-        bgThread.start();
-        bgHandler = new Handler(bgThread.getLooper());
-        mainHandler = new Handler(Looper.getMainLooper());
-        // Do nothing.
-    }
-
-    public void addMonitor(Monitor monitor) {
-        monitors.add(monitor);
-    }
-
-    public void removeMonitor(Monitor monitor) {
-        monitors.remove(monitor);
-    }
-
-    public void search(String searchTerm) {
-        String searchUrl = getSearchUrl(searchTerm, 100, 0);
-        query(searchUrl);
+      }
     }
+    return api;
+  }
+
+  private Api() {
+    HandlerThread bgThread = new HandlerThread("api_thread");
+    bgThread.start();
+    bgHandler = new Handler(bgThread.getLooper());
+    mainHandler = new Handler(Looper.getMainLooper());
+    // Do nothing.
+  }
+
+  public void addMonitor(Monitor monitor) {
+    monitors.add(monitor);
+  }
+
+  public void removeMonitor(Monitor monitor) {
+    monitors.remove(monitor);
+  }
+
+  public void search(String searchTerm) {
+    String searchUrl = getSearchUrl(searchTerm, 100, 0);
+    query(searchUrl);
+  }
+
+  public void getTrending() {
+    String trendingUrl = getTrendingUrl(100, 0);
+    query(trendingUrl);
+  }
+
+  private void query(final String apiUrl) {
+    bgHandler.post(new Runnable() {
+      @Override
+      public void run() {
+        URL url;
+        try {
+          url = new URL(apiUrl);
+        } catch (MalformedURLException e) {
+          throw new RuntimeException(e);
+        }
 
-    public void getTrending() {
-        String trendingUrl = getTrendingUrl(100, 0);
-        query(trendingUrl);
-    }
+        HttpURLConnection urlConnection = null;
+        InputStream is = null;
+        SearchResult result = new SearchResult();
+        try {
+          urlConnection = (HttpURLConnection) url.openConnection();
+          is = urlConnection.getInputStream();
+          InputStreamReader reader = new InputStreamReader(is);
+          result = new Gson().fromJson(reader, SearchResult.class);
+        } catch (IOException e) {
+          e.printStackTrace();
+        } finally {
+          if (is != null) {
+            try {
+              is.close();
+            } catch (IOException e) {
+              // Do nothing.
+            }
+          }
+          if (urlConnection != null) {
+            urlConnection.disconnect();
+          }
+        }
 
-    private void query(final String apiUrl) {
-        bgHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                URL url;
-                try {
-                    url = new URL(apiUrl);
-                } catch (MalformedURLException e) {
-                    throw new RuntimeException(e);
-                }
-
-                HttpURLConnection urlConnection = null;
-                InputStream is = null;
-                SearchResult result = new SearchResult();
-                try {
-                    urlConnection = (HttpURLConnection) url.openConnection();
-                    is = urlConnection.getInputStream();
-                    InputStreamReader reader = new InputStreamReader(is);
-                    result = new Gson().fromJson(reader, SearchResult.class);
-                } catch (IOException e) {
-                    e.printStackTrace();
-                } finally {
-                    if (is != null) {
-                        try {
-                            is.close();
-                        } catch (IOException e) {
-                            // Do nothing.
-                        }
-                    }
-                    if (urlConnection != null) {
-                        urlConnection.disconnect();
-                    }
-                }
-
-                final SearchResult finalResult = result;
-                mainHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        for (Monitor monitor : monitors) {
-                            monitor.onSearchComplete(finalResult);
-                        }
-                    }
-                });
+        final SearchResult finalResult = result;
+        mainHandler.post(new Runnable() {
+          @Override
+          public void run() {
+            for (Monitor monitor : monitors) {
+              monitor.onSearchComplete(finalResult);
             }
+          }
         });
+      }
+    });
+  }
+
+  /**
+   * A POJO mirroring the top level result JSON object returned from Giphy's api.
+   */
+  public static class SearchResult {
+    public GifResult[] data;
+
+    @Override
+    public String toString() {
+      return "SearchResult{" + "data=" + Arrays.toString(data) + '}';
     }
-
-    /**
-     * A POJO mirroring the top level result JSON object returned from Giphy's api.
-     */
-    public static class SearchResult {
-        public GifResult[] data;
-
-        @Override
-        public String toString() {
-            return "SearchResult{"
-                    + "data=" + Arrays.toString(data)
-                    + '}';
-        }
-    }
-
-    /**
-     * A POJO mirroring an individual GIF image returned from Giphy's api.
-     */
-    public static class GifResult {
-        public String id;
-        // Page url not gif url
-        public String url;
-        public GifUrlSet images;
-
-        @Override
-        public String toString() {
-            return "GifResult{"
-                    + "id='" + id + '\''
-                    + ", url='" + url + '\''
-                    + ", images=" + images
-                    + '}';
-        }
+  }
+
+  /**
+   * A POJO mirroring an individual GIF image returned from Giphy's api.
+   */
+  public static class GifResult {
+    public String id;
+    // Page url not gif url
+    public String url;
+    public GifUrlSet images;
+
+    @Override
+    public String toString() {
+      return "GifResult{" + "id='" + id + '\'' + ", url='" + url + '\'' + ", images=" + images
+          + '}';
     }
-
-    /**
-     * A POJO mirroring a JSON object with a set of urls of different sizes and dimensions returned for a single image
-     * from Giphy's api.
-     */
-    public static class GifUrlSet {
-        public GifImage original;
-        public GifImage fixed_width_downsampled;
-        public GifImage fixed_height_downsampled;
-
-        @Override
-        public String toString() {
-            return "GifUrlSet{"
-                    + "original=" + original
-                    + ", fixed_width_downsampled=" + fixed_width_downsampled
-                    + ", fixed_height_downsampled=" + fixed_height_downsampled
-                    + '}';
-        }
+  }
+
+  /**
+   * A POJO mirroring a JSON object with a put of urls of different sizes and dimensions returned
+   * for a single image from Giphy's api.
+   */
+  public static class GifUrlSet {
+    public GifImage original;
+    public GifImage fixed_width;
+    public GifImage fixed_height;
+
+    @Override
+    public String toString() {
+      return "GifUrlSet{" + "original=" + original + ", fixed_width="
+          + fixed_width + ", fixed_height=" + fixed_height
+          + '}';
     }
-
-    /**
-     * A POJO mirroring a JSON object for an image with one particular url, size and dimension returned from Giphy's
-     * api.
-     */
-    public static class GifImage {
-        public String url;
-        public int width;
-        public int height;
-        public int frames;
-        public int size;
-
-        @Override
-        public String toString() {
-            return "GifImage{"
-                    + "url='" + url + '\''
-                    + ", width=" + width
-                    + ", height=" + height
-                    + ", frames=" + frames
-                    + ", size=" + size
-                    + '}';
-        }
+  }
+
+  /**
+   * A POJO mirroring a JSON object for an image with one particular url, size and dimension
+   * returned from Giphy's api.
+   */
+  public static class GifImage {
+    public String url;
+    public int width;
+    public int height;
+    public int frames;
+    public int size;
+
+    @Override
+    public String toString() {
+      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height
+          + ", frames=" + frames + ", size=" + size + '}';
     }
+  }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
index 2599dc31f..47ef06e8e 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.samples.giphy;
 
+import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
+
 import com.google.gson.Gson;
 
 import android.app.Activity;
@@ -7,15 +9,17 @@
 import android.content.ClipboardManager;
 import android.content.Context;
 import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.view.View;
 import android.widget.ImageView;
 
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.drawable.GlideDrawable;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.transcode.BitmapToGlideDrawableTranscoder;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.Target;
 
@@ -23,69 +27,67 @@
  * An {@link android.app.Activity} for displaying full size original GIFs.
  */
 public class FullscreenActivity extends Activity {
-    private static final String EXTRA_RESULT_JSON = "result_json";
-    private GifDrawable gifDrawable;
+  private static final String EXTRA_RESULT_JSON = "result_json";
+  private GifDrawable gifDrawable;
 
-    public static Intent getIntent(Context context, Api.GifResult result) {
-        Intent intent = new Intent(context, FullscreenActivity.class);
-        intent.putExtra(EXTRA_RESULT_JSON, new Gson().toJson(result));
-        return intent;
-    }
+  public static Intent getIntent(Context context, Api.GifResult result) {
+    Intent intent = new Intent(context, FullscreenActivity.class);
+    intent.putExtra(EXTRA_RESULT_JSON, new Gson().toJson(result));
+    return intent;
+  }
 
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.fullscreen_activity);
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.fullscreen_activity);
 
-        String resultJson = getIntent().getStringExtra(EXTRA_RESULT_JSON);
-        final Api.GifResult result = new Gson().fromJson(resultJson, Api.GifResult.class);
+    String resultJson = getIntent().getStringExtra(EXTRA_RESULT_JSON);
+    final Api.GifResult result = new Gson().fromJson(resultJson, Api.GifResult.class);
 
-        ImageView gifView = (ImageView) findViewById(R.id.fullscreen_gif);
+    ImageView gifView = (ImageView) findViewById(R.id.fullscreen_gif);
 
-        gifView.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
-                ClipData clip = ClipData.newPlainText("giphy_url", result.images.original.url);
-                clipboard.setPrimaryClip(clip);
+    gifView.setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View view) {
+        ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
+        ClipData clip = ClipData.newPlainText("giphy_url", result.images.original.url);
+        clipboard.setPrimaryClip(clip);
 
-                if (gifDrawable != null) {
-                    if (gifDrawable.isRunning()) {
-                        gifDrawable.stop();
-                    } else {
-                        gifDrawable.start();
-                    }
-                }
-            }
-        });
+        if (gifDrawable != null) {
+          if (gifDrawable.isRunning()) {
+            gifDrawable.stop();
+          } else {
+            gifDrawable.start();
+          }
+        }
+      }
+    });
 
-        Glide.with(this)
-                .load(result.images.original.url)
-                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
-                .thumbnail(Glide.with(this)
-                        .load(result)
-                        .asBitmap()
-                        .transcode(new BitmapToGlideDrawableTranscoder(this), GlideDrawable.class)
-                        .diskCacheStrategy(DiskCacheStrategy.SOURCE)
-                )
-                .listener(new RequestListener<Object, GlideDrawable>() {
-                    @Override
-                    public boolean onException(Exception e, Object model, Target<GlideDrawable> target,
-                            boolean isFirstResource) {
-                        return false;
-                    }
+    RequestBuilder<Drawable> thumbnailRequest = Glide.with(this)
+        .load(result)
+        .apply(decodeTypeOf(Bitmap.class));
 
-                    @Override
-                    public boolean onResourceReady(GlideDrawable resource, Object model, Target<GlideDrawable> target,
-                            boolean isFromMemoryCache, boolean isFirstResource) {
-                        if (resource instanceof GifDrawable) {
-                            gifDrawable = (GifDrawable) resource;
-                        } else {
-                            gifDrawable = null;
-                        }
-                        return false;
-                    }
-                })
-                .into(gifView);
-    }
+    Glide.with(this)
+        .load(result.images.original.url)
+        .thumbnail(thumbnailRequest)
+        .listener(new RequestListener<Drawable>() {
+          @Override
+          public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
+              boolean isFirstResource) {
+            return false;
+          }
+
+          @Override
+          public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
+              DataSource dataSource, boolean isFirstResource) {
+            if (resource instanceof GifDrawable) {
+              gifDrawable = (GifDrawable) resource;
+            } else {
+              gifDrawable = null;
+            }
+            return false;
+          }
+        })
+        .into(gifView);
+  }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
new file mode 100644
index 000000000..7bc9bab9c
--- /dev/null
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.samples.giphy;
+
+import android.content.Context;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.module.GlideModule;
+
+import java.io.InputStream;
+
+/**
+ * {@link com.bumptech.glide.module.GlideModule} implementation for the Giphy sample app.
+ */
+public class GiphyGlideModule implements GlideModule {
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
+  }
+}
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index c27dbfa0f..3d27c6fe7 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -3,57 +3,67 @@
 import android.content.Context;
 import android.text.TextUtils;
 
-import com.bumptech.glide.load.model.GenericLoaderFactory;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
 
 import java.io.InputStream;
 
 /**
- * A model loader that translates a POJO mirroring a JSON object representing a single image from Giphy's api
- * into an {@link java.io.InputStream} that can be decoded into an {@link android.graphics.drawable.Drawable}.
+ * A model loader that translates a POJO mirroring a JSON object representing a single image from
+ * Giphy's api into an {@link java.io.InputStream} that can be decoded into an
+ * {@link android.graphics.drawable.Drawable}.
  */
 public class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
 
-    /**
-     * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
-     */
-    public static class Factory implements ModelLoaderFactory<Api.GifResult, InputStream> {
+  @Override
+  public boolean handles(Api.GifResult model) {
+    return true;
+  }
 
-        @Override
-        public ModelLoader<Api.GifResult, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new GiphyModelLoader(context);
-        }
+  /**
+   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
+   */
+  public static class Factory implements ModelLoaderFactory<Api.GifResult, InputStream> {
 
-        @Override
-        public void teardown() {
-            // Do nothing.
-        }
-    }
 
-    public GiphyModelLoader(Context context) {
-        super(context);
+    @Override
+    public ModelLoader<Api.GifResult, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
     @Override
-    protected String getUrl(Api.GifResult model, int width, int height) {
-        Api.GifImage fixedHeight = model.images.fixed_height_downsampled;
-        int fixedHeightDifference = getDifference(fixedHeight, width, height);
-        Api.GifImage fixedWidth = model.images.fixed_width_downsampled;
-        int fixedWidthDifference = getDifference(fixedWidth, width, height);
-        if (fixedHeightDifference < fixedWidthDifference && !TextUtils.isEmpty(fixedHeight.url)) {
-            return fixedHeight.url;
-        } else if (!TextUtils.isEmpty(fixedWidth.url)) {
-            return fixedWidth.url;
-        } else if (!TextUtils.isEmpty(model.images.original.url)) {
-            return model.images.original.url;
-        } else {
-            return null;
-        }
+    public void teardown() {
+      // Do nothing.
     }
+  }
 
-    private static int getDifference(Api.GifImage gifImage, int width, int height) {
-        return Math.abs(width - gifImage.width) + Math.abs(height - gifImage.height);
+  public GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
+    super(urlLoader);
+  }
+
+  @Override
+  protected String getUrl(Api.GifResult model, int width, int height, Options options) {
+    Api.GifImage fixedHeight = model.images.fixed_height;
+    int fixedHeightDifference = getDifference(fixedHeight, width, height);
+    Api.GifImage fixedWidth = model.images.fixed_width;
+    int fixedWidthDifference = getDifference(fixedWidth, width, height);
+    if (fixedHeightDifference < fixedWidthDifference && !TextUtils.isEmpty(fixedHeight.url)) {
+      return fixedHeight.url;
+    } else if (!TextUtils.isEmpty(fixedWidth.url)) {
+      return fixedWidth.url;
+    } else if (!TextUtils.isEmpty(model.images.original.url)) {
+      return model.images.original.url;
+    } else {
+      return null;
     }
+  }
+
+  private static int getDifference(Api.GifImage gifImage, int width, int height) {
+    return Math.abs(width - gifImage.width) + Math.abs(height - gifImage.height);
+  }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index e5dd70310..80e9f4fed 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -5,165 +5,157 @@
 import android.content.ClipboardManager;
 import android.content.Context;
 import android.content.Intent;
+import android.graphics.drawable.Drawable;
 import android.os.Bundle;
-import android.util.Log;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.BaseAdapter;
 import android.widget.ImageView;
-import android.widget.ListView;
 
-import com.bumptech.glide.DrawableRequestBuilder;
-import com.bumptech.glide.GenericRequestBuilder;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
 
-import java.io.InputStream;
-import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
- * The primary activity in the Giphy sample that allows users to view trending animated GIFs from Giphy's api.
+ * The primary activity in the Giphy sample that allows users to view trending animated GIFs from
+ * Giphy's api.
  */
 public class MainActivity extends Activity implements Api.Monitor {
-    private static final String TAG = "GiphyActivity";
+  private GifAdapter adapter;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+
+    ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
+
+    Glide.with(this)
+        .load(R.raw.large_giphy_logo)
+        .into(giphyLogoView);
+
+    RecyclerView gifList = (RecyclerView) findViewById(R.id.gif_list);
+    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
+    gifList.setLayoutManager(layoutManager);
+
+    RequestBuilder<Drawable> gifItemRequest = Glide.with(this).asDrawable();
+
+    ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider =
+        new ViewPreloadSizeProvider<>();
+    adapter = new GifAdapter(this, gifItemRequest, preloadSizeProvider);
+    gifList.setAdapter(adapter);
+    RecyclerViewPreloader<Api.GifResult> preloader =
+        new RecyclerViewPreloader<>(Glide.with(this), adapter, preloadSizeProvider, 4);
+    gifList.addOnScrollListener(preloader);
+  }
+
+  @Override
+  protected void onStart() {
+    super.onStart();
+    Api.get().addMonitor(this);
+    if (adapter.getItemCount() == 0) {
+      Api.get().getTrending();
+    }
+  }
+
+  @Override
+  protected void onStop() {
+    super.onStop();
+    Api.get().removeMonitor(this);
+  }
+
+  @Override
+  public void onSearchComplete(Api.SearchResult result) {
+    adapter.setResults(result.data);
+  }
 
-    private GifAdapter adapter;
-    private DrawableRequestBuilder<Api.GifResult> gifItemRequest;
+  private static class GifAdapter extends RecyclerView.Adapter<GifViewHolder>
+      implements ListPreloader.PreloadModelProvider<Api.GifResult> {
+    private static final Api.GifResult[] EMPTY_RESULTS = new Api.GifResult[0];
+
+    private final Activity activity;
+    private RequestBuilder<Drawable> requestBuilder;
     private ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
 
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_main);
-
-        Glide.get(this).register(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
-
-        ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
-        Glide.with(this)
-                .load(R.raw.large_giphy_logo)
-                .fitCenter()
-                .into(giphyLogoView);
-
-        ListView gifList = (ListView) findViewById(R.id.gif_list);
-
-        gifItemRequest = Glide.with(this)
-                .from(Api.GifResult.class)
-                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
-                .fitCenter();
-
-        preloadSizeProvider = new ViewPreloadSizeProvider<Api.GifResult>();
-        adapter = new GifAdapter(this, gifItemRequest, preloadSizeProvider);
-        gifList.setAdapter(adapter);
-        ListPreloader<Api.GifResult> preloader = new ListPreloader<Api.GifResult>(adapter, preloadSizeProvider, 2);
-        gifList.setOnScrollListener(preloader);
-    }
+    private Api.GifResult[] results = EMPTY_RESULTS;
 
-    @Override
-    protected void onStart() {
-        super.onStart();
-        Api.get().addMonitor(this);
-        if (adapter.getCount() == 0) {
-            Api.get().getTrending();
-        }
+    public GifAdapter(Activity activity, RequestBuilder<Drawable> requestBuilder,
+        ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider) {
+      this.activity = activity;
+      this.requestBuilder = requestBuilder;
+      this.preloadSizeProvider = preloadSizeProvider;
     }
 
-    @Override
-    protected void onStop() {
-        super.onStop();
-        Api.get().removeMonitor(this);
+    public void setResults(Api.GifResult[] results) {
+      if (results != null) {
+        this.results = results;
+      } else {
+        this.results = EMPTY_RESULTS;
+      }
+      notifyDataSetChanged();
     }
 
     @Override
-    public void onSearchComplete(Api.SearchResult result) {
-        adapter.setResults(result.data);
+    public GifViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      View view = activity.getLayoutInflater().inflate(R.layout.gif_list_item, parent, false);
+      return new GifViewHolder(view);
     }
 
-    private static class GifAdapter extends BaseAdapter implements ListPreloader.PreloadModelProvider<Api.GifResult> {
-        private static final Api.GifResult[] EMPTY_RESULTS = new Api.GifResult[0];
-
-        private final Activity activity;
-        private DrawableRequestBuilder<Api.GifResult> requestBuilder;
-        private ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
-
-        private Api.GifResult[] results = EMPTY_RESULTS;
-
-        public GifAdapter(Activity activity, DrawableRequestBuilder<Api.GifResult> requestBuilder,
-                ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider) {
-            this.activity = activity;
-            this.requestBuilder = requestBuilder;
-            this.preloadSizeProvider = preloadSizeProvider;
+    @Override
+    public void onBindViewHolder(GifViewHolder holder, int position) {
+      final Api.GifResult result = results[position];
+      holder.gifView.setOnClickListener(new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+          ClipboardManager clipboard =
+              (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+          ClipData clip =
+              ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
+          clipboard.setPrimaryClip(clip);
+
+          Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
+          activity.startActivity(fullscreenIntent);
         }
+      });
 
-        public void setResults(Api.GifResult[] results) {
-            if (results != null) {
-                this.results = results;
-            } else {
-                this.results = EMPTY_RESULTS;
-            }
-            notifyDataSetChanged();
-        }
+      requestBuilder.load(result).into(holder.gifView);
 
-        @Override
-        public int getCount() {
-            return results.length;
-        }
+      preloadSizeProvider.setView(holder.gifView);
+    }
 
-        @Override
-        public Api.GifResult getItem(int i) {
-            return results[i];
-        }
+    @Override
+    public long getItemId(int i) {
+      return 0;
+    }
 
-        @Override
-        public long getItemId(int i) {
-            return 0;
-        }
+    @Override
+    public int getItemCount() {
+      return results.length;
+    }
 
-        @Override
-        public View getView(int position, View convertView, ViewGroup parent) {
-            if (convertView == null) {
-                convertView = activity.getLayoutInflater().inflate(R.layout.gif_list_item, parent, false);
-            }
-
-            final Api.GifResult result = results[position];
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "load result: " + result);
-            }
-            final ImageView gifView = (ImageView) convertView.findViewById(R.id.gif_view);
-            gifView.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                    ClipboardManager clipboard =
-                            (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
-                    ClipData clip = ClipData.newPlainText("giphy_url", result.images.fixed_height_downsampled.url);
-                    clipboard.setPrimaryClip(clip);
-
-                    Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
-                    activity.startActivity(fullscreenIntent);
-                }
-            });
-
-            requestBuilder
-                    .load(result)
-                    .into(gifView);
-
-            preloadSizeProvider.setView(gifView);
-
-            return convertView;
-        }
+    @Override
+    public List<Api.GifResult> getPreloadItems(int position) {
+      return Collections.singletonList(results[position]);
+    }
 
-        @Override
-        public List<Api.GifResult> getPreloadItems(int position) {
-            List<Api.GifResult> items = new ArrayList<Api.GifResult>(1);
-            items.add(getItem(position));
-            return items;
-        }
+    @Override
+    public RequestBuilder getPreloadRequestBuilder(Api.GifResult item) {
+      return requestBuilder.load(item);
+    }
+  }
 
-        @Override
-        public GenericRequestBuilder getPreloadRequestBuilder(Api.GifResult item) {
-            return requestBuilder.load(item);
-        }
+  private static class GifViewHolder extends RecyclerView.ViewHolder {
+    private final ImageView gifView;
+
+    public GifViewHolder(View itemView) {
+      super(itemView);
+      gifView = (ImageView) itemView.findViewById(R.id.gif_view);
     }
+  }
 }
diff --git a/samples/giphy/src/main/res/drawable-hdpi/ic_launcher.png b/samples/giphy/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 55621cc10..000000000
Binary files a/samples/giphy/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/giphy/src/main/res/drawable-mdpi/ic_launcher.png b/samples/giphy/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index 11ec2068b..000000000
Binary files a/samples/giphy/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/giphy/src/main/res/drawable-xhdpi/ic_launcher.png b/samples/giphy/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 7c02b784a..000000000
Binary files a/samples/giphy/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/giphy/src/main/res/drawable-xxhdpi/ic_launcher.png b/samples/giphy/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 915d91441..000000000
Binary files a/samples/giphy/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/giphy/src/main/res/layout/activity_main.xml b/samples/giphy/src/main/res/layout/activity_main.xml
index 5c81a68ed..332705305 100644
--- a/samples/giphy/src/main/res/layout/activity_main.xml
+++ b/samples/giphy/src/main/res/layout/activity_main.xml
@@ -1,23 +1,19 @@
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin"
-    android:paddingBottom="@dimen/activity_vertical_margin"
-    android:orientation="vertical"
-    tools:context=".MainActivity">
+              xmlns:tools="http://schemas.android.com/tools"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:layout_margin="@dimen/activity_margin"
+              android:orientation="vertical"
+              tools:context=".MainActivity">
     <ImageView
         android:id="@+id/giphy_logo_view"
         android:layout_width="100dp"
         android:layout_height="50dp"
         android:layout_gravity="center_horizontal"
-        android:contentDescription="@string/giphy_logo_description"
-        />
-    <ListView
+        android:contentDescription="@string/giphy_logo_description" />
+    <android.support.v7.widget.RecyclerView
         android:id="@+id/gif_list"
-        android:layout_width="match_parent"
         android:layout_height="0dp"
+        android:layout_width="match_parent"
         android:layout_weight="1"/>
 </LinearLayout>
diff --git a/samples/giphy/src/main/res/layout/fullscreen_activity.xml b/samples/giphy/src/main/res/layout/fullscreen_activity.xml
index 09967b3e9..17613abe5 100644
--- a/samples/giphy/src/main/res/layout/fullscreen_activity.xml
+++ b/samples/giphy/src/main/res/layout/fullscreen_activity.xml
@@ -3,4 +3,6 @@
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/fullscreen_gif"
    android:layout_width="match_parent"
-   android:layout_height="match_parent"/>
+   android:layout_height="match_parent"
+   android:contentDescription="@string/fullscreen_description"
+   />
diff --git a/samples/giphy/src/main/res/layout/gif_list_item.xml b/samples/giphy/src/main/res/layout/gif_list_item.xml
index 6f79bb1c2..6c4d20c2a 100644
--- a/samples/giphy/src/main/res/layout/gif_list_item.xml
+++ b/samples/giphy/src/main/res/layout/gif_list_item.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <ImageView xmlns:android="http://schemas.android.com/apk/res/android"
-   android:id="@+id/gif_view"
-   android:layout_width="match_parent"
-   android:layout_height="125dp"
-   android:contentDescription="@string/image_description" />
+           android:id="@+id/gif_view"
+           android:layout_width="match_parent"
+           android:layout_height="125dp"
+           android:contentDescription="@string/image_description"/>
diff --git a/samples/giphy/src/main/res/raw/large_giphy_logo.gif b/samples/giphy/src/main/res/raw/large_giphy_logo.gif
old mode 100755
new mode 100644
diff --git a/samples/giphy/src/main/res/values-w820dp/dimens.xml b/samples/giphy/src/main/res/values-w820dp/dimens.xml
deleted file mode 100644
index 63fc81644..000000000
--- a/samples/giphy/src/main/res/values-w820dp/dimens.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<resources>
-    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
-         (such as screen margins) for screens with more than 820dp of available width. This
-         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
-    <dimen name="activity_horizontal_margin">64dp</dimen>
-</resources>
diff --git a/samples/giphy/src/main/res/values/dimens.xml b/samples/giphy/src/main/res/values/dimens.xml
index 47c822467..e641ba457 100644
--- a/samples/giphy/src/main/res/values/dimens.xml
+++ b/samples/giphy/src/main/res/values/dimens.xml
@@ -1,5 +1,3 @@
 <resources>
-    <!-- Default screen margins, per the Android Design guidelines. -->
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
+    <dimen name="activity_margin">16dp</dimen>
 </resources>
diff --git a/samples/giphy/src/main/res/values/strings.xml b/samples/giphy/src/main/res/values/strings.xml
index 0fc25a9a8..c3f4e93e9 100644
--- a/samples/giphy/src/main/res/values/strings.xml
+++ b/samples/giphy/src/main/res/values/strings.xml
@@ -3,4 +3,5 @@
   <string name="app_name">GiphySample</string>
   <string name="image_description">An image from the list of results for a search query</string>
   <string name="giphy_logo_description">An animated version of the Giphy company logo</string>
+  <string name="fullscreen_description">Full screen view of an image</string>
 </resources>
diff --git a/samples/samples.iml b/samples/samples.iml
deleted file mode 100644
index d5233217a..000000000
--- a/samples/samples.iml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":samples" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":samples" />
-      </configuration>
-    </facet>
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-      <excludeFolder url="file://$MODULE_DIR$/build" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
-
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index c0f6301b1..973afa473 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -6,16 +6,21 @@ repositories {
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
-        applicationId 'com.bumptech.svgsample.app'
+        applicationId 'com.bumptech.glide.samples.svg'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
         versionCode 1
         versionName '1.0'
     }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
 }
 
 dependencies {
@@ -25,5 +30,5 @@ dependencies {
 
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
-    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.svgsample.app/.MainActivity'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.svg/.MainActivity'
 }
diff --git a/samples/svg/lint.xml b/samples/svg/lint.xml
new file mode 100644
index 000000000..95a2ab036
--- /dev/null
+++ b/samples/svg/lint.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+</lint>
diff --git a/samples/svg/src/main/AndroidManifest.xml b/samples/svg/src/main/AndroidManifest.xml
index acfc3a8fb..218bbe4b5 100644
--- a/samples/svg/src/main/AndroidManifest.xml
+++ b/samples/svg/src/main/AndroidManifest.xml
@@ -1,19 +1,26 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.bumptech.svgsample.app" >
+    package="com.bumptech.glide.samples.svg" >
 
-    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <uses-sdk
+            android:minSdkVersion="10"
+            android:targetSdkVersion="22" />
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name">
+        <meta-data
+            android:name="com.bumptech.glide.samples.svg.SvgModule"
+            android:value="GlideModule"/>
         <activity
             android:name=".MainActivity"
             android:label="@string/app_name">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
     </application>
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
new file mode 100644
index 000000000..0587c01f7
--- /dev/null
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.samples.svg;
+
+import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
+import static com.bumptech.glide.request.RequestOptions.placeholderOf;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.graphics.drawable.PictureDrawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestBuilder;
+
+import java.io.File;
+
+/**
+ * Displays an SVG image loaded from an android raw resource.
+ */
+public class MainActivity extends Activity {
+  private static final String TAG = "SVGActivity";
+
+  private ImageView imageViewRes;
+  private ImageView imageViewNet;
+  private RequestBuilder<PictureDrawable> requestBuilder;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+
+    imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
+    imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);
+
+    requestBuilder = Glide.with(this)
+        .as(PictureDrawable.class)
+        .apply(placeholderOf(R.drawable.image_loading)
+            .error(R.drawable.image_error))
+        .transition(withCrossFade())
+        .listener(new SvgSoftwareLayerSetter());
+  }
+
+  @Override
+  protected void onStart() {
+    super.onStart();
+    reload();
+  }
+
+  public void clearCache(View v) {
+    Log.w(TAG, "clearing cache");
+    Glide.with(this).clear(imageViewRes);
+    Glide.with(this).clear(imageViewNet);
+    Glide.get(this).clearMemory();
+    File cacheDir = Glide.getPhotoCacheDir(this);
+    if (cacheDir.isDirectory()) {
+      for (File child : cacheDir.listFiles()) {
+        if (!child.delete()) {
+          Log.w(TAG, "cannot delete: " + child);
+        }
+      }
+    }
+    reload();
+  }
+
+  public void cycleScaleType(View v) {
+    ImageView.ScaleType curr = imageViewRes.getScaleType();
+    Log.w(TAG, "cycle: current=" + curr);
+    ImageView.ScaleType[] all = ImageView.ScaleType.values();
+    int nextOrdinal = (curr.ordinal() + 1) % all.length;
+    ImageView.ScaleType next = all[nextOrdinal];
+    Log.w(TAG, "cycle: next=" + next);
+    imageViewRes.setScaleType(next);
+    imageViewNet.setScaleType(next);
+    reload();
+  }
+
+  private void reload() {
+    Log.w(TAG, "reloading");
+    ((TextView) findViewById(R.id.button))
+        .setText(getString(R.string.scaleType, imageViewRes.getScaleType()));
+    loadRes();
+    loadNet();
+  }
+
+  private void loadRes() {
+    Uri uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getPackageName() + "/"
+        + R.raw.android_toy_h);
+    requestBuilder.load(uri).into(imageViewRes);
+  }
+
+  private void loadNet() {
+    Uri uri = Uri.parse("http://www.clker.com/cliparts/u/Z/2/b/a/6/android-toy-h.svg");
+    requestBuilder.load(uri).into(imageViewNet);
+  }
+}
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
new file mode 100644
index 000000000..3fdd91ad5
--- /dev/null
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.samples.svg;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.SimpleResource;
+import com.caverock.androidsvg.SVG;
+import com.caverock.androidsvg.SVGParseException;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Decodes an SVG internal representation from an {@link InputStream}.
+ */
+public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {
+
+  @Override
+  public boolean handles(InputStream source, Options options) throws IOException {
+    // TODO: Can we tell?
+    return true;
+  }
+
+  public Resource<SVG> decode(InputStream source, int width, int height, Options options)
+      throws IOException {
+    try {
+      SVG svg = SVG.getFromInputStream(source);
+      return new SimpleResource<SVG>(svg);
+    } catch (SVGParseException ex) {
+      throw new IOException("Cannot load SVG from stream", ex);
+    }
+  }
+}
diff --git a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
similarity index 50%
rename from samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java
rename to samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
index f4056d35d..43352acd8 100644
--- a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
@@ -1,4 +1,4 @@
-package com.bumptech.svgsample.app;
+package com.bumptech.glide.samples.svg;
 
 import android.graphics.Picture;
 import android.graphics.drawable.PictureDrawable;
@@ -9,19 +9,16 @@
 import com.caverock.androidsvg.SVG;
 
 /**
- * Convert the {@link SVG}'s internal representation to an Android-compatible one ({@link Picture}).
+ * Convert the {@link SVG}'s internal representation to an Android-compatible one
+ * ({@link Picture}).
  */
 public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
-    @Override
-    public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode) {
-        SVG svg = toTranscode.get();
-        Picture picture = svg.renderToPicture();
-        PictureDrawable drawable = new PictureDrawable(picture);
-        return new SimpleResource<PictureDrawable>(drawable);
-    }
-
-    @Override
-    public String getId() {
-        return "";
-    }
+  @Override
+  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode) {
+    SVG svg = toTranscode.get();
+    Picture picture = svg.renderToPicture();
+    PictureDrawable drawable = new PictureDrawable(picture);
+    return new SimpleResource<PictureDrawable>(drawable);
+  }
 }
+
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
new file mode 100644
index 000000000..b3cfcbfe0
--- /dev/null
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.samples.svg;
+
+import android.content.Context;
+import android.graphics.drawable.PictureDrawable;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.module.GlideModule;
+import com.caverock.androidsvg.SVG;
+
+import java.io.InputStream;
+
+/**
+ * Module for the SVG sample app.
+ */
+public class SvgModule implements GlideModule {
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
+        .append(InputStream.class, SVG.class, new SvgDecoder());
+  }
+}
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
new file mode 100644
index 000000000..c3b4aa003
--- /dev/null
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.samples.svg;
+
+import android.annotation.TargetApi;
+import android.graphics.drawable.PictureDrawable;
+import android.os.Build;
+import android.widget.ImageView;
+
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.ImageViewTarget;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Listener which updates the {@link ImageView} to be software rendered, because
+ * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
+ * a hardware backed {@link android.graphics.Canvas Canvas}.
+ */
+@TargetApi(Build.VERSION_CODES.HONEYCOMB)
+public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {
+
+  @Override
+  public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawable> target,
+      boolean isFirstResource) {
+    ImageView view = ((ImageViewTarget<?>) target).getView();
+    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
+      view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
+    }
+    return false;
+  }
+
+  @Override
+  public boolean onResourceReady(PictureDrawable resource, Object model,
+      Target<PictureDrawable> target, DataSource dataSource, boolean isFirstResource) {
+    ImageView view = ((ImageViewTarget<?>) target).getView();
+    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
+      view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
+    }
+    return false;
+  }
+}
diff --git a/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java b/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java
deleted file mode 100644
index dd9228ff9..000000000
--- a/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package com.bumptech.svgsample.app;
-
-import android.app.Activity;
-import android.content.ContentResolver;
-import android.graphics.drawable.PictureDrawable;
-import android.net.Uri;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import com.bumptech.glide.GenericRequestBuilder;
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.model.StreamEncoder;
-import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
-import com.caverock.androidsvg.SVG;
-
-import java.io.File;
-import java.io.InputStream;
-
-/**
- * Displays an SVG image loaded from an android raw resource.
- */
-public class MainActivity extends Activity {
-    private static final String TAG = "SVGActivity";
-
-    private ImageView imageViewRes;
-    private ImageView imageViewNet;
-    private GenericRequestBuilder<Uri, InputStream, SVG, PictureDrawable> requestBuilder;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_main);
-
-        imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
-        imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);
-
-        requestBuilder = Glide.with(this)
-                .using(Glide.buildStreamModelLoader(Uri.class, this), InputStream.class)
-                .from(Uri.class)
-                .as(SVG.class)
-                .transcode(new SvgDrawableTranscoder(), PictureDrawable.class)
-                .sourceEncoder(new StreamEncoder())
-                .cacheDecoder(new FileToStreamDecoder<SVG>(new SvgDecoder()))
-                .decoder(new SvgDecoder())
-                .placeholder(R.drawable.image_loading)
-                .error(R.drawable.image_error)
-                .animate(android.R.anim.fade_in)
-                .listener(new SvgSoftwareLayerSetter<Uri>());
-    }
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-        reload();
-    }
-
-    public void clearCache(View v) {
-        Log.w(TAG, "clearing cache");
-        Glide.clear(imageViewRes);
-        Glide.clear(imageViewNet);
-        Glide.get(this).clearMemory();
-        File cacheDir = Glide.getPhotoCacheDir(this);
-        if (cacheDir.isDirectory()) {
-            for (File child : cacheDir.listFiles()) {
-                if (!child.delete()) {
-                    Log.w(TAG, "cannot delete: " + child);
-                }
-            }
-        }
-        reload();
-    }
-
-    public void cycleScaleType(View v) {
-        ImageView.ScaleType curr = imageViewRes.getScaleType();
-        Log.w(TAG, "cycle: current=" + curr);
-        ImageView.ScaleType[] all = ImageView.ScaleType.values();
-        int nextOrdinal = (curr.ordinal() + 1) % all.length;
-        ImageView.ScaleType next = all[nextOrdinal];
-        Log.w(TAG, "cycle: next=" + next);
-        imageViewRes.setScaleType(next);
-        imageViewNet.setScaleType(next);
-        reload();
-    }
-
-    private void reload() {
-        Log.w(TAG, "reloading");
-        ((TextView) findViewById(R.id.button)).setText(getString(R.string.scaleType, imageViewRes.getScaleType()));
-        loadRes();
-        loadNet();
-    }
-
-    private void loadRes() {
-        Uri uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getPackageName() + "/"
-                + R.raw.android_toy_h);
-        requestBuilder
-                .diskCacheStrategy(DiskCacheStrategy.NONE)
-                        // SVG cannot be serialized so it's not worth to cache it
-                        // and the getResources() should be fast enough when acquiring the InputStream
-                .load(uri)
-                .into(imageViewRes);
-    }
-
-    private void loadNet() {
-        Uri uri = Uri.parse("http://www.clker.com/cliparts/u/Z/2/b/a/6/android-toy-h.svg");
-        requestBuilder
-                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
-                        // SVG cannot be serialized so it's not worth to cache it
-                .load(uri)
-                .into(imageViewNet);
-    }
-}
diff --git a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDecoder.java b/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDecoder.java
deleted file mode 100644
index 5b9060447..000000000
--- a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDecoder.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.bumptech.svgsample.app;
-
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.SimpleResource;
-import com.caverock.androidsvg.SVG;
-import com.caverock.androidsvg.SVGParseException;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Decodes an SVG internal representation from an {@link InputStream}.
- */
-public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {
-    public Resource<SVG> decode(InputStream source, int width, int height) throws IOException {
-        try {
-            SVG svg = SVG.getFromInputStream(source);
-            return new SimpleResource<SVG>(svg);
-        } catch (SVGParseException ex) {
-            throw new IOException("Cannot load SVG from stream", ex);
-        }
-    }
-
-    @Override
-    public String getId() {
-        return "SvgDecoder.com.bumptech.svgsample.app";
-    }
-}
diff --git a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java
deleted file mode 100644
index a23a030dd..000000000
--- a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.bumptech.svgsample.app;
-
-import android.annotation.TargetApi;
-import android.graphics.drawable.PictureDrawable;
-import android.os.Build;
-import android.widget.ImageView;
-
-import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.target.ImageViewTarget;
-import com.bumptech.glide.request.target.Target;
-
-/**
- * Listener which updates the {@link ImageView} to be software rendered,
- * because {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture}
- * can't render on a hardware backed {@link android.graphics.Canvas Canvas}.
- *
- * @param <T> not used, here to prevent unchecked warnings at usage
- */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
-public class SvgSoftwareLayerSetter<T> implements RequestListener<T, PictureDrawable> {
-
-    @Override
-    public boolean onException(Exception e, T model, Target<PictureDrawable> target, boolean isFirstResource) {
-        ImageView view = ((ImageViewTarget<?>) target).getView();
-        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-            view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onResourceReady(PictureDrawable resource, T model, Target<PictureDrawable> target,
-                                   boolean isFromMemoryCache, boolean isFirstResource) {
-        ImageView view = ((ImageViewTarget<?>) target).getView();
-        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-            view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
-        }
-        return false;
-    }
-}
diff --git a/samples/svg/src/main/res/drawable-hdpi/ic_launcher.png b/samples/svg/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 96a442e5b..000000000
Binary files a/samples/svg/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/svg/src/main/res/drawable-mdpi/ic_launcher.png b/samples/svg/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index 359047dfa..000000000
Binary files a/samples/svg/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/svg/src/main/res/drawable-xhdpi/ic_launcher.png b/samples/svg/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 71c6d760f..000000000
Binary files a/samples/svg/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/svg/src/main/res/drawable-xxhdpi/ic_launcher.png b/samples/svg/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 4df189464..000000000
Binary files a/samples/svg/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/svg/src/main/res/drawable/dot_dot_dot.xml b/samples/svg/src/main/res/drawable/dot_dot_dot.xml
index 3d168e06d..bfebb30da 100644
--- a/samples/svg/src/main/res/drawable/dot_dot_dot.xml
+++ b/samples/svg/src/main/res/drawable/dot_dot_dot.xml
@@ -1,21 +1,33 @@
 <?xml version="1.0" encoding="utf-8"?>
 <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
     <!-- 10(gap) 10(first) 10(gap) 10(second) 10(gap) 10(third) 10(gap) -->
-    <item android:left="10dp" android:right="50dp">
+    <item
+        android:left="10dp"
+        android:right="50dp">
         <shape android:shape="oval">
-            <size android:width="10dp" android:height="10dp" />
+            <size
+                android:width="10dp"
+                android:height="10dp"/>
             <solid android:color="@android:color/black"/>
         </shape>
     </item>
-    <item android:left="30dp" android:right="30dp">
+    <item
+        android:left="30dp"
+        android:right="30dp">
         <shape android:shape="oval">
-            <size android:width="10dp" android:height="10dp" />
+            <size
+                android:width="10dp"
+                android:height="10dp"/>
             <solid android:color="@android:color/black"/>
         </shape>
     </item>
-    <item android:left="50dp" android:right="10dp">
+    <item
+        android:left="50dp"
+        android:right="10dp">
         <shape android:shape="oval">
-            <size android:width="10dp" android:height="10dp" />
+            <size
+                android:width="10dp"
+                android:height="10dp"/>
             <solid android:color="@android:color/black"/>
         </shape>
     </item>
diff --git a/samples/svg/src/main/res/drawable/image_error.xml b/samples/svg/src/main/res/drawable/image_error.xml
index 97b538d39..bd78f2678 100644
--- a/samples/svg/src/main/res/drawable/image_error.xml
+++ b/samples/svg/src/main/res/drawable/image_error.xml
@@ -6,10 +6,10 @@
             <shape android:shape="line">
                 <size
                     android:width="128dp"
-                    android:height="128dp" />
+                    android:height="128dp"/>
                 <stroke
                     android:color="#f00"
-                    android:width="4dp" />
+                    android:width="4dp"/>
             </shape>
         </rotate>
     </item>
@@ -20,10 +20,10 @@
             <shape android:shape="line">
                 <size
                     android:width="128dp"
-                    android:height="128dp" />
+                    android:height="128dp"/>
                 <stroke
                     android:color="#f00"
-                    android:width="4dp" />
+                    android:width="4dp"/>
             </shape>
         </rotate>
     </item>
diff --git a/samples/svg/src/main/res/drawable/image_loading.xml b/samples/svg/src/main/res/drawable/image_loading.xml
index ae231139c..ad1bddfad 100644
--- a/samples/svg/src/main/res/drawable/image_loading.xml
+++ b/samples/svg/src/main/res/drawable/image_loading.xml
@@ -2,8 +2,11 @@
 <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
     <item>
         <bitmap
-            android:src="@drawable/ic_launcher"
+            android:src="@android:drawable/sym_def_app_icon"
             android:gravity="center" />
     </item>
-    <item android:top="20dp" android:bottom="20dp" android:drawable="@drawable/dot_dot_dot" />
+    <item
+        android:top="20dp"
+        android:bottom="20dp"
+        android:drawable="@drawable/dot_dot_dot"/>
 </layer-list>
diff --git a/samples/svg/src/main/res/layout/activity_main.xml b/samples/svg/src/main/res/layout/activity_main.xml
index 5db148867..704faa1f9 100644
--- a/samples/svg/src/main/res/layout/activity_main.xml
+++ b/samples/svg/src/main/res/layout/activity_main.xml
@@ -1,12 +1,12 @@
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:paddingBottom="@dimen/activity_vertical_margin"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin"
-    tools:context=".MainActivity">
+                xmlns:tools="http://schemas.android.com/tools"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:paddingBottom="@dimen/activity_vertical_margin"
+                android:paddingLeft="@dimen/activity_horizontal_margin"
+                android:paddingRight="@dimen/activity_horizontal_margin"
+                android:paddingTop="@dimen/activity_vertical_margin"
+                tools:context=".MainActivity">
 
     <TextView
         android:id="@+id/description"
@@ -16,7 +16,7 @@
         android:onClick="clearCache"
         android:clickable="true"
         android:text="@string/hello_world"
-    />
+        />
 
     <Button
         android:id="@+id/button"
@@ -27,7 +27,7 @@
         android:layout_marginTop="@dimen/activity_vertical_margin"
         android:onClick="cycleScaleType"
         android:text="@string/scaleType"
-    />
+        />
 
     <View
         android:id="@+id/align"
@@ -36,7 +36,7 @@
         android:layout_centerHorizontal="true"
         android:layout_marginLeft="@dimen/activity_horizontal_margin"
         android:layout_marginRight="@dimen/activity_horizontal_margin"
-     />
+        />
 
     <ImageView
         android:id="@+id/svg_image_view1"
@@ -52,7 +52,7 @@
         android:background="#808"
         android:contentDescription="@string/android_linen_content_description"
         android:src="@drawable/image_error"
-    />
+        />
 
     <ImageView
         android:id="@+id/svg_image_view2"
diff --git a/samples/svg/svg.iml b/samples/svg/svg.iml
deleted file mode 100644
index c81d390f2..000000000
--- a/samples/svg/svg.iml
+++ /dev/null
@@ -1,90 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":samples:svg" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.samples" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":samples:svg" />
-      </configuration>
-    </facet>
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="SELECTED_BUILD_VARIANT" value="debug" />
-        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
-        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
-        <option name="ALLOW_USER_CONFIGURATION" value="false" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
-        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
-      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
-      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" exported="" name="support-v4-19.1.0" level="project" />
-    <orderEntry type="library" exported="" name="androidsvg-1.2.1" level="project" />
-    <orderEntry type="module" module-name="library" exported="" />
-    <orderEntry type="module" module-name="disklrucache" exported="" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index a32cd39e7..ec5af0341 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -65,10 +65,10 @@ afterEvaluate { project ->
                 }
 
                 pom.project {
-                    name POM_NAME
-                    packaging POM_PACKAGING
-                    description POM_DESCRIPTION
-                    url POM_URL
+                    name = POM_NAME
+                    packaging = POM_PACKAGING
+                    description = POM_DESCRIPTION
+                    url = POM_URL
 
                     scm {
                         url POM_SCM_URL
@@ -78,22 +78,22 @@ afterEvaluate { project ->
 
                     licenses {
                         license {
-                            name "Simplified BSD License"
-                            url "http://www.opensource.org/licenses/bsd-license"
+                            name = "Simplified BSD License"
+                            url = "http://www.opensource.org/licenses/bsd-license"
                             distribution = "repo"
                         }
                         license {
-                            name "The Apache Software License, Version 2.0"
-                            url "http://www.apache.org/licenses/LICENSE-2.0.txt"
+                            name = "The Apache Software License, Version 2.0"
+                            url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
                             distribution = "repo"
                         }
                     }
 
                     developers {
                         developer {
-                            id POM_DEVELOPER_ID
-                            name POM_DEVELOPER_NAME
-                            email POM_DEVELOPER_EMAIL
+                            id = POM_DEVELOPER_ID
+                            name = POM_DEVELOPER_NAME
+                            email = POM_DEVELOPER_EMAIL
                         }
                     }
                 }
diff --git a/settings.gradle b/settings.gradle
index caef1261a..6f0fe1a45 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,14 +1,19 @@
+exec {
+  commandLine "git", "submodule", "update", "--init", "--recursive"
+}
 include ':library'
 include ':glide'
 include ':third_party:gif_decoder'
 include ':third_party:disklrucache'
-include ':third_party:gif_encoder'
 include ':samples:flickr'
 include ':samples:giphy'
 include ':samples:svg'
+include ':samples:gallery'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
+include ':integration:gifencoder'
+include ':integration:recyclerview'
 include ':testutil'
 
 rootProject.name = 'glide-parent'
diff --git a/testutil/build.gradle b/testutil/build.gradle
index bbfeb03c2..e2c77440d 100644
--- a/testutil/build.gradle
+++ b/testutil/build.gradle
@@ -1 +1,5 @@
 apply plugin: 'java'
+
+dependencies {
+    compile "com.google.truth:truth:${TRUTH_VERSION}"
+}
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
index e523b67d0..d311d940f 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
@@ -6,18 +6,18 @@
  * Test only utility for opening resources in androidTest/resources.
  */
 public final class TestResourceUtil {
-    private TestResourceUtil() {
-        // Utility class
-    }
+  private TestResourceUtil() {
+    // Utility class
+  }
 
-    /**
-     * Returns an InputStream for the given test class and sub-path.
-     *
-     * @param testClass A Junit test class.
-     * @param subPath The sub-path under androidTest/resources where the desired resource is located.
-     *                Should not be prefixed with a '/'
-     */
-    public static InputStream openResource(Class testClass, String subPath) {
-        return testClass.getResourceAsStream("/" + subPath);
-    }
+  /**
+   * Returns an InputStream for the given test class and sub-path.
+   *
+   * @param testClass A Junit test class.
+   * @param subPath   The sub-path under androidTest/resources where the desired resource is
+   *                  located. Should not be prefixed with a '/'
+   */
+  public static InputStream openResource(Class testClass, String subPath) {
+    return testClass.getResourceAsStream("/" + subPath);
+  }
 }
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
index 0ad40e0e6..2d4ab7b5b 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.testutil;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -8,30 +10,33 @@
  * Shared utility classes for tests.
  */
 public final class TestUtil {
-    private TestUtil() {
-        // Utility class.
-    }
+  private TestUtil() {
+    // Utility class.
+  }
 
-    public static byte[] resourceToBytes(Class testClass, String resourceName) throws IOException {
-        return isToBytes(TestResourceUtil.openResource(testClass, resourceName));
-    }
+  public static byte[] resourceToBytes(Class testClass, String resourceName) throws IOException {
+    return isToBytes(TestResourceUtil.openResource(testClass, resourceName));
+  }
 
-    public static byte[] isToBytes(InputStream is) throws IOException {
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        byte[] buffer = new byte[1024];
-        int read;
-        try {
-            while ((read = is.read(buffer)) != -1) {
-                os.write(buffer, 0, read);
-            }
-        } finally {
-            is.close();
-        }
-        return os.toByteArray();
+  public static byte[] isToBytes(InputStream is) throws IOException {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    byte[] buffer = new byte[1024];
+    int read;
+    try {
+      while ((read = is.read(buffer)) != -1) {
+        os.write(buffer, 0, read);
+      }
+    } finally {
+      is.close();
     }
+    return os.toByteArray();
+  }
 
-    public static String isToString(InputStream is) throws IOException {
-        return new String(isToBytes(is));
-    }
+  public static String isToString(InputStream is) throws IOException {
+    return new String(isToBytes(is));
+  }
 
+  public static void assertStreamOf(String expected, InputStream result) throws IOException {
+    assertThat(expected).isEqualTo(isToString(result));
+  }
 }
diff --git a/testutil/testutil.iml b/testutil/testutil.iml
deleted file mode 100644
index df334eef4..000000000
--- a/testutil/testutil.iml
+++ /dev/null
@@ -1,30 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":testutil" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":testutil" />
-      </configuration>
-    </facet>
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/classes/main" />
-    <output-test url="file://$MODULE_DIR$/build/classes/test" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-      <excludeFolder url="file://$MODULE_DIR$/build" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/third_party/disklrucache b/third_party/disklrucache
index 740db90bd..847e0dad0 160000
--- a/third_party/disklrucache
+++ b/third_party/disklrucache
@@ -1 +1 @@
-Subproject commit 740db90bd91a04aa6dff6e450c10755d130dded4
+Subproject commit 847e0dad08098c57e6dd12104463780e47e8e24e
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index be4a6b0c1..9857cf758 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -1,21 +1,22 @@
 apply plugin: 'com.android.library'
-apply plugin: 'robolectric'
+apply plugin: 'org.robolectric'
 
 dependencies {
-    androidTestCompile project(':testutil')
-    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    androidTestCompile "junit:junit:${JUNIT_VERSION}"
-    androidTestCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    androidTestCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+
+    testCompile project(':testutil')
+    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
-        applicationId 'com.bumptech.glide.gifdecoder'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
     }
diff --git a/third_party/gif_decoder/gif_decoder.iml b/third_party/gif_decoder/gif_decoder.iml
deleted file mode 100644
index afed21b75..000000000
--- a/third_party/gif_decoder/gif_decoder.iml
+++ /dev/null
@@ -1,112 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":third_party:gif_decoder" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.third_party" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":third_party:gif_decoder" />
-      </configuration>
-    </facet>
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="SELECTED_BUILD_VARIANT" value="debug" />
-        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
-        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
-        <option name="ALLOW_USER_CONFIGURATION" value="false" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
-        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
-        <option name="LIBRARY_PROJECT" value="true" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
-      <excludeFolder url="file://$MODULE_DIR$/build/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
-      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-report" />
-      <excludeFolder url="file://$MODULE_DIR$/build/test-results" />
-      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" exported="" scope="TEST" name="commons-codec-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-2.4" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="objenesis-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="robolectric-2.4" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="support-v4-19.1.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="vtd-xml-2.11" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-commons-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-core-1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="junit-4.11" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-tree-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-analysis-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="truth-0.24" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="mockito-all-1.9.5" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="ant-launcher-1.8.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="guava-17.0" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="asm-util-5.0.1" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />
-    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />
-    <orderEntry type="module" module-name="testutil" exported="" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/third_party/gif_decoder/lint.xml b/third_party/gif_decoder/lint.xml
index d9d6c9fff..ff7e5955c 100644
--- a/third_party/gif_decoder/lint.xml
+++ b/third_party/gif_decoder/lint.xml
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
-    <issue id="AllowBackup" severity="ignore" />
+    <issue id="AllowBackup" severity="ignore"/>
 </lint>
diff --git a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
deleted file mode 100644
index b3f35e076..000000000
--- a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package com.bumptech.glide.gifdecoder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.testutil.TestUtil;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-
-/**
- * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, emulateSdk = 18)
-public class GifDecoderTest {
-
-    private MockProvider provider;
-
-    @Before
-    public void setUp() {
-        provider = new MockProvider();
-    }
-
-    @Test
-    public void testCanDecodeFramesFromTestGif() throws IOException {
-        byte[] data = TestUtil.resourceToBytes(getClass(), "partial_gif_decode.gif");
-        GifHeaderParser headerParser = new GifHeaderParser();
-        headerParser.setData(data);
-        GifHeader header = headerParser.parseHeader();
-        GifDecoder decoder = new GifDecoder(provider);
-        decoder.setData(header, data);
-        decoder.advance();
-        Bitmap bitmap = decoder.getNextFrame();
-        assertNotNull(bitmap);
-        assertEquals(GifDecoder.STATUS_OK, decoder.getStatus());
-    }
-
-    @Test
-    public void testFrameIndexStartsAtNegativeOne() {
-        GifHeader gifheader = new GifHeader();
-        gifheader.frameCount = 4;
-        byte[] data = new byte[0];
-        GifDecoder decoder = new GifDecoder(provider);
-        decoder.setData(gifheader, data);
-        assertEquals(-1, decoder.getCurrentFrameIndex());
-    }
-
-    @Test
-    public void testAdvanceIncrementsFrameIndex() {
-        GifHeader gifheader = new GifHeader();
-        gifheader.frameCount = 4;
-        byte[] data = new byte[0];
-        GifDecoder decoder = new GifDecoder(provider);
-        decoder.setData(gifheader, data);
-        decoder.advance();
-        assertEquals(0, decoder.getCurrentFrameIndex());
-    }
-
-    @Test
-    public void testAdvanceWrapsIndexBackToZero() {
-        GifHeader gifheader = new GifHeader();
-        gifheader.frameCount = 2;
-        byte[] data = new byte[0];
-        GifDecoder decoder = new GifDecoder(provider);
-        decoder.setData(gifheader, data);
-        decoder.advance();
-        decoder.advance();
-        decoder.advance();
-        assertEquals(0, decoder.getCurrentFrameIndex());
-    }
-
-    @Test
-    public void testSettingDataResetsFramePointer() {
-        GifHeader gifheader = new GifHeader();
-        gifheader.frameCount = 4;
-        byte[] data = new byte[0];
-        GifDecoder decoder = new GifDecoder(provider);
-        decoder.setData(gifheader, data);
-        decoder.advance();
-        decoder.advance();
-        assertEquals(1, decoder.getCurrentFrameIndex());
-
-        decoder.setData(gifheader, data);
-        assertEquals(-1, decoder.getCurrentFrameIndex());
-    }
-
-    private static class MockProvider implements GifDecoder.BitmapProvider {
-
-        @Override
-        public Bitmap obtain(int width, int height, Bitmap.Config config) {
-            Bitmap result = Bitmap.createBitmap(width, height, config);
-            Robolectric.shadowOf(result).setMutable(true);
-            return result;
-        }
-
-        @Override
-        public void release(Bitmap bitmap) {
-            // Do nothing.
-        }
-    }
-}
diff --git a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
deleted file mode 100644
index 6f2807906..000000000
--- a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ /dev/null
@@ -1,228 +0,0 @@
-package com.bumptech.glide.gifdecoder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
-import com.bumptech.glide.testutil.TestUtil;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-
-/**
- * Tests for {@link com.bumptech.glide.gifdecoder.GifHeaderParser}.
- */
-@RunWith(JUnit4.class)
-public class GifHeaderParserTest {
-    private GifHeaderParser parser;
-
-    @Before
-    public void setUp() {
-        parser = new GifHeaderParser();
-    }
-
-    @Test
-    public void testReturnsHeaderWithFormatErrorIfDoesNotStartWithGifHeader() {
-        parser.setData("wrong_header".getBytes());
-        GifHeader result = parser.parseHeader();
-        assertEquals(GifDecoder.STATUS_FORMAT_ERROR, result.status);
-    }
-
-    @Test
-    public void testCanReadValidHeaderAndLSD() {
-        final int width = 10;
-        final int height = 20;
-        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH).order(ByteOrder.LITTLE_ENDIAN);
-        GifBytesTestUtil.writeHeaderAndLsd(buffer, width, height, false, 0);
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        assertEquals(width, header.width);
-        assertEquals(height, header.height);
-        assertFalse(header.gctFlag);
-        // 2^(1+0) == 2^1 == 2.
-        assertEquals(2, header.gctSize);
-        assertEquals(0, header.bgIndex);
-        assertEquals(0, header.pixelAspect);
-    }
-
-    @Test
-    public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOException {
-        byte[] data = TestUtil.resourceToBytes(getClass(), "gif_without_graphical_control_extension.gif");
-        parser.setData(data);
-        GifHeader header = parser.parseHeader();
-        assertEquals(1, header.frameCount);
-        assertNotNull(header.frames.get(0));
-        assertEquals(GifDecoder.STATUS_OK, header.status);
-    }
-
-    @Test
-    public void testCanReadImageDescriptorWithoutGraphicalExtension() {
-        final int lzwMinCodeSize = 2;
-        ByteBuffer buffer = ByteBuffer.allocate(
-                GifBytesTestUtil.HEADER_LENGTH
-                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize)
-        ).order(ByteOrder.LITTLE_ENDIAN);
-        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
-        GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        assertEquals(1, header.width);
-        assertEquals(1, header.height);
-        assertEquals(1, header.frameCount);
-        assertNotNull(header.frames.get(0));
-    }
-
-    private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {
-        final int lzwMinCodeSize = 2;
-        ByteBuffer buffer = ByteBuffer.allocate(
-                GifBytesTestUtil.HEADER_LENGTH
-                + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH
-                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize)
-        ).order(ByteOrder.LITTLE_ENDIAN);
-        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-        GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);
-        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
-        GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
-        return buffer;
-    }
-
-    @Test
-    public void testCanParseFrameDelay() {
-        final short frameDelay = 50;
-        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        GifFrame frame = header.frames.get(0);
-
-        // Convert delay in 100ths of a second to ms.
-        assertEquals(frameDelay * 10, frame.delay);
-    }
-
-    @Test
-    public void testSetsDefaultFrameDelayIfFrameDelayIsZero() {
-        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay((short) 0);
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        GifFrame frame = header.frames.get(0);
-
-        // Convert delay in 100ths of a second to ms.
-        assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);
-    }
-
-    @Test
-    public void testSetsDefaultFrameDelayIfFrameDelayIsLessThanMinimum() {
-        final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY - 1;
-        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        GifFrame frame = header.frames.get(0);
-
-        // Convert delay in 100ths of a second to ms.
-        assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);
-    }
-
-    @Test
-    public void testObeysFrameDelayIfFrameDelayIsAtMinimum() {
-        final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY;
-        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        GifFrame frame = header.frames.get(0);
-
-        // Convert delay in 100ths of a second to ms.
-        assertEquals(frameDelay * 10, frame.delay);
-    }
-
-    @Test
-    public void testSetsFrameLocalColorTableToNullIfNoColorTable() {
-        final int lzwMinCodeSize = 2;
-        ByteBuffer buffer = ByteBuffer.allocate(
-                GifBytesTestUtil.HEADER_LENGTH
-                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize)
-        ).order(ByteOrder.LITTLE_ENDIAN);
-        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
-        GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        assertEquals(1, header.width);
-        assertEquals(1, header.height);
-        assertEquals(1, header.frameCount);
-        assertNotNull(header.frames.get(0));
-        assertNull(header.frames.get(0).lct);
-    }
-
-    @Test
-    public void testSetsFrameLocalColorTableIfHasColorTable() {
-        final int lzwMinCodeSize = 2;
-        final int numColors = 4;
-        ByteBuffer buffer = ByteBuffer.allocate(
-                GifBytesTestUtil.HEADER_LENGTH
-                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize)
-                + GifBytesTestUtil.getColorTableLength(numColors)
-        ).order(ByteOrder.LITTLE_ENDIAN);
-        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, true /*hasLct*/, numColors);
-        GifBytesTestUtil.writeColorTable(buffer, numColors);
-        GifBytesTestUtil.writeFakeImageData(buffer, 2);
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        assertEquals(1, header.width);
-        assertEquals(1, header.height);
-        assertEquals(1, header.frameCount);
-        assertNotNull(header.frames.get(0));
-
-        GifFrame frame = header.frames.get(0);
-        assertNotNull(frame.lct);
-    }
-
-    @Test
-    public void testCanParseMultipleFrames() {
-        final int lzwMinCodeSize = 2;
-        final int expectedFrames = 3;
-
-        final int frameSize = GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
-        ByteBuffer buffer = ByteBuffer.allocate(
-                GifBytesTestUtil.HEADER_LENGTH + expectedFrames * frameSize
-        ).order(ByteOrder.LITTLE_ENDIAN);
-
-        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-        for (int i = 0; i < expectedFrames; i++) {
-            GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
-            GifBytesTestUtil.writeFakeImageData(buffer, 2);
-        }
-
-        parser.setData(buffer.array());
-        GifHeader header = parser.parseHeader();
-        assertEquals(expectedFrames, header.frameCount);
-        assertEquals(expectedFrames, header.frames.size());
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testThrowsIfParseHeaderCalledBeforeSetData() {
-        GifHeaderParser parser = new GifHeaderParser();
-        parser.parseHeader();
-    }
-}
\ No newline at end of file
diff --git a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
deleted file mode 100644
index b6f3140e5..000000000
--- a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
+++ /dev/null
@@ -1,145 +0,0 @@
-package com.bumptech.glide.gifdecoder.test;
-
-import java.nio.ByteBuffer;
-
-/**
- * Utils for writing the bytes of various parts of GIFs to byte buffers.
- */
-public class GifBytesTestUtil {
-    // Length in bytes.
-    public static final int HEADER_LENGTH = 13;
-    // Length in bytes.
-    public static final int IMAGE_DESCRIPTOR_LENGTH = 10;
-    // Length in bytes.
-    public static final int GRAPHICS_CONTROL_EXTENSION_LENGTH = 8;
-
-    public static int getColorTableLength(int numColors) {
-        return 3 * numColors;
-    }
-
-    public static int getImageDataSize(int lzwMinCodeSize) {
-        // TODO: fill this out.
-        return 4;
-    }
-
-    public static void writeFakeImageData(ByteBuffer out, int lzwMinCodeSize) {
-        // 1 for lzwMinCodeSize, 1 for length, 1 for min content, 1 for block terminator.
-        verifyRemaining(out, 4);
-        verifyShortValues(lzwMinCodeSize);
-
-        out.put((byte) lzwMinCodeSize);
-        // Block length.
-        out.put((byte) 0x01);
-        // Block content.
-        out.put((byte) 0x01);
-        // End of block.
-        out.put((byte) 0x00);
-    }
-
-    public static void writeColorTable(ByteBuffer out, int numColors) {
-        verifyRemaining(out, getColorTableLength(numColors));
-        for (int i = 0; i < numColors; i++) {
-            out.put((byte) (0xFF0000 & i));
-            out.put((byte) (0x00FF00 & i));
-            out.put((byte) (0x0000FF & i));
-        }
-    }
-
-    public static void writeImageDescriptor(ByteBuffer out, int imageLeft, int imageTop, int imageWidth,
-            int imageHeight, boolean hasLct, int numColors) {
-        verifyRemaining(out, IMAGE_DESCRIPTOR_LENGTH);
-        verifyShortValues(imageLeft, imageTop, imageWidth, imageHeight);
-
-        final byte packed;
-        if (hasLct) {
-            int size = log2(numColors) - 1;
-            packed = (byte) (0x80 | size);
-        } else {
-            packed = 0x00;
-        }
-
-        // Image separator
-        out.put((byte) 0x2C);
-        out
-                .putShort((short) imageLeft)
-                .putShort((short) imageTop)
-                .putShort((short) imageWidth)
-                .putShort((short) imageHeight)
-                .put(packed);
-    }
-
-    private static int log2(int num) {
-        return (int) Math.round(Math.log(num) / Math.log(2));
-    }
-
-    public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, boolean hasGct, int gctSize) {
-        verifyRemaining(out, HEADER_LENGTH);
-        verifyShortValues(width, height);
-
-        // GIF
-        out.put((byte) 0x47).put((byte) 0x49).put((byte) 0x46);
-        // Version - 89a.
-        out.put((byte) 0x38).put((byte) 0x39).put((byte) 0x61);
-
-        /** LSD (Logical Screen Descriptor) **/
-          // Width.
-        out.putShort((short) width);
-        // Height.
-        out.putShort((short) height);
-        // Packed GCT (Global Color Table) flag + color resolution + sort flag + size of GCT.
-        // GCT flag (false) - most significant bit.
-        byte gctFlag = (byte) ((hasGct ? 1 : 0) << 7);
-        // Color resolution - next three bits.
-        byte colorResolution = 1 << 5;
-        // Sort flag - next bit;
-        byte sortFlag = 0 << 4;
-        // exponent of size of color table, size = 2^(1 + exponent) - least significant 3 bits.
-        byte size = (byte) gctSize;
-
-        byte packed = (byte) (gctFlag | colorResolution | sortFlag | size);
-        out.put(packed);
-
-        // Background color index.
-        out.put((byte) 0);
-
-        // Pixel aspect ratio.
-        out.put((byte) 0);
-    }
-
-    public static void writeGraphicsControlExtension(ByteBuffer out, int delayTime) {
-        verifyRemaining(out, GRAPHICS_CONTROL_EXTENSION_LENGTH);
-        verifyShortValues(delayTime);
-
-        // Extension inducer (constant).
-        out.put((byte) 0x21);
-        // Graphic control label (constant).
-        out.put((byte) 0xF9);
-        // Block size (constant).
-        out.put((byte) 0x04);
-        // Packed (disposal method, user input, transparent color flag)
-        out.put((byte) 0x00);
-
-        // Frame delay in 100ths of a second.
-        out.putShort((short) delayTime);
-
-        // Transparent color index.
-        out.put((byte) 0x00);
-
-        // Block terminator (constant).
-        out.put((byte) 0x00);
-    }
-
-    private static void verifyRemaining(ByteBuffer buffer, int expected) {
-        if (buffer.remaining() < expected) {
-            throw new IllegalArgumentException("Must have at least " + expected + " bytes to write");
-        }
-    }
-
-    private static void verifyShortValues(int... shortValues) {
-        for (int dimen : shortValues) {
-            if (dimen > Short.MAX_VALUE || dimen < 0) {
-                throw new IllegalArgumentException("Must pass in non-negative short dimensions, not: " + dimen);
-            }
-        }
-    }
-}
diff --git a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
deleted file mode 100644
index 64a12db02..000000000
--- a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
+++ /dev/null
@@ -1,151 +0,0 @@
-package com.bumptech.glide.gifdecoder.test;
-
-import static org.junit.Assert.assertArrayEquals;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-
-/**
- * Tests for {@link com.bumptech.glide.gifdecoder.test.GifBytesTestUtil}.
- */
-@RunWith(JUnit4.class)
-public class GifBytesTestUtilTest {
-
-    @Test
-    public void testWriteHeaderAndLsdWithoutGct() {
-        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH);
-        GifBytesTestUtil.writeHeaderAndLsd(buffer, 8, 16, false, 0);
-
-        byte[] expected = new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00, 0x08, 0x00, 0x10, 0x20, 0x00, 0x00};
-
-        assertEquals(expected, buffer);
-    }
-
-    @Test
-    public void testWriteHeaderAndLsdWithGct() {
-        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH);
-        GifBytesTestUtil.writeHeaderAndLsd(buffer, 8, 16, true, 4);
-
-        byte[] expected = new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00, 0x08, 0x00, 0x10, (byte) 0xA4, 0x00,
-                0x00};
-
-        assertEquals(expected, buffer);
-    }
-
-    @Test
-    public void testWriteImageDescriptorWithoutColorTable() {
-        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH);
-        GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7, false, 0);
-
-        byte[] expected = new byte[] {
-                // Image separator.
-                0x2C,
-                // Image left.
-                0x00, 0x0A,
-                // Image right.
-                0x00, 0X09,
-                // Image width.
-                0x00, 0x08,
-                // Image height.
-                0x00, 0x07,
-                // Packed field.
-                0x00
-        };
-
-        assertEquals(expected, buffer);
-    }
-
-    @Test
-    public void testWriteImageDescriptorWithColorTable() {
-        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH);
-        GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7, true, 4);
-
-        byte packedField =
-                // Set LCT flag
-                (byte) 0x80
-                // Size of color table (2^(N + 1) == 4)
-                | 0x01;
-
-        byte[] expected = new byte[] {
-                // Image separator.
-                0x2C,
-                // Image left.
-                0x00, 0x0A,
-                // Image right.
-                0x00, 0X09,
-                // Image width.
-                0x00, 0x08,
-                // Image height.
-                0x00, 0x07,
-                packedField
-        };
-
-        assertEquals(expected, buffer);
-    }
-
-    @Test
-    public void testWriteColorTable() {
-        final int numColors = 4;
-        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.getColorTableLength(numColors));
-        GifBytesTestUtil.writeColorTable(buffer, numColors);
-
-        byte[] expected = new byte[] {
-                // First color.
-                0x00, 0x00, 0x00,
-                // Second color.
-                0x00, 0x00, 0x01,
-                // Third color.
-                0x00, 0x00, 0x02,
-                // Fourth color.
-                0x00, 0x00, 0x03,
-        };
-
-
-        assertEquals(expected, buffer);
-    }
-
-    @Test
-    public void testWriteFakeImageData() {
-        ByteBuffer buffer = ByteBuffer.allocate(4);
-        GifBytesTestUtil.writeFakeImageData(buffer, 2);
-
-        byte[] expected = new byte[] { 0x02, 0x01, 0x01, 0x00 };
-
-        assertEquals(expected, buffer);
-    }
-
-    @Test
-    public void testWritesGraphicsControlExtension() {
-        short delay = 20;
-        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH);
-        byte[] expected = new byte[] {
-                // Extension inducer.
-                0x21,
-                // Graphic control label.
-                (byte) 0xF9,
-                // Block size.
-                0x04,
-                // Packed byte.
-                0x00,
-                // Frame delay.
-                0x00,
-                0x14,
-                // Transparent color index.
-                0x00,
-                // block terminator.
-                0x00
-        };
-
-        GifBytesTestUtil.writeGraphicsControlExtension(buffer, delay);
-        assertEquals(expected, buffer);
-    }
-
-    private static void assertEquals(byte[] expected, ByteBuffer buffer) {
-        assertArrayEquals("expected=" + Arrays.toString(expected) + " received=" + Arrays.toString(buffer.array()),
-                expected, buffer.array());
-    }
-}
diff --git a/third_party/gif_decoder/src/main/AndroidManifest.xml b/third_party/gif_decoder/src/main/AndroidManifest.xml
index 2f91b04ef..bafd13c3b 100644
--- a/third_party/gif_decoder/src/main/AndroidManifest.xml
+++ b/third_party/gif_decoder/src/main/AndroidManifest.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.bumptech.glide.gifdecoder">
-  <application />
+
+    <application/>
 </manifest>
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index c4b4281d8..a6defca35 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.gifdecoder;
 
-
 /**
  * Copyright (c) 2013 Xcellent Creations, Inc.
  *
@@ -27,6 +26,8 @@
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 import java.io.ByteArrayOutputStream;
@@ -37,666 +38,822 @@
 import java.util.Arrays;
 
 /**
- * Reads frame data from a GIF image source and decodes it into individual frames
- * for animation purposes.  Image data can be read from either and InputStream source
- * or a byte[].
+ * Reads frame data from a GIF image source and decodes it into individual frames for animation
+ * purposes.  Image data can be read from either and InputStream source or a byte[].
  *
- * This class is optimized for running animations with the frames, there
- * are no methods to get individual frame images, only to decode the next frame in the
- * animation sequence.  Instead, it lowers its memory footprint by only housing the minimum
- * data necessary to decode the next frame in the animation sequence.
+ * <p>This class is optimized for running animations with the frames, there are no methods to get
+ * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
+ * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
+ * in the animation sequence.
  *
- * The animation must be manually moved forward using {@link #advance()} before requesting the next
- * frame.  This method must also be called before you request the first frame or an error will
- * occur.
+ * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
+ * next frame.  This method must also be called before you request the first frame or an error
+ * will occur.
  *
- * Implementation adapted from sample code published in Lyons. (2004). <em>Java for Programmers</em>,
- * republished under the MIT Open Source License
+ * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
+ * Programmers</em>, republished under the MIT Open Source License
  */
 public class GifDecoder {
-    private static final String TAG = GifDecoder.class.getSimpleName();
-
-    /**
-     * File read status: No errors.
-     */
-    public static final int STATUS_OK = 0;
-    /**
-     * File read status: Error decoding file (may be partially decoded).
-     */
-    public static final int STATUS_FORMAT_ERROR = 1;
-    /**
-     * File read status: Unable to open source.
-     */
-    public static final int STATUS_OPEN_ERROR = 2;
+  private static final String TAG = GifDecoder.class.getSimpleName();
+
+  /**
+   * File read status: No errors.
+   */
+  public static final int STATUS_OK = 0;
+  /**
+   * File read status: Error decoding file (may be partially decoded).
+   */
+  public static final int STATUS_FORMAT_ERROR = 1;
+  /**
+   * File read status: Unable to open source.
+   */
+  public static final int STATUS_OPEN_ERROR = 2;
+  /**
+   * Unable to fully decode the current frame.
+   */
+  public static final int STATUS_PARTIAL_DECODE = 3;
+  /**
+   * max decoder pixel stack size.
+   */
+  private static final int MAX_STACK_SIZE = 4096;
+
+  /**
+   * GIF Disposal Method meaning take no action.
+   */
+  private static final int DISPOSAL_UNSPECIFIED = 0;
+  /**
+   * GIF Disposal Method meaning leave canvas from previous frame.
+   */
+  private static final int DISPOSAL_NONE = 1;
+  /**
+   * GIF Disposal Method meaning clear canvas to background color.
+   */
+  private static final int DISPOSAL_BACKGROUND = 2;
+  /**
+   * GIF Disposal Method meaning clear canvas to frame before last.
+   */
+  private static final int DISPOSAL_PREVIOUS = 3;
+
+  private static final int NULL_CODE = -1;
+
+  private static final int INITIAL_FRAME_POINTER = -1;
+
+  private static final int BYTES_PER_INTEGER = 4;
+
+  // Global File Header values and parsing flags.
+  // Active color table.
+  private int[] act;
+
+  // Raw GIF data from input source.
+  private ByteBuffer rawData;
+
+  // Raw data read working array.
+  private byte[] block;
+
+  // Temporary buffer for block reading. Reads 16k chunks from the native buffer for processing,
+  // to greatly reduce JNI overhead.
+  private static final int WORK_BUFFER_SIZE = 16384;
+  @Nullable private byte[] workBuffer;
+  private int workBufferSize = 0;
+  private int workBufferPosition = 0;
+
+  private GifHeaderParser parser;
+
+  // LZW decoder working arrays.
+  private short[] prefix;
+  private byte[] suffix;
+  private byte[] pixelStack;
+  private byte[] mainPixels;
+  private int[] mainScratch;
+
+  private int framePointer;
+  private GifHeader header;
+  private BitmapProvider bitmapProvider;
+  private Bitmap previousImage;
+  private boolean savePrevious;
+  private int status;
+  private int sampleSize;
+  private int downsampledHeight;
+  private int downsampledWidth;
+  private boolean isFirstFrameTransparent;
+
+  /**
+   * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
+   * from constantly allocating {@link android.graphics.Bitmap}s for every frame.
+   */
+  public interface BitmapProvider {
     /**
-     * Unable to fully decode the current frame.
+     * Returns an {@link Bitmap} with exactly the given dimensions and config.
+     *
+     * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
+     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
+     * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
+     *               android.graphics.Bitmap}.
      */
-    public static final int STATUS_PARTIAL_DECODE = 3;
+    @NonNull
+    Bitmap obtain(int width, int height, Bitmap.Config config);
+
     /**
-     * max decoder pixel stack size.
+     * Releases the given Bitmap back to the pool.
      */
-    private static final int MAX_STACK_SIZE = 4096;
+    void release(Bitmap bitmap);
 
     /**
-     * GIF Disposal Method meaning take no action.
+     * Returns a byte array used for decoding and generating the frame bitmap.
+     *
+     * @param size the size of the byte array to obtain
      */
-    private static final int DISPOSAL_UNSPECIFIED = 0;
+    byte[] obtainByteArray(int size);
+
     /**
-     * GIF Disposal Method meaning leave canvas from previous frame.
+     * Releases the given byte array back to the pool.
      */
-    private static final int DISPOSAL_NONE = 1;
+    void release(byte[] bytes);
+
     /**
-     * GIF Disposal Method meaning clear canvas to background color.
+     * Returns an int array used for decoding/generating the frame bitmaps.
+     * @param size
      */
-    private static final int DISPOSAL_BACKGROUND = 2;
+    int[] obtainIntArray(int size);
+
     /**
-     * GIF Disposal Method meaning clear canvas to frame before last.
+     * Release the given array back to the pool.
+     * @param array
      */
-    private static final int DISPOSAL_PREVIOUS = 3;
-
-    private static final int NULL_CODE = -1;
-
-    private static final int INITIAL_FRAME_POINTER = -1;
-
-    // We can't tell if a gif has transparency to decode a partial frame on top of a previous frame, or if the final
-    // frame will actually have transparent pixels, so we must always use a format that supports transparency. We can't
-    // use ARGB_4444 because of framework issues drawing onto ARGB_4444 Bitmaps using Canvas.
-    private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;
-
-    // Global File Header values and parsing flags.
-    // Active color table.
-    private int[] act;
-
-    // Raw GIF data from input source.
-    private ByteBuffer rawData;
+    void release(int[] array);
+  }
+
+  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
+  }
+
+  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      int sampleSize) {
+    this(provider);
+    setData(gifHeader, rawData, sampleSize);
+  }
+
+  public GifDecoder(BitmapProvider provider) {
+    this.bitmapProvider = provider;
+    header = new GifHeader();
+  }
+
+  public int getWidth() {
+    return header.width;
+  }
+
+  public int getHeight() {
+    return header.height;
+  }
+
+  public ByteBuffer getData() {
+    return rawData;
+  }
+
+  /**
+   * Returns the current status of the decoder.
+   *
+   * <p> Status will update per frame to allow the caller to tell whether or not the current frame
+   * was decoded successfully and/or completely. Format and open failures persist across frames.
+   * </p>
+   */
+  public int getStatus() {
+    return status;
+  }
+
+  /**
+   * Move the animation frame counter forward.
+   */
+  public void advance() {
+    framePointer = (framePointer + 1) % header.frameCount;
+  }
+
+  /**
+   * Gets display duration for specified frame.
+   *
+   * @param n int index of frame.
+   * @return delay in milliseconds.
+   */
+  public int getDelay(int n) {
+    int delay = -1;
+    if ((n >= 0) && (n < header.frameCount)) {
+      delay = header.frames.get(n).delay;
+    }
+    return delay;
+  }
+
+  /**
+   * Gets display duration for the upcoming frame in ms.
+   */
+  public int getNextDelay() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      return 0;
+    }
 
-    // Raw data read working array.
-    private final byte[] block = new byte[256];
+    return getDelay(framePointer);
+  }
+
+  /**
+   * Gets the number of frames read from file.
+   *
+   * @return frame count.
+   */
+  public int getFrameCount() {
+    return header.frameCount;
+  }
+
+  /**
+   * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
+   *
+   * @return frame index.
+   */
+  public int getCurrentFrameIndex() {
+    return framePointer;
+  }
+
+  /**
+   * Resets the frame pointer to before the 0th frame, as if we'd never used this decoder to
+   * decode any frames.
+   */
+  public void resetFrameIndex() {
+    framePointer = INITIAL_FRAME_POINTER;
+  }
+
+  /**
+   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
+   *
+   * @return iteration count if one was specified, else 1.
+   */
+  public int getLoopCount() {
+    return header.loopCount;
+  }
+
+  /**
+   * Returns an estimated byte size for this decoder based on the data provided to {@link
+   * #setData(GifHeader, byte[])}, as well as internal buffers.
+   */
+  public int getByteSize() {
+    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
+  }
+
+  /**
+   * Get the next frame in the animation sequence.
+   *
+   * @return Bitmap representation of frame.
+   */
+  public synchronized Bitmap getNextFrame() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
+            + framePointer);
+      }
+      status = STATUS_FORMAT_ERROR;
+    }
+    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame, status=" + status);
+      }
+      return null;
+    }
+    status = STATUS_OK;
+
+    GifFrame currentFrame = header.frames.get(framePointer);
+    GifFrame previousFrame;
+    int previousIndex = framePointer - 1;
+    if (previousIndex >= 0) {
+      previousFrame = header.frames.get(previousIndex);
+    } else {
+      previousFrame = header.frames.get(getFrameCount() - 1);
+    }
 
-    private GifHeaderParser parser;
+    final int savedBgColor = header.bgColor;
 
-    // LZW decoder working arrays.
-    private short[] prefix;
-    private byte[] suffix;
-    private byte[] pixelStack;
-    private byte[] mainPixels;
-    private int[] mainScratch;
+    // Set the appropriate color table.
+    if (currentFrame.lct == null) {
+      act = header.gct;
+    } else {
+      act = currentFrame.lct;
+      if (header.bgIndex == currentFrame.transIndex) {
+        header.bgColor = 0;
+      }
+    }
 
-    private int framePointer;
-    private byte[] data;
-    private GifHeader header;
-    private BitmapProvider bitmapProvider;
-    private Bitmap previousImage;
-    private boolean savePrevious;
-    private int status;
+    int save = 0;
+    if (currentFrame.transparency) {
+      save = act[currentFrame.transIndex];
+      // Set transparent color if specified.
+      act[currentFrame.transIndex] = 0;
+    }
+    if (act == null) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "No Valid Color Table");
+      }
+      // No color table defined.
+      status = STATUS_FORMAT_ERROR;
+      return null;
+    }
 
-    /**
-     * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs from constantly
-     * allocating {@link android.graphics.Bitmap}s for every frame.
-     */
-    public interface BitmapProvider {
-        /**
-         * Returns an {@link Bitmap} with exactly the given dimensions and config, or null if no such {@link Bitmap}
-         * could be obtained.
-         *
-         * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
-         * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
-         * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link android.graphics.Bitmap}.
-         */
-        public Bitmap obtain(int width, int height, Bitmap.Config config);
+    // Transfer pixel data to image.
+    Bitmap result = setPixels(currentFrame, previousFrame);
 
-        /**
-         * Releases the given Bitmap back to the pool.
-         */
-        public void release(Bitmap bitmap);
+    // Reset the transparent pixel in the color table
+    if (currentFrame.transparency) {
+      act[currentFrame.transIndex] = save;
     }
-
-    public GifDecoder(BitmapProvider provider) {
-        this.bitmapProvider = provider;
-        header = new GifHeader();
+    header.bgColor = savedBgColor;
+
+    return result;
+  }
+
+  /**
+   * Reads GIF image from stream.
+   *
+   * @param is containing GIF file.
+   * @return read status code (0 = no errors).
+   */
+  public int read(InputStream is, int contentLength) {
+    if (is != null) {
+      try {
+        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
+        int nRead;
+        byte[] data = new byte[16384];
+        while ((nRead = is.read(data, 0, data.length)) != -1) {
+          buffer.write(data, 0, nRead);
+        }
+        buffer.flush();
+
+        read(buffer.toByteArray());
+      } catch (IOException e) {
+        Log.w(TAG, "Error reading data from stream", e);
+      }
+    } else {
+      status = STATUS_OPEN_ERROR;
     }
 
-    public int getWidth() {
-        return header.width;
+    try {
+      if (is != null) {
+        is.close();
+      }
+    } catch (IOException e) {
+      Log.w(TAG, "Error closing stream", e);
     }
 
-    public int getHeight() {
-        return header.height;
-    }
+    return status;
+  }
 
-    public byte[] getData() {
-        return data;
+  public void clear() {
+    header = null;
+    if (mainPixels != null) {
+      bitmapProvider.release(mainPixels);
     }
-
-    /**
-     * Returns the current status of the decoder.
-     *
-     * <p>
-     *     Status will update per frame to allow the caller to tell whether or not the current frame was decoded
-     *     successfully and/or completely. Format and open failures persist across frames.
-     * </p>
-     */
-    public int getStatus() {
-        return status;
+    if (mainScratch != null) {
+      bitmapProvider.release(mainScratch);
     }
-
-    /**
-     * Move the animation frame counter forward.
-     */
-    public void advance() {
-        framePointer = (framePointer + 1) % header.frameCount;
+    if (previousImage != null) {
+      bitmapProvider.release(previousImage);
     }
-
-    /**
-     * Gets display duration for specified frame.
-     *
-     * @param n int index of frame.
-     * @return delay in milliseconds.
-     */
-    public int getDelay(int n) {
-        int delay = -1;
-        if ((n >= 0) && (n < header.frameCount)) {
-            delay = header.frames.get(n).delay;
-        }
-        return delay;
+    previousImage = null;
+    rawData = null;
+    isFirstFrameTransparent = false;
+    if (block != null) {
+      bitmapProvider.release(block);
+    }
+    if (workBuffer != null) {
+      bitmapProvider.release(workBuffer);
     }
+  }
 
-    /**
-     * Gets display duration for the upcoming frame in ms.
-     */
-    public int getNextDelay() {
-        if (header.frameCount <= 0 || framePointer < 0) {
-            return -1;
-        }
+  public synchronized void setData(GifHeader header, byte[] data) {
+    setData(header, ByteBuffer.wrap(data));
+  }
 
-        return getDelay(framePointer);
-    }
+  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
+    setData(header, buffer, 1);
+  }
 
-    /**
-     * Gets the number of frames read from file.
-     *
-     * @return frame count.
-     */
-    public int getFrameCount() {
-        return header.frameCount;
+  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
+    if (sampleSize <= 0) {
+      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
     }
-
-    /**
-     * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
-     *
-     * @return frame index.
-     */
-    public int getCurrentFrameIndex() {
-        return framePointer;
+    // Make sure sample size is a power of 2.
+    sampleSize = Integer.highestOneBit(sampleSize);
+    this.status = STATUS_OK;
+    this.header = header;
+    isFirstFrameTransparent = false;
+    framePointer = INITIAL_FRAME_POINTER;
+    // Initialize the raw data buffer.
+    rawData = buffer.asReadOnlyBuffer();
+    rawData.position(0);
+    rawData.order(ByteOrder.LITTLE_ENDIAN);
+
+    // No point in specially saving an old frame if we're never going to use it.
+    savePrevious = false;
+    for (GifFrame frame : header.frames) {
+      if (frame.dispose == DISPOSAL_PREVIOUS) {
+        savePrevious = true;
+        break;
+      }
     }
 
-    public void resetFrameIndex() {
-        framePointer = -1;
+    this.sampleSize = sampleSize;
+    // Now that we know the size, init scratch arrays.
+    // TODO: Find a way to avoid this entirely or at least downsample it
+    // (either should be possible).
+    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
+    mainScratch =
+        bitmapProvider.obtainIntArray((header.width / sampleSize) * (header.height / sampleSize));
+    downsampledWidth = header.width / sampleSize;
+    downsampledHeight = header.height / sampleSize;
+  }
+
+  private GifHeaderParser getHeaderParser() {
+    if (parser == null) {
+      parser = new GifHeaderParser();
     }
-
-    /**
-     * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
-     *
-     * @return iteration count if one was specified, else 1.
-     */
-    public int getLoopCount() {
-        return header.loopCount;
+    return parser;
+  }
+
+  /**
+   * Reads GIF image from byte array.
+   *
+   * @param data containing GIF file.
+   * @return read status code (0 = no errors).
+   */
+  public synchronized int read(byte[] data) {
+    this.header = getHeaderParser().setData(data).parseHeader();
+    if (data != null) {
+      setData(header, data);
     }
 
-    /**
-     * Get the next frame in the animation sequence.
-     *
-     * @return Bitmap representation of frame.
-     */
-    public synchronized Bitmap getNextFrame() {
-        if (header.frameCount <= 0 || framePointer < 0) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer=" + framePointer);
-            }
-            status = STATUS_FORMAT_ERROR;
-        }
-        if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Unable to decode frame, status=" + status);
-            }
-            return null;
-        }
-        status = STATUS_OK;
-
-        GifFrame currentFrame = header.frames.get(framePointer);
-        GifFrame previousFrame = null;
-        int previousIndex = framePointer - 1;
-        if (previousIndex >= 0) {
-            previousFrame = header.frames.get(previousIndex);
-        }
-
-        // Set the appropriate color table.
-        if (currentFrame.lct == null) {
-            act = header.gct;
-        } else {
-            act = currentFrame.lct;
-            if (header.bgIndex == currentFrame.transIndex) {
-                header.bgColor = 0;
-            }
+    return status;
+  }
+
+  /**
+   * Creates new frame image from current data (and previous frames as specified by their
+   * disposition codes).
+   */
+  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
+    // Final location of blended pixels.
+    final int[] dest = mainScratch;
+
+    // fill in starting image contents based on last image's dispose code
+    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
+      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
+      // mainScratch and therefore so will our dest array.
+      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
+        // Start with a canvas filled with the background color
+        int c = 0;
+        if (!currentFrame.transparency) {
+          c = header.bgColor;
+        } else if (framePointer == 0) {
+          // TODO: We should check and see if all individual pixels are replaced. If they are, the
+          // first frame isn't actually transparent. For now, it's simpler and safer to assume
+          // drawing a transparent background means the GIF contains transparency.
+          isFirstFrameTransparent = true;
         }
+        Arrays.fill(dest, c);
+      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
+        // Start with the previous frame
+        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+            downsampledHeight);
+      }
+    }
 
-        int save = 0;
-        if (currentFrame.transparency) {
-            save = act[currentFrame.transIndex];
-            // Set transparent color if specified.
-            act[currentFrame.transIndex] = 0;
+    // Decode pixels for this frame  into the global pixels[] scratch.
+    decodeBitmapData(currentFrame);
+
+    int downsampledIH = currentFrame.ih / sampleSize;
+    int downsampledIY = currentFrame.iy / sampleSize;
+    int downsampledIW = currentFrame.iw / sampleSize;
+    int downsampledIX = currentFrame.ix / sampleSize;
+    // Copy each source line to the appropriate place in the destination.
+    int pass = 1;
+    int inc = 8;
+    int iline = 0;
+    boolean isFirstFrame = framePointer == 0;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i;
+      if (currentFrame.interlace) {
+        if (iline >= downsampledIH) {
+          pass++;
+          switch (pass) {
+            case 2:
+              iline = 4;
+              break;
+            case 3:
+              iline = 2;
+              inc = 4;
+              break;
+            case 4:
+              iline = 1;
+              inc = 2;
+              break;
+            default:
+              break;
+          }
         }
-        if (act == null) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "No Valid Color Table");
-            }
-            // No color table defined.
-            status = STATUS_FORMAT_ERROR;
-            return null;
+        line = iline;
+        iline += inc;
+      }
+      line += downsampledIY;
+      if (line < downsampledHeight) {
+        int k = line * downsampledWidth;
+        // Start of line in dest.
+        int dx = k + downsampledIX;
+        // End of dest line.
+        int dlim = dx + downsampledIW;
+        if (k + downsampledWidth < dlim) {
+          // Past dest edge.
+          dlim = k + downsampledWidth;
         }
-
-        // Transfer pixel data to image.
-        Bitmap result = setPixels(currentFrame, previousFrame);
-
-        // Reset the transparent pixel in the color table
-        if (currentFrame.transparency) {
-            act[currentFrame.transIndex] = save;
+        // Start of line in source.
+        int sx = i * sampleSize * currentFrame.iw;
+        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+        while (dx < dlim) {
+          // Map color and insert in destination.
+          int averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+          if (averageColor != 0) {
+            dest[dx] = averageColor;
+          } else if (!isFirstFrameTransparent && isFirstFrame) {
+            isFirstFrameTransparent = true;
+          }
+          sx += sampleSize;
+          dx++;
         }
-
-        return result;
+      }
     }
 
-    /**
-     * Reads GIF image from stream.
-     *
-     * @param is containing GIF file.
-     * @return read status code (0 = no errors).
-     */
-    public int read(InputStream is, int contentLength) {
-        if (is != null) {
-            try {
-                int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
-                ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
-                int nRead;
-                byte[] data = new byte[16384];
-                while ((nRead = is.read(data, 0, data.length)) != -1) {
-                    buffer.write(data, 0, nRead);
-                }
-                buffer.flush();
-
-                read(buffer.toByteArray());
-            } catch (IOException e) {
-                Log.w(TAG, "Error reading data from stream", e);
-            }
-        } else {
-            status = STATUS_OPEN_ERROR;
-        }
-
-        try {
-            if (is != null) {
-                is.close();
-            }
-        } catch (IOException e) {
-            Log.w(TAG, "Error closing stream", e);
-        }
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
 
-        return status;
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
+      int currentFrameIw) {
+    int alphaSum = 0;
+    int redSum = 0;
+    int greenSum = 0;
+    int blueSum = 0;
+
+    int totalAdded = 0;
+    // Find the pixels in the current row.
+    for (int i = positionInMainPixels;
+        i < positionInMainPixels + sampleSize && i < mainPixels.length
+        && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & 0x000000ff;
+        redSum += currentColor >> 16 & 0x000000ff;
+        greenSum += currentColor >> 8 & 0x000000ff;
+        blueSum += currentColor & 0x000000ff;
+        totalAdded++;
+      }
+    }
+    // Find the pixels in the next row.
+    for (int i = positionInMainPixels + currentFrameIw;
+        i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
+        && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & 0x000000ff;
+        redSum += currentColor >> 16 & 0x000000ff;
+        greenSum += currentColor >> 8 & 0x000000ff;
+        blueSum += currentColor & 0x000000ff;
+        totalAdded++;
+      }
+    }
+    if (totalAdded == 0) {
+      return 0;
+    } else {
+      return ((alphaSum / totalAdded) << 24)
+          | ((redSum / totalAdded) << 16)
+          | ((greenSum / totalAdded) << 8)
+          | (blueSum / totalAdded);
+     }
+  }
+
+  /**
+   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
+   */
+  private void decodeBitmapData(GifFrame frame) {
+    workBufferSize = 0;
+    workBufferPosition = 0;
+    if (frame != null) {
+      // Jump to the frame start position.
+      rawData.position(frame.bufferFrameStart);
     }
 
-    public void clear() {
-        header = null;
-        data = null;
-        mainPixels = null;
-        mainScratch = null;
-        if (previousImage != null) {
-            bitmapProvider.release(previousImage);
-        }
-        previousImage = null;
-    }
-
-    public void setData(GifHeader header, byte[] data) {
-        this.header = header;
-        this.data = data;
-        this.status = STATUS_OK;
-        framePointer = INITIAL_FRAME_POINTER;
-        // Initialize the raw data buffer.
-        rawData = ByteBuffer.wrap(data);
-        rawData.rewind();
-        rawData.order(ByteOrder.LITTLE_ENDIAN);
-
-
-        // No point in specially saving an old frame if we're never going to use it.
-        savePrevious = false;
-        for (GifFrame frame : header.frames) {
-            if (frame.dispose == DISPOSAL_PREVIOUS) {
-                savePrevious = true;
-                break;
-            }
-        }
+    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
+    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
+        i, datum,
+        dataSize, first, top, bi, pi;
 
-        // Now that we know the size, init scratch arrays.
-        mainPixels = new byte[header.width * header.height];
-        mainScratch = new int[header.width * header.height];
+    if (mainPixels == null || mainPixels.length < npix) {
+      // Allocate new pixel array.
+      mainPixels = bitmapProvider.obtainByteArray(npix);
     }
-
-    private GifHeaderParser getHeaderParser() {
-        if (parser == null) {
-            parser = new GifHeaderParser();
-        }
-        return parser;
+    if (prefix == null) {
+      prefix = new short[MAX_STACK_SIZE];
+    }
+    if (suffix == null) {
+      suffix = new byte[MAX_STACK_SIZE];
+    }
+    if (pixelStack == null) {
+      pixelStack = new byte[MAX_STACK_SIZE + 1];
     }
 
-    /**
-     * Reads GIF image from byte array.
-     *
-     * @param data containing GIF file.
-     * @return read status code (0 = no errors).
-     */
-    public int read(byte[] data) {
-        this.data = data;
-        this.header = getHeaderParser().setData(data).parseHeader();
-        if (data != null) {
-            // Initialize the raw data buffer.
-            rawData = ByteBuffer.wrap(data);
-            rawData.rewind();
-            rawData.order(ByteOrder.LITTLE_ENDIAN);
-
-            // Now that we know the size, init scratch arrays.
-            mainPixels = new byte[header.width * header.height];
-            mainScratch = new int[header.width * header.height];
-
-            // No point in specially saving an old frame if we're never going to use it.
-            savePrevious = false;
-            for (GifFrame frame : header.frames) {
-                if (frame.dispose == DISPOSAL_PREVIOUS) {
-                    savePrevious = true;
-                    break;
-                }
-            }
-        }
-
-        return status;
+    // Initialize GIF data stream decoder.
+    dataSize = readByte();
+    clear = 1 << dataSize;
+    endOfInformation = clear + 1;
+    available = clear + 2;
+    oldCode = NULL_CODE;
+    codeSize = dataSize + 1;
+    codeMask = (1 << codeSize) - 1;
+    for (code = 0; code < clear; code++) {
+      // XXX ArrayIndexOutOfBoundsException.
+      prefix[code] = 0;
+      suffix[code] = (byte) code;
     }
 
-    /**
-     * Creates new frame image from current data (and previous frames as specified by their disposition codes).
-     */
-    private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
-
-        int width = header.width;
-        int height = header.height;
-
-        // Final location of blended pixels.
-        final int[] dest = mainScratch;
-
-        // fill in starting image contents based on last image's dispose code
-        if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
-            // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our mainScratch
-            // and therefore so will our dest array.
-            if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
-                // Start with a canvas filled with the background color
-                int c = 0;
-                if (!currentFrame.transparency) {
-                    c = header.bgColor;
-                }
-                Arrays.fill(dest, c);
-            } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
-                // Start with the previous frame
-                previousImage.getPixels(dest, 0, width, 0, 0, width, height);
-            }
+    // Decode GIF pixel stream.
+    datum = bits = count = first = top = pi = bi = 0;
+    for (i = 0; i < npix; ) {
+      // Load bytes until there are enough bits for a code.
+      if (count == 0) {
+        // Read a new data block.
+        count = readBlock();
+        if (count <= 0) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
         }
-
-        // Decode pixels for this frame  into the global pixels[] scratch.
-        decodeBitmapData(currentFrame);
-
-        // Copy each source line to the appropriate place in the destination.
-        int pass = 1;
-        int inc = 8;
-        int iline = 0;
-        for (int i = 0; i < currentFrame.ih; i++) {
-            int line = i;
-            if (currentFrame.interlace) {
-                if (iline >= currentFrame.ih) {
-                    pass++;
-                    switch (pass) {
-                        case 2:
-                            iline = 4;
-                            break;
-                        case 3:
-                            iline = 2;
-                            inc = 4;
-                            break;
-                        case 4:
-                            iline = 1;
-                            inc = 2;
-                            break;
-                        default:
-                            break;
-                    }
-                }
-                line = iline;
-                iline += inc;
-            }
-            line += currentFrame.iy;
-            if (line < header.height) {
-                int k = line * header.width;
-                // Start of line in dest.
-                int dx = k + currentFrame.ix;
-                // End of dest line.
-                int dlim = dx + currentFrame.iw;
-                if ((k + header.width) < dlim) {
-                    // Past dest edge.
-                    dlim = k + header.width;
-                }
-                // Start of line in source.
-                int sx = i * currentFrame.iw;
-                while (dx < dlim) {
-                    // Map color and insert in destination.
-                    int index = ((int) mainPixels[sx++]) & 0xff;
-                    int c = act[index];
-                    if (c != 0) {
-                        dest[dx] = c;
-                    }
-                    dx++;
-                }
-            }
+        bi = 0;
+      }
+
+      datum += (((int) block[bi]) & 0xff) << bits;
+      bits += 8;
+      bi++;
+      count--;
+
+      while (bits >= codeSize) {
+        // Get the next code.
+        code = datum & codeMask;
+        datum >>= codeSize;
+        bits -= codeSize;
+
+        // Interpret the code.
+        if (code == clear) {
+          // Reset decoder.
+          codeSize = dataSize + 1;
+          codeMask = (1 << codeSize) - 1;
+          available = clear + 2;
+          oldCode = NULL_CODE;
+          continue;
         }
 
-        // Copy pixels into previous image
-        if (savePrevious && currentFrame.dispose == DISPOSAL_UNSPECIFIED || currentFrame.dispose == DISPOSAL_NONE) {
-            if (previousImage == null) {
-                previousImage = getNextBitmap();
-            }
-            previousImage.setPixels(dest, 0, width, 0, 0, width, height);
+        if (code > available) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
         }
 
-        // Set pixels for current image.
-        Bitmap result = getNextBitmap();
-        result.setPixels(dest, 0, width, 0, 0, width, height);
-        return result;
-    }
-
-    /**
-     * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
-     */
-    private void decodeBitmapData(GifFrame frame) {
-        if (frame != null) {
-            // Jump to the frame start position.
-            rawData.position(frame.bufferFrameStart);
+        if (code == endOfInformation) {
+          break;
         }
 
-        int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
-        int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count, i, datum,
-                dataSize, first, top, bi, pi;
-
-        if (mainPixels == null || mainPixels.length < npix) {
-            // Allocate new pixel array.
-            mainPixels = new byte[npix];
-        }
-        if (prefix == null) {
-            prefix = new short[MAX_STACK_SIZE];
+        if (oldCode == NULL_CODE) {
+          pixelStack[top++] = suffix[code];
+          oldCode = code;
+          first = code;
+          continue;
         }
-        if (suffix == null) {
-            suffix = new byte[MAX_STACK_SIZE];
+        inCode = code;
+        if (code >= available) {
+          pixelStack[top++] = (byte) first;
+          code = oldCode;
         }
-        if (pixelStack == null) {
-            pixelStack = new byte[MAX_STACK_SIZE + 1];
+        while (code >= clear) {
+          pixelStack[top++] = suffix[code];
+          code = prefix[code];
         }
-
-        // Initialize GIF data stream decoder.
-        dataSize = read();
-        clear = 1 << dataSize;
-        endOfInformation = clear + 1;
-        available = clear + 2;
-        oldCode = NULL_CODE;
-        codeSize = dataSize + 1;
-        codeMask = (1 << codeSize) - 1;
-        for (code = 0; code < clear; code++) {
-            // XXX ArrayIndexOutOfBoundsException.
-            prefix[code] = 0;
-            suffix[code] = (byte) code;
-        }
-
-        // Decode GIF pixel stream.
-        datum = bits = count = first = top = pi = bi = 0;
-        for (i = 0; i < npix; ) {
-            // Load bytes until there are enough bits for a code.
-            if (count == 0) {
-                // Read a new data block.
-                count = readBlock();
-                if (count <= 0) {
-                    status = STATUS_PARTIAL_DECODE;
-                    break;
-                }
-                bi = 0;
-            }
-
-            datum += (((int) block[bi]) & 0xff) << bits;
-            bits += 8;
-            bi++;
-            count--;
-
-            while (bits >= codeSize) {
-                // Get the next code.
-                code = datum & codeMask;
-                datum >>= codeSize;
-                bits -= codeSize;
-
-                // Interpret the code.
-                if (code == clear) {
-                    // Reset decoder.
-                    codeSize = dataSize + 1;
-                    codeMask = (1 << codeSize) - 1;
-                    available = clear + 2;
-                    oldCode = NULL_CODE;
-                    continue;
-                }
-
-                if (code > available) {
-                    status = STATUS_PARTIAL_DECODE;
-                    break;
-                }
-
-                if (code == endOfInformation) {
-                    break;
-                }
-
-                if (oldCode == NULL_CODE) {
-                    pixelStack[top++] = suffix[code];
-                    oldCode = code;
-                    first = code;
-                    continue;
-                }
-                inCode = code;
-                if (code >= available) {
-                    pixelStack[top++] = (byte) first;
-                    code = oldCode;
-                }
-                while (code >= clear) {
-                    pixelStack[top++] = suffix[code];
-                    code = prefix[code];
-                }
-                first = ((int) suffix[code]) & 0xff;
-                pixelStack[top++] = (byte) first;
-
-                // Add a new string to the string table.
-                if (available < MAX_STACK_SIZE) {
-                    prefix[available] = (short) oldCode;
-                    suffix[available] = (byte) first;
-                    available++;
-                    if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-                        codeSize++;
-                        codeMask += available;
-                    }
-                }
-                oldCode = inCode;
-
-                while (top > 0) {
-                    // Pop a pixel off the pixel stack.
-                    top--;
-                    mainPixels[pi++] = pixelStack[top];
-                    i++;
-                }
-            }
+        first = ((int) suffix[code]) & 0xff;
+        pixelStack[top++] = (byte) first;
+
+        // Add a new string to the string table.
+        if (available < MAX_STACK_SIZE) {
+          prefix[available] = (short) oldCode;
+          suffix[available] = (byte) first;
+          available++;
+          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
+            codeSize++;
+            codeMask += available;
+          }
         }
+        oldCode = inCode;
 
-        // Clear missing pixels.
-        for (i = pi; i < npix; i++) {
-            mainPixels[i] = 0;
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi++] = pixelStack[--top];
+          i++;
         }
+      }
     }
 
-    /**
-     * Reads a single byte from the input stream.
-     */
-    private int read() {
-        int curByte = 0;
-        try {
-            curByte = rawData.get() & 0xFF;
-        } catch (Exception e) {
-            status = STATUS_FORMAT_ERROR;
-        }
-        return curByte;
+    // Clear missing pixels.
+    for (i = pi; i < npix; i++) {
+      mainPixels[i] = 0;
     }
-
-    /**
-     * Reads next variable length block from input.
-     *
-     * @return number of bytes stored in "buffer".
-     */
-    private int readBlock() {
-        int blockSize = read();
-        int n = 0;
-        if (blockSize > 0) {
-            try {
-                int count;
-                while (n < blockSize) {
-                    count = blockSize - n;
-                    rawData.get(block, n, count);
-
-                    n += count;
-                }
-            } catch (Exception e) {
-                Log.w(TAG, "Error Reading Block", e);
-                status = STATUS_FORMAT_ERROR;
-            }
-        }
-        return n;
+  }
+
+  /**
+   * Reads the next chunk for the intermediate work buffer.
+   */
+  private void readChunkIfNeeded() {
+    if (workBufferSize > workBufferPosition) {
+      return;
     }
-
-    private Bitmap getNextBitmap() {
-        Bitmap result = bitmapProvider.obtain(header.width, header.height, BITMAP_CONFIG);
-        if (result == null) {
-            result = Bitmap.createBitmap(header.width, header.height, BITMAP_CONFIG);
-        }
-        setAlpha(result);
-        return result;
+    if (workBuffer == null) {
+      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
     }
-
-    @TargetApi(12)
-    private static void setAlpha(Bitmap bitmap) {
-        if (Build.VERSION.SDK_INT >= 12) {
-            bitmap.setHasAlpha(true);
+    workBufferPosition = 0;
+    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
+    rawData.get(workBuffer, 0, workBufferSize);
+  }
+
+  /**
+   * Reads a single byte from the input stream.
+   */
+  private int readByte() {
+    try {
+      readChunkIfNeeded();
+      return workBuffer[workBufferPosition++] & 0xFF;
+    } catch (Exception e) {
+      status = STATUS_FORMAT_ERROR;
+      return 0;
+    }
+  }
+
+  /**
+   * Reads next variable length block from input.
+   *
+   * @return number of bytes stored in "buffer".
+   */
+  private int readBlock() {
+    int blockSize = readByte();
+    if (blockSize > 0) {
+      try {
+        if (block == null) {
+          block = bitmapProvider.obtainByteArray(255);
         }
+        final int remaining = workBufferSize - workBufferPosition;
+        if (remaining >= blockSize) {
+          // Block can be read from the current work buffer.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
+          workBufferPosition += blockSize;
+        } else if (rawData.remaining() + remaining >= blockSize) {
+          // Block can be read in two passes.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
+          workBufferPosition = workBufferSize;
+          readChunkIfNeeded();
+          final int secondHalfRemaining = blockSize - remaining;
+          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
+          workBufferPosition += secondHalfRemaining;
+        } else {
+          status = STATUS_FORMAT_ERROR;
+        }
+      } catch (Exception e) {
+        Log.w(TAG, "Error Reading Block", e);
+        status = STATUS_FORMAT_ERROR;
+      }
+    }
+    return blockSize;
+  }
+
+  private Bitmap getNextBitmap() {
+    Bitmap.Config config = isFirstFrameTransparent
+        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
+    setAlpha(result);
+    return result;
+  }
+
+  @TargetApi(12)
+  private static void setAlpha(Bitmap bitmap) {
+    if (Build.VERSION.SDK_INT >= 12) {
+      bitmap.setHasAlpha(true);
     }
+  }
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
index 1cfa6847d..6da8c9e40 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
@@ -4,19 +4,33 @@
  * Inner model class housing metadata for each frame.
  */
 class GifFrame {
-    int ix, iy, iw, ih;
-    /** Control Flag. */
-    boolean interlace;
-    /** Control Flag. */
-    boolean transparency;
-    /** Disposal Method. */
-    int dispose;
-    /** Transparency Index. */
-    int transIndex;
-    /** Delay, in ms, to next frame. */
-    int delay;
-    /** Index in the raw buffer where we need to start reading to decode. */
-    int bufferFrameStart;
-    /** Local Color Table. */
-    int[] lct;
+  int ix, iy, iw, ih;
+  /**
+   * Control Flag.
+   */
+  boolean interlace;
+  /**
+   * Control Flag.
+   */
+  boolean transparency;
+  /**
+   * Disposal Method.
+   */
+  int dispose;
+  /**
+   * Transparency Index.
+   */
+  int transIndex;
+  /**
+   * Delay, in ms, to next frame.
+   */
+  int delay;
+  /**
+   * Index in the raw buffer where we need to start reading to decode.
+   */
+  int bufferFrameStart;
+  /**
+   * Local Color Table.
+   */
+  int[] lct;
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index 961529014..5b57212ec 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -4,54 +4,55 @@
 import java.util.List;
 
 /**
- * A header object containing the number of frames in an animated GIF image as well as basic metadata like width and
- * height that can be used to decode each individual frame of the GIF. Can be shared by one or more
- * {@link com.bumptech.glide.gifdecoder.GifDecoder}s to play the same animated GIF in multiple views.
+ * A header object containing the number of frames in an animated GIF image as well as basic
+ * metadata like width and height that can be used to decode each individual frame of the GIF. Can
+ * be shared by one or more {@link com.bumptech.glide.gifdecoder.GifDecoder}s to play the same
+ * animated GIF in multiple views.
  */
 public class GifHeader {
 
-    int[] gct = null;
-    int status = GifDecoder.STATUS_OK;
-    int frameCount = 0;
-
-    GifFrame currentFrame;
-    List<GifFrame> frames = new ArrayList<GifFrame>();
-    // Logical screen size.
-    // Full image width.
-    int width;
-    // Full image height.
-    int height;
-
-    // 1 : global color table flag.
-    boolean gctFlag;
-    // 2-4 : color resolution.
-    // 5 : gct sort flag.
-    // 6-8 : gct size.
-    int gctSize;
-    // Background color index.
-    int bgIndex;
-    // Pixel aspect ratio.
-    int pixelAspect;
-    //TODO: this is set both during reading the header and while decoding frames...
-    int bgColor;
-    int loopCount;
-
-    public int getHeight() {
-        return height;
-    }
-
-    public int getWidth() {
-        return width;
-    }
-
-    public int getNumFrames() {
-        return frameCount;
-    }
-
-    /**
-     * Global status code of GIF data parsing.
-     */
-    public int getStatus() {
-        return status;
-    }
+  int[] gct = null;
+  int status = GifDecoder.STATUS_OK;
+  int frameCount = 0;
+
+  GifFrame currentFrame;
+  List<GifFrame> frames = new ArrayList<GifFrame>();
+  // Logical screen size.
+  // Full image width.
+  int width;
+  // Full image height.
+  int height;
+
+  // 1 : global color table flag.
+  boolean gctFlag;
+  // 2-4 : color resolution.
+  // 5 : gct sort flag.
+  // 6-8 : gct size.
+  int gctSize;
+  // Background color index.
+  int bgIndex;
+  // Pixel aspect ratio.
+  int pixelAspect;
+  //TODO: this is set both during reading the header and while decoding frames...
+  int bgColor;
+  int loopCount;
+
+  public int getHeight() {
+    return height;
+  }
+
+  public int getWidth() {
+    return width;
+  }
+
+  public int getNumFrames() {
+    return frameCount;
+  }
+
+  /**
+   * Global status code of GIF data parsing.
+   */
+  public int getStatus() {
+    return status;
+  }
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index cf61531cd..3a0a16bb7 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -10,365 +10,395 @@
 import java.util.Arrays;
 
 /**
- * A class responsible for creating {@link com.bumptech.glide.gifdecoder.GifHeader}s from data representing animated
- * gifs.
+ * A class responsible for creating {@link com.bumptech.glide.gifdecoder.GifHeader}s from data
+ * representing animated gifs.
  */
 public class GifHeaderParser {
-    public static final String TAG = "GifHeaderParser";
-
-    // The minimum frame delay in hundredths of a second.
-    static final int MIN_FRAME_DELAY = 3;
-    // The default frame delay in hundredths of a second for GIFs with frame delays less than the minimum.
-    static final int DEFAULT_FRAME_DELAY = 10;
-
-    private static final int MAX_BLOCK_SIZE = 256;
-    // Raw data read working array.
-    private final byte[] block = new byte[MAX_BLOCK_SIZE];
-
-    private ByteBuffer rawData;
-    private GifHeader header;
-    private int blockSize = 0;
-
-    public GifHeaderParser setData(byte[] data) {
-        reset();
-        if (data != null) {
-            rawData = ByteBuffer.wrap(data);
-            rawData.rewind();
-            rawData.order(ByteOrder.LITTLE_ENDIAN);
-        } else {
-            rawData = null;
-            header.status = GifDecoder.STATUS_OPEN_ERROR;
-        }
-        return this;
+  public static final String TAG = "GifHeaderParser";
+
+  // The minimum frame delay in hundredths of a second.
+  static final int MIN_FRAME_DELAY = 2;
+  // The default frame delay in hundredths of a second for GIFs with frame delays less than the
+  // minimum.
+  static final int DEFAULT_FRAME_DELAY = 10;
+
+  private static final int MAX_BLOCK_SIZE = 256;
+  // Raw data read working array.
+  private final byte[] block = new byte[MAX_BLOCK_SIZE];
+
+  private ByteBuffer rawData;
+  private GifHeader header;
+  private int blockSize = 0;
+
+  public GifHeaderParser setData(ByteBuffer data) {
+    reset();
+    rawData = data.asReadOnlyBuffer();
+    rawData.position(0);
+    rawData.order(ByteOrder.LITTLE_ENDIAN);
+    return this;
+  }
+
+  public GifHeaderParser setData(byte[] data) {
+    if (data != null) {
+      setData(ByteBuffer.wrap(data));
+    } else {
+      rawData = null;
+      header.status = GifDecoder.STATUS_OPEN_ERROR;
     }
-
-    public void clear() {
-        rawData = null;
-        header = null;
+    return this;
+  }
+
+  public void clear() {
+    rawData = null;
+    header = null;
+  }
+
+  private void reset() {
+    rawData = null;
+    Arrays.fill(block, (byte) 0);
+    header = new GifHeader();
+    blockSize = 0;
+  }
+
+  public GifHeader parseHeader() {
+    if (rawData == null) {
+      throw new IllegalStateException("You must call setData() before parseHeader()");
     }
-
-    private void reset() {
-        rawData = null;
-        Arrays.fill(block, (byte) 0);
-        header = new GifHeader();
-        blockSize = 0;
+    if (err()) {
+      return header;
     }
 
-    public GifHeader parseHeader() {
-        if (rawData == null) {
-            throw new IllegalStateException("You must call setData() before parseHeader()");
-        }
-        if (err()) {
-            return header;
-        }
-
-        readHeader();
-        if (!err()) {
-            readContents();
-            if (header.frameCount < 0) {
-                header.status = STATUS_FORMAT_ERROR;
-            }
-        }
-
-        return header;
+    readHeader();
+    if (!err()) {
+      readContents();
+      if (header.frameCount < 0) {
+        header.status = STATUS_FORMAT_ERROR;
+      }
     }
 
-    /**
-     * Main file parser. Reads GIF content blocks.
-     */
-    private void readContents() {
-        // Read GIF file content blocks.
-        boolean done = false;
-        while (!(done || err())) {
-            int code = read();
-            switch (code) {
-                // Image separator.
-                case 0x2C:
-                    // The graphics control extension is optional, but will always come first if it exists. If one did
-                    // exist, there will be a non-null current frame which we should use. However if one did not exist,
-                    // the current frame will be null and we must create it here. See issue #134.
-                    if (header.currentFrame == null) {
-                        header.currentFrame = new GifFrame();
-                    }
-                    readBitmap();
-                    break;
-                // Extension.
-                case 0x21:
-                    code = read();
-                    switch (code) {
-                        // Graphics control extension.
-                        case 0xf9:
-                            // Start a new frame.
-                            header.currentFrame = new GifFrame();
-                            readGraphicControlExt();
-                            break;
-                        // Application extension.
-                        case 0xff:
-                            readBlock();
-                            String app = "";
-                            for (int i = 0; i < 11; i++) {
-                                app += (char) block[i];
-                            }
-                            if (app.equals("NETSCAPE2.0")) {
-                                readNetscapeExt();
-                            } else {
-                                // Don't care.
-                                skip();
-                            }
-                            break;
-                        // Comment extension.
-                        case 0xfe:
-                            skip();
-                            break;
-                        // Plain text extension.
-                        case 0x01:
-                            skip();
-                            break;
-                        // Uninteresting extension.
-                        default:
-                            skip();
-                    }
-                    break;
-                // Terminator.
-                case 0x3b:
-                    done = true;
-                    break;
-                // Bad byte, but keep going and see what happens break;
-                case 0x00:
-                default:
-                    header.status = STATUS_FORMAT_ERROR;
-            }
-        }
+    return header;
+  }
+
+  /**
+   * Determines if the GIF is animated by trying to read in the first 2 frames
+   * This method reparses the data even if the header has already been read.
+   */
+  public boolean isAnimated() {
+    readHeader();
+    if (!err()) {
+      readContents(2 /* maxFrames */);
     }
-
-    /**
-     * Reads Graphics Control Extension values.
-     */
-    private void readGraphicControlExt() {
-        // Block size.
-        read();
-        // Packed fields.
-        int packed = read();
-        // Disposal method.
-        header.currentFrame.dispose = (packed & 0x1c) >> 2;
-        if (header.currentFrame.dispose == 0) {
-            // Elect to keep old image if discretionary.
-            header.currentFrame.dispose = 1;
-        }
-        header.currentFrame.transparency = (packed & 1) != 0;
-        // Delay in milliseconds.
-        int delayInHundredthsOfASecond = readShort();
-        // TODO: consider allowing -1 to indicate show forever.
-        if (delayInHundredthsOfASecond < MIN_FRAME_DELAY) {
-            delayInHundredthsOfASecond = DEFAULT_FRAME_DELAY;
-        }
-        header.currentFrame.delay = delayInHundredthsOfASecond * 10;
-        // Transparent color index
-        header.currentFrame.transIndex = read();
-        // Block terminator
-        read();
+    return header.frameCount > 1;
+  }
+
+  /**
+   * Main file parser. Reads GIF content blocks.
+   */
+  private void readContents() {
+    readContents(Integer.MAX_VALUE /* maxFrames */);
+  }
+
+  /**
+   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames
+   */
+  private void readContents(int maxFrames) {
+    // Read GIF file content blocks.
+    boolean done = false;
+    while (!(done || err() || header.frameCount > maxFrames)) {
+      int code = read();
+      switch (code) {
+        // Image separator.
+        case 0x2C:
+          // The graphics control extension is optional, but will always come first if it exists.
+          // If one did
+          // exist, there will be a non-null current frame which we should use. However if one
+          // did not exist,
+          // the current frame will be null and we must create it here. See issue #134.
+          if (header.currentFrame == null) {
+            header.currentFrame = new GifFrame();
+          }
+          readBitmap();
+          break;
+        // Extension.
+        case 0x21:
+          code = read();
+          switch (code) {
+            // Graphics control extension.
+            case 0xf9:
+              // Start a new frame.
+              header.currentFrame = new GifFrame();
+              readGraphicControlExt();
+              break;
+            // Application extension.
+            case 0xff:
+              readBlock();
+              String app = "";
+              for (int i = 0; i < 11; i++) {
+                app += (char) block[i];
+              }
+              if (app.equals("NETSCAPE2.0")) {
+                readNetscapeExt();
+              } else {
+                // Don't care.
+                skip();
+              }
+              break;
+            // Comment extension.
+            case 0xfe:
+              skip();
+              break;
+            // Plain text extension.
+            case 0x01:
+              skip();
+              break;
+            // Uninteresting extension.
+            default:
+              skip();
+          }
+          break;
+        // Terminator.
+        case 0x3b:
+          done = true;
+          break;
+        // Bad byte, but keep going and see what happens break;
+        case 0x00:
+        default:
+          header.status = STATUS_FORMAT_ERROR;
+      }
     }
-
-    /**
-     * Reads next frame image.
-     */
-    private void readBitmap() {
-        // (sub)image position & size.
-        header.currentFrame.ix = readShort();
-        header.currentFrame.iy = readShort();
-        header.currentFrame.iw = readShort();
-        header.currentFrame.ih = readShort();
-
-        int packed = read();
-        // 1 - local color table flag interlace
-        boolean lctFlag = (packed & 0x80) != 0;
-        int lctSize = (int) Math.pow(2, (packed & 0x07) + 1);
-        // 3 - sort flag
-        // 4-5 - reserved lctSize = 2 << (packed & 7); // 6-8 - local color
-        // table size
-        header.currentFrame.interlace = (packed & 0x40) != 0;
-        if (lctFlag) {
-            // Read table.
-            header.currentFrame.lct = readColorTable(lctSize);
-        } else {
-            // No local color table.
-            header.currentFrame.lct = null;
-        }
-
-        // Save this as the decoding position pointer.
-        header.currentFrame.bufferFrameStart = rawData.position();
-
-        // False decode pixel data to advance buffer.
-        skipImageData();
-
-        if (err()) {
-            return;
-        }
-
-        header.frameCount++;
-        // Add image to frame.
-        header.frames.add(header.currentFrame);
+  }
+
+  /**
+   * Reads Graphics Control Extension values.
+   */
+  private void readGraphicControlExt() {
+    // Block size.
+    read();
+    // Packed fields.
+    int packed = read();
+    // Disposal method.
+    header.currentFrame.dispose = (packed & 0x1c) >> 2;
+    if (header.currentFrame.dispose == 0) {
+      // Elect to keep old image if discretionary.
+      header.currentFrame.dispose = 1;
     }
-    /**
-     * Reads Netscape extension to obtain iteration count.
-     */
-    private void readNetscapeExt() {
-        do {
-            readBlock();
-            if (block[0] == 1) {
-                // Loop count sub-block.
-                int b1 = ((int) block[1]) & 0xff;
-                int b2 = ((int) block[2]) & 0xff;
-                header.loopCount = (b2 << 8) | b1;
-            }
-        } while ((blockSize > 0) && !err());
+    header.currentFrame.transparency = (packed & 1) != 0;
+    // Delay in milliseconds.
+    int delayInHundredthsOfASecond = readShort();
+    // TODO: consider allowing -1 to indicate show forever.
+    if (delayInHundredthsOfASecond < MIN_FRAME_DELAY) {
+      delayInHundredthsOfASecond = DEFAULT_FRAME_DELAY;
     }
-
-
-    /**
-     * Reads GIF file header information.
-     */
-    private void readHeader() {
-        String id = "";
-        for (int i = 0; i < 6; i++) {
-            id += (char) read();
-        }
-        if (!id.startsWith("GIF")) {
-            header.status = STATUS_FORMAT_ERROR;
-            return;
-        }
-        readLSD();
-        if (header.gctFlag && !err()) {
-            header.gct = readColorTable(header.gctSize);
-            header.bgColor = header.gct[header.bgIndex];
-        }
-    }
-    /**
-     * Reads Logical Screen Descriptor.
-     */
-    private void readLSD() {
-        // Logical screen size.
-        header.width = readShort();
-        header.height = readShort();
-        // Packed fields
-        int packed = read();
-        // 1 : global color table flag.
-        header.gctFlag = (packed & 0x80) != 0;
-        // 2-4 : color resolution.
-        // 5 : gct sort flag.
-        // 6-8 : gct size.
-        header.gctSize = 2 << (packed & 7);
-        // Background color index.
-        header.bgIndex = read();
-        // Pixel aspect ratio
-        header.pixelAspect = read();
+    header.currentFrame.delay = delayInHundredthsOfASecond * 10;
+    // Transparent color index
+    header.currentFrame.transIndex = read();
+    // Block terminator
+    read();
+  }
+
+  /**
+   * Reads next frame image.
+   */
+  private void readBitmap() {
+    // (sub)image position & size.
+    header.currentFrame.ix = readShort();
+    header.currentFrame.iy = readShort();
+    header.currentFrame.iw = readShort();
+    header.currentFrame.ih = readShort();
+
+    int packed = read();
+    // 1 - local color table flag interlace
+    boolean lctFlag = (packed & 0x80) != 0;
+    int lctSize = (int) Math.pow(2, (packed & 0x07) + 1);
+    // 3 - sort flag
+    // 4-5 - reserved lctSize = 2 << (packed & 7); // 6-8 - local color
+    // table size
+    header.currentFrame.interlace = (packed & 0x40) != 0;
+    if (lctFlag) {
+      // Read table.
+      header.currentFrame.lct = readColorTable(lctSize);
+    } else {
+      // No local color table.
+      header.currentFrame.lct = null;
     }
 
-    /**
-     * Reads color table as 256 RGB integer values.
-     *
-     * @param ncolors int number of colors to read.
-     * @return int array containing 256 colors (packed ARGB with full alpha).
-     */
-    private int[] readColorTable(int ncolors) {
-        int nbytes = 3 * ncolors;
-        int[] tab = null;
-        byte[] c = new byte[nbytes];
-
-        try {
-            rawData.get(c);
-
-            // TODO: what bounds checks are we avoiding if we know the number of colors?
-            // Max size to avoid bounds checks.
-            tab = new int[MAX_BLOCK_SIZE];
-            int i = 0;
-            int j = 0;
-            while (i < ncolors) {
-                int r = ((int) c[j++]) & 0xff;
-                int g = ((int) c[j++]) & 0xff;
-                int b = ((int) c[j++]) & 0xff;
-                tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
-            }
-        } catch (BufferUnderflowException e) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Format Error Reading Color Table", e);
-            }
-            header.status = STATUS_FORMAT_ERROR;
-        }
+    // Save this as the decoding position pointer.
+    header.currentFrame.bufferFrameStart = rawData.position();
 
-        return tab;
-    }
+    // False decode pixel data to advance buffer.
+    skipImageData();
 
-    /**
-     * Skips LZW image data for a single frame to advance buffer.
-     */
-    private void skipImageData() {
-        // lzwMinCodeSize
-        read();
-        // data sub-blocks
-        skip();
+    if (err()) {
+      return;
     }
 
-    /**
-     * Skips variable length blocks up to and including next zero length block.
-     */
-    private void skip() {
-        int blockSize;
-        do {
-            blockSize = read();
-            rawData.position(rawData.position() + blockSize);
-        } while (blockSize > 0);
+    header.frameCount++;
+    // Add image to frame.
+    header.frames.add(header.currentFrame);
+  }
+
+  /**
+   * Reads Netscape extension to obtain iteration count.
+   */
+  private void readNetscapeExt() {
+    do {
+      readBlock();
+      if (block[0] == 1) {
+        // Loop count sub-block.
+        int b1 = ((int) block[1]) & 0xff;
+        int b2 = ((int) block[2]) & 0xff;
+        header.loopCount = (b2 << 8) | b1;
+      }
+    } while ((blockSize > 0) && !err());
+  }
+
+
+  /**
+   * Reads GIF file header information.
+   */
+  private void readHeader() {
+    String id = "";
+    for (int i = 0; i < 6; i++) {
+      id += (char) read();
     }
-
-    /**
-     * Reads next variable length block from input.
-     *
-     * @return number of bytes stored in "buffer"
-     */
-    private int readBlock() {
-        blockSize = read();
-        int n = 0;
-        if (blockSize > 0) {
-            int count = 0;
-            try {
-                while (n < blockSize) {
-                    count = blockSize - n;
-                    rawData.get(block, n, count);
-
-                    n += count;
-                }
-            } catch (Exception e) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Error Reading Block n: " + n + " count: " + count + " blockSize: " + blockSize, e);
-                }
-                header.status = STATUS_FORMAT_ERROR;
-            }
-        }
-        return n;
+    if (!id.startsWith("GIF")) {
+      header.status = STATUS_FORMAT_ERROR;
+      return;
     }
-
-    /**
-     * Reads a single byte from the input stream.
-     */
-    private int read() {
-        int curByte = 0;
-        try {
-            curByte = rawData.get() & 0xFF;
-        } catch (Exception e) {
-            header.status = STATUS_FORMAT_ERROR;
-        }
-        return curByte;
+    readLSD();
+    if (header.gctFlag && !err()) {
+      header.gct = readColorTable(header.gctSize);
+      header.bgColor = header.gct[header.bgIndex];
     }
-
-    /**
-     * Reads next 16-bit value, LSB first.
-     */
-    private int readShort() {
-        // Read 16-bit value.
-        return rawData.getShort();
+  }
+
+  /**
+   * Reads Logical Screen Descriptor.
+   */
+  private void readLSD() {
+    // Logical screen size.
+    header.width = readShort();
+    header.height = readShort();
+    // Packed fields
+    int packed = read();
+    // 1 : global color table flag.
+    header.gctFlag = (packed & 0x80) != 0;
+    // 2-4 : color resolution.
+    // 5 : gct sort flag.
+    // 6-8 : gct size.
+    header.gctSize = 2 << (packed & 7);
+    // Background color index.
+    header.bgIndex = read();
+    // Pixel aspect ratio
+    header.pixelAspect = read();
+  }
+
+  /**
+   * Reads color table as 256 RGB integer values.
+   *
+   * @param ncolors int number of colors to read.
+   * @return int array containing 256 colors (packed ARGB with full alpha).
+   */
+  private int[] readColorTable(int ncolors) {
+    int nbytes = 3 * ncolors;
+    int[] tab = null;
+    byte[] c = new byte[nbytes];
+
+    try {
+      rawData.get(c);
+
+      // TODO: what bounds checks are we avoiding if we know the number of colors?
+      // Max size to avoid bounds checks.
+      tab = new int[MAX_BLOCK_SIZE];
+      int i = 0;
+      int j = 0;
+      while (i < ncolors) {
+        int r = ((int) c[j++]) & 0xff;
+        int g = ((int) c[j++]) & 0xff;
+        int b = ((int) c[j++]) & 0xff;
+        tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
+      }
+    } catch (BufferUnderflowException e) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Format Error Reading Color Table", e);
+      }
+      header.status = STATUS_FORMAT_ERROR;
     }
 
-    private boolean err() {
-        return header.status != GifDecoder.STATUS_OK;
+    return tab;
+  }
+
+  /**
+   * Skips LZW image data for a single frame to advance buffer.
+   */
+  private void skipImageData() {
+    // lzwMinCodeSize
+    read();
+    // data sub-blocks
+    skip();
+  }
+
+  /**
+   * Skips variable length blocks up to and including next zero length block.
+   */
+  private void skip() {
+    int blockSize;
+    do {
+      blockSize = read();
+      rawData.position(rawData.position() + blockSize);
+    } while (blockSize > 0);
+  }
+
+  /**
+   * Reads next variable length block from input.
+   *
+   * @return number of bytes stored in "buffer"
+   */
+  private int readBlock() {
+    blockSize = read();
+    int n = 0;
+    if (blockSize > 0) {
+      int count = 0;
+      try {
+        while (n < blockSize) {
+          count = blockSize - n;
+          rawData.get(block, n, count);
+
+          n += count;
+        }
+      } catch (Exception e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG,
+              "Error Reading Block n: " + n + " count: " + count + " blockSize: " + blockSize, e);
+        }
+        header.status = STATUS_FORMAT_ERROR;
+      }
+    }
+    return n;
+  }
+
+  /**
+   * Reads a single byte from the input stream.
+   */
+  private int read() {
+    int curByte = 0;
+    try {
+      curByte = rawData.get() & 0xFF;
+    } catch (Exception e) {
+      header.status = STATUS_FORMAT_ERROR;
     }
+    return curByte;
+  }
+
+  /**
+   * Reads next 16-bit value, LSB first.
+   */
+  private int readShort() {
+    // Read 16-bit value.
+    return rawData.getShort();
+  }
+
+  private boolean err() {
+    return header.status != GifDecoder.STATUS_OK;
+  }
 }
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
new file mode 100644
index 000000000..210818ea2
--- /dev/null
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -0,0 +1,178 @@
+package com.bumptech.glide.gifdecoder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.robolectric.Shadows.shadowOf;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+
+import com.bumptech.glide.testutil.TestUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GifDecoderTest {
+
+  private MockProvider provider;
+
+  @Before
+  public void setUp() {
+    provider = new MockProvider();
+  }
+
+  @Test
+  public void testCanDecodeFramesFromTestGif() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "partial_gif_decode.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new GifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap bitmap = decoder.getNextFrame();
+    assertNotNull(bitmap);
+    assertEquals(GifDecoder.STATUS_OK, decoder.getStatus());
+  }
+
+  @Test
+  public void testFrameIndexStartsAtNegativeOne() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.frameCount = 4;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new GifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(-1, decoder.getCurrentFrameIndex());
+  }
+
+  @Test
+  public void testAdvanceIncrementsFrameIndex() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.frameCount = 4;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new GifDecoder(provider);
+    decoder.setData(gifheader, data);
+    decoder.advance();
+    assertEquals(0, decoder.getCurrentFrameIndex());
+  }
+
+  @Test
+  public void testAdvanceWrapsIndexBackToZero() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.frameCount = 2;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new GifDecoder(provider);
+    decoder.setData(gifheader, data);
+    decoder.advance();
+    decoder.advance();
+    decoder.advance();
+    assertEquals(0, decoder.getCurrentFrameIndex());
+  }
+
+  @Test
+  public void testSettingDataResetsFramePointer() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.frameCount = 4;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new GifDecoder(provider);
+    decoder.setData(gifheader, data);
+    decoder.advance();
+    decoder.advance();
+    assertEquals(1, decoder.getCurrentFrameIndex());
+
+    decoder.setData(gifheader, data);
+    assertEquals(-1, decoder.getCurrentFrameIndex());
+  }
+
+  @Test
+  @Config(shadows = { CustomShadowBitmap.class })
+  public void testFirstFrameMustUsingLastFrameDispose() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_dispose.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new GifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap firstFrame = decoder.getNextFrame();
+    decoder.advance();
+    decoder.getNextFrame();
+    decoder.advance();
+    Bitmap firstFrameTwice = decoder.getNextFrame();
+    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
+        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
+  }
+
+  /**
+   * Preserve generated bitmap data for checking.
+   */
+  @Implements(Bitmap.class)
+  public static class CustomShadowBitmap extends ShadowBitmap {
+
+    private int[] pixels;
+
+    @Implementation
+    public void setPixels(int[] pixels, int offset, int stride,
+        int x, int y, int width, int height) {
+      this.pixels = new int[pixels.length];
+      System.arraycopy(pixels, 0, this.pixels, 0, this.pixels.length);
+    }
+
+    public int[] getPixels() {
+      return pixels;
+    }
+  }
+
+  private static class MockProvider implements GifDecoder.BitmapProvider {
+
+    @NonNull
+    @Override
+    public Bitmap obtain(int width, int height, Bitmap.Config config) {
+      Bitmap result = Bitmap.createBitmap(width, height, config);
+      Shadows.shadowOf(result).setMutable(true);
+      return result;
+    }
+
+    @Override
+    public void release(Bitmap bitmap) {
+      // Do nothing.
+    }
+
+    @Override
+    public byte[] obtainByteArray(int size) {
+      return new byte[size];
+    }
+
+    @Override
+    public void release(byte[] bytes) {
+      // Do nothing.
+    }
+
+    @Override
+    public int[] obtainIntArray(int size) {
+      return new int[size];
+    }
+
+    @Override
+    public void release(int[] array) {
+      // Do Nothing
+    }
+
+  }
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
new file mode 100644
index 000000000..22f2e5c78
--- /dev/null
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -0,0 +1,266 @@
+package com.bumptech.glide.gifdecoder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
+import com.bumptech.glide.testutil.TestUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * Tests for {@link com.bumptech.glide.gifdecoder.GifHeaderParser}.
+ */
+@RunWith(JUnit4.class)
+public class GifHeaderParserTest {
+  private GifHeaderParser parser;
+
+  @Before
+  public void setUp() {
+    parser = new GifHeaderParser();
+  }
+
+  @Test
+  public void testReturnsHeaderWithFormatErrorIfDoesNotStartWithGifHeader() {
+    parser.setData("wrong_header".getBytes());
+    GifHeader result = parser.parseHeader();
+    assertEquals(GifDecoder.STATUS_FORMAT_ERROR, result.status);
+  }
+
+  @Test
+  public void testCanReadValidHeaderAndLSD() {
+    final int width = 10;
+    final int height = 20;
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH).order(ByteOrder.LITTLE_ENDIAN);
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, width, height, false, 0);
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    assertEquals(width, header.width);
+    assertEquals(height, header.height);
+    assertFalse(header.gctFlag);
+    // 2^(1+0) == 2^1 == 2.
+    assertEquals(2, header.gctSize);
+    assertEquals(0, header.bgIndex);
+    assertEquals(0, header.pixelAspect);
+  }
+
+  @Test
+  public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOException {
+    byte[] data =
+        TestUtil.resourceToBytes(getClass(), "gif_without_graphical_control_extension.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.frameCount);
+    assertNotNull(header.frames.get(0));
+    assertEquals(GifDecoder.STATUS_OK, header.status);
+  }
+
+  @Test
+  public void testCanReadImageDescriptorWithoutGraphicalExtension() {
+    final int lzwMinCodeSize = 2;
+    ByteBuffer buffer = ByteBuffer.allocate(
+        GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
+            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
+    GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.width);
+    assertEquals(1, header.height);
+    assertEquals(1, header.frameCount);
+    assertNotNull(header.frames.get(0));
+  }
+
+  private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {
+    final int lzwMinCodeSize = 2;
+    ByteBuffer buffer = ByteBuffer.allocate(
+        GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH
+            + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
+            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
+    GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
+    return buffer;
+  }
+
+  @Test
+  public void testCanParseFrameDelay() {
+    final short frameDelay = 50;
+    ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    GifFrame frame = header.frames.get(0);
+
+    // Convert delay in 100ths of a second to ms.
+    assertEquals(frameDelay * 10, frame.delay);
+  }
+
+  @Test
+  public void testSetsDefaultFrameDelayIfFrameDelayIsZero() {
+    ByteBuffer buffer = writeHeaderWithGceAndFrameDelay((short) 0);
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    GifFrame frame = header.frames.get(0);
+
+    // Convert delay in 100ths of a second to ms.
+    assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);
+  }
+
+  @Test
+  public void testSetsDefaultFrameDelayIfFrameDelayIsLessThanMinimum() {
+    final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY - 1;
+    ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    GifFrame frame = header.frames.get(0);
+
+    // Convert delay in 100ths of a second to ms.
+    assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);
+  }
+
+  @Test
+  public void testObeysFrameDelayIfFrameDelayIsAtMinimum() {
+    final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY;
+    ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    GifFrame frame = header.frames.get(0);
+
+    // Convert delay in 100ths of a second to ms.
+    assertEquals(frameDelay * 10, frame.delay);
+  }
+
+  @Test
+  public void testSetsFrameLocalColorTableToNullIfNoColorTable() {
+    final int lzwMinCodeSize = 2;
+    ByteBuffer buffer = ByteBuffer.allocate(
+        GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
+            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
+    GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.width);
+    assertEquals(1, header.height);
+    assertEquals(1, header.frameCount);
+    assertNotNull(header.frames.get(0));
+    assertNull(header.frames.get(0).lct);
+  }
+
+  @Test
+  public void testSetsFrameLocalColorTableIfHasColorTable() {
+    final int lzwMinCodeSize = 2;
+    final int numColors = 4;
+    ByteBuffer buffer = ByteBuffer.allocate(
+        GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
+            .getImageDataSize(lzwMinCodeSize) + GifBytesTestUtil.getColorTableLength(numColors))
+        .order(ByteOrder.LITTLE_ENDIAN);
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, true /*hasLct*/, numColors);
+    GifBytesTestUtil.writeColorTable(buffer, numColors);
+    GifBytesTestUtil.writeFakeImageData(buffer, 2);
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.width);
+    assertEquals(1, header.height);
+    assertEquals(1, header.frameCount);
+    assertNotNull(header.frames.get(0));
+
+    GifFrame frame = header.frames.get(0);
+    assertNotNull(frame.lct);
+  }
+
+  @Test
+  public void testCanParseMultipleFrames() {
+    final int lzwMinCodeSize = 2;
+    final int expectedFrames = 3;
+
+    final int frameSize = GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
+        .getImageDataSize(lzwMinCodeSize);
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + expectedFrames * frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    for (int i = 0; i < expectedFrames; i++) {
+      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+      GifBytesTestUtil.writeFakeImageData(buffer, 2);
+    }
+
+    parser.setData(buffer.array());
+    GifHeader header = parser.parseHeader();
+    assertEquals(expectedFrames, header.frameCount);
+    assertEquals(expectedFrames, header.frames.size());
+  }
+
+  @Test
+  public void testIsAnimatedMultipleFrames() {
+    final int lzwMinCodeSize = 2;
+    final int numFrames = 3;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    for (int i = 0; i < numFrames; i++) {
+      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+      GifBytesTestUtil.writeFakeImageData(buffer, 2);
+    }
+
+    parser.setData(buffer.array());
+    assertTrue(parser.isAnimated());
+  }
+
+  @Test
+  public void testIsNotAnimatedOneFrame() {
+    final int lzwMinCodeSize = 2;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+    GifBytesTestUtil.writeFakeImageData(buffer, 2);
+
+    parser.setData(buffer.array());
+    assertFalse(parser.isAnimated());
+  }
+
+
+  @Test(expected = IllegalStateException.class)
+  public void testThrowsIfParseHeaderCalledBeforeSetData() {
+    GifHeaderParser parser = new GifHeaderParser();
+    parser.parseHeader();
+  }
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
new file mode 100644
index 000000000..7a32733a6
--- /dev/null
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
@@ -0,0 +1,143 @@
+package com.bumptech.glide.gifdecoder.test;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Utils for writing the bytes of various parts of GIFs to byte buffers.
+ */
+public class GifBytesTestUtil {
+  // Length in bytes.
+  public static final int HEADER_LENGTH = 13;
+  // Length in bytes.
+  public static final int IMAGE_DESCRIPTOR_LENGTH = 10;
+  // Length in bytes.
+  public static final int GRAPHICS_CONTROL_EXTENSION_LENGTH = 8;
+
+  public static int getColorTableLength(int numColors) {
+    return 3 * numColors;
+  }
+
+  public static int getImageDataSize(int lzwMinCodeSize) {
+    // TODO: fill this out.
+    return 4;
+  }
+
+  public static void writeFakeImageData(ByteBuffer out, int lzwMinCodeSize) {
+    // 1 for lzwMinCodeSize, 1 for length, 1 for min content, 1 for block terminator.
+    verifyRemaining(out, 4);
+    verifyShortValues(lzwMinCodeSize);
+
+    out.put((byte) lzwMinCodeSize);
+    // Block length.
+    out.put((byte) 0x01);
+    // Block content.
+    out.put((byte) 0x01);
+    // End of block.
+    out.put((byte) 0x00);
+  }
+
+  public static void writeColorTable(ByteBuffer out, int numColors) {
+    verifyRemaining(out, getColorTableLength(numColors));
+    for (int i = 0; i < numColors; i++) {
+      out.put((byte) (0xFF0000 & i));
+      out.put((byte) (0x00FF00 & i));
+      out.put((byte) (0x0000FF & i));
+    }
+  }
+
+  public static void writeImageDescriptor(ByteBuffer out, int imageLeft, int imageTop,
+      int imageWidth, int imageHeight, boolean hasLct, int numColors) {
+    verifyRemaining(out, IMAGE_DESCRIPTOR_LENGTH);
+    verifyShortValues(imageLeft, imageTop, imageWidth, imageHeight);
+
+    final byte packed;
+    if (hasLct) {
+      int size = log2(numColors) - 1;
+      packed = (byte) (0x80 | size);
+    } else {
+      packed = 0x00;
+    }
+
+    // Image separator
+    out.put((byte) 0x2C);
+    out.putShort((short) imageLeft).putShort((short) imageTop).putShort((short) imageWidth)
+        .putShort((short) imageHeight).put(packed);
+  }
+
+  private static int log2(int num) {
+    return (int) Math.round(Math.log(num) / Math.log(2));
+  }
+
+  public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, boolean hasGct,
+      int gctSize) {
+    verifyRemaining(out, HEADER_LENGTH);
+    verifyShortValues(width, height);
+
+    // GIF
+    out.put((byte) 0x47).put((byte) 0x49).put((byte) 0x46);
+    // Version - 89a.
+    out.put((byte) 0x38).put((byte) 0x39).put((byte) 0x61);
+
+    /** LSD (Logical Screen Descriptor) **/
+    // Width.
+    out.putShort((short) width);
+    // Height.
+    out.putShort((short) height);
+    // Packed GCT (Global Color Table) flag + color resolution + sort flag + size of GCT.
+    // GCT flag (false) - most significant bit.
+    byte gctFlag = (byte) ((hasGct ? 1 : 0) << 7);
+    // Color resolution - next three bits.
+    byte colorResolution = 1 << 5;
+    // Sort flag - next bit;
+    byte sortFlag = 0 << 4;
+    // exponent of size of color table, size = 2^(1 + exponent) - least significant 3 bits.
+    byte size = (byte) gctSize;
+
+    byte packed = (byte) (gctFlag | colorResolution | sortFlag | size);
+    out.put(packed);
+
+    // Background color index.
+    out.put((byte) 0);
+
+    // Pixel aspect ratio.
+    out.put((byte) 0);
+  }
+
+  public static void writeGraphicsControlExtension(ByteBuffer out, int delayTime) {
+    verifyRemaining(out, GRAPHICS_CONTROL_EXTENSION_LENGTH);
+    verifyShortValues(delayTime);
+
+    // Extension inducer (constant).
+    out.put((byte) 0x21);
+    // Graphic control label (constant).
+    out.put((byte) 0xF9);
+    // Block size (constant).
+    out.put((byte) 0x04);
+    // Packed (disposal method, user input, transparent color flag)
+    out.put((byte) 0x00);
+
+    // Frame delay in 100ths of a second.
+    out.putShort((short) delayTime);
+
+    // Transparent color index.
+    out.put((byte) 0x00);
+
+    // Block terminator (constant).
+    out.put((byte) 0x00);
+  }
+
+  private static void verifyRemaining(ByteBuffer buffer, int expected) {
+    if (buffer.remaining() < expected) {
+      throw new IllegalArgumentException("Must have at least " + expected + " bytes to write");
+    }
+  }
+
+  private static void verifyShortValues(int... shortValues) {
+    for (int dimen : shortValues) {
+      if (dimen > Short.MAX_VALUE || dimen < 0) {
+        throw new IllegalArgumentException(
+            "Must pass in non-negative short dimensions, not: " + dimen);
+      }
+    }
+  }
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
new file mode 100644
index 000000000..680f49d09
--- /dev/null
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
@@ -0,0 +1,148 @@
+package com.bumptech.glide.gifdecoder.test;
+
+import static org.junit.Assert.assertArrayEquals;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Tests for {@link com.bumptech.glide.gifdecoder.test.GifBytesTestUtil}.
+ */
+@RunWith(JUnit4.class)
+public class GifBytesTestUtilTest {
+
+  @Test
+  public void testWriteHeaderAndLsdWithoutGct() {
+    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH);
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 8, 16, false, 0);
+
+    byte[] expected =
+        new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00, 0x08, 0x00, 0x10, 0x20, 0x00, 0x00 };
+
+    assertEquals(expected, buffer);
+  }
+
+  @Test
+  public void testWriteHeaderAndLsdWithGct() {
+    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH);
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 8, 16, true, 4);
+
+    byte[] expected =
+        new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00, 0x08, 0x00, 0x10, (byte) 0xA4, 0x00,
+            0x00 };
+
+    assertEquals(expected, buffer);
+  }
+
+  @Test
+  public void testWriteImageDescriptorWithoutColorTable() {
+    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7, false, 0);
+
+    byte[] expected = new byte[] {
+        // Image separator.
+        0x2C,
+        // Image left.
+        0x00, 0x0A,
+        // Image right.
+        0x00, 0X09,
+        // Image width.
+        0x00, 0x08,
+        // Image height.
+        0x00, 0x07,
+        // Packed field.
+        0x00 };
+
+    assertEquals(expected, buffer);
+  }
+
+  @Test
+  public void testWriteImageDescriptorWithColorTable() {
+    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7, true, 4);
+
+    byte packedField =
+        // Set LCT flag
+        (byte) 0x80
+            // Size of color table (2^(N + 1) == 4)
+            | 0x01;
+
+    byte[] expected = new byte[] {
+        // Image separator.
+        0x2C,
+        // Image left.
+        0x00, 0x0A,
+        // Image right.
+        0x00, 0X09,
+        // Image width.
+        0x00, 0x08,
+        // Image height.
+        0x00, 0x07, packedField };
+
+    assertEquals(expected, buffer);
+  }
+
+  @Test
+  public void testWriteColorTable() {
+    final int numColors = 4;
+    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.getColorTableLength(numColors));
+    GifBytesTestUtil.writeColorTable(buffer, numColors);
+
+    byte[] expected = new byte[] {
+        // First color.
+        0x00, 0x00, 0x00,
+        // Second color.
+        0x00, 0x00, 0x01,
+        // Third color.
+        0x00, 0x00, 0x02,
+        // Fourth color.
+        0x00, 0x00, 0x03, };
+
+
+    assertEquals(expected, buffer);
+  }
+
+  @Test
+  public void testWriteFakeImageData() {
+    ByteBuffer buffer = ByteBuffer.allocate(4);
+    GifBytesTestUtil.writeFakeImageData(buffer, 2);
+
+    byte[] expected = new byte[] { 0x02, 0x01, 0x01, 0x00 };
+
+    assertEquals(expected, buffer);
+  }
+
+  @Test
+  public void testWritesGraphicsControlExtension() {
+    short delay = 20;
+    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH);
+    byte[] expected = new byte[] {
+        // Extension inducer.
+        0x21,
+        // Graphic control label.
+        (byte) 0xF9,
+        // Block size.
+        0x04,
+        // Packed byte.
+        0x00,
+        // Frame delay.
+        0x00, 0x14,
+        // Transparent color index.
+        0x00,
+        // block terminator.
+        0x00 };
+
+    GifBytesTestUtil.writeGraphicsControlExtension(buffer, delay);
+    assertEquals(expected, buffer);
+  }
+
+  private static void assertEquals(byte[] expected, ByteBuffer buffer) {
+    assertArrayEquals(
+        "expected=" + Arrays.toString(expected) + " received=" + Arrays.toString(buffer.array()),
+        expected, buffer.array());
+  }
+}
diff --git a/third_party/gif_decoder/src/androidTest/resources/gif_without_graphical_control_extension.gif b/third_party/gif_decoder/src/test/resources/gif_without_graphical_control_extension.gif
similarity index 100%
rename from third_party/gif_decoder/src/androidTest/resources/gif_without_graphical_control_extension.gif
rename to third_party/gif_decoder/src/test/resources/gif_without_graphical_control_extension.gif
diff --git a/third_party/gif_decoder/src/androidTest/resources/partial_gif_decode.gif b/third_party/gif_decoder/src/test/resources/partial_gif_decode.gif
similarity index 100%
rename from third_party/gif_decoder/src/androidTest/resources/partial_gif_decode.gif
rename to third_party/gif_decoder/src/test/resources/partial_gif_decode.gif
diff --git a/third_party/gif_decoder/src/test/resources/transparent_dispose.gif b/third_party/gif_decoder/src/test/resources/transparent_dispose.gif
new file mode 100644
index 000000000..3c64b1d65
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/transparent_dispose.gif differ
diff --git a/third_party/gif_encoder/build.gradle b/third_party/gif_encoder/build.gradle
deleted file mode 100644
index 6d2143286..000000000
--- a/third_party/gif_encoder/build.gradle
+++ /dev/null
@@ -1,12 +0,0 @@
-apply plugin: 'com.android.library'
-
-android {
-    compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
-
-    defaultConfig {
-        applicationId 'com.bumptech.glide.gifencoder'
-        minSdkVersion MIN_SDK_VERSION as int
-        targetSdkVersion TARGET_SDK_VERSION as int
-    }
-}
diff --git a/third_party/gif_encoder/gif_encoder.iml b/third_party/gif_encoder/gif_encoder.iml
deleted file mode 100644
index 2a8f3ee75..000000000
--- a/third_party/gif_encoder/gif_encoder.iml
+++ /dev/null
@@ -1,87 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":third_party:gif_encoder" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.third_party" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":third_party:gif_encoder" />
-      </configuration>
-    </facet>
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="SELECTED_BUILD_VARIANT" value="debug" />
-        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
-        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
-        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
-        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
-        <option name="ALLOW_USER_CONFIGURATION" value="false" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
-        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
-        <option name="LIBRARY_PROJECT" value="true" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
-      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
-      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
-      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
-      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 19 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index aa1123f67..e08a214f7 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -22,6 +22,7 @@
  *     e.setDelay(1000);   // 1 frame per sec
  *     e.addFrame(image1);
  *     e.addFrame(image2);
+ *     e.addFrame(image3, 100, 100);    // set position of the frame
  *     e.finish();
  * </pre>
  *
@@ -38,13 +39,18 @@
 public class AnimatedGifEncoder {
     private static final String TAG = "AnimatedGifEncoder";
 
-    // The minimum % of an images pixels that must be transparent for us to set a transparent index automatically.
+    // The minimum % of an images pixels that must be transparent for us to set a transparent index
+    // automatically.
     private static final double MIN_TRANSPARENT_PERCENTAGE = 4d;
 
     private int width; // image size
 
     private int height;
 
+    private int fixedWidth;   // set by setSize()
+
+    private int fixedHeight;
+
     private Integer transparent = null; // transparent color if given
 
     private int transIndex; // transparent index in color table
@@ -140,22 +146,46 @@ public void setTransparent(int color) {
      * Adds next GIF frame. The frame is not written immediately, but is actually
      * deferred until the next frame is received so that timing data can be
      * inserted. Invoking <code>finish()</code> flushes all frames. If
-     * <code>setSize</code> was not invoked, the size of the first image is used
-     * for all subsequent frames.
+     * <code>setSize</code> was invoked, the size is used for all subsequent frames.
+     * Otherwise, the actual size of the image is used for each frames.
      *
      * @param im
      *          BufferedImage containing frame to write.
      * @return true if successful.
      */
     public boolean addFrame(Bitmap im) {
+        return addFrame(im, 0, 0);
+    }
+
+    /**
+     * Adds next GIF frame to the specified position. The frame is not written immediately, but is
+     * actually deferred until the next frame is received so that timing data can be inserted.
+     * Invoking <code>finish()</code> flushes all frames. If <code>setSize</code> was invoked, the
+     * size is used for all subsequent frames. Otherwise, the actual size of the image is used for
+     * each frame.
+     *
+     * See page 11 of http://giflib.sourceforge.net/gif89.txt for the position of the frame
+     *
+     * @param im
+     *          BufferedImage containing frame to write.
+     * @param x
+     *          Column number, in pixels, of the left edge of the image, with respect to the left
+     *          edge of the Logical Screen.
+     * @param y
+     *          Row number, in pixels, of the top edge of the image with respect to the top edge of
+     *          the Logical Screen.
+     * @return true if successful.
+     */
+    public boolean addFrame(Bitmap im, int x, int y) {
         if ((im == null) || !started) {
             return false;
         }
         boolean ok = true;
         try {
-            if (!sizeSet) {
-                // use first frame's size
-                setSize(im.getWidth(), im.getHeight());
+            if (sizeSet) {
+                setFrameSize(fixedWidth, fixedHeight);
+            } else {
+                setFrameSize(im.getWidth(), im.getHeight());
             }
             image = im;
             getImagePixels(); // convert to correct format if necessary
@@ -169,7 +199,7 @@ public boolean addFrame(Bitmap im) {
                 }
             }
             writeGraphicCtrlExt(); // write graphic control extension
-            writeImageDesc(); // image descriptor
+            writeImageDesc(x, y); // image descriptor
             if (!firstFrame) {
                 writePalette(); // local color table
             }
@@ -243,8 +273,8 @@ public void setQuality(int quality) {
     }
 
     /**
-     * Sets the GIF frame size. The default size is the size of the first frame
-     * added if this method is not invoked.
+     * Sets the fixed GIF frame size for all the frames.
+     * This should be called before start.
      *
      * @param w
      *          int frame width.
@@ -252,15 +282,33 @@ public void setQuality(int quality) {
      *          int frame width.
      */
     public void setSize(int w, int h) {
-        if (started && !firstFrame)
+        if (started) {
             return;
+        }
+
+        fixedWidth = w;
+        fixedHeight = h;
+        if (fixedWidth < 1) {
+            fixedWidth = 320;
+        }
+        if (fixedHeight < 1) {
+            fixedHeight = 240;
+        }
+
+        sizeSet = true;
+    }
+
+    /**
+     * Sets current GIF frame size.
+     *
+     * @param w
+     *          int frame width.
+     * @param h
+     *          int frame width.
+     */
+    private void setFrameSize(int w, int h) {
         width = w;
         height = h;
-        if (width < 1)
-            width = 320;
-        if (height < 1)
-            height = 240;
-        sizeSet = true;
     }
 
     /**
@@ -400,11 +448,12 @@ private void getImagePixels() {
         }
 
         double transparentPercentage = 100 * totalTransparentPixels / (double) pixelsInt.length;
-        // Assume images with greater where more than n% of the pixels are transparent actually have transparency.
-        // See issue #214.
+        // Assume images with greater where more than n% of the pixels are transparent actually have
+        // transparency. See issue #214.
         hasTransparentPixels = transparentPercentage > MIN_TRANSPARENT_PERCENTAGE;
         if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "got pixels for frame with " + transparentPercentage + "% transparent pixels");
+            Log.d(TAG, "got pixels for frame with " + transparentPercentage
+                + "% transparent pixels");
         }
     }
 
@@ -442,10 +491,10 @@ private void writeGraphicCtrlExt() throws IOException {
     /**
      * Writes Image Descriptor
      */
-    private void writeImageDesc() throws IOException {
+    private void writeImageDesc(int x, int y) throws IOException {
         out.write(0x2c); // image separator
-        writeShort(0); // image position x,y = 0,0
-        writeShort(0);
+        writeShort(x); // image position
+        writeShort(y);
         writeShort(width); // image size
         writeShort(height);
         // packed fields
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/LZWEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/LZWEncoder.java
index 0d61ef48a..41febf606 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/LZWEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/LZWEncoder.java
@@ -6,7 +6,6 @@
 // ==============================================================================
 // Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.
 // K Weiner 12/00
-
 class LZWEncoder {
 
     private static final int EOF = -1;
diff --git a/third_party/third_party.iml b/third_party/third_party.iml
deleted file mode 100644
index f1ddc76e2..000000000
--- a/third_party/third_party.iml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":third_party" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="android-gradle" name="Android-Gradle">
-      <configuration>
-        <option name="GRADLE_PROJECT_PATH" value=":third_party" />
-      </configuration>
-    </facet>
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-      <excludeFolder url="file://$MODULE_DIR$/build" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
-
