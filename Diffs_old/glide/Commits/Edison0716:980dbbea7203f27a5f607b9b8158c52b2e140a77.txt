diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 5e89d0815..53e21086b 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -632,6 +632,7 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
 
+    //建立请求
     Request request = buildRequest(target, targetListener, options, callbackExecutor);
 
     Request previous = target.getRequest();
@@ -653,6 +654,7 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
 
     requestManager.clear(target);
     target.setRequest(request);
+    //追踪请求
     requestManager.track(target, request);
 
     return target;
@@ -903,6 +905,7 @@ private Request buildRequestRecursive(
       parentCoordinator = errorRequestCoordinator;
     }
 
+    //创建缩略图请求
     Request mainRequest =
         buildThumbnailRequestRecursive(
             target,
@@ -927,6 +930,7 @@ private Request buildRequestRecursive(
       errorOverrideHeight = requestOptions.getOverrideHeight();
     }
 
+    //错误请求
     Request errorRequest =
         errorBuilder.buildRequestRecursive(
             target,
@@ -938,6 +942,7 @@ private Request buildRequestRecursive(
             errorOverrideHeight,
             errorBuilder,
             callbackExecutor);
+    //关联
     errorRequestCoordinator.setRequests(mainRequest, errorRequest);
     return errorRequestCoordinator;
   }
@@ -980,6 +985,7 @@ private Request buildThumbnailRequestRecursive(
       }
 
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+      //正常请求对象
       Request fullRequest =
           obtainRequest(
               target,
@@ -1005,6 +1011,7 @@ private Request buildThumbnailRequestRecursive(
               thumbnailBuilder,
               callbackExecutor);
       isThumbnailBuilt = false;
+      //关联
       coordinator.setRequests(fullRequest, thumbRequest);
       return coordinator;
     } else if (thumbSizeMultiplier != null) {
@@ -1053,6 +1060,7 @@ private Request buildThumbnailRequestRecursive(
     }
   }
 
+
   private Request obtainRequest(
       Target<TranscodeType> target,
       RequestListener<TranscodeType> targetListener,
@@ -1063,6 +1071,7 @@ private Request obtainRequest(
       int overrideWidth,
       int overrideHeight,
       Executor callbackExecutor) {
+    //真正的请求对象
     return SingleRequest.obtain(
         context,
         glideContext,
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index 8373a1efa..f6b7e9eda 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -57,7 +57,9 @@ public void loadData(@NonNull Priority priority,
       @NonNull DataCallback<? super InputStream> callback) {
     long startTime = LogTime.getLogTime();
     try {
+      //请求获得图片流
       InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
+      //回调
       callback.onDataReady(result);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index f98f5679b..07524ef8a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -226,6 +226,7 @@ public void run() {
     GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);
     // Methods in the try statement can invalidate currentFetcher, so set a local variable here to
     // ensure that the fetcher is cleaned up either way.
+    // 网络请求子线程
     DataFetcher<?> localFetcher = currentFetcher;
     try {
       if (isCancelled) {
@@ -286,6 +287,7 @@ private void runWrapped() {
     }
   }
 
+  // 关注点1，完整情况下，会异步依次生成这里的ResourceCacheGenerator、DataCacheGenerator和SourceGenerator对象，并在之后执行其中的startNext()
   private DataFetcherGenerator getNextGenerator() {
     switch (stage) {
       case RESOURCE_CACHE:
@@ -293,6 +295,7 @@ private DataFetcherGenerator getNextGenerator() {
       case DATA_CACHE:
         return new DataCacheGenerator(decodeHelper, this);
       case SOURCE:
+        //关键点在这 进行网络请求
         return new SourceGenerator(decodeHelper, this);
       case FINISHED:
         return null;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 54697616d..231aa9f00 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -177,8 +177,10 @@ public Engine(
     EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
         resourceClass, transcodeClass, options);
 
+    //先从弱引用查找
     EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
     if (active != null) {
+      //找到直接回调 到 SingleRequest onResourceReady
       cb.onResourceReady(active, DataSource.MEMORY_CACHE);
       if (VERBOSE_IS_LOGGABLE) {
         logWithTimeAndKey("Loaded resource from active resources", startTime, key);
@@ -186,8 +188,10 @@ public Engine(
       return null;
     }
 
+    //弱引用没有则内存中查找 有的话 存入弱引用中
     EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
     if (cached != null) {
+      //找到直接回调 到 SingleRequest onResourceReady
       cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
       if (VERBOSE_IS_LOGGABLE) {
         logWithTimeAndKey("Loaded resource from cache", startTime, key);
@@ -267,6 +271,7 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     EngineResource<?> cached = getEngineResourceFromCache(key);
     if (cached != null) {
       cached.acquire();
+      //存入弱引用
       activeResources.activate(key, cached);
     }
     return cached;
