diff --git a/README.md b/README.md
index 4301cb748..f5e872511 100644
--- a/README.md
+++ b/README.md
@@ -656,6 +656,7 @@ RuntimeCompat：可用进程数
   }
 ```
 ### LruBitmapPool
+* LruPoolStrategy：默认创建位图大小与位图配置策略SizeConfigStrategy
 ```java
   public class LruBitmapPool implements BitmapPool{
     private static final String TAG="LruBitmapPool";
@@ -821,6 +822,7 @@ RuntimeCompat：可用进程数
     private static Set<Bitmap.Config> getDefaultAllowedConfigs(){
       Set<Bitmap.Config> configs=new HashSet<>(Arrays.asList(Bitmap.Config.values()));
       if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.KITKAT){
+        //GIFs 占坑
         configs.add(null);
       }
       if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O){
@@ -880,6 +882,7 @@ SizeConfigStrategy
     private static final Bitmap.Config[] ALPHA_8_IN_CONFIGS=new Bitmap.Config[]{Bitmap.Config.ALPHA_8};
     
     private final KeyPool keyPool=new KeyPool();
+    //类似：LinkedHashMap,
     private final GroupedLinkedMap<Key,Bitmap> groupedMap=new GroupedLinkedMap<>();
     private final Map<Bitmap.Config,NavigableMap<Integer,Integer>> sortedSizes=new HashMap<>();
     
@@ -1048,6 +1051,96 @@ SizeConfigStrategy
     }
   }
 ```
+AttributeStrategy
+```java
+  class AttributeStrategy implements LruPoolStrategy{
+    private final KeyPool keyPool=new KeyPool();
+    private final GroupedLinkedMap<Key,Bitmap> groupedMap=new GroupedLinkedMap<>();
+    @Override
+    public void put(Bitmap bitmap){
+      final Key key=keyPool.get(bitmap.getWidth(),bitmap.getHeight(),bitmap.getConfig());
+      groupedMap.put(key,map);
+    }
+    @Override
+    public Bitmap get(int width,int height,Bitmap.Config config){
+      final Key key=keyPool.get(width,height,config);
+      return groupedMap.get(key);
+    }
+    @Override
+    public Bitmap removeLast(){
+      return groupedMap.removeLast();
+    }
+    @Override
+    public String logBitmap(Bitmap bitmap){
+      return getBitmapString(bitmap);
+    }
+    @Override
+    public String logBitmap(int width,int height,Bitmap.Config config){
+      return getBitmapString(width,height,config);
+    }
+    @Override
+    public int getSize(Bitmap bitmap){
+      return Util.getBitmapByteSize(bitmap);
+    }
+    @Override
+    public String toString(){
+      return "AttributeStrategy:\n"+groupedMap;
+    }
+    private static String getBitmapString(Bitmap bitmap){
+      return getBitmapString(bitmap.getWidth(),bitmap.getHeight(),bitmap.getConfig());
+    }
+    static String getBitmapString(int width,int height,Bitmap.Config config){
+      return "["+width+"x"+height+"],"+config;
+    }
+    static class KeyPool extends BaseKeyPool<Key>{
+      Key get(int width,int height,Bitmap.Config config){
+        Key result=get();
+        result.init(width,height,config);
+        return result;
+      }
+      @Override
+      protected Key create(){
+        return new Key(this);
+      }
+    }
+    static class Key implements Poolable{
+      private final KeyPool pool;
+      private int width;
+      private int height;
+      private Bitmap.Config config;
+      public Key(KeyPool pool){
+        this.pool=pool;
+      }
+      public void init(int width,int height,Bitmap.Config config){
+        this.width=width;
+        this.height=height;
+        this.config=config;
+      }
+      public boolean equals(Object o){
+        if(o instanceof Key){
+          Key other=(Key)o;
+          return width==other.width&&height==other.height&&config==other.config;
+        }
+        return false;
+      }
+      @Override
+      public int hashCode(){
+        int result=width;
+        result=31*result+height;
+        result=31*result+(config!=null?config.hashCode():0);
+        return result;
+      }
+      @Override
+      public String toString(){
+        return getBitmapString(width,height,config);
+      }
+      @Override
+      public void offer(){
+        pool.offer(this);
+      }
+    }
+  }
+```
 BaseKeyPool
 ```java
   abstract class BaseKeyPool<T extends Poolable>{
@@ -1205,7 +1298,118 @@ Util
     }
   }
 ```
-
+GroupedLinkedMap:类似LinkedHashMap
+```java
+  class GroupedLinkedMap<K extends Poolable,V>{
+    private final LinkedEntry<K,V> head=new LinkedEntry<>();
+    private final Map<K,LinkedEntry<K,V>> keyToEntry = new HashMap<>();
+    
+    public void put(K key,V value){
+      LinkedEntry<K,V> entry=keyToEntry.get(key);
+      if(entry==null){
+        entry=new LinkedEntry<>(key);//下一个==上一个==当前
+        makeTail(entry);
+        keyToEntry.put(key,entry);
+      }else{
+        key.offer();
+      }
+      entry.add(value);
+    }
+    @Nullable
+    public V get(K key){
+      LinkedEntry<K,V> entry=keyToEntry.get(key);
+      if(entry==null){
+        entry=new LinkedEntry<>(key);
+        keyToEntry.put(key,entry);
+      }else{
+        key.offer();
+      }
+      makeHead(entry);
+      return entry.removeLast();
+    }
+    @Nullable
+    public V removeLast(){
+      LinkedEntry<K,V> last = head.prev;
+      while(!last.equals(head)){
+        V removed = last.removeLast();
+        if(removed!=null){
+          return removed;
+        }else{
+          removeEntry(last);
+          keyToEntry.remove(last.key);
+          last.key.offer();
+        }
+        last=last.prev;
+      }
+      return null;
+    }
+    @Override
+    public String toString(){
+      StringBuilder sb=new StringBuilder("GroupedLinkedMap(");
+      LinkedEntry<K,V> current=head.next;
+      boolean hadAtLeastOneItem=false;
+      while(!current.equals(head)){
+        hadAtLeastOneItem=true;
+        sb.append("{").append(current.key).append(":").append(current.size()).append("}, ");
+        current=current.next;
+      }
+      if(hadAtLeastOneItem){
+        sb.delete(sb.length()-2,sb.length());
+      }
+      return sb.append(")").toString();
+    }
+    private void makeHead(LinkedEntry<K,V> entry){
+      removeEntry(entry);
+      entry.prev=head;
+      entry.next=head.next;
+      updateEntry(entry);
+    }
+    private void makeTail(LinkedEntry<K,V> entry){
+      removeEntry(entry);
+      entry.prev=head.prev;
+      entry.next=head;
+      updateEntry(entry);
+    }
+    private static <K,V> void updateEntry(LinkedEntry<K,V> entry){
+      entry.next.prev=entry;
+      entry.prev.next=entry;
+    }
+    private static <K,V> void removeEntry(LinkedEntry<K,V> entry){
+      entry.prev.next=entry.next;
+      entry.next.prev=entry.prev;
+    }
+    
+    private static class LinkedEntry<K,V>{
+      @Synthetic final K key;
+      private List<V> values;
+      LinkedEntry<K,V> next;
+      LinkedEntry<K,V> prev;
+      
+      LinkedEntry(){
+        this(null);
+      }
+      LinkedEntry(K key){
+        next=prev=this;
+        this.key=key;
+      }
+      @Nullable
+      public V removeLast(){
+        final int valueSize=size();
+        return valueSize>0?values.remove(valueSize-1):null;
+      }
+      public int size(){
+        return values!=null?values.szie():0;
+      }
+      public void add(V value){
+        if(values==null){
+          values=new ArrayList<>();
+        }
+        values.add(value);
+      }
+    }
+  }
+  
+```
 
 
 
