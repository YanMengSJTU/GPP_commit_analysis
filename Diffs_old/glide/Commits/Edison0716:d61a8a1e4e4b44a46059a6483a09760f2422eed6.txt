diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index a4ceab042..abad5c466 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -165,11 +165,11 @@ public static Glide get(@NonNull Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
+          //双重检查锁 用于判断Glide只初始化一次
           checkAndInitializeGlide(context);
         }
       }
     }
-
     return glide;
   }
 
@@ -223,10 +223,13 @@ private static void initializeGlide(@NonNull Context context) {
     initializeGlide(context, new GlideBuilder());
   }
 
+  //4.0以后 配置Glide不需要再Manifest中注册 通過註解注解
   @SuppressWarnings("deprecation")
   private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
     Context applicationContext = context.getApplicationContext();
+    //获取被注解的GlideModel文件
     GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
+    //获取在Manifest中设置的Glide GlideModel 为空 并且配置manifest中设置为true
     List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
     if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
       manifestModules = new ManifestParser(applicationContext).parse();
@@ -259,13 +262,17 @@ private static void initializeGlide(@NonNull Context context, @NonNull GlideBuil
         annotationGeneratedModule != null
             ? annotationGeneratedModule.getRequestManagerFactory() : null;
     builder.setRequestManagerFactory(factory);
+    //遍历
     for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       module.applyOptions(applicationContext, builder);
     }
+    //应用
     if (annotationGeneratedModule != null) {
       annotationGeneratedModule.applyOptions(applicationContext, builder);
     }
+    //glide设置配置信息
     Glide glide = builder.build(applicationContext);
+    //替换Glide默认组件
     for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       try {
         module.registerComponents(applicationContext, glide, glide.registry);
@@ -344,6 +351,9 @@ private static void throwIncorrectGlideModule(Exception e) {
 
     final Resources resources = context.getResources();
 
+    // 注册管理任务执行对象的类(Registry)
+    // Registry是一个工厂，而其中所有注册的对象都是一个工厂员工，当任务分发时，
+    // 根据当前任务的性质，分发给相应员工进行处理
     registry = new Registry();
     registry.register(new DefaultImageHeaderParser());
     // Right now we're only using this parser for HEIF images, which are only supported on OMR1+.
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index fd4d859a2..f44e470c5 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -435,14 +435,15 @@ GlideBuilder setEngine(Engine engine) {
 
   @NonNull
   Glide build(@NonNull Context context) {
+    //创建图片网络请求线程池
     if (sourceExecutor == null) {
       sourceExecutor = GlideExecutor.newSourceExecutor();
     }
-
+    //创建硬盘缓存线程池
     if (diskCacheExecutor == null) {
       diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
-
+    //动画线程池
     if (animationExecutor == null) {
       animationExecutor = GlideExecutor.newAnimationExecutor();
     }
@@ -456,10 +457,13 @@ Glide build(@NonNull Context context) {
     }
 
     if (bitmapPool == null) {
+      //根据屏幕密度和尺寸设置pool size
       int size = memorySizeCalculator.getBitmapPoolSize();
       if (size > 0) {
+        //缓存操作
         bitmapPool = new LruBitmapPool(size);
       } else {
+        //基本不做任何缓存
         bitmapPool = new BitmapPoolAdapter();
       }
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index 58ee33826..304f5bf6a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -15,8 +15,10 @@
 
   @Override
   public void put(Bitmap bitmap) {
+    //获取Key
     final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
 
+    //分组
     groupedMap.put(key, bitmap);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
index ccb085511..c08034a96 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
@@ -4,7 +4,9 @@
 import java.util.Queue;
 
 abstract class BaseKeyPool<T extends Poolable> {
+  //前20张图片进行缓存
   private static final int MAX_SIZE = 20;
+  //保存到队列中
   private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);
 
   T get() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index 9060fd825..933c46f3c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -17,6 +17,23 @@
  * no bitmaps of that size are present. We do not count addition or removal of bitmaps as an
  * access.
  */
+
+/**
+ * groupedMap是GroupedLinkedMap的实例，GroupedLinkedMap内部使用了一个名为head的链表，链表的key是由bitmap size和config构成的Key，
+ * value是一个由bitmap构成的链表。这样GroupedLinkedMap中的每个元素就相当于是一个组，这个组中的bitmap具有相同的size和config,
+ * 对应的存储类实现就是GroupedLinkedMap中的LinkedEntry。同时，为了加快查找速度，GroupedLinkedMap中还有一个keyToEntry的Hashmap，
+ * 将key和链表中的LinkedEntry对应起来。
+ * 在GroupedLinkedMap的Put和get方法中，会将操作元素对应所在的LinkedEntry在head链表中往前移动，由于链表的移动成本很低，因存取效率很高。
+ * ---------------------
+ * 作者：大雀儿飞飞
+ * 来源：CSDN
+ * 原文：https://blog.csdn.net/yxz329130952/article/details/65447706
+ * 版权声明：本文为博主原创文章，转载请附上博文链接！
+ *
+ *
+ * https://www.jianshu.com/p/62b7f990ee83 分析的也挺好
+ */
+
 class GroupedLinkedMap<K extends Poolable, V> {
   private final LinkedEntry<K, V> head = new LinkedEntry<>();
   private final Map<K, LinkedEntry<K, V>> keyToEntry = new HashMap<>();
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index d233c9130..36345b54d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -226,6 +226,7 @@ public void trimMemory(int level) {
   }
 
   private synchronized void trimToSize(long size) {
+    //如果当前的BitmapPool占用大于最大内存
     while (currentSize > size) {
       final Bitmap removed = strategy.removeLast();
       // TODO: This shouldn't ever happen, see #331.
@@ -259,9 +260,11 @@ private void dumpUnchecked() {
         + ", currentSize=" + currentSize + ", maxSize=" + maxSize + "\nStrategy=" + strategy);
   }
 
+
   private static LruPoolStrategy getDefaultStrategy() {
     final LruPoolStrategy strategy;
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      //API大于19
       strategy = new SizeConfigStrategy();
     } else {
       strategy = new AttributeStrategy();
@@ -297,7 +300,7 @@ private static LruPoolStrategy getDefaultStrategy() {
 
     @Override
     public void add(Bitmap bitmap) {
-      if (bitmaps.contains(bitmap)) {
+      if (bitmaps.contains(bitmap)) { //相同的 bitmap 不能添加
         throw new IllegalStateException(
             "Can't add already added bitmap: " + bitmap + " [" + bitmap.getWidth() + "x" + bitmap
                 .getHeight() + "]");
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
index 376dd9665..80e1eb553 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
@@ -3,18 +3,59 @@
 import android.graphics.Bitmap;
 import android.support.annotation.Nullable;
 
+/**
+ * The interface Lru pool strategy.
+ */
 interface LruPoolStrategy {
+  /**
+   * 增加一个缓存
+   *
+   * @param bitmap the bitmap
+   */
   void put(Bitmap bitmap);
 
+  /**
+   * 从缓存中获取指定尺寸和配置的图片
+   *
+   * @param width  the width
+   * @param height the height
+   * @param config the config
+   * @return the bitmap
+   */
   @Nullable
   Bitmap get(int width, int height, Bitmap.Config config);
 
+  /**
+   * 删除一个最不常用的 在Bitmap size > 可用bitmapPoolSize
+   *
+   * @return the bitmap
+   */
   @Nullable
   Bitmap removeLast();
 
+  /**
+   * Log bitmap string.
+   *
+   * @param bitmap the bitmap
+   * @return the string
+   */
   String logBitmap(Bitmap bitmap);
 
+  /**
+   * Log bitmap string.
+   *
+   * @param width  the width
+   * @param height the height
+   * @param config the config
+   * @return the string
+   */
   String logBitmap(int width, int height, Bitmap.Config config);
 
+  /**
+   * 获取图片占用的空间
+   *
+   * @param bitmap the bitmap
+   * @return the size
+   */
   int getSize(Bitmap bitmap);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index a4b0f46b4..518dfe5ff 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -56,6 +56,12 @@
 
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
+  /**
+   * sortedSizes实际上是groupedMap的一个概要信息，他不做缓存，只表明SizeConfigStrategy中的GroupedLinkedMap中指定size和config的bitmap有多少。
+   * 它是一个Hashmap，其中key是bitmap config，value是TreeMap，TreeMap的key为bitmap size，value为bitmap的数量，
+   * 这样一来，首先通过config能够查询到缓存中bitmap config为指定值的bitmap有哪些大小的，然后每个大小后面的数据由表明了这种config和size的bitmap在内存中还有多少，
+   * 所以缓存中的bitmap信息也就一目了然。
+   */
   private final Map<Bitmap.Config, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
 
   @Override
@@ -73,24 +79,26 @@ public void put(Bitmap bitmap) {
   @Override
   @Nullable
   public Bitmap get(int width, int height, Bitmap.Config config) {
-    int size = Util.getBitmapByteSize(width, height, config);
+    int size = Util.getBitmapByteSize(width, height, config);//计算出bitmap的size
     Key bestKey = findBestKey(size, config);
 
-    Bitmap result = groupedMap.get(bestKey);
+    Bitmap result = groupedMap.get(bestKey);//从缓存中获取并删除
     if (result != null) {
       // Decrement must be called before reconfigure.
-      decrementBitmapOfSize(bestKey.size, result);
-      result.reconfigure(width, height, config);
+      decrementBitmapOfSize(bestKey.size, result);// 缓存命中 则 记录信息要减一
+      result.reconfigure(width, height, config); // 在底层图片存储不变的情况下将缓存配置成要求的图片
     }
     return result;
   }
 
+  //获取Key
   private Key findBestKey(int size, Bitmap.Config config) {
     Key result = keyPool.get(size, config);
     for (Bitmap.Config possibleConfig : getInConfigs(config)) {
       NavigableMap<Integer, Integer> sizesForPossibleConfig = getSizesForConfig(possibleConfig);
       Integer possibleSize = sizesForPossibleConfig.ceilingKey(size);
       if (possibleSize != null && possibleSize <= size * MAX_SIZE_MULTIPLE) {
+        //size config 不一定非得完全相等
         if (possibleSize != size
             || (possibleConfig == null ? config != null : !possibleConfig.equals(config))) {
           keyPool.offer(result);
@@ -131,6 +139,11 @@ private void decrementBitmapOfSize(Integer size, Bitmap removed) {
     }
   }
 
+  /**
+   * 获取一种config对应有哪些不同大小图片的概要信息
+   * @param config
+   * @return
+   */
   private NavigableMap<Integer, Integer> getSizesForConfig(Bitmap.Config config) {
     NavigableMap<Integer, Integer> sizes = sortedSizes.get(config);
     if (sizes == null) {
@@ -173,6 +186,10 @@ public String toString() {
     return sb.append(")}").toString();
   }
 
+  /**
+   * 由于存在很多图片大小相同且图片配置类型也一样的图片（这是使用Glide的前提假设），为了更加快速地构建
+   * 图片缓存的key，将最近常用的Key缓存起来。避免每次都使用size和config来创建一个新的对象。
+   */
   @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
@@ -188,6 +205,9 @@ protected Key create() {
     }
   }
 
+  /**
+   * 将bitmap的大小和配置封装，作为后面缓存存取的key.
+   */
   @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 1418c466b..39f15879b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -35,23 +35,24 @@
   MemorySizeCalculator(MemorySizeCalculator.Builder builder) {
     this.context = builder.context;
 
+    //内存默认是4M 低内存设备则除以2
     arrayPoolSize =
         isLowMemoryDevice(builder.activityManager)
             ? builder.arrayPoolSizeBytes / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
             : builder.arrayPoolSizeBytes;
-    int maxSize =
-        getMaxSize(
-            builder.activityManager, builder.maxSizeMultiplier, builder.lowMemoryMaxSizeMultiplier);
+    int maxSize = getMaxSize(builder.activityManager, builder.maxSizeMultiplier, builder.lowMemoryMaxSizeMultiplier);
 
     int widthPixels = builder.screenDimensions.getWidthPixels();
     int heightPixels = builder.screenDimensions.getHeightPixels();
+    //计算一张屏幕大小的ARGB-8888的图片
     int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;
 
     int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);
 
     int targetMemoryCacheSize = Math.round(screenSize * builder.memoryCacheScreens);
+    // 可用分配给图片的内存 = 最大的可使用的内存 - ArrayPool
     int availableSize = maxSize - arrayPoolSize;
-
+    // 资源超出了 则进行内存限制
     if (targetMemoryCacheSize + targetBitmapPoolSize <= availableSize) {
       memoryCacheSize = targetMemoryCacheSize;
       bitmapPoolSize = targetBitmapPoolSize;
@@ -105,8 +106,10 @@ public int getArrayPoolSizeInBytes() {
 
   private static int getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,
       float lowMemoryMaxSizeMultiplier) {
+    //先去判断当前可使用的内存是多少
     final int memoryClassBytes = activityManager.getMemoryClass() * 1024 * 1024;
     final boolean isLowMemoryDevice = isLowMemoryDevice(activityManager);
+    //判断是否是低内存机型 如果是低内存 0.33 普通内存 0.4
     return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier
         : maxSizeMultiplier));
   }
