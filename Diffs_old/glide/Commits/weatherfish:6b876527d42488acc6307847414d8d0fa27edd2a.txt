diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index aca220c91..2b1f90a78 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -36,7 +36,6 @@ public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
   @Override
   public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
-    boolean isUserAgentSet = false;
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
       requestBuilder.addHeader(key, headerEntry.getValue());
@@ -56,7 +55,7 @@ public void onFailure(Request request, IOException e) {
       public void onResponse(Response response) throws IOException {
         responseBody = response.body();
         if (response.isSuccessful()) {
-          long contentLength = response.body().contentLength();
+          long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
         } else if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
index 17799b54f..4179455e3 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
index c08955f7b..61adb97b1 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -55,7 +54,7 @@ public void onFailure(Call call, IOException e) {
       public void onResponse(Call call, Response response) throws IOException {
         responseBody = response.body();
         if (response.isSuccessful()) {
-          long contentLength = response.body().contentLength();
+          long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
         } else if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 564283f73..a68bfe6c2 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -48,6 +48,7 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableEncoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
@@ -188,12 +189,15 @@ public static void tearDown() {
 
     final Resources resources = context.getResources();
 
-    Downsampler downsampler =
-        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);
+    registry = new Registry();
+    registry.register(new DefaultImageHeaderParser());
+
+    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
+        resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
-        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);
-    registry = new Registry()
-        .register(ByteBuffer.class, new ByteBufferEncoder())
+        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+
+    registry.register(ByteBuffer.class, new ByteBufferEncoder())
         .register(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
         .append(ByteBuffer.class, Bitmap.class,
@@ -214,7 +218,7 @@ public static void tearDown() {
         .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
         /* GIFs */
         .prepend(InputStream.class, GifDrawable.class,
-            new StreamGifDecoder(byteBufferGifDecoder, arrayPool))
+            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
         .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
         .register(GifDrawable.class, new GifDrawableEncoder())
         /* GIF Frames */
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index be6272bbd..7468be5be 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -2,6 +2,7 @@
 
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.data.DataRewinder;
@@ -15,6 +16,7 @@
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.load.resource.transcode.TranscoderRegistry;
 import com.bumptech.glide.provider.EncoderRegistry;
+import com.bumptech.glide.provider.ImageHeaderParserRegistry;
 import com.bumptech.glide.provider.LoadPathCache;
 import com.bumptech.glide.provider.ModelToResourceClassCache;
 import com.bumptech.glide.provider.ResourceDecoderRegistry;
@@ -34,6 +36,7 @@
   private final ResourceEncoderRegistry resourceEncoderRegistry;
   private final DataRewinderRegistry dataRewinderRegistry;
   private final TranscoderRegistry transcoderRegistry;
+  private final ImageHeaderParserRegistry imageHeaderParserRegistry;
 
   private final ModelToResourceClassCache modelToResourceClassCache =
       new ModelToResourceClassCache();
@@ -47,6 +50,7 @@ public Registry() {
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
     this.dataRewinderRegistry = new DataRewinderRegistry();
     this.transcoderRegistry = new TranscoderRegistry();
+    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();
   }
 
   public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
@@ -83,6 +87,11 @@ public Registry register(DataRewinder.Factory factory) {
     return this;
   }
 
+  public Registry register(ImageHeaderParser parser) {
+    imageHeaderParserRegistry.add(parser);
+    return this;
+  }
+
   /**
    * Use the given factory to build a {@link com.bumptech.glide.load.model.ModelLoader} for models
    * of the given class. Generally the best use of this method is to replace one of the default
@@ -220,6 +229,14 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     return result;
   }
 
+  public List<ImageHeaderParser> getImageHeaderParsers() {
+    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();
+    if (result.isEmpty()) {
+      throw new NoImageHeaderParserException();
+    }
+    return result;
+  }
+
   /**
    * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
    * model class.
@@ -260,4 +277,13 @@ public MissingComponentException(String message) {
       super(message);
     }
   }
+
+  /**
+   * Thrown when no {@link ImageHeaderParser} is registered.
+   */
+  public static final class NoImageHeaderParserException extends MissingComponentException {
+    public NoImageHeaderParserException() {
+      super("Failed to find image header parser.");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
new file mode 100644
index 000000000..6cecef3ac
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -0,0 +1,63 @@
+package com.bumptech.glide.load;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Interface for the ImageHeaderParser.
+ */
+public interface ImageHeaderParser {
+  /**
+   * A constant indicating we were unable to parse the orientation from the image either because
+   * no exif segment containing orientation data existed, or because of an I/O error attempting to
+   * read the exif segment.
+   */
+  int UNKNOWN_ORIENTATION = -1;
+
+  /**
+   * The format of the image data including whether or not the image may include transparent
+   * pixels.
+   */
+  enum ImageType {
+    GIF(true),
+    JPEG(false),
+    RAW(false),
+    /** PNG type with alpha. */
+    PNG_A(true),
+    /** PNG type without alpha. */
+    PNG(false),
+    /** WebP type with alpha. */
+    WEBP_A(true),
+    /** WebP type without alpha. */
+    WEBP(false),
+    /**
+     * Unrecognized type.
+     */
+    UNKNOWN(false);
+    private final boolean hasAlpha;
+
+    ImageType(boolean hasAlpha) {
+      this.hasAlpha = hasAlpha;
+    }
+
+    public boolean hasAlpha() {
+      return hasAlpha;
+    }
+  }
+
+  ImageType getType(InputStream is) throws IOException;
+  ImageType getType(ByteBuffer byteBuffer) throws IOException;
+
+  /**
+   * Parse the orientation from the image header. If it doesn't handle this image type (or this is
+   * not an image) it will return a default value rather than throwing an exception.
+   *
+   * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
+   * contain an orientation
+   * @throws IOException
+   */
+  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;
+  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
new file mode 100644
index 000000000..b092e15f2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * Utilities for the ImageHeaderParser.
+ */
+public final class ImageHeaderParserUtils {
+  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but
+  // will resize up to this amount if necessary.
+  private static final int MARK_POSITION = 5 * 1024 * 1024;
+
+  private ImageHeaderParserUtils() { }
+
+  /** Returns the ImageType for the given InputStream. */
+  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable InputStream is,
+      ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    for (ImageHeaderParser parser : parsers) {
+      try {
+        ImageType type = parser.getType(is);
+        if (type != ImageType.UNKNOWN) {
+          return type;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the ImageType for the given ByteBuffer. */
+  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer)
+      throws IOException {
+    if (buffer == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    for (ImageHeaderParser parser : parsers) {
+      ImageType type = parser.getType(buffer);
+      if (type != ImageType.UNKNOWN) {
+        return type;
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the orientation for the given InputStream. */
+  public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable InputStream is,
+      ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageHeaderParser.UNKNOWN_ORIENTATION;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    for (ImageHeaderParser parser : parsers) {
+      try {
+        int orientation = parser.getOrientation(is, byteArrayPool);
+        if (orientation != ImageHeaderParser.UNKNOWN_ORIENTATION) {
+          return orientation;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 4bd15097b..f7f7db337 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -39,8 +39,10 @@ public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
     ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
-    return new ThumbFetcher(
-        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));
+    ThumbnailStreamOpener opener = new ThumbnailStreamOpener(
+        Glide.get(context).getRegistry().getImageHeaderParsers(), query, byteArrayPool,
+        context.getContentResolver());
+    return new ThumbFetcher(uri, opener);
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 7ccc08820..a57b64541 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -5,27 +5,33 @@
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.List;
 
 class ThumbnailStreamOpener {
   private static final String TAG = "ThumbStreamOpener";
   private static final FileService DEFAULT_SERVICE = new FileService();
+
   private final FileService service;
   private final ThumbnailQuery query;
   private final ArrayPool byteArrayPool;
   private final ContentResolver contentResolver;
+  private final List<ImageHeaderParser> parsers;
 
   public ThumbnailStreamOpener(
-      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {
-    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
+      List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
+    this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
   public ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers,
       FileService service,
       ThumbnailQuery query,
       ArrayPool byteArrayPool,
@@ -34,28 +40,28 @@ public ThumbnailStreamOpener(
     this.query = query;
     this.byteArrayPool = byteArrayPool;
     this.contentResolver = contentResolver;
+    this.parsers = parsers;
   }
 
   public int getOrientation(Uri uri) {
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
     InputStream is = null;
     try {
       is = contentResolver.openInputStream(uri);
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
+      return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "Failed to open uri: " + uri, e);
+        Log.d(TAG, "Failed to open uri: " + uri, e);
       }
     } finally {
       if (is != null) {
-          try {
-              is.close();
-          } catch (IOException e) {
-              // Ignored.
-          }
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
       }
     }
-    return orientation;
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
   }
 
   public InputStream open(Uri uri) throws FileNotFoundException {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index f39c06da9..bbd9504ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -198,8 +198,14 @@ boolean isSourceKey(Key key) {
       int size = loadData.size();
       for (int i = 0; i < size; i++) {
         LoadData<?> data = loadData.get(i);
-        cacheKeys.add(data.sourceKey);
-        cacheKeys.addAll(data.alternateKeys);
+        if (!cacheKeys.contains(data.sourceKey)) {
+          cacheKeys.add(data.sourceKey);
+        }
+        for (int j = 0; j < data.alternateKeys.size(); j++) {
+          if (!cacheKeys.contains(data.alternateKeys.get(j))) {
+            cacheKeys.add(data.alternateKeys.get(j));
+          }
+        }
       }
     }
     return cacheKeys;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index c00824e23..4dddc8eab 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -58,6 +58,7 @@
   private Stage stage;
   private RunReason runReason;
   private long startFetchTime;
+  private boolean onlyRetrieveFromCache;
 
   private Thread currentThread;
   @Synthetic Key currentSourceKey;
@@ -88,6 +89,7 @@
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean onlyRetrieveFromCache,
       Options options,
       Callback<R> callback,
       int order) {
@@ -112,6 +114,7 @@
     this.width = width;
     this.height = height;
     this.diskCacheStrategy = diskCacheStrategy;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     this.options = options;
     this.callback = callback;
     this.order = order;
@@ -316,7 +319,8 @@ private Stage getNextStage(Stage current) {
         return diskCacheStrategy.decodeCachedData()
             ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
       case DATA_CACHE:
-        return Stage.SOURCE;
+        // Skip loading from source if the user opted to only retrieve the resource from cache.
+        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
       case SOURCE:
       case FINISHED:
         return Stage.FINISHED;
@@ -350,6 +354,7 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
   @Override
   public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
       DataSource dataSource) {
+    fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
     exceptions.add(exception);
@@ -383,6 +388,10 @@ private void decodeFromRetrievedData() {
   }
 
   private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
+    if (resource instanceof Initializable) {
+      ((Initializable) resource).initialize();
+    }
+
     Resource<R> result = resource;
     LockedResource<R> lockedResource = null;
     if (deferredEncodeManager.hasResourceToEncode()) {
@@ -455,11 +464,12 @@ public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
+  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
     private final DataSource dataSource;
 
-    public DecodeCallback(DataSource dataSource) {
+    @Synthetic
+    DecodeCallback(DataSource dataSource) {
       this.dataSource = dataSource;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index fdeff2601..1dc070d50 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -154,6 +154,7 @@ public Engine(MemoryCache memoryCache,
       Options options,
       boolean isMemoryCacheable,
       boolean useUnlimitedSourceExecutorPool,
+      boolean onlyRetrieveFromCache,
       ResourceCallback cb) {
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
@@ -203,6 +204,7 @@ public Engine(MemoryCache memoryCache,
         diskCacheStrategy,
         transformations,
         isTransformationRequired,
+        onlyRetrieveFromCache,
         options,
         engineJob);
     jobs.put(key, engineJob);
@@ -418,6 +420,7 @@ public boolean queueIdle() {
         DiskCacheStrategy diskCacheStrategy,
         Map<Class<?>, Transformation<?>> transformations,
         boolean isTransformationRequired,
+        boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
       DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
@@ -434,6 +437,7 @@ public boolean queueIdle() {
           diskCacheStrategy,
           transformations,
           isTransformationRequired,
+          onlyRetrieveFromCache,
           options,
           callback,
           creationOrder++);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
new file mode 100644
index 000000000..9b34820b1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.load.engine;
+
+/**
+ * A callback allowing a resource to do some optimization on a background thread before being
+ * returned to the ui.
+ */
+public interface Initializable {
+
+  /**
+   * Called on a background thread so the {@link Resource} can do some eager initialization.
+   */
+  void initialize();
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
index c97a84b0c..18427396a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -15,11 +15,6 @@
    */
   int getArrayLength(T array);
 
-  /**
-   * Reset the array for re-use (e.g. set all values to 0).
-   */
-  void resetArray(T array);
-
   /**
    * Allocate and return an array of the specified size.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index 34d78b312..bfdb18621 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -22,6 +22,8 @@
    * Returns a non-null array of the given type with a length >= to the given size.
    *
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
    */
   <T> T get(int size, Class<T> arrayClass);
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
index 96a79def3..95f5ff708 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import java.util.Arrays;
-
 /**
  * Adapter for handling primitive byte arrays.
  */
@@ -19,11 +17,6 @@ public int getArrayLength(byte[] array) {
     return array.length;
   }
 
-  @Override
-  public void resetArray(byte[] array) {
-    Arrays.fill(array, (byte) 0);
-  }
-
   @Override
   public byte[] newArray(int length) {
     return new byte[length];
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
index e6f8129be..4fb179c38 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import java.util.Arrays;
-
 /**
  * Adapter for handling primitive int arrays.
  */
@@ -19,11 +17,6 @@ public int getArrayLength(int[] array) {
     return array.length;
   }
 
-  @Override
-  public void resetArray(int[] array) {
-    Arrays.fill(array, 0);
-  }
-
   @Override
   public int[] newArray(int length) {
     return new int[length];
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
index 87301f1ca..6da2cb0e0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -85,9 +85,7 @@ public LruArrayPool(int maxSize) {
       }
     }
 
-    if (result != null) {
-      arrayAdapter.resetArray(result);
-    } else {
+    if (result == null) {
       if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
         Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index 6977a0559..989664e20 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 import com.bumptech.glide.util.Util;
@@ -15,7 +16,8 @@
  * given {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is
  * recycled. </p>
  */
-public class BitmapDrawableResource extends DrawableResource<BitmapDrawable> {
+public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>
+    implements Initializable {
   private final BitmapPool bitmapPool;
 
   public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
@@ -37,4 +39,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(drawable.getBitmap());
   }
+
+  @Override
+  public void initialize() {
+    drawable.getBitmap().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 474c76f4c..102c688c0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -10,7 +11,8 @@
 /**
  * A resource wrapping a {@link android.graphics.Bitmap} object.
  */
-public class BitmapResource implements Resource<Bitmap> {
+public class BitmapResource implements Resource<Bitmap>,
+    Initializable {
   private final Bitmap bitmap;
   private final BitmapPool bitmapPool;
 
@@ -54,4 +56,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(bitmap);
   }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
similarity index 79%
rename from library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
rename to library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 0ad18f335..5bfe67f8c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -1,12 +1,13 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.GIF;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.JPEG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG_A;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.UNKNOWN;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.GIF;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.JPEG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG_A;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.UNKNOWN;
 
 import android.util.Log;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
@@ -18,59 +19,25 @@
 /**
  * A class for parsing the exif orientation and other data from an image header.
  */
-public class ImageHeaderParser {
-  private static final String TAG = "ImageHeaderParser";
-  /**
-   * A constant indicating we were unable to parse the orientation from the image either because
-   * no exif segment containing orientation data existed, or because of an I/O error attempting to
-   * read the exif segment.
-   */
-  public static final int UNKNOWN_ORIENTATION = -1;
-
-  /**
-   * The format of the image data including whether or not the image may include transparent
-   * pixels.
-   */
-  public enum ImageType {
-    GIF(true),
-    JPEG(false),
-    /** PNG type with alpha. */
-    PNG_A(true),
-    /** PNG type without alpha. */
-    PNG(false),
-    /** WebP type with alpha. */
-    WEBP_A(true),
-    /** WebP type without alpha. */
-    WEBP(false),
-    /**
-     * Unrecognized type.
-     */
-    UNKNOWN(false);
-    private final boolean hasAlpha;
-
-    ImageType(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
+public final class DefaultImageHeaderParser implements ImageHeaderParser {
+  // Due to https://code.google.com/p/android/issues/detail?id=97751.
+  // TAG needs to be under 23 chars, so "Default" > "Dflt".
+  private static final String TAG = "DfltImageHeaderParser";
 
   private static final int GIF_HEADER = 0x474946;
   private static final int PNG_HEADER = 0x89504E47;
-  private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
+  static final int EXIF_MAGIC_NUMBER = 0xFFD8;
   // "MM".
   private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
   // "II".
   private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
-  private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
-  private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
+  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
+  static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
       JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
   private static final int SEGMENT_SOS = 0xDA;
   private static final int MARKER_EOI = 0xD9;
-  private static final int SEGMENT_START_ID = 0xFF;
-  private static final int EXIF_SEGMENT_TYPE = 0xE1;
+  static final int SEGMENT_START_ID = 0xFF;
+  static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
   private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
   // WebP-related
@@ -89,28 +56,29 @@ public boolean hasAlpha() {
   private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
   private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
 
-  private final ArrayPool byteArrayPool;
-  private final Reader reader;
+  @Override
+  public ImageType getType(InputStream is) throws IOException {
+    return getType(new StreamReader(Preconditions.checkNotNull(is)));
+  }
 
-  public ImageHeaderParser(InputStream is, ArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(is);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new StreamReader(is);
+  @Override
+  public ImageType getType(ByteBuffer byteBuffer) throws IOException {
+    return getType(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)));
   }
 
-  public ImageHeaderParser(ByteBuffer byteBuffer, ArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(byteBuffer);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new ByteBufferReader(byteBuffer);
+  @Override
+  public int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException {
+    return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  // 0xD0A3C68 -> <htm
-  // 0xCAFEBABE -> <!DOCTYPE...
-  public boolean hasAlpha() throws IOException {
-    return getType().hasAlpha();
+  @Override
+  public int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException {
+    return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  public ImageType getType() throws IOException {
+  private ImageType getType(Reader reader) throws IOException {
     int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
@@ -171,7 +139,7 @@ public ImageType getType() throws IOException {
    * contain an orientation
    * @throws IOException
    */
-  public int getOrientation() throws IOException {
+  private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
 
     if (!handles(magicNumber)) {
@@ -180,7 +148,7 @@ public int getOrientation() throws IOException {
       }
       return UNKNOWN_ORIENTATION;
     } else {
-      int exifSegmentLength = moveToExifSegmentAndGetLength();
+      int exifSegmentLength = moveToExifSegmentAndGetLength(reader);
       if (exifSegmentLength == -1) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Failed to parse exif segment length, or exif segment not found");
@@ -190,14 +158,15 @@ public int getOrientation() throws IOException {
 
       byte[] exifData = byteArrayPool.get(exifSegmentLength, byte[].class);
       try {
-        return parseExifSegment(exifData, exifSegmentLength);
+        return parseExifSegment(reader, exifData, exifSegmentLength);
       } finally {
         byteArrayPool.put(exifData, byte[].class);
       }
     }
   }
 
-  private int parseExifSegment(byte[] tempArray, int exifSegmentLength) throws IOException {
+  private int parseExifSegment(Reader reader, byte[] tempArray, int exifSegmentLength)
+      throws IOException {
     int read = reader.read(tempArray, exifSegmentLength);
     if (read != exifSegmentLength) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -237,7 +206,7 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * Moves reader to the start of the exif segment and returns the length of the exif segment or
    * {@code -1} if no exif segment is found.
    */
-  private int moveToExifSegmentAndGetLength() throws IOException {
+  private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
     short segmentId, segmentType;
     int segmentLength;
     while (true) {
@@ -377,29 +346,33 @@ private static boolean handles(int imageMagicNumber) {
         || imageMagicNumber == INTEL_TIFF_MAGIC_NUMBER;
   }
 
-  private static class RandomAccessReader {
+  private static final class RandomAccessReader {
     private final ByteBuffer data;
 
-    public RandomAccessReader(byte[] data, int length) {
+    RandomAccessReader(byte[] data, int length) {
       this.data = (ByteBuffer) ByteBuffer.wrap(data)
           .order(ByteOrder.BIG_ENDIAN)
           .limit(length);
     }
 
-    public void order(ByteOrder byteOrder) {
+    void order(ByteOrder byteOrder) {
       this.data.order(byteOrder);
     }
 
-    public int length() {
+    int length() {
       return data.remaining();
     }
 
-    public int getInt32(int offset) {
-      return data.getInt(offset);
+    int getInt32(int offset) {
+      return isAvailable(offset, 4) ? data.getInt(offset) : -1;
+    }
+
+    short getInt16(int offset) {
+      return isAvailable(offset, 2) ? data.getShort(offset) : -1;
     }
 
-    public short getInt16(int offset) {
-      return data.getShort(offset);
+    private boolean isAvailable(int offset, int byteSize) {
+      return data.remaining() - offset >= byteSize;
     }
   }
 
@@ -411,11 +384,11 @@ public short getInt16(int offset) {
     int getByte() throws IOException;
   }
 
-  private static class ByteBufferReader implements Reader {
+  private static final class ByteBufferReader implements Reader {
 
     private final ByteBuffer byteBuffer;
 
-    public ByteBufferReader(ByteBuffer byteBuffer) {
+    ByteBufferReader(ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
       byteBuffer.order(ByteOrder.BIG_ENDIAN);
     }
@@ -440,7 +413,10 @@ public long skip(long total) throws IOException {
     @Override
     public int read(byte[] buffer, int byteCount) throws IOException {
       int toRead = Math.min(byteCount, byteBuffer.remaining());
-      byteBuffer.get(buffer, 0 /*dstOffset*/, byteCount);
+      if (toRead == 0) {
+        return -1;
+      }
+      byteBuffer.get(buffer, 0 /*dstOffset*/, toRead);
       return toRead;
     }
 
@@ -453,10 +429,10 @@ public int getByte() throws IOException {
     }
   }
 
-  private static class StreamReader implements Reader {
+  private static final class StreamReader implements Reader {
     private final InputStream is;
     // Motorola / big endian byte order.
-    public StreamReader(InputStream is) {
+    StreamReader(InputStream is) {
       this.is = is;
     }
 
@@ -513,4 +489,3 @@ public int getByte() throws IOException {
     }
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 55d23b2ca..f60807c3a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -7,6 +7,8 @@
 import android.util.DisplayMetrics;
 import android.util.Log;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
@@ -23,6 +25,7 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 
@@ -47,6 +50,19 @@
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
           DownsampleStrategy.AT_LEAST);
 
+  /**
+   * Ensure that the size of the bitmap is fixed to the requested width and height of the
+   * resource from the caller.  The final resource dimensions may differ from the requested
+   * width and height, and thus setting this to true may result in the bitmap size differing
+   * from the resource dimensions.
+   *
+   * This can be used as a performance optimization for KitKat and above by fixing the size of the
+   * bitmap for a collection of requested resources so that the bitmap pool will not need to
+   * allocate new bitmaps for images of different sizes.
+   */
+  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
+
   private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
   private static final String ICO_MIME_TYPE = "image/x-ico";
   private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
@@ -85,9 +101,11 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
   private final ArrayPool byteArrayPool;
+  private final List<ImageHeaderParser> parsers;
 
-  public Downsampler(DisplayMetrics displayMetrics, BitmapPool bitmapPool,
-       ArrayPool byteArrayPool) {
+  public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
+      BitmapPool bitmapPool, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
@@ -151,10 +169,12 @@ public boolean handles(ByteBuffer byteBuffer) {
 
     DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
     DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
+    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
 
     try {
       Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight, callbacks);
+          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,
+          fixBitmapToRequestedDimensions, callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
@@ -165,25 +185,61 @@ public boolean handles(ByteBuffer byteBuffer) {
   private Bitmap decodeFromWrappedStreams(InputStream is,
       BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
       DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,
-      DecodeCallbacks callbacks) throws IOException {
+      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {
 
     int[] sourceDimensions = getDimensions(is, options, callbacks);
     int sourceWidth = sourceDimensions[0];
     int sourceHeight = sourceDimensions[1];
     String sourceMimeType = options.outMimeType;
 
-    int orientation = getOrientation(is);
+    int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
     int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
 
     options.inPreferredConfig = getConfig(is, decodeFormat);
     if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
       options.inDither = true;
     }
-    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, requestedWidth,
-        requestedHeight, options);
 
-    Bitmap downsampled = downsampleWithSize(is, options, bitmapPool, sourceWidth,
-        sourceHeight, callbacks);
+    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
+    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
+
+    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,
+        targetHeight, options);
+
+    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
+    if ((options.inSampleSize == 1 || isKitKatOrGreater)
+        && shouldUsePool(is)) {
+      int expectedWidth;
+      int expectedHeight;
+      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+        expectedWidth = targetWidth;
+        expectedHeight = targetHeight;
+      } else {
+        float densityMultiplier = isScaling(options)
+            ? (float) options.inTargetDensity / options.inDensity : 1f;
+        int sampleSize = options.inSampleSize;
+        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
+        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
+        expectedWidth = Math.round(downsampledWidth * densityMultiplier);
+        expectedHeight = Math.round(downsampledHeight * densityMultiplier);
+
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
+              + " [" + sourceWidth + "x" + sourceHeight + "]"
+              + ", sampleSize: " + sampleSize
+              + ", targetDensity: " + options.inTargetDensity
+              + ", density: " + options.inDensity
+              + ", density multiplier: " + densityMultiplier);
+        }
+      }
+      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
+      // will be -1 here.
+      if (expectedWidth > 0 && expectedHeight > 0) {
+        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
+      }
+    }
+    Bitmap downsampled = decodeStream(is, options, callbacks);
     callbacks.onDecodeComplete(bitmapPool, downsampled);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -208,16 +264,13 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
 
   // Visible for testing.
   static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,
-      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight,
+      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,
       BitmapFactory.Options options) {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
       return;
     }
 
-    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
-    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
-
     final float exactScaleFactor;
     if (degreesToRotate == 90 || degreesToRotate == 270) {
       // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
@@ -291,54 +344,6 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
     }
   }
 
-  private int getOrientation(InputStream is) throws IOException {
-    is.mark(MARK_POSITION);
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
-    try {
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine the image orientation from header", e);
-      }
-    } finally {
-      is.reset();
-    }
-    return orientation;
-  }
-
-  private Bitmap downsampleWithSize(InputStream is, BitmapFactory.Options options,
-      BitmapPool pool, int sourceWidth, int sourceHeight, DecodeCallbacks callbacks)
-      throws IOException {
-    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-    if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT)
-        && shouldUsePool(is)) {
-
-      float densityMultiplier = isScaling(options)
-          ? (float) options.inTargetDensity / options.inDensity : 1f;
-
-      int sampleSize = options.inSampleSize;
-      int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
-      int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
-      int expectedWidth = Math.round(downsampledWidth * densityMultiplier);
-      int expectedHeight = Math.round(downsampledHeight * densityMultiplier);
-
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
-            + " [" + sourceWidth + "x" + sourceHeight + "]"
-            + ", sampleSize: " + sampleSize
-            + ", targetDensity: " + options.inTargetDensity
-            + ", density: " + options.inDensity
-            + ", density multiplier: " + densityMultiplier);
-      }
-      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
-      // will be -1 here.
-      if (expectedWidth > 0 && expectedHeight > 0) {
-        setInBitmap(options, pool, expectedWidth, expectedHeight, options.inPreferredConfig);
-      }
-    }
-    return decodeStream(is, options, callbacks);
-  }
-
   private boolean shouldUsePool(InputStream is) throws IOException {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
@@ -346,9 +351,8 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       return true;
     }
 
-    is.mark(MARK_POSITION);
     try {
-      final ImageHeaderParser.ImageType type = new ImageHeaderParser(is, byteArrayPool).getType();
+      ImageHeaderParser.ImageType type = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
       // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
       // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
       return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
@@ -356,8 +360,6 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Cannot determine the image type from header", e);
       }
-    } finally {
-      is.reset();
     }
     return false;
   }
@@ -370,16 +372,13 @@ private boolean shouldUsePool(InputStream is) throws IOException {
     }
 
     boolean hasAlpha = false;
-    is.mark(MARK_POSITION);
     try {
-      hasAlpha = new ImageHeaderParser(is, byteArrayPool).hasAlpha();
+      hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Cannot determine whether the image has alpha or not from header"
             + ", format " + format, e);
       }
-    } finally {
-      is.reset();
     }
 
     return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
@@ -488,10 +487,10 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
 
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
-      int height, Bitmap.Config config) {
+      int height) {
     if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
       // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-      options.inBitmap = bitmapPool.getDirty(width, height, config);
+      options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index f936b5c80..412c5cc5b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -5,6 +5,7 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -14,7 +15,8 @@
  * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
  * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public class LazyBitmapDrawableResource implements Resource<BitmapDrawable> {
+public class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
+    Initializable {
 
   private final Bitmap bitmap;
   private final Resources resources;
@@ -54,4 +56,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(bitmap);
   }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 22672fadd..163cbe50a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -1,7 +1,10 @@
 package com.bumptech.glide.load.resource.drawable;
 
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.Preconditions;
 
 /**
@@ -14,7 +17,8 @@
  *
  * @param <T> type of the wrapped {@link Drawable}
  */
-public abstract class DrawableResource<T extends Drawable> implements Resource<T> {
+public abstract class DrawableResource<T extends Drawable> implements Resource<T>,
+    Initializable {
   protected final T drawable;
 
   public DrawableResource(T drawable) {
@@ -30,4 +34,13 @@ public final T get() {
     // and subsequent copies may end up with that temporary state. See #276.
     return (T) drawable.getConstantState().newDrawable();
   }
+
+  @Override
+  public void initialize() {
+    if (drawable instanceof BitmapDrawable) {
+      ((BitmapDrawable) drawable).getBitmap().prepareToDraw();
+    } else if (drawable instanceof GifDrawable) {
+      ((GifDrawable) drawable).getFirstFrame().prepareToDraw();
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 3ff49505f..2b56d271e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -8,20 +8,21 @@
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
 import com.bumptech.glide.gifdecoder.StandardGifDecoder;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.List;
 import java.util.Queue;
 
 /**
@@ -43,28 +44,33 @@
   private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
 
   private final Context context;
+  private final List<ImageHeaderParser> parsers;
   private final GifHeaderParserPool parserPool;
   private final BitmapPool bitmapPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
+    this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
+        Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
   }
 
   public ByteBufferGifDecoder(
-      Context context, BitmapPool bitmapPool, ArrayPool arrayPool) {
-    this(context, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
+      Context context, List<ImageHeaderParser> parsers, BitmapPool bitmapPool,
+      ArrayPool arrayPool) {
+    this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
   // Visible for testing.
   ByteBufferGifDecoder(
       Context context,
+      List<ImageHeaderParser> parsers,
       BitmapPool bitmapPool,
       ArrayPool arrayPool,
       GifHeaderParserPool parserPool,
       GifDecoderFactory gifDecoderFactory) {
     this.context = context.getApplicationContext();
+    this.parsers = parsers;
     this.bitmapPool = bitmapPool;
     this.gifDecoderFactory = gifDecoderFactory;
     this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
@@ -73,9 +79,8 @@ public ByteBufferGifDecoder(
 
   @Override
   public boolean handles(ByteBuffer source, Options options) throws IOException {
-    ArrayPool byteArrayPool = new LruArrayPool();
     return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+        && ImageHeaderParserUtils.getType(parsers, source) == ImageType.GIF;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 39cf6fe16..7c5a8de78 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -154,6 +154,15 @@ private void resetLoopCount() {
     loopCount = 0;
   }
 
+  /**
+   * Starts the animation from the first frame. Can only be called while animation is not running.
+   */
+  public void startFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "You cannot restart a currently running animation.");
+    state.frameLoader.setNextStartFromFirstFrame();
+    start();
+  }
+
   @Override
   public void start() {
     isStarted = true;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index 6b8301462..d0275e023 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.load.resource.gif;
 
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
 /**
  * A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
-public class GifDrawableResource extends DrawableResource<GifDrawable> {
+public class GifDrawableResource extends DrawableResource<GifDrawable>
+    implements Initializable {
   public GifDrawableResource(GifDrawable drawable) {
     super(drawable);
   }
@@ -25,4 +27,9 @@ public void recycle() {
     drawable.stop();
     drawable.recycle();
   }
+
+  @Override
+  public void initialize() {
+    drawable.getFirstFrame().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 61ef285c5..a510ce05f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -39,6 +39,7 @@
 
   private boolean isRunning = false;
   private boolean isLoadPending = false;
+  private boolean startFromFirstFrame = false;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
@@ -198,6 +199,10 @@ private void loadNextFrame() {
     if (!isRunning || isLoadPending) {
       return;
     }
+    if (startFromFirstFrame) {
+      gifDecoder.resetFrameIndex();
+      startFromFirstFrame = false;
+    }
     isLoadPending = true;
     // Get the delay before incrementing the pointer because the delay indicates the amount of time
     // we want to spend on the current frame.
@@ -216,6 +221,11 @@ private void recycleFirstFrame() {
     }
   }
 
+  void setNextStartFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "Can't restart a running animation");
+    startFromFirstFrame = true;
+  }
+
   // Visible for testing.
   void onFrameReady(DelayTarget delayTarget) {
     if (isCleared) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index 933c65698..4e887ed11 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -25,8 +25,7 @@ public boolean handles(GifDecoder source, Options options) {
   }
 
   @Override
-  public Resource<Bitmap> decode(GifDecoder source, int width, int height,
-      Options options) {
+  public Resource<Bitmap> decode(GifDecoder source, int width, int height, Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index bd8b6d70e..baf4abc43 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -1,17 +1,19 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.util.Log;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.List;
 
 /**
  * A relatively inefficient decoder for {@link com.bumptech.glide.load.resource.gif.GifDrawable}
@@ -28,11 +30,13 @@
   public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
       "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
 
+  private final List<ImageHeaderParser> parsers;
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private final ArrayPool byteArrayPool;
 
-  public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
-      ArrayPool byteArrayPool) {
+  public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuffer,
+      GifDrawable> byteBufferDecoder, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.byteBufferDecoder = byteBufferDecoder;
     this.byteArrayPool = byteArrayPool;
   }
@@ -40,7 +44,7 @@ public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecod
   @Override
   public boolean handles(InputStream source, Options options) throws IOException {
     return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+        && ImageHeaderParserUtils.getType(parsers, source, byteArrayPool) == ImageType.GIF;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
new file mode 100644
index 000000000..af329320e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.provider;
+
+import com.bumptech.glide.load.ImageHeaderParser;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers.
+ */
+public final class ImageHeaderParserRegistry {
+  private final List<ImageHeaderParser> parsers = new ArrayList<>();
+
+  public synchronized List<ImageHeaderParser> getParsers() {
+    return parsers;
+  }
+
+  public synchronized void add(ImageHeaderParser parser) {
+    parsers.add(parser);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
index 0bab50800..c490b3ba7 100644
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -63,6 +63,7 @@
   private static final int TRANSFORMATION_ALLOWED = 1 << 16;
   private static final int TRANSFORMATION_REQUIRED = 1 << 17;
   private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
+  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
 
   private int fields;
 
@@ -89,6 +90,7 @@
   private Resources.Theme theme;
   private boolean isAutoCloneEnabled;
   private boolean useUnlimitedSourceGeneratorsPool;
+  private boolean onlyRetrieveFromCache;
 
   /**
    * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
@@ -125,6 +127,20 @@ public final CHILD useUnlimitedSourceGeneratorsPool(boolean flag) {
     return selfOrThrowIfLocked();
   }
 
+  /**
+   * If set to true, will only load an item if found in the cache, and will not fetch from source.
+   */
+  public final CHILD onlyRetrieveFromCache(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().onlyRetrieveFromCache(flag);
+    }
+
+    this.onlyRetrieveFromCache = flag;
+    fields |= ONLY_RETRIEVE_FROM_CACHE;
+
+    return selfOrThrowIfLocked();
+  }
+
   /**
    * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
    *
@@ -817,6 +833,9 @@ public final CHILD apply(BaseRequestOptions<?> other) {
     if (isSet(other.fields, TRANSFORMATION)) {
       transformations.putAll(other.transformations);
     }
+    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
+      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
+    }
 
     // Applying options with dontTransform() is expected to clear our transformations.
     if (!isTransformationAllowed) {
@@ -960,4 +979,8 @@ private static boolean isSet(int fields, int flag) {
   public final boolean getUseUnlimitedSourceGeneratorsPool() {
     return useUnlimitedSourceGeneratorsPool;
   }
+
+  public final boolean getOnlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 1ed0cb125..63592bf82 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -144,7 +144,7 @@ public static RequestOptions centerInsideTransform(Context context) {
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #circleCrop(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #centerCrop(Context)} set.
    */
   public static RequestOptions centerCropTransform(Context context) {
     if (centerCropOptions == null) {
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index c0dba86d6..05312672e 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -395,6 +395,7 @@ public void onSizeReady(int width, int height) {
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
         requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+        requestOptions.getOnlyRetrieveFromCache(),
         this);
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index 82080d64d..77c6a93f5 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -4,7 +4,7 @@
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
 import java.io.IOException;
 import java.io.InputStream;
@@ -36,13 +36,12 @@ public void testIncludesGivenExifOrientation() throws IOException {
       for (int j = 0; j < 8; j++) {
         InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
         InputStream wrapped = new ExifOrientationStream(toWrap, i);
-        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
 
         toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
         wrapped = new ExifOrientationStream(toWrap, i);
-        parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
       }
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index a27944ab7..50535836c 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -12,12 +12,16 @@
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.provider.MediaStore;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -128,7 +132,10 @@ public Harness() {
     }
 
     public ThumbnailStreamOpener get() {
-      return new ThumbnailStreamOpener(service, query, byteArrayPool, getContentResolver());
+      List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+      parsers.add(new DefaultImageHeaderParser());
+      return new ThumbnailStreamOpener(
+          parsers, service, query, byteArrayPool, getContentResolver());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 38f51ba04..6a5cb537c 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -483,6 +483,7 @@ public void runTest() throws Exception {
     GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
+    boolean onlyRetrieveFromCache = false;
 
     public EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
@@ -515,6 +516,7 @@ public EngineTestHarness() {
           options,
           isMemoryCacheable,
           useUnlimitedSourceGeneratorPool,
+          onlyRetrieveFromCache,
           cb);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
new file mode 100644
index 000000000..40b9bfb7a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -0,0 +1,402 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.testutil.TestResourceUtil;
+import java.io.ByteArrayInputStream;
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.Util;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DefaultImageHeaderParserTest {
+
+  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
+      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
+          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
+
+  private ArrayPool byteArrayPool;
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruArrayPool();
+  }
+
+  @Test
+  public void testCanParsePngType() throws IOException {
+    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
+    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParsePngWithAlpha() throws IOException {
+    for (int i = 3; i <= 6; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParsePngWithoutAlpha() throws IOException {
+    for (int i = 0; i < 3; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParseJpegType() throws IOException {
+    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseGifType() throws IOException {
+    byte[] data = new byte[] { 'G', 'I', 'F' };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
+        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithoutAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
+        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
+    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #286.
+  @Test
+  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
+    byte[] data =
+        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(-1, parser.getOrientation(is, byteArrayPool));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownForEmptyData() throws IOException {
+    runTest(new byte[0], new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialReads() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialReadInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialSkips() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialSkipInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  @Test
+  public void testHandlesSometimesZeroSkips() throws IOException {
+    InputStream is = new ByteArrayInputStream(
+        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
+    DefaultImageHeaderParser parser =
+        new DefaultImageHeaderParser();
+    assertEquals(ImageType.PNG, parser.getType(new SometimesZeroSkipInputStream(is)));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
+        (byte) 0xE5,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleButLessThanLength_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity());
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity() + 2 + 1);
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  private static ByteBuffer getExifMagicNumber() {
+    ByteBuffer jpegHeaderBytes = ByteBuffer.allocate(2);
+    jpegHeaderBytes.putShort((short) DefaultImageHeaderParser.EXIF_MAGIC_NUMBER);
+    jpegHeaderBytes.position(0);
+    return jpegHeaderBytes;
+  }
+
+  private interface ParserTestCase {
+    void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+        throws IOException;
+    void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+        throws IOException;
+  }
+
+  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
+    InputStream is = new ByteArrayInputStream(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    test.run(parser, is, new LruArrayPool());
+
+    ByteBuffer buffer = ByteBuffer.wrap(data);
+    parser = new DefaultImageHeaderParser();
+    test.run(parser, buffer, new LruArrayPool());
+  }
+
+  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
+    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
+    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
+    result[result.length - 1] = (byte) bitDepth;
+    return result;
+  }
+
+  private static class SometimesZeroSkipInputStream extends FilterInputStream {
+    boolean returnZeroFlag = true;
+
+    protected SometimesZeroSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      final long result;
+      if (returnZeroFlag) {
+        result = 0;
+      } else {
+        result = super.skip(byteCount);
+      }
+      returnZeroFlag = !returnZeroFlag;
+      return result;
+    }
+  }
+
+  private static class PartialSkipInputStream extends FilterInputStream {
+
+    protected PartialSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+        long toActuallySkip = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallySkip = 1;
+        }
+        return super.skip(toActuallySkip);
+    }
+  }
+
+  private static class PartialReadInputStream extends FilterInputStream {
+
+    protected PartialReadInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        int toActuallyRead = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallyRead = 1;
+        }
+        return super.read(buffer, byteOffset, toActuallyRead);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
index 3bcd69b66..4cbfc7e49 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -11,6 +11,7 @@
 import android.os.Build;
 import android.util.DisplayMetrics;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -22,6 +23,8 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -53,7 +56,11 @@ public void setUp() throws Exception {
         RuntimeEnvironment.application.getResources().getDisplayMetrics();
     when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
         .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
-    downsampler = new Downsampler(displayMetrics, bitmapPool, byteArrayPool);
+
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    downsampler = new Downsampler(parsers, displayMetrics, bitmapPool, byteArrayPool);
 
     initialSdkVersion = Build.VERSION.SDK_INT;
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
deleted file mode 100644
index ed6b2c680..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ /dev/null
@@ -1,254 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-import com.bumptech.glide.testutil.TestResourceUtil;
-import java.io.ByteArrayInputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.util.Util;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ImageHeaderParserTest {
-
-  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
-      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
-          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
-
-  private ArrayPool byteArrayPool;
-
-  @Before
-  public void setUp() {
-    byteArrayPool = new LruArrayPool();
-  }
-
-  @Test
-  public void testCanParsePngType() throws IOException {
-    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
-    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.PNG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParsePngWithAlpha() throws IOException {
-    for (int i = 3; i <= 6; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParsePngWithoutAlpha() throws IOException {
-    for (int i = 0; i < 3; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParseJpegType() throws IOException {
-    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseGifType() throws IOException {
-    byte[] data = new byte[] { 'G', 'I', 'F' };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.GIF, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseWebpWithAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
-        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.WEBP_A, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseWebpWithoutAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
-        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.WEBP, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
-    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #286.
-  @Test
-  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
-    byte[] data =
-        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(-1, parser.getOrientation());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownForEmptyData() throws IOException {
-    runTest(new byte[0], new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialReads() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialSkips() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  @Test
-  public void testHandlesSometimesZeroSkips() throws IOException {
-    InputStream is = new ByteArrayInputStream(
-        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
-    ImageHeaderParser parser =
-        new ImageHeaderParser(new SometimesZeroSkipInputStream(is), byteArrayPool);
-    assertEquals(ImageType.PNG, parser.getType());
-  }
-
-  private interface ParserTestCase {
-    void run(ImageHeaderParser parser) throws IOException;
-  }
-
-  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
-    InputStream is = new ByteArrayInputStream(data);
-    ImageHeaderParser parser = new ImageHeaderParser(is, new LruArrayPool());
-    test.run(parser);
-
-    ByteBuffer buffer = ByteBuffer.wrap(data);
-    parser = new ImageHeaderParser(buffer, new LruArrayPool());
-    test.run(parser);
-  }
-
-  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
-    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
-    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
-    result[result.length - 1] = (byte) bitDepth;
-    return result;
-  }
-
-  private static class SometimesZeroSkipInputStream extends FilterInputStream {
-    boolean returnZeroFlag = true;
-
-    protected SometimesZeroSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-      final long result;
-      if (returnZeroFlag) {
-        result = 0;
-      } else {
-        result = super.skip(byteCount);
-      }
-      returnZeroFlag = !returnZeroFlag;
-      return result;
-    }
-  }
-
-  private static class PartialSkipInputStream extends FilterInputStream {
-
-    protected PartialSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-        long toActuallySkip = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallySkip = 1;
-        }
-        return super.skip(toActuallySkip);
-    }
-  }
-
-  private static class PartialReadInputStream extends FilterInputStream {
-
-    protected PartialReadInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
-        int toActuallyRead = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallyRead = 1;
-        }
-        return super.read(buffer, byteOffset, toActuallyRead);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index c4b9c51c1..9d12894be 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -353,7 +353,7 @@ public void testRotateImage() {
     assertTrue(toRotate == zero);
 
     Bitmap ninety = TransformationUtils.rotateImage(toRotate, 90);
-    assertTrue(Shadows.shadowOf(ninety).getDescription().contains("rotate=90.0"));
+    assertThat(Shadows.shadowOf(ninety).getDescription()).contains("rotate=90.0");
     assertEquals(toRotate.getWidth(), toRotate.getHeight());
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index 718e0f1c1..8c78f1de1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -12,12 +12,16 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.tests.GlideShadowLooper;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -56,10 +60,14 @@ public void setUp() {
         eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
     options = new Options();
     decoder =
         new ByteBufferGifDecoder(
             RuntimeEnvironment.application,
+            parsers,
             bitmapPool,
             new LruArrayPool(ARRAY_POOL_SIZE_BYTES),
             parserPool,
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index 085014881..f6d4eba4c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -2,12 +2,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,7 +34,10 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    decoder = new StreamGifDecoder(byteBufferDecoder, new LruArrayPool());
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    decoder = new StreamGifDecoder(parsers, byteBufferDecoder, new LruArrayPool());
     options = new Options();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 723fc3631..c0e60f63c 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -278,7 +278,7 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
   @Test
@@ -297,7 +297,7 @@ public void testEngineLoadCancelledOnCancel() {
        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
           eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
           eq(harness.transformations), anyBoolean(), any(Options.class),
-          anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
+          anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = harness.getRequest();
@@ -541,7 +541,8 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class)))
         .thenAnswer(new Answer<Object>() {
           @Override
           public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -655,7 +656,8 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   @Test
@@ -677,7 +679,7 @@ public void testCanReRunCancelledRequests() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
+            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new CallResourceCallback(harness.resource));
     SingleRequest<List> request = harness.getRequest();
 
@@ -706,7 +708,8 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
 
@@ -724,7 +727,8 @@ public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), eq(Boolean.TRUE), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   @Test
@@ -741,7 +745,8 @@ public void testCallsSourceExecutorEngineIfOptionsIsSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), eq(Boolean.FALSE), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   // TODO do we want to move these to Util?
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 649c906de..95eaca505 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -5,7 +5,7 @@
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
 import java.io.IOException;
 import java.io.InputStream;
@@ -29,7 +29,7 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
     InputStream is = null;
     try {
       is = open(filePrefix + "_" + expectedOrientation + ".jpg");
-      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),
+      assertEquals(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool),
           expectedOrientation);
     } catch (IOException e) {
       throw new RuntimeException(e);
@@ -52,7 +52,7 @@ public void setUp() {
   @Test
   public void testIssue387() throws IOException {
     InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
+    assertThat(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool)).isEqualTo(6);
   }
 
   @Test
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index fa84d3f7f..05662c04e 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -460,7 +460,8 @@ private void skip() {
     int blockSize;
     do {
       blockSize = read();
-      rawData.position(rawData.position() + blockSize);
+      int newPosition = Math.min(rawData.position() + blockSize, rawData.limit());
+      rawData.position(newPosition);
     } while (blockSize > 0);
   }
 
