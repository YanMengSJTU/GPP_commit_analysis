diff --git a/.gitmodules b/.gitmodules
index d9d405d51..e69de29bb 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,6 +0,0 @@
-[submodule "third_party/disklrucache"]
-	path = third_party/disklrucache
-	url = https://github.com/sjudd/DiskLruCache.git
-[submodule "library/test/src/test/resources/exif-orientation-examples"]
-	path = library/test/src/test/resources/exif-orientation-examples
-	url = https://github.com/recurser/exif-orientation-examples.git
diff --git a/gradlew.bat b/gradlew.bat
index e95643d6a..f9553162f 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -1,84 +1,84 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windows variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index d0591d1af..83cd3f419 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -14,8 +14,8 @@
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
-import android.support.graphics.drawable.Animatable2Compat;
 import android.view.Gravity;
+import android.support.graphics.drawable.Animatable2Compat;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
diff --git a/library/test/build.gradle b/library/test/build.gradle
index 8b0823363..71b05f91d 100644
--- a/library/test/build.gradle
+++ b/library/test/build.gradle
@@ -50,4 +50,13 @@ android {
     }
 
     testOptions.unitTests.includeAndroidResources = true
+
+    sourceSets {
+        androidTest {
+            resources.srcDirs += ['../../third_party/exif_orientation_examples']
+        }
+        test {
+            resources.srcDirs += ['../../third_party/exif_orientation_examples']
+        }
+    }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index d753c6e95..e896b9712 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -21,8 +21,7 @@
 
   private InputStream openOrientationExample(boolean isLandscape, int item) {
     String filePrefix = isLandscape ? "Landscape" : "Portrait";
-    return TestResourceUtil.openResource(
-        getClass(), "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
+    return TestResourceUtil.openResource(getClass(), filePrefix + "_" + item + ".jpg");
   }
 
   @Before
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
index 4ac0b520c..1f4e00f00 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -11,11 +11,11 @@
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.view.ViewPager;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+import android.support.v4.view.ViewPager;
 import com.bumptech.glide.Glide;
 
 /** A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117. */
diff --git a/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 13d25d06e..f05b9c316 100644
--- a/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -22,7 +22,7 @@
   private ArrayPool byteArrayPool;
 
   private InputStream open(String imageName) {
-    return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
+    return TestResourceUtil.openResource(getClass(), imageName);
   }
 
   private void assertOrientation(String filePrefix, int expectedOrientation) {
diff --git a/library/test/src/test/resources/exif-orientation-examples b/library/test/src/test/resources/exif-orientation-examples
deleted file mode 160000
index 9c4ccfaea..000000000
--- a/library/test/src/test/resources/exif-orientation-examples
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 9c4ccfaea6bfd434ac1c4bb0750ac6fc5848a5f4
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index 1ba7cac7f..9b24dce80 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -10,7 +10,6 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.view.ViewPager;
 import android.support.v7.app.AppCompatActivity;
 import android.text.TextUtils;
 import android.util.Log;
@@ -20,6 +19,7 @@
 import android.view.ViewGroup;
 import android.widget.SearchView;
 import android.widget.TextView;
+import android.support.v4.view.ViewPager;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.samples.flickr.api.Api;
diff --git a/third_party/disklrucache b/third_party/disklrucache
deleted file mode 160000
index 273f119c6..000000000
--- a/third_party/disklrucache
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 273f119c607eb55da0627ebb4a0c1b0d1a15b2dc
diff --git a/third_party/disklrucache/.gitignore b/third_party/disklrucache/.gitignore
new file mode 100644
index 000000000..5bbf7d56f
--- /dev/null
+++ b/third_party/disklrucache/.gitignore
@@ -0,0 +1,23 @@
+#Eclipse
+.project
+.classpath
+.settings
+.checkstyle
+
+#IntelliJ IDEA
+.idea
+*.iml
+*.ipr
+*.iws
+
+#Maven
+target
+release.properties
+pom.xml.*
+
+#OSX
+.DS_Store
+
+#gradle
+build/**
+.gradle/**
diff --git a/third_party/disklrucache/CHANGELOG.md b/third_party/disklrucache/CHANGELOG.md
new file mode 100644
index 000000000..50a43e8c1
--- /dev/null
+++ b/third_party/disklrucache/CHANGELOG.md
@@ -0,0 +1,67 @@
+Change Log
+==========
+
+Version 2.0.2 *(2013-06-18)*
+----------------------------
+
+ * Fix: Prevent exception trying to delete a non-existent file.
+
+
+Version 2.0.1 *(2013-04-27)*
+----------------------------
+
+ * Fix: Do not throw runtime exceptions for racy file I/O.
+ * Fix: Synchronize calls to `isClosed`.
+
+
+Version 2.0.0 *(2013-04-13)*
+----------------------------
+
+The package name is now `com.jakewharton.disklrucache`.
+
+ * New: Automatically flush the cache when an edit is completed.
+ * Fix: Ensure file handles are not held when a file is not found.
+ * Fix: Correct journal rebuilds on Windows.
+ * Fix: Ensure file writer uses the appropriate encoding.
+
+
+Version 1.3.1 *(2013-01-02)*
+----------------------------
+
+ * Fix: Correct logic around detecting whether a journal rebuild is required.
+   *(Thanks Jonathan Gerbaud)*
+
+
+Version 1.3.0 *(2012-12-24)*
+----------------------------
+
+ * Re-allow dash in cache key (now `[a-z0-9_-]{1,64}`).
+ * New: `getLength` method on `Snapshot`. *(Thanks Edward Dale)*
+ * Performance improvements reading journal lines.
+
+
+Version 1.2.1 *(2012-10-08)*
+----------------------------
+
+ * Fix: Ensure library references Java 5-compatible version of
+   `Arrays.copyOfRange`. *(Thanks Edward Dale)*
+
+
+Version 1.2.0 *(2012-09-30)*
+----------------------------
+
+ * New API for cache size adjustment.
+ * Keys are now enforced to match `[a-z0-9_]{1,64}` *(Thanks Brian Langel)*
+ * Fix: Cache will gracefully recover if directory is deleted at runtime.
+
+
+Version 1.1.0 *(2012-01-07)*
+----------------------------
+
+ * New API for editing an existing snapshot. *(Thanks Jesse Wilson)*
+
+
+Version 1.0.0 *(2012-01-04)*
+----------------------------
+
+Initial version.
diff --git a/third_party/disklrucache/LICENSE b/third_party/disklrucache/LICENSE
new file mode 100644
index 000000000..add20f0c7
--- /dev/null
+++ b/third_party/disklrucache/LICENSE
@@ -0,0 +1,14 @@
+Copyright 2012 Jake Wharton
+Copyright 2011 The Android Open Source Project
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/third_party/disklrucache/LICENSE.txt b/third_party/disklrucache/LICENSE.txt
new file mode 100644
index 000000000..53b48b6b6
--- /dev/null
+++ b/third_party/disklrucache/LICENSE.txt
@@ -0,0 +1,203 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2012 Jake Wharton
+   Copyright 2011 The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/third_party/disklrucache/README.md b/third_party/disklrucache/README.md
new file mode 100644
index 000000000..5f27ca267
--- /dev/null
+++ b/third_party/disklrucache/README.md
@@ -0,0 +1,63 @@
+Disk LRU Cache
+==============
+
+A cache that uses a bounded amount of space on a filesystem. Each cache entry
+has a string key and a fixed number of values. Each key must match the regex
+`[a-z0-9_-]{1,64}`.  Values are byte sequences, accessible as streams or files.
+Each value must be between `0` and `Integer.MAX_VALUE` bytes in length.
+
+The cache stores its data in a directory on the filesystem. This directory must
+be exclusive to the cache; the cache may delete or overwrite files from its
+directory. It is an error for multiple processes to use the same cache
+directory at the same time.
+
+This cache limits the number of bytes that it will store on the filesystem.
+When the number of stored bytes exceeds the limit, the cache will remove
+entries in the background until the limit is satisfied. The limit is not
+strict: the cache may temporarily exceed it while waiting for files to be
+deleted. The limit does not include filesystem overhead or the cache journal so
+space-sensitive applications should set a conservative limit.
+
+Clients call `edit` to create or update the values of an entry. An entry may
+have only one editor at one time; if a value is not available to be edited then
+`edit` will return null.
+
+ *  When an entry is being **created** it is necessary to supply a full set of
+    values; the empty value should be used as a placeholder if necessary.
+ *  When an entry is being **edited**, it is not necessary to supply data for
+    every value; values default to their previous value.
+
+Every `edit` call must be matched by a call to `Editor.commit` or
+`Editor.abort`. Committing is atomic: a read observes the full set of values as
+they were before or after the commit, but never a mix of values.
+
+Clients call `get` to read a snapshot of an entry. The read will observe the
+value at the time that `get` was called. Updates and removals after the call do
+not impact ongoing reads.
+
+This class is tolerant of some I/O errors. If files are missing from the
+filesystem, the corresponding entries will be dropped from the cache. If an
+error occurs while writing a cache value, the edit will fail silently. Callers
+should handle other problems by catching `IOException` and responding
+appropriately.
+
+*Note: This implementation specifically targets Android compatibility.*
+
+License
+=======
+
+    Copyright 2012 Jake Wharton
+    Copyright 2011 The Android Open Source Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
diff --git a/third_party/disklrucache/README.third_party b/third_party/disklrucache/README.third_party
new file mode 100644
index 000000000..88189ae35
--- /dev/null
+++ b/third_party/disklrucache/README.third_party
@@ -0,0 +1,10 @@
+URL: https://github.com/JakeWharton/DiskLruCache/tarball/7a1ecbd38d2ad0873fb843e911d60235b7434acb
+Version: 7a1ecbd38d2ad0873fb843e911d60235b7434acb
+License: Apache 2.0
+License File: LICENSE
+
+Description:
+Java implementation of a Disk-based LRU cache which specifically targets Android compatibility.
+
+Local Modifications:
+Exposed File objects directly to gets, removed key validation, removed test sources.
diff --git a/third_party/disklrucache/build.gradle b/third_party/disklrucache/build.gradle
new file mode 100644
index 000000000..800293655
--- /dev/null
+++ b/third_party/disklrucache/build.gradle
@@ -0,0 +1,26 @@
+apply plugin: 'java'
+apply plugin: 'checkstyle'
+
+repositories {
+  jcenter()
+}
+
+checkstyle {
+    toolVersion = "6.6"
+}
+
+checkstyle {
+    configFile = new File(projectDir, 'checkstyle.xml')
+}
+
+dependencies {
+    def junitVersion = hasProperty('JUNIT_VERSION') ? JUNIT_VERSION : '4.11';
+    testCompile "junit:junit:${junitVersion}"
+    testCompile 'commons-io:commons-io:2.1'
+    testCompile 'org.easytesting:fest-assert-core:2.0M10'
+}
+
+def uploaderScript = "${rootProject.projectDir}/scripts/upload.gradle"
+if (file(uploaderScript).exists()) {
+	apply from: uploaderScript
+}
diff --git a/third_party/disklrucache/checkstyle.xml b/third_party/disklrucache/checkstyle.xml
new file mode 100644
index 000000000..3f1f67704
--- /dev/null
+++ b/third_party/disklrucache/checkstyle.xml
@@ -0,0 +1,130 @@
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<module name="Checker">
+    <module name="FileLength"/>
+    <module name="FileTabCharacter"/>
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf" />
+    </module>
+
+    <!-- Trailing spaces -->
+    <module name="RegexpSingleline">
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module>
+
+    <!-- Space after 'for' and 'if' -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*(for|if)\b[^ ]"/>
+        <property name="message" value="Space needed before opening parenthesis."/>
+    </module>
+
+    <!-- For each spacing -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+        <property name="message" value="Space needed around ':' character."/>
+    </module>
+
+    <module name="TreeWalker">
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <!--module name="JavadocMethod"/-->
+        <!--module name="JavadocType"/-->
+        <!--module name="JavadocVariable"/-->
+        <module name="JavadocStyle"/>
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <!--<module name="ConstantName"/>-->
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/>
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <module name="AvoidStarImport"/>
+        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport"/>
+        <module name="UnusedImports"/>
+
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <module name="LineLength">
+            <property name="max" value="100"/>
+        </module>
+        <module name="MethodLength"/>
+        <module name="ParameterNumber"/>
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <module name="GenericWhitespace"/>
+        <!--<module name="EmptyForIteratorPad"/>-->
+        <module name="MethodParamPad"/>
+        <!--<module name="NoWhitespaceAfter"/>-->
+        <!--<module name="NoWhitespaceBefore"/>-->
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <module name="TypecastParenPad"/>
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround"/>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <module name="ModifierOrder"/>
+        <module name="RedundantModifier"/>
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <module name="AvoidNestedBlocks"/>
+        <!--module name="EmptyBlock"/-->
+        <module name="LeftCurly"/>
+        <!--<module name="NeedBraces"/>-->
+        <module name="RightCurly"/>
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--module name="AvoidInlineConditionals"/-->
+        <module name="CovariantEquals"/>
+        <module name="EmptyStatement"/>
+        <!--<module name="EqualsAvoidNull"/>-->
+        <module name="EqualsHashCode"/>
+        <!--module name="HiddenField"/-->
+        <module name="IllegalInstantiation"/>
+        <!--module name="InnerAssignment"/-->
+        <!--module name="MagicNumber"/-->
+        <!--module name="MissingSwitchDefault"/-->
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--module name="DesignForExtension"/-->
+        <!--<module name="FinalClass"/>-->
+        <module name="HideUtilityClassConstructor"/>
+        <module name="InterfaceIsType"/>
+        <!--module name="VisibilityModifier"/-->
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <module name="ArrayTypeStyle"/>
+        <!--module name="FinalParameters"/-->
+        <!--module name="TodoComment"/-->
+        <module name="UpperEll"/>
+    </module>
+</module>
diff --git a/third_party/disklrucache/gradle.properties b/third_party/disklrucache/gradle.properties
new file mode 100644
index 000000000..db29a2519
--- /dev/null
+++ b/third_party/disklrucache/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Disk LRU Cache Library
+POM_ARTIFACT_ID=disklrucache
+POM_PACKAGING=jar
+POM_DESCRIPTION=A cache that uses a bounded amount of space on a filesystem. Based on Jake Wharton's tailored for Glide.
diff --git a/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/DiskLruCache.java b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/DiskLruCache.java
new file mode 100644
index 000000000..f3f80431e
--- /dev/null
+++ b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/DiskLruCache.java
@@ -0,0 +1,939 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.StrictMode;
+import java.io.BufferedWriter;
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A cache that uses a bounded amount of space on a filesystem. Each cache
+ * entry has a string key and a fixed number of values. Each key must match
+ * the regex <strong>[a-z0-9_-]{1,120}</strong>. Values are byte sequences,
+ * accessible as streams or files. Each value must be between {@code 0} and
+ * {@code Integer.MAX_VALUE} bytes in length.
+ *
+ * <p>The cache stores its data in a directory on the filesystem. This
+ * directory must be exclusive to the cache; the cache may delete or overwrite
+ * files from its directory. It is an error for multiple processes to use the
+ * same cache directory at the same time.
+ *
+ * <p>This cache limits the number of bytes that it will store on the
+ * filesystem. When the number of stored bytes exceeds the limit, the cache will
+ * remove entries in the background until the limit is satisfied. The limit is
+ * not strict: the cache may temporarily exceed it while waiting for files to be
+ * deleted. The limit does not include filesystem overhead or the cache
+ * journal so space-sensitive applications should set a conservative limit.
+ *
+ * <p>Clients call {@link #edit} to create or update the values of an entry. An
+ * entry may have only one editor at one time; if a value is not available to be
+ * edited then {@link #edit} will return null.
+ * <ul>
+ * <li>When an entry is being <strong>created</strong> it is necessary to
+ * supply a full set of values; the empty value should be used as a
+ * placeholder if necessary.
+ * <li>When an entry is being <strong>edited</strong>, it is not necessary
+ * to supply data for every value; values default to their previous
+ * value.
+ * </ul>
+ * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
+ * or {@link Editor#abort}. Committing is atomic: a read observes the full set
+ * of values as they were before or after the commit, but never a mix of values.
+ *
+ * <p>Clients call {@link #get} to read a snapshot of an entry. The read will
+ * observe the value at the time that {@link #get} was called. Updates and
+ * removals after the call do not impact ongoing reads.
+ *
+ * <p>This class is tolerant of some I/O errors. If files are missing from the
+ * filesystem, the corresponding entries will be dropped from the cache. If
+ * an error occurs while writing a cache value, the edit will fail silently.
+ * Callers should handle other problems by catching {@code IOException} and
+ * responding appropriately.
+ */
+public final class DiskLruCache implements Closeable {
+  static final String JOURNAL_FILE = "journal";
+  static final String JOURNAL_FILE_TEMP = "journal.tmp";
+  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
+  static final String MAGIC = "libcore.io.DiskLruCache";
+  static final String VERSION_1 = "1";
+  static final long ANY_SEQUENCE_NUMBER = -1;
+  private static final String CLEAN = "CLEAN";
+  private static final String DIRTY = "DIRTY";
+  private static final String REMOVE = "REMOVE";
+  private static final String READ = "READ";
+
+    /*
+     * This cache uses a journal file named "journal". A typical journal file
+     * looks like this:
+     *     libcore.io.DiskLruCache
+     *     1
+     *     100
+     *     2
+     *
+     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
+     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
+     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
+     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
+     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
+     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
+     *     READ 335c4c6028171cfddfbaae1a9c313c52
+     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
+     *
+     * The first five lines of the journal form its header. They are the
+     * constant string "libcore.io.DiskLruCache", the disk cache's version,
+     * the application's version, the value count, and a blank line.
+     *
+     * Each of the subsequent lines in the file is a record of the state of a
+     * cache entry. Each line contains space-separated values: a state, a key,
+     * and optional state-specific values.
+     *   o DIRTY lines track that an entry is actively being created or updated.
+     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
+     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
+     *     temporary files may need to be deleted.
+     *   o CLEAN lines track a cache entry that has been successfully published
+     *     and may be read. A publish line is followed by the lengths of each of
+     *     its values.
+     *   o READ lines track accesses for LRU.
+     *   o REMOVE lines track entries that have been deleted.
+     *
+     * The journal file is appended to as cache operations occur. The journal may
+     * occasionally be compacted by dropping redundant lines. A temporary file named
+     * "journal.tmp" will be used during compaction; that file should be deleted if
+     * it exists when the cache is opened.
+     */
+
+  private final File directory;
+  private final File journalFile;
+  private final File journalFileTmp;
+  private final File journalFileBackup;
+  private final int appVersion;
+  private long maxSize;
+  private final int valueCount;
+  private long size = 0;
+  private Writer journalWriter;
+  private final LinkedHashMap<String, Entry> lruEntries =
+      new LinkedHashMap<String, Entry>(0, 0.75f, true);
+  private int redundantOpCount;
+
+  /**
+   * To differentiate between old and current snapshots, each entry is given
+   * a sequence number each time an edit is committed. A snapshot is stale if
+   * its sequence number is not equal to its entry's sequence number.
+   */
+  private long nextSequenceNumber = 0;
+
+  /** This cache uses a single background thread to evict entries. */
+  final ThreadPoolExecutor executorService =
+      new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
+          new DiskLruCacheThreadFactory());
+  private final Callable<Void> cleanupCallable = new Callable<Void>() {
+    public Void call() throws Exception {
+      synchronized (DiskLruCache.this) {
+        if (journalWriter == null) {
+          return null; // Closed.
+        }
+        trimToSize();
+        if (journalRebuildRequired()) {
+          rebuildJournal();
+          redundantOpCount = 0;
+        }
+      }
+      return null;
+    }
+  };
+
+  private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {
+    this.directory = directory;
+    this.appVersion = appVersion;
+    this.journalFile = new File(directory, JOURNAL_FILE);
+    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
+    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
+    this.valueCount = valueCount;
+    this.maxSize = maxSize;
+  }
+
+  /**
+   * Opens the cache in {@code directory}, creating a cache if none exists
+   * there.
+   *
+   * @param directory a writable directory
+   * @param valueCount the number of values per cache entry. Must be positive.
+   * @param maxSize the maximum number of bytes this cache should use to store
+   * @throws IOException if reading or writing the cache directory fails
+   */
+  public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)
+      throws IOException {
+    if (maxSize <= 0) {
+      throw new IllegalArgumentException("maxSize <= 0");
+    }
+    if (valueCount <= 0) {
+      throw new IllegalArgumentException("valueCount <= 0");
+    }
+
+    // If a bkp file exists, use it instead.
+    File backupFile = new File(directory, JOURNAL_FILE_BACKUP);
+    if (backupFile.exists()) {
+      File journalFile = new File(directory, JOURNAL_FILE);
+      // If journal file also exists just delete backup file.
+      if (journalFile.exists()) {
+        backupFile.delete();
+      } else {
+        renameTo(backupFile, journalFile, false);
+      }
+    }
+
+    // Prefer to pick up where we left off.
+    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
+    if (cache.journalFile.exists()) {
+      try {
+        cache.readJournal();
+        cache.processJournal();
+        return cache;
+      } catch (IOException journalIsCorrupt) {
+        System.out
+            .println("DiskLruCache "
+                + directory
+                + " is corrupt: "
+                + journalIsCorrupt.getMessage()
+                + ", removing");
+        cache.delete();
+      }
+    }
+
+    // Create a new empty cache.
+    directory.mkdirs();
+    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
+    cache.rebuildJournal();
+    return cache;
+  }
+
+  private void readJournal() throws IOException {
+    StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);
+    try {
+      String magic = reader.readLine();
+      String version = reader.readLine();
+      String appVersionString = reader.readLine();
+      String valueCountString = reader.readLine();
+      String blank = reader.readLine();
+      if (!MAGIC.equals(magic)
+          || !VERSION_1.equals(version)
+          || !Integer.toString(appVersion).equals(appVersionString)
+          || !Integer.toString(valueCount).equals(valueCountString)
+          || !"".equals(blank)) {
+        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
+            + valueCountString + ", " + blank + "]");
+      }
+
+      int lineCount = 0;
+      while (true) {
+        try {
+          readJournalLine(reader.readLine());
+          lineCount++;
+        } catch (EOFException endOfJournal) {
+          break;
+        }
+      }
+      redundantOpCount = lineCount - lruEntries.size();
+
+      // If we ended on a truncated line, rebuild the journal before appending to it.
+      if (reader.hasUnterminatedLine()) {
+        rebuildJournal();
+      } else {
+        journalWriter = new BufferedWriter(new OutputStreamWriter(
+            new FileOutputStream(journalFile, true), Util.US_ASCII));
+      }
+    } finally {
+      Util.closeQuietly(reader);
+    }
+  }
+
+  private void readJournalLine(String line) throws IOException {
+    int firstSpace = line.indexOf(' ');
+    if (firstSpace == -1) {
+      throw new IOException("unexpected journal line: " + line);
+    }
+
+    int keyBegin = firstSpace + 1;
+    int secondSpace = line.indexOf(' ', keyBegin);
+    final String key;
+    if (secondSpace == -1) {
+      key = line.substring(keyBegin);
+      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
+        lruEntries.remove(key);
+        return;
+      }
+    } else {
+      key = line.substring(keyBegin, secondSpace);
+    }
+
+    Entry entry = lruEntries.get(key);
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    }
+
+    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
+      String[] parts = line.substring(secondSpace + 1).split(" ");
+      entry.readable = true;
+      entry.currentEditor = null;
+      entry.setLengths(parts);
+    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
+      entry.currentEditor = new Editor(entry);
+    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
+      // This work was already done by calling lruEntries.get().
+    } else {
+      throw new IOException("unexpected journal line: " + line);
+    }
+  }
+
+  /**
+   * Computes the initial size and collects garbage as a part of opening the
+   * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+   */
+  private void processJournal() throws IOException {
+    deleteIfExists(journalFileTmp);
+    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
+      Entry entry = i.next();
+      if (entry.currentEditor == null) {
+        for (int t = 0; t < valueCount; t++) {
+          size += entry.lengths[t];
+        }
+      } else {
+        entry.currentEditor = null;
+        for (int t = 0; t < valueCount; t++) {
+          deleteIfExists(entry.getCleanFile(t));
+          deleteIfExists(entry.getDirtyFile(t));
+        }
+        i.remove();
+      }
+    }
+  }
+
+  /**
+   * Creates a new journal that omits redundant information. This replaces the
+   * current journal if it exists.
+   */
+  private synchronized void rebuildJournal() throws IOException {
+    if (journalWriter != null) {
+      closeWriter(journalWriter);
+    }
+
+    Writer writer = new BufferedWriter(
+        new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII));
+    try {
+      writer.write(MAGIC);
+      writer.write("\n");
+      writer.write(VERSION_1);
+      writer.write("\n");
+      writer.write(Integer.toString(appVersion));
+      writer.write("\n");
+      writer.write(Integer.toString(valueCount));
+      writer.write("\n");
+      writer.write("\n");
+
+      for (Entry entry : lruEntries.values()) {
+        if (entry.currentEditor != null) {
+          writer.write(DIRTY + ' ' + entry.key + '\n');
+        } else {
+          writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+        }
+      }
+    } finally {
+      closeWriter(writer);
+    }
+
+    if (journalFile.exists()) {
+      renameTo(journalFile, journalFileBackup, true);
+    }
+    renameTo(journalFileTmp, journalFile, false);
+    journalFileBackup.delete();
+
+    journalWriter = new BufferedWriter(
+        new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));
+  }
+
+  private static void deleteIfExists(File file) throws IOException {
+    if (file.exists() && !file.delete()) {
+      throw new IOException();
+    }
+  }
+
+  private static void renameTo(File from, File to, boolean deleteDestination) throws IOException {
+    if (deleteDestination) {
+      deleteIfExists(to);
+    }
+    if (!from.renameTo(to)) {
+      throw new IOException();
+    }
+  }
+
+  /**
+   * Returns a snapshot of the entry named {@code key}, or null if it doesn't
+   * exist is not currently readable. If a value is returned, it is moved to
+   * the head of the LRU queue.
+   */
+  public synchronized Value get(String key) throws IOException {
+    checkNotClosed();
+    Entry entry = lruEntries.get(key);
+    if (entry == null) {
+      return null;
+    }
+
+    if (!entry.readable) {
+      return null;
+    }
+
+    for (File file : entry.cleanFiles) {
+        // A file must have been deleted manually!
+        if (!file.exists()) {
+            return null;
+        }
+    }
+
+    redundantOpCount++;
+    journalWriter.append(READ);
+    journalWriter.append(' ');
+    journalWriter.append(key);
+    journalWriter.append('\n');
+    if (journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+
+    return new Value(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths);
+  }
+
+  /**
+   * Returns an editor for the entry named {@code key}, or null if another
+   * edit is in progress.
+   */
+  public Editor edit(String key) throws IOException {
+    return edit(key, ANY_SEQUENCE_NUMBER);
+  }
+
+  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+    checkNotClosed();
+    Entry entry = lruEntries.get(key);
+    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
+        || entry.sequenceNumber != expectedSequenceNumber)) {
+      return null; // Value is stale.
+    }
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    } else if (entry.currentEditor != null) {
+      return null; // Another edit is in progress.
+    }
+
+    Editor editor = new Editor(entry);
+    entry.currentEditor = editor;
+
+    // Flush the journal before creating files to prevent file leaks.
+    journalWriter.append(DIRTY);
+    journalWriter.append(' ');
+    journalWriter.append(key);
+    journalWriter.append('\n');
+    flushWriter(journalWriter);
+    return editor;
+  }
+
+  /** Returns the directory where this cache stores its data. */
+  public File getDirectory() {
+    return directory;
+  }
+
+  /**
+   * Returns the maximum number of bytes that this cache should use to store
+   * its data.
+   */
+  public synchronized long getMaxSize() {
+    return maxSize;
+  }
+
+  /**
+   * Changes the maximum number of bytes the cache can store and queues a job
+   * to trim the existing store, if necessary.
+   */
+  public synchronized void setMaxSize(long maxSize) {
+    this.maxSize = maxSize;
+    executorService.submit(cleanupCallable);
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in
+   * this cache. This may be greater than the max size if a background
+   * deletion is pending.
+   */
+  public synchronized long size() {
+    return size;
+  }
+
+  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+    Entry entry = editor.entry;
+    if (entry.currentEditor != editor) {
+      throw new IllegalStateException();
+    }
+
+    // If this edit is creating the entry for the first time, every index must have a value.
+    if (success && !entry.readable) {
+      for (int i = 0; i < valueCount; i++) {
+        if (!editor.written[i]) {
+          editor.abort();
+          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
+        }
+        if (!entry.getDirtyFile(i).exists()) {
+          editor.abort();
+          return;
+        }
+      }
+    }
+
+    for (int i = 0; i < valueCount; i++) {
+      File dirty = entry.getDirtyFile(i);
+      if (success) {
+        if (dirty.exists()) {
+          File clean = entry.getCleanFile(i);
+          dirty.renameTo(clean);
+          long oldLength = entry.lengths[i];
+          long newLength = clean.length();
+          entry.lengths[i] = newLength;
+          size = size - oldLength + newLength;
+        }
+      } else {
+        deleteIfExists(dirty);
+      }
+    }
+
+    redundantOpCount++;
+    entry.currentEditor = null;
+    if (entry.readable | success) {
+      entry.readable = true;
+      journalWriter.append(CLEAN);
+      journalWriter.append(' ');
+      journalWriter.append(entry.key);
+      journalWriter.append(entry.getLengths());
+      journalWriter.append('\n');
+
+      if (success) {
+        entry.sequenceNumber = nextSequenceNumber++;
+      }
+    } else {
+      lruEntries.remove(entry.key);
+      journalWriter.append(REMOVE);
+      journalWriter.append(' ');
+      journalWriter.append(entry.key);
+      journalWriter.append('\n');
+    }
+    flushWriter(journalWriter);
+
+    if (size > maxSize || journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+  }
+
+  /**
+   * We only rebuild the journal when it will halve the size of the journal
+   * and eliminate at least 2000 ops.
+   */
+  private boolean journalRebuildRequired() {
+    final int redundantOpCompactThreshold = 2000;
+    return redundantOpCount >= redundantOpCompactThreshold //
+        && redundantOpCount >= lruEntries.size();
+  }
+
+  /**
+   * Drops the entry for {@code key} if it exists and can be removed. Entries
+   * actively being edited cannot be removed.
+   *
+   * @return true if an entry was removed.
+   */
+  public synchronized boolean remove(String key) throws IOException {
+    checkNotClosed();
+    Entry entry = lruEntries.get(key);
+    if (entry == null || entry.currentEditor != null) {
+      return false;
+    }
+
+    for (int i = 0; i < valueCount; i++) {
+      File file = entry.getCleanFile(i);
+      if (file.exists() && !file.delete()) {
+        throw new IOException("failed to delete " + file);
+      }
+      size -= entry.lengths[i];
+      entry.lengths[i] = 0;
+    }
+
+    redundantOpCount++;
+    journalWriter.append(REMOVE);
+    journalWriter.append(' ');
+    journalWriter.append(key);
+    journalWriter.append('\n');
+
+    lruEntries.remove(key);
+
+    if (journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+
+    return true;
+  }
+
+  /** Returns true if this cache has been closed. */
+  public synchronized boolean isClosed() {
+    return journalWriter == null;
+  }
+
+  private void checkNotClosed() {
+    if (journalWriter == null) {
+      throw new IllegalStateException("cache is closed");
+    }
+  }
+
+  /** Force buffered operations to the filesystem. */
+  public synchronized void flush() throws IOException {
+    checkNotClosed();
+    trimToSize();
+    flushWriter(journalWriter);
+  }
+
+  /** Closes this cache. Stored values will remain on the filesystem. */
+  public synchronized void close() throws IOException {
+    if (journalWriter == null) {
+      return; // Already closed.
+    }
+    for (Entry entry : new ArrayList<Entry>(lruEntries.values())) {
+      if (entry.currentEditor != null) {
+        entry.currentEditor.abort();
+      }
+    }
+    trimToSize();
+    closeWriter(journalWriter);
+    journalWriter = null;
+  }
+
+  private void trimToSize() throws IOException {
+    while (size > maxSize) {
+      Map.Entry<String, Entry> toEvict = lruEntries.entrySet().iterator().next();
+      remove(toEvict.getKey());
+    }
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete
+   * all files in the cache directory including files that weren't created by
+   * the cache.
+   */
+  public void delete() throws IOException {
+    close();
+    Util.deleteContents(directory);
+  }
+
+  private static String inputStreamToString(InputStream in) throws IOException {
+    return Util.readFully(new InputStreamReader(in, Util.UTF_8));
+  }
+
+  /**
+   * Closes the writer while whitelisting with StrictMode if necessary.
+   *
+   * <p>Analogous to b/71520172.
+   */
+  private static void closeWriter(Writer writer) throws IOException {
+    // If API is less than 26, we don't need to whitelist with StrictMode.
+    if (VERSION.SDK_INT < VERSION_CODES.O) {
+      writer.close();
+      return;
+    }
+
+    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+    StrictMode.ThreadPolicy unbufferedIoPolicy =
+        new StrictMode.ThreadPolicy.Builder(oldPolicy).permitUnbufferedIo().build();
+    StrictMode.setThreadPolicy(unbufferedIoPolicy);
+    try {
+      writer.close();
+    } finally {
+      StrictMode.setThreadPolicy(oldPolicy);
+    }
+  }
+
+  /**
+   * Flushes the writer while whitelisting with StrictMode if necessary.
+   *
+   * <p>See b/71520172.
+   */
+  private static void flushWriter(Writer writer) throws IOException {
+    // If API is less than 26, we don't need to whitelist with StrictMode.
+    if (VERSION.SDK_INT < VERSION_CODES.O) {
+      writer.flush();
+      return;
+    }
+
+    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+    StrictMode.ThreadPolicy unbufferedIoPolicy =
+        new StrictMode.ThreadPolicy.Builder(oldPolicy).permitUnbufferedIo().build();
+    StrictMode.setThreadPolicy(unbufferedIoPolicy);
+    try {
+      writer.flush();
+    } finally {
+      StrictMode.setThreadPolicy(oldPolicy);
+    }
+  }
+
+  /** A snapshot of the values for an entry. */
+  public final class Value {
+    private final String key;
+    private final long sequenceNumber;
+    private final long[] lengths;
+    private final File[] files;
+
+      private Value(String key, long sequenceNumber, File[] files, long[] lengths) {
+      this.key = key;
+      this.sequenceNumber = sequenceNumber;
+      this.files = files;
+      this.lengths = lengths;
+    }
+
+    /**
+     * Returns an editor for this snapshot's entry, or null if either the
+     * entry has changed since this snapshot was created or if another edit
+     * is in progress.
+     */
+    public Editor edit() throws IOException {
+      return DiskLruCache.this.edit(key, sequenceNumber);
+    }
+
+    public File getFile(int index) {
+        return files[index];
+    }
+
+    /** Returns the string value for {@code index}. */
+    public String getString(int index) throws IOException {
+      InputStream is = new FileInputStream(files[index]);
+      return inputStreamToString(is);
+    }
+
+    /** Returns the byte length of the value for {@code index}. */
+    public long getLength(int index) {
+      return lengths[index];
+    }
+  }
+
+  /** Edits the values for an entry. */
+  public final class Editor {
+    private final Entry entry;
+    private final boolean[] written;
+    private boolean committed;
+
+    private Editor(Entry entry) {
+      this.entry = entry;
+      this.written = (entry.readable) ? null : new boolean[valueCount];
+    }
+
+    /**
+     * Returns an unbuffered input stream to read the last committed value,
+     * or null if no value has been committed.
+     */
+    private InputStream newInputStream(int index) throws IOException {
+      synchronized (DiskLruCache.this) {
+        if (entry.currentEditor != this) {
+          throw new IllegalStateException();
+        }
+        if (!entry.readable) {
+          return null;
+        }
+        try {
+          return new FileInputStream(entry.getCleanFile(index));
+        } catch (FileNotFoundException e) {
+          return null;
+        }
+      }
+    }
+
+    /**
+     * Returns the last committed value as a string, or null if no value
+     * has been committed.
+     */
+    public String getString(int index) throws IOException {
+      InputStream in = newInputStream(index);
+      return in != null ? inputStreamToString(in) : null;
+    }
+
+    public File getFile(int index) throws IOException {
+      synchronized (DiskLruCache.this) {
+        if (entry.currentEditor != this) {
+            throw new IllegalStateException();
+        }
+        if (!entry.readable) {
+            written[index] = true;
+        }
+        File dirtyFile = entry.getDirtyFile(index);
+        if (!directory.exists()) {
+            directory.mkdirs();
+        }
+        return dirtyFile;
+      }
+    }
+
+    /** Sets the value at {@code index} to {@code value}. */
+    public void set(int index, String value) throws IOException {
+      Writer writer = null;
+      try {
+        OutputStream os = new FileOutputStream(getFile(index));
+        writer = new OutputStreamWriter(os, Util.UTF_8);
+        writer.write(value);
+      } finally {
+        Util.closeQuietly(writer);
+      }
+    }
+
+    /**
+     * Commits this edit so it is visible to readers.  This releases the
+     * edit lock so another edit may be started on the same key.
+     */
+    public void commit() throws IOException {
+      // The object using this Editor must catch and handle any errors
+      // during the write. If there is an error and they call commit
+      // anyway, we will assume whatever they managed to write was valid.
+      // Normally they should call abort.
+      completeEdit(this, true);
+      committed = true;
+    }
+
+    /**
+     * Aborts this edit. This releases the edit lock so another edit may be
+     * started on the same key.
+     */
+    public void abort() throws IOException {
+      completeEdit(this, false);
+    }
+
+    public void abortUnlessCommitted() {
+      if (!committed) {
+        try {
+          abort();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+  }
+
+  private final class Entry {
+    private final String key;
+
+    /** Lengths of this entry's files. */
+    private final long[] lengths;
+
+    /** Memoized File objects for this entry to avoid char[] allocations. */
+    File[] cleanFiles;
+    File[] dirtyFiles;
+
+    /** True if this entry has ever been published. */
+    private boolean readable;
+
+    /** The ongoing edit or null if this entry is not being edited. */
+    private Editor currentEditor;
+
+    /** The sequence number of the most recently committed edit to this entry. */
+    private long sequenceNumber;
+
+    private Entry(String key) {
+      this.key = key;
+      this.lengths = new long[valueCount];
+      cleanFiles = new File[valueCount];
+      dirtyFiles = new File[valueCount];
+
+      // The names are repetitive so re-use the same builder to avoid allocations.
+      StringBuilder fileBuilder = new StringBuilder(key).append('.');
+      int truncateTo = fileBuilder.length();
+      for (int i = 0; i < valueCount; i++) {
+          fileBuilder.append(i);
+          cleanFiles[i] = new File(directory, fileBuilder.toString());
+          fileBuilder.append(".tmp");
+          dirtyFiles[i] = new File(directory, fileBuilder.toString());
+          fileBuilder.setLength(truncateTo);
+      }
+    }
+
+    public String getLengths() throws IOException {
+      StringBuilder result = new StringBuilder();
+      for (long size : lengths) {
+        result.append(' ').append(size);
+      }
+      return result.toString();
+    }
+
+    /** Set lengths using decimal numbers like "10123". */
+    private void setLengths(String[] strings) throws IOException {
+      if (strings.length != valueCount) {
+        throw invalidLengths(strings);
+      }
+
+      try {
+        for (int i = 0; i < strings.length; i++) {
+          lengths[i] = Long.parseLong(strings[i]);
+        }
+      } catch (NumberFormatException e) {
+        throw invalidLengths(strings);
+      }
+    }
+
+    private IOException invalidLengths(String[] strings) throws IOException {
+      throw new IOException("unexpected journal line: " + java.util.Arrays.toString(strings));
+    }
+
+    public File getCleanFile(int i) {
+      return cleanFiles[i];
+    }
+
+    public File getDirtyFile(int i) {
+      return dirtyFiles[i];
+    }
+  }
+
+  /**
+   * A {@link java.util.concurrent.ThreadFactory} that builds a thread with a specific thread name
+   * and with minimum priority.
+   */
+  private static final class DiskLruCacheThreadFactory implements ThreadFactory {
+    @Override
+    public synchronized Thread newThread(Runnable runnable) {
+      Thread result = new Thread(runnable, "glide-disk-lru-cache-thread");
+      result.setPriority(Thread.MIN_PRIORITY);
+      return result;
+    }
+  }
+}
diff --git a/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/StrictLineReader.java b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/StrictLineReader.java
new file mode 100644
index 000000000..11135db04
--- /dev/null
+++ b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/StrictLineReader.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+
+/**
+ * Buffers input from an {@link InputStream} for reading lines.
+ *
+ * <p>This class is used for buffered reading of lines. For purposes of this class, a line ends
+ * with "\n" or "\r\n". End of input is reported by throwing {@code EOFException}. Unterminated
+ * line at end of input is invalid and will be ignored, the caller may use {@code
+ * hasUnterminatedLine()} to detect it after catching the {@code EOFException}.
+ *
+ * <p>This class is intended for reading input that strictly consists of lines, such as line-based
+ * cache entries or cache journal. Unlike the {@link java.io.BufferedReader} which in conjunction
+ * with {@link java.io.InputStreamReader} provides similar functionality, this class uses different
+ * end-of-input reporting and a more restrictive definition of a line.
+ *
+ * <p>This class supports only charsets that encode '\r' and '\n' as a single byte with value 13
+ * and 10, respectively, and the representation of no other character contains these values.
+ * We currently check in constructor that the charset is one of US-ASCII, UTF-8 and ISO-8859-1.
+ * The default charset is US_ASCII.
+ */
+class StrictLineReader implements Closeable {
+  private static final byte CR = (byte) '\r';
+  private static final byte LF = (byte) '\n';
+
+  private final InputStream in;
+  private final Charset charset;
+
+  /*
+   * Buffered data is stored in {@code buf}. As long as no exception occurs, 0 <= pos <= end
+   * and the data in the range [pos, end) is buffered for reading. At end of input, if there is
+   * an unterminated line, we set end == -1, otherwise end == pos. If the underlying
+   * {@code InputStream} throws an {@code IOException}, end may remain as either pos or -1.
+   */
+  private byte[] buf;
+  private int pos;
+  private int end;
+
+  /**
+   * Constructs a new {@code LineReader} with the specified charset and the default capacity.
+   *
+   * @param in the {@code InputStream} to read data from.
+   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
+   * supported.
+   * @throws NullPointerException if {@code in} or {@code charset} is null.
+   * @throws IllegalArgumentException if the specified charset is not supported.
+   */
+  public StrictLineReader(InputStream in, Charset charset) {
+    this(in, 8192, charset);
+  }
+
+  /**
+   * Constructs a new {@code LineReader} with the specified capacity and charset.
+   *
+   * @param in the {@code InputStream} to read data from.
+   * @param capacity the capacity of the buffer.
+   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
+   * supported.
+   * @throws NullPointerException if {@code in} or {@code charset} is null.
+   * @throws IllegalArgumentException if {@code capacity} is negative or zero
+   * or the specified charset is not supported.
+   */
+  public StrictLineReader(InputStream in, int capacity, Charset charset) {
+    if (in == null || charset == null) {
+      throw new NullPointerException();
+    }
+    if (capacity < 0) {
+      throw new IllegalArgumentException("capacity <= 0");
+    }
+    if (!(charset.equals(Util.US_ASCII))) {
+      throw new IllegalArgumentException("Unsupported encoding");
+    }
+
+    this.in = in;
+    this.charset = charset;
+    buf = new byte[capacity];
+  }
+
+  /**
+   * Closes the reader by closing the underlying {@code InputStream} and
+   * marking this reader as closed.
+   *
+   * @throws IOException for errors when closing the underlying {@code InputStream}.
+   */
+  public void close() throws IOException {
+    synchronized (in) {
+      if (buf != null) {
+        buf = null;
+        in.close();
+      }
+    }
+  }
+
+  /**
+   * Reads the next line. A line ends with {@code "\n"} or {@code "\r\n"},
+   * this end of line marker is not included in the result.
+   *
+   * @return the next line from the input.
+   * @throws IOException for underlying {@code InputStream} errors.
+   * @throws EOFException for the end of source stream.
+   */
+  public String readLine() throws IOException {
+    synchronized (in) {
+      if (buf == null) {
+        throw new IOException("LineReader is closed");
+      }
+
+      // Read more data if we are at the end of the buffered data.
+      // Though it's an error to read after an exception, we will let {@code fillBuf()}
+      // throw again if that happens; thus we need to handle end == -1 as well as end == pos.
+      if (pos >= end) {
+        fillBuf();
+      }
+      // Try to find LF in the buffered data and return the line if successful.
+      for (int i = pos; i != end; ++i) {
+        if (buf[i] == LF) {
+          int lineEnd = (i != pos && buf[i - 1] == CR) ? i - 1 : i;
+          String res = new String(buf, pos, lineEnd - pos, charset.name());
+          pos = i + 1;
+          return res;
+        }
+      }
+
+      // Let's anticipate up to 80 characters on top of those already read.
+      ByteArrayOutputStream out = new ByteArrayOutputStream(end - pos + 80) {
+        @Override
+        public String toString() {
+          int length = (count > 0 && buf[count - 1] == CR) ? count - 1 : count;
+          try {
+            return new String(buf, 0, length, charset.name());
+          } catch (UnsupportedEncodingException e) {
+            throw new AssertionError(e); // Since we control the charset this will never happen.
+          }
+        }
+      };
+
+      while (true) {
+        out.write(buf, pos, end - pos);
+        // Mark unterminated line in case fillBuf throws EOFException or IOException.
+        end = -1;
+        fillBuf();
+        // Try to find LF in the buffered data and return the line if successful.
+        for (int i = pos; i != end; ++i) {
+          if (buf[i] == LF) {
+            if (i != pos) {
+              out.write(buf, pos, i - pos);
+            }
+            pos = i + 1;
+            return out.toString();
+          }
+        }
+      }
+    }
+  }
+
+  public boolean hasUnterminatedLine() {
+    return end == -1;
+  }
+
+  /**
+   * Reads new input data into the buffer. Call only with pos == end or end == -1,
+   * depending on the desired outcome if the function throws.
+   */
+  private void fillBuf() throws IOException {
+    int result = in.read(buf, 0, buf.length);
+    if (result == -1) {
+      throw new EOFException();
+    }
+    pos = 0;
+    end = result;
+  }
+}
+
diff --git a/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/Util.java b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/Util.java
new file mode 100644
index 000000000..0260c6362
--- /dev/null
+++ b/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/Util.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.nio.charset.Charset;
+
+/** Junk drawer of utility methods. */
+final class Util {
+  static final Charset US_ASCII = Charset.forName("US-ASCII");
+  static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private Util() {
+  }
+
+  static String readFully(Reader reader) throws IOException {
+    try {
+      StringWriter writer = new StringWriter();
+      char[] buffer = new char[1024];
+      int count;
+      while ((count = reader.read(buffer)) != -1) {
+        writer.write(buffer, 0, count);
+      }
+      return writer.toString();
+    } finally {
+      reader.close();
+    }
+  }
+
+  /**
+   * Deletes the contents of {@code dir}. Throws an IOException if any file
+   * could not be deleted, or if {@code dir} is not a readable directory.
+   */
+  static void deleteContents(File dir) throws IOException {
+    File[] files = dir.listFiles();
+    if (files == null) {
+      throw new IOException("not a readable directory: " + dir);
+    }
+    for (File file : files) {
+      if (file.isDirectory()) {
+        deleteContents(file);
+      }
+      if (!file.delete()) {
+        throw new IOException("failed to delete file: " + file);
+      }
+    }
+  }
+
+  static void closeQuietly(/*Auto*/Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+}
diff --git a/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/DiskLruCacheTest.java b/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/DiskLruCacheTest.java
new file mode 100644
index 000000000..689f8b76f
--- /dev/null
+++ b/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/DiskLruCacheTest.java
@@ -0,0 +1,916 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import static com.bumptech.glide.disklrucache.DiskLruCache.JOURNAL_FILE;
+import static com.bumptech.glide.disklrucache.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static com.bumptech.glide.disklrucache.DiskLruCache.MAGIC;
+import static com.bumptech.glide.disklrucache.DiskLruCache.VERSION_1;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.hamcrest.core.IsNot.not;
+import static org.junit.Assume.assumeThat;
+
+import org.apache.commons.io.FileUtils;
+import org.hamcrest.core.StringStartsWith;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(JUnit4.class)
+public final class DiskLruCacheTest {
+  private final int appVersion = 100;
+  private File cacheDir;
+  private File journalFile;
+  private File journalBkpFile;
+  private DiskLruCache cache;
+
+  @Rule public TemporaryFolder tempDir = new TemporaryFolder();
+
+  @BeforeClass
+  public static void setUpClass() {
+    assumeThat(System.getProperty("os.name"), not(StringStartsWith.startsWith("Windows")));
+  }
+
+  @Before public void setUp() throws Exception {
+    cacheDir = tempDir.newFolder("DiskLruCacheTest");
+    journalFile = new File(cacheDir, JOURNAL_FILE);
+    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
+    for (File file : cacheDir.listFiles()) {
+      file.delete();
+    }
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+  }
+
+  @After public void tearDown() throws Exception {
+    cache.close();
+  }
+
+  @Test public void emptyCache() throws Exception {
+    cache.close();
+    assertJournalEquals();
+  }
+
+  @Test public void writeAndReadEntry() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    assertThat(creator.getString(0)).isNull();
+    assertThat(creator.getString(1)).isNull();
+    creator.commit();
+
+    DiskLruCache.Value value = cache.get("k1");
+    assertThat(value.getString(0)).isEqualTo("ABC");
+    assertThat(value.getLength(0)).isEqualTo(3);
+    assertThat(value.getString(1)).isEqualTo("DE");
+    assertThat(value.getLength(1)).isEqualTo(2);
+  }
+
+  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+    cache.close();
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    DiskLruCache.Value value = cache.get("k1");
+    assertThat(value.getString(0)).isEqualTo("A");
+    assertThat(value.getLength(0)).isEqualTo(1);
+    assertThat(value.getString(1)).isEqualTo("B");
+    assertThat(value.getLength(1)).isEqualTo(1);
+  }
+
+  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+
+    // Simulate a dirty close of 'cache' by opening the cache directory again.
+    DiskLruCache cache2 = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    DiskLruCache.Value value = cache2.get("k1");
+    assertThat(value.getString(0)).isEqualTo("A");
+    assertThat(value.getLength(0)).isEqualTo(1);
+    assertThat(value.getString(1)).isEqualTo("B");
+    assertThat(value.getLength(1)).isEqualTo(1);
+    cache2.close();
+  }
+
+  @Test public void journalWithEditAndPublish() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    creator.set(0, "AB");
+    creator.set(1, "C");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
+  }
+
+  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    creator.set(0, "AB");
+    creator.set(1, "C");
+    creator.abort();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
+    cache.edit("k1");
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertThat(cache.get("k1")).isNull();
+    creator.set(0, "A");
+    creator.set(1, "BC");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
+  }
+
+  @Test public void journalWithEditAndPublishAndRead() throws Exception {
+    DiskLruCache.Editor k1Creator = cache.edit("k1");
+    k1Creator.set(0, "AB");
+    k1Creator.set(1, "C");
+    k1Creator.commit();
+    DiskLruCache.Editor k2Creator = cache.edit("k2");
+    k2Creator.set(0, "DEF");
+    k2Creator.set(1, "G");
+    k2Creator.commit();
+    DiskLruCache.Value k1Value = cache.get("k1");
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
+  }
+
+  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "A");
+    editor.set(1, "B");
+    editor.commit();
+    assertInoperable(editor);
+  }
+
+  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "A");
+    editor.set(1, "B");
+    editor.abort();
+    assertInoperable(editor);
+  }
+
+  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "ABC");
+    editor.set(1, "B");
+    editor.commit();
+    File k1 = getCleanFile("k1", 0);
+    assertThat(readFile(k1)).isEqualTo("ABC");
+    cache.remove("k1");
+    assertThat(k1.exists()).isFalse();
+  }
+
+  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
+    cache.close();
+    File cleanFile0 = getCleanFile("k1", 0);
+    File cleanFile1 = getCleanFile("k1", 1);
+    File dirtyFile0 = getDirtyFile("k1", 0);
+    File dirtyFile1 = getDirtyFile("k1", 1);
+    writeFile(cleanFile0, "A");
+    writeFile(cleanFile1, "B");
+    writeFile(dirtyFile0, "C");
+    writeFile(dirtyFile1, "D");
+    createJournal("CLEAN k1 1 1", "DIRTY   k1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertThat(cleanFile0.exists()).isFalse();
+    assertThat(cleanFile1.exists()).isFalse();
+    assertThat(dirtyFile0.exists()).isFalse();
+    assertThat(dirtyFile1.exists()).isFalse();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "0", "100", "2", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "101", "2", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "1", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1", "BOGUS");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 0000x001 1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
+    cache.close();
+    writeFile(getCleanFile("k1", 0), "A");
+    writeFile(getCleanFile("k1", 1), "B");
+    Writer writer = new FileWriter(journalFile);
+    writer.write(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
+    writer.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertThat(cache.get("k1")).isNull();
+
+    // The journal is not corrupt when editing after a truncated line.
+    set("k1", "C", "D");
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertValue("k1", "C", "D");
+  }
+
+  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1 1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void nullKeyThrows() throws Exception {
+    try {
+      cache.edit(null);
+      Assert.fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(1, "A");
+    try {
+      creator.commit();
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    assertThat(getCleanFile("k1", 0).exists()).isFalse();
+    assertThat(getCleanFile("k1", 1).exists()).isFalse();
+    assertThat(getDirtyFile("k1", 0).exists()).isFalse();
+    assertThat(getDirtyFile("k1", 1).exists()).isFalse();
+    assertThat(cache.get("k1")).isNull();
+
+    DiskLruCache.Editor creator2 = cache.edit("k1");
+    creator2.set(0, "B");
+    creator2.set(1, "C");
+    creator2.commit();
+  }
+
+  @Test public void revertWithTooFewValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(1, "A");
+    creator.abort();
+    assertThat(getCleanFile("k1", 0).exists()).isFalse();
+    assertThat(getCleanFile("k1", 1).exists()).isFalse();
+    assertThat(getDirtyFile("k1", 0).exists()).isFalse();
+    assertThat(getDirtyFile("k1", 1).exists()).isFalse();
+    assertThat(cache.get("k1")).isNull();
+  }
+
+  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+
+    DiskLruCache.Editor updater = cache.edit("k1");
+    updater.set(0, "C");
+    updater.commit();
+
+    DiskLruCache.Value value = cache.get("k1");
+    assertThat(value.getString(0)).isEqualTo("C");
+    assertThat(value.getLength(0)).isEqualTo(1);
+    assertThat(value.getString(1)).isEqualTo("B");
+    assertThat(value.getLength(1)).isEqualTo(1);
+  }
+
+  @Test public void growMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    cache.setMaxSize(20);
+    set("c", "c", "c"); // size 12
+    assertThat(cache.size()).isEqualTo(12);
+  }
+
+  @Test public void shrinkMaxSizeEvicts() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 20);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    set("c", "c", "c"); // size 12
+    cache.setMaxSize(10);
+    cache.executorService.shutdown();
+    cache.executorService.awaitTermination(500, TimeUnit.MILLISECONDS);
+    assertThat(cache.size()).isEqualTo(8 /* 12 - 4 */);
+  }
+
+  @Test public void evictOnInsert() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    assertThat(cache.size()).isEqualTo(10);
+
+    // Cause the size to grow to 12 should evict 'A'.
+    set("c", "c", "c");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(8);
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+
+    // Causing the size to grow to 10 should evict nothing.
+    set("d", "d", "d");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(10);
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+    assertValue("d", "d", "d");
+
+    // Causing the size to grow to 18 should evict 'B' and 'C'.
+    set("e", "eeee", "eeee");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(10);
+    assertAbsent("a");
+    assertAbsent("b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "eeee", "eeee");
+  }
+
+  @Test public void evictOnUpdate() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("a", "a", "aa"); // size 3
+    set("b", "b", "bb"); // size 3
+    set("c", "c", "cc"); // size 3
+    assertThat(cache.size()).isEqualTo(9);
+
+    // Causing the size to grow to 11 should evict 'A'.
+    set("b", "b", "bbbb");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(8);
+    assertAbsent("a");
+    assertValue("b", "b", "bbbb");
+    assertValue("c", "c", "cc");
+  }
+
+  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    cache.get("b"); // 'B' is now least recently used.
+
+    // Causing the size to grow to 12 should evict 'A'.
+    set("f", "f", "f");
+    // Causing the size to grow to 12 should evict 'C'.
+    set("g", "g", "g");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(10);
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+  }
+
+  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    set("f", "f", "f");
+    cache.get("b"); // 'B' is now least recently used.
+    assertThat(cache.size()).isEqualTo(12);
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("g", "g", "g");
+    cache.flush();
+    assertThat(cache.size()).isEqualTo(10);
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+    assertValue("g", "g", "g");
+  }
+
+  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aaaaa", "aaaaaa"); // size=11
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aaaaaaaaaaa", "a"); // size=12
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
+    try {
+      DiskLruCache.open(cacheDir, appVersion, 2, 0);
+      Assert.fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
+    try {
+      DiskLruCache.open(cacheDir, appVersion, 0, 10);
+      Assert.fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void removeAbsentElement() throws Exception {
+    cache.remove("a");
+  }
+
+  @Test public void readingTheSameFileMultipleTimes() throws Exception {
+    set("a", "a", "b");
+    DiskLruCache.Value value = cache.get("a");
+    assertThat(value.getFile(0)).isSameAs(value.getFile(0));
+  }
+
+  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break; // Test passed!
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      set("a", "a", "a");
+      set("b", "b", "b");
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break;
+      }
+      lastJournalLength = journalLength;
+    }
+
+    // Sanity check that a rebuilt journal behaves normally.
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+      cache.close();
+      cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break; // Test passed!
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      set("a", "a", "a");
+      set("b", "b", "b");
+      cache.close();
+      cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break;
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  @Test public void restoreBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    creator.commit();
+    cache.close();
+
+    assertThat(journalFile.renameTo(journalBkpFile)).isTrue();
+    assertThat(journalFile.exists()).isFalse();
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+
+    DiskLruCache.Value value = cache.get("k1");
+    assertThat(value.getString(0)).isEqualTo("ABC");
+    assertThat(value.getLength(0)).isEqualTo(3);
+    assertThat(value.getString(1)).isEqualTo("DE");
+    assertThat(value.getLength(1)).isEqualTo(2);
+
+    assertThat(journalBkpFile.exists()).isFalse();
+    assertThat(journalFile.exists()).isTrue();
+  }
+
+  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    creator.commit();
+    cache.flush();
+
+    FileUtils.copyFile(journalFile, journalBkpFile);
+
+    creator = cache.edit("k2");
+    creator.set(0, "F");
+    creator.set(1, "GH");
+    creator.commit();
+    cache.close();
+
+    assertThat(journalFile.exists()).isTrue();
+    assertThat(journalBkpFile.exists()).isTrue();
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+
+    DiskLruCache.Value valueA = cache.get("k1");
+    assertThat(valueA.getString(0)).isEqualTo("ABC");
+    assertThat(valueA.getLength(0)).isEqualTo(3);
+    assertThat(valueA.getString(1)).isEqualTo("DE");
+    assertThat(valueA.getLength(1)).isEqualTo(2);
+
+    DiskLruCache.Value valueB = cache.get("k2");
+    assertThat(valueB.getString(0)).isEqualTo("F");
+    assertThat(valueB.getLength(0)).isEqualTo(1);
+    assertThat(valueB.getString(1)).isEqualTo("GH");
+    assertThat(valueB.getLength(1)).isEqualTo(2);
+
+    assertThat(journalBkpFile.exists()).isFalse();
+    assertThat(journalFile.exists()).isTrue();
+  }
+
+  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
+    cache.close();
+    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
+    cache = DiskLruCache.open(dir, appVersion, 2, Integer.MAX_VALUE);
+    set("a", "a", "a");
+    assertThat(new File(dir, "a.0").exists()).isTrue();
+    assertThat(new File(dir, "a.1").exists()).isTrue();
+    assertThat(new File(dir, "journal").exists()).isTrue();
+  }
+
+  @Test public void fileDeletedExternally() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 1).delete();
+    assertThat(cache.get("a")).isNull();
+  }
+
+  @Test public void editSameVersion() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Value value = cache.get("a");
+    DiskLruCache.Editor editor = value.edit();
+    editor.set(1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeAborted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Value value = cache.get("a");
+    DiskLruCache.Editor toAbort = value.edit();
+    toAbort.set(0, "b");
+    toAbort.abort();
+    DiskLruCache.Editor editor = value.edit();
+    editor.set(1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Value value = cache.get("a");
+    DiskLruCache.Editor toAbort = value.edit();
+    toAbort.set(0, "b");
+    toAbort.commit();
+    assertThat(value.edit()).isNull();
+  }
+
+  @Test public void editSinceEvicted() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Value value = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    cache.flush();
+    assertThat(value.edit()).isNull();
+  }
+
+  @Test public void editSinceEvictedAndRecreated() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Value value = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    set("a", "a", "aaaa"); // size 5; will evict 'B'
+    cache.flush();
+    assertThat(value.edit()).isNull();
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesWrite() throws Exception {
+    FileUtils.deleteDirectory(cacheDir);
+    set("a", "a", "a");
+    assertValue("a", "a", "a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesEdit() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    FileUtils.deleteDirectory(cacheDir);
+    a.set(1, "a2");
+    a.commit();
+  }
+
+  @Test public void removeHandlesMissingFile() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 0).delete();
+    cache.remove("a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    a.set(0, "a1");
+    FileUtils.deleteDirectory(cacheDir);
+    a.set(1, "a2");
+    a.commit();
+    assertThat(cache.get("a")).isNull();
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesRead() throws Exception {
+    FileUtils.deleteDirectory(cacheDir);
+    assertThat(cache.get("a")).isNull();
+  }
+
+  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
+    List<String> expectedLines = new ArrayList<String>();
+    expectedLines.add(MAGIC);
+    expectedLines.add(VERSION_1);
+    expectedLines.add("100");
+    expectedLines.add("2");
+    expectedLines.add("");
+    expectedLines.addAll(Arrays.asList(expectedBodyLines));
+    assertThat(readJournalLines()).isEqualTo(expectedLines);
+  }
+
+  private void createJournal(String... bodyLines) throws Exception {
+    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
+  }
+
+  private void createJournalWithHeader(String magic, String version, String appVersion,
+      String valueCount, String blank, String... bodyLines) throws Exception {
+    Writer writer = new FileWriter(journalFile);
+    writer.write(magic + "\n");
+    writer.write(version + "\n");
+    writer.write(appVersion + "\n");
+    writer.write(valueCount + "\n");
+    writer.write(blank + "\n");
+    for (String line : bodyLines) {
+      writer.write(line);
+      writer.write('\n');
+    }
+    writer.close();
+  }
+
+  private List<String> readJournalLines() throws Exception {
+    List<String> result = new ArrayList<String>();
+    BufferedReader reader = new BufferedReader(new FileReader(journalFile));
+    String line;
+    while ((line = reader.readLine()) != null) {
+      result.add(line);
+    }
+    reader.close();
+    return result;
+  }
+
+  private File getCleanFile(String key, int index) {
+    return new File(cacheDir, key + "." + index);
+  }
+
+  private File getDirtyFile(String key, int index) {
+    return new File(cacheDir, key + "." + index + ".tmp");
+  }
+
+  private static String readFile(File file) throws Exception {
+    Reader reader = new FileReader(file);
+    StringWriter writer = new StringWriter();
+    char[] buffer = new char[1024];
+    int count;
+    while ((count = reader.read(buffer)) != -1) {
+      writer.write(buffer, 0, count);
+    }
+    reader.close();
+    return writer.toString();
+  }
+
+  public static void writeFile(File file, String content) throws Exception {
+    FileWriter writer = new FileWriter(file);
+    writer.write(content);
+    writer.close();
+  }
+
+  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
+    try {
+      editor.getString(0);
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.set(0, "A");
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.getFile(0);
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.commit();
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.abort();
+      Assert.fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  private void generateSomeGarbageFiles() throws Exception {
+    File dir1 = new File(cacheDir, "dir1");
+    File dir2 = new File(dir1, "dir2");
+    writeFile(getCleanFile("g1", 0), "A");
+    writeFile(getCleanFile("g1", 1), "B");
+    writeFile(getCleanFile("g2", 0), "C");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(new File(cacheDir, "otherFile0"), "E");
+    dir1.mkdir();
+    dir2.mkdir();
+    writeFile(new File(dir2, "otherFile1"), "F");
+  }
+
+  private void assertGarbageFilesAllDeleted() throws Exception {
+    assertThat(getCleanFile("g1", 0)).doesNotExist();
+    assertThat(getCleanFile("g1", 1)).doesNotExist();
+    assertThat(getCleanFile("g2", 0)).doesNotExist();
+    assertThat(getCleanFile("g2", 1)).doesNotExist();
+    assertThat(new File(cacheDir, "otherFile0")).doesNotExist();
+    assertThat(new File(cacheDir, "dir1")).doesNotExist();
+  }
+
+  private void set(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Editor editor = cache.edit(key);
+    editor.set(0, value0);
+    editor.set(1, value1);
+    editor.commit();
+  }
+
+  private void assertAbsent(String key) throws Exception {
+    DiskLruCache.Value value = cache.get(key);
+    if (value != null) {
+      Assert.fail();
+    }
+    assertThat(getCleanFile(key, 0)).doesNotExist();
+    assertThat(getCleanFile(key, 1)).doesNotExist();
+    assertThat(getDirtyFile(key, 0)).doesNotExist();
+    assertThat(getDirtyFile(key, 1)).doesNotExist();
+  }
+
+  private void assertValue(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Value value = cache.get(key);
+    assertThat(value.getString(0)).isEqualTo(value0);
+    assertThat(value.getLength(0)).isEqualTo(value0.length());
+    assertThat(value.getString(1)).isEqualTo(value1);
+    assertThat(value.getLength(1)).isEqualTo(value1.length());
+    assertThat(getCleanFile(key, 0)).exists();
+    assertThat(getCleanFile(key, 1)).exists();
+  }
+}
diff --git a/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/StrictLineReaderTest.java b/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/StrictLineReaderTest.java
new file mode 100644
index 000000000..8e1bb63b3
--- /dev/null
+++ b/third_party/disklrucache/src/test/java/com/bumptech/glide/disklrucache/StrictLineReaderTest.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.bumptech.glide.disklrucache;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.ByteArrayInputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(JUnit4.class)
+public class StrictLineReaderTest {
+  @Test public void lineReaderConsistencyWithReadAsciiLine() {
+    try {
+      // Testing with LineReader buffer capacity 32 to check some corner cases.
+      StrictLineReader lineReader =
+          new StrictLineReader(createTestInputStream(), 32, Util.US_ASCII);
+      InputStream refStream = createTestInputStream();
+      while (true) {
+        try {
+          String refLine = readAsciiLine(refStream);
+          try {
+            String line = lineReader.readLine();
+            if (!refLine.equals(line)) {
+              Assert.fail("line (\"" + line + "\") differs from expected (\"" + refLine + "\").");
+            }
+          } catch (EOFException eof) {
+            Assert.fail("line reader threw EOFException too early.");
+          }
+        } catch (EOFException refEof) {
+          try {
+            lineReader.readLine();
+            Assert.fail("line reader didn't throw the expected EOFException.");
+          } catch (EOFException expected) {
+            break;
+          }
+        }
+      }
+      refStream.close();
+      lineReader.close();
+    } catch (IOException ioe) {
+      Assert.fail("Unexpected IOException " + ioe.toString());
+    }
+  }
+
+  /* XXX From libcore.io.Streams */
+  private static String readAsciiLine(InputStream in) throws IOException {
+    // TODO: support UTF-8 here instead
+
+    StringBuilder result = new StringBuilder(80);
+    while (true) {
+      int c = in.read();
+      if (c == -1) {
+        throw new EOFException();
+      } else if (c == '\n') {
+        break;
+      }
+
+      result.append((char) c);
+    }
+    int length = result.length();
+    if (length > 0 && result.charAt(length - 1) == '\r') {
+      result.setLength(length - 1);
+    }
+    return result.toString();
+  }
+
+  private static InputStream createTestInputStream() {
+    return new ByteArrayInputStream((""
+        // Each source lines below should represent 32 bytes, until the next comment.
+        + "12 byte line\n18 byte line......\n"
+        + "pad\nline spanning two 32-byte bu"
+        + "ffers\npad......................\n"
+        + "pad\nline spanning three 32-byte "
+        + "buffers and ending with LF at th"
+        + "e end of a 32 byte buffer......\n"
+        + "pad\nLine ending with CRLF split"
+        + " at the end of a 32-byte buffer\r"
+        + "\npad...........................\n"
+        // End of 32-byte lines.
+        + "line ending with CRLF\r\n"
+        + "this is a long line with embedded CR \r ending with CRLF and having more than "
+        + "32 characters\r\n"
+        + "unterminated line - should be dropped").getBytes());
+  }
+}
+
diff --git a/third_party/exif_orientation_examples/.gitignore b/third_party/exif_orientation_examples/.gitignore
new file mode 100644
index 000000000..f39f9657c
--- /dev/null
+++ b/third_party/exif_orientation_examples/.gitignore
@@ -0,0 +1,6 @@
+/.ruby-gemset
+/.ruby-version
+/generator/Gemfile.lock
+/Landscape.jpg
+/Portrait.jpg
+/sources
diff --git a/third_party/exif_orientation_examples/LICENSE b/third_party/exif_orientation_examples/LICENSE
new file mode 100644
index 000000000..978ee2ae8
--- /dev/null
+++ b/third_party/exif_orientation_examples/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2010 Dave Perrett, http://recursive-design.com/
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
\ No newline at end of file
diff --git a/third_party/exif_orientation_examples/Landscape_1.jpg b/third_party/exif_orientation_examples/Landscape_1.jpg
new file mode 100644
index 000000000..fda188236
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_1.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_2.jpg b/third_party/exif_orientation_examples/Landscape_2.jpg
new file mode 100644
index 000000000..d2605f81b
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_2.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_3.jpg b/third_party/exif_orientation_examples/Landscape_3.jpg
new file mode 100644
index 000000000..f50805234
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_3.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_4.jpg b/third_party/exif_orientation_examples/Landscape_4.jpg
new file mode 100644
index 000000000..d73dee8fd
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_4.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_5.jpg b/third_party/exif_orientation_examples/Landscape_5.jpg
new file mode 100644
index 000000000..975d85883
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_5.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_6.jpg b/third_party/exif_orientation_examples/Landscape_6.jpg
new file mode 100644
index 000000000..b579b7f9a
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_6.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_7.jpg b/third_party/exif_orientation_examples/Landscape_7.jpg
new file mode 100644
index 000000000..b1e919cfd
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_7.jpg differ
diff --git a/third_party/exif_orientation_examples/Landscape_8.jpg b/third_party/exif_orientation_examples/Landscape_8.jpg
new file mode 100644
index 000000000..c381db10e
Binary files /dev/null and b/third_party/exif_orientation_examples/Landscape_8.jpg differ
diff --git a/third_party/exif_orientation_examples/Makefile b/third_party/exif_orientation_examples/Makefile
new file mode 100644
index 000000000..c5fc2e0e4
--- /dev/null
+++ b/third_party/exif_orientation_examples/Makefile
@@ -0,0 +1,11 @@
+all: portrait landscape
+
+portrait:
+	curl --location https://source.unsplash.com/random/1200x1600 --output ./Portrait.jpg
+	bash -c "cd generator && ./generate.rb ../Portrait.jpg"
+	rm -f ./Portrait.jpg
+
+landscape:
+	curl --location https://source.unsplash.com/random/1600x1200 --output ./Landscape.jpg
+	bash -c "cd generator && ./generate.rb ../Landscape.jpg"
+	rm -f ./Landscape.jpg
diff --git a/third_party/exif_orientation_examples/Portrait_1.jpg b/third_party/exif_orientation_examples/Portrait_1.jpg
new file mode 100644
index 000000000..dcb57c537
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_1.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_2.jpg b/third_party/exif_orientation_examples/Portrait_2.jpg
new file mode 100644
index 000000000..8c3adf7af
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_2.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_3.jpg b/third_party/exif_orientation_examples/Portrait_3.jpg
new file mode 100644
index 000000000..5a5544f23
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_3.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_4.jpg b/third_party/exif_orientation_examples/Portrait_4.jpg
new file mode 100644
index 000000000..9eb2a6a1e
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_4.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_5.jpg b/third_party/exif_orientation_examples/Portrait_5.jpg
new file mode 100644
index 000000000..905169aa7
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_5.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_6.jpg b/third_party/exif_orientation_examples/Portrait_6.jpg
new file mode 100644
index 000000000..8fc576e06
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_6.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_7.jpg b/third_party/exif_orientation_examples/Portrait_7.jpg
new file mode 100644
index 000000000..cfa04d66e
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_7.jpg differ
diff --git a/third_party/exif_orientation_examples/Portrait_8.jpg b/third_party/exif_orientation_examples/Portrait_8.jpg
new file mode 100644
index 000000000..b2a50d6eb
Binary files /dev/null and b/third_party/exif_orientation_examples/Portrait_8.jpg differ
diff --git a/third_party/exif_orientation_examples/README.markdown b/third_party/exif_orientation_examples/README.markdown
new file mode 100644
index 000000000..61c0b8595
--- /dev/null
+++ b/third_party/exif_orientation_examples/README.markdown
@@ -0,0 +1,82 @@
+EXIF Orientation-flag example images
+====================================
+
+Example images using each of the EXIF orientation flags (1-to-8), in both landscape and portrait orientations.
+
+[See here](http://www.daveperrett.com/articles/2012/07/28/exif-orientation-handling-is-a-ghetto/) for more information.
+
+
+Generating your own images
+--------------------------
+
+If you would like to generate test images based on your own photos, you can use the `generate.rb` script included in the `generator` folder.
+
+The instructions below assume you are running on OSX - if not, you will need to install the Ghostscript fonts (`brew install gs`) some other way.
+
+To install the dependencies:
+
+```
+> brew install gs
+> cd generator
+> gem install bundler
+> bundle install
+```
+
+To generate test images:
+
+```
+> cd generator
+> ./generate path/to/image.jpg
+```
+
+This will create images `image_1.jpg` through to `image_8.jpg`.
+
+
+Re-generating sample images
+---------------------------
+
+Simply run `make` to regenerate the included sample images. This will download random portrait and landscape orientation images from [unsplash.com](https://unsplash.com/) and generate sample images for each of them.
+
+Generating these images depends on having the generator dependencies installed - see the *Generating your own images* section for instructions on installing dependencies.
+
+
+Credits
+-------
+
+* The sample landscape image is by [Pierre Bouillot](https://unsplash.com/photos/v15iOM6pWgI).
+* The sample portrait image is by [John Salvino](https://unsplash.com/photos/1PPpwrTNkJI).
+
+
+Change history
+--------------
+
+* **Version 2.0.0 (2017-08-05)** : Add a script to generate example images from the command line.
+* **Version 1.0.2 (2017-03-06)** : Remove Apple Copyrighted ICC profile from orientations 2-8 (thanks @mans0954!).
+* **Version 1.0.1 (2013-03-10)** : Add MIT license and some contact details.
+* **Version 1.0.0 (2012-07-28)** : 1.0 release.
+
+
+Contributing
+------------
+
+Once you've made your commits:
+
+1. [Fork](http://help.github.com/fork-a-repo/) exif-orientation-examples
+2. Create a topic branch - `git checkout -b my_branch`
+3. Push to your branch - `git push origin my_branch`
+4. Create a [Pull Request](http://help.github.com/pull-requests/) from your branch
+5. That's it!
+
+
+Author
+------
+
+Dave Perrett :: hello@daveperrett.com :: [@daveperrett](http://twitter.com/daveperrett)
+
+
+Copyright
+---------
+
+These images are licensed under the [MIT License](http://opensource.org/licenses/MIT).
+
+Copyright (c) 2010 Dave Perrett. See [License](https://github.com/recurser/exif-orientation-examples/blob/master/LICENSE) for details.
diff --git a/third_party/exif_orientation_examples/README.third_party b/third_party/exif_orientation_examples/README.third_party
new file mode 100644
index 000000000..e27da7562
--- /dev/null
+++ b/third_party/exif_orientation_examples/README.third_party
@@ -0,0 +1,10 @@
+URL: https://github.com/recurser/exif-orientation-examples/tree/d06cd11258b98b24b3cd8d391ee5bf4961a80853
+Version: d06cd11258b98b24b3cd8d391ee5bf4961a80853
+License: MIT
+License File: LICENSE
+
+Description:
+Sample images with all of the supported exif orientations.
+ 
+Local Modifications:
+None
diff --git a/third_party/exif_orientation_examples/VERSION b/third_party/exif_orientation_examples/VERSION
new file mode 100644
index 000000000..227cea215
--- /dev/null
+++ b/third_party/exif_orientation_examples/VERSION
@@ -0,0 +1 @@
+2.0.0
diff --git a/third_party/exif_orientation_examples/generator/Gemfile b/third_party/exif_orientation_examples/generator/Gemfile
new file mode 100644
index 000000000..65e8f880b
--- /dev/null
+++ b/third_party/exif_orientation_examples/generator/Gemfile
@@ -0,0 +1,4 @@
+source 'https://rubygems.org'
+ruby '2.4.1'
+
+gem 'rmagick'
diff --git a/third_party/exif_orientation_examples/generator/generate.rb b/third_party/exif_orientation_examples/generator/generate.rb
new file mode 100755
index 000000000..4df576670
--- /dev/null
+++ b/third_party/exif_orientation_examples/generator/generate.rb
@@ -0,0 +1,135 @@
+#!/usr/bin/env ruby
+
+# Make sure to 'brew install gs' before running this.
+
+require 'RMagick'
+require 'tempfile'
+
+if ARGV.length != 1
+  abort "Usage: #{$PROGRAM_NAME} /path/to/image"
+end
+
+# Make sure the file exists.
+source = ARGV[0]
+abort "Error: File '#{source}' not found" unless File.exist?(source) && File.file?(source)
+
+# Copy it to the temp directory.
+path = Tempfile.new('to-convert').path
+FileUtils.cp source, path
+
+# Make sure it's an image.
+image = begin
+  Magick::Image::read(path).first
+rescue Magick::ImageMagickError
+  abort "Error: File '#{source}' does not appear to be an image."
+end
+
+# Make sure exiftool and convert are available.
+abort 'Error: The exiftool command does not appear to be available' if `which exiftool` == ''
+abort 'Error: The convert command does not appear to be available' if `which convert` == ''
+abort 'Error: the input file must be a JPEG' unless image.format == 'JPEG'
+
+# Decide where we'll put the output.
+dest_folder    = File.dirname(source)
+dest_file_base = File.basename(source, '.*')
+dest_extention = File.extname(source)
+
+# Strip all exif data.
+`exiftool -all= #{path}`
+
+# Strip color profile info.
+FileUtils.cp path, "#{path}.convert"
+`convert #{path}.convert +profile "*" #{path}`
+FileUtils.rm_f "#{path}.convert"
+
+# Decide on a suitable font size.
+dimension = [image.rows, image.columns].max
+font_size = dimension / 20
+
+# Add top / right / bottom / left text.
+text              = Magick::Draw.new
+text.font_family  = 'helvetica'
+text.pointsize    = font_size
+text.fill         = 'white'
+text.stroke       = 'black'
+text.stroke_width = 1
+edge_padding      = font_size / 4
+
+text.annotate(image, 0, 0, 0, edge_padding, 'top') do
+  self.gravity = Magick::NorthGravity
+end
+
+text.annotate(image, 0, 0, 0, edge_padding, 'bottom') do
+  self.gravity = Magick::SouthGravity
+end
+
+text.annotate(image, 0, 0, edge_padding, 0, 'right') do
+  self.gravity = Magick::EastGravity
+end
+
+text.annotate(image, 0, 0, edge_padding, 0, 'left') do
+  self.gravity = Magick::WestGravity
+end
+
+transformations = [
+  {
+    exif_tag:         1,
+    rotation_degrees: 0,
+    flop:             false,
+  },
+  {
+    exif_tag:         2,
+    rotation_degrees: 0,
+    flop:             true,
+  },
+
+  {
+    exif_tag:         3,
+    rotation_degrees: 180,
+    flop:             false,
+  },
+  {
+    exif_tag:         4,
+    rotation_degrees: 180,
+    flop:             true,
+  },
+  {
+    exif_tag:         5,
+    rotation_degrees: -90,
+    flop:             true,
+  },
+  {
+    exif_tag:         6,
+    rotation_degrees: -90,
+    flop:             false,
+  },
+  {
+    exif_tag:         7,
+    rotation_degrees: 90,
+    flop:             true,
+  },
+  {
+    exif_tag:         8,
+    rotation_degrees: 90,
+    flop:             false,
+  },
+]
+
+transformations.each do |t|
+  tmp_image = image.dup
+
+  # Add centered text displaying the orientation tag number.
+  text.annotate(tmp_image, 0, 0, 0, 0, t[:exif_tag].to_s) do
+    self.gravity   = Magick::CenterGravity
+    text.pointsize = font_size * 2
+  end
+
+  # Rotate and transform the image.
+  tmp_image.flop! if t[:flop]
+  tmp_image.rotate! t[:rotation_degrees] if t[:rotation_degrees] != 0
+  out_path = File.join(dest_folder, "#{dest_file_base}_#{t[:exif_tag]}#{dest_extention}")
+  tmp_image.write(out_path)
+
+  # Set the EXIF Orientation tag.
+  `exiftool -overwrite_original -orientation=#{t[:exif_tag]} -n #{out_path}`
+end
