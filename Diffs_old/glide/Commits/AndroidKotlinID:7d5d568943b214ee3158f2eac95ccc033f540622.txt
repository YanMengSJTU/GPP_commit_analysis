diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
index ca27a20c0..8c4810acf 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.eq;
@@ -8,23 +9,22 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
-import android.os.Handler;
-import android.os.Looper;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
 import com.bumptech.glide.test.GlideApp;
 import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
 import com.bumptech.glide.test.TearDownGlide;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import org.junit.Before;
 import org.junit.Rule;
@@ -40,14 +40,13 @@
 @RunWith(AndroidJUnit4.class)
 public class CachingTest {
   private static final int IMAGE_SIZE_PIXELS = 500;
-  private static final long TIMEOUT_MS = 5000;
-  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;
   // Store at least 10 500x500 pixel Bitmaps with the ARGB_8888 config to be safe.
   private static final long CACHE_SIZE_BYTES =
       IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;
 
   @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
   @Mock private RequestListener<Drawable> requestListener;
+  private ConcurrencyHelper concurrency = new ConcurrencyHelper();
 
   private Context context;
 
@@ -60,6 +59,83 @@ public void setUp() throws InterruptedException {
         context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));
   }
 
+  @Test
+  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    FutureTarget<Drawable> first =
+        GlideApp.with(context)
+            .load(raw.canonical)
+            .submit();
+    concurrency.get(first);
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            any(Drawable.class),
+            any(),
+            anyTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    FutureTarget<Drawable> first =
+        GlideApp.with(context)
+            .load(raw.canonical)
+            .submit();
+    concurrency.get(first);
+
+    // Allow first to be GCed and removed from active resources.
+    //noinspection UnusedAssignment
+    first = null;
+    // De-flake by allowing multiple tries
+    for (int j = 0; j < 10; j++) {
+      Runtime.getRuntime().gc();
+      concurrency.pokeMainThread();
+      try {
+        // Loading again here won't shuffle our resource around because it only changes our
+        // reference count from 1 to 2 and back. The reference we're waiting for will only be
+        // decremented when the target is GCed.
+        FutureTarget<Drawable> target =
+            concurrency.wait(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .onlyRetrieveFromCache(true)
+                    .diskCacheStrategy(DiskCacheStrategy.NONE)
+                    .submit());
+        GlideApp.with(context).clear(target);
+      } catch (RuntimeException e) {
+        // The item has been cleared from active resources.
+        break;
+      }
+    }
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            any(Drawable.class),
+            any(),
+            anyTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
   @Test
   public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache()
       throws InterruptedException, ExecutionException, TimeoutException {
@@ -67,17 +143,17 @@ public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCac
         .load(ResourceIds.raw.canonical)
         .diskCacheStrategy(DiskCacheStrategy.DATA)
         .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
-    future.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
+    concurrency.get(future);
     GlideApp.with(context).clear(future);
 
     clearMemoryCacheOnMainThread();
 
-    GlideApp.with(context)
-        .load(ResourceIds.raw.canonical)
-        .diskCacheStrategy(DiskCacheStrategy.DATA)
-        .listener(requestListener)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
-        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
 
     verify(requestListener)
         .onResourceReady(
@@ -93,20 +169,23 @@ public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFr
       throws InterruptedException, TimeoutException, ExecutionException {
     // We can't allow any mocks (RequestListner, Target etc) to reference this request or the test
     // will fail due to the transient strong reference to the request.
-    GlideApp.with(context)
-        .load(ResourceIds.raw.canonical)
-        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
-        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
     // Force the collection of weak references now that the listener/request in the first load is no
     // longer referenced.
     Runtime.getRuntime().gc();
-    GlideApp.with(context)
-        .load(ResourceIds.raw.canonical)
-        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
-        .listener(requestListener)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
-        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+    concurrency.pokeMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
 
     verify(requestListener).onResourceReady(
         any(Drawable.class), any(), anyTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
@@ -117,22 +196,25 @@ public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecy
       throws InterruptedException, TimeoutException, ExecutionException {
     // We can't allow any mocks (RequestListener, Target etc) to reference this request or the test
     // will fail due to the transient strong reference to the request.
-    Bitmap bitmap = GlideApp.with(context)
-        .asBitmap()
-        .load(ResourceIds.raw.canonical)
-        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
-        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.canonical)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
     // Force the collection of weak references now that the listener/request in the first load is no
     // longer referenced.
     Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
 
     FutureTarget<Bitmap> future = GlideApp.with(context)
         .asBitmap()
         .load(ResourceIds.raw.canonical)
         .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
         .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
-    future.get(TIMEOUT_MS, TIMEOUT_UNIT);
+    concurrency.get(future);
     Glide.with(context).clear(future);
 
     clearMemoryCacheOnMainThread();
@@ -147,7 +229,7 @@ public void clearDiskCache_doesNotPreventFutureLoads()
         .load(ResourceIds.raw.canonical)
         .diskCacheStrategy(DiskCacheStrategy.DATA)
         .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
-    future.get(TIMEOUT_MS, TIMEOUT_UNIT);
+    concurrency.get(future);
     GlideApp.with(context).clear(future);
 
     clearMemoryCacheOnMainThread();
@@ -157,17 +239,17 @@ public void clearDiskCache_doesNotPreventFutureLoads()
         .load(ResourceIds.raw.canonical)
         .diskCacheStrategy(DiskCacheStrategy.DATA)
         .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
-    future.get(TIMEOUT_MS, TIMEOUT_UNIT);
+    concurrency.get(future);
 
     GlideApp.with(context).clear(future);
     clearMemoryCacheOnMainThread();
 
-    GlideApp.with(context)
-        .load(ResourceIds.raw.canonical)
-        .listener(requestListener)
-        .diskCacheStrategy(DiskCacheStrategy.DATA)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS)
-        .get(TIMEOUT_MS, TIMEOUT_UNIT);
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
 
     verify(requestListener).onResourceReady(
         any(Drawable.class), any(), anyTarget(), eq(DataSource.DATA_DISK_CACHE), anyBoolean());
@@ -179,14 +261,11 @@ public void clearDiskCache_doesNotPreventFutureLoads()
   }
 
   private void clearMemoryCacheOnMainThread() throws InterruptedException {
-    final CountDownLatch countDownLatch = new CountDownLatch(1);
-    new Handler(Looper.getMainLooper()).post(new Runnable() {
+    concurrency.runOnMainThread(new Runnable() {
       @Override
       public void run() {
         Glide.get(context).clearMemory();
-        countDownLatch.countDown();
       }
     });
-    countDownLatch.await(TIMEOUT_MS, TIMEOUT_UNIT);
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
new file mode 100644
index 000000000..58a3b728d
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
@@ -0,0 +1,95 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.ImageView;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.LifecycleListener;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class RequestManagerTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestManagerTreeNode treeNode;
+
+  private ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private RequestManager requestManager;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+    Glide glide = Glide.get(context);
+    requestManager = new RequestManager(glide, new Lifecycle() {
+      @Override
+      public void addListener(LifecycleListener listener) {
+        listener.onStart();
+      }
+
+      @Override
+      public void removeListener(LifecycleListener listener) {
+        // Do nothing.
+      }
+    }, treeNode, context);
+  }
+
+  /**
+   * Tests #2262.
+   */
+  @Test
+  public void clear_withNonOwningRequestManager_afterOwningManagerIsDestroyed_doesNotThrow() {
+    // First destroy our Fragment/Activity RequestManager.
+    requestManager.onDestroy();
+
+    final ImageView imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+    // Then start a new load with our now destroyed RequestManager.
+    concurrency.loadOnMainThread(requestManager.load(ResourceIds.raw.canonical), imageView);
+
+    // Finally clear our new load with any RequestManager other than the one we used to start it.
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(context).clear(imageView);
+      }
+    });
+  }
+
+  /**
+   * Tests b/69361054.
+   */
+  @Test
+  public void clear_withNonOwningRequestManager_onBackgroundTHread_doesNotThrow() {
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        requestManager.onDestroy();
+      }
+    });
+
+    final FutureTarget<Drawable> target =
+        concurrency.wait(requestManager.load(raw.canonical).submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(context).clear(target);
+      }
+    });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
new file mode 100644
index 000000000..7da379364
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -0,0 +1,161 @@
+package com.bumptech.glide.test;
+
+
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.Nullable;
+import android.widget.ImageView;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.target.DrawableImageViewTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Helper for running sections of code on the main thread in emulator tests.
+ */
+public class ConcurrencyHelper {
+  private final Handler handler = new Handler(Looper.getMainLooper());
+  private static final long TIMEOUT_MS = 5000;
+  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;
+
+  public <T> T get(Future<T> future) {
+    try {
+      return future.get(TIMEOUT_MS, TIMEOUT_UNIT);
+    } catch (InterruptedException | ExecutionException | TimeoutException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public <T, Y extends Future<T>> Y wait(Y future) {
+    get(future);
+    return future;
+  }
+
+  public Target<Drawable> loadOnMainThread(
+      final RequestBuilder<Drawable> builder, ImageView imageView) {
+    return loadOnMainThread(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  public <T> Target<T> loadOnMainThread(final RequestBuilder<T> builder, final Target<T> target) {
+    return callOnMainThread(new Callable<Target<T>>() {
+      @Override
+      public Target<T> call() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(1);
+        builder.into(new Target<T>() {
+          @Override
+          public void onStart() {
+            target.onStart();
+          }
+
+          @Override
+          public void onStop() {
+            target.onStop();
+          }
+
+          @Override
+          public void onDestroy() {
+            target.onDestroy();
+          }
+
+          @Override
+          public void onResourceReady(T resource, Transition<? super T> transition) {
+            target.onResourceReady(resource, transition);
+            latch.countDown();
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {
+            target.onLoadCleared(placeholder);
+          }
+
+          @Override
+          public void onLoadStarted(@Nullable Drawable placeholder) {
+            target.onLoadStarted(placeholder);
+          }
+
+          @Override
+          public void onLoadFailed(@Nullable Drawable errorDrawable) {
+            target.onLoadFailed(errorDrawable);
+            latch.countDown();
+          }
+
+          @Override
+          public void getSize(SizeReadyCallback cb) {
+            target.getSize(cb);
+          }
+
+          @Override
+          public void removeCallback(SizeReadyCallback cb) {
+            target.removeCallback(cb);
+          }
+
+          @Override
+          public void setRequest(@Nullable Request request) {
+            target.setRequest(request);
+
+          }
+
+          @Nullable
+          @Override
+          public Request getRequest() {
+            return target.getRequest();
+          }
+        });
+        latch.await(TIMEOUT_MS, TIMEOUT_UNIT);
+        return target;
+      }
+    });
+  }
+
+  public void pokeMainThread() {
+    runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        // Do nothing.
+      }
+    });
+  }
+
+  public void runOnMainThread(final Runnable runnable) {
+    callOnMainThread(new Callable<Void>() {
+      @Override
+      public Void call() throws Exception {
+        runnable.run();
+        return null;
+      }
+    });
+  }
+
+  public <T> T callOnMainThread(final Callable<T> callable) {
+    final AtomicReference<T> reference = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    handler.post(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          T result = callable.call();
+          reference.set(result);
+        } catch (Exception e) {
+          throw new RuntimeException(e);
+        }
+        latch.countDown();
+      }
+    });
+    try {
+      latch.await(TIMEOUT_MS, TIMEOUT_UNIT);
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+    return reference.get();
+  }
+}
diff --git a/library/build.gradle b/library/build.gradle
index e9ff851da..6f8565c22 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -19,6 +19,7 @@ dependencies {
     testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
     testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
     testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+    testImplementation 'commons-io:commons-io:2.6'
 }
 
 android.testOptions.unitTests.all { Test testTask ->
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index f1ce6fd7e..047c8691d 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -186,11 +186,17 @@ private static void checkAndInitializeGlide(Context context) {
   @VisibleForTesting
   @Deprecated
   public static synchronized void init(Glide glide) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
     Glide.glide = glide;
   }
 
   @VisibleForTesting
   public static synchronized void init(Context context, GlideBuilder builder) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
     initializeGlide(context, builder);
   }
 
@@ -705,15 +711,16 @@ public Registry getRegistry() {
     return registry;
   }
 
-  void removeFromManagers(Target<?> target) {
+  boolean removeFromManagers(Target<?> target) {
     synchronized (managers) {
       for (RequestManager requestManager : managers) {
         if (requestManager.untrack(target)) {
-          return;
+          return true;
         }
       }
     }
-    throw new IllegalStateException("Failed to remove target from managers");
+
+    return false;
   }
 
   void registerRequestManager(RequestManager requestManager) {
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index ecd2e5821..73c0447c0 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -447,8 +447,27 @@ public void run() {
 
   private void untrackOrDelegate(Target<?> target) {
     boolean isOwnedByUs = untrack(target);
-    if (!isOwnedByUs) {
-      glide.removeFromManagers(target);
+    // We'll end up here if the Target was cleared after the RequestManager that started the request
+    // is destroyed. That can happen for at least two reasons:
+    // 1. We call clear() on a background thread using something other than Application Context
+    // RequestManager.
+    // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
+    // Fragment is destroyed, starts a load with it, and then clears that load with a different
+    // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
+    //
+    // #1 is always an error. At best the caller is leaking memory briefly in something like an
+    // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
+    // time if they do something like reference the Activity RequestManager in a long lived
+    // background thread or task.
+    //
+    // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
+    // the corresponding Activity or Fragment is destroyed because retaining any reference to the
+    // RequestManager leaks memory. It's possible that there's some brief period of time during or
+    // immediately after onDestroy where this is reasonable, but I can't think of why.
+    if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
+      Request request = target.getRequest();
+      target.setRequest(null);
+      request.clear();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
index 0cbde46d1..f88316ca8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -83,14 +83,14 @@ public boolean queueIdle() {
 
   private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
     @Synthetic final Key key;
-    @Synthetic final EngineResource<?> resource;
+    @Synthetic final Resource<?> resource;
     @Synthetic final boolean isCacheable;
 
     ResourceWeakReference(
         Key key, EngineResource<?> r, ReferenceQueue<? super EngineResource<?>> q) {
       super(r, q);
       this.key = Preconditions.checkNotNull(key);
-      this.resource = Preconditions.checkNotNull(r);
+      this.resource = Preconditions.checkNotNull(r.getResource());
       isCacheable = r.isCacheable();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index f735e3618..970a9b663 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Util;
 import java.util.ArrayList;
@@ -49,18 +50,28 @@ void addRequest(Request request) {
 
   /**
    * Stops tracking the given request, clears, and recycles it, and returns {@code true} if the
-   * request was removed or {@code false} if the request was not found.
+   * request was removed or invalid or {@code false} if the request was not found.
    */
-  public boolean clearRemoveAndRecycle(Request request) {
-    if (request == null) {
-      return false;
+  public boolean clearRemoveAndRecycle(@Nullable Request request) {
+    // It's safe for us to recycle because this is only called when the user is explicitly clearing
+    // a Target so we know that there are no remaining references to the Request.
+    return clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ true);
+  }
+
+  private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean isSafeToRecycle) {
+     if (request == null) {
+       // If the Request is null, the request is already cleared and we don't need to search further
+       // for its owner.
+      return true;
     }
     boolean isOwnedByUs = requests.remove(request);
     // Avoid short circuiting.
     isOwnedByUs = pendingRequests.remove(request) || isOwnedByUs;
     if (isOwnedByUs) {
       request.clear();
-      request.recycle();
+      if (isSafeToRecycle) {
+        request.recycle();
+      }
     }
     return isOwnedByUs;
   }
@@ -105,7 +116,9 @@ public void resumeRequests() {
    */
   public void clearRequests() {
     for (Request request : Util.getSnapshot(requests)) {
-      clearRemoveAndRecycle(request);
+      // It's unsafe to recycle the Request here because we don't know who might else have a
+      // reference to it.
+      clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ false);
     }
     pendingRequests.clear();
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 64dd276db..b98f710f1 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
@@ -46,7 +45,7 @@ public void onDestroy() {
   }
 
   public List<Target<?>> getAll() {
-    return new ArrayList<>(targets);
+    return Util.getSnapshot(targets);
   }
 
   public void clear() {
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index f33cc4cf7..2b2279d4d 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -307,6 +307,7 @@ private void assertNotCallingCallbacks() {
   public void clear() {
     Util.assertMainThread();
     assertNotCallingCallbacks();
+    stateVerifier.throwIfRecycled();
     if (status == Status.CLEARED) {
       return;
     }
@@ -459,6 +460,13 @@ public void onSizeReady(int width, int height) {
         requestOptions.getUseAnimationPool(),
         requestOptions.getOnlyRetrieveFromCache(),
         this);
+
+    // This is a hack that's only useful for testing right now where loads complete synchronously
+    // even though under any executor running on any thread but the main thread, the load would
+    // have completed asynchronously.
+    if (status != Status.RUNNING) {
+      loadStatus = null;
+    }
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index ed5224809..3eccad550 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -170,14 +170,19 @@ public static boolean isOnBackgroundThread() {
    * Returns a copy of the given list that is safe to iterate over and perform actions that may
    * modify the original list.
    *
-   * <p> See #303 and #375. </p>
+   * <p>See #303, #375, #322, #2262.
    */
+  @SuppressWarnings("UseBulkOperation")
   public static <T> List<T> getSnapshot(Collection<T> other) {
-    // toArray creates a new ArrayList internally and this way we can guarantee entries will not
-    // be null. See #322.
-    List<T> result = new ArrayList<T>(other.size());
+    // toArray creates a new ArrayList internally and does not guarantee that the values it contains
+    // are non-null. Collections.addAll in ArrayList uses toArray internally and therefore also
+    // doesn't guarantee that entries are non-null. WeakHashMap's iterator does avoid returning null
+    // and is therefore safe to use. See #322, #2262.
+    List<T> result = new ArrayList<>(other.size());
     for (T item : other) {
-      result.add(item);
+      if (item != null) {
+        result.add(item);
+      }
     }
     return result;
   }
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 77eb57a78..2bf0e4067 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -51,10 +51,12 @@
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.testutil.TestResourceUtil;
 import java.io.ByteArrayInputStream;
@@ -66,8 +68,8 @@
 import java.nio.ByteBuffer;
 import java.util.HashMap;
 import java.util.Map;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -96,6 +98,8 @@
 @SuppressWarnings("unchecked")
 public class GlideTest {
 
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   @SuppressWarnings("rawtypes")
   @Mock private Target target;
   @Mock private DiskCache.Factory diskCacheFactory;
@@ -153,11 +157,6 @@ public Boolean answer(InvocationOnMock invocation) throws Throwable {
     requestManager.resumeRequests();
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
   @Test
   public void testCanSetMemoryCategory() {
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
@@ -679,6 +678,23 @@ public void testByteData() {
     requestManager.load(data).into(target);
   }
 
+  @Test
+  public void removeFromManagers_afterRequestManagerRemoved_clearsRequest() {
+    target = requestManager.load(mockUri("content://uri")).into(new SimpleTarget<Drawable>() {
+      @Override
+      public void onResourceReady(Drawable resource, Transition<? super Drawable> transition) {
+        // Do nothing.
+      }
+    });
+    Request request = target.getRequest();
+
+    requestManager.onDestroy();
+    requestManager.clear(target);
+
+    assertThat(target.getRequest()).isNull();
+    assertThat(request.isCancelled()).isTrue();
+  }
+
   @Test
   public void testClone() throws IOException {
     Target<Drawable> firstTarget = mock(Target.class);
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index 4a9d72750..0f39a806f 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -14,8 +14,9 @@
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.BackgroundUtil;
-import org.junit.After;
+import com.bumptech.glide.tests.TearDownGlide;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -28,6 +29,8 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RequestBuilderTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   @Mock GlideContext glideContext;
   @Mock RequestManager requestManager;
   private Glide glide;
@@ -40,11 +43,6 @@ public void setUp() {
     context = RuntimeEnvironment.application;
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
     new RequestBuilder<>(null /*context*/, requestManager, Object.class, context);
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
index 0091ddb8d..9d4e521a5 100644
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -10,16 +10,27 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.content.Context;
+import android.graphics.drawable.Drawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
+import com.bumptech.glide.request.target.BaseTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
+import java.io.File;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -33,18 +44,22 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerTest {
-  @Mock Lifecycle lifecycle = mock(Lifecycle.class);
-  @Mock RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private Lifecycle lifecycle = mock(Lifecycle.class);
+  @Mock private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
 
   private RequestManager manager;
   private ConnectivityMonitor connectivityMonitor;
   private RequestTracker requestTracker;
   private ConnectivityListener connectivityListener;
+  private Application context;
+  private BaseTarget<Drawable> target;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    Context context = RuntimeEnvironment.application;
+    context = RuntimeEnvironment.application;
     connectivityMonitor = mock(ConnectivityMonitor.class);
     ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
     when(factory.build(isA(Context.class), isA(ConnectivityMonitor.ConnectivityListener.class)))
@@ -55,6 +70,22 @@ public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable
             return connectivityMonitor;
           }
         });
+
+     target = new BaseTarget<Drawable>() {
+       @Override
+       public void onResourceReady(Drawable resource, Transition<? super Drawable> transition) {
+         // Empty.
+       }
+       @Override
+       public void getSize(SizeReadyCallback cb) {
+         // Empty.
+       }
+       @Override
+       public void removeCallback(SizeReadyCallback cb) {
+         // Empty.
+       }
+    };
+
     requestTracker = mock(RequestTracker.class);
     manager =
         new RequestManager(
@@ -153,4 +184,78 @@ public void testDelegatesIsPausedToRequestTracker() {
     when(requestTracker.isPaused()).thenReturn(false);
     assertFalse(manager.isPaused());
   }
+
+  @Test
+  public void clear_withRequestStartedInSiblingManager_doesNotThrow() {
+    final RequestManager child1 = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+     final RequestManager child2 = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return new HashSet<>(java.util.Arrays.asList(child1, child2));
+          }
+        }, context);
+
+    File file = new File("fake");
+    child1.load(file).into(target);
+    child2.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInChildManager_doesNotThrow() {
+    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.singleton(child);
+          }
+        }, context);
+
+    File file = new File("fake");
+    child.load(file).into(target);
+    parent.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInParentManager_doesNotThrow() {
+    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.singleton(child);
+          }
+        }, context);
+
+    File file = new File("fake");
+
+    parent.load(file).into(target);
+    child.clear(target);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index 29b03a1ec..5fe54bda6 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -9,6 +9,8 @@
 import java.io.File;
 import java.io.IOException;
 import java.security.MessageDigest;
+import org.apache.commons.io.FileUtils;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,15 +24,25 @@
   private DiskLruCacheWrapper cache;
   private byte[] data;
   private StringKey key;
+  private File dir;
 
   @Before
   public void setUp() {
-    File dir = RuntimeEnvironment.application.getCacheDir();
+    dir = RuntimeEnvironment.application.getCacheDir();
     cache = new DiskLruCacheWrapper(dir, 10 * 1024 * 1024);
     key = new StringKey("test" + Math.random());
     data = new byte[] { 1, 2, 3, 4, 5, 6 };
   }
 
+  @After
+  public void tearDown() {
+    try {
+      FileUtils.deleteDirectory(dir);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
   @Test
   public void testCanInsertAndGet() throws IOException {
     cache.put(key, new DiskCache.Writer() {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 6a98c4297..889a9a08c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -27,11 +27,12 @@
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
@@ -44,6 +45,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameLoaderTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
 
   @Mock GifFrameLoader.FrameCallback callback;
   @Mock GifDecoder gifDecoder;
@@ -70,11 +72,6 @@ public void setUp() {
     loader = createGifFrameLoader(handler);
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
   @NonNull
   private GifFrameLoader createGifFrameLoader(Handler handler) {
     Glide glide = getGlideSingleton();
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index 97884942a..2cb52bb76 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -20,9 +20,11 @@
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
@@ -36,6 +38,8 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerRetrieverTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   private static final String PARENT_TAG = "parent";
   private RetrieverHarness[] harnesses;
   private RequestManagerRetriever retriever;
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
index 889cd2ba2..10bf21e27 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -15,6 +15,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -24,27 +25,40 @@
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
     tracker = new RequestTracker();
   }
 
   @Test
-  public void testClearsAddedRequestsOnDestroy() {
+  public void clearRequests_doesNotRecycleRequests() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
 
     tracker.clearRequests();
 
     verify(request).clear();
-    verify(request).recycle();
+    verify(request, never()).recycle();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withRequestPreviouslyClearedInClearRequests_doesNothing() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+
+    tracker.clearRequests();
+    tracker.clearRemoveAndRecycle(request);
+
+    verify(request).clear();
+    verify(request, never()).recycle();
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsFalse() {
-    assertThat(tracker.clearRemoveAndRecycle(null)).isFalse();
+  public void clearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsTrue() {
+    assertThat(tracker.clearRemoveAndRecycle(null)).isTrue();
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
+  public void clearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
     Request request = mock(Request.class);
 
     assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
@@ -54,7 +68,7 @@ public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturns
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
+  public void clearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
 
@@ -64,7 +78,7 @@ public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturn
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+  public void clearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
     tracker.clearRemoveAndRecycle(request);
diff --git a/library/src/test/java/com/bumptech/glide/tests/TearDownGlide.java b/library/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
new file mode 100644
index 000000000..c7eded785
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
@@ -0,0 +1,49 @@
+package com.bumptech.glide.tests;
+
+import android.content.Context;
+import com.bumptech.glide.Glide;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import org.robolectric.RuntimeEnvironment;
+
+/**
+ * Clears out Glide's disk cache and the Glide singleton after every test method.
+ */
+public final class TearDownGlide implements TestRule {
+  private static final long TIMEOUT = 500;
+  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        base.evaluate();
+        tearDownGlide();
+      }
+    };
+  }
+
+  private void tearDownGlide() {
+    final Context context = RuntimeEnvironment.application;
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    try {
+      executor.submit(new Runnable() {
+        @Override
+        public void run() {
+          Glide.get(context).clearDiskCache();
+        }
+      }).get(TIMEOUT, TIMEOUT_UNIT);
+    } catch (InterruptedException | ExecutionException | TimeoutException e) {
+      throw new RuntimeException(e);
+    }
+    executor.shutdown();
+    Glide.tearDown();
+  }
+}
