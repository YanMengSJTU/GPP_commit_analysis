diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index c7f7e4562..1104f2281 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -19,6 +19,7 @@
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
 import android.view.View;
+
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -79,6 +80,7 @@
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
+
 import java.io.File;
 import java.io.InputStream;
 import java.lang.reflect.InvocationTargetException;
@@ -97,734 +99,734 @@
  * {@link com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
  */
 public class Glide implements ComponentCallbacks2 {
-  private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
-  private static final String TAG = "Glide";
-  private static volatile Glide glide;
-  private static volatile boolean isInitializing;
-
-  private final Engine engine;
-  private final BitmapPool bitmapPool;
-  private final MemoryCache memoryCache;
-  private final BitmapPreFiller bitmapPreFiller;
-  private final GlideContext glideContext;
-  private final Registry registry;
-  private final ArrayPool arrayPool;
-  private final RequestManagerRetriever requestManagerRetriever;
-  private final ConnectivityMonitorFactory connectivityMonitorFactory;
-  private final List<RequestManager> managers = new ArrayList<>();
-  private MemoryCategory memoryCategory = MemoryCategory.NORMAL;
-
-  /**
-   * Returns a directory with a default name in the private cache directory of the application to
-   * use to store retrieved media and thumbnails.
-   *
-   * @param context A context.
-   * @see #getPhotoCacheDir(android.content.Context, String)
-   */
-  @Nullable
-  public static File getPhotoCacheDir(@NonNull Context context) {
-    return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
-  }
-
-  /**
-   * Returns a directory with the given name in the private cache directory of the application to
-   * use to store retrieved media and thumbnails.
-   *
-   * @param context   A context.
-   * @param cacheName The name of the subdirectory in which to store the cache.
-   * @see #getPhotoCacheDir(android.content.Context)
-   */
-  @Nullable
-  public static File getPhotoCacheDir(@NonNull Context context, @NonNull String cacheName) {
-    File cacheDir = context.getCacheDir();
-    if (cacheDir != null) {
-      File result = new File(cacheDir, cacheName);
-      if (!result.mkdirs() && (!result.exists() || !result.isDirectory())) {
-        // File wasn't able to create a directory, or the result exists but not a directory
+    private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
+    private static final String TAG = "Glide";
+    private static volatile Glide glide;
+    private static volatile boolean isInitializing;
+
+    private final Engine engine;
+    private final BitmapPool bitmapPool;
+    private final MemoryCache memoryCache;
+    private final BitmapPreFiller bitmapPreFiller;
+    private final GlideContext glideContext;
+    private final Registry registry;
+    private final ArrayPool arrayPool;
+    private final RequestManagerRetriever requestManagerRetriever;
+    private final ConnectivityMonitorFactory connectivityMonitorFactory;
+    private final List<RequestManager> managers = new ArrayList<>();
+    private MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+
+    /**
+     * Returns a directory with a default name in the private cache directory of the application to
+     * use to store retrieved media and thumbnails.
+     *
+     * @param context A context.
+     * @see #getPhotoCacheDir(android.content.Context, String)
+     */
+    @Nullable
+    public static File getPhotoCacheDir(@NonNull Context context) {
+        return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
+    }
+
+    /**
+     * Returns a directory with the given name in the private cache directory of the application to
+     * use to store retrieved media and thumbnails.
+     *
+     * @param context   A context.
+     * @param cacheName The name of the subdirectory in which to store the cache.
+     * @see #getPhotoCacheDir(android.content.Context)
+     */
+    @Nullable
+    public static File getPhotoCacheDir(@NonNull Context context, @NonNull String cacheName) {
+        File cacheDir = context.getCacheDir();
+        if (cacheDir != null) {
+            File result = new File(cacheDir, cacheName);
+            if (!result.mkdirs() && (!result.exists() || !result.isDirectory())) {
+                // File wasn't able to create a directory, or the result exists but not a directory
+                return null;
+            }
+            return result;
+        }
+        if (Log.isLoggable(TAG, Log.ERROR)) {
+            Log.e(TAG, "default disk cache dir is null");
+        }
         return null;
-      }
-      return result;
-    }
-    if (Log.isLoggable(TAG, Log.ERROR)) {
-      Log.e(TAG, "default disk cache dir is null");
-    }
-    return null;
-  }
-
-  /**
-   * Get the singleton.
-   *
-   * @return the singleton
-   */
-  @NonNull
-  public static Glide get(@NonNull Context context) {
-    if (glide == null) {
-      synchronized (Glide.class) {
+    }
+
+    /**
+     * Get the singleton.
+     *
+     * @return the singleton
+     */
+    @NonNull
+    public static Glide get(@NonNull Context context) {
         if (glide == null) {
-          checkAndInitializeGlide(context);
+            synchronized (Glide.class) {
+                if (glide == null) {
+                    checkAndInitializeGlide(context);
+                }
+            }
+        }
+
+        return glide;
+    }
+
+    private static void checkAndInitializeGlide(@NonNull Context context) {
+        // In the thread running initGlide(), one or more classes may call Glide.get(context).
+        // Without this check, those calls could trigger infinite recursion.
+        if (isInitializing) {
+            throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),"
+                    + " use the provided Glide instance instead");
+        }
+        isInitializing = true;
+        initializeGlide(context);
+        isInitializing = false;
+    }
+
+    /**
+     * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with
+     * Glide's generated API.
+     * <p>
+     * <p>This method will be removed in a future version of Glide.
+     */
+    @VisibleForTesting
+    @Deprecated
+    public static synchronized void init(Glide glide) {
+        if (Glide.glide != null) {
+            tearDown();
+        }
+        Glide.glide = glide;
+    }
+
+    @VisibleForTesting
+    public static synchronized void init(@NonNull Context context, @NonNull GlideBuilder builder) {
+        if (Glide.glide != null) {
+            tearDown();
+        }
+        initializeGlide(context, builder);
+    }
+
+    @VisibleForTesting
+    public static synchronized void tearDown() {
+        if (glide != null) {
+            glide.getContext()
+                    .getApplicationContext()
+                    .unregisterComponentCallbacks(glide);
+            glide.engine.shutdown();
+        }
+        glide = null;
+    }
+
+    private static void initializeGlide(@NonNull Context context) {
+        initializeGlide(context, new GlideBuilder());
+    }
+
+    @SuppressWarnings("deprecation")
+    private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
+        Context applicationContext = context.getApplicationContext();
+        GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
+        List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
+        if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
+            manifestModules = new ManifestParser(applicationContext).parse();
         }
-      }
-    }
-
-    return glide;
-  }
-
-  private static void checkAndInitializeGlide(@NonNull Context context) {
-    // In the thread running initGlide(), one or more classes may call Glide.get(context).
-    // Without this check, those calls could trigger infinite recursion.
-    if (isInitializing) {
-      throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),"
-          + " use the provided Glide instance instead");
-    }
-    isInitializing = true;
-    initializeGlide(context);
-    isInitializing = false;
-  }
-
-  /**
-   * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with
-   * Glide's generated API.
-   *
-   * <p>This method will be removed in a future version of Glide.
-   */
-  @VisibleForTesting
-  @Deprecated
-  public static synchronized void init(Glide glide) {
-    if (Glide.glide != null) {
-      tearDown();
-    }
-    Glide.glide = glide;
-  }
-
-  @VisibleForTesting
-  public static synchronized void init(@NonNull Context context, @NonNull GlideBuilder builder) {
-    if (Glide.glide != null) {
-      tearDown();
-    }
-    initializeGlide(context, builder);
-  }
-
-  @VisibleForTesting
-  public static synchronized void tearDown() {
-    if (glide != null) {
-      glide.getContext()
-          .getApplicationContext()
-          .unregisterComponentCallbacks(glide);
-      glide.engine.shutdown();
-    }
-    glide = null;
-  }
-
-  private static void initializeGlide(@NonNull Context context) {
-    initializeGlide(context, new GlideBuilder());
-  }
-
-  @SuppressWarnings("deprecation")
-  private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
-    Context applicationContext = context.getApplicationContext();
-    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
-    List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
-    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
-      manifestModules = new ManifestParser(applicationContext).parse();
-    }
-
-    if (annotationGeneratedModule != null
-        && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
-      Set<Class<?>> excludedModuleClasses =
-          annotationGeneratedModule.getExcludedModuleClasses();
-      Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
-      while (iterator.hasNext()) {
-        com.bumptech.glide.module.GlideModule current = iterator.next();
-        if (!excludedModuleClasses.contains(current.getClass())) {
-          continue;
+
+        if (annotationGeneratedModule != null
+                && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
+            Set<Class<?>> excludedModuleClasses =
+                    annotationGeneratedModule.getExcludedModuleClasses();
+            Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
+            while (iterator.hasNext()) {
+                com.bumptech.glide.module.GlideModule current = iterator.next();
+                if (!excludedModuleClasses.contains(current.getClass())) {
+                    continue;
+                }
+                if (Log.isLoggable(TAG, Log.DEBUG)) {
+                    Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);
+                }
+                iterator.remove();
+            }
         }
+
         if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);
+            for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {
+                Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
+            }
+        }
+
+        RequestManagerRetriever.RequestManagerFactory factory =
+                annotationGeneratedModule != null
+                        ? annotationGeneratedModule.getRequestManagerFactory() : null;
+        builder.setRequestManagerFactory(factory);
+        for (com.bumptech.glide.module.GlideModule module : manifestModules) {
+            module.applyOptions(applicationContext, builder);
+        }
+        if (annotationGeneratedModule != null) {
+            annotationGeneratedModule.applyOptions(applicationContext, builder);
+        }
+        Glide glide = builder.build(applicationContext);
+        for (com.bumptech.glide.module.GlideModule module : manifestModules) {
+            module.registerComponents(applicationContext, glide, glide.registry);
+        }
+        if (annotationGeneratedModule != null) {
+            annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
         }
-        iterator.remove();
-      }
-    }
-
-    if (Log.isLoggable(TAG, Log.DEBUG)) {
-      for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {
-        Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
-      }
-    }
-
-    RequestManagerRetriever.RequestManagerFactory factory =
-        annotationGeneratedModule != null
-            ? annotationGeneratedModule.getRequestManagerFactory() : null;
-    builder.setRequestManagerFactory(factory);
-    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
-      module.applyOptions(applicationContext, builder);
-    }
-    if (annotationGeneratedModule != null) {
-      annotationGeneratedModule.applyOptions(applicationContext, builder);
-    }
-    Glide glide = builder.build(applicationContext);
-    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
-      module.registerComponents(applicationContext, glide, glide.registry);
-    }
-    if (annotationGeneratedModule != null) {
-      annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
-    }
-    applicationContext.registerComponentCallbacks(glide);
-    Glide.glide = glide;
-  }
-
-  @Nullable
-  @SuppressWarnings({"unchecked", "deprecation", "TryWithIdenticalCatches"})
-  private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
-    GeneratedAppGlideModule result = null;
-    try {
-      Class<GeneratedAppGlideModule> clazz =
-          (Class<GeneratedAppGlideModule>)
-              Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
-      result = clazz.getDeclaredConstructor().newInstance();
-    } catch (ClassNotFoundException e) {
-      if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
-            + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
-            + " in your application and a @GlideModule annotated AppGlideModule implementation or"
-            + " LibraryGlideModules will be silently ignored");
-      }
-    // These exceptions can't be squashed across all versions of Android.
-    } catch (InstantiationException e) {
-      throwIncorrectGlideModule(e);
-    } catch (IllegalAccessException e) {
-      throwIncorrectGlideModule(e);
-    } catch (NoSuchMethodException e) {
-      throwIncorrectGlideModule(e);
-    } catch (InvocationTargetException e) {
-      throwIncorrectGlideModule(e);
-    }
-    return result;
-  }
-
-  private static void throwIncorrectGlideModule(Exception e) {
-    throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
-        + " If you've manually implemented this class, remove your implementation. The Annotation"
-        + " processor will generate a correct implementation.", e);
-  }
-
-  Glide(
-      @NonNull Context context,
-      @NonNull Engine engine,
-      @NonNull MemoryCache memoryCache,
-      @NonNull BitmapPool bitmapPool,
-      @NonNull ArrayPool arrayPool,
-      @NonNull RequestManagerRetriever requestManagerRetriever,
-      @NonNull ConnectivityMonitorFactory connectivityMonitorFactory,
-      int logLevel,
-      @NonNull RequestOptions defaultRequestOptions,
-      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
-    this.engine = engine;
-    this.bitmapPool = bitmapPool;
-    this.arrayPool = arrayPool;
-    this.memoryCache = memoryCache;
-    this.requestManagerRetriever = requestManagerRetriever;
-    this.connectivityMonitorFactory = connectivityMonitorFactory;
-
-    DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
-    bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
-
-    final Resources resources = context.getResources();
-
-    registry = new Registry();
-    registry.register(new DefaultImageHeaderParser());
-
-    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
-        resources.getDisplayMetrics(), bitmapPool, arrayPool);
-    ByteBufferGifDecoder byteBufferGifDecoder =
-        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
-    ResourceDecoder<ParcelFileDescriptor, Bitmap> parcelFileDescriptorVideoDecoder =
-        VideoDecoder.parcel(bitmapPool);
-    ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
-    StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
-    ResourceDrawableDecoder resourceDrawableDecoder =
-        new ResourceDrawableDecoder(context);
-    ResourceLoader.StreamFactory resourceLoaderStreamFactory =
-        new ResourceLoader.StreamFactory(resources);
-    ResourceLoader.UriFactory resourceLoaderUriFactory =
-        new ResourceLoader.UriFactory(resources);
-    ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
-        new ResourceLoader.FileDescriptorFactory(resources);
-    ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
-        new ResourceLoader.AssetFileDescriptorFactory(resources);
-    BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);
-
-    BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();
-    GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();
-
-    ContentResolver contentResolver = context.getContentResolver();
-
-    registry
-        .append(ByteBuffer.class, new ByteBufferEncoder())
-        .append(InputStream.class, new StreamEncoder(arrayPool))
+        applicationContext.registerComponentCallbacks(glide);
+        Glide.glide = glide;
+    }
+
+    @Nullable
+    @SuppressWarnings({"unchecked", "deprecation", "TryWithIdenticalCatches"})
+    private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
+        GeneratedAppGlideModule result = null;
+        try {
+            Class<GeneratedAppGlideModule> clazz =
+                    (Class<GeneratedAppGlideModule>)
+                            Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
+            result = clazz.getDeclaredConstructor().newInstance();
+        } catch (ClassNotFoundException e) {
+            if (Log.isLoggable(TAG, Log.WARN)) {
+                Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
+                        + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
+                        + " in your application and a @GlideModule annotated AppGlideModule implementation or"
+                        + " LibraryGlideModules will be silently ignored");
+            }
+            // These exceptions can't be squashed across all versions of Android.
+        } catch (InstantiationException e) {
+            throwIncorrectGlideModule(e);
+        } catch (IllegalAccessException e) {
+            throwIncorrectGlideModule(e);
+        } catch (NoSuchMethodException e) {
+            throwIncorrectGlideModule(e);
+        } catch (InvocationTargetException e) {
+            throwIncorrectGlideModule(e);
+        }
+        return result;
+    }
+
+    private static void throwIncorrectGlideModule(Exception e) {
+        throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+                + " If you've manually implemented this class, remove your implementation. The Annotation"
+                + " processor will generate a correct implementation.", e);
+    }
+
+    Glide(
+            @NonNull Context context,
+            @NonNull Engine engine,
+            @NonNull MemoryCache memoryCache,
+            @NonNull BitmapPool bitmapPool,
+            @NonNull ArrayPool arrayPool,
+            @NonNull RequestManagerRetriever requestManagerRetriever,
+            @NonNull ConnectivityMonitorFactory connectivityMonitorFactory,
+            int logLevel,
+            @NonNull RequestOptions defaultRequestOptions,
+            @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
+        this.engine = engine;
+        this.bitmapPool = bitmapPool;
+        this.arrayPool = arrayPool;
+        this.memoryCache = memoryCache;
+        this.requestManagerRetriever = requestManagerRetriever;
+        this.connectivityMonitorFactory = connectivityMonitorFactory;
+
+        DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
+        bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
+
+        final Resources resources = context.getResources();
+
+        registry = new Registry();
+        registry.register(new DefaultImageHeaderParser());
+
+        Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
+                resources.getDisplayMetrics(), bitmapPool, arrayPool);
+        ByteBufferGifDecoder byteBufferGifDecoder =
+                new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+        ResourceDecoder<ParcelFileDescriptor, Bitmap> parcelFileDescriptorVideoDecoder =
+                VideoDecoder.parcel(bitmapPool);
+        ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
+        StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
+        ResourceDrawableDecoder resourceDrawableDecoder =
+                new ResourceDrawableDecoder(context);
+        ResourceLoader.StreamFactory resourceLoaderStreamFactory =
+                new ResourceLoader.StreamFactory(resources);
+        ResourceLoader.UriFactory resourceLoaderUriFactory =
+                new ResourceLoader.UriFactory(resources);
+        ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
+                new ResourceLoader.FileDescriptorFactory(resources);
+        ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
+                new ResourceLoader.AssetFileDescriptorFactory(resources);
+        BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);
+
+        BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();
+        GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();
+
+        ContentResolver contentResolver = context.getContentResolver();
+
+        registry
+                .append(ByteBuffer.class, new ByteBufferEncoder())
+                .append(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
-        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)
-        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)
-        .append(
-            Registry.BUCKET_BITMAP,
-            ParcelFileDescriptor.class,
-            Bitmap.class,
-            parcelFileDescriptorVideoDecoder)
-        .append(
-            Registry.BUCKET_BITMAP,
-            AssetFileDescriptor.class,
-            Bitmap.class,
-            VideoDecoder.asset(bitmapPool))
-        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
-        .append(
-            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
-        .append(Bitmap.class, bitmapEncoder)
+                .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)
+                .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)
+                .append(
+                        Registry.BUCKET_BITMAP,
+                        ParcelFileDescriptor.class,
+                        Bitmap.class,
+                        parcelFileDescriptorVideoDecoder)
+                .append(
+                        Registry.BUCKET_BITMAP,
+                        AssetFileDescriptor.class,
+                        Bitmap.class,
+                        VideoDecoder.asset(bitmapPool))
+                .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
+                .append(
+                        Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
+                .append(Bitmap.class, bitmapEncoder)
         /* BitmapDrawables */
-        .append(
-            Registry.BUCKET_BITMAP_DRAWABLE,
-            ByteBuffer.class,
-            BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, byteBufferBitmapDecoder))
-        .append(
-            Registry.BUCKET_BITMAP_DRAWABLE,
-            InputStream.class,
-            BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, streamBitmapDecoder))
-        .append(
-            Registry.BUCKET_BITMAP_DRAWABLE,
-            ParcelFileDescriptor.class,
-            BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, parcelFileDescriptorVideoDecoder))
-        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
+                .append(
+                        Registry.BUCKET_BITMAP_DRAWABLE,
+                        ByteBuffer.class,
+                        BitmapDrawable.class,
+                        new BitmapDrawableDecoder<>(resources, byteBufferBitmapDecoder))
+                .append(
+                        Registry.BUCKET_BITMAP_DRAWABLE,
+                        InputStream.class,
+                        BitmapDrawable.class,
+                        new BitmapDrawableDecoder<>(resources, streamBitmapDecoder))
+                .append(
+                        Registry.BUCKET_BITMAP_DRAWABLE,
+                        ParcelFileDescriptor.class,
+                        BitmapDrawable.class,
+                        new BitmapDrawableDecoder<>(resources, parcelFileDescriptorVideoDecoder))
+                .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
         /* GIFs */
-        .append(
-            Registry.BUCKET_GIF,
-            InputStream.class,
-            GifDrawable.class,
-            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
-        .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
-        .append(GifDrawable.class, new GifDrawableEncoder())
+                .append(
+                        Registry.BUCKET_GIF,
+                        InputStream.class,
+                        GifDrawable.class,
+                        new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
+                .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
+                .append(GifDrawable.class, new GifDrawableEncoder())
         /* GIF Frames */
-        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
-        .append(
-            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance())
-        .append(
-            Registry.BUCKET_BITMAP,
-            GifDecoder.class,
-            Bitmap.class,
-            new GifFrameResourceDecoder(bitmapPool))
+                // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
+                .append(
+                        GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance())
+                .append(
+                        Registry.BUCKET_BITMAP,
+                        GifDecoder.class,
+                        Bitmap.class,
+                        new GifFrameResourceDecoder(bitmapPool))
         /* Drawables */
-        .append(Uri.class, Drawable.class, resourceDrawableDecoder)
-        .append(
-            Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))
+                .append(Uri.class, Drawable.class, resourceDrawableDecoder)
+                .append(
+                        Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))
         /* Files */
-        .register(new ByteBufferRewinder.Factory())
-        .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
-        .append(File.class, InputStream.class, new FileLoader.StreamFactory())
-        .append(File.class, File.class, new FileDecoder())
-        .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
-        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
-        .append(File.class, File.class, UnitModelLoader.Factory.<File>getInstance())
+                .register(new ByteBufferRewinder.Factory())
+                .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
+                .append(File.class, InputStream.class, new FileLoader.StreamFactory())
+                .append(File.class, File.class, new FileDecoder())
+                .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
+                // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
+                .append(File.class, File.class, UnitModelLoader.Factory.<File>getInstance())
         /* Models */
-        .register(new InputStreamRewinder.Factory(arrayPool))
-        .append(int.class, InputStream.class, resourceLoaderStreamFactory)
-        .append(
-            int.class,
-            ParcelFileDescriptor.class,
-            resourceLoaderFileDescriptorFactory)
-        .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
-        .append(
-            Integer.class,
-            ParcelFileDescriptor.class,
-            resourceLoaderFileDescriptorFactory)
-        .append(Integer.class, Uri.class, resourceLoaderUriFactory)
-        .append(
-            int.class,
-            AssetFileDescriptor.class,
-            resourceLoaderAssetFileDescriptorFactory)
-        .append(
-            Integer.class,
-            AssetFileDescriptor.class,
-            resourceLoaderAssetFileDescriptorFactory)
-        .append(int.class, Uri.class, resourceLoaderUriFactory)
-        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
-        .append(Uri.class, InputStream.class, new DataUrlLoader.StreamFactory<Uri>())
-        .append(String.class, InputStream.class, new StringLoader.StreamFactory())
-        .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
-        .append(
-            String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
-        .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
-        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
-        .append(
-            Uri.class,
-            ParcelFileDescriptor.class,
-            new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
-        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
-        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
-        .append(
-            Uri.class,
-            InputStream.class,
-            new UriLoader.StreamFactory(contentResolver))
-        .append(
-            Uri.class,
-            ParcelFileDescriptor.class,
-             new UriLoader.FileDescriptorFactory(contentResolver))
-        .append(
-            Uri.class,
-            AssetFileDescriptor.class,
-            new UriLoader.AssetFileDescriptorFactory(contentResolver))
-        .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
-        .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
-        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
-        .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
-        .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
-        .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
-        .append(Uri.class, Uri.class, UnitModelLoader.Factory.<Uri>getInstance())
-        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance())
-        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())
+                .register(new InputStreamRewinder.Factory(arrayPool))
+                .append(int.class, InputStream.class, resourceLoaderStreamFactory)
+                .append(
+                        int.class,
+                        ParcelFileDescriptor.class,
+                        resourceLoaderFileDescriptorFactory)
+                .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
+                .append(
+                        Integer.class,
+                        ParcelFileDescriptor.class,
+                        resourceLoaderFileDescriptorFactory)
+                .append(Integer.class, Uri.class, resourceLoaderUriFactory)
+                .append(
+                        int.class,
+                        AssetFileDescriptor.class,
+                        resourceLoaderAssetFileDescriptorFactory)
+                .append(
+                        Integer.class,
+                        AssetFileDescriptor.class,
+                        resourceLoaderAssetFileDescriptorFactory)
+                .append(int.class, Uri.class, resourceLoaderUriFactory)
+                .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
+                .append(Uri.class, InputStream.class, new DataUrlLoader.StreamFactory<Uri>())
+                .append(String.class, InputStream.class, new StringLoader.StreamFactory())
+                .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
+                .append(
+                        String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
+                .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
+                .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
+                .append(
+                        Uri.class,
+                        ParcelFileDescriptor.class,
+                        new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+                .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
+                .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
+                .append(
+                        Uri.class,
+                        InputStream.class,
+                        new UriLoader.StreamFactory(contentResolver))
+                .append(
+                        Uri.class,
+                        ParcelFileDescriptor.class,
+                        new UriLoader.FileDescriptorFactory(contentResolver))
+                .append(
+                        Uri.class,
+                        AssetFileDescriptor.class,
+                        new UriLoader.AssetFileDescriptorFactory(contentResolver))
+                .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
+                .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
+                .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
+                .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
+                .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
+                .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
+                .append(Uri.class, Uri.class, UnitModelLoader.Factory.<Uri>getInstance())
+                .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance())
+                .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())
         /* Transcoders */
-        .register(
-            Bitmap.class,
-            BitmapDrawable.class,
-            new BitmapDrawableTranscoder(resources))
-        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)
-        .register(
-            Drawable.class,
-            byte[].class,
-            new DrawableBytesTranscoder(
-                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))
-        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);
-
-    ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
-    glideContext =
-        new GlideContext(
-            context,
-            arrayPool,
-            registry,
-            imageViewTargetFactory,
-            defaultRequestOptions,
-            defaultTransitionOptions,
-            engine,
-            logLevel);
-  }
-
-  /**
-   * Returns the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} used to
-   * temporarily store {@link android.graphics.Bitmap}s so they can be reused to avoid garbage
-   * collections.
-   *
-   * <p> Note - Using this pool directly can lead to undefined behavior and strange drawing errors.
-   * Any {@link android.graphics.Bitmap} added to the pool must not be currently in use in any other
-   * part of the application. Any {@link android.graphics.Bitmap} added to the pool must be removed
-   * from the pool before it is added a second time. </p>
-   *
-   * <p> Note - To make effective use of the pool, any {@link android.graphics.Bitmap} removed from
-   * the pool must eventually be re-added. Otherwise the pool will eventually empty and will not
-   * serve any useful purpose. </p>
-   *
-   * <p> The primary reason this object is exposed is for use in custom
-   * {@link com.bumptech.glide.load.ResourceDecoder}s and
-   * {@link com.bumptech.glide.load.Transformation}s. Use outside of these classes is not generally
-   * recommended. </p>
-   */
-  @NonNull
-  public BitmapPool getBitmapPool() {
-    return bitmapPool;
-  }
-
-  @NonNull
-  public ArrayPool getArrayPool() {
-    return arrayPool;
-  }
-
-  /**
-   * @return The context associated with this instance.
-   */
-  @NonNull
-  public Context getContext() {
-    return glideContext.getBaseContext();
-  }
-
-  ConnectivityMonitorFactory getConnectivityMonitorFactory() {
-    return connectivityMonitorFactory;
-  }
-
-  @NonNull
-  GlideContext getGlideContext() {
-    return glideContext;
-  }
-
-  /**
-   * Pre-fills the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} using the given
-   * sizes.
-   *
-   * <p> Enough Bitmaps are added to completely fill the pool, so most or all of the Bitmaps
-   * currently in the pool will be evicted. Bitmaps are allocated according to the weights of the
-   * given sizes, where each size gets (weight / prefillWeightSum) percent of the pool to fill.
-   * </p>
-   *
-   * <p> Note - Pre-filling is done asynchronously using and
-   * {@link android.os.MessageQueue.IdleHandler}. Any currently running pre-fill will be cancelled
-   * and replaced by a call to this method. </p>
-   *
-   * <p> This method should be used with caution, overly aggressive pre-filling is substantially
-   * worse than not pre-filling at all. Pre-filling should only be started in onCreate to avoid
-   * constantly clearing and re-filling the
-   * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}. Rotation should be carefully
-   * considered as well. It may be worth calling this method only when no saved instance state
-   * exists so that pre-filling only happens when the Activity is first created, rather than on
-   * every rotation. </p>
-   *
-   * @param bitmapAttributeBuilders The list of
-   * {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
-   * individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
-   */
-  @SuppressWarnings("unused") // Public API
-  public void preFillBitmapPool(@NonNull PreFillType.Builder... bitmapAttributeBuilders) {
-    bitmapPreFiller.preFill(bitmapAttributeBuilders);
-  }
-
-  /**
-   * Clears as much memory as possible.
-   *
-   * @see android.content.ComponentCallbacks#onLowMemory()
-   * @see android.content.ComponentCallbacks2#onLowMemory()
-   */
-  public void clearMemory() {
-    // Engine asserts this anyway when removing resources, fail faster and consistently
-    Util.assertMainThread();
-    // memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687.
-    memoryCache.clearMemory();
-    bitmapPool.clearMemory();
-    arrayPool.clearMemory();
-  }
-
-  /**
-   * Clears some memory with the exact amount depending on the given level.
-   *
-   * @see android.content.ComponentCallbacks2#onTrimMemory(int)
-   */
-  public void trimMemory(int level) {
-    // Engine asserts this anyway when removing resources, fail faster and consistently
-    Util.assertMainThread();
-    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
-    memoryCache.trimMemory(level);
-    bitmapPool.trimMemory(level);
-    arrayPool.trimMemory(level);
-  }
-
-  /**
-   * Clears disk cache.
-   *
-   * <p>
-   *     This method should always be called on a background thread, since it is a blocking call.
-   * </p>
-   */
-  // Public API.
-  @SuppressWarnings({"unused", "WeakerAccess"})
-  public void clearDiskCache() {
-    Util.assertBackgroundThread();
-    engine.clearDiskCache();
-  }
-
-  /**
-   * Internal method.
-   */
-  @NonNull
-  public RequestManagerRetriever getRequestManagerRetriever() {
-    return requestManagerRetriever;
-  }
-
-  /**
-   * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
-   *
-   * <p> The default {@link MemoryCategory} is {@link MemoryCategory#NORMAL}.
-   * {@link MemoryCategory#HIGH} increases Glide's maximum memory usage by up to 50% and
-   * {@link MemoryCategory#LOW} decreases Glide's maximum memory usage by 50%. This method should be
-   * used to temporarily increase or decrease memory usage for a single Activity or part of the app.
-   * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want
-   * to change the default. </p>
-   *
-   * @return the previous MemoryCategory used by Glide.
-   */
-  @SuppressWarnings("WeakerAccess") // Public API
-  @NonNull
-  public MemoryCategory setMemoryCategory(@NonNull MemoryCategory memoryCategory) {
-    // Engine asserts this anyway when removing resources, fail faster and consistently
-    Util.assertMainThread();
-    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
-    memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
-    bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
-    MemoryCategory oldCategory = this.memoryCategory;
-    this.memoryCategory = memoryCategory;
-    return oldCategory;
-  }
-
-  @NonNull
-  private static RequestManagerRetriever getRetriever(@Nullable Context context) {
-    // Context could be null for other reasons (ie the user passes in null), but in practice it will
-    // only occur due to errors with the Fragment lifecycle.
-    Preconditions.checkNotNull(
-        context,
-        "You cannot start a load on a not yet attached View or a Fragment where getActivity() "
-            + "returns null (which usually occurs when getActivity() is called before the Fragment "
-            + "is attached or after the Fragment is destroyed).");
-    return Glide.get(context).getRequestManagerRetriever();
-  }
-
-  /**
-   * Begin a load with Glide by passing in a context.
-   *
-   * <p> Any requests started using a context will only have the application level options applied
-   * and will not be started or stopped based on lifecycle events. In general, loads should be
-   * started at the level the result will be used in. If the resource will be used in a view in a
-   * child fragment, the load should be started with {@link #with(android.app.Fragment)}} using that
-   * child fragment. Similarly, if the resource will be used in a view in the parent fragment, the
-   * load should be started with {@link #with(android.app.Fragment)} using the parent fragment. In
-   * the same vein, if the resource will be used in a view in an activity, the load should be
-   * started with {@link #with(android.app.Activity)}}. </p>
-   *
-   * <p> This method is appropriate for resources that will be used outside of the normal fragment
-   * or activity lifecycle (For example in services, or for notification thumbnails). </p>
-   *
-   * @param context Any context, will not be retained.
-   * @return A RequestManager for the top level application that can be used to start a load.
-   * @see #with(android.app.Activity)
-   * @see #with(android.app.Fragment)
-   * @see #with(android.support.v4.app.Fragment)
-   * @see #with(android.support.v4.app.FragmentActivity)
-   */
-  @NonNull
-  public static RequestManager with(@NonNull Context context) {
-    return getRetriever(context).get(context);
-  }
-
-  /**
-   * Begin a load with Glide that will be tied to the given {@link android.app.Activity}'s lifecycle
-   * and that uses the given {@link Activity}'s default options.
-   *
-   * @param activity The activity to use.
-   * @return A RequestManager for the given activity that can be used to start a load.
-   */
-  @NonNull
-  public static RequestManager with(@NonNull Activity activity) {
-    return getRetriever(activity).get(activity);
-  }
-
-  /**
-   * Begin a load with Glide that will tied to the give
-   * {@link android.support.v4.app.FragmentActivity}'s lifecycle and that uses the given
-   * {@link android.support.v4.app.FragmentActivity}'s default options.
-   *
-   * @param activity The activity to use.
-   * @return A RequestManager for the given FragmentActivity that can be used to start a load.
-   */
-  @NonNull
-  public static RequestManager with(@NonNull FragmentActivity activity) {
-    return getRetriever(activity).get(activity);
-  }
-
-  /**
-   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
-   * and that uses the given {@link android.app.Fragment}'s default options.
-   *
-   * @param fragment The fragment to use.
-   * @return A RequestManager for the given Fragment that can be used to start a load.
-   */
-  @NonNull
-  public static RequestManager with(@NonNull android.app.Fragment fragment) {
-    return getRetriever(fragment.getActivity()).get(fragment);
-  }
-
-  /**
-   * Begin a load with Glide that will be tied to the given
-   * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
-   * {@link android.support.v4.app.Fragment}'s default options.
-   *
-   * @param fragment The fragment to use.
-   * @return A RequestManager for the given Fragment that can be used to start a load.
-   */
-  @NonNull
-  public static RequestManager with(@NonNull Fragment fragment) {
-    return getRetriever(fragment.getActivity()).get(fragment);
-  }
-
-  /**
-   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},
-   * {@link android.app.Fragment}, or {@link Activity} that contains the View.
-   *
-   * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View
-   * is a child of the View returned by the {@link Fragment#getView()}} method.
-   *
-   * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment
-   * variants unless you're loading in a View subclass.
-   *
-   * <p>This method may be inefficient aways and is definitely inefficient for large hierarchies.
-   * Consider memoizing the result after the View is attached or again, prefer the Activity and
-   * Fragment variants whenever possible.
-   *
-   * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,
-   * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider
-   * avoiding entirely or using the {@link Fragment}s from the support library instead.
-   *
-   * <p>If the support {@link FragmentActivity} class is used, this method will only attempt to
-   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached
-   * to the {@link FragmentActivity} will be ignored.
-   *
-   * @param view The view to search for a containing Fragment or Activity from.
-   * @return A RequestManager that can be used to start a load.
-   */
-  @NonNull
-  public static RequestManager with(@NonNull View view) {
-    return getRetriever(view.getContext()).get(view);
-  }
-
-  @NonNull
-  public Registry getRegistry() {
-    return registry;
-  }
-
-  boolean removeFromManagers(@NonNull Target<?> target) {
-    synchronized (managers) {
-      for (RequestManager requestManager : managers) {
-        if (requestManager.untrack(target)) {
-          return true;
-        }
-      }
+                .register(
+                        Bitmap.class,
+                        BitmapDrawable.class,
+                        new BitmapDrawableTranscoder(resources))
+                .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)
+                .register(
+                        Drawable.class,
+                        byte[].class,
+                        new DrawableBytesTranscoder(
+                                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))
+                .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);
+
+        ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
+        glideContext =
+                new GlideContext(
+                        context,
+                        arrayPool,
+                        registry,
+                        imageViewTargetFactory,
+                        defaultRequestOptions,
+                        defaultTransitionOptions,
+                        engine,
+                        logLevel);
     }
 
-    return false;
-  }
+    /**
+     * Returns the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} used to
+     * temporarily store {@link android.graphics.Bitmap}s so they can be reused to avoid garbage
+     * collections.
+     * <p>
+     * <p> Note - Using this pool directly can lead to undefined behavior and strange drawing errors.
+     * Any {@link android.graphics.Bitmap} added to the pool must not be currently in use in any other
+     * part of the application. Any {@link android.graphics.Bitmap} added to the pool must be removed
+     * from the pool before it is added a second time. </p>
+     * <p>
+     * <p> Note - To make effective use of the pool, any {@link android.graphics.Bitmap} removed from
+     * the pool must eventually be re-added. Otherwise the pool will eventually empty and will not
+     * serve any useful purpose. </p>
+     * <p>
+     * <p> The primary reason this object is exposed is for use in custom
+     * {@link com.bumptech.glide.load.ResourceDecoder}s and
+     * {@link com.bumptech.glide.load.Transformation}s. Use outside of these classes is not generally
+     * recommended. </p>
+     */
+    @NonNull
+    public BitmapPool getBitmapPool() {
+        return bitmapPool;
+    }
 
-  void registerRequestManager(RequestManager requestManager) {
-    synchronized (managers) {
-      if (managers.contains(requestManager)) {
-        throw new IllegalStateException("Cannot register already registered manager");
-      }
-      managers.add(requestManager);
+    @NonNull
+    public ArrayPool getArrayPool() {
+        return arrayPool;
     }
-  }
 
-  void unregisterRequestManager(RequestManager requestManager) {
-    synchronized (managers) {
-      if (!managers.contains(requestManager)) {
-        throw new IllegalStateException("Cannot unregister not yet registered manager");
-      }
-      managers.remove(requestManager);
+    /**
+     * @return The context associated with this instance.
+     */
+    @NonNull
+    public Context getContext() {
+        return glideContext.getBaseContext();
     }
-  }
 
-  @Override
-  public void onTrimMemory(int level) {
-    trimMemory(level);
-  }
+    ConnectivityMonitorFactory getConnectivityMonitorFactory() {
+        return connectivityMonitorFactory;
+    }
 
-  @Override
-  public void onConfigurationChanged(Configuration newConfig) {
-    // Do nothing.
-  }
+    @NonNull
+    GlideContext getGlideContext() {
+        return glideContext;
+    }
 
-  @Override
-  public void onLowMemory() {
-    clearMemory();
-  }
+    /**
+     * Pre-fills the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} using the given
+     * sizes.
+     * <p>
+     * <p> Enough Bitmaps are added to completely fill the pool, so most or all of the Bitmaps
+     * currently in the pool will be evicted. Bitmaps are allocated according to the weights of the
+     * given sizes, where each size gets (weight / prefillWeightSum) percent of the pool to fill.
+     * </p>
+     * <p>
+     * <p> Note - Pre-filling is done asynchronously using and
+     * {@link android.os.MessageQueue.IdleHandler}. Any currently running pre-fill will be cancelled
+     * and replaced by a call to this method. </p>
+     * <p>
+     * <p> This method should be used with caution, overly aggressive pre-filling is substantially
+     * worse than not pre-filling at all. Pre-filling should only be started in onCreate to avoid
+     * constantly clearing and re-filling the
+     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}. Rotation should be carefully
+     * considered as well. It may be worth calling this method only when no saved instance state
+     * exists so that pre-filling only happens when the Activity is first created, rather than on
+     * every rotation. </p>
+     *
+     * @param bitmapAttributeBuilders The list of
+     *                                {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
+     *                                individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
+     */
+    @SuppressWarnings("unused") // Public API
+    public void preFillBitmapPool(@NonNull PreFillType.Builder... bitmapAttributeBuilders) {
+        bitmapPreFiller.preFill(bitmapAttributeBuilders);
+    }
+
+    /**
+     * Clears as much memory as possible.
+     *
+     * @see android.content.ComponentCallbacks#onLowMemory()
+     * @see android.content.ComponentCallbacks2#onLowMemory()
+     */
+    public void clearMemory() {
+        // Engine asserts this anyway when removing resources, fail faster and consistently
+        Util.assertMainThread();
+        // memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687.
+        memoryCache.clearMemory();
+        bitmapPool.clearMemory();
+        arrayPool.clearMemory();
+    }
+
+    /**
+     * Clears some memory with the exact amount depending on the given level.
+     *
+     * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+     */
+    public void trimMemory(int level) {
+        // Engine asserts this anyway when removing resources, fail faster and consistently
+        Util.assertMainThread();
+        // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
+        memoryCache.trimMemory(level);
+        bitmapPool.trimMemory(level);
+        arrayPool.trimMemory(level);
+    }
+
+    /**
+     * Clears disk cache.
+     * <p>
+     * <p>
+     * This method should always be called on a background thread, since it is a blocking call.
+     * </p>
+     */
+    // Public API.
+    @SuppressWarnings({"unused", "WeakerAccess"})
+    public void clearDiskCache() {
+        Util.assertBackgroundThread();
+        engine.clearDiskCache();
+    }
+
+    /**
+     * Internal method.
+     */
+    @NonNull
+    public RequestManagerRetriever getRequestManagerRetriever() {
+        return requestManagerRetriever;
+    }
+
+    /**
+     * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
+     * <p>
+     * <p> The default {@link MemoryCategory} is {@link MemoryCategory#NORMAL}.
+     * {@link MemoryCategory#HIGH} increases Glide's maximum memory usage by up to 50% and
+     * {@link MemoryCategory#LOW} decreases Glide's maximum memory usage by 50%. This method should be
+     * used to temporarily increase or decrease memory usage for a single Activity or part of the app.
+     * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want
+     * to change the default. </p>
+     *
+     * @return the previous MemoryCategory used by Glide.
+     */
+    @SuppressWarnings("WeakerAccess") // Public API
+    @NonNull
+    public MemoryCategory setMemoryCategory(@NonNull MemoryCategory memoryCategory) {
+        // Engine asserts this anyway when removing resources, fail faster and consistently
+        Util.assertMainThread();
+        // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
+        memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
+        bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
+        MemoryCategory oldCategory = this.memoryCategory;
+        this.memoryCategory = memoryCategory;
+        return oldCategory;
+    }
+
+    @NonNull
+    private static RequestManagerRetriever getRetriever(@Nullable Context context) {
+        // Context could be null for other reasons (ie the user passes in null), but in practice it will
+        // only occur due to errors with the Fragment lifecycle.
+        Preconditions.checkNotNull(
+                context,
+                "You cannot start a load on a not yet attached View or a Fragment where getActivity() "
+                        + "returns null (which usually occurs when getActivity() is called before the Fragment "
+                        + "is attached or after the Fragment is destroyed).");
+        return Glide.get(context).getRequestManagerRetriever();
+    }
+
+    /**
+     * Begin a load with Glide by passing in a context.
+     * <p>
+     * <p> Any requests started using a context will only have the application level options applied
+     * and will not be started or stopped based on lifecycle events. In general, loads should be
+     * started at the level the result will be used in. If the resource will be used in a view in a
+     * child fragment, the load should be started with {@link #with(android.app.Fragment)}} using that
+     * child fragment. Similarly, if the resource will be used in a view in the parent fragment, the
+     * load should be started with {@link #with(android.app.Fragment)} using the parent fragment. In
+     * the same vein, if the resource will be used in a view in an activity, the load should be
+     * started with {@link #with(android.app.Activity)}}. </p>
+     * <p>
+     * <p> This method is appropriate for resources that will be used outside of the normal fragment
+     * or activity lifecycle (For example in services, or for notification thumbnails). </p>
+     *
+     * @param context Any context, will not be retained.
+     * @return A RequestManager for the top level application that can be used to start a load.
+     * @see #with(android.app.Activity)
+     * @see #with(android.app.Fragment)
+     * @see #with(android.support.v4.app.Fragment)
+     * @see #with(android.support.v4.app.FragmentActivity)
+     */
+    @NonNull
+    public static RequestManager with(@NonNull Context context) {
+        return getRetriever(context).get(context);
+    }
+
+    /**
+     * Begin a load with Glide that will be tied to the given {@link android.app.Activity}'s lifecycle
+     * and that uses the given {@link Activity}'s default options.
+     *
+     * @param activity The activity to use.
+     * @return A RequestManager for the given activity that can be used to start a load.
+     */
+    @NonNull
+    public static RequestManager with(@NonNull Activity activity) {
+        return getRetriever(activity).get(activity);
+    }
+
+    /**
+     * Begin a load with Glide that will tied to the give
+     * {@link android.support.v4.app.FragmentActivity}'s lifecycle and that uses the given
+     * {@link android.support.v4.app.FragmentActivity}'s default options.
+     *
+     * @param activity The activity to use.
+     * @return A RequestManager for the given FragmentActivity that can be used to start a load.
+     */
+    @NonNull
+    public static RequestManager with(@NonNull FragmentActivity activity) {
+        return getRetriever(activity).get(activity);
+    }
+
+    /**
+     * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
+     * and that uses the given {@link android.app.Fragment}'s default options.
+     *
+     * @param fragment The fragment to use.
+     * @return A RequestManager for the given Fragment that can be used to start a load.
+     */
+    @NonNull
+    public static RequestManager with(@NonNull android.app.Fragment fragment) {
+        return getRetriever(fragment.getActivity()).get(fragment);
+    }
+
+    /**
+     * Begin a load with Glide that will be tied to the given
+     * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
+     * {@link android.support.v4.app.Fragment}'s default options.
+     *
+     * @param fragment The fragment to use.
+     * @return A RequestManager for the given Fragment that can be used to start a load.
+     */
+    @NonNull
+    public static RequestManager with(@NonNull Fragment fragment) {
+        return getRetriever(fragment.getActivity()).get(fragment);
+    }
+
+    /**
+     * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},
+     * {@link android.app.Fragment}, or {@link Activity} that contains the View.
+     * <p>
+     * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View
+     * is a child of the View returned by the {@link Fragment#getView()}} method.
+     * <p>
+     * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment
+     * variants unless you're loading in a View subclass.
+     * <p>
+     * <p>This method may be inefficient aways and is definitely inefficient for large hierarchies.
+     * Consider memoizing the result after the View is attached or again, prefer the Activity and
+     * Fragment variants whenever possible.
+     * <p>
+     * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,
+     * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider
+     * avoiding entirely or using the {@link Fragment}s from the support library instead.
+     * <p>
+     * <p>If the support {@link FragmentActivity} class is used, this method will only attempt to
+     * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached
+     * to the {@link FragmentActivity} will be ignored.
+     *
+     * @param view The view to search for a containing Fragment or Activity from.
+     * @return A RequestManager that can be used to start a load.
+     */
+    @NonNull
+    public static RequestManager with(@NonNull View view) {
+        return getRetriever(view.getContext()).get(view);
+    }
+
+    @NonNull
+    public Registry getRegistry() {
+        return registry;
+    }
+
+    boolean removeFromManagers(@NonNull Target<?> target) {
+        synchronized (managers) {
+            for (RequestManager requestManager : managers) {
+                if (requestManager.untrack(target)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    void registerRequestManager(RequestManager requestManager) {
+        synchronized (managers) {
+            if (managers.contains(requestManager)) {
+                throw new IllegalStateException("Cannot register already registered manager");
+            }
+            managers.add(requestManager);
+        }
+    }
+
+    void unregisterRequestManager(RequestManager requestManager) {
+        synchronized (managers) {
+            if (!managers.contains(requestManager)) {
+                throw new IllegalStateException("Cannot unregister not yet registered manager");
+            }
+            managers.remove(requestManager);
+        }
+    }
+
+    @Override
+    public void onTrimMemory(int level) {
+        trimMemory(level);
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        // Do nothing.
+    }
+
+    @Override
+    public void onLowMemory() {
+        clearMemory();
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 3f8056407..964d5fbc5 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -14,6 +14,7 @@
 import android.support.annotation.Nullable;
 import android.support.annotation.RawRes;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.request.ErrorRequestCoordinator;
@@ -32,6 +33,7 @@
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+
 import java.io.File;
 import java.net.URL;
 
@@ -39,1011 +41,1009 @@
  * A generic class that can handle setting options and staring loads for generic resource types.
  *
  * @param <TranscodeType> The type of resource that will be delivered to the
- * {@link com.bumptech.glide.request.target.Target}.
+ *                        {@link com.bumptech.glide.request.target.Target}.
  */
 // Public API.
 @SuppressWarnings({"unused", "WeakerAccess"})
 public class RequestBuilder<TranscodeType> implements Cloneable,
-    ModelTypes<RequestBuilder<TranscodeType>> {
-  // Used in generated subclasses
-  protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
-          .skipMemoryCache(true);
-
-  private final Context context;
-  private final RequestManager requestManager;
-  private final Class<TranscodeType> transcodeClass;
-  private final RequestOptions defaultRequestOptions;
-  private final Glide glide;
-  private final GlideContext glideContext;
-
-  @NonNull protected RequestOptions requestOptions;
-
-  @NonNull
-  @SuppressWarnings("unchecked")
-  private TransitionOptions<?, ? super TranscodeType> transitionOptions;
-
-  @Nullable private Object model;
-  // model may occasionally be null, so to enforce that load() was called, put a boolean rather
-  // than relying on model not to be null.
-  @Nullable private RequestListener<TranscodeType> requestListener;
-  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
-  @Nullable private RequestBuilder<TranscodeType> errorBuilder;
-  @Nullable private Float thumbSizeMultiplier;
-  private boolean isDefaultTransitionOptionsSet = true;
-  private boolean isModelSet;
-  private boolean isThumbnailBuilt;
-
-  protected RequestBuilder(Glide glide, RequestManager requestManager,
-      Class<TranscodeType> transcodeClass, Context context) {
-    this.glide = glide;
-    this.requestManager = requestManager;
-    this.transcodeClass = transcodeClass;
-    this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
-    this.context = context;
-    this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
-    this.requestOptions = defaultRequestOptions;
-    this.glideContext = glide.getGlideContext();
-  }
-
-  protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.glide, other.requestManager, transcodeClass, other.context);
-    model = other.model;
-    isModelSet = other.isModelSet;
-    requestOptions = other.requestOptions;
-  }
-
-  /**
-   * Applies the given options to the request.
-   *
-   * <p>As with {@link RequestOptions#apply(RequestOptions)}, {@code #apply} only replaces those
-   * values that are explicitly set in the given {@link RequestOptions} object. If you need to
-   * completely reset all previously set options, create a new {@code RequestBuilder} instead of
-   * using this method.
-   *
-   * @see RequestOptions#apply(RequestOptions)
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
-    Preconditions.checkNotNull(requestOptions);
-    this.requestOptions = getMutableOptions().apply(requestOptions);
-    return this;
-  }
-
-  // We're checking to see if we need to clone our options object because we want to make sure the
-  // original is never modified, so we need reference equality.
-  @SuppressWarnings("ReferenceEquality")
-  @NonNull
-  protected RequestOptions getMutableOptions() {
-    return defaultRequestOptions == this.requestOptions
-        ? this.requestOptions.clone() : this.requestOptions;
-  }
-
-  /**
-   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
-   * this load completes.
-   *
-   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
-   * previously.
-   *
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> transition(
-      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
-    this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
-    isDefaultTransitionOptionsSet = false;
-    return this;
-  }
-
-  /**
-   * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
-   * instance of an exception handler per type of request (usually activity/fragment) rather than
-   * pass one in per request to avoid some redundant object allocation.
-   *
-   * @param requestListener The request listener to use.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> listener(
-      @Nullable RequestListener<TranscodeType> requestListener) {
-    this.requestListener = requestListener;
-
-    return this;
-  }
-
-  /**
-   * Sets a {@link RequestBuilder} that is built and run iff the load started by this
-   * {@link RequestBuilder} fails.
-   *
-   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
-   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
-   *
-   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
-   * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
-   *
-   * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
-   * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
-   * Options like priority, override widths and heights and transitions must be applied
-   * independently to the error builder.
-   *
-   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
-   * if it's set on this {@link RequestBuilder} via
-   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
-   * {@link RequestOptions#fallback(int)}.
-   *
-   * @return This {@link RequestBuilder}.
-   */
-  @NonNull
-  public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
-    this.errorBuilder = errorBuilder;
-    return this;
-  }
-
-  /**
-   * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
-   * this request. Best used for loading thumbnail resources that are smaller and will be loaded
-   * more quickly than the full size resource. There are no guarantees about the order in which the
-   * requests will actually finish. However, if the thumb request completes after the full request,
-   * the thumb resource will never replace the full resource.
-   *
-   * <p>Recursive calls to thumbnail are supported.
-   *
-   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
-   * {@link #thumbnail(RequestBuilder[])}.
-   *
-   * @see #thumbnail(float)
-   * @see #thumbnail(RequestBuilder[])
-   *
-   * @param thumbnailRequest The request to use to load the thumbnail.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> thumbnail(
-      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
-    this.thumbnailBuilder = thumbnailRequest;
-
-    return this;
-  }
-
-  /**
-   * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
-   * loaded as thumbnails in the given priority order.
-   *
-   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
-   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
-   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
-   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
-   *
-   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
-   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
-   * {@link #thumbnail(RequestBuilder)} with {@code null}.
-   *
-   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
-   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
-   * chain.
-   *
-   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
-   * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
-   *
-   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
-   * {@link #thumbnail(float)} and this method.
-   *
-   * @see #thumbnail(float)
-   * @see #thumbnail(RequestBuilder)
-   *
-   * @return This request builder.
-   */
-  @SuppressWarnings({"CheckResult", "unchecked"})
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> thumbnail(
-      @Nullable RequestBuilder<TranscodeType>... thumbnails) {
-    if (thumbnails == null || thumbnails.length == 0) {
-      return thumbnail((RequestBuilder<TranscodeType>) null);
+        ModelTypes<RequestBuilder<TranscodeType>> {
+    // Used in generated subclasses
+    protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
+                    .skipMemoryCache(true);
+
+    private final Context context;
+    private final RequestManager requestManager;
+    private final Class<TranscodeType> transcodeClass;
+    private final RequestOptions defaultRequestOptions;
+    private final Glide glide;
+    private final GlideContext glideContext;
+
+    @NonNull
+    protected RequestOptions requestOptions;
+
+    @NonNull
+    @SuppressWarnings("unchecked")
+    private TransitionOptions<?, ? super TranscodeType> transitionOptions;
+
+    @Nullable
+    private Object model;
+    // model may occasionally be null, so to enforce that load() was called, put a boolean rather
+    // than relying on model not to be null.
+    @Nullable
+    private RequestListener<TranscodeType> requestListener;
+    @Nullable
+    private RequestBuilder<TranscodeType> thumbnailBuilder;
+    @Nullable
+    private RequestBuilder<TranscodeType> errorBuilder;
+    @Nullable
+    private Float thumbSizeMultiplier;
+    private boolean isDefaultTransitionOptionsSet = true;
+    private boolean isModelSet;
+    private boolean isThumbnailBuilt;
+
+    protected RequestBuilder(Glide glide, RequestManager requestManager,
+                             Class<TranscodeType> transcodeClass, Context context) {
+        this.glide = glide;
+        this.requestManager = requestManager;
+        this.transcodeClass = transcodeClass;
+        this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
+        this.context = context;
+        this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
+        this.requestOptions = defaultRequestOptions;
+        this.glideContext = glide.getGlideContext();
+    }
+
+    protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+        this(other.glide, other.requestManager, transcodeClass, other.context);
+        model = other.model;
+        isModelSet = other.isModelSet;
+        requestOptions = other.requestOptions;
+    }
+
+    /**
+     * Applies the given options to the request.
+     * <p>
+     * <p>As with {@link RequestOptions#apply(RequestOptions)}, {@code #apply} only replaces those
+     * values that are explicitly set in the given {@link RequestOptions} object. If you need to
+     * completely reset all previously set options, create a new {@code RequestBuilder} instead of
+     * using this method.
+     *
+     * @return This request builder.
+     * @see RequestOptions#apply(RequestOptions)
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
+        Preconditions.checkNotNull(requestOptions);
+        this.requestOptions = getMutableOptions().apply(requestOptions);
+        return this;
+    }
+
+    // We're checking to see if we need to clone our options object because we want to make sure the
+    // original is never modified, so we need reference equality.
+    @SuppressWarnings("ReferenceEquality")
+    @NonNull
+    protected RequestOptions getMutableOptions() {
+        return defaultRequestOptions == this.requestOptions
+                ? this.requestOptions.clone() : this.requestOptions;
+    }
+
+    /**
+     * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
+     * this load completes.
+     * <p>
+     * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
+     * previously.
+     *
+     * @return This request builder.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<TranscodeType> transition(
+            @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
+        this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
+        isDefaultTransitionOptionsSet = false;
+        return this;
+    }
+
+    /**
+     * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
+     * instance of an exception handler per type of request (usually activity/fragment) rather than
+     * pass one in per request to avoid some redundant object allocation.
+     *
+     * @param requestListener The request listener to use.
+     * @return This request builder.
+     */
+    @NonNull
+    @CheckResult
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<TranscodeType> listener(
+            @Nullable RequestListener<TranscodeType> requestListener) {
+        this.requestListener = requestListener;
+
+        return this;
+    }
+
+    /**
+     * Sets a {@link RequestBuilder} that is built and run iff the load started by this
+     * {@link RequestBuilder} fails.
+     * <p>
+     * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
+     * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
+     * <p>
+     * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
+     * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
+     * <p>
+     * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
+     * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
+     * Options like priority, override widths and heights and transitions must be applied
+     * independently to the error builder.
+     * <p>
+     * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
+     * if it's set on this {@link RequestBuilder} via
+     * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
+     * {@link RequestOptions#fallback(int)}.
+     *
+     * @return This {@link RequestBuilder}.
+     */
+    @NonNull
+    public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
+        this.errorBuilder = errorBuilder;
+        return this;
+    }
+
+    /**
+     * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
+     * this request. Best used for loading thumbnail resources that are smaller and will be loaded
+     * more quickly than the full size resource. There are no guarantees about the order in which the
+     * requests will actually finish. However, if the thumb request completes after the full request,
+     * the thumb resource will never replace the full resource.
+     * <p>
+     * <p>Recursive calls to thumbnail are supported.
+     * <p>
+     * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
+     * {@link #thumbnail(RequestBuilder[])}.
+     *
+     * @param thumbnailRequest The request to use to load the thumbnail.
+     * @return This request builder.
+     * @see #thumbnail(float)
+     * @see #thumbnail(RequestBuilder[])
+     */
+    @NonNull
+    @CheckResult
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<TranscodeType> thumbnail(
+            @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
+        this.thumbnailBuilder = thumbnailRequest;
+
+        return this;
+    }
+
+    /**
+     * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
+     * loaded as thumbnails in the given priority order.
+     * <p>
+     * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
+     * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
+     * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
+     * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+     * <p>
+     * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
+     * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
+     * {@link #thumbnail(RequestBuilder)} with {@code null}.
+     * <p>
+     * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
+     * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
+     * chain.
+     * <p>
+     * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
+     * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
+     * <p>
+     * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
+     * {@link #thumbnail(float)} and this method.
+     *
+     * @return This request builder.
+     * @see #thumbnail(float)
+     * @see #thumbnail(RequestBuilder)
+     */
+    @SuppressWarnings({"CheckResult", "unchecked"})
+    @NonNull
+    @CheckResult
+    public RequestBuilder<TranscodeType> thumbnail(
+            @Nullable RequestBuilder<TranscodeType>... thumbnails) {
+        if (thumbnails == null || thumbnails.length == 0) {
+            return thumbnail((RequestBuilder<TranscodeType>) null);
+        }
+
+        RequestBuilder<TranscodeType> previous = null;
+
+        // Start with the lowest priority thumbnail so that we can safely handle mutations if
+        // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
+        // Starting with the highest priority thumbnail would prevent us from assigning the result of
+        // thumbnail because the mutated request wouldn't be used in the next iteration.
+        for (int i = thumbnails.length - 1; i >= 0; i--) {
+            RequestBuilder<TranscodeType> current = thumbnails[i];
+            // Ignore null thumbnails.
+            if (current == null) {
+                continue;
+            }
+
+            if (previous == null) {
+                // If we don't yet have our first non-null request, set it and continue.
+                previous = current;
+            } else {
+                // Otherwise make our next lowest priority request the thumbnail of our current request.
+                previous = current.thumbnail(previous);
+            }
+        }
+        return thumbnail(previous);
+    }
+
+    /**
+     * Loads a resource in an identical manner to this request except with the dimensions of the
+     * target multiplied by the given size multiplier. If the thumbnail load completes before the full
+     * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
+     * load, the thumbnail will not be shown.
+     * <p>
+     * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
+     * {@link ImageView}) must be able to scale the thumbnail appropriately. See
+     * {@link android.widget.ImageView.ScaleType}.
+     * <p>
+     * <p>Almost all options will be copied from the original load, including the {@link
+     * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
+     * and {@link com.bumptech.glide.load.Transformation}s. However,
+     * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
+     * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
+     * {@link #listener(RequestListener)} will only be used on the full size load and will not be
+     * copied for the thumbnail load.
+     * <p>
+     * <p>Recursive calls to thumbnail are supported.
+     * <p>
+     * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
+     * and {@link #thumbnail(RequestBuilder)}.
+     *
+     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
+     *                       the thumbnail.
+     * @return This request builder.
+     * @see #thumbnail(RequestBuilder)
+     * @see #thumbnail(RequestBuilder[])
+     */
+    @NonNull
+    @CheckResult
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
+        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+        }
+        this.thumbSizeMultiplier = sizeMultiplier;
+
+        return this;
+    }
+
+    /**
+     * Sets the specific model to load data for.
+     *
+     * @param model The model to load data for, or null.
+     * @return This request builder.
+     */
+    @NonNull
+    @CheckResult
+    @SuppressWarnings("unchecked")
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable Object model) {
+        return loadGeneric(model);
+    }
+
+    @NonNull
+    private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
+        this.model = model;
+        isModelSet = true;
+        return this;
+    }
+
+    /**
+     * Returns an object to load the given {@link Bitmap}.
+     * <p>
+     * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
+     * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
+     * not supported by Glide by default, consider registering a custom
+     * {@link com.bumptech.glide.load.model.ModelLoader} or
+     * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+     * <p>
+     * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+     * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+     * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+     * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+     * <p>
+     * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
+     * compared.
+     *
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
+        return loadGeneric(bitmap)
+                .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+
+    /**
+     * Returns a request builder to load the given {@link Drawable}.
+     * <p>
+     * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
+     * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
+     * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
+     * {@link com.bumptech.glide.load.model.ModelLoader} or
+     * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+     * <p>
+     * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+     * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+     * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+     * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+     * <p>
+     * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
+     * compared.
+     *
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
+        return loadGeneric(drawable)
+                .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+
+    /**
+     * Returns a request builder to load the given {@link java.lang.String}.
+     * <p>
+     * <p> Note - this method caches data using only the given String as the cache key. If the data is
+     * a Uri outside of your control, or you otherwise expect the data represented by the given String
+     * to change without the String identifier changing, Consider using
+     * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
+     * mixin a signature you create that identifies the data currently at the given String that will
+     * invalidate the cache if that data changes. Alternatively, using
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+     * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+     * appropriate.
+     * </p>
+     *
+     * @param string A file path, or a uri or url handled by
+     *               {@link com.bumptech.glide.load.model.UriLoader}.
+     * @see #load(Object)
+     */
+    @NonNull
+    @Override
+    @CheckResult
+    public RequestBuilder<TranscodeType> load(@Nullable String string) {
+        return loadGeneric(string);
     }
 
-    RequestBuilder<TranscodeType> previous = null;
-
-    // Start with the lowest priority thumbnail so that we can safely handle mutations if
-    // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
-    // Starting with the highest priority thumbnail would prevent us from assigning the result of
-    // thumbnail because the mutated request wouldn't be used in the next iteration.
-    for (int i = thumbnails.length - 1; i >= 0; i--) {
-      RequestBuilder<TranscodeType> current = thumbnails[i];
-      // Ignore null thumbnails.
-      if (current == null) {
-        continue;
-      }
-
-      if (previous == null) {
-        // If we don't yet have our first non-null request, set it and continue.
-        previous = current;
-      } else {
-        // Otherwise make our next lowest priority request the thumbnail of our current request.
-        previous = current.thumbnail(previous);
-      }
+    /**
+     * Returns a request builder to load the given {@link Uri}.
+     * <p>
+     * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
+     * represented by Uris from some content providers may change without the Uri changing, which
+     * means using this method can lead to displaying stale data. Consider using
+     * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
+     * mixin a signature you create based on the data at the given Uri that will invalidate the cache
+     * if that data changes. Alternatively, using
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+     * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+     * appropriate. </p>
+     *
+     * @param uri The Uri representing the image. Must be of a type handled by
+     *            {@link com.bumptech.glide.load.model.UriLoader}.
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
+        return loadGeneric(uri);
     }
-    return thumbnail(previous);
-  }
-
-  /**
-   * Loads a resource in an identical manner to this request except with the dimensions of the
-   * target multiplied by the given size multiplier. If the thumbnail load completes before the full
-   * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
-   * load, the thumbnail will not be shown.
-   *
-   * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
-   * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}.
-   *
-   * <p>Almost all options will be copied from the original load, including the {@link
-   * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
-   * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
-   * {@link #listener(RequestListener)} will only be used on the full size load and will not be
-   * copied for the thumbnail load.
-   *
-   * <p>Recursive calls to thumbnail are supported.
-   *
-   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
-   *  and {@link #thumbnail(RequestBuilder)}.
-   *
-   * @see #thumbnail(RequestBuilder)
-   * @see #thumbnail(RequestBuilder[])
-   *
-   * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
-   *                       the thumbnail.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+
+    /**
+     * Returns a request builder to load the given {@link File}.
+     * <p>
+     * <p>Note - this method caches data for Files using only the file path itself as the cache key.
+     * The data in the File can change so using this method can lead to displaying stale data. If you
+     * expect the data in the File to change, Consider using
+     * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
+     * to mixin a signature you create that identifies the data currently in the File that will
+     * invalidate the cache if that data changes. Alternatively, using
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+     * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+     * appropriate.
+     *
+     * @param file The File containing the image
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable File file) {
+        return loadGeneric(file);
+    }
+
+    /**
+     * Returns a request builder that uses the
+     * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
+     * {@link Integer} to load the image represented by the given {@link Integer} resource id.
+     * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
+     * <p>
+     * <p>By default this method adds a version code based signature to the cache key used to cache
+     * this resource in Glide. This signature is sufficient to guarantee that end users will see the
+     * most up to date versions of your Drawables, but during development if you do not increment your
+     * version code before each install and you replace a Drawable with different data without
+     * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
+     * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
+     * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+     * during development, and re-enabling the default
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+     * <p>
+     * <p>This method will load non-{@link android.graphics.Bitmap} resources like
+     * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
+     * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
+     * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
+     * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
+     * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
+     * load failures if a {@link Drawable} can't be transformed, use the optional transformation
+     * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
+     * <p>
+     * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
+     * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
+     * caution for non-{@link Bitmap} {@link Drawable}s.
+     *
+     * @see #load(Integer)
+     * @see com.bumptech.glide.signature.ApplicationVersionSignature
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
+        return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
+    }
+
+    /**
+     * Returns a request builder to load the given {@link URL}.
+     *
+     * @param url The URL representing the image.
+     * @see #load(Object)
+     * @deprecated The {@link java.net.URL} class has
+     * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
+     * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
+     */
+    @Deprecated
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable URL url) {
+        return loadGeneric(url);
     }
-    this.thumbSizeMultiplier = sizeMultiplier;
-
-    return this;
-  }
-
-  /**
-   * Sets the specific model to load data for.
-   *
-   * @param model The model to load data for, or null.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Object model) {
-    return loadGeneric(model);
-  }
-
-  @NonNull
-  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
-    this.model = model;
-    isModelSet = true;
-    return this;
-  }
-  /**
-   * Returns an object to load the given {@link Bitmap}.
-   *
-   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
-   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
-   * not supported by Glide by default, consider registering a custom
-   * {@link com.bumptech.glide.load.model.ModelLoader} or
-   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
-   *
-   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
-   * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
-   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
-   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
-   *
-   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
-   * compared.
-   *
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
-    return loadGeneric(bitmap)
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link Drawable}.
-   *
-   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
-   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
-   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
-   * {@link com.bumptech.glide.load.model.ModelLoader} or
-   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
-   *
-   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
-   * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
-   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
-   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
-   *
-   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
-   * compared.
-   *
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
-    return loadGeneric(drawable)
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link java.lang.String}.
-   *
-   * <p> Note - this method caches data using only the given String as the cache key. If the data is
-   * a Uri outside of your control, or you otherwise expect the data represented by the given String
-   * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create that identifies the data currently at the given String that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   * </p>
-   *
-   * @see #load(Object)
-   *
-   * @param string A file path, or a uri or url handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
-   */
-  @NonNull
-  @Override
-  @CheckResult
-  public RequestBuilder<TranscodeType> load(@Nullable String string) {
-    return loadGeneric(string);
-  }
-
-  /**
-   * Returns a request builder to load the given {@link Uri}.
-   *
-   * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
-   * represented by Uris from some content providers may change without the Uri changing, which
-   * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create based on the data at the given Uri that will invalidate the cache
-   * if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate. </p>
-   *
-   * @see #load(Object)
-   *
-   * @param uri The Uri representing the image. Must be of a type handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
-    return loadGeneric(uri);
-  }
-
-  /**
-   * Returns a request builder to load the given {@link File}.
-   *
-   * <p>Note - this method caches data for Files using only the file path itself as the cache key.
-   * The data in the File can change so using this method can lead to displaying stale data. If you
-   * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
-   * to mixin a signature you create that identifies the data currently in the File that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   *
-   * @see #load(Object)
-   *
-   * @param file The File containing the image
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable File file) {
-    return loadGeneric(file);
-  }
-
-  /**
-   * Returns a request builder that uses the
-   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
-   * {@link Integer} to load the image represented by the given {@link Integer} resource id.
-   * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
-   *
-   * <p>By default this method adds a version code based signature to the cache key used to cache
-   * this resource in Glide. This signature is sufficient to guarantee that end users will see the
-   * most up to date versions of your Drawables, but during development if you do not increment your
-   * version code before each install and you replace a Drawable with different data without
-   * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
-   * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
-   *
-   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
-   * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
-   * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
-   * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
-   * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
-   * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
-   * load failures if a {@link Drawable} can't be transformed, use the optional transformation
-   * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
-   *
-   * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
-   * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
-   * caution for non-{@link Bitmap} {@link Drawable}s.
-   *
-   * @see #load(Integer)
-   * @see com.bumptech.glide.signature.ApplicationVersionSignature
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
-    return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link URL}.
-   *
-   * @param url The URL representing the image.
-   * @see #load(Object)
-   * @deprecated The {@link java.net.URL} class has
-   * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
-   * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
-   */
-  @Deprecated
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable URL url) {
-    return loadGeneric(url);
-  }
-
-  /**
-   * Returns a request to load the given byte array.
-   *
-   * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
-   *
-   * @param model the data to load.
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    RequestBuilder<TranscodeType> result = loadGeneric(model);
-    if (!result.requestOptions.isDiskCacheStrategySet()) {
-        result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+
+    /**
+     * Returns a request to load the given byte array.
+     * <p>
+     * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
+     *
+     * @param model the data to load.
+     * @see #load(Object)
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
+        RequestBuilder<TranscodeType> result = loadGeneric(model);
+        if (!result.requestOptions.isDiskCacheStrategySet()) {
+            result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+        }
+        if (!result.requestOptions.isSkipMemoryCacheSet()) {
+            result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+        }
+        return result;
     }
-    if (!result.requestOptions.isSkipMemoryCacheSet()) {
-      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+
+    /**
+     * Returns a copy of this request builder with all of the options put so far on this builder.
+     * <p>
+     * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+     * changes to one builder will not affect the other builder. However, in addition to immutable
+     * arguments, the current model is not copied copied so changes to the model will affect both
+     * builders. </p>
+     */
+    @SuppressWarnings({
+            "unchecked",
+            // we don't want to throw to be user friendly
+            "PMD.CloneThrowsCloneNotSupportedException"
+    })
+    @CheckResult
+    @Override
+    public RequestBuilder<TranscodeType> clone() {
+        try {
+            RequestBuilder<TranscodeType> result = (RequestBuilder<TranscodeType>) super.clone();
+            result.requestOptions = result.requestOptions.clone();
+            result.transitionOptions = result.transitionOptions.clone();
+            return result;
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
     }
-    return result;
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   */
-  @SuppressWarnings({
-      "unchecked",
-      // we don't want to throw to be user friendly
-      "PMD.CloneThrowsCloneNotSupportedException"
-  })
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> clone() {
-    try {
-      RequestBuilder<TranscodeType> result = (RequestBuilder<TranscodeType>) super.clone();
-      result.requestOptions = result.requestOptions.clone();
-      result.transitionOptions = result.transitionOptions.clone();
-      return result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
+
+    /**
+     * Set the target the resource will be loaded into.
+     *
+     * @param target The target to load the resource into.
+     * @return The given target.
+     * @see RequestManager#clear(Target)
+     */
+    @NonNull
+    public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
+        return into(target, /*targetListener=*/ null);
     }
-  }
-
-  /**
-   * Set the target the resource will be loaded into.
-   *
-   * @param target The target to load the resource into.
-   * @return The given target.
-   * @see RequestManager#clear(Target)
-   */
-  @NonNull
-  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
-    return into(target, /*targetListener=*/ null);
-  }
-
-  @NonNull
-  @Synthetic <Y extends Target<TranscodeType>> Y into(
-      @NonNull Y target,
-      @Nullable RequestListener<TranscodeType> targetListener) {
-    return into(target, targetListener, getMutableOptions());
-  }
-
-  private <Y extends Target<TranscodeType>> Y into(
-      @NonNull Y target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      @NonNull RequestOptions options) {
-    Util.assertMainThread();
-    Preconditions.checkNotNull(target);
-    if (!isModelSet) {
-      throw new IllegalArgumentException("You must call #load() before calling #into()");
+
+    @NonNull
+    @Synthetic
+    <Y extends Target<TranscodeType>> Y into(
+            @NonNull Y target,
+            @Nullable RequestListener<TranscodeType> targetListener) {
+        return into(target, targetListener, getMutableOptions());
     }
 
-    options = options.autoClone();
-    Request request = buildRequest(target, targetListener, options);
-
-    Request previous = target.getRequest();
-    if (request.isEquivalentTo(previous)
-        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
-      request.recycle();
-      // If the request is completed, beginning again will ensure the result is re-delivered,
-      // triggering RequestListeners and Targets. If the request is failed, beginning again will
-      // restart the request, giving it another chance to complete. If the request is already
-      // running, we can let it continue running without interruption.
-      if (!Preconditions.checkNotNull(previous).isRunning()) {
-        // Use the previous request rather than the new one to allow for optimizations like skipping
-        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
-        // that are done in the individual Request.
-        previous.begin();
-      }
-      return target;
+    private <Y extends Target<TranscodeType>> Y into(
+            @NonNull Y target,
+            @Nullable RequestListener<TranscodeType> targetListener,
+            @NonNull RequestOptions options) {
+        Util.assertMainThread();
+        Preconditions.checkNotNull(target);
+        if (!isModelSet) {
+            throw new IllegalArgumentException("You must call #load() before calling #into()");
+        }
+
+        options = options.autoClone();
+        Request request = buildRequest(target, targetListener, options);
+
+        Request previous = target.getRequest();
+        if (request.isEquivalentTo(previous)
+                && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
+            request.recycle();
+            // If the request is completed, beginning again will ensure the result is re-delivered,
+            // triggering RequestListeners and Targets. If the request is failed, beginning again will
+            // restart the request, giving it another chance to complete. If the request is already
+            // running, we can let it continue running without interruption.
+            if (!Preconditions.checkNotNull(previous).isRunning()) {
+                // Use the previous request rather than the new one to allow for optimizations like skipping
+                // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
+                // that are done in the individual Request.
+                previous.begin();
+            }
+            return target;
+        }
+
+        requestManager.clear(target);
+        target.setRequest(request);
+        requestManager.track(target, request);
+
+        return target;
     }
 
-    requestManager.clear(target);
-    target.setRequest(request);
-    requestManager.track(target, request);
-
-    return target;
-  }
-
-  // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
-  // the previous request will complete from memory because it will just use the resource that had
-  // already been loaded. If the previous request isn't complete, we can wait for it to finish
-  // because the previous request must also be using skipMemoryCache for the requests to be
-  // equivalent. See #2663 for additional context.
-  private boolean isSkipMemoryCacheWithCompletePreviousRequest(
-      RequestOptions options, Request previous) {
-    return !options.isMemoryCacheable() && previous.isComplete();
-  }
-
-  /**
-   * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
-   * the view, and frees any resources Glide may have previously loaded into the view so they may be
-   * reused.
-   *
-   * @see RequestManager#clear(Target)
-   *
-   * @param view The view to cancel previous loads for and load the new resource into.
-   * @return The
-   * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
-   */
-  @NonNull
-  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
-    Util.assertMainThread();
-    Preconditions.checkNotNull(view);
-
-    RequestOptions requestOptions = this.requestOptions;
-    if (!requestOptions.isTransformationSet()
-        && requestOptions.isTransformationAllowed()
-        && view.getScaleType() != null) {
-      // Clone in this method so that if we use this RequestBuilder to load into a View and then
-      // into a different target, we don't retain the transformation applied based on the previous
-      // View's scale type.
-      switch (view.getScaleType()) {
-        case CENTER_CROP:
-          requestOptions = requestOptions.clone().optionalCenterCrop();
-          break;
-        case CENTER_INSIDE:
-          requestOptions = requestOptions.clone().optionalCenterInside();
-          break;
-        case FIT_CENTER:
-        case FIT_START:
-        case FIT_END:
-          requestOptions = requestOptions.clone().optionalFitCenter();
-          break;
-        case FIT_XY:
-          requestOptions = requestOptions.clone().optionalCenterInside();
-          break;
-        case CENTER:
-        case MATRIX:
-        default:
-          // Do nothing.
-      }
+    // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
+    // the previous request will complete from memory because it will just use the resource that had
+    // already been loaded. If the previous request isn't complete, we can wait for it to finish
+    // because the previous request must also be using skipMemoryCache for the requests to be
+    // equivalent. See #2663 for additional context.
+    private boolean isSkipMemoryCacheWithCompletePreviousRequest(
+            RequestOptions options, Request previous) {
+        return !options.isMemoryCacheable() && previous.isComplete();
     }
 
-    return into(
-        glideContext.buildImageViewTarget(view, transcodeClass),
+    /**
+     * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
+     * the view, and frees any resources Glide may have previously loaded into the view so they may be
+     * reused.
+     *
+     * @param view The view to cancel previous loads for and load the new resource into.
+     * @return The
+     * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
+     * @see RequestManager#clear(Target)
+     */
+    @NonNull
+    public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
+        Util.assertMainThread();
+        Preconditions.checkNotNull(view);
+
+        RequestOptions requestOptions = this.requestOptions;
+        if (!requestOptions.isTransformationSet()
+                && requestOptions.isTransformationAllowed()
+                && view.getScaleType() != null) {
+            // Clone in this method so that if we use this RequestBuilder to load into a View and then
+            // into a different target, we don't retain the transformation applied based on the previous
+            // View's scale type.
+            switch (view.getScaleType()) {
+                case CENTER_CROP:
+                    requestOptions = requestOptions.clone().optionalCenterCrop();
+                    break;
+                case CENTER_INSIDE:
+                    requestOptions = requestOptions.clone().optionalCenterInside();
+                    break;
+                case FIT_CENTER:
+                case FIT_START:
+                case FIT_END:
+                    requestOptions = requestOptions.clone().optionalFitCenter();
+                    break;
+                case FIT_XY:
+                    requestOptions = requestOptions.clone().optionalCenterInside();
+                    break;
+                case CENTER:
+                case MATRIX:
+                default:
+                    // Do nothing.
+            }
+        }
+
+        return into(
+                glideContext.buildImageViewTarget(view, transcodeClass),
         /*targetListener=*/ null,
-        requestOptions);
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   * @see RequestManager#clear(Target)
-   *
-   * @deprecated Use {@link #submit(int, int)} instead.
-   */
-  @Deprecated
-  public FutureTarget<TranscodeType> into(int width, int height) {
-    return submit(width, height);
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
-   * since the width and height will be overridden by values passed to {@link
-   * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
-   * with override values are applied, or whenever you want to retrieve the image in its original
-   * size.
-   *
-   * @see #submit(int, int)
-   * @see #into(Target)
-   */
-  @NonNull
-  public FutureTarget<TranscodeType> submit() {
-    return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   */
-  @NonNull
-  public FutureTarget<TranscodeType> submit(int width, int height) {
-    final RequestFutureTarget<TranscodeType> target =
-        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
-
-    if (Util.isOnBackgroundThread()) {
-      glideContext.getMainHandler().post(new Runnable() {
-        @Override
-        public void run() {
-          if (!target.isCancelled()) {
+                requestOptions);
+    }
+
+    /**
+     * Returns a future that can be used to do a blocking get on a background thread.
+     *
+     * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+     *               previously called.
+     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+     *               previously called).
+     * @see RequestManager#clear(Target)
+     * @deprecated Use {@link #submit(int, int)} instead.
+     */
+    @Deprecated
+    public FutureTarget<TranscodeType> into(int width, int height) {
+        return submit(width, height);
+    }
+
+    /**
+     * Returns a future that can be used to do a blocking get on a background thread.
+     * <p>
+     * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
+     * since the width and height will be overridden by values passed to {@link
+     * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
+     * with override values are applied, or whenever you want to retrieve the image in its original
+     * size.
+     *
+     * @see #submit(int, int)
+     * @see #into(Target)
+     */
+    @NonNull
+    public FutureTarget<TranscodeType> submit() {
+        return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+    }
+
+    /**
+     * Returns a future that can be used to do a blocking get on a background thread.
+     *
+     * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+     *               previously called.
+     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+     *               previously called).
+     */
+    @NonNull
+    public FutureTarget<TranscodeType> submit(int width, int height) {
+        final RequestFutureTarget<TranscodeType> target =
+                new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
+
+        if (Util.isOnBackgroundThread()) {
+            glideContext.getMainHandler().post(new Runnable() {
+                @Override
+                public void run() {
+                    if (!target.isCancelled()) {
+                        into(target, target);
+                    }
+                }
+            });
+        } else {
             into(target, target);
-          }
         }
-      });
-    } else {
-      into(target, target);
+
+        return target;
+    }
+
+    /**
+     * Preloads the resource into the cache using the given width and height.
+     * <p>
+     * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
+     * future are available quickly. </p>
+     *
+     * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+     *               previously called.
+     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+     *               overridden by
+     *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+     *               previously called).
+     * @return A {@link Target} that can be used to cancel the load via
+     * {@link RequestManager#clear(Target)}.
+     * @see com.bumptech.glide.ListPreloader
+     */
+    @NonNull
+    public Target<TranscodeType> preload(int width, int height) {
+        final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
+        return into(target);
+    }
+
+    /**
+     * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and
+     * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
+     * the width and height.
+     *
+     * @return A {@link Target} that can be used to cancel the load via
+     * {@link RequestManager#clear(Target)}
+     * @see #preload(int, int)
+     */
+    @NonNull
+    public Target<TranscodeType> preload() {
+        return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+    }
+
+    /**
+     * Loads the original unmodified data into the cache and calls the given Target with the cache
+     * File.
+     *
+     * @param target The Target that will receive the cache File when the load completes
+     * @param <Y>    The type of Target.
+     * @return The given Target.
+     * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
+     */
+    @Deprecated
+    @CheckResult
+    public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
+        return getDownloadOnlyRequest().into(target);
+    }
+
+    /**
+     * Loads the original unmodified data into the cache and returns a
+     * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
+     * data.
+     *
+     * @param width  The width in pixels to use to fetch the data.
+     * @param height The height in pixels to use to fetch the data.
+     * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
+     * containing the data.
+     * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}.
+     */
+    @Deprecated
+    @CheckResult
+    public FutureTarget<File> downloadOnly(int width, int height) {
+        return getDownloadOnlyRequest().submit(width, height);
+    }
+
+    @NonNull
+    @CheckResult
+    protected RequestBuilder<File> getDownloadOnlyRequest() {
+        return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
     }
 
-    return target;
-  }
-
-  /**
-   * Preloads the resource into the cache using the given width and height.
-   *
-   * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
-   * future are available quickly. </p>
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}.
-   * @see com.bumptech.glide.ListPreloader
-   */
-  @NonNull
-  public Target<TranscodeType> preload(int width, int height) {
-    final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
-    return into(target);
-  }
-
-  /**
-   * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and
-   * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
-   * the width and height.
-   *
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}
-   * @see #preload(int, int)
-   */
-  @NonNull
-  public Target<TranscodeType> preload() {
-    return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
-  }
-
-  /**
-   * Loads the original unmodified data into the cache and calls the given Target with the cache
-   * File.
-   *
-   * @param target The Target that will receive the cache File when the load completes
-   * @param <Y>    The type of Target.
-   * @return The given Target.
-   *
-   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
-   */
-  @Deprecated
-  @CheckResult
-  public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
-    return getDownloadOnlyRequest().into(target);
-  }
-
-  /**
-   * Loads the original unmodified data into the cache and returns a
-   * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
-   * data.
-   *
-   * @param width  The width in pixels to use to fetch the data.
-   * @param height The height in pixels to use to fetch the data.
-   * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
-   * containing the data.
-   *
-   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}.
-   */
-  @Deprecated
-  @CheckResult
-  public FutureTarget<File> downloadOnly(int width, int height) {
-    return getDownloadOnlyRequest().submit(width, height);
-  }
-
-  @NonNull
-  @CheckResult
-  protected RequestBuilder<File> getDownloadOnlyRequest() {
-    return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
-  }
-
-  @NonNull
-  private Priority getThumbnailPriority(@NonNull Priority current) {
-    switch (current) {
-      case LOW:
-        return Priority.NORMAL;
-      case NORMAL:
-        return Priority.HIGH;
-      case HIGH:
-      case IMMEDIATE:
-        return Priority.IMMEDIATE;
-      default:
-        throw new IllegalArgumentException("unknown priority: " + requestOptions.getPriority());
+    @NonNull
+    private Priority getThumbnailPriority(@NonNull Priority current) {
+        switch (current) {
+            case LOW:
+                return Priority.NORMAL;
+            case NORMAL:
+                return Priority.HIGH;
+            case HIGH:
+            case IMMEDIATE:
+                return Priority.IMMEDIATE;
+            default:
+                throw new IllegalArgumentException("unknown priority: " + requestOptions.getPriority());
+        }
     }
-  }
-
-  private Request buildRequest(
-      Target<TranscodeType> target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      RequestOptions requestOptions) {
-    return buildRequestRecursive(
-        target,
-        targetListener,
+
+    private Request buildRequest(
+            Target<TranscodeType> target,
+            @Nullable RequestListener<TranscodeType> targetListener,
+            RequestOptions requestOptions) {
+        return buildRequestRecursive(
+                target,
+                targetListener,
         /*parentCoordinator=*/ null,
-        transitionOptions,
-        requestOptions.getPriority(),
-        requestOptions.getOverrideWidth(),
-        requestOptions.getOverrideHeight(),
-        requestOptions);
-  }
-
-  private Request buildRequestRecursive(
-      Target<TranscodeType> target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      @Nullable RequestCoordinator parentCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight,
-      RequestOptions requestOptions) {
-
-    // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
-    ErrorRequestCoordinator errorRequestCoordinator = null;
-    if (errorBuilder != null) {
-      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
-      parentCoordinator = errorRequestCoordinator;
+                transitionOptions,
+                requestOptions.getPriority(),
+                requestOptions.getOverrideWidth(),
+                requestOptions.getOverrideHeight(),
+                requestOptions);
     }
 
-    Request mainRequest =
-        buildThumbnailRequestRecursive(
-            target,
-            targetListener,
-            parentCoordinator,
-            transitionOptions,
-            priority,
-            overrideWidth,
-            overrideHeight,
-            requestOptions);
-
-    if (errorRequestCoordinator == null) {
-      return mainRequest;
+    private Request buildRequestRecursive(
+            Target<TranscodeType> target,
+            @Nullable RequestListener<TranscodeType> targetListener,
+            @Nullable RequestCoordinator parentCoordinator,
+            TransitionOptions<?, ? super TranscodeType> transitionOptions,
+            Priority priority,
+            int overrideWidth,
+            int overrideHeight,
+            RequestOptions requestOptions) {
+
+        // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
+        ErrorRequestCoordinator errorRequestCoordinator = null;
+        if (errorBuilder != null) {
+            errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
+            parentCoordinator = errorRequestCoordinator;
+        }
+
+        Request mainRequest =
+                buildThumbnailRequestRecursive(
+                        target,
+                        targetListener,
+                        parentCoordinator,
+                        transitionOptions,
+                        priority,
+                        overrideWidth,
+                        overrideHeight,
+                        requestOptions);
+
+        if (errorRequestCoordinator == null) {
+            return mainRequest;
+        }
+
+        int errorOverrideWidth = errorBuilder.requestOptions.getOverrideWidth();
+        int errorOverrideHeight = errorBuilder.requestOptions.getOverrideHeight();
+        if (Util.isValidDimensions(overrideWidth, overrideHeight)
+                && !errorBuilder.requestOptions.isValidOverride()) {
+            errorOverrideWidth = requestOptions.getOverrideWidth();
+            errorOverrideHeight = requestOptions.getOverrideHeight();
+        }
+
+        Request errorRequest = errorBuilder.buildRequestRecursive(
+                target,
+                targetListener,
+                errorRequestCoordinator,
+                errorBuilder.transitionOptions,
+                errorBuilder.requestOptions.getPriority(),
+                errorOverrideWidth,
+                errorOverrideHeight,
+                errorBuilder.requestOptions);
+        errorRequestCoordinator.setRequests(mainRequest, errorRequest);
+        return errorRequestCoordinator;
     }
 
-    int errorOverrideWidth = errorBuilder.requestOptions.getOverrideWidth();
-    int errorOverrideHeight = errorBuilder.requestOptions.getOverrideHeight();
-    if (Util.isValidDimensions(overrideWidth, overrideHeight)
-        && !errorBuilder.requestOptions.isValidOverride()) {
-      errorOverrideWidth = requestOptions.getOverrideWidth();
-      errorOverrideHeight = requestOptions.getOverrideHeight();
+    private Request buildThumbnailRequestRecursive(
+            Target<TranscodeType> target,
+            RequestListener<TranscodeType> targetListener,
+            @Nullable RequestCoordinator parentCoordinator,
+            TransitionOptions<?, ? super TranscodeType> transitionOptions,
+            Priority priority,
+            int overrideWidth,
+            int overrideHeight,
+            RequestOptions requestOptions) {
+        if (thumbnailBuilder != null) {
+            // Recursive case: contains a potentially recursive thumbnail request builder.
+            if (isThumbnailBuilt) {
+                throw new IllegalStateException("You cannot use a request as both the main request and a "
+                        + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
+            }
+
+            TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
+                    thumbnailBuilder.transitionOptions;
+
+            // Apply our transition by default to thumbnail requests but avoid overriding custom options
+            // that may have been applied on the thumbnail request explicitly.
+            if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
+                thumbTransitionOptions = transitionOptions;
+            }
+
+            Priority thumbPriority = thumbnailBuilder.requestOptions.isPrioritySet()
+                    ? thumbnailBuilder.requestOptions.getPriority() : getThumbnailPriority(priority);
+
+            int thumbOverrideWidth = thumbnailBuilder.requestOptions.getOverrideWidth();
+            int thumbOverrideHeight = thumbnailBuilder.requestOptions.getOverrideHeight();
+            if (Util.isValidDimensions(overrideWidth, overrideHeight)
+                    && !thumbnailBuilder.requestOptions.isValidOverride()) {
+                thumbOverrideWidth = requestOptions.getOverrideWidth();
+                thumbOverrideHeight = requestOptions.getOverrideHeight();
+            }
+
+            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+            Request fullRequest =
+                    obtainRequest(
+                            target,
+                            targetListener,
+                            requestOptions,
+                            coordinator,
+                            transitionOptions,
+                            priority,
+                            overrideWidth,
+                            overrideHeight);
+            isThumbnailBuilt = true;
+            // Recursively generate thumbnail requests.
+            Request thumbRequest =
+                    thumbnailBuilder.buildRequestRecursive(
+                            target,
+                            targetListener,
+                            coordinator,
+                            thumbTransitionOptions,
+                            thumbPriority,
+                            thumbOverrideWidth,
+                            thumbOverrideHeight,
+                            thumbnailBuilder.requestOptions);
+            isThumbnailBuilt = false;
+            coordinator.setRequests(fullRequest, thumbRequest);
+            return coordinator;
+        } else if (thumbSizeMultiplier != null) {
+            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
+            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+            Request fullRequest =
+                    obtainRequest(
+                            target,
+                            targetListener,
+                            requestOptions,
+                            coordinator,
+                            transitionOptions,
+                            priority,
+                            overrideWidth,
+                            overrideHeight);
+            RequestOptions thumbnailOptions = requestOptions.clone()
+                    .sizeMultiplier(thumbSizeMultiplier);
+
+            Request thumbnailRequest =
+                    obtainRequest(
+                            target,
+                            targetListener,
+                            thumbnailOptions,
+                            coordinator,
+                            transitionOptions,
+                            getThumbnailPriority(priority),
+                            overrideWidth,
+                            overrideHeight);
+
+            coordinator.setRequests(fullRequest, thumbnailRequest);
+            return coordinator;
+        } else {
+            // Base case: no thumbnail.
+            return obtainRequest(
+                    target,
+                    targetListener,
+                    requestOptions,
+                    parentCoordinator,
+                    transitionOptions,
+                    priority,
+                    overrideWidth,
+                    overrideHeight);
+        }
     }
 
-    Request errorRequest = errorBuilder.buildRequestRecursive(
-        target,
-        targetListener,
-        errorRequestCoordinator,
-        errorBuilder.transitionOptions,
-        errorBuilder.requestOptions.getPriority(),
-        errorOverrideWidth,
-        errorOverrideHeight,
-        errorBuilder.requestOptions);
-    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
-    return errorRequestCoordinator;
-  }
-
-  private Request buildThumbnailRequestRecursive(
-      Target<TranscodeType> target,
-      RequestListener<TranscodeType> targetListener,
-      @Nullable RequestCoordinator parentCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight,
-      RequestOptions requestOptions) {
-    if (thumbnailBuilder != null) {
-      // Recursive case: contains a potentially recursive thumbnail request builder.
-      if (isThumbnailBuilt) {
-        throw new IllegalStateException("You cannot use a request as both the main request and a "
-            + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
-      }
-
-      TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
-          thumbnailBuilder.transitionOptions;
-
-      // Apply our transition by default to thumbnail requests but avoid overriding custom options
-      // that may have been applied on the thumbnail request explicitly.
-      if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
-        thumbTransitionOptions = transitionOptions;
-      }
-
-      Priority thumbPriority = thumbnailBuilder.requestOptions.isPrioritySet()
-          ? thumbnailBuilder.requestOptions.getPriority() : getThumbnailPriority(priority);
-
-      int thumbOverrideWidth = thumbnailBuilder.requestOptions.getOverrideWidth();
-      int thumbOverrideHeight = thumbnailBuilder.requestOptions.getOverrideHeight();
-      if (Util.isValidDimensions(overrideWidth, overrideHeight)
-          && !thumbnailBuilder.requestOptions.isValidOverride()) {
-        thumbOverrideWidth = requestOptions.getOverrideWidth();
-        thumbOverrideHeight = requestOptions.getOverrideHeight();
-      }
-
-      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              requestOptions,
-              coordinator,
-              transitionOptions,
-              priority,
-              overrideWidth,
-              overrideHeight);
-      isThumbnailBuilt = true;
-      // Recursively generate thumbnail requests.
-      Request thumbRequest =
-          thumbnailBuilder.buildRequestRecursive(
-              target,
-              targetListener,
-              coordinator,
-              thumbTransitionOptions,
-              thumbPriority,
-              thumbOverrideWidth,
-              thumbOverrideHeight,
-              thumbnailBuilder.requestOptions);
-      isThumbnailBuilt = false;
-      coordinator.setRequests(fullRequest, thumbRequest);
-      return coordinator;
-    } else if (thumbSizeMultiplier != null) {
-      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
-      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              requestOptions,
-              coordinator,
-              transitionOptions,
-              priority,
-              overrideWidth,
-              overrideHeight);
-      RequestOptions thumbnailOptions = requestOptions.clone()
-          .sizeMultiplier(thumbSizeMultiplier);
-
-      Request thumbnailRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              thumbnailOptions,
-              coordinator,
-              transitionOptions,
-              getThumbnailPriority(priority),
-              overrideWidth,
-              overrideHeight);
-
-      coordinator.setRequests(fullRequest, thumbnailRequest);
-      return coordinator;
-    } else {
-      // Base case: no thumbnail.
-      return obtainRequest(
-          target,
-          targetListener,
-          requestOptions,
-          parentCoordinator,
-          transitionOptions,
-          priority,
-          overrideWidth,
-          overrideHeight);
+    private Request obtainRequest(
+            Target<TranscodeType> target,
+            RequestListener<TranscodeType> targetListener,
+            RequestOptions requestOptions,
+            RequestCoordinator requestCoordinator,
+            TransitionOptions<?, ? super TranscodeType> transitionOptions,
+            Priority priority,
+            int overrideWidth,
+            int overrideHeight) {
+        return SingleRequest.obtain(
+                context,
+                glideContext,
+                model,
+                transcodeClass,
+                requestOptions,
+                overrideWidth,
+                overrideHeight,
+                priority,
+                target,
+                targetListener,
+                requestListener,
+                requestCoordinator,
+                glideContext.getEngine(),
+                transitionOptions.getTransitionFactory());
     }
-  }
-
-  private Request obtainRequest(
-      Target<TranscodeType> target,
-      RequestListener<TranscodeType> targetListener,
-      RequestOptions requestOptions,
-      RequestCoordinator requestCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight) {
-    return SingleRequest.obtain(
-        context,
-        glideContext,
-        model,
-        transcodeClass,
-        requestOptions,
-        overrideWidth,
-        overrideHeight,
-        priority,
-        target,
-        targetListener,
-        requestListener,
-        requestCoordinator,
-        glideContext.getEngine(),
-        transitionOptions.getTransitionFactory());
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index f05ad0d83..b9c02a4e1 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -14,6 +14,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.view.View;
+
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
@@ -30,6 +31,7 @@
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+
 import java.io.File;
 import java.net.URL;
 
@@ -46,634 +48,631 @@
  * @see Glide#with(Context)
  */
 public class RequestManager implements LifecycleListener,
-    ModelTypes<RequestBuilder<Drawable>> {
-  private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
-  private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
-  private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
-          .skipMemoryCache(true);
-
-  protected final Glide glide;
-  protected final Context context;
-  @Synthetic final Lifecycle lifecycle;
-  private final RequestTracker requestTracker;
-  private final RequestManagerTreeNode treeNode;
-  private final TargetTracker targetTracker = new TargetTracker();
-  private final Runnable addSelfToLifecycle = new Runnable() {
-    @Override
-    public void run() {
-      lifecycle.addListener(RequestManager.this);
-    }
-  };
-  private final Handler mainHandler = new Handler(Looper.getMainLooper());
-  private final ConnectivityMonitor connectivityMonitor;
-
-  private RequestOptions requestOptions;
-
-  public RequestManager(
-      @NonNull Glide glide, @NonNull Lifecycle lifecycle,
-      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
-    this(
-        glide,
-        lifecycle,
-        treeNode,
-        new RequestTracker(),
-        glide.getConnectivityMonitorFactory(),
-        context);
-  }
-
-  // Our usage is safe here.
-  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
-  RequestManager(
-      Glide glide,
-      Lifecycle lifecycle,
-      RequestManagerTreeNode treeNode,
-      RequestTracker requestTracker,
-      ConnectivityMonitorFactory factory,
-      Context context) {
-    this.glide = glide;
-    this.lifecycle = lifecycle;
-    this.treeNode = treeNode;
-    this.requestTracker = requestTracker;
-    this.context = context;
-
-    connectivityMonitor =
-        factory.build(
-            context.getApplicationContext(),
-            new RequestManagerConnectivityListener(requestTracker));
-
-    // If we're the application level request manager, we may be created on a background thread.
-    // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
-    // issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.
-    // This should be entirely safe.
-    if (Util.isOnBackgroundThread()) {
-      mainHandler.post(addSelfToLifecycle);
-    } else {
-      lifecycle.addListener(this);
-    }
-    lifecycle.addListener(connectivityMonitor);
-
-    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
-
-    glide.registerRequestManager(this);
-  }
-
-  protected void setRequestOptions(@NonNull RequestOptions toSet) {
-    requestOptions = toSet.clone().autoClone();
-  }
-
-  private void updateRequestOptions(@NonNull RequestOptions toUpdate) {
-    requestOptions = requestOptions.apply(toUpdate);
-  }
-
-  /**
-   * Updates the default {@link RequestOptions} for all loads started with this request manager
-   * with the given {@link RequestOptions}.
-   *
-   * <p>The {@link RequestOptions} provided here are applied on top of those provided via {@link
-   * GlideBuilder#setDefaultRequestOptions(RequestOptions)}. If there are conflicts, the options
-   * applied here will win. Note that this method does not mutate options provided to
-   * {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
-   *
-   * <p>Multiple sets of options can be applied. If there are conflicts the last {@link
-   * RequestOptions} applied will win.
-   *
-   * <p>The modified options will only be applied to loads started after this method is called.
-   *
-   * @see RequestBuilder#apply(RequestOptions)
-   *
-   * @return This request manager.
-   */
-  @NonNull
-  public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
-    updateRequestOptions(requestOptions);
-    return this;
-  }
-
-  /**
-   * Replaces the default {@link RequestOptions} for all loads started with this request manager
-   * with the given {@link RequestOptions}.
-   *
-   * <p>The {@link RequestOptions} provided here replace those that have been previously provided
-   * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and
-   * {@link #applyDefaultRequestOptions(RequestOptions)}.
-   *
-   * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
-   * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
-   * options and mutate the clone.
-   *
-   * @see #applyDefaultRequestOptions(RequestOptions)
-   *
-   * @return This request manager.
-   */
-  @NonNull
-  public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
-    setRequestOptions(requestOptions);
-    return this;
-  }
-
-  /**
-   * @see android.content.ComponentCallbacks2#onTrimMemory(int)
-   *
-   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
-   * externally.
-   */
-  @Deprecated
-  public void onTrimMemory(int level) {
-    glide.onTrimMemory(level);
-  }
-
-  /**
-   * @see android.content.ComponentCallbacks2#onLowMemory()
-   *
-   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
-   * externally.
-   */
-  @Deprecated
-  public void onLowMemory() {
-    glide.onLowMemory();
-  }
-
-  /**
-   * Returns true if loads for this {@link RequestManager} are currently paused.
-   *
-   * @see #pauseRequests()
-   * @see #resumeRequests()
-   */
-  public boolean isPaused() {
-    Util.assertMainThread();
-    return requestTracker.isPaused();
-  }
-
-  /**
-   * Cancels any in progress loads, but does not clear resources of completed loads.
-   *
-   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
-   * manager is paused to complete. RequestManagers attached to Fragments and Activities
-   * automatically resume onStart().
-   *
-   * @see #isPaused()
-   * @see #resumeRequests()
-   */
-  public void pauseRequests() {
-    Util.assertMainThread();
-    requestTracker.pauseRequests();
-  }
-
-  /**
-   * Cancels any in progress loads and clears resources of completed loads.
-   *
-   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
-   * manager is paused to complete. RequestManagers attached to Fragments and Activities
-   * automatically resume onStart().
-   *
-   * <p>This will release the memory used by completed bitmaps but leaves them in any configured
-   * caches. When an #{@link android.app.Activity} receives #{@link
-   * android.app.Activity#onTrimMemory(int)} at a level of #{@link
-   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep
-   * your process alive longer.
-   *
-   * @see #isPaused()
-   * @see #resumeRequests()
-   */
-  public void pauseAllRequests() {
-    Util.assertMainThread();
-    requestTracker.pauseAllRequests();
-  }
-
-  /**
-   * Performs {@link #pauseRequests()} recursively for all managers that are contextually
-   * descendant to this manager based on the Activity/Fragment hierarchy:
-   *
-   * <ul>
-   *   <li>When pausing on an Activity all attached fragments will also get paused.
-   *   <li>When pausing on an attached Fragment all descendant fragments will also get paused.
-   *   <li>When pausing on a detached Fragment or the application context only the current
-   *   RequestManager is paused.
-   * </ul>
-   *
-   * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
-   * pause, in this case either call pause on the Activity or use a support Fragment.
-   */
-  // Public API.
-  @SuppressWarnings({"WeakerAccess", "unused"})
-  public void pauseRequestsRecursive() {
-    Util.assertMainThread();
-    pauseRequests();
-    for (RequestManager requestManager : treeNode.getDescendants()) {
-      requestManager.pauseRequests();
-    }
-  }
-
-  /**
-   * Restarts any loads that have not yet completed.
-   *
-   * @see #isPaused()
-   * @see #pauseRequests()
-   */
-  public void resumeRequests() {
-    Util.assertMainThread();
-    requestTracker.resumeRequests();
-  }
-
-  /**
-   * Performs {@link #resumeRequests()} recursively for all managers that are contextually
-   * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
-   * are identical as for {@link #pauseRequestsRecursive()}.
-   */
-  // Public API.
-  @SuppressWarnings("unused")
-  public void resumeRequestsRecursive() {
-    Util.assertMainThread();
-    resumeRequests();
-    for (RequestManager requestManager : treeNode.getDescendants()) {
-      requestManager.resumeRequests();
-    }
-  }
-
-  /**
-   * Lifecycle callback that registers for connectivity events (if the
-   * android.permission.ACCESS_NETWORK_STATE permission is present) and restarts failed or paused
-   * requests.
-   */
-  @Override
-  public void onStart() {
-    resumeRequests();
-    targetTracker.onStart();
-  }
-
-  /**
-   * Lifecycle callback that unregisters for connectivity events (if the
-   * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.
-   */
-  @Override
-  public void onStop() {
-    pauseRequests();
-    targetTracker.onStop();
-  }
-
-  /**
-   * Lifecycle callback that cancels all in progress requests and clears and recycles resources for
-   * all completed requests.
-   */
-  @Override
-  public void onDestroy() {
-    targetTracker.onDestroy();
-    for (Target<?> target : targetTracker.getAll()) {
-      clear(target);
-    }
-    targetTracker.clear();
-    requestTracker.clearRequests();
-    lifecycle.removeListener(this);
-    lifecycle.removeListener(connectivityMonitor);
-    mainHandler.removeCallbacks(addSelfToLifecycle);
-    glide.unregisterRequestManager(this);
-  }
-
-  /**
-   * Attempts to always load the resource as a {@link android.graphics.Bitmap}, even if it could
-   * actually be animated.
-   *
-   * @return A new request builder for loading a {@link android.graphics.Bitmap}
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<Bitmap> asBitmap() {
-    return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
-  }
-
-  /**
-   * Attempts to always load the resource as a
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
-   *
-   * <p> If the underlying data is not a GIF, this will fail. As a result, this should only be used
-   * if the model represents an animated GIF and the caller wants to interact with the GifDrawable
-   * directly. Normally using just {@link #asDrawable()} is sufficient because it will determine
-   * whether or not the given data represents an animated GIF and return the appropriate {@link
-   * Drawable}, animated or not, automatically. </p>
-   *
-   * @return A new request builder for loading a
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<GifDrawable> asGif() {
-    return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
-  }
-
-  /**
-   * Attempts to always load the resource using any registered {@link
-   * com.bumptech.glide.load.ResourceDecoder}s that can decode any subclass of {@link Drawable}.
-   *
-   * <p> By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
-   * GifDrawable}, but if additional decoders are registered for other {@link Drawable} subclasses,
-   * any of those subclasses may also be returned. </p>
-   *
-   * @return A new request builder for loading a {@link Drawable}.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<Drawable> asDrawable() {
-    return as(Drawable.class);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
-    return asDrawable().load(bitmap);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
-    return asDrawable().load(drawable);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable String string) {
-    return asDrawable().load(string);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Uri uri) {
-    return asDrawable().load(uri);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable File file) {
-    return asDrawable().load(file);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @SuppressWarnings("deprecation")
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Integer resourceId) {
-    return asDrawable().load(resourceId);
-  }
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @SuppressWarnings("deprecation")
-  @CheckResult
-  @Override
-  @Deprecated
-  public RequestBuilder<Drawable> load(@Nullable URL url) {
-    return asDrawable().load(url);
-  }
-
-
-  /**
-   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable byte[] model) {
-    return asDrawable().load(model);
-  }
-
-  /**
-   * A helper method equivalent to calling {@link #asDrawable()} and then {@link
-   * RequestBuilder#load(Object)} with the given model.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<Drawable> load(@Nullable Object model) {
-    return asDrawable().load(model);
-  }
-
-  /**
-   * Attempts always load the resource into the cache and return the {@link File} containing the
-   * cached source data.
-   *
-   * <p>This method is designed to work for remote data that is or will be cached using {@link
-   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not
-   * recommended.
-   *
-   * @return A new request builder for downloading content to cache and returning the cache File.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<File> downloadOnly() {
-    return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
-  }
-
-  /**
-   * A helper method equivalent to calling {@link #downloadOnly()} ()} and then {@link
-   * RequestBuilder#load(Object)} with the given model.
-   *
-   * @return A new request builder for loading a {@link Drawable} using the given model.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<File> download(@Nullable Object model) {
-    return downloadOnly().load(model);
-  }
-
-  /**
-   * Attempts to always load a {@link File} containing the resource, either using a file path
-   * obtained from the media store (for local images/videos), or using Glide's disk cache
-   * (for remote images/videos).
-   *
-   * <p>For remote content, prefer {@link #downloadOnly()}.
-   *
-   * @return A new request builder for obtaining File paths to content.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<File> asFile() {
-    return as(File.class).apply(skipMemoryCacheOf(true));
-  }
-
-  /**
-   * Attempts to load the resource using any registered
-   * {@link com.bumptech.glide.load.ResourceDecoder}s
-   * that can decode the given resource class or any subclass of the given resource class.
-   *
-   * @param resourceClass The resource to decode.
-   * @return A new request builder for loading the given resource class.
-   */
-  @NonNull
-  @CheckResult
-  public <ResourceType> RequestBuilder<ResourceType> as(
-      @NonNull Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(glide, this, resourceClass, context);
-  }
-
-  /**
-   * Cancel any pending loads Glide may have for the view and free any resources that may have been
-   * loaded for the view.
-   *
-   * <p> Note that this will only work if {@link View#setTag(Object)} is not called on this view
-   * outside of Glide. </p>
-   *
-   * @param view The view to cancel loads and free resources for.
-   * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
-   *                                  tag.
-   * @see #clear(Target)
-   */
-  public void clear(@NonNull View view) {
-    clear(new ClearTarget(view));
-  }
-
-  /**
-   * Cancel any pending loads Glide may have for the target and free any resources (such as
-   * {@link Bitmap}s) that may have been loaded for the target so they may be reused.
-   *
-   * @param target The Target to cancel loads for.
-   */
-  public void clear(@Nullable final Target<?> target) {
-    if (target == null) {
-      return;
-    }
-
-    if (Util.isOnMainThread()) {
-      untrackOrDelegate(target);
-    } else {
-      mainHandler.post(new Runnable() {
+        ModelTypes<RequestBuilder<Drawable>> {
+    private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
+    private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
+    private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
+            diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
+                    .skipMemoryCache(true);
+
+    protected final Glide glide;
+    protected final Context context;
+    @Synthetic
+    final Lifecycle lifecycle;
+    private final RequestTracker requestTracker;
+    private final RequestManagerTreeNode treeNode;
+    private final TargetTracker targetTracker = new TargetTracker();
+    private final Runnable addSelfToLifecycle = new Runnable() {
         @Override
         public void run() {
-          clear(target);
+            lifecycle.addListener(RequestManager.this);
         }
-      });
-    }
-  }
-
-  private void untrackOrDelegate(@NonNull Target<?> target) {
-    boolean isOwnedByUs = untrack(target);
-    // We'll end up here if the Target was cleared after the RequestManager that started the request
-    // is destroyed. That can happen for at least two reasons:
-    // 1. We call clear() on a background thread using something other than Application Context
-    // RequestManager.
-    // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
-    // Fragment is destroyed, starts a load with it, and then clears that load with a different
-    // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
-    //
-    // #1 is always an error. At best the caller is leaking memory briefly in something like an
-    // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
-    // time if they do something like reference the Activity RequestManager in a long lived
-    // background thread or task.
-    //
-    // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
-    // the corresponding Activity or Fragment is destroyed because retaining any reference to the
-    // RequestManager leaks memory. It's possible that there's some brief period of time during or
-    // immediately after onDestroy where this is reasonable, but I can't think of why.
-    if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
-      Request request = target.getRequest();
-      target.setRequest(null);
-      request.clear();
-    }
-  }
-
-  boolean untrack(@NonNull Target<?> target) {
-    Request request = target.getRequest();
-    // If the Target doesn't have a request, it's already been cleared.
-    if (request == null) {
-      return true;
-    }
-
-    if (requestTracker.clearRemoveAndRecycle(request)) {
-      targetTracker.untrack(target);
-      target.setRequest(null);
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  void track(@NonNull Target<?> target, @NonNull Request request) {
-    targetTracker.track(target);
-    requestTracker.runRequest(request);
-  }
-
-  RequestOptions getDefaultRequestOptions() {
-    return requestOptions;
-  }
-
-  @NonNull
-  <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
-    return glide.getGlideContext().getDefaultTransitionOptions(transcodeClass);
-  }
-
-  @Override
-  public String toString() {
-    return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
-  }
-
-  private static class RequestManagerConnectivityListener implements ConnectivityMonitor
-      .ConnectivityListener {
-    private final RequestTracker requestTracker;
+    };
+    private final Handler mainHandler = new Handler(Looper.getMainLooper());
+    private final ConnectivityMonitor connectivityMonitor;
+
+    private RequestOptions requestOptions;
+
+    public RequestManager(
+            @NonNull Glide glide, @NonNull Lifecycle lifecycle,
+            @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+        this(
+                glide,
+                lifecycle,
+                treeNode,
+                new RequestTracker(),
+                glide.getConnectivityMonitorFactory(),
+                context);
+    }
+
+    // Our usage is safe here.
+    @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+    RequestManager(
+            Glide glide,
+            Lifecycle lifecycle,
+            RequestManagerTreeNode treeNode,
+            RequestTracker requestTracker,
+            ConnectivityMonitorFactory factory,
+            Context context) {
+        this.glide = glide;
+        this.lifecycle = lifecycle;
+        this.treeNode = treeNode;
+        this.requestTracker = requestTracker;
+        this.context = context;
+
+        connectivityMonitor =
+                factory.build(
+                        context.getApplicationContext(),
+                        new RequestManagerConnectivityListener(requestTracker));
+
+        // If we're the application level request manager, we may be created on a background thread.
+        // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
+        // issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.
+        // This should be entirely safe.
+        if (Util.isOnBackgroundThread()) {
+            mainHandler.post(addSelfToLifecycle);
+        } else {
+            lifecycle.addListener(this);
+        }
+        lifecycle.addListener(connectivityMonitor);
+
+        setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
+
+        glide.registerRequestManager(this);
+    }
+
+    protected void setRequestOptions(@NonNull RequestOptions toSet) {
+        requestOptions = toSet.clone().autoClone();
+    }
+
+    private void updateRequestOptions(@NonNull RequestOptions toUpdate) {
+        requestOptions = requestOptions.apply(toUpdate);
+    }
+
+    /**
+     * Updates the default {@link RequestOptions} for all loads started with this request manager
+     * with the given {@link RequestOptions}.
+     * <p>
+     * <p>The {@link RequestOptions} provided here are applied on top of those provided via {@link
+     * GlideBuilder#setDefaultRequestOptions(RequestOptions)}. If there are conflicts, the options
+     * applied here will win. Note that this method does not mutate options provided to
+     * {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+     * <p>
+     * <p>Multiple sets of options can be applied. If there are conflicts the last {@link
+     * RequestOptions} applied will win.
+     * <p>
+     * <p>The modified options will only be applied to loads started after this method is called.
+     *
+     * @return This request manager.
+     * @see RequestBuilder#apply(RequestOptions)
+     */
+    @NonNull
+    public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
+        updateRequestOptions(requestOptions);
+        return this;
+    }
+
+    /**
+     * Replaces the default {@link RequestOptions} for all loads started with this request manager
+     * with the given {@link RequestOptions}.
+     * <p>
+     * <p>The {@link RequestOptions} provided here replace those that have been previously provided
+     * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and
+     * {@link #applyDefaultRequestOptions(RequestOptions)}.
+     * <p>
+     * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
+     * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
+     * options and mutate the clone.
+     *
+     * @return This request manager.
+     * @see #applyDefaultRequestOptions(RequestOptions)
+     */
+    @NonNull
+    public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
+        setRequestOptions(requestOptions);
+        return this;
+    }
+
+    /**
+     * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+     * @deprecated This method is called automatically by Glide's internals and shouldn't be called
+     * externally.
+     */
+    @Deprecated
+    public void onTrimMemory(int level) {
+        glide.onTrimMemory(level);
+    }
+
+    /**
+     * @see android.content.ComponentCallbacks2#onLowMemory()
+     * @deprecated This method is called automatically by Glide's internals and shouldn't be called
+     * externally.
+     */
+    @Deprecated
+    public void onLowMemory() {
+        glide.onLowMemory();
+    }
+
+    /**
+     * Returns true if loads for this {@link RequestManager} are currently paused.
+     *
+     * @see #pauseRequests()
+     * @see #resumeRequests()
+     */
+    public boolean isPaused() {
+        Util.assertMainThread();
+        return requestTracker.isPaused();
+    }
+
+    /**
+     * Cancels any in progress loads, but does not clear resources of completed loads.
+     * <p>
+     * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+     * manager is paused to complete. RequestManagers attached to Fragments and Activities
+     * automatically resume onStart().
+     *
+     * @see #isPaused()
+     * @see #resumeRequests()
+     */
+    public void pauseRequests() {
+        Util.assertMainThread();
+        requestTracker.pauseRequests();
+    }
+
+    /**
+     * Cancels any in progress loads and clears resources of completed loads.
+     * <p>
+     * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+     * manager is paused to complete. RequestManagers attached to Fragments and Activities
+     * automatically resume onStart().
+     * <p>
+     * <p>This will release the memory used by completed bitmaps but leaves them in any configured
+     * caches. When an #{@link android.app.Activity} receives #{@link
+     * android.app.Activity#onTrimMemory(int)} at a level of #{@link
+     * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep
+     * your process alive longer.
+     *
+     * @see #isPaused()
+     * @see #resumeRequests()
+     */
+    public void pauseAllRequests() {
+        Util.assertMainThread();
+        requestTracker.pauseAllRequests();
+    }
+
+    /**
+     * Performs {@link #pauseRequests()} recursively for all managers that are contextually
+     * descendant to this manager based on the Activity/Fragment hierarchy:
+     * <p>
+     * <ul>
+     * <li>When pausing on an Activity all attached fragments will also get paused.
+     * <li>When pausing on an attached Fragment all descendant fragments will also get paused.
+     * <li>When pausing on a detached Fragment or the application context only the current
+     * RequestManager is paused.
+     * </ul>
+     * <p>
+     * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
+     * pause, in this case either call pause on the Activity or use a support Fragment.
+     */
+    // Public API.
+    @SuppressWarnings({"WeakerAccess", "unused"})
+    public void pauseRequestsRecursive() {
+        Util.assertMainThread();
+        pauseRequests();
+        for (RequestManager requestManager : treeNode.getDescendants()) {
+            requestManager.pauseRequests();
+        }
+    }
+
+    /**
+     * Restarts any loads that have not yet completed.
+     *
+     * @see #isPaused()
+     * @see #pauseRequests()
+     */
+    public void resumeRequests() {
+        Util.assertMainThread();
+        requestTracker.resumeRequests();
+    }
+
+    /**
+     * Performs {@link #resumeRequests()} recursively for all managers that are contextually
+     * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
+     * are identical as for {@link #pauseRequestsRecursive()}.
+     */
+    // Public API.
+    @SuppressWarnings("unused")
+    public void resumeRequestsRecursive() {
+        Util.assertMainThread();
+        resumeRequests();
+        for (RequestManager requestManager : treeNode.getDescendants()) {
+            requestManager.resumeRequests();
+        }
+    }
+
+    /**
+     * Lifecycle callback that registers for connectivity events (if the
+     * android.permission.ACCESS_NETWORK_STATE permission is present) and restarts failed or paused
+     * requests.
+     */
+    @Override
+    public void onStart() {
+        resumeRequests();
+        targetTracker.onStart();
+    }
+
+    /**
+     * Lifecycle callback that unregisters for connectivity events (if the
+     * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.
+     */
+    @Override
+    public void onStop() {
+        pauseRequests();
+        targetTracker.onStop();
+    }
+
+    /**
+     * Lifecycle callback that cancels all in progress requests and clears and recycles resources for
+     * all completed requests.
+     */
+    @Override
+    public void onDestroy() {
+        targetTracker.onDestroy();
+        for (Target<?> target : targetTracker.getAll()) {
+            clear(target);
+        }
+        targetTracker.clear();
+        requestTracker.clearRequests();
+        lifecycle.removeListener(this);
+        lifecycle.removeListener(connectivityMonitor);
+        mainHandler.removeCallbacks(addSelfToLifecycle);
+        glide.unregisterRequestManager(this);
+    }
+
+    /**
+     * Attempts to always load the resource as a {@link android.graphics.Bitmap}, even if it could
+     * actually be animated.
+     *
+     * @return A new request builder for loading a {@link android.graphics.Bitmap}
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<Bitmap> asBitmap() {
+        return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
+    }
+
+    /**
+     * Attempts to always load the resource as a
+     * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+     * <p>
+     * <p> If the underlying data is not a GIF, this will fail. As a result, this should only be used
+     * if the model represents an animated GIF and the caller wants to interact with the GifDrawable
+     * directly. Normally using just {@link #asDrawable()} is sufficient because it will determine
+     * whether or not the given data represents an animated GIF and return the appropriate {@link
+     * Drawable}, animated or not, automatically. </p>
+     *
+     * @return A new request builder for loading a
+     * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<GifDrawable> asGif() {
+        return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
+    }
+
+    /**
+     * Attempts to always load the resource using any registered {@link
+     * com.bumptech.glide.load.ResourceDecoder}s that can decode any subclass of {@link Drawable}.
+     * <p>
+     * <p> By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
+     * GifDrawable}, but if additional decoders are registered for other {@link Drawable} subclasses,
+     * any of those subclasses may also be returned. </p>
+     *
+     * @return A new request builder for loading a {@link Drawable}.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<Drawable> asDrawable() {
+        return as(Drawable.class);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
+        return asDrawable().load(bitmap);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
+        return asDrawable().load(drawable);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable String string) {
+        return asDrawable().load(string);
+    }
 
-    RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
-      this.requestTracker = requestTracker;
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable Uri uri) {
+        return asDrawable().load(uri);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable File file) {
+        return asDrawable().load(file);
     }
 
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @SuppressWarnings("deprecation")
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable Integer resourceId) {
+        return asDrawable().load(resourceId);
+    }
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @SuppressWarnings("deprecation")
+    @CheckResult
+    @Override
+    @Deprecated
+    public RequestBuilder<Drawable> load(@Nullable URL url) {
+        return asDrawable().load(url);
+    }
+
+
+    /**
+     * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
     @Override
-    public void onConnectivityChanged(boolean isConnected) {
-      if (isConnected) {
-        requestTracker.restartRequests();
-      }
+    public RequestBuilder<Drawable> load(@Nullable byte[] model) {
+        return asDrawable().load(model);
+    }
+
+    /**
+     * A helper method equivalent to calling {@link #asDrawable()} and then {@link
+     * RequestBuilder#load(Object)} with the given model.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    @Override
+    public RequestBuilder<Drawable> load(@Nullable Object model) {
+        return asDrawable().load(model);
+    }
+
+    /**
+     * Attempts always load the resource into the cache and return the {@link File} containing the
+     * cached source data.
+     * <p>
+     * <p>This method is designed to work for remote data that is or will be cached using {@link
+     * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a
+     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not
+     * recommended.
+     *
+     * @return A new request builder for downloading content to cache and returning the cache File.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<File> downloadOnly() {
+        return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
+    }
+
+    /**
+     * A helper method equivalent to calling {@link #downloadOnly()} ()} and then {@link
+     * RequestBuilder#load(Object)} with the given model.
+     *
+     * @return A new request builder for loading a {@link Drawable} using the given model.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<File> download(@Nullable Object model) {
+        return downloadOnly().load(model);
+    }
+
+    /**
+     * Attempts to always load a {@link File} containing the resource, either using a file path
+     * obtained from the media store (for local images/videos), or using Glide's disk cache
+     * (for remote images/videos).
+     * <p>
+     * <p>For remote content, prefer {@link #downloadOnly()}.
+     *
+     * @return A new request builder for obtaining File paths to content.
+     */
+    @NonNull
+    @CheckResult
+    public RequestBuilder<File> asFile() {
+        return as(File.class).apply(skipMemoryCacheOf(true));
+    }
+
+    /**
+     * Attempts to load the resource using any registered
+     * {@link com.bumptech.glide.load.ResourceDecoder}s
+     * that can decode the given resource class or any subclass of the given resource class.
+     *
+     * @param resourceClass The resource to decode.
+     * @return A new request builder for loading the given resource class.
+     */
+    @NonNull
+    @CheckResult
+    public <ResourceType> RequestBuilder<ResourceType> as(
+            @NonNull Class<ResourceType> resourceClass) {
+        return new RequestBuilder<>(glide, this, resourceClass, context);
+    }
+
+    /**
+     * Cancel any pending loads Glide may have for the view and free any resources that may have been
+     * loaded for the view.
+     * <p>
+     * <p> Note that this will only work if {@link View#setTag(Object)} is not called on this view
+     * outside of Glide. </p>
+     *
+     * @param view The view to cancel loads and free resources for.
+     * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
+     *                                  tag.
+     * @see #clear(Target)
+     */
+    public void clear(@NonNull View view) {
+        clear(new ClearTarget(view));
+    }
+
+    /**
+     * Cancel any pending loads Glide may have for the target and free any resources (such as
+     * {@link Bitmap}s) that may have been loaded for the target so they may be reused.
+     *
+     * @param target The Target to cancel loads for.
+     */
+    public void clear(@Nullable final Target<?> target) {
+        if (target == null) {
+            return;
+        }
+
+        if (Util.isOnMainThread()) {
+            untrackOrDelegate(target);
+        } else {
+            mainHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    clear(target);
+                }
+            });
+        }
     }
-  }
 
-  private static class ClearTarget extends ViewTarget<View, Object> {
+    private void untrackOrDelegate(@NonNull Target<?> target) {
+        boolean isOwnedByUs = untrack(target);
+        // We'll end up here if the Target was cleared after the RequestManager that started the request
+        // is destroyed. That can happen for at least two reasons:
+        // 1. We call clear() on a background thread using something other than Application Context
+        // RequestManager.
+        // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
+        // Fragment is destroyed, starts a load with it, and then clears that load with a different
+        // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
+        //
+        // #1 is always an error. At best the caller is leaking memory briefly in something like an
+        // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
+        // time if they do something like reference the Activity RequestManager in a long lived
+        // background thread or task.
+        //
+        // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
+        // the corresponding Activity or Fragment is destroyed because retaining any reference to the
+        // RequestManager leaks memory. It's possible that there's some brief period of time during or
+        // immediately after onDestroy where this is reasonable, but I can't think of why.
+        if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
+            Request request = target.getRequest();
+            target.setRequest(null);
+            request.clear();
+        }
+    }
+
+    boolean untrack(@NonNull Target<?> target) {
+        Request request = target.getRequest();
+        // If the Target doesn't have a request, it's already been cleared.
+        if (request == null) {
+            return true;
+        }
+
+        if (requestTracker.clearRemoveAndRecycle(request)) {
+            targetTracker.untrack(target);
+            target.setRequest(null);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    void track(@NonNull Target<?> target, @NonNull Request request) {
+        targetTracker.track(target);
+        requestTracker.runRequest(request);
+    }
+
+    RequestOptions getDefaultRequestOptions() {
+        return requestOptions;
+    }
 
-    ClearTarget(@NonNull View view) {
-      super(view);
+    @NonNull
+    <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
+        return glide.getGlideContext().getDefaultTransitionOptions(transcodeClass);
     }
 
     @Override
-    public void onResourceReady(@NonNull Object resource,
-        @Nullable Transition<? super Object> transition) {
-      // Do nothing.
+    public String toString() {
+        return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
+    }
+
+    private static class RequestManagerConnectivityListener implements ConnectivityMonitor
+            .ConnectivityListener {
+        private final RequestTracker requestTracker;
+
+        RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
+            this.requestTracker = requestTracker;
+        }
+
+        @Override
+        public void onConnectivityChanged(boolean isConnected) {
+            if (isConnected) {
+                requestTracker.restartRequests();
+            }
+        }
+    }
+
+    private static class ClearTarget extends ViewTarget<View, Object> {
+
+        ClearTarget(@NonNull View view) {
+            super(view);
+        }
+
+        @Override
+        public void onResourceReady(@NonNull Object resource,
+                                    @Nullable Transition<? super Object> transition) {
+            // Do nothing.
+        }
     }
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index dcb320c2d..6f7dc1f0b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -5,6 +5,7 @@
 import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
 import android.util.Log;
+
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -21,6 +22,7 @@
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
+
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
@@ -29,496 +31,504 @@
  * Responsible for starting loads and managing active and cached resources.
  */
 public class Engine implements EngineJobListener,
-    MemoryCache.ResourceRemovedListener,
-    EngineResource.ResourceListener {
-  private static final String TAG = "Engine";
-  private static final int JOB_POOL_SIZE = 150;
-  private final Jobs jobs;
-  private final EngineKeyFactory keyFactory;
-  private final MemoryCache cache;
-  private final EngineJobFactory engineJobFactory;
-  private final ResourceRecycler resourceRecycler;
-  private final LazyDiskCacheProvider diskCacheProvider;
-  private final DecodeJobFactory decodeJobFactory;
-  private final ActiveResources activeResources;
-
-  public Engine(
-      MemoryCache memoryCache,
-      DiskCache.Factory diskCacheFactory,
-      GlideExecutor diskCacheExecutor,
-      GlideExecutor sourceExecutor,
-      GlideExecutor sourceUnlimitedExecutor,
-      GlideExecutor animationExecutor,
-      boolean isActiveResourceRetentionAllowed) {
-    this(
-        memoryCache,
-        diskCacheFactory,
-        diskCacheExecutor,
-        sourceExecutor,
-        sourceUnlimitedExecutor,
-        animationExecutor,
+        MemoryCache.ResourceRemovedListener,
+        EngineResource.ResourceListener {
+    private static final String TAG = "Engine";
+    private static final int JOB_POOL_SIZE = 150;
+    private final Jobs jobs;
+    private final EngineKeyFactory keyFactory;
+    private final MemoryCache cache;
+    private final EngineJobFactory engineJobFactory;
+    private final ResourceRecycler resourceRecycler;
+    private final LazyDiskCacheProvider diskCacheProvider;
+    private final DecodeJobFactory decodeJobFactory;
+    private final ActiveResources activeResources;
+
+    public Engine(
+            MemoryCache memoryCache,
+            DiskCache.Factory diskCacheFactory,
+            GlideExecutor diskCacheExecutor,
+            GlideExecutor sourceExecutor,
+            GlideExecutor sourceUnlimitedExecutor,
+            GlideExecutor animationExecutor,
+            boolean isActiveResourceRetentionAllowed) {
+        this(
+                memoryCache,
+                diskCacheFactory,
+                diskCacheExecutor,
+                sourceExecutor,
+                sourceUnlimitedExecutor,
+                animationExecutor,
         /*jobs=*/ null,
         /*keyFactory=*/ null,
         /*activeResources=*/ null,
         /*engineJobFactory=*/ null,
         /*decodeJobFactory=*/ null,
         /*resourceRecycler=*/ null,
-        isActiveResourceRetentionAllowed);
-  }
-
-  @VisibleForTesting
-  Engine(MemoryCache cache,
-      DiskCache.Factory diskCacheFactory,
-      GlideExecutor diskCacheExecutor,
-      GlideExecutor sourceExecutor,
-      GlideExecutor sourceUnlimitedExecutor,
-      GlideExecutor animationExecutor,
-      Jobs jobs,
-      EngineKeyFactory keyFactory,
-      ActiveResources activeResources,
-      EngineJobFactory engineJobFactory,
-      DecodeJobFactory decodeJobFactory,
-      ResourceRecycler resourceRecycler,
-      boolean isActiveResourceRetentionAllowed) {
-    this.cache = cache;
-    this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
-
-    if (activeResources == null) {
-      activeResources = new ActiveResources(isActiveResourceRetentionAllowed);
+                isActiveResourceRetentionAllowed);
     }
-    this.activeResources = activeResources;
-    activeResources.setListener(this);
 
-    if (keyFactory == null) {
-      keyFactory = new EngineKeyFactory();
-    }
-    this.keyFactory = keyFactory;
+    @VisibleForTesting
+    Engine(MemoryCache cache,
+           DiskCache.Factory diskCacheFactory,
+           GlideExecutor diskCacheExecutor,
+           GlideExecutor sourceExecutor,
+           GlideExecutor sourceUnlimitedExecutor,
+           GlideExecutor animationExecutor,
+           Jobs jobs,
+           EngineKeyFactory keyFactory,
+           ActiveResources activeResources,
+           EngineJobFactory engineJobFactory,
+           DecodeJobFactory decodeJobFactory,
+           ResourceRecycler resourceRecycler,
+           boolean isActiveResourceRetentionAllowed) {
+        this.cache = cache;
+        this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
+
+        if (activeResources == null) {
+            activeResources = new ActiveResources(isActiveResourceRetentionAllowed);
+        }
+        this.activeResources = activeResources;
+        activeResources.setListener(this);
 
-    if (jobs == null) {
-      jobs = new Jobs();
-    }
-    this.jobs = jobs;
+        if (keyFactory == null) {
+            keyFactory = new EngineKeyFactory();
+        }
+        this.keyFactory = keyFactory;
+
+        if (jobs == null) {
+            jobs = new Jobs();
+        }
+        this.jobs = jobs;
 
-    if (engineJobFactory == null) {
-      engineJobFactory =
-          new EngineJobFactory(
-              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);
+        if (engineJobFactory == null) {
+            engineJobFactory =
+                    new EngineJobFactory(
+                            diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);
+        }
+        this.engineJobFactory = engineJobFactory;
+
+        if (decodeJobFactory == null) {
+            decodeJobFactory = new DecodeJobFactory(diskCacheProvider);
+        }
+        this.decodeJobFactory = decodeJobFactory;
+
+        if (resourceRecycler == null) {
+            resourceRecycler = new ResourceRecycler();
+        }
+        this.resourceRecycler = resourceRecycler;
+
+        cache.setResourceRemovedListener(this);
     }
-    this.engineJobFactory = engineJobFactory;
 
-    if (decodeJobFactory == null) {
-      decodeJobFactory = new DecodeJobFactory(diskCacheProvider);
+    /**
+     * Starts a load for the given arguments.
+     * <p>
+     * <p>Must be called on the main thread.
+     * <p>
+     * <p>The flow for any request is as follows:
+     * <ul>
+     * <li>Check the current set of actively used resources, return the active resource if
+     * present, and move any newly inactive resources into the memory cache.</li>
+     * <li>Check the memory cache and provide the cached resource if present.</li>
+     * <li>Check the current set of in progress loads and add the cb to the in progress load if
+     * one is present.</li>
+     * <li>Start a new load.</li>
+     * </ul>
+     * <p>
+     * <p>Active resources are those that have been provided to at least one request and have not yet
+     * been released. Once all consumers of a resource have released that resource, the resource then
+     * goes to cache. If the resource is ever returned to a new consumer from cache, it is re-added to
+     * the active resources. If the resource is evicted from the cache, its resources are recycled and
+     * re-used if possible and the resource is discarded. There is no strict requirement that
+     * consumers release their resources so active resources are held weakly.
+     *
+     * @param width  The target width in pixels of the desired resource.
+     * @param height The target height in pixels of the desired resource.
+     * @param cb     The callback that will be called when the load completes.
+     */
+    public <R> LoadStatus load(
+            GlideContext glideContext,
+            Object model,
+            Key signature,
+            int width,
+            int height,
+            Class<?> resourceClass,
+            Class<R> transcodeClass,
+            Priority priority,
+            DiskCacheStrategy diskCacheStrategy,
+            Map<Class<?>, Transformation<?>> transformations,
+            boolean isTransformationRequired,
+            boolean isScaleOnlyOrNoTransform,
+            Options options,
+            boolean isMemoryCacheable,
+            boolean useUnlimitedSourceExecutorPool,
+            boolean useAnimationPool,
+            boolean onlyRetrieveFromCache,
+            ResourceCallback cb) {
+        Util.assertMainThread();
+        long startTime = LogTime.getLogTime();
+
+        EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
+                resourceClass, transcodeClass, options);
+
+        EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
+        if (active != null) {
+            cb.onResourceReady(active, DataSource.MEMORY_CACHE);
+            if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                logWithTimeAndKey("Loaded resource from active resources", startTime, key);
+            }
+            return null;
+        }
+
+        EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
+        if (cached != null) {
+            cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
+            if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                logWithTimeAndKey("Loaded resource from cache", startTime, key);
+            }
+            return null;
+        }
+
+        EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
+        if (current != null) {
+            current.addCallback(cb);
+            if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                logWithTimeAndKey("Added to existing load", startTime, key);
+            }
+            return new LoadStatus(cb, current);
+        }
+
+        EngineJob<R> engineJob =
+                engineJobFactory.build(
+                        key,
+                        isMemoryCacheable,
+                        useUnlimitedSourceExecutorPool,
+                        useAnimationPool,
+                        onlyRetrieveFromCache);
+
+        DecodeJob<R> decodeJob =
+                decodeJobFactory.build(
+                        glideContext,
+                        model,
+                        key,
+                        signature,
+                        width,
+                        height,
+                        resourceClass,
+                        transcodeClass,
+                        priority,
+                        diskCacheStrategy,
+                        transformations,
+                        isTransformationRequired,
+                        isScaleOnlyOrNoTransform,
+                        onlyRetrieveFromCache,
+                        options,
+                        engineJob);
+
+        jobs.put(key, engineJob);
+
+        engineJob.addCallback(cb);
+        engineJob.start(decodeJob);
+
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            logWithTimeAndKey("Started new load", startTime, key);
+        }
+        return new LoadStatus(cb, engineJob);
     }
-    this.decodeJobFactory = decodeJobFactory;
 
-    if (resourceRecycler == null) {
-      resourceRecycler = new ResourceRecycler();
+    private static void logWithTimeAndKey(String log, long startTime, Key key) {
+        Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
     }
-    this.resourceRecycler = resourceRecycler;
-
-    cache.setResourceRemovedListener(this);
-  }
-
-  /**
-   * Starts a load for the given arguments.
-   *
-   * <p>Must be called on the main thread.
-   *
-   * <p>The flow for any request is as follows:
-   * <ul>
-   *   <li>Check the current set of actively used resources, return the active resource if
-   *   present, and move any newly inactive resources into the memory cache.</li>
-   *   <li>Check the memory cache and provide the cached resource if present.</li>
-   *   <li>Check the current set of in progress loads and add the cb to the in progress load if
-   *   one is present.</li>
-   *   <li>Start a new load.</li>
-   * </ul>
-   *
-   * <p>Active resources are those that have been provided to at least one request and have not yet
-   * been released. Once all consumers of a resource have released that resource, the resource then
-   * goes to cache. If the resource is ever returned to a new consumer from cache, it is re-added to
-   * the active resources. If the resource is evicted from the cache, its resources are recycled and
-   * re-used if possible and the resource is discarded. There is no strict requirement that
-   * consumers release their resources so active resources are held weakly.
-   *
-   * @param width  The target width in pixels of the desired resource.
-   * @param height The target height in pixels of the desired resource.
-   * @param cb     The callback that will be called when the load completes.
-   */
-  public <R> LoadStatus load(
-      GlideContext glideContext,
-      Object model,
-      Key signature,
-      int width,
-      int height,
-      Class<?> resourceClass,
-      Class<R> transcodeClass,
-      Priority priority,
-      DiskCacheStrategy diskCacheStrategy,
-      Map<Class<?>, Transformation<?>> transformations,
-      boolean isTransformationRequired,
-      boolean isScaleOnlyOrNoTransform,
-      Options options,
-      boolean isMemoryCacheable,
-      boolean useUnlimitedSourceExecutorPool,
-      boolean useAnimationPool,
-      boolean onlyRetrieveFromCache,
-      ResourceCallback cb) {
-    Util.assertMainThread();
-    long startTime = LogTime.getLogTime();
-
-    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
-        resourceClass, transcodeClass, options);
-
-    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
-    if (active != null) {
-      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
-      }
-      return null;
+
+    @Nullable
+    private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
+        if (!isMemoryCacheable) {
+            return null;
+        }
+        EngineResource<?> active = activeResources.get(key);
+        if (active != null) {
+            active.acquire();
+        }
+
+        return active;
     }
 
-    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
-    if (cached != null) {
-      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from cache", startTime, key);
-      }
-      return null;
+    private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
+        if (!isMemoryCacheable) {
+            return null;
+        }
+
+        EngineResource<?> cached = getEngineResourceFromCache(key);
+        if (cached != null) {
+            cached.acquire();
+            activeResources.activate(key, cached);
+        }
+        return cached;
     }
 
-    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
-    if (current != null) {
-      current.addCallback(cb);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Added to existing load", startTime, key);
-      }
-      return new LoadStatus(cb, current);
+    private EngineResource<?> getEngineResourceFromCache(Key key) {
+        Resource<?> cached = cache.remove(key);
+
+        final EngineResource<?> result;
+        if (cached == null) {
+            result = null;
+        } else if (cached instanceof EngineResource) {
+            // Save an object allocation if we've cached an EngineResource (the typical case).
+            result = (EngineResource<?>) cached;
+        } else {
+            result = new EngineResource<>(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/);
+        }
+        return result;
     }
 
-    EngineJob<R> engineJob =
-        engineJobFactory.build(
-            key,
-            isMemoryCacheable,
-            useUnlimitedSourceExecutorPool,
-            useAnimationPool,
-            onlyRetrieveFromCache);
-
-    DecodeJob<R> decodeJob =
-        decodeJobFactory.build(
-            glideContext,
-            model,
-            key,
-            signature,
-            width,
-            height,
-            resourceClass,
-            transcodeClass,
-            priority,
-            diskCacheStrategy,
-            transformations,
-            isTransformationRequired,
-            isScaleOnlyOrNoTransform,
-            onlyRetrieveFromCache,
-            options,
-            engineJob);
-
-    jobs.put(key, engineJob);
-
-    engineJob.addCallback(cb);
-    engineJob.start(decodeJob);
-
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      logWithTimeAndKey("Started new load", startTime, key);
+    public void release(Resource<?> resource) {
+        Util.assertMainThread();
+        if (resource instanceof EngineResource) {
+            ((EngineResource<?>) resource).release();
+        } else {
+            throw new IllegalArgumentException("Cannot release anything but an EngineResource");
+        }
     }
-    return new LoadStatus(cb, engineJob);
-  }
 
-  private static void logWithTimeAndKey(String log, long startTime, Key key) {
-    Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
-  }
+    @SuppressWarnings("unchecked")
+    @Override
+    public void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
+        Util.assertMainThread();
+        // A null resource indicates that the load failed, usually due to an exception.
+        if (resource != null) {
+            resource.setResourceListener(key, this);
+
+            if (resource.isCacheable()) {
+                activeResources.activate(key, resource);
+            }
+        }
 
-  @Nullable
-  private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
-    if (!isMemoryCacheable) {
-      return null;
-    }
-    EngineResource<?> active = activeResources.get(key);
-    if (active != null) {
-      active.acquire();
+        jobs.removeIfCurrent(key, engineJob);
     }
 
-    return active;
-  }
+    @Override
+    public void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
+        Util.assertMainThread();
 
-  private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
-    if (!isMemoryCacheable) {
-      return null;
+        jobs.removeIfCurrent(key, engineJob);
     }
 
-    EngineResource<?> cached = getEngineResourceFromCache(key);
-    if (cached != null) {
-      cached.acquire();
-      activeResources.activate(key, cached);
-    }
-    return cached;
-  }
-
-  private EngineResource<?> getEngineResourceFromCache(Key key) {
-    Resource<?> cached = cache.remove(key);
-
-    final EngineResource<?> result;
-    if (cached == null) {
-      result = null;
-    } else if (cached instanceof EngineResource) {
-      // Save an object allocation if we've cached an EngineResource (the typical case).
-      result = (EngineResource<?>) cached;
-    } else {
-      result = new EngineResource<>(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/);
-    }
-    return result;
-  }
-
-  public void release(Resource<?> resource) {
-    Util.assertMainThread();
-    if (resource instanceof EngineResource) {
-      ((EngineResource<?>) resource).release();
-    } else {
-      throw new IllegalArgumentException("Cannot release anything but an EngineResource");
-    }
-  }
-
-  @SuppressWarnings("unchecked")
-  @Override
-  public void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
-    Util.assertMainThread();
-    // A null resource indicates that the load failed, usually due to an exception.
-    if (resource != null) {
-      resource.setResourceListener(key, this);
-
-      if (resource.isCacheable()) {
-        activeResources.activate(key, resource);
-      }
+    @Override
+    public void onResourceRemoved(@NonNull final Resource<?> resource) {
+        Util.assertMainThread();
+        resourceRecycler.recycle(resource);
     }
 
-    jobs.removeIfCurrent(key, engineJob);
-  }
-
-  @Override
-  public void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
-    Util.assertMainThread();
-
-    jobs.removeIfCurrent(key, engineJob);
-  }
-
-  @Override
-  public void onResourceRemoved(@NonNull final Resource<?> resource) {
-    Util.assertMainThread();
-    resourceRecycler.recycle(resource);
-  }
-
-  @Override
-  public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
-    Util.assertMainThread();
-    activeResources.deactivate(cacheKey);
-    if (resource.isCacheable()) {
-      cache.put(cacheKey, resource);
-    } else {
-      resourceRecycler.recycle(resource);
+    @Override
+    public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
+        Util.assertMainThread();
+        activeResources.deactivate(cacheKey);
+        if (resource.isCacheable()) {
+            cache.put(cacheKey, resource);
+        } else {
+            resourceRecycler.recycle(resource);
+        }
     }
-  }
-
-  public void clearDiskCache() {
-    diskCacheProvider.getDiskCache().clear();
-  }
-
-  @VisibleForTesting
-  public void shutdown() {
-    engineJobFactory.shutdown();
-    diskCacheProvider.clearDiskCacheIfCreated();
-    activeResources.shutdown();
-  }
-
-  /**
-   * Allows a request to indicate it no longer is interested in a given load.
-   */
-  public static class LoadStatus {
-    private final EngineJob<?> engineJob;
-    private final ResourceCallback cb;
-
-    LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
-      this.cb = cb;
-      this.engineJob = engineJob;
+
+    public void clearDiskCache() {
+        diskCacheProvider.getDiskCache().clear();
     }
 
-    public void cancel() {
-      engineJob.removeCallback(cb);
+    @VisibleForTesting
+    public void shutdown() {
+        engineJobFactory.shutdown();
+        diskCacheProvider.clearDiskCacheIfCreated();
+        activeResources.shutdown();
     }
-  }
 
-  private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
+    /**
+     * Allows a request to indicate it no longer is interested in a given load.
+     */
+    public static class LoadStatus {
+        private final EngineJob<?> engineJob;
+        private final ResourceCallback cb;
 
-    private final DiskCache.Factory factory;
-    private volatile DiskCache diskCache;
+        LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
+            this.cb = cb;
+            this.engineJob = engineJob;
+        }
 
-    LazyDiskCacheProvider(DiskCache.Factory factory) {
-      this.factory = factory;
+        public void cancel() {
+            engineJob.removeCallback(cb);
+        }
     }
 
-    @VisibleForTesting
-    synchronized void clearDiskCacheIfCreated() {
-      if (diskCache == null) {
-        return;
-      }
-      diskCache.clear();
-    }
+    private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
 
-    @Override
-    public DiskCache getDiskCache() {
-      if (diskCache == null) {
-        synchronized (this) {
-          if (diskCache == null) {
-            diskCache = factory.build();
-          }
-          if (diskCache == null) {
-            diskCache = new DiskCacheAdapter();
-          }
+        private final DiskCache.Factory factory;
+        private volatile DiskCache diskCache;
+
+        LazyDiskCacheProvider(DiskCache.Factory factory) {
+            this.factory = factory;
         }
-      }
-      return diskCache;
-    }
-  }
-
-  @VisibleForTesting
-  static class DecodeJobFactory {
-    @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
-    @Synthetic final Pools.Pool<DecodeJob<?>> pool =
-        FactoryPools.simple(JOB_POOL_SIZE,
-            new FactoryPools.Factory<DecodeJob<?>>() {
-          @Override
-          public DecodeJob<?> create() {
-            return new DecodeJob<>(diskCacheProvider, pool);
-          }
-        });
-    private int creationOrder;
-
-    DecodeJobFactory(DecodeJob.DiskCacheProvider diskCacheProvider) {
-      this.diskCacheProvider = diskCacheProvider;
-    }
 
-    @SuppressWarnings("unchecked")
-    <R> DecodeJob<R> build(GlideContext glideContext,
-        Object model,
-        EngineKey loadKey,
-        Key signature,
-        int width,
-        int height,
-        Class<?> resourceClass,
-        Class<R> transcodeClass,
-        Priority priority,
-        DiskCacheStrategy diskCacheStrategy,
-        Map<Class<?>, Transformation<?>> transformations,
-        boolean isTransformationRequired,
-        boolean isScaleOnlyOrNoTransform,
-        boolean onlyRetrieveFromCache,
-        Options options,
-        DecodeJob.Callback<R> callback) {
-      DecodeJob<R> result = Preconditions.checkNotNull((DecodeJob<R>) pool.acquire());
-      return result.init(
-          glideContext,
-          model,
-          loadKey,
-          signature,
-          width,
-          height,
-          resourceClass,
-          transcodeClass,
-          priority,
-          diskCacheStrategy,
-          transformations,
-          isTransformationRequired,
-          isScaleOnlyOrNoTransform,
-          onlyRetrieveFromCache,
-          options,
-          callback,
-          creationOrder++);
-    }
-  }
-
-  @VisibleForTesting
-  static class EngineJobFactory {
-    @Synthetic final GlideExecutor diskCacheExecutor;
-    @Synthetic final GlideExecutor sourceExecutor;
-    @Synthetic final GlideExecutor sourceUnlimitedExecutor;
-    @Synthetic final GlideExecutor animationExecutor;
-    @Synthetic final EngineJobListener listener;
-    @Synthetic final Pools.Pool<EngineJob<?>> pool =
-        FactoryPools.simple(
-            JOB_POOL_SIZE,
-            new FactoryPools.Factory<EngineJob<?>>() {
-              @Override
-              public EngineJob<?> create() {
-                return new EngineJob<>(
-                    diskCacheExecutor,
-                    sourceExecutor,
-                    sourceUnlimitedExecutor,
-                    animationExecutor,
-                    listener,
-                    pool);
-              }
-            });
-
-    EngineJobFactory(
-        GlideExecutor diskCacheExecutor,
-        GlideExecutor sourceExecutor,
-        GlideExecutor sourceUnlimitedExecutor,
-        GlideExecutor animationExecutor,
-        EngineJobListener listener) {
-      this.diskCacheExecutor = diskCacheExecutor;
-      this.sourceExecutor = sourceExecutor;
-      this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
-      this.animationExecutor = animationExecutor;
-      this.listener = listener;
+        @VisibleForTesting
+        synchronized void clearDiskCacheIfCreated() {
+            if (diskCache == null) {
+                return;
+            }
+            diskCache.clear();
+        }
+
+        @Override
+        public DiskCache getDiskCache() {
+            if (diskCache == null) {
+                synchronized (this) {
+                    if (diskCache == null) {
+                        diskCache = factory.build();
+                    }
+                    if (diskCache == null) {
+                        diskCache = new DiskCacheAdapter();
+                    }
+                }
+            }
+            return diskCache;
+        }
     }
 
     @VisibleForTesting
-    void shutdown() {
-      shutdownAndAwaitTermination(diskCacheExecutor);
-      shutdownAndAwaitTermination(sourceExecutor);
-      shutdownAndAwaitTermination(sourceUnlimitedExecutor);
-      shutdownAndAwaitTermination(animationExecutor);
-    }
+    static class DecodeJobFactory {
+        @Synthetic
+        final DecodeJob.DiskCacheProvider diskCacheProvider;
+        @Synthetic
+        final Pools.Pool<DecodeJob<?>> pool =
+                FactoryPools.simple(JOB_POOL_SIZE,
+                        new FactoryPools.Factory<DecodeJob<?>>() {
+                            @Override
+                            public DecodeJob<?> create() {
+                                return new DecodeJob<>(diskCacheProvider, pool);
+                            }
+                        });
+        private int creationOrder;
+
+        DecodeJobFactory(DecodeJob.DiskCacheProvider diskCacheProvider) {
+            this.diskCacheProvider = diskCacheProvider;
+        }
 
-    @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(
-        Key key,
-        boolean isMemoryCacheable,
-        boolean useUnlimitedSourceGeneratorPool,
-        boolean useAnimationPool,
-        boolean onlyRetrieveFromCache) {
-      EngineJob<R> result = Preconditions.checkNotNull((EngineJob<R>) pool.acquire());
-      return result.init(
-          key,
-          isMemoryCacheable,
-          useUnlimitedSourceGeneratorPool,
-          useAnimationPool,
-          onlyRetrieveFromCache);
+        @SuppressWarnings("unchecked")
+        <R> DecodeJob<R> build(GlideContext glideContext,
+                               Object model,
+                               EngineKey loadKey,
+                               Key signature,
+                               int width,
+                               int height,
+                               Class<?> resourceClass,
+                               Class<R> transcodeClass,
+                               Priority priority,
+                               DiskCacheStrategy diskCacheStrategy,
+                               Map<Class<?>, Transformation<?>> transformations,
+                               boolean isTransformationRequired,
+                               boolean isScaleOnlyOrNoTransform,
+                               boolean onlyRetrieveFromCache,
+                               Options options,
+                               DecodeJob.Callback<R> callback) {
+            DecodeJob<R> result = Preconditions.checkNotNull((DecodeJob<R>) pool.acquire());
+            return result.init(
+                    glideContext,
+                    model,
+                    loadKey,
+                    signature,
+                    width,
+                    height,
+                    resourceClass,
+                    transcodeClass,
+                    priority,
+                    diskCacheStrategy,
+                    transformations,
+                    isTransformationRequired,
+                    isScaleOnlyOrNoTransform,
+                    onlyRetrieveFromCache,
+                    options,
+                    callback,
+                    creationOrder++);
+        }
     }
 
-    private static void shutdownAndAwaitTermination(ExecutorService pool) {
-      long shutdownSeconds = 5;
-      pool.shutdown();
-      try {
-        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
-          pool.shutdownNow();
-          if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
-            throw new RuntimeException("Failed to shutdown");
-          }
+    @VisibleForTesting
+    static class EngineJobFactory {
+        @Synthetic
+        final GlideExecutor diskCacheExecutor;
+        @Synthetic
+        final GlideExecutor sourceExecutor;
+        @Synthetic
+        final GlideExecutor sourceUnlimitedExecutor;
+        @Synthetic
+        final GlideExecutor animationExecutor;
+        @Synthetic
+        final EngineJobListener listener;
+        @Synthetic
+        final Pools.Pool<EngineJob<?>> pool =
+                FactoryPools.simple(
+                        JOB_POOL_SIZE,
+                        new FactoryPools.Factory<EngineJob<?>>() {
+                            @Override
+                            public EngineJob<?> create() {
+                                return new EngineJob<>(
+                                        diskCacheExecutor,
+                                        sourceExecutor,
+                                        sourceUnlimitedExecutor,
+                                        animationExecutor,
+                                        listener,
+                                        pool);
+                            }
+                        });
+
+        EngineJobFactory(
+                GlideExecutor diskCacheExecutor,
+                GlideExecutor sourceExecutor,
+                GlideExecutor sourceUnlimitedExecutor,
+                GlideExecutor animationExecutor,
+                EngineJobListener listener) {
+            this.diskCacheExecutor = diskCacheExecutor;
+            this.sourceExecutor = sourceExecutor;
+            this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+            this.animationExecutor = animationExecutor;
+            this.listener = listener;
+        }
+
+        @VisibleForTesting
+        void shutdown() {
+            shutdownAndAwaitTermination(diskCacheExecutor);
+            shutdownAndAwaitTermination(sourceExecutor);
+            shutdownAndAwaitTermination(sourceUnlimitedExecutor);
+            shutdownAndAwaitTermination(animationExecutor);
+        }
+
+        @SuppressWarnings("unchecked")
+        <R> EngineJob<R> build(
+                Key key,
+                boolean isMemoryCacheable,
+                boolean useUnlimitedSourceGeneratorPool,
+                boolean useAnimationPool,
+                boolean onlyRetrieveFromCache) {
+            EngineJob<R> result = Preconditions.checkNotNull((EngineJob<R>) pool.acquire());
+            return result.init(
+                    key,
+                    isMemoryCacheable,
+                    useUnlimitedSourceGeneratorPool,
+                    useAnimationPool,
+                    onlyRetrieveFromCache);
+        }
+
+        private static void shutdownAndAwaitTermination(ExecutorService pool) {
+            long shutdownSeconds = 5;
+            pool.shutdown();
+            try {
+                if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+                    pool.shutdownNow();
+                    if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+                        throw new RuntimeException("Failed to shutdown");
+                    }
+                }
+            } catch (InterruptedException ie) {
+                throw new RuntimeException(ie);
+            }
         }
-      } catch (InterruptedException ie) {
-        throw new RuntimeException(ie);
-      }
     }
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
index cd6a43151..97f503267 100644
--- a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -7,152 +7,152 @@
  * if the single primary request fails.
  */
 public final class ErrorRequestCoordinator implements RequestCoordinator,
-    Request {
-
-  @Nullable
-  private final RequestCoordinator parent;
-  private Request primary;
-  private Request error;
-
-  public ErrorRequestCoordinator(@Nullable RequestCoordinator parent) {
-    this.parent = parent;
-  }
-
-  public void setRequests(Request primary, Request error) {
-    this.primary = primary;
-    this.error = error;
-  }
-
-  @Override
-  public void begin() {
-    if (!primary.isRunning()) {
-      primary.begin();
-    }
-  }
-
-  @Override
-  public void pause() {
-    if (!primary.isFailed()) {
-      primary.pause();
-    }
-    if (error.isRunning()) {
-      error.pause();
-    }
-  }
-
-  @Override
-  public void clear() {
-    primary.clear();
-    // Don't check primary.isFailed() here because it will have been reset by the clear call
-    // immediately before this.
-    if (error.isRunning()) {
-      error.clear();
-    }
-  }
-
-  @Override
-  public boolean isPaused() {
-    return primary.isFailed() ? error.isPaused() : primary.isPaused();
-  }
-
-  @Override
-  public boolean isRunning() {
-    return primary.isFailed() ? error.isRunning() : primary.isRunning();
-  }
-
-  @Override
-  public boolean isComplete() {
-    return primary.isFailed() ? error.isComplete() : primary.isComplete();
-  }
-
-  @Override
-  public boolean isResourceSet() {
-    return primary.isFailed() ? error.isResourceSet() : primary.isResourceSet();
-  }
-
-  @Override
-  public boolean isCancelled() {
-    return primary.isFailed() ? error.isCancelled() : primary.isCancelled();
-  }
-
-  @Override
-  public boolean isFailed() {
-    return primary.isFailed() && error.isFailed();
-  }
-
-  @Override
-  public void recycle() {
-    primary.recycle();
-    error.recycle();
-  }
-
-  @Override
-  public boolean isEquivalentTo(Request o) {
-    if (o instanceof ErrorRequestCoordinator) {
-      ErrorRequestCoordinator other = (ErrorRequestCoordinator) o;
-      return primary.isEquivalentTo(other.primary) && error.isEquivalentTo(other.error);
-    }
-    return false;
-  }
-
-  @Override
-  public boolean canSetImage(Request request) {
-    return parentCanSetImage() && isValidRequest(request);
-  }
-
-  private boolean parentCanSetImage() {
-    return parent == null || parent.canSetImage(this);
-  }
-
-  @Override
-  public boolean canNotifyStatusChanged(Request request) {
-    return parentCanNotifyStatusChanged() && isValidRequest(request);
-  }
-
-  @Override
-  public boolean canNotifyCleared(Request request) {
-    return parentCanNotifyCleared() && isValidRequest(request);
-  }
-
-  private boolean parentCanNotifyCleared() {
-    return parent == null || parent.canNotifyCleared(this);
-  }
-
-  private boolean parentCanNotifyStatusChanged() {
-    return parent == null || parent.canNotifyStatusChanged(this);
-  }
-
-  private boolean isValidRequest(Request request) {
-    return request.equals(primary) || (primary.isFailed() && request.equals(error));
-  }
-
-  @Override
-  public boolean isAnyResourceSet() {
-    return parentIsAnyResourceSet() || isResourceSet();
-  }
-
-  private boolean parentIsAnyResourceSet() {
-    return parent != null && parent.isAnyResourceSet();
-  }
-
-  @Override
-  public void onRequestSuccess(Request request) {
-    if (parent != null) {
-      parent.onRequestSuccess(this);
-    }
-  }
-
-  @Override
-  public void onRequestFailed(Request request) {
-    if (!request.equals(error)) {
-      if (!error.isRunning()) {
-        error.begin();
-      }
-      return;
-    }
-
-    if (parent != null) {
-      parent.onRequestFailed(this);
-    }
-  }
+        Request {
+
+    @Nullable
+    private final RequestCoordinator parent;
+    private Request primary;
+    private Request error;
+
+    public ErrorRequestCoordinator(@Nullable RequestCoordinator parent) {
+        this.parent = parent;
+    }
+
+    public void setRequests(Request primary, Request error) {
+        this.primary = primary;
+        this.error = error;
+    }
+
+    @Override
+    public void begin() {
+        if (!primary.isRunning()) {
+            primary.begin();
+        }
+    }
+
+    @Override
+    public void pause() {
+        if (!primary.isFailed()) {
+            primary.pause();
+        }
+        if (error.isRunning()) {
+            error.pause();
+        }
+    }
+
+    @Override
+    public void clear() {
+        primary.clear();
+        // Don't check primary.isFailed() here because it will have been reset by the clear call
+        // immediately before this.
+        if (error.isRunning()) {
+            error.clear();
+        }
+    }
+
+    @Override
+    public boolean isPaused() {
+        return primary.isFailed() ? error.isPaused() : primary.isPaused();
+    }
+
+    @Override
+    public boolean isRunning() {
+        return primary.isFailed() ? error.isRunning() : primary.isRunning();
+    }
+
+    @Override
+    public boolean isComplete() {
+        return primary.isFailed() ? error.isComplete() : primary.isComplete();
+    }
+
+    @Override
+    public boolean isResourceSet() {
+        return primary.isFailed() ? error.isResourceSet() : primary.isResourceSet();
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return primary.isFailed() ? error.isCancelled() : primary.isCancelled();
+    }
+
+    @Override
+    public boolean isFailed() {
+        return primary.isFailed() && error.isFailed();
+    }
+
+    @Override
+    public void recycle() {
+        primary.recycle();
+        error.recycle();
+    }
+
+    @Override
+    public boolean isEquivalentTo(Request o) {
+        if (o instanceof ErrorRequestCoordinator) {
+            ErrorRequestCoordinator other = (ErrorRequestCoordinator) o;
+            return primary.isEquivalentTo(other.primary) && error.isEquivalentTo(other.error);
+        }
+        return false;
+    }
+
+    @Override
+    public boolean canSetImage(Request request) {
+        return parentCanSetImage() && isValidRequest(request);
+    }
+
+    private boolean parentCanSetImage() {
+        return parent == null || parent.canSetImage(this);
+    }
+
+    @Override
+    public boolean canNotifyStatusChanged(Request request) {
+        return parentCanNotifyStatusChanged() && isValidRequest(request);
+    }
+
+    @Override
+    public boolean canNotifyCleared(Request request) {
+        return parentCanNotifyCleared() && isValidRequest(request);
+    }
+
+    private boolean parentCanNotifyCleared() {
+        return parent == null || parent.canNotifyCleared(this);
+    }
+
+    private boolean parentCanNotifyStatusChanged() {
+        return parent == null || parent.canNotifyStatusChanged(this);
+    }
+
+    private boolean isValidRequest(Request request) {
+        return request.equals(primary) || (primary.isFailed() && request.equals(error));
+    }
+
+    @Override
+    public boolean isAnyResourceSet() {
+        return parentIsAnyResourceSet() || isResourceSet();
+    }
+
+    private boolean parentIsAnyResourceSet() {
+        return parent != null && parent.isAnyResourceSet();
+    }
+
+    @Override
+    public void onRequestSuccess(Request request) {
+        if (parent != null) {
+            parent.onRequestSuccess(this);
+        }
+    }
+
+    @Override
+    public void onRequestFailed(Request request) {
+        if (!request.equals(error)) {
+            if (!error.isRunning()) {
+                error.begin();
+            }
+            return;
+        }
+
+        if (parent != null) {
+            parent.onRequestFailed(this);
+        }
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 1cc122df3..906c53b9a 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -8,6 +8,7 @@
 import android.support.annotation.Nullable;
 import android.support.v4.util.Pools;
 import android.util.Log;
+
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -32,616 +33,620 @@
  * @param <R> The type of the resource that will be transcoded from the loaded resource.
  */
 public final class SingleRequest<R> implements Request,
-    SizeReadyCallback,
-    ResourceCallback,
-    FactoryPools.Poolable {
-  /** Tag for logging internal events, not generally suitable for public use. */
-  private static final String TAG = "Request";
-  /** Tag for logging externally useful events (request completion, timing etc). */
-  private static final String GLIDE_TAG = "Glide";
-  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.simple(150,
-      new FactoryPools.Factory<SingleRequest<?>>() {
-        @Override
-        public SingleRequest<?> create() {
-          return new SingleRequest<Object>();
-        }
-      });
-  private boolean isCallingCallbacks;
-
-  private static final boolean IS_VERBOSE_LOGGABLE =
-      Log.isLoggable(TAG, Log.VERBOSE);
-
-  private enum Status {
+        SizeReadyCallback,
+        ResourceCallback,
+        FactoryPools.Poolable {
     /**
-     * Created but not yet running.
+     * Tag for logging internal events, not generally suitable for public use.
      */
-    PENDING,
+    private static final String TAG = "Request";
     /**
-     * In the process of fetching media.
+     * Tag for logging externally useful events (request completion, timing etc).
      */
-    RUNNING,
+    private static final String GLIDE_TAG = "Glide";
+    private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.simple(150,
+            new FactoryPools.Factory<SingleRequest<?>>() {
+                @Override
+                public SingleRequest<?> create() {
+                    return new SingleRequest<Object>();
+                }
+            });
+    private boolean isCallingCallbacks;
+
+    private static final boolean IS_VERBOSE_LOGGABLE =
+            Log.isLoggable(TAG, Log.VERBOSE);
+
+    private enum Status {
+        /**
+         * Created but not yet running.
+         */
+        PENDING,
+        /**
+         * In the process of fetching media.
+         */
+        RUNNING,
+        /**
+         * Waiting for a callback given to the Target to be called to determine target dimensions.
+         */
+        WAITING_FOR_SIZE,
+        /**
+         * Finished loading media successfully.
+         */
+        COMPLETE,
+        /**
+         * Failed to load media, may be restarted.
+         */
+        FAILED,
+        /**
+         * Cancelled by the user, may not be restarted.
+         */
+        CANCELLED,
+        /**
+         * Cleared by the user with a placeholder set, may not be restarted.
+         */
+        CLEARED,
+        /**
+         * Temporarily paused by the system, may be restarted.
+         */
+        PAUSED,
+    }
+
+    @Nullable
+    private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
+    private final StateVerifier stateVerifier = StateVerifier.newInstance();
+
+    @Nullable
+    private RequestListener<R> targetListener;
+    private RequestCoordinator requestCoordinator;
+    private Context context;
+    private GlideContext glideContext;
+    @Nullable
+    private Object model;
+    private Class<R> transcodeClass;
+    private RequestOptions requestOptions;
+    private int overrideWidth;
+    private int overrideHeight;
+    private Priority priority;
+    private Target<R> target;
+    private RequestListener<R> requestListener;
+    private Engine engine;
+    private TransitionFactory<? super R> animationFactory;
+    private Resource<R> resource;
+    private Engine.LoadStatus loadStatus;
+    private long startTime;
+    private Status status;
+    private Drawable errorDrawable;
+    private Drawable placeholderDrawable;
+    private Drawable fallbackDrawable;
+    private int width;
+    private int height;
+
+    public static <R> SingleRequest<R> obtain(
+            Context context,
+            GlideContext glideContext,
+            Object model,
+            Class<R> transcodeClass,
+            RequestOptions requestOptions,
+            int overrideWidth,
+            int overrideHeight,
+            Priority priority,
+            Target<R> target,
+            RequestListener<R> targetListener,
+            RequestListener<R> requestListener,
+            RequestCoordinator requestCoordinator,
+            Engine engine,
+            TransitionFactory<? super R> animationFactory) {
+        @SuppressWarnings("unchecked") SingleRequest<R> request =
+                (SingleRequest<R>) POOL.acquire();
+        if (request == null) {
+            request = new SingleRequest<>();
+        }
+        request.init(
+                context,
+                glideContext,
+                model,
+                transcodeClass,
+                requestOptions,
+                overrideWidth,
+                overrideHeight,
+                priority,
+                target,
+                targetListener,
+                requestListener,
+                requestCoordinator,
+                engine,
+                animationFactory);
+        return request;
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    @Synthetic
+    SingleRequest() {
+        // just create, instances are reused with recycle/init
+    }
+
+    private void init(
+            Context context,
+            GlideContext glideContext,
+            Object model,
+            Class<R> transcodeClass,
+            RequestOptions requestOptions,
+            int overrideWidth,
+            int overrideHeight,
+            Priority priority,
+            Target<R> target,
+            RequestListener<R> targetListener,
+            RequestListener<R> requestListener,
+            RequestCoordinator requestCoordinator,
+            Engine engine,
+            TransitionFactory<? super R> animationFactory) {
+        this.context = context;
+        this.glideContext = glideContext;
+        this.model = model;
+        this.transcodeClass = transcodeClass;
+        this.requestOptions = requestOptions;
+        this.overrideWidth = overrideWidth;
+        this.overrideHeight = overrideHeight;
+        this.priority = priority;
+        this.target = target;
+        this.targetListener = targetListener;
+        this.requestListener = requestListener;
+        this.requestCoordinator = requestCoordinator;
+        this.engine = engine;
+        this.animationFactory = animationFactory;
+        status = Status.PENDING;
+    }
+
+    @NonNull
+    @Override
+    public StateVerifier getVerifier() {
+        return stateVerifier;
+    }
+
+    @Override
+    public void recycle() {
+        assertNotCallingCallbacks();
+        context = null;
+        glideContext = null;
+        model = null;
+        transcodeClass = null;
+        requestOptions = null;
+        overrideWidth = -1;
+        overrideHeight = -1;
+        target = null;
+        requestListener = null;
+        targetListener = null;
+        requestCoordinator = null;
+        animationFactory = null;
+        loadStatus = null;
+        errorDrawable = null;
+        placeholderDrawable = null;
+        fallbackDrawable = null;
+        width = -1;
+        height = -1;
+        POOL.release(this);
+    }
+
+    @Override
+    public void begin() {
+        assertNotCallingCallbacks();
+        stateVerifier.throwIfRecycled();
+        startTime = LogTime.getLogTime();
+        if (model == null) {
+            if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+                width = overrideWidth;
+                height = overrideHeight;
+            }
+            // Only log at more verbose log levels if the user has set a fallback drawable, because
+            // fallback Drawables indicate the user expects null models occasionally.
+            int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
+            onLoadFailed(new GlideException("Received null model"), logLevel);
+            return;
+        }
+
+        if (status == Status.RUNNING) {
+            throw new IllegalArgumentException("Cannot restart a running request");
+        }
+
+        // If we're restarted after we're complete (usually via something like a notifyDataSetChanged
+        // that starts an identical request into the same Target or View), we can simply use the
+        // resource and size we retrieved the last time around and skip obtaining a new size, starting a
+        // new load etc. This does mean that users who want to restart a load because they expect that
+        // the view size has changed will need to explicitly clear the View or Target before starting
+        // the new load.
+        if (status == Status.COMPLETE) {
+            onResourceReady(resource, DataSource.MEMORY_CACHE);
+            return;
+        }
+
+        // Restarts for requests that are neither complete nor running can be treated as new requests
+        // and can run again from the beginning.
+
+        status = Status.WAITING_FOR_SIZE;
+        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+            onSizeReady(overrideWidth, overrideHeight);
+        } else {
+            target.getSize(this);
+        }
+
+        if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
+                && canNotifyStatusChanged()) {
+            target.onLoadStarted(getPlaceholderDrawable());
+        }
+        if (IS_VERBOSE_LOGGABLE) {
+            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
+        }
+    }
+
     /**
-     * Waiting for a callback given to the Target to be called to determine target dimensions.
+     * Cancels the current load but does not release any resources held by the request and continues
+     * to display the loaded resource if the load completed before the call to cancel.
+     * <p>
+     * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
+     *
+     * @see #clear()
      */
-    WAITING_FOR_SIZE,
+    void cancel() {
+        assertNotCallingCallbacks();
+        stateVerifier.throwIfRecycled();
+        target.removeCallback(this);
+        status = Status.CANCELLED;
+        if (loadStatus != null) {
+            loadStatus.cancel();
+            loadStatus = null;
+        }
+    }
+
+    // Avoids difficult to understand errors like #2413.
+    private void assertNotCallingCallbacks() {
+        if (isCallingCallbacks) {
+            throw new IllegalStateException("You can't start or clear loads in RequestListener or"
+                    + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
+                    + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
+                    + " clear() calls to the main thread using a Handler instead.");
+        }
+    }
+
     /**
-     * Finished loading media successfully.
+     * Cancels the current load if it is in progress, clears any resources held onto by the request
+     * and replaces the loaded resource if the load completed with the placeholder.
+     * <p>
+     * <p> Cleared requests can be restarted with a subsequent call to {@link #begin()} </p>
+     *
+     * @see #cancel()
      */
-    COMPLETE,
+    @Override
+    public void clear() {
+        Util.assertMainThread();
+        assertNotCallingCallbacks();
+        stateVerifier.throwIfRecycled();
+        if (status == Status.CLEARED) {
+            return;
+        }
+        cancel();
+        // Resource must be released before canNotifyStatusChanged is called.
+        if (resource != null) {
+            releaseResource(resource);
+        }
+        if (canNotifyCleared()) {
+            target.onLoadCleared(getPlaceholderDrawable());
+        }
+        // Must be after cancel().
+        status = Status.CLEARED;
+    }
+
+    @Override
+    public boolean isPaused() {
+        return status == Status.PAUSED;
+    }
+
+    @Override
+    public void pause() {
+        clear();
+        status = Status.PAUSED;
+    }
+
+    private void releaseResource(Resource<?> resource) {
+        engine.release(resource);
+        this.resource = null;
+    }
+
+    @Override
+    public boolean isRunning() {
+        return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
+    }
+
+    @Override
+    public boolean isComplete() {
+        return status == Status.COMPLETE;
+    }
+
+    @Override
+    public boolean isResourceSet() {
+        return isComplete();
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return status == Status.CANCELLED || status == Status.CLEARED;
+    }
+
+    @Override
+    public boolean isFailed() {
+        return status == Status.FAILED;
+    }
+
+    private Drawable getErrorDrawable() {
+        if (errorDrawable == null) {
+            errorDrawable = requestOptions.getErrorPlaceholder();
+            if (errorDrawable == null && requestOptions.getErrorId() > 0) {
+                errorDrawable = loadDrawable(requestOptions.getErrorId());
+            }
+        }
+        return errorDrawable;
+    }
+
+    private Drawable getPlaceholderDrawable() {
+        if (placeholderDrawable == null) {
+            placeholderDrawable = requestOptions.getPlaceholderDrawable();
+            if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
+                placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
+            }
+        }
+        return placeholderDrawable;
+    }
+
+    private Drawable getFallbackDrawable() {
+        if (fallbackDrawable == null) {
+            fallbackDrawable = requestOptions.getFallbackDrawable();
+            if (fallbackDrawable == null && requestOptions.getFallbackId() > 0) {
+                fallbackDrawable = loadDrawable(requestOptions.getFallbackId());
+            }
+        }
+        return fallbackDrawable;
+    }
+
+    private Drawable loadDrawable(@DrawableRes int resourceId) {
+        Theme theme = requestOptions.getTheme() != null
+                ? requestOptions.getTheme() : context.getTheme();
+        return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
+    }
+
+    private void setErrorPlaceholder() {
+        if (!canNotifyStatusChanged()) {
+            return;
+        }
+
+        Drawable error = null;
+        if (model == null) {
+            error = getFallbackDrawable();
+        }
+        // Either the model isn't null, or there was no fallback drawable set.
+        if (error == null) {
+            error = getErrorDrawable();
+        }
+        // The model isn't null, no fallback drawable was set or no error drawable was set.
+        if (error == null) {
+            error = getPlaceholderDrawable();
+        }
+        target.onLoadFailed(error);
+    }
+
     /**
-     * Failed to load media, may be restarted.
+     * A callback method that should never be invoked directly.
      */
-    FAILED,
+    @Override
+    public void onSizeReady(int width, int height) {
+        stateVerifier.throwIfRecycled();
+        if (IS_VERBOSE_LOGGABLE) {
+            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
+        }
+        if (status != Status.WAITING_FOR_SIZE) {
+            return;
+        }
+        status = Status.RUNNING;
+
+        float sizeMultiplier = requestOptions.getSizeMultiplier();
+        this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
+        this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
+
+        if (IS_VERBOSE_LOGGABLE) {
+            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
+        }
+        loadStatus = engine.load(
+                glideContext,
+                model,
+                requestOptions.getSignature(),
+                this.width,
+                this.height,
+                requestOptions.getResourceClass(),
+                transcodeClass,
+                priority,
+                requestOptions.getDiskCacheStrategy(),
+                requestOptions.getTransformations(),
+                requestOptions.isTransformationRequired(),
+                requestOptions.isScaleOnlyOrNoTransform(),
+                requestOptions.getOptions(),
+                requestOptions.isMemoryCacheable(),
+                requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+                requestOptions.getUseAnimationPool(),
+                requestOptions.getOnlyRetrieveFromCache(),
+                this);
+
+        // This is a hack that's only useful for testing right now where loads complete synchronously
+        // even though under any executor running on any thread but the main thread, the load would
+        // have completed asynchronously.
+        if (status != Status.RUNNING) {
+            loadStatus = null;
+        }
+        if (IS_VERBOSE_LOGGABLE) {
+            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
+        }
+    }
+
+    private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
+        return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
+    }
+
+    private boolean canSetResource() {
+        return requestCoordinator == null || requestCoordinator.canSetImage(this);
+    }
+
+    private boolean canNotifyCleared() {
+        return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
+    }
+
+    private boolean canNotifyStatusChanged() {
+        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
+    }
+
+    private boolean isFirstReadyResource() {
+        return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
+    }
+
+    private void notifyLoadSuccess() {
+        if (requestCoordinator != null) {
+            requestCoordinator.onRequestSuccess(this);
+        }
+    }
+
+    private void notifyLoadFailed() {
+        if (requestCoordinator != null) {
+            requestCoordinator.onRequestFailed(this);
+        }
+    }
+
     /**
-     * Cancelled by the user, may not be restarted.
+     * A callback method that should never be invoked directly.
      */
-    CANCELLED,
+    @SuppressWarnings("unchecked")
+    @Override
+    public void onResourceReady(Resource<?> resource, DataSource dataSource) {
+        stateVerifier.throwIfRecycled();
+        loadStatus = null;
+        if (resource == null) {
+            GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
+                    + "object of " + transcodeClass + " inside, but instead got null.");
+            onLoadFailed(exception);
+            return;
+        }
+
+        Object received = resource.get();
+        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
+            releaseResource(resource);
+            GlideException exception = new GlideException("Expected to receive an object of "
+                    + transcodeClass + " but instead" + " got "
+                    + (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
+                    + "Resource{" + resource + "}."
+                    + (received != null ? "" : " " + "To indicate failure return a null Resource "
+                    + "object, rather than a Resource object containing null data."));
+            onLoadFailed(exception);
+            return;
+        }
+
+        if (!canSetResource()) {
+            releaseResource(resource);
+            // We can't put the status to complete before asking canSetResource().
+            status = Status.COMPLETE;
+            return;
+        }
+
+        onResourceReady((Resource<R>) resource, (R) received, dataSource);
+    }
+
     /**
-     * Cleared by the user with a placeholder set, may not be restarted.
+     * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
+     *
+     * @param resource original {@link Resource}, never <code>null</code>
+     * @param result   object returned by {@link Resource#get()}, checked for type and never
+     *                 <code>null</code>
      */
-    CLEARED,
+    private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
+        // We must call isFirstReadyResource before setting status.
+        boolean isFirstResource = isFirstReadyResource();
+        status = Status.COMPLETE;
+        this.resource = resource;
+
+        if (glideContext.getLogLevel() <= Log.DEBUG) {
+            Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
+                    + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
+                    + LogTime.getElapsedMillis(startTime) + " ms");
+        }
+
+        isCallingCallbacks = true;
+        try {
+            if ((requestListener == null
+                    || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))
+                    && (targetListener == null
+                    || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) {
+                Transition<? super R> animation =
+                        animationFactory.build(dataSource, isFirstResource);
+                target.onResourceReady(result, animation);
+            }
+        } finally {
+            isCallingCallbacks = false;
+        }
+
+        notifyLoadSuccess();
+    }
+
     /**
-     * Temporarily paused by the system, may be restarted.
+     * A callback method that should never be invoked directly.
      */
-    PAUSED,
-  }
-
-  @Nullable
-  private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
-  private final StateVerifier stateVerifier = StateVerifier.newInstance();
-
-  @Nullable
-  private RequestListener<R> targetListener;
-  private RequestCoordinator requestCoordinator;
-  private Context context;
-  private GlideContext glideContext;
-  @Nullable
-  private Object model;
-  private Class<R> transcodeClass;
-  private RequestOptions requestOptions;
-  private int overrideWidth;
-  private int overrideHeight;
-  private Priority priority;
-  private Target<R> target;
-  private RequestListener<R> requestListener;
-  private Engine engine;
-  private TransitionFactory<? super R> animationFactory;
-  private Resource<R> resource;
-  private Engine.LoadStatus loadStatus;
-  private long startTime;
-  private Status status;
-  private Drawable errorDrawable;
-  private Drawable placeholderDrawable;
-  private Drawable fallbackDrawable;
-  private int width;
-  private int height;
-
-  public static <R> SingleRequest<R> obtain(
-      Context context,
-      GlideContext glideContext,
-      Object model,
-      Class<R> transcodeClass,
-      RequestOptions requestOptions,
-      int overrideWidth,
-      int overrideHeight,
-      Priority priority,
-      Target<R> target,
-      RequestListener<R> targetListener,
-      RequestListener<R> requestListener,
-      RequestCoordinator requestCoordinator,
-      Engine engine,
-      TransitionFactory<? super R> animationFactory) {
-    @SuppressWarnings("unchecked") SingleRequest<R> request =
-        (SingleRequest<R>) POOL.acquire();
-    if (request == null) {
-      request = new SingleRequest<>();
-    }
-    request.init(
-        context,
-        glideContext,
-        model,
-        transcodeClass,
-        requestOptions,
-        overrideWidth,
-        overrideHeight,
-        priority,
-        target,
-        targetListener,
-        requestListener,
-        requestCoordinator,
-        engine,
-        animationFactory);
-    return request;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  @Synthetic
-  SingleRequest() {
-    // just create, instances are reused with recycle/init
-  }
-
-  private void init(
-      Context context,
-      GlideContext glideContext,
-      Object model,
-      Class<R> transcodeClass,
-      RequestOptions requestOptions,
-      int overrideWidth,
-      int overrideHeight,
-      Priority priority,
-      Target<R> target,
-      RequestListener<R> targetListener,
-      RequestListener<R> requestListener,
-      RequestCoordinator requestCoordinator,
-      Engine engine,
-      TransitionFactory<? super R> animationFactory) {
-    this.context = context;
-    this.glideContext = glideContext;
-    this.model = model;
-    this.transcodeClass = transcodeClass;
-    this.requestOptions = requestOptions;
-    this.overrideWidth = overrideWidth;
-    this.overrideHeight = overrideHeight;
-    this.priority = priority;
-    this.target = target;
-    this.targetListener = targetListener;
-    this.requestListener = requestListener;
-    this.requestCoordinator = requestCoordinator;
-    this.engine = engine;
-    this.animationFactory = animationFactory;
-    status = Status.PENDING;
-  }
-
-  @NonNull
-  @Override
-  public StateVerifier getVerifier() {
-    return stateVerifier;
-  }
-
-  @Override
-  public void recycle() {
-    assertNotCallingCallbacks();
-    context = null;
-    glideContext = null;
-    model = null;
-    transcodeClass = null;
-    requestOptions = null;
-    overrideWidth = -1;
-    overrideHeight = -1;
-    target = null;
-    requestListener = null;
-    targetListener = null;
-    requestCoordinator = null;
-    animationFactory = null;
-    loadStatus = null;
-    errorDrawable = null;
-    placeholderDrawable = null;
-    fallbackDrawable = null;
-    width = -1;
-    height = -1;
-    POOL.release(this);
-  }
-
-  @Override
-  public void begin() {
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    startTime = LogTime.getLogTime();
-    if (model == null) {
-      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
-        width = overrideWidth;
-        height = overrideHeight;
-      }
-      // Only log at more verbose log levels if the user has set a fallback drawable, because
-      // fallback Drawables indicate the user expects null models occasionally.
-      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
-      onLoadFailed(new GlideException("Received null model"), logLevel);
-      return;
-    }
-
-    if (status == Status.RUNNING) {
-      throw new IllegalArgumentException("Cannot restart a running request");
-    }
-
-    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged
-    // that starts an identical request into the same Target or View), we can simply use the
-    // resource and size we retrieved the last time around and skip obtaining a new size, starting a
-    // new load etc. This does mean that users who want to restart a load because they expect that
-    // the view size has changed will need to explicitly clear the View or Target before starting
-    // the new load.
-    if (status == Status.COMPLETE) {
-      onResourceReady(resource, DataSource.MEMORY_CACHE);
-      return;
-    }
-
-    // Restarts for requests that are neither complete nor running can be treated as new requests
-    // and can run again from the beginning.
-
-    status = Status.WAITING_FOR_SIZE;
-    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
-      onSizeReady(overrideWidth, overrideHeight);
-    } else {
-      target.getSize(this);
-    }
-
-    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
-        && canNotifyStatusChanged()) {
-      target.onLoadStarted(getPlaceholderDrawable());
-    }
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished run method in " + LogTime.getElapsedMillis(startTime));
-    }
-  }
-
-  /**
-   * Cancels the current load but does not release any resources held by the request and continues
-   * to display the loaded resource if the load completed before the call to cancel.
-   *
-   * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
-   *
-   * @see #clear()
-   */
-  void cancel() {
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    target.removeCallback(this);
-    status = Status.CANCELLED;
-    if (loadStatus != null) {
-      loadStatus.cancel();
-      loadStatus = null;
-    }
-  }
-
-  // Avoids difficult to understand errors like #2413.
-  private void assertNotCallingCallbacks() {
-    if (isCallingCallbacks) {
-      throw new IllegalStateException("You can't start or clear loads in RequestListener or"
-          + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
-          + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
-          + " clear() calls to the main thread using a Handler instead.");
-    }
-  }
-
-  /**
-   * Cancels the current load if it is in progress, clears any resources held onto by the request
-   * and replaces the loaded resource if the load completed with the placeholder.
-   *
-   * <p> Cleared requests can be restarted with a subsequent call to {@link #begin()} </p>
-   *
-   * @see #cancel()
-   */
-  @Override
-  public void clear() {
-    Util.assertMainThread();
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    if (status == Status.CLEARED) {
-      return;
-    }
-    cancel();
-    // Resource must be released before canNotifyStatusChanged is called.
-    if (resource != null) {
-      releaseResource(resource);
-    }
-    if (canNotifyCleared()) {
-      target.onLoadCleared(getPlaceholderDrawable());
-    }
-    // Must be after cancel().
-    status = Status.CLEARED;
-  }
-
-  @Override
-  public boolean isPaused() {
-    return status == Status.PAUSED;
-  }
-
-  @Override
-  public void pause() {
-    clear();
-    status = Status.PAUSED;
-  }
-
-  private void releaseResource(Resource<?> resource) {
-    engine.release(resource);
-    this.resource = null;
-  }
-
-  @Override
-  public boolean isRunning() {
-    return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
-  }
-
-  @Override
-  public boolean isComplete() {
-    return status == Status.COMPLETE;
-  }
-
-  @Override
-  public boolean isResourceSet() {
-    return isComplete();
-  }
-
-  @Override
-  public boolean isCancelled() {
-    return status == Status.CANCELLED || status == Status.CLEARED;
-  }
-
-  @Override
-  public boolean isFailed() {
-    return status == Status.FAILED;
-  }
-
-  private Drawable getErrorDrawable() {
-    if (errorDrawable == null) {
-      errorDrawable = requestOptions.getErrorPlaceholder();
-      if (errorDrawable == null && requestOptions.getErrorId() > 0) {
-        errorDrawable = loadDrawable(requestOptions.getErrorId());
-      }
-    }
-    return errorDrawable;
-  }
-
-  private Drawable getPlaceholderDrawable() {
-     if (placeholderDrawable == null) {
-      placeholderDrawable = requestOptions.getPlaceholderDrawable();
-      if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
-        placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
-      }
-    }
-    return placeholderDrawable;
-  }
-
-  private Drawable getFallbackDrawable() {
-    if (fallbackDrawable == null) {
-      fallbackDrawable = requestOptions.getFallbackDrawable();
-      if (fallbackDrawable == null && requestOptions.getFallbackId() > 0) {
-        fallbackDrawable = loadDrawable(requestOptions.getFallbackId());
-      }
-    }
-    return fallbackDrawable;
-  }
-
-  private Drawable loadDrawable(@DrawableRes int resourceId) {
-    Theme theme = requestOptions.getTheme() != null
-        ? requestOptions.getTheme() : context.getTheme();
-    return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
-  }
-
-  private void setErrorPlaceholder() {
-    if (!canNotifyStatusChanged()) {
-      return;
-    }
-
-    Drawable error = null;
-    if (model == null) {
-      error = getFallbackDrawable();
-    }
-    // Either the model isn't null, or there was no fallback drawable set.
-    if (error == null) {
-      error = getErrorDrawable();
-    }
-    // The model isn't null, no fallback drawable was set or no error drawable was set.
-    if (error == null) {
-      error = getPlaceholderDrawable();
-    }
-    target.onLoadFailed(error);
-  }
-
-  /**
-   * A callback method that should never be invoked directly.
-   */
-  @Override
-  public void onSizeReady(int width, int height) {
-    stateVerifier.throwIfRecycled();
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
-    }
-    if (status != Status.WAITING_FOR_SIZE) {
-      return;
-    }
-    status = Status.RUNNING;
-
-    float sizeMultiplier = requestOptions.getSizeMultiplier();
-    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
-    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
-
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
-    }
-    loadStatus = engine.load(
-        glideContext,
-        model,
-        requestOptions.getSignature(),
-        this.width,
-        this.height,
-        requestOptions.getResourceClass(),
-        transcodeClass,
-        priority,
-        requestOptions.getDiskCacheStrategy(),
-        requestOptions.getTransformations(),
-        requestOptions.isTransformationRequired(),
-        requestOptions.isScaleOnlyOrNoTransform(),
-        requestOptions.getOptions(),
-        requestOptions.isMemoryCacheable(),
-        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
-        requestOptions.getUseAnimationPool(),
-        requestOptions.getOnlyRetrieveFromCache(),
-        this);
-
-    // This is a hack that's only useful for testing right now where loads complete synchronously
-    // even though under any executor running on any thread but the main thread, the load would
-    // have completed asynchronously.
-    if (status != Status.RUNNING) {
-      loadStatus = null;
-    }
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
-    }
-  }
-
-  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
-    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
-  }
-
-  private boolean canSetResource() {
-    return requestCoordinator == null || requestCoordinator.canSetImage(this);
-  }
-
-  private boolean canNotifyCleared() {
-    return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
-  }
-
-  private boolean canNotifyStatusChanged() {
-    return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
-  }
-
-  private boolean isFirstReadyResource() {
-    return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
-  }
-
-  private void notifyLoadSuccess() {
-    if (requestCoordinator != null) {
-      requestCoordinator.onRequestSuccess(this);
-    }
-  }
-
-  private void notifyLoadFailed() {
-    if (requestCoordinator != null) {
-      requestCoordinator.onRequestFailed(this);
-    }
-  }
-
-  /**
-   * A callback method that should never be invoked directly.
-   */
-  @SuppressWarnings("unchecked")
-  @Override
-  public void onResourceReady(Resource<?> resource, DataSource dataSource) {
-    stateVerifier.throwIfRecycled();
-    loadStatus = null;
-    if (resource == null) {
-      GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
-          + "object of " + transcodeClass + " inside, but instead got null.");
-      onLoadFailed(exception);
-      return;
-    }
-
-    Object received = resource.get();
-    if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
-      releaseResource(resource);
-      GlideException exception = new GlideException("Expected to receive an object of "
-          + transcodeClass + " but instead" + " got "
-          + (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
-          + "Resource{" + resource + "}."
-          + (received != null ? "" : " " + "To indicate failure return a null Resource "
-          + "object, rather than a Resource object containing null data."));
-      onLoadFailed(exception);
-      return;
-    }
-
-    if (!canSetResource()) {
-      releaseResource(resource);
-      // We can't put the status to complete before asking canSetResource().
-      status = Status.COMPLETE;
-      return;
-    }
-
-    onResourceReady((Resource<R>) resource, (R) received, dataSource);
-  }
-
-  /**
-   * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
-   *
-   * @param resource original {@link Resource}, never <code>null</code>
-   * @param result   object returned by {@link Resource#get()}, checked for type and never
-   *                 <code>null</code>
-   */
-  private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
-    // We must call isFirstReadyResource before setting status.
-    boolean isFirstResource = isFirstReadyResource();
-    status = Status.COMPLETE;
-    this.resource = resource;
-
-    if (glideContext.getLogLevel() <= Log.DEBUG) {
-      Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
-          + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
-          + LogTime.getElapsedMillis(startTime) + " ms");
-    }
-
-    isCallingCallbacks = true;
-    try {
-      if ((requestListener == null
-          || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))
-          && (targetListener == null
-          || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) {
-        Transition<? super R> animation =
-            animationFactory.build(dataSource, isFirstResource);
-        target.onResourceReady(result, animation);
-      }
-    } finally {
-      isCallingCallbacks = false;
-    }
-
-    notifyLoadSuccess();
-  }
-
-  /**
-   * A callback method that should never be invoked directly.
-   */
-  @Override
-  public void onLoadFailed(GlideException e) {
-    onLoadFailed(e, Log.WARN);
-  }
-
-  private void onLoadFailed(GlideException e, int maxLogLevel) {
-    stateVerifier.throwIfRecycled();
-    int logLevel = glideContext.getLogLevel();
-    if (logLevel <= maxLogLevel) {
-      Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
-      if (logLevel <= Log.INFO) {
-        e.logRootCauses(GLIDE_TAG);
-      }
-    }
-
-    loadStatus = null;
-    status = Status.FAILED;
-
-    isCallingCallbacks = true;
-    try {
-      //TODO: what if this is a thumbnail request?
-      if ((requestListener == null
-          || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource()))
-          && (targetListener == null
-          || !targetListener.onLoadFailed(e, model, target, isFirstReadyResource()))) {
-        setErrorPlaceholder();
-      }
-    } finally {
-      isCallingCallbacks = false;
-    }
-
-    notifyLoadFailed();
-  }
-
-  @Override
-  public boolean isEquivalentTo(Request o) {
-    if (o instanceof SingleRequest) {
-      SingleRequest<?> that = (SingleRequest<?>) o;
-      return overrideWidth == that.overrideWidth
-          && overrideHeight == that.overrideHeight
-          && Util.bothModelsNullEquivalentOrEquals(model, that.model)
-          && transcodeClass.equals(that.transcodeClass)
-          && requestOptions.equals(that.requestOptions)
-          && priority == that.priority
-          // We do not want to require that RequestListeners implement equals/hashcode, so we don't
-          // compare them using equals(). We can however, at least assert that the request listener
-          // is either present or not present in both requests.
-          && (requestListener != null
-          ? that.requestListener != null : that.requestListener == null);
-    }
-    return false;
-  }
-
-  private void logV(String message) {
-    Log.v(TAG, message + " this: " + tag);
-  }
+    @Override
+    public void onLoadFailed(GlideException e) {
+        onLoadFailed(e, Log.WARN);
+    }
+
+    private void onLoadFailed(GlideException e, int maxLogLevel) {
+        stateVerifier.throwIfRecycled();
+        int logLevel = glideContext.getLogLevel();
+        if (logLevel <= maxLogLevel) {
+            Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
+            if (logLevel <= Log.INFO) {
+                e.logRootCauses(GLIDE_TAG);
+            }
+        }
+
+        loadStatus = null;
+        status = Status.FAILED;
+
+        isCallingCallbacks = true;
+        try {
+            //TODO: what if this is a thumbnail request?
+            if ((requestListener == null
+                    || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource()))
+                    && (targetListener == null
+                    || !targetListener.onLoadFailed(e, model, target, isFirstReadyResource()))) {
+                setErrorPlaceholder();
+            }
+        } finally {
+            isCallingCallbacks = false;
+        }
+
+        notifyLoadFailed();
+    }
+
+    @Override
+    public boolean isEquivalentTo(Request o) {
+        if (o instanceof SingleRequest) {
+            SingleRequest<?> that = (SingleRequest<?>) o;
+            return overrideWidth == that.overrideWidth
+                    && overrideHeight == that.overrideHeight
+                    && Util.bothModelsNullEquivalentOrEquals(model, that.model)
+                    && transcodeClass.equals(that.transcodeClass)
+                    && requestOptions.equals(that.requestOptions)
+                    && priority == that.priority
+                    // We do not want to require that RequestListeners implement equals/hashcode, so we don't
+                    // compare them using equals(). We can however, at least assert that the request listener
+                    // is either present or not present in both requests.
+                    && (requestListener != null
+                    ? that.requestListener != null : that.requestListener == null);
+        }
+        return false;
+    }
+
+    private void logV(String message) {
+        Log.v(TAG, message + " this: " + tag);
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 2e91ac594..98e19162d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -10,17 +10,17 @@
  * {@link com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
  */
 public class ImageViewTargetFactory {
-  @NonNull
-  @SuppressWarnings("unchecked")
-  public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
-      @NonNull Class<Z> clazz) {
-    if (Bitmap.class.equals(clazz)) {
-      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
-    } else if (Drawable.class.isAssignableFrom(clazz)) {
-      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
-    } else {
-      throw new IllegalArgumentException(
-          "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
+    @NonNull
+    @SuppressWarnings("unchecked")
+    public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
+                                                    @NonNull Class<Z> clazz) {
+        if (Bitmap.class.equals(clazz)) {
+            return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
+        } else if (Drawable.class.isAssignableFrom(clazz)) {
+            return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
+        } else {
+            throw new IllegalArgumentException(
+                    "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
+        }
     }
-  }
 }
