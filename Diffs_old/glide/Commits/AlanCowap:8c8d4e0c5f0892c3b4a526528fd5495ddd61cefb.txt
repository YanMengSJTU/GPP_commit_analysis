diff --git a/.travis.yml b/.travis.yml
index cb517689d..c2f8037b5 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -6,6 +6,7 @@ before_install:
   - mkdir "$ANDROID_HOME/licenses" || true
   - echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55\nd56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
   - echo -e "\n84831b9409646a918e30573bab4c9c91346d8abd\n504667f4c0de7af1a06de9f4b1727b84351f2910" > "$ANDROID_HOME/licenses/android-sdk-preview-license"
+  - yes | $ANDROID_HOME/tools/bin/sdkmanager "build-tools;28.0.3" "platforms;android-28"
 
 android:
   components:
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
index 065ac564f..68cbdb6bd 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
@@ -86,7 +86,8 @@ public String apply(ParameterSpec input) {
             .add(");\n")
             .build());
 
-    if (methodToOverride.getSimpleName().toString().equals("transforms")) {
+    if (methodToOverride.getSimpleName().toString().contains("transform")
+        && methodToOverride.isVarArgs()) {
       result
           .addModifiers(Modifier.FINAL)
           .addAnnotation(SafeVarargs.class)
diff --git a/annotation/compiler/src/main/resources/META-INF/gradle/incremental.annotation.processors b/annotation/compiler/src/main/resources/META-INF/gradle/incremental.annotation.processors
new file mode 100644
index 000000000..1b2cafe7f
--- /dev/null
+++ b/annotation/compiler/src/main/resources/META-INF/gradle/incremental.annotation.processors
@@ -0,0 +1 @@
+com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
index b2cb067dc..dea6e476f 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -558,6 +559,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
index 440c153b7..42346164b 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
@@ -384,9 +384,23 @@
     return (GlideRequest<TranscodeType>) super.transform(transformation);
   }
 
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
   /**
    * @see GlideOptions#transforms(Transformation<Bitmap>[])
    */
+  @Deprecated
   @NonNull
   @CheckResult
   @SuppressWarnings({
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
index 7344fe291..9f8cd70cc 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
@@ -48,13 +48,13 @@ public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
 
   @Override
   @NonNull
-  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {
+  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {
     return (GlideRequests) super.applyDefaultRequestOptions(options);
   }
 
   @Override
   @NonNull
-  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {
+  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {
     return (GlideRequests) super.setDefaultRequestOptions(options);
   }
 
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
index 4da6ef1ba..24e38fddb 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -561,6 +562,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
index 18fb054fb..f3edeea92 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -384,9 +384,23 @@
     return (GlideRequest<TranscodeType>) super.transform(transformation);
   }
 
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
   /**
    * @see GlideOptions#transforms(Transformation<Bitmap>[])
    */
+  @Deprecated
   @NonNull
   @CheckResult
   @SuppressWarnings({
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
index 089b752ef..48a2d8bd4 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -552,6 +553,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
index 860faf1ac..b15070a1b 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -375,9 +375,23 @@
     return (GlideRequest<TranscodeType>) super.transform(transformation);
   }
 
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
   /**
    * @see GlideOptions#transforms(Transformation<Bitmap>[])
    */
+  @Deprecated
   @NonNull
   @CheckResult
   @SuppressWarnings({
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
index 89850adc8..0fe0aa379 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -542,6 +543,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
index 0b3f59384..f68d6f476 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
@@ -375,9 +375,23 @@
     return (GlideRequest<TranscodeType>) super.transform(transformation);
   }
 
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
   /**
    * @see GlideOptions#transforms(Transformation<Bitmap>[])
    */
+  @Deprecated
   @NonNull
   @CheckResult
   @SuppressWarnings({
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
index 124b80a27..bd338d637 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -552,6 +553,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
index 0c4f8ba9b..f4d3bcaa3 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -375,9 +375,23 @@
     return (GlideRequest<TranscodeType>) super.transform(transformation);
   }
 
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
   /**
    * @see GlideOptions#transforms(Transformation<Bitmap>[])
    */
+  @Deprecated
   @NonNull
   @CheckResult
   @SuppressWarnings({
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
index a98146108..1baed9ffa 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -559,6 +560,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
index 18fb054fb..f3edeea92 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -384,9 +384,23 @@
     return (GlideRequest<TranscodeType>) super.transform(transformation);
   }
 
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
   /**
    * @see GlideOptions#transforms(Transformation<Bitmap>[])
    */
+  @Deprecated
   @NonNull
   @CheckResult
   @SuppressWarnings({
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
index 6c20113cb..32c1ab8b8 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -559,6 +560,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
index 18fb054fb..f3edeea92 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -384,9 +384,23 @@
     return (GlideRequest<TranscodeType>) super.transform(transformation);
   }
 
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
   /**
    * @see GlideOptions#transforms(Transformation<Bitmap>[])
    */
+  @Deprecated
   @NonNull
   @CheckResult
   @SuppressWarnings({
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
index ce0df8dd7..25d649038 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -559,6 +560,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
index 51f731b2b..95a2ffd7d 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
@@ -384,9 +384,23 @@
     return (GlideRequest<TranscodeType>) super.transform(transformation);
   }
 
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideRequest<TranscodeType>) super.transform(transformations);
+  }
+
   /**
    * @see GlideOptions#transforms(Transformation<Bitmap>[])
    */
+  @Deprecated
   @NonNull
   @CheckResult
   @SuppressWarnings({
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
index 435ea9275..bedefc889 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
@@ -20,6 +20,7 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.lang.Class;
 import java.lang.Cloneable;
+import java.lang.Deprecated;
 import java.lang.Override;
 import java.lang.SafeVarargs;
 import java.lang.SuppressWarnings;
@@ -559,6 +560,16 @@ public GlideOptions transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings("varargs")
   @NonNull
   @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {
+    return (GlideOptions) super.transform(transformations);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @Deprecated
+  @NonNull
+  @CheckResult
   public final GlideOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
     return (GlideOptions) super.transforms(transformations);
   }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
index e0d0ad1d9..bb35a9fa8 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
@@ -58,13 +58,13 @@ public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
 
   @Override
   @NonNull
-  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {
+  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {
     return (GlideRequests) super.applyDefaultRequestOptions(options);
   }
 
   @Override
   @NonNull
-  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {
+  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {
     return (GlideRequests) super.setDefaultRequestOptions(options);
   }
 
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
index bb525c849..790c42bf7 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
@@ -11,5 +11,5 @@
  * @see GlideOption
  */
 @Target(ElementType.TYPE)
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS)
 public @interface GlideExtension { }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
index dc91418e2..7db045996 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -12,7 +12,7 @@
  * <p>Replaces <meta-data /> tags in AndroidManifest.xml.
  */
 @Target(ElementType.TYPE)
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS)
 public @interface GlideModule {
   /**
    * Returns the name of the class that will be used as a replacement for
diff --git a/build.gradle b/build.gradle
index c689d6105..ea8d78df5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -48,7 +48,8 @@ subprojects { project ->
         options.setBootstrapClasspath(files("${System.getProperty('java.home')}/lib/rt.jar"))
         // gifencoder is a legacy project that has a ton of warnings and is basically never
         // modified, so we're not going to worry about cleaning it up.
-        if ("gifencoder" != project.getName()) {
+        // Imgur uses generated code from dagger that has warnings.
+        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {
           options.compilerArgs \
                 /*
                  * Treat all warnings as errors.
diff --git a/gradle.properties b/gradle.properties
index 0af4d3a62..58d6319a6 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,17 +16,18 @@ POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
 ANDROID_SUPPORT_VERSION=27.1.1
+ANDROID_X_VERSION=1.0.0
 ANDROIDX_TEST_VERSION=1.1.0-alpha4
-VOLLEY_VERSION=1.0.0
+VOLLEY_VERSION=1.1.0
 OK_HTTP_VERSION=3.9.1
-ANDROID_GRADLE_VERSION=3.1.3
-DAGGER_VERSION=2.11
+ANDROID_GRADLE_VERSION=3.2.1
+DAGGER_VERSION=2.15
 
 JUNIT_VERSION=4.13-SNAPSHOT
 # Matches the version in Google.
 MOCKITO_VERSION=1.9.5
 MOCKITO_ANDROID_VERSION=2.21.0
-ROBOLECTRIC_VERSION=3.6.1
+ROBOLECTRIC_VERSION=4.1
 MOCKWEBSERVER_VERSION=3.0.0-RC1
 TRUTH_VERSION=0.36
 JSR_305_VERSION=3.0.2
@@ -39,7 +40,7 @@ ERROR_PRONE_VERSION=2.3.1
 ERROR_PRONE_PLUGIN_VERSION=0.0.13
 VIOLATIONS_PLUGIN_VERSION=1.8
 
-COMPILE_SDK_VERSION=27
+COMPILE_SDK_VERSION=28
 TARGET_SDK_VERSION=27
 MIN_SDK_VERSION=14
 
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
index cd2ef820f..03f2e9298 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -25,6 +25,8 @@
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.Target;
@@ -67,12 +69,11 @@
   private Context context;
 
   @Before
-  public void setUp() throws InterruptedException {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = InstrumentationRegistry.getTargetContext();
 
-    Glide.init(
-        context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));
+    Glide.init(context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));
   }
 
   @Test
@@ -164,8 +165,18 @@ public void run() {
   }
 
   @Test
-  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache()
-      throws InterruptedException, ExecutionException, TimeoutException {
+  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache() {
+    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob
+    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race
+    // by making our clear and EngineJob's clear run on the same thread.
+    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setSourceExecutor(mainThreadExecutor)
+            .setDiskCacheExecutor(mainThreadExecutor)
+            .setAnimationExecutor(mainThreadExecutor));
+
     FutureTarget<Drawable> future = GlideApp.with(context)
         .load(ResourceIds.raw.canonical)
         .diskCacheStrategy(DiskCacheStrategy.DATA)
@@ -192,8 +203,7 @@ public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCac
   }
 
   @Test
-  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache()
-      throws InterruptedException, TimeoutException, ExecutionException {
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache() {
     // We can't allow any mocks (RequestListner, Target etc) to reference this request or the test
     // will fail due to the transient strong reference to the request.
     concurrency.get(
@@ -224,8 +234,7 @@ public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFr
   }
 
   @Test
-  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap()
-      throws InterruptedException, TimeoutException, ExecutionException {
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap() {
     // We can't allow any mocks (RequestListener, Target etc) to reference this request or the test
     // will fail due to the transient strong reference to the request.
     Bitmap bitmap =
@@ -255,27 +264,42 @@ public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecy
   }
 
   @Test
-  public void clearDiskCache_doesNotPreventFutureLoads()
-      throws ExecutionException, InterruptedException, TimeoutException {
-    FutureTarget<Drawable> future = GlideApp.with(context)
-        .load(ResourceIds.raw.canonical)
-        .diskCacheStrategy(DiskCacheStrategy.DATA)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+  public void clearDiskCache_doesNotPreventFutureLoads() {
+    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob
+    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race
+    // by making our clear and EngineJob's clear run on the same thread.
+    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setSourceExecutor(mainThreadExecutor)
+            .setDiskCacheExecutor(mainThreadExecutor)
+            .setAnimationExecutor(mainThreadExecutor));
+
+    // Load the request once.
+    FutureTarget<Drawable> future =
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
     concurrency.get(future);
+    // Clear the result from all of our caches.
     GlideApp.with(context).clear(future);
-
     clearMemoryCacheOnMainThread();
     GlideApp.get(context).clearDiskCache();
 
-    future = GlideApp.with(context)
-        .load(ResourceIds.raw.canonical)
-        .diskCacheStrategy(DiskCacheStrategy.DATA)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    // Load the request a second time into the disk cache.
+    future =
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
     concurrency.get(future);
-
+    // Clear the second request from everywhere but the disk cache.
     GlideApp.with(context).clear(future);
     clearMemoryCacheOnMainThread();
 
+    // Load the request a third time.
     concurrency.get(
         GlideApp.with(context)
             .load(ResourceIds.raw.canonical)
@@ -283,6 +307,8 @@ public void clearDiskCache_doesNotPreventFutureLoads()
             .diskCacheStrategy(DiskCacheStrategy.DATA)
             .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
 
+    // Assert that the third request comes from the disk cache (which was populated by the second
+    // request).
     verify(requestListener)
         .onResourceReady(
             anyDrawable(),
@@ -351,12 +377,14 @@ public void run() {
     // Verify that the request that didn't have retrieve from cache succeeds
     assertThat(concurrency.get(expectedFuture)).isNotNull();
     // The first request only from cache should fail because the item is not in cache.
-    assertThrows(RuntimeException.class, new ThrowingRunnable() {
-      @Override
-      public void run() throws Throwable {
-        concurrency.get(firstQueuedFuture);
-      }
-    });
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            concurrency.get(firstQueuedFuture);
+          }
+        });
   }
 
   @Test
@@ -482,7 +510,7 @@ public void loadIntoView_withSkipMemoryCache_doesNotLoadFromMemoryCacheIfPresent
             anyBoolean());
   }
 
-  private void clearMemoryCacheOnMainThread() throws InterruptedException {
+  private void clearMemoryCacheOnMainThread() {
     concurrency.runOnMainThread(new Runnable() {
       @Override
       public void run() {
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
index 7365aa0c5..f00da78c7 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
@@ -23,6 +23,8 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.test.ConcurrencyHelper;
@@ -45,18 +47,31 @@
 
   private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
   private Context context;
+  private GlideBuilder glideBuilder;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = InstrumentationRegistry.getTargetContext();
+
+    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob
+    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race
+    // by making our clear and EngineJob's clear run on the same thread.
+    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();
+    glideBuilder =
+        new GlideBuilder()
+            .setSourceExecutor(mainThreadExecutor)
+            .setDiskCacheExecutor(mainThreadExecutor)
+            .setAnimationExecutor(mainThreadExecutor);
   }
 
   @Test
   public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new MemoryCacheAdapter())
-        .setBitmapPool(new BitmapPoolAdapter()));
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     Target<Drawable> target =
         concurrency.wait(
@@ -74,9 +89,11 @@ public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBi
 
   @Test
   public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new MemoryCacheAdapter())
-        .setBitmapPool(new BitmapPoolAdapter()));
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     concurrency.wait(
         GlideApp.with(context)
@@ -90,9 +107,11 @@ public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecyc
 
   @Test
   public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new MemoryCacheAdapter())
-        .setBitmapPool(new BitmapPoolAdapter()));
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     Target<Drawable> target =
         concurrency.wait(
@@ -109,9 +128,11 @@ public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
 
   @Test
   public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new MemoryCacheAdapter())
-        .setBitmapPool(new BitmapPoolAdapter()));
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     concurrency.wait(
         GlideApp.with(context)
@@ -124,9 +145,11 @@ public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap()
 
   @Test
   public void clearFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new MemoryCacheAdapter())
-        .setBitmapPool(new BitmapPoolAdapter()));
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     Target<Bitmap> target =
         concurrency.wait(
@@ -144,9 +167,11 @@ public void clearFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitm
 
   @Test
   public void transformFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new MemoryCacheAdapter())
-        .setBitmapPool(new BitmapPoolAdapter()));
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     concurrency.wait(
         GlideApp.with(context)
@@ -161,9 +186,11 @@ public void transformFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycle
   @Test
   public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
-        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
         concurrency.wait(
             GlideApp.with(context)
@@ -200,9 +227,11 @@ public void run() {
   @Test
   public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
-        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
         concurrency.wait(
             GlideApp.with(context)
@@ -240,9 +269,11 @@ public void run() {
   @Test
   public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
-        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
         concurrency.wait(
             GlideApp.with(context)
@@ -281,9 +312,11 @@ public void run() {
   @Test
   public void loadFromRequestBuilder_asBitmap_withBitmap_doesNotLoadFromDiskCache() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
-        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Bitmap> target =
         concurrency.wait(
             GlideApp.with(context)
@@ -322,9 +355,12 @@ public void run() {
   @Test
   public void loadFromRequestBuilder_asBitmap_withBitmapAndStrategyBeforeLoad_notFromCache() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
-        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+
     Target<Bitmap> target =
         concurrency.wait(
             GlideApp.with(context)
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
index f1290ef9e..20756248d 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
@@ -21,6 +21,8 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.test.ConcurrencyHelper;
@@ -43,19 +45,31 @@
   @Mock private RequestListener<Drawable> listener;
 
   private Context context;
+  private GlideExecutor executor;
+  private GlideBuilder glideBuilder;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
+    executor = MockGlideExecutor.newMainThreadExecutor();
+
     context = InstrumentationRegistry.getTargetContext();
+    glideBuilder =
+        new GlideBuilder()
+            .setAnimationExecutor(executor)
+            .setSourceExecutor(executor)
+            .setDiskCacheExecutor(executor);
   }
 
+
   @Test
   public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new MemoryCacheAdapter())
-        .setBitmapPool(new BitmapPoolAdapter()));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
     Target<Drawable> target =
@@ -73,9 +87,11 @@ public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
 
   @Test
   public void transform_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new MemoryCacheAdapter())
-        .setBitmapPool(new BitmapPoolAdapter()));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new MemoryCacheAdapter())
+            .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
     concurrency.wait(
@@ -91,9 +107,11 @@ public void transform_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
   public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
-        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
         concurrency.wait(
             GlideApp.with(context)
@@ -131,9 +149,11 @@ public void run() {
   public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
-        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
         concurrency.wait(
             GlideApp.with(context)
@@ -172,9 +192,11 @@ public void run() {
   public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
-    Glide.init(context, new GlideBuilder()
-        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
-        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Glide.init(
+        context,
+        glideBuilder
+            .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+            .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
         concurrency.wait(
             GlideApp.with(context)
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
index 3a57f5293..efc1fa5d2 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -395,7 +395,7 @@ public void load_withApplicationIconResourceIdUri_asBitmap_producesNonNullBitmap
 
   @Test
   public void load_withApplicationIconResourceIdUri_asBitmap_withTransformation_nonNullBitmap()
-      throws NameNotFoundException, ExecutionException, InterruptedException {
+      throws ExecutionException, InterruptedException {
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
@@ -426,9 +426,8 @@ public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDr
       Uri uri = new Uri.Builder()
           .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
           .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
+          .appendPath(resources.getResourceTypeName(iconResourceId))
+          .appendPath(resources.getResourceEntryName(iconResourceId))
           .build();
 
       Drawable drawable = Glide.with(context)
@@ -439,7 +438,6 @@ public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDr
     }
   }
 
-
   @Test
   public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_nonNullDrawable()
       throws ExecutionException, InterruptedException, NameNotFoundException {
@@ -451,9 +449,8 @@ public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_non
       Uri uri = new Uri.Builder()
           .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
           .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
+          .appendPath(resources.getResourceTypeName(iconResourceId))
+          .appendPath(resources.getResourceEntryName(iconResourceId))
           .build();
 
       Drawable drawable = Glide.with(context)
@@ -476,9 +473,8 @@ public void load_withApplicationIconResourceNameUri_asBitmap_producesNonNullBitm
       Uri uri = new Uri.Builder()
           .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
           .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
+          .appendPath(resources.getResourceTypeName(iconResourceId))
+          .appendPath(resources.getResourceEntryName(iconResourceId))
           .build();
 
       Bitmap bitmap = Glide.with(context)
@@ -501,9 +497,8 @@ public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNu
       Uri uri = new Uri.Builder()
           .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
           .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
+          .appendPath(resources.getResourceTypeName(iconResourceId))
+          .appendPath(resources.getResourceEntryName(iconResourceId))
           .build();
 
       Bitmap bitmap = Glide.with(context)
@@ -524,8 +519,10 @@ public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNu
         packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
     Set<String> result = new HashSet<>();
     for (ResolveInfo info : pkgAppsList) {
-      int iconResourceId = getResourceId(info.activityInfo.packageName);
-      if (iconResourceId != 0) {
+      String packageName = info.activityInfo.packageName;
+      int iconResourceId = getResourceId(packageName);
+      if (iconResourceId != 0
+              && doesApplicationPackageNameMatchResourcePackageName(packageName, iconResourceId)) {
         result.add(info.activityInfo.packageName);
       }
     }
@@ -541,4 +538,44 @@ private int getResourceId(String packageName) {
     }
     return packageInfo.applicationInfo.icon;
   }
+
+  /**
+   * Returns {@code true} iff the resource package name is exactly the same as the containing
+   * application package name for a given resource id.
+   *
+   * <p>The resource package name is the value returned by
+   * {@link Resources#getResourcePackageName(int)}. The application package name is package name of
+   * the enclosing application. If these two things are equal, then we can both construct a Context
+   * for that package and retrieve a resource id for that package from a "standard" resource Uri
+   * containing a name instead of an id. If they aren't equal, then we can do only one of the two
+   * required tasks, so our Uri load will always fail. To handle this properly, we'd need callers to
+   * include both package names in the Uri. I'm not aware of any standardized Uri format for doing
+   * so, so these requests will just be treated as unsupported for the time being.
+   *
+   * <p>Take Calendar (emulators API 24 and below) as an example:
+   * <ul>
+   *     <li>package name: com.google.android.calendar</li>
+   *     <li>resource package name: com.android.calendar</li>
+   * </ul>
+   * We can construct one of two possible Uris:
+   * <ul>
+   *     <li>android.resource://com.google.android.calendar/mipmap/ic_icon_calendar.</li>
+   *     <li>android.resource://com.android.calendar/mipmap/ic_icon_calendar.<</li>
+   * </ul>
+   * From the first Uri, we can obtain the correct Context/Resources for the calendar package, but
+   * our attempts to resolve the correct resource id will fail because we do not have the resource
+   * package name. From the second Uri we cannot obtain the Context/Resources for the calendar
+   * package because the resource package name doesn't match the application package name.
+   */
+  private boolean doesApplicationPackageNameMatchResourcePackageName(
+          String applicationPackageName, int iconResourceId) {
+    try {
+      Context current = context.createPackageContext(applicationPackageName, /*flags=*/ 0);
+      String resourcePackageName = current.getResources().getResourcePackageName(iconResourceId);
+      return applicationPackageName.equals(resourcePackageName);
+    } catch (NameNotFoundException e) {
+      // This should never happen
+      throw new RuntimeException(e);
+    }
+  }
 }
diff --git a/library/build.gradle b/library/build.gradle
index 6f01832e2..e2fa09bd1 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -13,6 +13,7 @@ dependencies {
     api project(':third_party:disklrucache')
     api project(':annotation')
     api "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    api "com.android.support:animated-vector-drawable:${ANDROID_SUPPORT_VERSION}"
     compileOnly "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
 
     if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
@@ -37,6 +38,7 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
         versionName VERSION_NAME as String
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     compileOptions {
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 89b950cd8..8691928f6 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -322,7 +322,8 @@ private static void throwIncorrectGlideModule(Exception e) {
       int logLevel,
       @NonNull RequestOptions defaultRequestOptions,
       @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
-      @NonNull List<RequestListener<Object>> defaultRequestListeners) {
+      @NonNull List<RequestListener<Object>> defaultRequestListeners,
+      boolean isLoggingRequestOriginsEnabled) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
@@ -336,14 +337,12 @@ private static void throwIncorrectGlideModule(Exception e) {
     final Resources resources = context.getResources();
 
     registry = new Registry();
+    registry.register(new DefaultImageHeaderParser());
     // Right now we're only using this parser for HEIF images, which are only supported on OMR1+.
     // If we need this for other file types, we should consider removing this restriction.
-    // Note that order here matters. We want to check the ExifInterface parser first for orientation
-    // and then fall back to DefaultImageHeaderParser for other fields.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {
       registry.register(new ExifInterfaceImageHeaderParser());
     }
-    registry.register(new DefaultImageHeaderParser());
 
     List<ImageHeaderParser> imageHeaderParsers = registry.getImageHeaderParsers();
     Downsampler downsampler =
@@ -522,6 +521,7 @@ private static void throwIncorrectGlideModule(Exception e) {
             defaultTransitionOptions,
             defaultRequestListeners,
             engine,
+            isLoggingRequestOriginsEnabled,
             logLevel);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index bdfae965b..98338cfcd 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -24,6 +24,7 @@
 import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
+import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
@@ -54,6 +55,7 @@
   private boolean isActiveResourceRetentionAllowed;
   @Nullable
   private List<RequestListener<Object>> defaultRequestListeners;
+  private boolean isLoggingRequestOriginsEnabled;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -204,7 +206,7 @@ public GlideBuilder setAnimationExecutor(@Nullable GlideExecutor service) {
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
    * <p>Applying additional options with {@link
-   * RequestBuilder#apply(RequestOptions)} will override defaults
+   * RequestBuilder#apply(BaseRequestOptions)} will override defaults
    * set here.
    *
    * @param requestOptions The options to use by default.
@@ -406,6 +408,21 @@ public GlideBuilder addGlobalRequestListener(@NonNull RequestListener<Object> li
     return this;
   }
 
+  /**
+   * Set to {@code true} to make Glide populate
+   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests.
+   *
+   * <p>The exception set by this method is not printed by {@link GlideException} and can only be
+   * viewed via a {@link RequestListener} that reads the field via
+   * {@link GlideException#getOrigin()}.
+   *
+   * <p>This is an experimental API that may be removed in the future.
+   */
+  public GlideBuilder setLogRequestOrigins(boolean isEnabled) {
+    isLoggingRequestOriginsEnabled = isEnabled;
+    return this;
+  }
+
   void setRequestManagerFactory(@Nullable RequestManagerFactory factory) {
     this.requestManagerFactory = factory;
   }
@@ -491,6 +508,7 @@ Glide build(@NonNull Context context) {
         logLevel,
         defaultRequestOptions.lock(),
         defaultTransitionOptions,
-        defaultRequestListeners);
+        defaultRequestListeners,
+        isLoggingRequestOriginsEnabled);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index a587b19bd..22f138e84 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -2,8 +2,6 @@
 
 import android.content.Context;
 import android.content.ContextWrapper;
-import android.os.Handler;
-import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.widget.ImageView;
@@ -25,7 +23,6 @@
   @VisibleForTesting
   static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
       new GenericTransitionOptions<>();
-  private final Handler mainHandler;
   private final ArrayPool arrayPool;
   private final Registry registry;
   private final ImageViewTargetFactory imageViewTargetFactory;
@@ -33,6 +30,7 @@
   private final List<RequestListener<Object>> defaultRequestListeners;
   private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions;
   private final Engine engine;
+  private final boolean isLoggingRequestOriginsEnabled;
   private final int logLevel;
 
   public GlideContext(
@@ -44,6 +42,7 @@ public GlideContext(
       @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
       @NonNull List<RequestListener<Object>> defaultRequestListeners,
       @NonNull Engine engine,
+      boolean isLoggingRequestOriginsEnabled,
       int logLevel) {
     super(context.getApplicationContext());
     this.arrayPool = arrayPool;
@@ -53,9 +52,8 @@ public GlideContext(
     this.defaultRequestListeners = defaultRequestListeners;
     this.defaultTransitionOptions = defaultTransitionOptions;
     this.engine = engine;
+    this.isLoggingRequestOriginsEnabled = isLoggingRequestOriginsEnabled;
     this.logLevel = logLevel;
-
-    mainHandler = new Handler(Looper.getMainLooper());
   }
 
   public List<RequestListener<Object>> getDefaultRequestListeners() {
@@ -89,11 +87,6 @@ public RequestOptions getDefaultRequestOptions() {
     return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
   }
 
-  @NonNull
-  public Handler getMainHandler() {
-    return mainHandler;
-  }
-
   @NonNull
   public Engine getEngine() {
     return engine;
@@ -112,4 +105,14 @@ public int getLogLevel() {
   public ArrayPool getArrayPool() {
     return arrayPool;
   }
+
+  /**
+   * Returns {@code true} if Glide should populate
+   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests.
+   *
+   * <p>This is an experimental API that may be removed in the future.
+   */
+  public boolean isLoggingRequestOriginsEnabled() {
+    return isLoggingRequestOriginsEnabled;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index a01d45500..5e89d0815 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -31,6 +31,7 @@
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.signature.ApplicationVersionSignature;
+import com.bumptech.glide.util.Executors;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
@@ -38,6 +39,7 @@
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.Executor;
 
 /**
  * A generic class that can handle setting options and staring loads for generic resource types.
@@ -95,12 +97,14 @@ protected RequestBuilder(
     apply(requestManager.getDefaultRequestOptions());
   }
 
+  @SuppressLint("CheckResult")
   @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
   protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
     this(other.glide, other.requestManager, transcodeClass, other.context);
     model = other.model;
     isModelSet = other.isModelSet;
 
+    // This is safe because it will always mutate, no one else has access to the object.
     apply(other);
   }
 
@@ -606,27 +610,29 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
    */
   @NonNull
   public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
-    return into(target, /*targetListener=*/ null);
+    return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor());
   }
 
   @NonNull
-  @Synthetic <Y extends Target<TranscodeType>> Y into(
+  @Synthetic
+  <Y extends Target<TranscodeType>> Y into(
       @NonNull Y target,
-      @Nullable RequestListener<TranscodeType> targetListener) {
-    return into(target, targetListener, /*options=*/ this);
+      @Nullable RequestListener<TranscodeType> targetListener,
+      Executor callbackExecutor) {
+    return into(target, targetListener, /*options=*/ this, callbackExecutor);
   }
 
   private <Y extends Target<TranscodeType>> Y into(
       @NonNull Y target,
       @Nullable RequestListener<TranscodeType> targetListener,
-      BaseRequestOptions<?> options) {
-    Util.assertMainThread();
+      BaseRequestOptions<?> options,
+      Executor callbackExecutor) {
     Preconditions.checkNotNull(target);
     if (!isModelSet) {
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
 
-    Request request = buildRequest(target, targetListener, options);
+    Request request = buildRequest(target, targetListener, options, callbackExecutor);
 
     Request previous = target.getRequest();
     if (request.isEquivalentTo(previous)
@@ -710,7 +716,8 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
     return into(
         glideContext.buildImageViewTarget(view, transcodeClass),
         /*targetListener=*/ null,
-        requestOptions);
+        requestOptions,
+        Executors.mainThreadExecutor());
   }
 
   /**
@@ -764,23 +771,8 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
    */
   @NonNull
   public FutureTarget<TranscodeType> submit(int width, int height) {
-    final RequestFutureTarget<TranscodeType> target =
-        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
-
-    if (Util.isOnBackgroundThread()) {
-      glideContext.getMainHandler().post(new Runnable() {
-        @Override
-        public void run() {
-          if (!target.isCancelled()) {
-            into(target, target);
-          }
-        }
-      });
-    } else {
-      into(target, target);
-    }
-
-    return target;
+    final RequestFutureTarget<TranscodeType> target = new RequestFutureTarget<>(width, height);
+    return into(target, target, Executors.directExecutor());
   }
 
   /**
@@ -879,7 +871,8 @@ private Priority getThumbnailPriority(@NonNull Priority current) {
   private Request buildRequest(
       Target<TranscodeType> target,
       @Nullable RequestListener<TranscodeType> targetListener,
-      BaseRequestOptions<?> requestOptions) {
+      BaseRequestOptions<?> requestOptions,
+      Executor callbackExecutor) {
     return buildRequestRecursive(
         target,
         targetListener,
@@ -888,7 +881,8 @@ private Request buildRequest(
         requestOptions.getPriority(),
         requestOptions.getOverrideWidth(),
         requestOptions.getOverrideHeight(),
-        requestOptions);
+        requestOptions,
+        callbackExecutor);
   }
 
   private Request buildRequestRecursive(
@@ -899,7 +893,8 @@ private Request buildRequestRecursive(
       Priority priority,
       int overrideWidth,
       int overrideHeight,
-      BaseRequestOptions<?> requestOptions) {
+      BaseRequestOptions<?> requestOptions,
+      Executor callbackExecutor) {
 
     // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
     ErrorRequestCoordinator errorRequestCoordinator = null;
@@ -917,7 +912,8 @@ private Request buildRequestRecursive(
             priority,
             overrideWidth,
             overrideHeight,
-            requestOptions);
+            requestOptions,
+            callbackExecutor);
 
     if (errorRequestCoordinator == null) {
       return mainRequest;
@@ -931,15 +927,17 @@ private Request buildRequestRecursive(
       errorOverrideHeight = requestOptions.getOverrideHeight();
     }
 
-    Request errorRequest = errorBuilder.buildRequestRecursive(
-        target,
-        targetListener,
-        errorRequestCoordinator,
-        errorBuilder.transitionOptions,
-        errorBuilder.getPriority(),
-        errorOverrideWidth,
-        errorOverrideHeight,
-        errorBuilder);
+    Request errorRequest =
+        errorBuilder.buildRequestRecursive(
+            target,
+            targetListener,
+            errorRequestCoordinator,
+            errorBuilder.transitionOptions,
+            errorBuilder.getPriority(),
+            errorOverrideWidth,
+            errorOverrideHeight,
+            errorBuilder,
+            callbackExecutor);
     errorRequestCoordinator.setRequests(mainRequest, errorRequest);
     return errorRequestCoordinator;
   }
@@ -952,7 +950,8 @@ private Request buildThumbnailRequestRecursive(
       Priority priority,
       int overrideWidth,
       int overrideHeight,
-      BaseRequestOptions<?> requestOptions) {
+      BaseRequestOptions<?> requestOptions,
+      Executor callbackExecutor) {
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
@@ -990,7 +989,8 @@ private Request buildThumbnailRequestRecursive(
               transitionOptions,
               priority,
               overrideWidth,
-              overrideHeight);
+              overrideHeight,
+              callbackExecutor);
       isThumbnailBuilt = true;
       // Recursively generate thumbnail requests.
       Request thumbRequest =
@@ -1002,7 +1002,8 @@ private Request buildThumbnailRequestRecursive(
               thumbPriority,
               thumbOverrideWidth,
               thumbOverrideHeight,
-              thumbnailBuilder);
+              thumbnailBuilder,
+              callbackExecutor);
       isThumbnailBuilt = false;
       coordinator.setRequests(fullRequest, thumbRequest);
       return coordinator;
@@ -1018,7 +1019,8 @@ private Request buildThumbnailRequestRecursive(
               transitionOptions,
               priority,
               overrideWidth,
-              overrideHeight);
+              overrideHeight,
+              callbackExecutor);
       BaseRequestOptions<?> thumbnailOptions =
           requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);
 
@@ -1031,7 +1033,8 @@ private Request buildThumbnailRequestRecursive(
               transitionOptions,
               getThumbnailPriority(priority),
               overrideWidth,
-              overrideHeight);
+              overrideHeight,
+              callbackExecutor);
 
       coordinator.setRequests(fullRequest, thumbnailRequest);
       return coordinator;
@@ -1045,7 +1048,8 @@ private Request buildThumbnailRequestRecursive(
           transitionOptions,
           priority,
           overrideWidth,
-          overrideHeight);
+          overrideHeight,
+          callbackExecutor);
     }
   }
 
@@ -1057,7 +1061,8 @@ private Request obtainRequest(
       TransitionOptions<?, ? super TranscodeType> transitionOptions,
       Priority priority,
       int overrideWidth,
-      int overrideHeight) {
+      int overrideHeight,
+      Executor callbackExecutor) {
     return SingleRequest.obtain(
         context,
         glideContext,
@@ -1072,6 +1077,7 @@ private Request obtainRequest(
         requestListeners,
         requestCoordinator,
         glideContext.getEngine(),
-        transitionOptions.getTransitionFactory());
+        transitionOptions.getTransitionFactory(),
+        callbackExecutor);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 9e0cdb6c3..cc415d705 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -12,6 +12,7 @@
 import android.os.Looper;
 import android.support.annotation.CheckResult;
 import android.support.annotation.DrawableRes;
+import android.support.annotation.GuardedBy;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.RawRes;
@@ -27,6 +28,7 @@
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.manager.TargetTracker;
+import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
@@ -62,9 +64,13 @@
 
   protected final Glide glide;
   protected final Context context;
+  @SuppressWarnings("WeakerAccess")
   @Synthetic final Lifecycle lifecycle;
+  @GuardedBy("this")
   private final RequestTracker requestTracker;
+  @GuardedBy("this")
   private final RequestManagerTreeNode treeNode;
+  @GuardedBy("this")
   private final TargetTracker targetTracker = new TargetTracker();
   private final Runnable addSelfToLifecycle = new Runnable() {
     @Override
@@ -79,6 +85,7 @@ public void run() {
   // the list each time a request is started.
   private final CopyOnWriteArrayList<RequestListener<Object>> defaultRequestListeners;
 
+  @GuardedBy("this")
   private RequestOptions requestOptions;
 
   public RequestManager(
@@ -131,34 +138,35 @@ public RequestManager(
     glide.registerRequestManager(this);
   }
 
-  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+  protected synchronized void setRequestOptions(@NonNull RequestOptions toSet) {
     requestOptions = toSet.clone().autoClone();
   }
 
-  private void updateRequestOptions(@NonNull RequestOptions toUpdate) {
+  private synchronized void updateRequestOptions(@NonNull RequestOptions toUpdate) {
     requestOptions = requestOptions.apply(toUpdate);
   }
 
   /**
-   * Updates the default {@link RequestOptions} for all loads started with this request manager
-   * with the given {@link RequestOptions}.
+   * Updates the default {@link RequestOptions} for all loads started with this request manager with
+   * the given {@link RequestOptions}.
    *
    * <p>The {@link RequestOptions} provided here are applied on top of those provided via {@link
    * GlideBuilder#setDefaultRequestOptions(RequestOptions)}. If there are conflicts, the options
-   * applied here will win. Note that this method does not mutate options provided to
-   * {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   * applied here will win. Note that this method does not mutate options provided to {@link
+   * GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
    *
    * <p>Multiple sets of options can be applied. If there are conflicts the last {@link
    * RequestOptions} applied will win.
    *
    * <p>The modified options will only be applied to loads started after this method is called.
    *
-   * @see RequestBuilder#apply(RequestOptions)
+   * @see RequestBuilder#apply(BaseRequestOptions)
    *
    * @return This request manager.
    */
   @NonNull
-  public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
+  public synchronized RequestManager applyDefaultRequestOptions(
+      @NonNull RequestOptions requestOptions) {
     updateRequestOptions(requestOptions);
     return this;
   }
@@ -168,19 +176,19 @@ public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions request
    * with the given {@link RequestOptions}.
    *
    * <p>The {@link RequestOptions} provided here replace those that have been previously provided
-   * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and
-   * {@link #applyDefaultRequestOptions(RequestOptions)}.
+   * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and {@link
+   * #applyDefaultRequestOptions(RequestOptions)}.
    *
-   * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
-   * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
-   * options and mutate the clone.
+   * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate the
+   * {@link RequestOptions} provided here. Instead the manager will create a clone of these options
+   * and mutate the clone.
    *
    * @see #applyDefaultRequestOptions(RequestOptions)
-   *
    * @return This request manager.
    */
   @NonNull
-  public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
+  public synchronized RequestManager setDefaultRequestOptions(
+      @NonNull RequestOptions requestOptions) {
     setRequestOptions(requestOptions);
     return this;
   }
@@ -189,19 +197,18 @@ public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOp
    * Adds a default {@link RequestListener} that will be added to every request started with this
    * {@link RequestManager}.
    *
-   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or
-   * to individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
-   * added. Even if an earlier {@link RequestListener} returns {@code true} from
-   * {@link RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or
-   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will
-   * not prevent subsequent {@link RequestListener}s from being called.
+   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or to
+   * individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
+   * added. Even if an earlier {@link RequestListener} returns {@code true} from {@link
+   * RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or {@link
+   * RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will not
+   * prevent subsequent {@link RequestListener}s from being called.
    *
    * <p>Because Glide requests can be started for any number of individual resource types, any
-   * listener added here has to accept any generic resource type in
-   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you
-   * must base the behavior of the listener on the resource type, you will need to use
-   * {@code instanceof} to do so. It's not safe to cast resource types without first checking
-   * with {@code instanceof}.
+   * listener added here has to accept any generic resource type in {@link
+   * RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you must base
+   * the behavior of the listener on the resource type, you will need to use {@code instanceof} to
+   * do so. It's not safe to cast resource types without first checking with {@code instanceof}.
    */
   public RequestManager addDefaultRequestListener(RequestListener<Object> requestListener) {
     defaultRequestListeners.add(requestListener);
@@ -214,8 +221,7 @@ public RequestManager addDefaultRequestListener(RequestListener<Object> requestL
    * @see #pauseRequests()
    * @see #resumeRequests()
    */
-  public boolean isPaused() {
-    Util.assertMainThread();
+  public synchronized boolean isPaused() {
     return requestTracker.isPaused();
   }
 
@@ -229,8 +235,7 @@ public boolean isPaused() {
    * @see #isPaused()
    * @see #resumeRequests()
    */
-  public void pauseRequests() {
-    Util.assertMainThread();
+  public synchronized void pauseRequests() {
     requestTracker.pauseRequests();
   }
 
@@ -250,20 +255,19 @@ public void pauseRequests() {
    * @see #isPaused()
    * @see #resumeRequests()
    */
-  public void pauseAllRequests() {
-    Util.assertMainThread();
+  public synchronized void pauseAllRequests() {
     requestTracker.pauseAllRequests();
   }
 
   /**
-   * Performs {@link #pauseRequests()} recursively for all managers that are contextually
-   * descendant to this manager based on the Activity/Fragment hierarchy:
+   * Performs {@link #pauseRequests()} recursively for all managers that are contextually descendant
+   * to this manager based on the Activity/Fragment hierarchy:
    *
    * <ul>
    *   <li>When pausing on an Activity all attached fragments will also get paused.
    *   <li>When pausing on an attached Fragment all descendant fragments will also get paused.
    *   <li>When pausing on a detached Fragment or the application context only the current
-   *   RequestManager is paused.
+   *       RequestManager is paused.
    * </ul>
    *
    * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
@@ -271,8 +275,7 @@ public void pauseAllRequests() {
    */
   // Public API.
   @SuppressWarnings({"WeakerAccess", "unused"})
-  public void pauseRequestsRecursive() {
-    Util.assertMainThread();
+  public synchronized void pauseRequestsRecursive() {
     pauseRequests();
     for (RequestManager requestManager : treeNode.getDescendants()) {
       requestManager.pauseRequests();
@@ -285,8 +288,7 @@ public void pauseRequestsRecursive() {
    * @see #isPaused()
    * @see #pauseRequests()
    */
-  public void resumeRequests() {
-    Util.assertMainThread();
+  public synchronized void resumeRequests() {
     requestTracker.resumeRequests();
   }
 
@@ -297,7 +299,7 @@ public void resumeRequests() {
    */
   // Public API.
   @SuppressWarnings("unused")
-  public void resumeRequestsRecursive() {
+  public synchronized void resumeRequestsRecursive() {
     Util.assertMainThread();
     resumeRequests();
     for (RequestManager requestManager : treeNode.getDescendants()) {
@@ -311,7 +313,7 @@ public void resumeRequestsRecursive() {
    * requests.
    */
   @Override
-  public void onStart() {
+  public synchronized void onStart() {
     resumeRequests();
     targetTracker.onStart();
   }
@@ -321,7 +323,7 @@ public void onStart() {
    * android.permission.ACCESS_NETWORK_STATE permission is present) and pauses in progress loads.
    */
   @Override
-  public void onStop() {
+  public synchronized void onStop() {
     pauseRequests();
     targetTracker.onStop();
   }
@@ -331,7 +333,7 @@ public void onStop() {
    * all completed requests.
    */
   @Override
-  public void onDestroy() {
+  public synchronized void onDestroy() {
     targetTracker.onDestroy();
     for (Target<?> target : targetTracker.getAll()) {
       clear(target);
@@ -579,26 +581,17 @@ public void clear(@NonNull View view) {
   }
 
   /**
-   * Cancel any pending loads Glide may have for the target and free any resources (such as
-   * {@link Bitmap}s) that may have been loaded for the target so they may be reused.
+   * Cancel any pending loads Glide may have for the target and free any resources (such as {@link
+   * Bitmap}s) that may have been loaded for the target so they may be reused.
    *
    * @param target The Target to cancel loads for.
    */
-  public void clear(@Nullable final Target<?> target) {
+  public synchronized void clear(@Nullable final Target<?> target) {
     if (target == null) {
       return;
     }
 
-    if (Util.isOnMainThread()) {
-      untrackOrDelegate(target);
-    } else {
-      mainHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          clear(target);
-        }
-      });
-    }
+    untrackOrDelegate(target);
   }
 
   private void untrackOrDelegate(@NonNull Target<?> target) {
@@ -627,7 +620,7 @@ private void untrackOrDelegate(@NonNull Target<?> target) {
     }
   }
 
-  boolean untrack(@NonNull Target<?> target) {
+  synchronized boolean untrack(@NonNull Target<?> target) {
     Request request = target.getRequest();
     // If the Target doesn't have a request, it's already been cleared.
     if (request == null) {
@@ -643,7 +636,7 @@ boolean untrack(@NonNull Target<?> target) {
     }
   }
 
-  void track(@NonNull Target<?> target, @NonNull Request request) {
+  synchronized void track(@NonNull Target<?> target, @NonNull Request request) {
     targetTracker.track(target);
     requestTracker.runRequest(request);
   }
@@ -652,7 +645,7 @@ void track(@NonNull Target<?> target, @NonNull Request request) {
     return defaultRequestListeners;
   }
 
-  RequestOptions getDefaultRequestOptions() {
+  synchronized RequestOptions getDefaultRequestOptions() {
     return requestOptions;
   }
 
@@ -662,12 +655,13 @@ RequestOptions getDefaultRequestOptions() {
   }
 
   @Override
-  public String toString() {
+  public synchronized String toString() {
     return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
   }
 
-  private static class RequestManagerConnectivityListener implements ConnectivityMonitor
-      .ConnectivityListener {
+  private class RequestManagerConnectivityListener
+      implements ConnectivityMonitor.ConnectivityListener {
+    @GuardedBy("RequestManager.this")
     private final RequestTracker requestTracker;
 
     RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
@@ -677,7 +671,9 @@ public String toString() {
     @Override
     public void onConnectivityChanged(boolean isConnected) {
       if (isConnected) {
-        requestTracker.restartRequests();
+        synchronized (RequestManager.this) {
+          requestTracker.restartRequests();
+        }
       }
     }
   }
@@ -691,7 +687,7 @@ public void onConnectivityChanged(boolean isConnected) {
     @Override
     public void onResourceReady(@NonNull Object resource,
         @Nullable Transition<? super Object> transition) {
-      // Do nothing.
+
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
index 5ccbf7b7f..9b25b8a97 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -1,71 +1,82 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Handler;
-import android.os.Handler.Callback;
-import android.os.Looper;
-import android.os.Message;
 import android.os.Process;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.util.Executors;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
-import com.bumptech.glide.util.Util;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadFactory;
 
 final class ActiveResources {
-  private static final int MSG_CLEAN_REF = 1;
-
   private final boolean isActiveResourceRetentionAllowed;
-  private final Handler mainHandler = new Handler(Looper.getMainLooper(), new Callback() {
-    @Override
-    public boolean handleMessage(Message msg) {
-      if (msg.what == MSG_CLEAN_REF) {
-        cleanupActiveReference((ResourceWeakReference) msg.obj);
-        return true;
-      }
-      return false;
-    }
-  });
+  private final Executor monitorClearedResourcesExecutor;
   @VisibleForTesting
   final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+  private final ReferenceQueue<EngineResource<?>> resourceReferenceQueue = new ReferenceQueue<>();
 
   private ResourceListener listener;
 
-  /**
-   * Lazily instantiate to avoid exceptions if Glide is initialized on a background thread.
-   *
-   * @see <a href="https://github.com/bumptech/glide/issues/295">#295</a>
-   */
-  @Nullable
-  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
-  @Nullable
-  private Thread cleanReferenceQueueThread;
   private volatile boolean isShutdown;
   @Nullable
   private volatile DequeuedResourceCallback cb;
 
   ActiveResources(boolean isActiveResourceRetentionAllowed) {
+    this(
+        isActiveResourceRetentionAllowed,
+        java.util.concurrent.Executors.newSingleThreadExecutor(
+            new ThreadFactory() {
+              @Override
+              public Thread newThread(@NonNull final Runnable r) {
+                return new Thread(
+                    new Runnable() {
+                      @Override
+                      public void run() {
+                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+                        r.run();
+                      }
+                    },
+                    "glide-active-resources");
+              }
+            }));
+  }
+
+  @VisibleForTesting
+  ActiveResources(
+      boolean isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) {
     this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
+    this.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;
+
+    monitorClearedResourcesExecutor.execute(
+        new Runnable() {
+          @Override
+          public void run() {
+            cleanReferenceQueue();
+          }
+        });
   }
 
   void setListener(ResourceListener listener) {
-    this.listener = listener;
+    synchronized (listener) {
+      synchronized (this) {
+        this.listener = listener;
+      }
+    }
   }
 
-  void activate(Key key, EngineResource<?> resource) {
+  synchronized void activate(Key key, EngineResource<?> resource) {
     ResourceWeakReference toPut =
         new ResourceWeakReference(
-            key,
-            resource,
-            getReferenceQueue(),
-            isActiveResourceRetentionAllowed);
+            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);
 
     ResourceWeakReference removed = activeEngineResources.put(key, toPut);
     if (removed != null) {
@@ -73,7 +84,7 @@ void activate(Key key, EngineResource<?> resource) {
     }
   }
 
-  void deactivate(Key key) {
+  synchronized void deactivate(Key key) {
     ResourceWeakReference removed = activeEngineResources.remove(key);
     if (removed != null) {
       removed.reset();
@@ -81,7 +92,7 @@ void deactivate(Key key) {
   }
 
   @Nullable
-  EngineResource<?> get(Key key) {
+  synchronized EngineResource<?> get(Key key) {
     ResourceWeakReference activeRef = activeEngineResources.get(key);
     if (activeRef == null) {
       return null;
@@ -94,34 +105,24 @@ void deactivate(Key key) {
     return active;
   }
 
-  @SuppressWarnings("WeakerAccess")
-  @Synthetic void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
-    Util.assertMainThread();
-    activeEngineResources.remove(ref.key);
-
-    if (!ref.isCacheable || ref.resource == null) {
-      return;
-    }
-    EngineResource<?> newResource =
-        new EngineResource<>(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
-    newResource.setResourceListener(ref.key, listener);
-    listener.onResourceReleased(ref.key, newResource);
-  }
-
-  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
-    if (resourceReferenceQueue == null) {
-      resourceReferenceQueue = new ReferenceQueue<>();
-      cleanReferenceQueueThread = new Thread(new Runnable() {
-        @SuppressWarnings("InfiniteLoopStatement")
-        @Override
-        public void run() {
-          Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-          cleanReferenceQueue();
+  @SuppressWarnings({"WeakerAccess", "SynchronizeOnNonFinalField"})
+  @Synthetic
+  void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
+    // Fixes a deadlock where we normally acquire the Engine lock and then the ActiveResources lock
+    // but reverse that order in this one particular test. This is definitely a bit of a hack...
+    synchronized (listener) {
+      synchronized (this) {
+        activeEngineResources.remove(ref.key);
+
+        if (!ref.isCacheable || ref.resource == null) {
+          return;
         }
-      }, "glide-active-resources");
-      cleanReferenceQueueThread.start();
+        EngineResource<?> newResource =
+            new EngineResource<>(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+        newResource.setResourceListener(ref.key, listener);
+        listener.onResourceReleased(ref.key, newResource);
+      }
     }
-    return resourceReferenceQueue;
   }
 
   @SuppressWarnings("WeakerAccess")
@@ -129,7 +130,7 @@ public void run() {
     while (!isShutdown) {
       try {
         ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();
-        mainHandler.obtainMessage(MSG_CLEAN_REF, ref).sendToTarget();
+        cleanupActiveReference(ref);
 
         // This section for testing only.
         DequeuedResourceCallback current = cb;
@@ -156,18 +157,9 @@ void setDequeuedResourceCallback(DequeuedResourceCallback cb) {
   @VisibleForTesting
   void shutdown() {
     isShutdown = true;
-    if (cleanReferenceQueueThread == null) {
-      return;
-    }
-
-    cleanReferenceQueueThread.interrupt();
-    try {
-      cleanReferenceQueueThread.join(TimeUnit.SECONDS.toMillis(5));
-      if (cleanReferenceQueueThread.isAlive()) {
-        throw new RuntimeException("Failed to join in time");
-      }
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
+    if (monitorClearedResourcesExecutor instanceof ExecutorService) {
+      ExecutorService service = (ExecutorService) monitorClearedResourcesExecutor;
+      Executors.shutdownAndAwaitTermination(service);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java b/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java
new file mode 100644
index 000000000..9692fa765
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.load.engine;
+
+/**
+ * An exception indicating that code outside of Glide threw an unexpected exception.
+ *
+ * <p>This is useful to allow us to distinguish developer errors on the part of users of Glide from
+ * developer errors on the part of developers of Glide itself.
+ */
+final class CallbackException extends RuntimeException {
+  private static final long serialVersionUID = -7530898992688511851L;
+
+  CallbackException(Throwable cause) {
+    super("Unexpected exception thrown by non-Glide code", cause);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 903d0c9b6..0f05483e0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -216,6 +216,8 @@ public void cancel() {
     }
   }
 
+  // We need to rethrow only CallbackException, but not other types of Throwables.
+  @SuppressWarnings("PMD.AvoidRethrowingException")
   @Override
   public void run() {
     // This should be much more fine grained, but since Java's thread pool implementation silently
@@ -231,6 +233,10 @@ public void run() {
         return;
       }
       runWrapped();
+    } catch (CallbackException e) {
+      // If a callback not controlled by Glide throws an exception, we should avoid the Glide
+      // specific debug logic below.
+      throw e;
     } catch (Throwable t) {
       // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our
       // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We
@@ -251,6 +257,7 @@ public void run() {
       if (!isCancelled) {
         throw t;
       }
+      throw t;
     } finally {
       // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
       // close in all cases anyway.
@@ -332,7 +339,8 @@ private void notifyComplete(Resource<R> resource, DataSource dataSource) {
   private void setNotifiedOrThrow() {
     stateVerifier.throwIfRecycled();
     if (isCallbackNotified) {
-      throw new IllegalStateException("Already notified");
+      Throwable lastThrown = throwables.isEmpty() ? null : throwables.get(throwables.size() - 1);
+      throw new IllegalStateException("Already notified", lastThrown);
     }
     isCallbackNotified = true;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index dbeb547cf..f3050c8b7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -16,14 +16,13 @@
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Executors;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
-import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import java.util.Map;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.Executor;
 
 /**
  * Responsible for starting loads and managing active and cached resources.
@@ -126,13 +125,14 @@ public Engine(
    * <p>Must be called on the main thread.
    *
    * <p>The flow for any request is as follows:
+   *
    * <ul>
-   *   <li>Check the current set of actively used resources, return the active resource if
-   *   present, and move any newly inactive resources into the memory cache.</li>
-   *   <li>Check the memory cache and provide the cached resource if present.</li>
-   *   <li>Check the current set of in progress loads and add the cb to the in progress load if
-   *   one is present.</li>
-   *   <li>Start a new load.</li>
+   *   <li>Check the current set of actively used resources, return the active resource if present,
+   *       and move any newly inactive resources into the memory cache.
+   *   <li>Check the memory cache and provide the cached resource if present.
+   *   <li>Check the current set of in progress loads and add the cb to the in progress load if one
+   *       is present.
+   *   <li>Start a new load.
    * </ul>
    *
    * <p>Active resources are those that have been provided to at least one request and have not yet
@@ -142,11 +142,11 @@ public Engine(
    * re-used if possible and the resource is discarded. There is no strict requirement that
    * consumers release their resources so active resources are held weakly.
    *
-   * @param width  The target width in pixels of the desired resource.
+   * @param width The target width in pixels of the desired resource.
    * @param height The target height in pixels of the desired resource.
-   * @param cb     The callback that will be called when the load completes.
+   * @param cb The callback that will be called when the load completes.
    */
-  public <R> LoadStatus load(
+  public synchronized <R> LoadStatus load(
       GlideContext glideContext,
       Object model,
       Key signature,
@@ -164,8 +164,8 @@ public Engine(
       boolean useUnlimitedSourceExecutorPool,
       boolean useAnimationPool,
       boolean onlyRetrieveFromCache,
-      ResourceCallback cb) {
-    Util.assertMainThread();
+      ResourceCallback cb,
+      Executor callbackExecutor) {
     long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;
 
     EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
@@ -191,7 +191,7 @@ public Engine(
 
     EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
     if (current != null) {
-      current.addCallback(cb);
+      current.addCallback(cb, callbackExecutor);
       if (VERBOSE_IS_LOGGABLE) {
         logWithTimeAndKey("Added to existing load", startTime, key);
       }
@@ -227,7 +227,7 @@ public Engine(
 
     jobs.put(key, engineJob);
 
-    engineJob.addCallback(cb);
+    engineJob.addCallback(cb, callbackExecutor);
     engineJob.start(decodeJob);
 
     if (VERBOSE_IS_LOGGABLE) {
@@ -282,7 +282,6 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
   }
 
   public void release(Resource<?> resource) {
-    Util.assertMainThread();
     if (resource instanceof EngineResource) {
       ((EngineResource<?>) resource).release();
     } else {
@@ -292,8 +291,8 @@ public void release(Resource<?> resource) {
 
   @SuppressWarnings("unchecked")
   @Override
-  public void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
-    Util.assertMainThread();
+  public synchronized void onEngineJobComplete(
+      EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
     // A null resource indicates that the load failed, usually due to an exception.
     if (resource != null) {
       resource.setResourceListener(key, this);
@@ -307,21 +306,17 @@ public void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<
   }
 
   @Override
-  public void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
-    Util.assertMainThread();
-
+  public synchronized void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
     jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
   public void onResourceRemoved(@NonNull final Resource<?> resource) {
-    Util.assertMainThread();
     resourceRecycler.recycle(resource);
   }
 
   @Override
-  public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
-    Util.assertMainThread();
+  public synchronized void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
     activeResources.deactivate(cacheKey);
     if (resource.isCacheable()) {
       cache.put(cacheKey, resource);
@@ -343,8 +338,10 @@ public void shutdown() {
 
   /**
    * Allows a request to indicate it no longer is interested in a given load.
+   *
+   * <p>Non-final for mocking.
    */
-  public static class LoadStatus {
+  public class LoadStatus {
     private final EngineJob<?> engineJob;
     private final ResourceCallback cb;
 
@@ -354,7 +351,13 @@ public void shutdown() {
     }
 
     public void cancel() {
-      engineJob.removeCallback(cb);
+      // Acquire the Engine lock so that a new request can't get access to a particular EngineJob
+      // just after the EngineJob has been cancelled. Without this lock, we'd allow new requests
+      // to find the cancelling EngineJob in our Jobs data structure. With this lock, the EngineJob
+      // is both cancelled and removed from Jobs atomically.
+      synchronized (Engine.this) {
+        engineJob.removeCallback(cb);
+      }
     }
   }
 
@@ -395,7 +398,7 @@ public DiskCache getDiskCache() {
   static class DecodeJobFactory {
     @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
     @Synthetic final Pools.Pool<DecodeJob<?>> pool =
-        FactoryPools.simple(JOB_POOL_SIZE,
+        FactoryPools.threadSafe(JOB_POOL_SIZE,
             new FactoryPools.Factory<DecodeJob<?>>() {
           @Override
           public DecodeJob<?> create() {
@@ -455,7 +458,7 @@ public DiskCache getDiskCache() {
     @Synthetic final GlideExecutor animationExecutor;
     @Synthetic final EngineJobListener listener;
     @Synthetic final Pools.Pool<EngineJob<?>> pool =
-        FactoryPools.simple(
+        FactoryPools.threadSafe(
             JOB_POOL_SIZE,
             new FactoryPools.Factory<EngineJob<?>>() {
               @Override
@@ -485,10 +488,10 @@ public DiskCache getDiskCache() {
 
     @VisibleForTesting
     void shutdown() {
-      shutdownAndAwaitTermination(diskCacheExecutor);
-      shutdownAndAwaitTermination(sourceExecutor);
-      shutdownAndAwaitTermination(sourceUnlimitedExecutor);
-      shutdownAndAwaitTermination(animationExecutor);
+      Executors.shutdownAndAwaitTermination(diskCacheExecutor);
+      Executors.shutdownAndAwaitTermination(sourceExecutor);
+      Executors.shutdownAndAwaitTermination(sourceUnlimitedExecutor);
+      Executors.shutdownAndAwaitTermination(animationExecutor);
     }
 
     @SuppressWarnings("unchecked")
@@ -506,20 +509,5 @@ void shutdown() {
           useAnimationPool,
           onlyRetrieveFromCache);
     }
-
-    private static void shutdownAndAwaitTermination(ExecutorService pool) {
-      long shutdownSeconds = 5;
-      pool.shutdown();
-      try {
-        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
-          pool.shutdownNow();
-          if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
-            throw new RuntimeException("Failed to shutdown");
-          }
-        }
-      } catch (InterruptedException ie) {
-        throw new RuntimeException(ie);
-      }
-    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 344a15036..c3bd7358e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -1,8 +1,5 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
 import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
@@ -10,12 +7,16 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Executors;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
-import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * A class that manages a load by adding and removing callbacks for for the load and notifying
@@ -24,16 +25,11 @@
 class EngineJob<R> implements DecodeJob.Callback<R>,
     Poolable {
   private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();
-  private static final Handler MAIN_THREAD_HANDLER =
-      new Handler(Looper.getMainLooper(), new MainThreadCallback());
 
-  private static final int MSG_COMPLETE = 1;
-  private static final int MSG_EXCEPTION = 2;
-  // Used when we realize we're cancelled on a background thread in reschedule and can recycle
-  // immediately rather than waiting for a result or an error.
-  private static final int MSG_CANCELLED = 3;
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final ResourceCallbacksAndExecutors cbs = new ResourceCallbacksAndExecutors();
 
-  private final List<ResourceCallback> cbs = new ArrayList<>(2);
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private final Pools.Pool<EngineJob<?>> pool;
   private final EngineResourceFactory engineResourceFactory;
@@ -42,6 +38,7 @@
   private final GlideExecutor sourceExecutor;
   private final GlideExecutor sourceUnlimitedExecutor;
   private final GlideExecutor animationExecutor;
+  private final AtomicInteger pendingCallbacks = new AtomicInteger();
 
   private Key key;
   private boolean isCacheable;
@@ -49,14 +46,23 @@
   private boolean useAnimationPool;
   private boolean onlyRetrieveFromCache;
   private Resource<?> resource;
-  private DataSource dataSource;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  DataSource dataSource;
+
   private boolean hasResource;
-  private GlideException exception;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  GlideException exception;
+
   private boolean hasLoadFailed;
-  // A put of callbacks that are removed while we're notifying other callbacks of a change in
-  // status.
-  private List<ResourceCallback> ignoredCallbacks;
-  private EngineResource<?> engineResource;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  EngineResource<?> engineResource;
+
   private DecodeJob<R> decodeJob;
 
   // Checked primarily on the main thread, but also on other threads in reschedule.
@@ -98,7 +104,7 @@
   }
 
   @VisibleForTesting
-  EngineJob<R> init(
+  synchronized EngineJob<R> init(
       Key key,
       boolean isCacheable,
       boolean useUnlimitedSourceGeneratorPool,
@@ -112,7 +118,7 @@
     return this;
   }
 
-  public void start(DecodeJob<R> decodeJob) {
+  public synchronized void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
     GlideExecutor executor = decodeJob.willDecodeFromCache()
         ? diskCacheExecutor
@@ -120,27 +126,56 @@ public void start(DecodeJob<R> decodeJob) {
     executor.execute(decodeJob);
   }
 
-  void addCallback(ResourceCallback cb) {
-    Util.assertMainThread();
+  synchronized void addCallback(final ResourceCallback cb, Executor callbackExecutor) {
     stateVerifier.throwIfRecycled();
+    cbs.add(cb, callbackExecutor);
     if (hasResource) {
-      cb.onResourceReady(engineResource, dataSource);
+      // Acquire early so that the resource isn't recycled while the Runnable below is still sitting
+      // in the executors queue.
+      incrementPendingCallbacks(1);
+      callbackExecutor.execute(new CallResourceReady(cb));
     } else if (hasLoadFailed) {
-      cb.onLoadFailed(exception);
+      incrementPendingCallbacks(1);
+      callbackExecutor.execute(new CallLoadFailed(cb));
     } else {
-      cbs.add(cb);
+      Preconditions.checkArgument(!isCancelled, "Cannot add callbacks to a cancelled EngineJob");
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  synchronized void callCallbackOnResourceReady(ResourceCallback cb) {
+    try {
+      // This is overly broad, some Glide code is actually called here, but it's much
+      // simpler to encapsulate here than to do so at the actual call point in the
+      // Request implementation.
+      cb.onResourceReady(engineResource, dataSource);
+    } catch (Throwable t) {
+      throw new CallbackException(t);
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  synchronized void callCallbackOnLoadFailed(ResourceCallback cb) {
+    // This is overly broad, some Glide code is actually called here, but it's much
+    // simpler to encapsulate here than to do so at the actual call point in the Request
+    // implementation.
+    try {
+      cb.onLoadFailed(exception);
+    } catch (Throwable t) {
+      throw new CallbackException(t);
     }
   }
 
-  void removeCallback(ResourceCallback cb) {
-    Util.assertMainThread();
+  synchronized void removeCallback(ResourceCallback cb) {
     stateVerifier.throwIfRecycled();
-    if (hasResource || hasLoadFailed) {
-      addIgnoredCallback(cb);
-    } else {
-      cbs.remove(cb);
-      if (cbs.isEmpty()) {
-        cancel();
+    cbs.remove(cb);
+    if (cbs.isEmpty()) {
+      cancel();
+      boolean isFinishedRunning = hasResource || hasLoadFailed;
+      if (isFinishedRunning && pendingCallbacks.get() == 0) {
+        release();
       }
     }
   }
@@ -154,99 +189,106 @@ private GlideExecutor getActiveSourceExecutor() {
         ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);
   }
 
-  // We cannot remove callbacks while notifying our list of callbacks directly because doing so
-  // would cause a ConcurrentModificationException. However, we need to obey the cancellation
-  // request such that if notifying a callback early in the callbacks list cancels a callback later
-  // in the request list, the cancellation for the later request is still obeyed. Using a put of
-  // ignored callbacks allows us to avoid the exception while still meeting the requirement.
-  private void addIgnoredCallback(ResourceCallback cb) {
-    if (ignoredCallbacks == null) {
-      ignoredCallbacks = new ArrayList<>(2);
-    }
-    if (!ignoredCallbacks.contains(cb)) {
-      ignoredCallbacks.add(cb);
-    }
-  }
-
-  private boolean isInIgnoredCallbacks(ResourceCallback cb) {
-    return ignoredCallbacks != null && ignoredCallbacks.contains(cb);
-  }
-
   // Exposed for testing.
   void cancel() {
-    if (hasLoadFailed || hasResource || isCancelled) {
+    if (isDone()) {
       return;
     }
 
     isCancelled = true;
     decodeJob.cancel();
-    // TODO: Consider trying to remove jobs that have never been run before from executor queues.
-    // Removing jobs that have run before can break things. See #1996.
     listener.onEngineJobCancelled(this, key);
   }
 
   // Exposed for testing.
-  boolean isCancelled() {
+  synchronized boolean isCancelled() {
     return isCancelled;
   }
 
+  private boolean isDone() {
+    return hasLoadFailed || hasResource || isCancelled;
+  }
+
+  // We have to post Runnables in a loop. Typically there will be very few callbacks. AccessorMethod
+  // seems to be a false positive
+  @SuppressWarnings(
+          {"WeakerAccess", "PMD.AvoidInstantiatingObjectsInLoops", "PMD.AccessorMethodGeneration"})
   @Synthetic
-  void handleResultOnMainThread() {
-    stateVerifier.throwIfRecycled();
-    if (isCancelled) {
-      resource.recycle();
-      release(false /*isRemovedFromQueue*/);
-      return;
-    } else if (cbs.isEmpty()) {
-      throw new IllegalStateException("Received a resource without any callbacks to notify");
-    } else if (hasResource) {
-      throw new IllegalStateException("Already have resource");
-    }
-    engineResource = engineResourceFactory.build(resource, isCacheable);
-    hasResource = true;
-
-    // Hold on to resource for duration of request so we don't recycle it in the middle of
-    // notifying if it synchronously released by one of the callbacks.
-    engineResource.acquire();
-    listener.onEngineJobComplete(this, key, engineResource);
-
-    //noinspection ForLoopReplaceableByForEach to improve perf
-    for (int i = 0, size = cbs.size(); i < size; i++) {
-      ResourceCallback cb = cbs.get(i);
-      if (!isInIgnoredCallbacks(cb)) {
-        engineResource.acquire();
-        cb.onResourceReady(engineResource, dataSource);
+  void notifyCallbacksOfResult() {
+    ResourceCallbacksAndExecutors copy;
+    Key localKey;
+    EngineResource<?> localResource;
+    synchronized (this) {
+      stateVerifier.throwIfRecycled();
+      if (isCancelled) {
+        // TODO: Seems like we might as well put this in the memory cache instead of just recycling
+        // it since we've gotten this far...
+        resource.recycle();
+        release();
+        return;
+      } else if (cbs.isEmpty()) {
+        throw new IllegalStateException("Received a resource without any callbacks to notify");
+      } else if (hasResource) {
+        throw new IllegalStateException("Already have resource");
       }
+      engineResource = engineResourceFactory.build(resource, isCacheable);
+      // Hold on to resource for duration of our callbacks below so we don't recycle it in the
+      // middle of notifying if it synchronously released by one of the callbacks. Acquire it under
+      // a lock here so that any newly added callback that executes before the next locked section
+      // below can't recycle the resource before we call the callbacks.
+      hasResource = true;
+      copy = cbs.copy();
+      incrementPendingCallbacks(copy.size() + 1);
+
+      localKey = key;
+      localResource = engineResource;
+    }
+
+    listener.onEngineJobComplete(this, localKey, localResource);
+
+    for (final ResourceCallbackAndExecutor entry : copy) {
+      entry.executor.execute(new CallResourceReady(entry.cb));
     }
-    // Our request is complete, so we can release the resource.
-    engineResource.release();
+    decrementPendingCallbacks();
+  }
 
-    release(false /*isRemovedFromQueue*/);
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  synchronized void incrementPendingCallbacks(int count) {
+    Preconditions.checkArgument(isDone(), "Not yet complete!");
+    if (pendingCallbacks.getAndAdd(count) == 0 && engineResource != null) {
+      engineResource.acquire();
+    }
   }
 
+  @SuppressWarnings("WeakerAccess")
   @Synthetic
-  void handleCancelledOnMainThread() {
+  synchronized void decrementPendingCallbacks() {
     stateVerifier.throwIfRecycled();
-    if (!isCancelled) {
-      throw new IllegalStateException("Not cancelled");
+    Preconditions.checkArgument(isDone(), "Not yet complete!");
+    int decremented = pendingCallbacks.decrementAndGet();
+    Preconditions.checkArgument(decremented >= 0, "Can't decrement below 0");
+    if (decremented == 0) {
+      if (engineResource != null) {
+        engineResource.release();
+      }
+
+      release();
     }
-    listener.onEngineJobCancelled(this, key);
-    release(false /*isRemovedFromQueue*/);
   }
 
-  private void release(boolean isRemovedFromQueue) {
-    Util.assertMainThread();
+  private synchronized void release() {
+    if (key == null) {
+      throw new IllegalArgumentException();
+    }
     cbs.clear();
     key = null;
     engineResource = null;
     resource = null;
-    if (ignoredCallbacks != null) {
-      ignoredCallbacks.clear();
-    }
     hasLoadFailed = false;
     isCancelled = false;
     hasResource = false;
-    decodeJob.release(isRemovedFromQueue);
+    decodeJob.release(/*isRemovedFromQueue=*/ false);
     decodeJob = null;
     exception = null;
     dataSource = null;
@@ -255,15 +297,19 @@ private void release(boolean isRemovedFromQueue) {
 
   @Override
   public void onResourceReady(Resource<R> resource, DataSource dataSource) {
-    this.resource = resource;
-    this.dataSource = dataSource;
-    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();
+    synchronized (this) {
+      this.resource = resource;
+      this.dataSource = dataSource;
+    }
+    notifyCallbacksOfResult();
   }
 
   @Override
   public void onLoadFailed(GlideException e) {
-    this.exception = e;
-    MAIN_THREAD_HANDLER.obtainMessage(MSG_EXCEPTION, this).sendToTarget();
+    synchronized (this) {
+      this.exception = e;
+    }
+    notifyCallbacksOfException();
   }
 
   @Override
@@ -273,28 +319,40 @@ public void reschedule(DecodeJob<?> job) {
     getActiveSourceExecutor().execute(job);
   }
 
+  // We have to post Runnables in a loop. Typically there will be very few callbacks. Acessor method
+  // warning seems to be false positive.
+  @SuppressWarnings(
+          {"WeakerAccess", "PMD.AvoidInstantiatingObjectsInLoops", "PMD.AccessorMethodGeneration"})
   @Synthetic
-  void handleExceptionOnMainThread() {
-    stateVerifier.throwIfRecycled();
-    if (isCancelled) {
-      release(false /*isRemovedFromQueue*/);
-      return;
-    } else if (cbs.isEmpty()) {
-      throw new IllegalStateException("Received an exception without any callbacks to notify");
-    } else if (hasLoadFailed) {
-      throw new IllegalStateException("Already failed once");
-    }
-    hasLoadFailed = true;
+  void notifyCallbacksOfException() {
+    ResourceCallbacksAndExecutors copy;
+    Key localKey;
+    synchronized (this) {
+      stateVerifier.throwIfRecycled();
+      if (isCancelled) {
+        release();
+        return;
+      } else if (cbs.isEmpty()) {
+        throw new IllegalStateException("Received an exception without any callbacks to notify");
+      } else if (hasLoadFailed) {
+        throw new IllegalStateException("Already failed once");
+      }
+      hasLoadFailed = true;
 
-    listener.onEngineJobComplete(this, key, null);
+      localKey = key;
 
-    for (ResourceCallback cb : cbs) {
-      if (!isInIgnoredCallbacks(cb)) {
-        cb.onLoadFailed(exception);
-      }
+      copy = cbs.copy();
+      // One for each callback below, plus one for ourselves so that we finish if a callback runs on
+      // another thread before we finish scheduling all of them.
+      incrementPendingCallbacks(copy.size() + 1);
     }
 
-    release(false /*isRemovedFromQueue*/);
+    listener.onEngineJobComplete(this, localKey, /*resource=*/ null);
+
+    for (ResourceCallbackAndExecutor entry : copy) {
+      entry.executor.execute(new CallLoadFailed(entry.cb));
+    }
+    decrementPendingCallbacks();
   }
 
   @NonNull
@@ -303,36 +361,127 @@ public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  @VisibleForTesting
-  static class EngineResourceFactory {
-    public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
-      return new EngineResource<>(resource, isMemoryCacheable, /*isRecyclable=*/ true);
+  private class CallLoadFailed implements Runnable {
+
+    private final ResourceCallback cb;
+
+    CallLoadFailed(ResourceCallback cb) {
+      this.cb = cb;
+    }
+
+    @Override
+    public void run() {
+      synchronized (EngineJob.this) {
+        if (cbs.contains(cb)) {
+          callCallbackOnLoadFailed(cb);
+        }
+
+        decrementPendingCallbacks();
+      }
     }
   }
 
-  private static class MainThreadCallback implements Handler.Callback {
+  private class CallResourceReady implements Runnable {
 
-    @Synthetic
-    @SuppressWarnings("WeakerAccess")
-    MainThreadCallback() { }
+    private final ResourceCallback cb;
+
+    CallResourceReady(ResourceCallback cb) {
+      this.cb = cb;
+    }
 
     @Override
-    public boolean handleMessage(Message message) {
-      EngineJob<?> job = (EngineJob<?>) message.obj;
-      switch (message.what) {
-        case MSG_COMPLETE:
-          job.handleResultOnMainThread();
-          break;
-        case MSG_EXCEPTION:
-          job.handleExceptionOnMainThread();
-          break;
-        case MSG_CANCELLED:
-          job.handleCancelledOnMainThread();
-          break;
-        default:
-          throw new IllegalStateException("Unrecognized message: " + message.what);
+    public void run() {
+      synchronized (EngineJob.this) {
+        if (cbs.contains(cb)) {
+          // Acquire for this particular callback.
+          engineResource.acquire();
+          callCallbackOnResourceReady(cb);
+          removeCallback(cb);
+        }
+        decrementPendingCallbacks();
       }
-      return true;
+    }
+  }
+
+  static final class ResourceCallbacksAndExecutors
+      implements Iterable<ResourceCallbackAndExecutor> {
+    private final List<ResourceCallbackAndExecutor> callbacksAndExecutors;
+
+    ResourceCallbacksAndExecutors() {
+      this(new ArrayList<ResourceCallbackAndExecutor>(2));
+    }
+
+    ResourceCallbacksAndExecutors(List<ResourceCallbackAndExecutor> callbacksAndExecutors) {
+      this.callbacksAndExecutors = callbacksAndExecutors;
+    }
+
+    void add(ResourceCallback cb, Executor executor) {
+      callbacksAndExecutors.add(new ResourceCallbackAndExecutor(cb, executor));
+    }
+
+    void remove(ResourceCallback cb) {
+      callbacksAndExecutors.remove(defaultCallbackAndExecutor(cb));
+    }
+
+    boolean contains(ResourceCallback cb) {
+      return callbacksAndExecutors.contains(defaultCallbackAndExecutor(cb));
+    }
+
+    boolean isEmpty() {
+      return callbacksAndExecutors.isEmpty();
+    }
+
+    int size() {
+      return callbacksAndExecutors.size();
+    }
+
+    void clear() {
+      callbacksAndExecutors.clear();
+    }
+
+    ResourceCallbacksAndExecutors copy() {
+      return new ResourceCallbacksAndExecutors(new ArrayList<>(callbacksAndExecutors));
+    }
+
+    private static ResourceCallbackAndExecutor defaultCallbackAndExecutor(ResourceCallback cb) {
+      return new ResourceCallbackAndExecutor(cb, Executors.directExecutor());
+    }
+
+    @NonNull
+    @Override
+    public Iterator<ResourceCallbackAndExecutor> iterator() {
+      return callbacksAndExecutors.iterator();
+    }
+  }
+
+  static final class ResourceCallbackAndExecutor {
+    final ResourceCallback cb;
+    final Executor executor;
+
+    ResourceCallbackAndExecutor(ResourceCallback cb, Executor executor) {
+      this.cb = cb;
+      this.executor = executor;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof ResourceCallbackAndExecutor) {
+        ResourceCallbackAndExecutor other = (ResourceCallbackAndExecutor) o;
+        return cb.equals(other.cb);
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return cb.hashCode();
+    }
+  }
+
+  @VisibleForTesting
+  static class EngineResourceFactory {
+    public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
+      return new EngineResource<>(resource, isMemoryCacheable, /*isRecyclable=*/ true);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 75bb1b841..5a4cd298b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Looper;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
@@ -30,7 +29,7 @@
     this.isRecyclable = isRecyclable;
   }
 
-  void setResourceListener(Key key, ResourceListener listener) {
+  synchronized void setResourceListener(Key key, ResourceListener listener) {
     this.key = key;
     this.listener = listener;
   }
@@ -61,7 +60,7 @@ public int getSize() {
   }
 
   @Override
-  public void recycle() {
+  public synchronized void recycle() {
     if (acquired > 0) {
       throw new IllegalStateException("Cannot recycle a resource while it is still acquired");
     }
@@ -78,18 +77,15 @@ public void recycle() {
    * Increments the number of consumers using the wrapped resource. Must be called on the main
    * thread.
    *
-   * <p> This must be called with a number corresponding to the number of new consumers each time
-   * new consumers begin using the wrapped resource. It is always safer to call acquire more often
-   * than necessary. Generally external users should never call this method, the framework will take
-   * care of this for you. </p>
+   * <p>This must be called with a number corresponding to the number of new consumers each time new
+   * consumers begin using the wrapped resource. It is always safer to call acquire more often than
+   * necessary. Generally external users should never call this method, the framework will take care
+   * of this for you.
    */
-  void acquire() {
+  synchronized void acquire() {
     if (isRecycled) {
       throw new IllegalStateException("Cannot acquire a recycled resource");
     }
-    if (!Looper.getMainLooper().equals(Looper.myLooper())) {
-      throw new IllegalThreadStateException("Must call acquire on the main thread");
-    }
     ++acquired;
   }
 
@@ -101,20 +97,17 @@ void acquire() {
    * done with the resource. Generally external users should never call this method, the framework
    * will take care of this for you.
    */
-  void release() {
+  synchronized void release() {
     if (acquired <= 0) {
       throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
     }
-    if (!Looper.getMainLooper().equals(Looper.myLooper())) {
-      throw new IllegalThreadStateException("Must call release on the main thread");
-    }
     if (--acquired == 0) {
       listener.onResourceReleased(key, this);
     }
   }
 
   @Override
-  public String toString() {
+  public synchronized String toString() {
     return "EngineResource{"
         + "isCacheable=" + isCacheable
         + ", listener=" + listener
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index 79d05eff5..f74488b3e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -27,6 +27,8 @@
   private DataSource dataSource;
   private Class<?> dataClass;
   private String detailMessage;
+  @Nullable
+  private Exception exception;
 
   public GlideException(String message) {
     this(message, Collections.<Throwable>emptyList());
@@ -52,7 +54,25 @@ void setLoggingDetails(Key key, DataSource dataSource, Class<?> dataClass) {
     this.dataClass = dataClass;
   }
 
+  /**
+   * Sets a stack trace that includes where the request originated.
+   *
+   * <p>This is an experimental API that may be removed in the future.
+   */
+  public void setOrigin(@Nullable Exception exception) {
+    this.exception = exception;
+  }
 
+  /**
+   * Returns an {@link Exception} with a stack trace that includes where the request originated
+   * (if previously set via {@link #setOrigin(Exception)})
+   *
+   * <p>This is an experimental API that may be removed in the future.
+   */
+  @Nullable
+  public Exception getOrigin() {
+    return exception;
+  }
 
   // No need to synchronize when doing nothing whatsoever.
   @SuppressWarnings("UnsynchronizedOverridesSynchronized")
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index 4ad3cf905..82b36ef98 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -4,7 +4,6 @@
 import android.os.Looper;
 import android.os.Message;
 import com.bumptech.glide.util.Synthetic;
-import com.bumptech.glide.util.Util;
 
 /**
  * A class that can safely recycle recursive resources.
@@ -14,14 +13,11 @@
   private final Handler handler =
       new Handler(Looper.getMainLooper(), new ResourceRecyclerCallback());
 
-  void recycle(Resource<?> resource) {
-    Util.assertMainThread();
-
+  synchronized void recycle(Resource<?> resource) {
     if (isRecycling) {
       // If a resource has sub-resources, releasing a sub resource can cause it's parent to be
-      // synchronously
-      // evicted which leads to a recycle loop when the parent releases it's children. Posting
-      // breaks this loop.
+      // synchronously evicted which leads to a recycle loop when the parent releases it's children.
+      // Posting breaks this loop.
       handler.obtainMessage(ResourceRecyclerCallback.RECYCLE_RESOURCE, resource).sendToTarget();
     } else {
       isRecycling = true;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index e496fde4e..a4b0f46b4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -80,8 +80,7 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
     if (result != null) {
       // Decrement must be called before reconfigure.
       decrementBitmapOfSize(bestKey.size, result);
-      result.reconfigure(width, height,
-          result.getConfig() != null ? result.getConfig() : Bitmap.Config.ARGB_8888);
+      result.reconfigure(width, height, config);
     }
     return result;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index e7f446ca5..3a03d37b1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import java.util.ArrayList;
@@ -132,7 +133,7 @@ public int hashCode() {
      *
      * @see #addHeader(String, LazyHeaderFactory)
      */
-    public Builder addHeader(String key, String value) {
+    public Builder addHeader(@NonNull String key, @NonNull String value) {
       return addHeader(key, new StringHeaderFactory(value));
     }
 
@@ -146,7 +147,7 @@ public Builder addHeader(String key, String value) {
      * <p> This class does not prevent you from adding the same value to a given key multiple
      * times </p>
      */
-    public Builder addHeader(String key, LazyHeaderFactory factory) {
+    public Builder addHeader(@NonNull String key, @NonNull LazyHeaderFactory factory) {
       if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
         return setHeader(key, factory);
       }
@@ -166,7 +167,7 @@ public Builder addHeader(String key, LazyHeaderFactory factory) {
      * (i.e. an OAuth token). </p>
      */
     @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}) // Public API
-    public Builder setHeader(String key, String value) {
+    public Builder setHeader(@NonNull String key, @Nullable String value) {
       return setHeader(key, value == null ? null : new StringHeaderFactory(value));
     }
 
@@ -176,7 +177,7 @@ public Builder setHeader(String key, String value) {
      *
      * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
      */
-    public Builder setHeader(String key, LazyHeaderFactory factory) {
+    public Builder setHeader(@NonNull String key, @Nullable LazyHeaderFactory factory) {
       copyIfNecessary();
       if (factory == null) {
         headers.remove(key);
@@ -255,9 +256,10 @@ static String getSanitizedUserAgent() {
 
   static final class StringHeaderFactory implements LazyHeaderFactory {
 
+    @NonNull
     private final String value;
 
-    StringHeaderFactory(String value) {
+    StringHeaderFactory(@NonNull String value) {
       this.value = value;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index bbe616a76..9d2476d9b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -80,6 +80,7 @@ public String toString() {
     private DataCallback<? super Data> callback;
     @Nullable
     private List<Throwable> exceptions;
+    private boolean isCancelled;
 
     MultiFetcher(
         @NonNull List<DataFetcher<Data>> fetchers,
@@ -97,6 +98,14 @@ public void loadData(
       this.callback = callback;
       exceptions = throwableListPool.acquire();
       fetchers.get(currentIndex).loadData(priority, this);
+
+      // If a race occurred where we cancelled the fetcher in cancel() and then called loadData here
+      // immediately after, make sure that we cancel the newly started fetcher. We don't bother
+      // checking cancelled before loadData because it's not required for correctness and would
+      // require an unlikely race to be useful.
+      if (isCancelled) {
+        cancel();
+      }
     }
 
     @Override
@@ -112,6 +121,7 @@ public void cleanup() {
 
     @Override
     public void cancel() {
+      isCancelled = true;
       for (DataFetcher<Data> fetcher : fetchers) {
         fetcher.cancel();
       }
@@ -145,6 +155,10 @@ public void onLoadFailed(@NonNull Exception e) {
     }
 
     private void startNextOrFail() {
+      if (isCancelled) {
+        return;
+      }
+
       if (currentIndex < fetchers.size() - 1) {
         currentIndex++;
         loadData(priority, callback);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java
new file mode 100644
index 000000000..e732f48dc
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Util;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * A {@link BitmapTransformation} which rotates the bitmap.
+ */
+public class Rotate extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.Rotate";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  private final int degreesToRotate;
+
+  /**
+    * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is
+    *                        not modified.
+   */
+  public Rotate(int degreesToRotate) {
+    this.degreesToRotate = degreesToRotate;
+  }
+
+  @Override
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.rotateImage(toTransform, degreesToRotate);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof Rotate) {
+      Rotate other = (Rotate) o;
+      return degreesToRotate == other.degreesToRotate;
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return Util.hashCode(ID.hashCode(),
+            Util.hashCode(degreesToRotate));
+  }
+
+  @Override
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+
+    byte[] degreesData = ByteBuffer.allocate(4).putInt(degreesToRotate).array();
+    messageDigest.update(degreesData);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 1c4d4812c..ff04a29ae 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -330,6 +330,8 @@ public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap i
 
     matrix.postTranslate(-newRect.left, -newRect.top);
 
+    result.setHasAlpha(inBitmap.hasAlpha());
+
     applyMatrix(inBitmap, result, matrix);
     return result;
   }
@@ -464,7 +466,7 @@ public static Bitmap roundedCorners(
    *
    * <p>This method does <em>NOT</em> resize the given {@link Bitmap}, it only rounds it's corners.
    * To both resize and round the corners of an image, consider
-   * {@link com.bumptech.glide.request.RequestOptions#transforms(Transformation[])} and/or
+   * {@link com.bumptech.glide.request.RequestOptions#transform(Transformation[])} and/or
    * {@link com.bumptech.glide.load.MultiTransformation}.
    *
    * @param inBitmap the source bitmap to use as a basis for the created bitmap.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
index f37045c7f..0923ffceb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
@@ -3,6 +3,7 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.support.annotation.DrawableRes;
@@ -22,6 +23,18 @@
  * other packages.
  */
 public class ResourceDrawableDecoder implements ResourceDecoder<Uri, Drawable> {
+  /**
+   * The package name to provide {@link Resources#getIdentifier(String, String, String)} when trying
+   * to find system resource ids.
+   *
+   * <p>As far as I can tell this is undocumented, but works.
+   */
+  private static final String ANDROID_PACKAGE_NAME = "android";
+  /**
+   * {@link Resources#getIdentifier(String, String, String)} documents that it will return 0 and
+   * that 0 is not a valid resouce id.
+   */
+  private static final int MISSING_RESOURCE_ID = 0;
   // android.resource://<package_name>/<type>/<name>.
   private static final int NAME_URI_PATH_SEGMENTS = 2;
   private static final int TYPE_PATH_SEGMENT_INDEX = 0;
@@ -45,47 +58,71 @@ public boolean handles(@NonNull Uri source, @NonNull Options options) {
   @Override
   public Resource<Drawable> decode(@NonNull Uri source, int width, int height,
       @NonNull Options options) {
-    @DrawableRes int resId = loadResourceIdFromUri(source);
     String packageName = source.getAuthority();
-    Context targetContext = packageName.equals(context.getPackageName())
-        ? context : getContextForPackage(source, packageName);
+    Context targetContext = findContextForPackage(source, packageName);
+    @DrawableRes int resId = findResourceIdFromUri(targetContext, source);
     // We can't get a theme from another application.
     Drawable drawable = DrawableDecoderCompat.getDrawable(context, targetContext, resId);
     return NonOwnedDrawableResource.newInstance(drawable);
   }
 
   @NonNull
-  private Context getContextForPackage(Uri source, String packageName) {
+  private Context findContextForPackage(Uri source, String packageName) {
+    // Fast path
+    if (packageName.equals(context.getPackageName())) {
+      return context;
+    }
+
     try {
       return context.createPackageContext(packageName, /*flags=*/ 0);
     } catch (NameNotFoundException e) {
+      // The parent APK holds the correct context if the resource is located in a split
+      if (packageName.contains(context.getPackageName())) {
+        return context;
+      }
+
       throw new IllegalArgumentException(
           "Failed to obtain context or unrecognized Uri format for: " + source, e);
     }
   }
 
   @DrawableRes
-  private int loadResourceIdFromUri(Uri source) {
+  private int findResourceIdFromUri(Context context, Uri source) {
     List<String> segments = source.getPathSegments();
-    @DrawableRes Integer result = null;
     if (segments.size() == NAME_URI_PATH_SEGMENTS) {
-      String packageName = source.getAuthority();
-      String typeName = segments.get(TYPE_PATH_SEGMENT_INDEX);
-      String resourceName = segments.get(NAME_PATH_SEGMENT_INDEX);
-      result = context.getResources().getIdentifier(resourceName, typeName, packageName);
+      return findResourceIdFromTypeAndNameResourceUri(context, source);
     } else if (segments.size() == ID_PATH_SEGMENTS) {
-      try {
-        result = Integer.valueOf(segments.get(RESOURCE_ID_SEGMENT_INDEX));
-      } catch (NumberFormatException e) {
-        // Ignored.
-      }
+      return findResourceIdFromResourceIdUri(source);
+    } else {
+      throw new IllegalArgumentException("Unrecognized Uri format: " + source);
     }
+  }
 
-    if (result == null) {
-      throw new IllegalArgumentException("Unrecognized Uri format: " + source);
-    } else if (result == 0) {
-      throw new IllegalArgumentException("Failed to obtain resource id for: " + source);
+  // android.resource://com.android.camera2/mipmap/logo_camera_color
+  @DrawableRes
+  private int findResourceIdFromTypeAndNameResourceUri(Context context, Uri source) {
+    List<String> segments = source.getPathSegments();
+    String packageName = source.getAuthority();
+    String typeName = segments.get(TYPE_PATH_SEGMENT_INDEX);
+    String resourceName = segments.get(NAME_PATH_SEGMENT_INDEX);
+    int result = context.getResources().getIdentifier(resourceName, typeName, packageName);
+    if (result == MISSING_RESOURCE_ID) {
+      result = Resources.getSystem().getIdentifier(resourceName, typeName, ANDROID_PACKAGE_NAME);
+    }
+    if (result == MISSING_RESOURCE_ID) {
+      throw new IllegalArgumentException("Failed to find resource id for: " + source);
     }
     return result;
   }
+
+  // android.resource://com.android.camera2/123456
+  @DrawableRes
+  private int findResourceIdFromResourceIdUri(Uri source) {
+    List<String> segments = source.getPathSegments();
+    try {
+      return Integer.parseInt(segments.get(RESOURCE_ID_SEGMENT_INDEX));
+    } catch (NumberFormatException e) {
+      throw new IllegalArgumentException("Unrecognized Uri format: " + source, e);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index cd0aa5248..8de52d8d1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -14,6 +14,7 @@
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
+import android.support.graphics.drawable.Animatable2Compat;
 import android.view.Gravity;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
@@ -21,12 +22,14 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * An animated {@link android.graphics.drawable.Drawable} that plays the frames of an animated GIF.
  */
 public class GifDrawable extends Drawable implements GifFrameLoader.FrameCallback,
-    Animatable {
+    Animatable, Animatable2Compat {
   /**
    * A constant indicating that an animated drawable should loop continuously.
    */
@@ -76,6 +79,11 @@
   private Paint paint;
   private Rect destRect;
 
+  /**
+   * Callbacks to notify loop completion of a gif, where the loop count is explicitly specified.
+   */
+  private List<AnimationCallback> animationCallbacks;
+
   /**
    * Constructor for GifDrawable.
    *
@@ -351,10 +359,19 @@ public void onFrameReady() {
     }
 
     if (maxLoopCount != LOOP_FOREVER && loopCount >= maxLoopCount) {
+      notifyAnimationEndToListeners();
       stop();
     }
   }
 
+  private void notifyAnimationEndToListeners() {
+    if (animationCallbacks != null) {
+      for (int i = 0, size = animationCallbacks.size(); i < size; i++) {
+        animationCallbacks.get(i).onAnimationEnd(this);
+      }
+    }
+  }
+
   @Override
   public ConstantState getConstantState() {
     return state;
@@ -390,6 +407,42 @@ public void setLoopCount(int loopCount) {
     }
   }
 
+  /**
+   * Register callback to listen to GifDrawable animation end event after specific loop count
+   * set by {@link GifDrawable#setLoopCount(int)}.
+   *
+   * Note: This will only be called if the Gif stop because it reaches the loop count. Unregister
+   * this in onLoadCleared to avoid potential memory leak.
+   * @see GifDrawable#unregisterAnimationCallback(AnimationCallback).
+   *
+   * @param animationCallback Animation callback {@link Animatable2Compat.AnimationCallback}.
+   */
+  @Override
+  public void registerAnimationCallback(@NonNull AnimationCallback animationCallback) {
+    if (animationCallback == null) {
+      return;
+    }
+    if (animationCallbacks == null) {
+      animationCallbacks = new ArrayList<>();
+    }
+    animationCallbacks.add(animationCallback);
+  }
+
+  @Override
+  public boolean unregisterAnimationCallback(@NonNull AnimationCallback animationCallback) {
+    if (animationCallbacks == null || animationCallback == null) {
+      return false;
+    }
+    return animationCallbacks.remove(animationCallback);
+  }
+
+  @Override
+  public void clearAnimationCallbacks() {
+    if (animationCallbacks != null) {
+      animationCallbacks.clear();
+    }
+  }
+
   static final class GifState extends ConstantState {
     @VisibleForTesting
     final GifFrameLoader frameLoader;
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
index 08136a327..ea7f66fa4 100644
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -929,6 +929,36 @@ public T transform(@NonNull Transformation<Bitmap> transformation) {
   @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
   @NonNull
   @CheckResult
+  public T transform(@NonNull Transformation<Bitmap>... transformations) {
+    if (transformations.length > 1) {
+      return transform(new MultiTransformation<>(transformations), /*isRequired=*/ true);
+    } else if (transformations.length == 1) {
+      return transform(transformations[0]);
+    } else {
+      return selfOrThrowIfLocked();
+    }
+  }
+
+  /**
+   * Applies the given {@link Transformation}s in the given order for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   *
+   * @deprecated Deprecated due to api update, use {@link #transform(Transformation[])} instead
+   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
+  @NonNull
+  @CheckResult
+  @Deprecated
   public T transforms(@NonNull Transformation<Bitmap>... transformations) {
     return transform(new MultiTransformation<>(transformations), /*isRequired=*/ true);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 77dad3e09..5289da076 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.request;
 
 import android.graphics.drawable.Drawable;
-import android.os.Handler;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
@@ -20,43 +19,40 @@
  * A {@link java.util.concurrent.Future} implementation for Glide that can be used to load resources
  * in a blocking manner on background threads.
  *
- * <p> Note - Unlike most targets, RequestFutureTargets can be used once and only once. Attempting
- * to reuse a RequestFutureTarget will probably result in undesirable behavior or exceptions.
- * Instead of reusing objects of this class, the pattern should be:
+ * <p>Note - Unlike most targets, RequestFutureTargets can be used once and only once. Attempting to
+ * reuse a RequestFutureTarget will probably result in undesirable behavior or exceptions. Instead
+ * of reusing objects of this class, the pattern should be:
  *
- * <pre>
- *     {@code
- *      FutureTarget<File> target = null;
- *      RequestManager requestManager = Glide.with(context);
- *      try {
- *        target = requestManager
- *           .downloadOnly()
- *           .load(model)
- *           .submit();
- *        File downloadedFile = target.get();
- *        // ... do something with the file (usually throws IOException)
- *      } catch (ExecutionException | InterruptedException | IOException e) {
- *        // ... bug reporting or recovery
- *      } finally {
- *        // make sure to cancel pending operations and free resources
- *        if (target != null) {
- *          target.cancel(true); // mayInterruptIfRunning
- *        }
- *      }
- *     }
- *     </pre>
- * The {@link #cancel(boolean)} call will cancel pending operations and
- * make sure that any resources used are recycled.
- * </p>
+ * <pre>{@code
+ *  FutureTarget<File> target = null;
+ *  RequestManager requestManager = Glide.with(context);
+ *  try {
+ *    target = requestManager
+ *       .downloadOnly()
+ *       .load(model)
+ *       .submit();
+ *    File downloadedFile = target.get();
+ *    // ... do something with the file (usually throws IOException)
+ *  } catch (ExecutionException | InterruptedException | IOException e) {
+ *    // ... bug reporting or recovery
+ *  } finally {
+ *    // make sure to cancel pending operations and free resources
+ *    if (target != null) {
+ *      target.cancel(true); // mayInterruptIfRunning
+ *    }
+ *  }
+ * }
+ *
+ * </pre>
+ *
+ * The {@link #cancel(boolean)} call will cancel pending operations and make sure that any resources
+ * used are recycled.
  *
  * @param <R> The type of the resource that will be loaded.
  */
-public class RequestFutureTarget<R> implements FutureTarget<R>,
-    RequestListener<R>,
-    Runnable {
+public class RequestFutureTarget<R> implements FutureTarget<R>, RequestListener<R> {
   private static final Waiter DEFAULT_WAITER = new Waiter();
 
-  private final Handler mainHandler;
   private final int width;
   private final int height;
   // Exists for testing only.
@@ -70,16 +66,12 @@
   private boolean loadFailed;
   @Nullable private GlideException exception;
 
-  /**
-   * Constructor for a RequestFutureTarget. Should not be used directly.
-   */
-  public RequestFutureTarget(Handler mainHandler, int width, int height) {
-    this(mainHandler, width, height, true, DEFAULT_WAITER);
+  /** Constructor for a RequestFutureTarget. Should not be used directly. */
+  public RequestFutureTarget(int width, int height) {
+    this(width, height, true, DEFAULT_WAITER);
   }
 
-  RequestFutureTarget(Handler mainHandler, int width, int height, boolean assertBackgroundThread,
-      Waiter waiter) {
-    this.mainHandler = mainHandler;
+  RequestFutureTarget(int width, int height, boolean assertBackgroundThread, Waiter waiter) {
     this.width = width;
     this.height = height;
     this.assertBackgroundThread = assertBackgroundThread;
@@ -93,8 +85,9 @@ public synchronized boolean cancel(boolean mayInterruptIfRunning) {
     }
     isCancelled = true;
     waiter.notifyAll(this);
-    if (mayInterruptIfRunning) {
-      clearOnMainThread();
+    if (mayInterruptIfRunning && request != null) {
+      request.clear();
+      request = null;
     }
     return true;
   }
@@ -138,13 +131,13 @@ public void removeCallback(@NonNull SizeReadyCallback cb) {
   }
 
   @Override
-  public void setRequest(@Nullable Request request) {
+  public synchronized void setRequest(@Nullable Request request) {
     this.request = request;
   }
 
   @Override
   @Nullable
-  public Request getRequest() {
+  public synchronized Request getRequest() {
     return request;
   }
 
@@ -219,21 +212,6 @@ private synchronized R doGet(Long timeoutMillis)
     return resource;
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
-  @Override
-  public void run() {
-    if (request != null) {
-      request.clear();
-      request = null;
-    }
-  }
-
-  private void clearOnMainThread() {
-    mainHandler.post(this);
-  }
-
   @Override
   public void onStart() {
     // Do nothing.
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index 74b33246c..fa6b4721f 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -2,6 +2,7 @@
 
 import android.graphics.drawable.Drawable;
 import android.support.annotation.Nullable;
+import android.widget.ImageView;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
@@ -10,6 +11,15 @@
 /**
  * A class for monitoring the status of a request while images load.
  *
+ * <p>All methods in this interface will be called from a background thread if the
+ * {@code RequestListener} is added to a request that is started with
+ * {@link RequestBuilder#submit()}, {@link RequestBuilder#submit(int, int)}, or
+ * {@link RequestBuilder#into(int, int)}. Those methods no longer post results back to the main
+ * thread to avoid the unnecessary thread interactions and corresponding latency. As a side affect
+ * though, listeners added to those requests are no longer called on the main thread.
+ * {@code RequestListeners} added to requests started with {@link RequestBuilder#into(Target)} or
+ * {@link RequestBuilder#into(ImageView)} will continue to be called back on the main thread.
+ *
  * @param <R> The type of resource being loaded.
  */
 public interface RequestListener<R> {
@@ -28,6 +38,8 @@
    * {@link Target} at this point, as long as you return {@code true} from the method to prevent
    * {@link Target#onLoadFailed(Drawable)} from being called.
    *
+   * <p>For threading guarantees, see the class comment.
+   *
    * For example:
    * <pre>
    * {@code
@@ -39,6 +51,7 @@
    * </pre>
    * </p>
    *
+   *
    * @param e               The maybe {@code null} exception containing information about why the
    *                        request failed.
    * @param model           The model we were trying to load when the exception occurred.
@@ -56,19 +69,19 @@ boolean onLoadFailed(
    * Called when a load completes successfully, immediately before {@link
    * Target#onResourceReady(Object, com.bumptech.glide.request.transition.Transition)}.
    *
-   * @param resource          The resource that was loaded for the target.
-   * @param model             The specific model that was used to load the image.
-   * @param target            The target the model was loaded into.
-   * @param dataSource        The {@link DataSource} the resource was loaded from.
-   * @param isFirstResource   {@code true} if this is the first resource to in this load to be
-   *                          loaded into the target. For example when loading a thumbnail and a
-   *                          full-sized image, this will be {@code true} for the first image to
-   *                          load and {@code false} for the second.
+   * <p>For threading guarantees, see the class comment.
    *
+   * @param resource The resource that was loaded for the target.
+   * @param model The specific model that was used to load the image.
+   * @param target The target the model was loaded into.
+   * @param dataSource The {@link DataSource} the resource was loaded from.
+   * @param isFirstResource {@code true} if this is the first resource to in this load to be loaded
+   *     into the target. For example when loading a thumbnail and a full-sized image, this will be
+   *     {@code true} for the first image to load and {@code false} for the second.
    * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
-   * {@code target}, typically because the listener wants to update the {@code target} or the object
-   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}
-   * to be called on {@code target}.
+   *     {@code target}, typically because the listener wants to update the {@code target} or the
+   *     object the {@code target} wraps itself or {@code false} to allow {@link
+   *     Target#onLoadFailed(Drawable)} to be called on {@code target}.
    */
   boolean onResourceReady(
       R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource);
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 7207bc57e..03d3b34cc 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -4,6 +4,7 @@
 import android.content.res.Resources.Theme;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.DrawableRes;
+import android.support.annotation.GuardedBy;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.util.Pools;
@@ -25,6 +26,7 @@
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
 import java.util.List;
+import java.util.concurrent.Executor;
 
 /**
  * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given
@@ -40,7 +42,7 @@
   private static final String TAG = "Request";
   /** Tag for logging externally useful events (request completion, timing etc). */
   private static final String GLIDE_TAG = "Glide";
-  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.simple(150,
+  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.threadSafe(150,
       new FactoryPools.Factory<SingleRequest<?>>() {
         @Override
         public SingleRequest<?> create() {
@@ -99,15 +101,19 @@
   @Nullable private List<RequestListener<R>> requestListeners;
   private Engine engine;
   private TransitionFactory<? super R> animationFactory;
+  private Executor callbackExecutor;
   private Resource<R> resource;
   private Engine.LoadStatus loadStatus;
   private long startTime;
+  @GuardedBy("this")
   private Status status;
   private Drawable errorDrawable;
   private Drawable placeholderDrawable;
   private Drawable fallbackDrawable;
   private int width;
   private int height;
+  @Nullable
+  private RuntimeException requestOrigin;
 
   public static <R> SingleRequest<R> obtain(
       Context context,
@@ -123,7 +129,8 @@
       @Nullable List<RequestListener<R>> requestListeners,
       RequestCoordinator requestCoordinator,
       Engine engine,
-      TransitionFactory<? super R> animationFactory) {
+      TransitionFactory<? super R> animationFactory,
+      Executor callbackExecutor) {
     @SuppressWarnings("unchecked") SingleRequest<R> request =
         (SingleRequest<R>) POOL.acquire();
     if (request == null) {
@@ -143,7 +150,8 @@
         requestListeners,
         requestCoordinator,
         engine,
-        animationFactory);
+        animationFactory,
+        callbackExecutor);
     return request;
   }
 
@@ -153,7 +161,7 @@
     // just create, instances are reused with recycle/init
   }
 
-  private void init(
+  private synchronized void init(
       Context context,
       GlideContext glideContext,
       Object model,
@@ -167,7 +175,8 @@ private void init(
       @Nullable List<RequestListener<R>> requestListeners,
       RequestCoordinator requestCoordinator,
       Engine engine,
-      TransitionFactory<? super R> animationFactory) {
+      TransitionFactory<? super R> animationFactory,
+      Executor callbackExecutor) {
     this.context = context;
     this.glideContext = glideContext;
     this.model = model;
@@ -182,7 +191,12 @@ private void init(
     this.requestCoordinator = requestCoordinator;
     this.engine = engine;
     this.animationFactory = animationFactory;
+    this.callbackExecutor = callbackExecutor;
     status = Status.PENDING;
+
+    if (requestOrigin == null && glideContext.isLoggingRequestOriginsEnabled()) {
+      requestOrigin = new RuntimeException("Glide request origin trace");
+    }
   }
 
   @NonNull
@@ -192,7 +206,7 @@ public StateVerifier getVerifier() {
   }
 
   @Override
-  public void recycle() {
+  public synchronized void recycle() {
     assertNotCallingCallbacks();
     context = null;
     glideContext = null;
@@ -212,11 +226,12 @@ public void recycle() {
     fallbackDrawable = null;
     width = -1;
     height = -1;
+    requestOrigin = null;
     POOL.release(this);
   }
 
   @Override
-  public void begin() {
+  public synchronized void begin() {
     assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
@@ -298,13 +313,12 @@ private void assertNotCallingCallbacks() {
    * Cancels the current load if it is in progress, clears any resources held onto by the request
    * and replaces the loaded resource if the load completed with the placeholder.
    *
-   * <p> Cleared requests can be restarted with a subsequent call to {@link #begin()} </p>
+   * <p>Cleared requests can be restarted with a subsequent call to {@link #begin()}
    *
    * @see #cancel()
    */
   @Override
-  public void clear() {
-    Util.assertMainThread();
+  public synchronized void clear() {
     assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     if (status == Status.CLEARED) {
@@ -328,27 +342,27 @@ private void releaseResource(Resource<?> resource) {
   }
 
   @Override
-  public boolean isRunning() {
+  public synchronized boolean isRunning() {
     return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
   }
 
   @Override
-  public boolean isComplete() {
+  public synchronized boolean isComplete() {
     return status == Status.COMPLETE;
   }
 
   @Override
-  public boolean isResourceSet() {
+  public synchronized boolean isResourceSet() {
     return isComplete();
   }
 
   @Override
-  public boolean isCleared() {
+  public synchronized boolean isCleared() {
     return status == Status.CLEARED;
   }
 
   @Override
-  public boolean isFailed() {
+  public synchronized boolean isFailed() {
     return status == Status.FAILED;
   }
 
@@ -388,7 +402,7 @@ private Drawable loadDrawable(@DrawableRes int resourceId) {
     return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
   }
 
-  private void setErrorPlaceholder() {
+  private synchronized void setErrorPlaceholder() {
     if (!canNotifyStatusChanged()) {
       return;
     }
@@ -412,7 +426,7 @@ private void setErrorPlaceholder() {
    * A callback method that should never be invoked directly.
    */
   @Override
-  public void onSizeReady(int width, int height) {
+  public synchronized void onSizeReady(int width, int height) {
     stateVerifier.throwIfRecycled();
     if (IS_VERBOSE_LOGGABLE) {
       logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
@@ -429,25 +443,27 @@ public void onSizeReady(int width, int height) {
     if (IS_VERBOSE_LOGGABLE) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
     }
-    loadStatus = engine.load(
-        glideContext,
-        model,
-        requestOptions.getSignature(),
-        this.width,
-        this.height,
-        requestOptions.getResourceClass(),
-        transcodeClass,
-        priority,
-        requestOptions.getDiskCacheStrategy(),
-        requestOptions.getTransformations(),
-        requestOptions.isTransformationRequired(),
-        requestOptions.isScaleOnlyOrNoTransform(),
-        requestOptions.getOptions(),
-        requestOptions.isMemoryCacheable(),
-        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
-        requestOptions.getUseAnimationPool(),
-        requestOptions.getOnlyRetrieveFromCache(),
-        this);
+    loadStatus =
+        engine.load(
+            glideContext,
+            model,
+            requestOptions.getSignature(),
+            this.width,
+            this.height,
+            requestOptions.getResourceClass(),
+            transcodeClass,
+            priority,
+            requestOptions.getDiskCacheStrategy(),
+            requestOptions.getTransformations(),
+            requestOptions.isTransformationRequired(),
+            requestOptions.isScaleOnlyOrNoTransform(),
+            requestOptions.getOptions(),
+            requestOptions.isMemoryCacheable(),
+            requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+            requestOptions.getUseAnimationPool(),
+            requestOptions.getOnlyRetrieveFromCache(),
+            this,
+            callbackExecutor);
 
     // This is a hack that's only useful for testing right now where loads complete synchronously
     // even though under any executor running on any thread but the main thread, the load would
@@ -492,12 +508,10 @@ private void notifyLoadFailed() {
     }
   }
 
-  /**
-   * A callback method that should never be invoked directly.
-   */
+  /** A callback method that should never be invoked directly. */
   @SuppressWarnings("unchecked")
   @Override
-  public void onResourceReady(Resource<?> resource, DataSource dataSource) {
+  public synchronized void onResourceReady(Resource<?> resource, DataSource dataSource) {
     stateVerifier.throwIfRecycled();
     loadStatus = null;
     if (resource == null) {
@@ -534,10 +548,10 @@ public void onResourceReady(Resource<?> resource, DataSource dataSource) {
    * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
    *
    * @param resource original {@link Resource}, never <code>null</code>
-   * @param result   object returned by {@link Resource#get()}, checked for type and never
-   *                 <code>null</code>
+   * @param result object returned by {@link Resource#get()}, checked for type and never <code>null
+   *     </code>
    */
-  private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
+  private synchronized void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
     // We must call isFirstReadyResource before setting status.
     boolean isFirstResource = isFirstReadyResource();
     status = Status.COMPLETE;
@@ -574,16 +588,15 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
     notifyLoadSuccess();
   }
 
-  /**
-   * A callback method that should never be invoked directly.
-   */
+  /** A callback method that should never be invoked directly. */
   @Override
-  public void onLoadFailed(GlideException e) {
+  public synchronized void onLoadFailed(GlideException e) {
     onLoadFailed(e, Log.WARN);
   }
 
-  private void onLoadFailed(GlideException e, int maxLogLevel) {
+  private synchronized void onLoadFailed(GlideException e, int maxLogLevel) {
     stateVerifier.throwIfRecycled();
+    e.setOrigin(requestOrigin);
     int logLevel = glideContext.getLogLevel();
     if (logLevel <= maxLogLevel) {
       Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
@@ -619,28 +632,34 @@ private void onLoadFailed(GlideException e, int maxLogLevel) {
     notifyLoadFailed();
   }
 
+  @SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
   @Override
-  public boolean isEquivalentTo(Request o) {
+  public synchronized boolean isEquivalentTo(Request o) {
     if (o instanceof SingleRequest) {
       SingleRequest<?> that = (SingleRequest<?>) o;
-      return overrideWidth == that.overrideWidth
-          && overrideHeight == that.overrideHeight
-          && Util.bothModelsNullEquivalentOrEquals(model, that.model)
-          && transcodeClass.equals(that.transcodeClass)
-          && requestOptions.equals(that.requestOptions)
-          && priority == that.priority
-          // We do not want to require that RequestListeners implement equals/hashcode, so we don't
-          // compare them using equals(). We can however, at least assert that the same amount of
-          // request listeners are present in both requests
-          && listenerCountEquals(this, that);
+      synchronized (that) {
+        return overrideWidth == that.overrideWidth
+            && overrideHeight == that.overrideHeight
+            && Util.bothModelsNullEquivalentOrEquals(model, that.model)
+            && transcodeClass.equals(that.transcodeClass)
+            && requestOptions.equals(that.requestOptions)
+            && priority == that.priority
+            // We do not want to require that RequestListeners implement equals/hashcode, so we
+            // don't compare them using equals(). We can however, at least assert that the same
+            // amount of request listeners are present in both requests.
+            && listenerCountEquals(that);
+      }
     }
     return false;
   }
 
-  private static boolean listenerCountEquals(SingleRequest<?> first, SingleRequest<?> second) {
-    int firstListenerCount = first.requestListeners == null ? 0 : first.requestListeners.size();
-    int secondListenerCount = second.requestListeners == null ? 0 : second.requestListeners.size();
-    return firstListenerCount == secondListenerCount;
+  @SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
+  private synchronized boolean listenerCountEquals(SingleRequest<?> other) {
+    synchronized (other) {
+      int firstListenerCount = requestListeners == null ? 0 : requestListeners.size();
+      int secondListenerCount = other.requestListeners == null ? 0 : other.requestListeners.size();
+      return firstListenerCount == secondListenerCount;
+    }
   }
 
   private void logV(String message) {
diff --git a/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
index ede0b2baf..ce7ebba38 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
@@ -57,7 +57,7 @@ public CustomTarget() {
   }
 
   /**
-   * Creates a new {@code CustomTarget} that will return the given {@code width} and {@link @code}
+   * Creates a new {@code CustomTarget} that will return the given {@code width} and {@code height}
    * as the requested size (unless overridden by
    * {@link com.bumptech.glide.request.RequestOptions#override(int)} in the request).
    *
diff --git a/library/src/main/java/com/bumptech/glide/util/Executors.java b/library/src/main/java/com/bumptech/glide/util/Executors.java
new file mode 100644
index 000000000..c37a558d0
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/Executors.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.util;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+
+/** Generic {@link Executor} implementations. */
+public final class Executors {
+  private Executors() {
+    // Utility class.
+  }
+
+  private static final Executor MAIN_THREAD_EXECUTOR =
+      new Executor() {
+        private final Handler handler = new Handler(Looper.getMainLooper());
+
+        @Override
+        public void execute(@NonNull Runnable command) {
+          handler.post(command);
+        }
+      };
+  private static final Executor DIRECT_EXECUTOR =
+      new Executor() {
+        @Override
+        public void execute(@NonNull Runnable command) {
+          command.run();
+        }
+      };
+
+  /** Posts executions to the main thread. */
+  public static Executor mainThreadExecutor() {
+    return MAIN_THREAD_EXECUTOR;
+  }
+
+  /** Immediately calls {@link Runnable#run()} on the current thread. */
+  public static Executor directExecutor() {
+    return DIRECT_EXECUTOR;
+  }
+
+  @VisibleForTesting
+  public static void shutdownAndAwaitTermination(ExecutorService pool) {
+    long shutdownSeconds = 5;
+    pool.shutdownNow();
+    try {
+      if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+        pool.shutdownNow();
+        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+          throw new RuntimeException("Failed to shutdown");
+        }
+      }
+    } catch (InterruptedException ie) {
+      pool.shutdownNow();
+      Thread.currentThread().interrupt();
+      throw new RuntimeException(ie);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
index 899090631..21a15ded9 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
@@ -26,6 +26,7 @@
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
 import android.widget.FrameLayout;
+import android.widget.LinearLayout;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
@@ -74,8 +75,19 @@ public void setUp() {
     target = new TestViewTarget(view);
     attachStateTarget = new AttachStateTarget(view);
 
-    activity.get().setContentView(view);
-    parent = (ViewGroup) view.getParent();
+    LinearLayout linearLayout = new LinearLayout(activity.get());
+    View expandView = new View(activity.get());
+    LinearLayout.LayoutParams linearLayoutParams =
+        new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, /*height=*/ 0);
+    linearLayoutParams.weight = 1f;
+    expandView.setLayoutParams(linearLayoutParams);
+    linearLayout.addView(expandView);
+
+    parent = new FrameLayout(activity.get());
+    parent.addView(view);
+    linearLayout.addView(parent);
+
+    activity.get().setContentView(linearLayout);
   }
 
   @After
@@ -113,7 +125,7 @@ public void testRetrievesRequestFromPreviousTargetForView() {
   @Test
   public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
     int dimens = 333;
-    activity.get().setContentView(view);
+    // activity.get().setContentView(view);
     view.layout(0, 0, dimens, dimens);
 
     target.getSize(cb);
@@ -231,14 +243,10 @@ public void testMatchParentWidthAndHeight() {
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
-    int width = 32;
-    int height = 45;
-    parent.getLayoutParams().width = width;
-    parent.getLayoutParams().height = height;
     activity.visible();
     view.getViewTreeObserver().dispatchOnPreDraw();
 
-    verify(cb).onSizeReady(eq(width), eq(height));
+    verify(cb).onSizeReady(eq(parent.getWidth()), eq(parent.getHeight()));
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
index 34dc8de84..41e8201fb 100644
--- a/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
@@ -45,6 +45,7 @@ public void setUp() {
         transitionOptions,
         /*defaultRequestListeners=*/ Collections.<RequestListener<Object>>emptyList(),
         mock(Engine.class),
+        /*isLoggingRequestOriginsEnabled=*/ false,
         Log.DEBUG);
   }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index 140bf5b92..70b7a084c 100644
--- a/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -111,8 +111,8 @@ public void runTest() {
     });
   }
 
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
+  @Test
+  public void doesNotThrowIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
     final Target<Object> target = mock(Target.class);
     testInBackground(new BackgroundTester() {
       @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
index a7a73ccae..9a60f6f2e 100644
--- a/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -162,8 +162,9 @@ public void testDoesNotRestartRequestsOnDisconnected() {
     verify(requestTracker, never()).restartRequests();
   }
 
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfResumeCalledOnBackgroundThread() throws InterruptedException {
+  @Test
+  public void resumeRequests_whenCalledOnBackgroundThread_doesNotThrow()
+      throws InterruptedException {
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
       public void runTest() {
@@ -172,8 +173,9 @@ public void runTest() {
     });
   }
 
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfPauseCalledOnBackgroundThread() throws InterruptedException {
+  @Test
+  public void pauseRequests_whenCalledOnBackgroundThread_doesNotThrow()
+      throws InterruptedException {
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
       public void runTest() {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
index 288ac29d5..a467ea774 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
@@ -7,12 +7,16 @@
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.ActiveResources.DequeuedResourceCallback;
 import com.bumptech.glide.load.engine.ActiveResources.ResourceWeakReference;
 import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
 import com.bumptech.glide.tests.GlideShadowLooper;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import org.junit.After;
 import org.junit.Before;
@@ -191,8 +195,7 @@ public void queueIdle_withNotCacheableResourceInActive_doesNotCallListener() {
   }
 
   @Test
-  public void queueIdle_withCacheableResourceInActive_removesResourceFromActive()
-      throws InterruptedException {
+  public void queueIdle_withCacheableResourceInActive_removesResourceFromActive() {
     EngineResource<Object> engineResource =
         new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
     resources.activate(key, engineResource);
@@ -275,38 +278,97 @@ public void queueIdle_withQueuedReferenceRetrievedFromGetAndNotCacheable_doesNot
 
   @Test
   public void queueIdle_withQueuedReferenceDeactivated_doesNotNotifyListener() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
-    resources.activate(key, engineResource);
-
-    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
-    CountDownLatch latch = getLatchForClearedRef();
-    weakRef.enqueue();
-
-    resources.deactivate(key);
-
-    waitForLatch(latch);
-
-    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    final ExecutorService delegate = Executors.newSingleThreadExecutor();
+    try {
+      final CountDownLatch blockExecutor = new CountDownLatch(1);
+      resources =
+          new ActiveResources(
+              /*isActiveResourceRetentionAllowed=*/ true,
+              new Executor() {
+                @Override
+                public void execute(@NonNull final Runnable command) {
+                  delegate.execute(
+                      new Runnable() {
+                        @Override
+                        public void run() {
+                          try {
+                            blockExecutor.await();
+                          } catch (InterruptedException e) {
+                            throw new RuntimeException(e);
+                          }
+                          command.run();
+                        }
+                      });
+                }
+              });
+      resources.setListener(listener);
+
+      EngineResource<Object> engineResource =
+          new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+      resources.activate(key, engineResource);
+
+      ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+      CountDownLatch latch = getLatchForClearedRef();
+      weakRef.enqueue();
+      resources.deactivate(key);
+      blockExecutor.countDown();
+
+      waitForLatch(latch);
+
+      verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    } finally {
+      resources.shutdown();
+      com.bumptech.glide.util.Executors.shutdownAndAwaitTermination(delegate);
+    }
   }
 
   @Test
   public void queueIdle_afterReferenceQueuedThenReactivated_doesNotNotifyListener() {
-    EngineResource<Object> first =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
-    resources.activate(key, first);
-
-    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
-    CountDownLatch latch = getLatchForClearedRef();
-    weakRef.enqueue();
-
-    EngineResource<Object> second =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
-    resources.activate(key, second);
-
-    waitForLatch(latch);
-
-    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    final ExecutorService delegate = Executors.newSingleThreadExecutor();
+    try {
+      final CountDownLatch blockExecutor = new CountDownLatch(1);
+      resources =
+          new ActiveResources(
+              /*isActiveResourceRetentionAllowed=*/ true,
+              new Executor() {
+                @Override
+                public void execute(@NonNull final Runnable command) {
+                  delegate.execute(
+                      new Runnable() {
+                        @Override
+                        public void run() {
+                          try {
+                            blockExecutor.await();
+                          } catch (InterruptedException e) {
+                            throw new RuntimeException(e);
+                          }
+                          command.run();
+                        }
+                      });
+                }
+              });
+      resources.setListener(listener);
+
+      EngineResource<Object> first =
+          new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+      resources.activate(key, first);
+
+      ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+      CountDownLatch latch = getLatchForClearedRef();
+      weakRef.enqueue();
+
+      EngineResource<Object> second =
+          new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+      resources.activate(key, second);
+      blockExecutor.countDown();
+
+      waitForLatch(latch);
+
+      verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    } finally {
+      resources.shutdown();
+      com.bumptech.glide.util.Executors.shutdownAndAwaitTermination(delegate);
+    }
   }
 
   @Test
@@ -321,6 +383,7 @@ public void activate_withNonCacheableResource_doesNotSaveResource() {
   @Test
   public void get_withActiveClearedKey_cacheableResource_retentionDisabled_doesNotCallListener() {
     resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    resources.setListener(listener);
     EngineResource<Object> engineResource =
         new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
     resources.activate(key, engineResource);
@@ -333,6 +396,7 @@ public void get_withActiveClearedKey_cacheableResource_retentionDisabled_doesNot
   @Test
   public void get_withQueuedReference_retentionDisabled_returnsResource() {
     resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    resources.setListener(listener);
     EngineResource<Object> engineResource =
         new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
     resources.activate(key, engineResource);
@@ -346,6 +410,7 @@ public void get_withQueuedReference_retentionDisabled_returnsResource() {
   @Test
   public void queueIdle_withQueuedReferenceRetrievedFromGet_retentionDisabled_doesNotNotify() {
     resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    resources.setListener(listener);
     EngineResource<Object> engineResource =
         new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
     resources.activate(key, engineResource);
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 7734cd208..d6bb580ed 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -24,6 +24,7 @@
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Executors;
 import java.util.ArrayList;
 import java.util.List;
 import org.junit.Before;
@@ -48,7 +49,7 @@ public void setUp() {
   }
 
   @Test
-  public void testOnResourceReadyPassedToCallbacks() throws Exception {
+  public void testOnResourceReadyPassedToCallbacks() {
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
@@ -182,7 +183,7 @@ public void testRemovingAllCallbacksCancelsRunner() {
   @Test
   public void removingSomeCallbacksDoesNotCancelRunner() {
     EngineJob<Object> job = harness.getJob();
-    job.addCallback(mock(ResourceCallback.class));
+    job.addCallback(mock(ResourceCallback.class), Executors.directExecutor());
     job.removeCallback(harness.cb);
 
     assertFalse(job.isCancelled());
@@ -233,11 +234,10 @@ public void testReleasesResourceIfCancelledOnReady() {
     Looper looper = harness.mainHandler.getLooper();
     Shadows.shadowOf(looper).pause();
 
-    EngineJob<Object> job = harness.getJob();
+    final EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource, harness.dataSource);
     job.cancel();
-    Shadows.shadowOf(looper).runOneTask();
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     verify(harness.resource).recycle();
   }
@@ -258,15 +258,18 @@ public void testNotifiesNewCallbackOfResourceIfCallbackIsAddedDuringOnResourceRe
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.addCallback(newCallback);
-        return null;
-      }
-    }).when(existingCallback).onResourceReady(anyResource(), isADataSource());
-
-    job.addCallback(existingCallback);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.addCallback(newCallback, Executors.directExecutor());
+                return null;
+              }
+            })
+        .when(existingCallback)
+        .onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(existingCallback, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
 
@@ -280,16 +283,19 @@ public void testNotifiesNewCallbackOfExceptionIfCallbackIsAddedDuringOnException
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.addCallback(newCallback);
-        return null;
-      }
-    }).when(existingCallback).onLoadFailed(any(GlideException.class));
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.addCallback(newCallback, Executors.directExecutor());
+                return null;
+              }
+            })
+        .when(existingCallback)
+        .onLoadFailed(any(GlideException.class));
 
     GlideException exception = new GlideException("test");
-    job.addCallback(existingCallback);
+    job.addCallback(existingCallback, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onLoadFailed(exception);
 
@@ -301,15 +307,18 @@ public void testRemovingCallbackDuringOnResourceReadyIsIgnoredIfCallbackHasAlrea
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(cb);
-        return null;
-      }
-    }).when(cb).onResourceReady(anyResource(), isADataSource());
-
-    job.addCallback(cb);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(cb);
+                return null;
+              }
+            })
+        .when(cb)
+        .onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(cb, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
 
@@ -322,16 +331,19 @@ public void testRemovingCallbackDuringOnExceptionIsIgnoredIfCallbackHasAlreadyBe
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(cb);
-        return null;
-      }
-    }).when(cb).onLoadFailed(any(GlideException.class));
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(cb);
+                return null;
+              }
+            })
+        .when(cb)
+        .onLoadFailed(any(GlideException.class));
 
     GlideException exception = new GlideException("test");
-    job.addCallback(cb);
+    job.addCallback(cb, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onLoadFailed(exception);
 
@@ -344,15 +356,18 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(notYetCalled);
-        return null;
-      }
-    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
-
-    job.addCallback(notYetCalled);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(notYetCalled);
+                return null;
+              }
+            })
+        .when(harness.cb)
+        .onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(notYetCalled, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
 
@@ -365,15 +380,18 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(notYetCalled);
-        return null;
-      }
-    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
-
-    job.addCallback(notYetCalled);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(notYetCalled);
+                return null;
+              }
+            })
+        .when(harness.cb)
+        .onResourceReady(anyResource(), isADataSource());
+
+    job.addCallback(notYetCalled, Executors.directExecutor());
     job.start(harness.decodeJob);
 
     job.onResourceReady(harness.resource, harness.dataSource);
@@ -389,16 +407,19 @@ public void testRemovingCallbackDuringOnExceptionPreventsCallbackFromBeingCalled
     final ResourceCallback called = mock(ResourceCallback.class);
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        job.removeCallback(notYetCalled);
-        return null;
-      }
-    }).when(called).onLoadFailed(any(GlideException.class));
-
-    job.addCallback(called);
-    job.addCallback(notYetCalled);
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                job.removeCallback(notYetCalled);
+                return null;
+              }
+            })
+        .when(called)
+        .onLoadFailed(any(GlideException.class));
+
+    job.addCallback(called, Executors.directExecutor());
+    job.addCallback(notYetCalled, Executors.directExecutor());
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
@@ -498,7 +519,7 @@ public MultiCbHarness() {
         cbs.add(mock(ResourceCallback.class));
       }
       for (ResourceCallback cb : cbs) {
-        job.addCallback(cb);
+        job.addCallback(cb, Executors.directExecutor());
       }
     }
   }
@@ -521,7 +542,7 @@ public MultiCbHarness() {
     final boolean useAnimationPool = false;
     final boolean onlyRetrieveFromCache = false;
     final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SynchronizedPool<>(1);
     final DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
     EngineJob<Object> getJob() {
@@ -541,7 +562,7 @@ public MultiCbHarness() {
           useUnlimitedSourceGeneratorPool,
           useAnimationPool,
           onlyRetrieveFromCache);
-      result.addCallback(cb);
+      result.addCallback(cb, Executors.directExecutor());
       return result;
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 4decb9a07..207d7abcc 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -32,8 +32,10 @@
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.util.Executors;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.Executor;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -64,7 +66,7 @@ public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
   public void testCallbackIsAddedToNewEngineJobWithNoExistingLoad() {
     harness.doLoad();
 
-    verify(harness.job).addCallback(eq(harness.cb));
+    verify(harness.job).addCallback(eq(harness.cb), any(Executor.class));
   }
 
   @Test
@@ -103,7 +105,7 @@ public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
     harness.cb = newCallback;
     harness.doLoad();
 
-    verify(harness.job).addCallback(eq(newCallback));
+    verify(harness.job).addCallback(eq(newCallback), any(Executor.class));
   }
 
   @Test
@@ -204,14 +206,17 @@ public void testHandlesNonEngineResourcesFromCacheIfPresent() {
     when(fromCache.get()).thenReturn(expected);
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[0];
-        assertEquals(expected, resource.get());
-        return null;
-      }
-    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[0];
+                assertEquals(expected, resource.get());
+                return null;
+              }
+            })
+        .when(harness.cb)
+        .onResourceReady(anyResource(), isADataSource());
 
     harness.doLoad();
 
@@ -323,14 +328,17 @@ public void testResourceIsAddedToCacheOnReleased() {
     final Object expected = new Object();
     when(harness.resource.isCacheable()).thenReturn(true);
     when(harness.resource.get()).thenReturn(expected);
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
-        assertEquals(expected, resource.get());
-        return null;
-      }
-    }).when(harness.cache).put(eq(harness.cacheKey), anyResource());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
+                assertEquals(expected, resource.get());
+                return null;
+              }
+            })
+        .when(harness.cache)
+        .put(eq(harness.cacheKey), anyResource());
 
     harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
@@ -426,8 +434,8 @@ public void testThrowsIfAskedToReleaseNonEngineResource() {
     harness.getEngine().release(mockResource());
   }
 
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
+  @Test
+  public void load_whenCalledOnBackgroundThread_doesNotThrow() throws InterruptedException {
     BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
       public void runTest() {
@@ -439,13 +447,16 @@ public void runTest() {
   @Test
   public void load_afterResourceIsLoadedInActiveResources_returnsFromMemoryCache() {
     when(harness.resource.isCacheable()).thenReturn(true);
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        harness.callOnEngineJobComplete();
-        return null;
-      }
-    }).when(harness.job).start(any(DecodeJob.class));
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocationOnMock) {
+                harness.callOnEngineJobComplete();
+                return null;
+              }
+            })
+        .when(harness.job)
+        .start(any(DecodeJob.class));
     harness.doLoad();
     harness.doLoad();
     verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
@@ -455,13 +466,16 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   public void load_afterResourceIsLoadedAndReleased_returnsFromMemoryCache() {
     harness.cache = new LruResourceCache(100);
     when(harness.resource.isCacheable()).thenReturn(true);
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        harness.callOnEngineJobComplete();
-        return null;
-      }
-    }).when(harness.job).start(any(DecodeJob.class));
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocationOnMock) {
+                harness.callOnEngineJobComplete();
+                return null;
+              }
+            })
+        .when(harness.job)
+        .start(any(DecodeJob.class));
     harness.doLoad();
     harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
     harness.doLoad();
@@ -670,24 +684,27 @@ void callOnEngineJobComplete() {
               eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean(), anyBoolean()))
           .thenReturn((EngineJob<Object>) job);
       when(job.onlyRetrieveFromCache()).thenReturn(onlyRetrieveFromCache);
-      return getEngine().load(glideContext,
-          model,
-          signature,
-          width,
-          height,
-          Object.class /*resourceClass*/,
-          Object.class /*transcodeClass*/,
-          Priority.HIGH,
-          DiskCacheStrategy.ALL,
-          transformations,
-          false /*isTransformationRequired*/,
-          isScaleOnlyOrNoTransform,
-          options,
-          isMemoryCacheable,
-          useUnlimitedSourceGeneratorPool,
-          /*useAnimationPool=*/ false,
-          onlyRetrieveFromCache,
-          cb);
+      return getEngine()
+          .load(
+              glideContext,
+              model,
+              signature,
+              width,
+              height,
+              Object.class /*resourceClass*/,
+              Object.class /*transcodeClass*/,
+              Priority.HIGH,
+              DiskCacheStrategy.ALL,
+              transformations,
+              false /*isTransformationRequired*/,
+              isScaleOnlyOrNoTransform,
+              options,
+              isMemoryCacheable,
+              useUnlimitedSourceGeneratorPool,
+              /*useAnimationPool=*/ false,
+              onlyRetrieveFromCache,
+              cb,
+              Executors.directExecutor());
     }
 
     Engine getEngine() {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index ab73d11e3..fda944cd7 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -27,7 +27,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 28)
 public class LruBitmapPoolTest {
   private static final int MAX_SIZE = 10;
   private static final Set<Bitmap.Config> ALLOWED_CONFIGS =
@@ -215,12 +215,12 @@ public void testBitmapsWithDisallowedConfigsAreIgnored() {
     assertEquals(0, strategy.numPuts);
   }
 
-  @Test
+  @Test @Config(sdk = 19)
   public void testBitmapsWithAllowedNullConfigsAreAllowed() {
     pool = new LruBitmapPool(100, strategy, Collections.<Bitmap.Config>singleton(null));
 
     Bitmap bitmap = createMutableBitmap();
-    Shadows.shadowOf(bitmap).setConfig(null);
+    bitmap.setConfig(null);
 
     pool.put(bitmap);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 68d4a56c3..ee204f478 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -7,12 +7,14 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import org.junit.After;
@@ -21,7 +23,6 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
@@ -41,9 +42,7 @@ public void tearDown() {
 
   @Test
   public void testBitmapIsEncoded() throws IOException {
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, Shadows.shadowOf(harness.bitmap).getDescription());
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.JPEG, 90));
   }
 
   @Test
@@ -51,9 +50,7 @@ public void testBitmapIsEncodedWithGivenQuality() throws IOException {
     int quality = 7;
     harness.setQuality(quality);
 
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, String.valueOf(quality));
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.JPEG, quality));
   }
 
   @Test
@@ -61,9 +58,7 @@ public void testEncoderObeysNonNullCompressFormat() throws IOException {
     Bitmap.CompressFormat format = Bitmap.CompressFormat.WEBP;
     harness.setFormat(format);
 
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, format.toString());
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.WEBP, 90));
   }
 
   @Test
@@ -71,9 +66,7 @@ public void testEncoderEncodesJpegWithNullFormatAndBitmapWithoutAlpha() throws I
     harness.setFormat(null);
     harness.bitmap.setHasAlpha(false);
 
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, Bitmap.CompressFormat.JPEG.toString());
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.JPEG, 90));
   }
 
   @Test
@@ -81,9 +74,7 @@ public void testEncoderEncodesPngWithNullFormatAndBitmapWithAlpha() throws IOExc
     harness.setFormat(null);
     harness.bitmap.setHasAlpha(true);
 
-    String fakeBytes = harness.encode();
-
-    assertContains(fakeBytes, Bitmap.CompressFormat.PNG.toString());
+    assertThat(harness.encode()).isEqualTo(harness.expectedData(CompressFormat.PNG, 90));
   }
 
   @Test
@@ -98,10 +89,6 @@ public void testEncodeStrategy_alwaysReturnsTransformed() {
     assertEquals(EncodeStrategy.TRANSFORMED, encoder.getEncodeStrategy(harness.options));
   }
 
-  private static void assertContains(String string, String expected) {
-    assertThat(string).contains(expected);
-  }
-
   private static class EncoderHarness {
     final Resource<Bitmap> resource = mockResource();
     final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
@@ -121,11 +108,16 @@ void setFormat(Bitmap.CompressFormat format) {
       options.set(BitmapEncoder.COMPRESSION_FORMAT, format);
     }
 
-    String encode() throws IOException {
+    byte[] encode() throws IOException {
       BitmapEncoder encoder = new BitmapEncoder(arrayPool);
       encoder.encode(resource, file, options);
-      byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
-      return new String(data, "UTF-8");
+      return ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
+    }
+
+    byte[] expectedData(CompressFormat expectedFormat, int expectedQuality) {
+      ByteArrayOutputStream os = new ByteArrayOutputStream();
+      bitmap.compress(expectedFormat, expectedQuality, os);
+      return os.toByteArray();
     }
 
     void tearDown() {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index d36b44ebd..93cd95ce6 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -31,11 +31,10 @@
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 28)
 public class CenterCropTest {
   @Rule public final KeyTester keyTester = new KeyTester();
   @Mock private Resource<Bitmap> resource;
@@ -101,9 +100,9 @@ public void testDoesNotRecycleGivenResource() {
     verify(resource, never()).recycle();
   }
 
-  @Test
+  @Test @Config(sdk = 19)
   public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
-    Shadows.shadowOf(bitmap).setConfig(null);
+    bitmap.setConfig(null);
 
     centerCrop.transform(context, resource, 10, 10);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index effaae7bf..dd1a06168 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -32,7 +32,7 @@
 import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
+@Config(manifest = Config.NONE, sdk = 28, shadows = {
     TransformationUtilsTest.AlphaShadowBitmap.class })
 public class TransformationUtilsTest {
 
@@ -162,10 +162,10 @@ public void testCenterCropReturnsGivenBitmapIfGivenBitmapExactlyMatchesGivenDime
     assertTrue(toCrop == transformed);
   }
 
-  @Test
+  @Test @Config(sdk = 19)
   public void testFitCenterHandlesBitmapsWithNullConfigs() {
     Bitmap toFit = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Shadows.shadowOf(toFit).setConfig(null);
+    toFit.setConfig(null);
     Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toFit, 50, 50);
     assertEquals(Bitmap.Config.ARGB_8888, transformed.getConfig());
   }
@@ -220,10 +220,10 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
     assertTrue(result.hasAlpha());
   }
 
-  @Test
+  @Test @Config(sdk = 19)
   public void testCenterCropHandlesBitmapsWithNullConfigs() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Shadows.shadowOf(toTransform).setConfig(null);
+    toTransform.setConfig(null);
 
     Bitmap transformed = TransformationUtils.centerCrop(bitmapPool, toTransform, 50, 50);
 
@@ -383,10 +383,10 @@ public void testRotateImageExifReturnsGivenBitmapIfOrientationIsInvalid() {
     assertTrue(toRotate == rotated);
   }
 
-  @Test
+  @Test @Config(sdk = 19)
   public void testRotateImageExifHandlesBitmapsWithNullConfigs() {
     Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Shadows.shadowOf(toRotate).setConfig(null);
+    toRotate.setConfig(null);
     Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
         ExifInterface.ORIENTATION_ROTATE_180);
     assertEquals(Bitmap.Config.ARGB_8888, rotated.getConfig());
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index 866b3ff70..d6760ec91 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -8,12 +8,12 @@
 import android.graphics.Bitmap;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-import java.nio.charset.Charset;
+import com.bumptech.glide.util.Preconditions;
+import java.io.ByteArrayOutputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
@@ -28,29 +28,26 @@ public void setUp() {
 
   @Test
   public void testReturnsBytesOfGivenBitmap() {
-    String transcodedDescription = harness.getTranscodedDescription();
-    assertThat(transcodedDescription).startsWith(harness.description);
+    assertThat(harness.getTranscodeResult()).isEqualTo(harness.getExpectedData());
   }
 
   @Test
   public void testUsesGivenQuality() {
     harness.quality = 66;
-    String transcodedDescription = harness.getTranscodedDescription();
-    assertThat(transcodedDescription).contains(String.valueOf(harness.quality));
+    assertThat(harness.getTranscodeResult()).isEqualTo(harness.getExpectedData());
   }
 
   @Test
   public void testUsesGivenFormat() {
     for (Bitmap.CompressFormat format : Bitmap.CompressFormat.values()) {
       harness.compressFormat = format;
-      String transcodedDescription = harness.getTranscodedDescription();
-      assertThat(transcodedDescription).contains(format.name());
+      assertThat(harness.getTranscodeResult()).isEqualTo(harness.getExpectedData());
     }
   }
 
   @Test
   public void testBitmapResourceIsRecycled() {
-    harness.getTranscodedDescription();
+    harness.getTranscodeResult();
 
     verify(harness.bitmapResource).recycle();
   }
@@ -58,21 +55,26 @@ public void testBitmapResourceIsRecycled() {
   private static class BitmapBytesTranscoderHarness {
     Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
     int quality = 100;
-    final String description = "TestDescription";
     final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
     final Resource<Bitmap> bitmapResource = mockResource();
     final Options options = new Options();
 
     BitmapBytesTranscoderHarness() {
       when(bitmapResource.get()).thenReturn(bitmap);
-      Shadows.shadowOf(bitmap).setDescription(description);
     }
 
-    String getTranscodedDescription() {
+    byte[] getTranscodeResult() {
       BitmapBytesTranscoder transcoder = new BitmapBytesTranscoder(compressFormat, quality);
-      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource, options);
+      Resource<byte[]> bytesResource =
+          Preconditions.checkNotNull(transcoder.transcode(bitmapResource, options));
 
-      return new String(bytesResource.get(), Charset.defaultCharset());
+      return bytesResource.get();
+    }
+
+    byte[] getExpectedData() {
+      ByteArrayOutputStream os = new ByteArrayOutputStream();
+      bitmap.compress(compressFormat, quality, os);
+      return os.toByteArray();
     }
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index 930a9f34e..386c842de 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -178,7 +178,7 @@ void connect() {
 
     void broadcast() {
       Intent connected = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
-      ShadowApplication.getInstance().sendBroadcast(connected);
+      RuntimeEnvironment.application.sendBroadcast(connected);
     }
   }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index c7b48a83d..e45aace85 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -3,7 +3,6 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.atLeastOnce;
@@ -13,7 +12,6 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.os.Handler;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import java.util.concurrent.CancellationException;
@@ -35,16 +33,14 @@
   private int height;
   private RequestFutureTarget<Object> future;
   private Request request;
-  private Handler handler;
   private RequestFutureTarget.Waiter waiter;
 
   @Before
   public void setUp() {
     width = 100;
     height = 100;
-    handler = mock(Handler.class);
     waiter = mock(RequestFutureTarget.Waiter.class);
-    future = new RequestFutureTarget<>(handler, width, height, false, waiter);
+    future = new RequestFutureTarget<>(width, height, false, waiter);
     request = mock(Request.class);
     future.setRequest(request);
   }
@@ -83,32 +79,25 @@ public void testReturnsTrueFromCancelIfNotYetDone() {
   }
 
   @Test
-  public void cancel_withMayInterruptIfRunningTrueAndNotFinishedRequest_clearsFutureOnMainThread() {
+  public void cancel_withMayInterruptIfRunningTrueAndNotFinishedRequest_clearsFuture() {
     future.cancel(true);
 
-    verify(handler).post(eq(future));
+    verify(request).clear();
   }
 
   @Test
-  public void cancel_withInterruptFalseAndNotFinishedRequest_doesNotclearFutureOnMainThread() {
+  public void cancel_withInterruptFalseAndNotFinishedRequest_doesNotClearFuture() {
     future.cancel(false);
 
-    verify(handler, never()).post(eq(future));
+    verify(request, never()).clear();
   }
 
   @Test
-  public void testDoesNotRepeatedlyClearRequestOnMainThreadIfCancelledRepeatedly() {
+  public void testDoesNotRepeatedlyClearRequestIfCancelledRepeatedly() {
     future.cancel(true);
     future.cancel(true);
 
-    verify(handler, times(1)).post(any(Runnable.class));
-  }
-
-  @Test
-  public void testClearsRequestOnRun() {
-    future.run();
-
-    verify(request).clear();
+    verify(request, times(1)).clear();
   }
 
   @Test
@@ -232,14 +221,14 @@ public void testThrowsTimeoutExceptionOnGetIfFailedToReceiveResourceInTime()
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsExceptionIfGetCalledOnMainThread()
       throws ExecutionException, InterruptedException {
-    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future = new RequestFutureTarget<>(width, height, true, waiter);
     future.get();
   }
 
   @Test
   public void testGetSucceedsOnMainThreadIfDone()
       throws ExecutionException, InterruptedException {
-    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future = new RequestFutureTarget<>(width, height, true, waiter);
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
@@ -252,13 +241,16 @@ public void testGetSucceedsOnMainThreadIfDone()
   @Test(expected = InterruptedException.class)
   public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting()
       throws InterruptedException, ExecutionException {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Thread.currentThread().interrupt();
-        return null;
-      }
-    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                Thread.currentThread().interrupt();
+                return null;
+              }
+            })
+        .when(waiter)
+        .waitForTimeout(eq(future), anyLong());
 
     future.get();
   }
@@ -266,26 +258,33 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
-        return null;
-      }
-    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                future.onLoadFailed(
+                    /*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
+                return null;
+              }
+            })
+        .when(waiter)
+        .waitForTimeout(eq(future), anyLong());
     future.get();
   }
 
   @Test(expected = CancellationException.class)
   public void testThrowsCancellationExceptionIfCancelledWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.cancel(false);
-        return null;
-      }
-    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                future.cancel(false);
+                return null;
+              }
+            })
+        .when(waiter)
+        .waitForTimeout(eq(future), anyLong());
     future.get();
   }
 
@@ -336,18 +335,21 @@ public void testDoesNotNotifyAllOnSecondCancel() {
   public void testReturnsResourceIfReceivedWhileWaiting()
       throws ExecutionException, InterruptedException {
     final Object expected = new Object();
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onResourceReady(
-            /*resource=*/ expected,
-            /*model=*/ null,
-            /*target=*/future,
-            DataSource.DATA_DISK_CACHE,
-            true /*isFirstResource*/);
-        return null;
-      }
-    }).when(waiter).waitForTimeout(eq(future), anyLong());
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                future.onResourceReady(
+                    /*resource=*/ expected,
+                    /*model=*/ null,
+                    /*target=*/ future,
+                    DataSource.DATA_DISK_CACHE,
+                    true /*isFirstResource*/);
+                return null;
+              }
+            })
+        .when(waiter)
+        .waitForTimeout(eq(future), anyLong());
     assertEquals(expected, future.get());
   }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
index 1f5536b3a..48123faeb 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -255,7 +255,7 @@ public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
   @Test
   @SuppressWarnings({"unchecked", "varargs"})
   public void testApplyMultiTransform() {
-    options.transforms(new CircleCrop(), new CenterCrop());
+    options.transform(new CircleCrop(), new CenterCrop());
     assertThat(options.isTransformationRequired()).isTrue();
     assertThat(options.getTransformations()).containsKey(Bitmap.class);
     assertThat(options.getTransformations().get(Bitmap.class))
diff --git a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 8341cd3c7..e6f56512d 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -37,12 +37,14 @@
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.util.Executors;
 import com.google.common.base.Equivalence;
 import com.google.common.testing.EquivalenceTester;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Executor;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -247,7 +249,8 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
   @Test
@@ -262,8 +265,7 @@ public void testIsFailedAfterNoResultAndNullException() {
   public void testEngineLoadCancelledOnCancel() {
     Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
 
-    when(builder.engine
-        .load(
+    when(builder.engine.load(
             eq(builder.glideContext),
             eq(builder.model),
             eq(builder.signature),
@@ -281,7 +283,8 @@ public void testEngineLoadCancelledOnCancel() {
             anyBoolean(),
             anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class)))
+            any(ResourceCallback.class),
+            anyExecutor()))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = builder.build();
@@ -545,8 +548,7 @@ public void testRequestListenerIsCalledWithTarget() {
   public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
     final SingleRequest<List> request = builder.addRequestListener(listener1).build();
 
-    when(builder.engine
-        .load(
+    when(builder.engine.load(
             eq(builder.glideContext),
             eq(builder.model),
             eq(builder.signature),
@@ -564,14 +566,16 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class)))
-        .thenAnswer(new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) {
-            request.onResourceReady(builder.resource, DataSource.MEMORY_CACHE);
-            return null;
-          }
-        });
+            any(ResourceCallback.class),
+            anyExecutor()))
+        .thenAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) {
+                request.onResourceReady(builder.resource, DataSource.MEMORY_CACHE);
+                return null;
+              }
+            });
 
     request.begin();
     request.onSizeReady(100, 100);
@@ -699,7 +703,8 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
   @Test
@@ -718,8 +723,7 @@ public void testCanReRunClearedRequests() {
     doAnswer(new CallSizeReady(100, 100)).when(builder.target)
         .getSize(any(SizeReadyCallback.class));
 
-    when(builder.engine
-        .load(
+    when(builder.engine.load(
             eq(builder.glideContext),
             eq(builder.model),
             eq(builder.signature),
@@ -737,7 +741,8 @@ public void testCanReRunClearedRequests() {
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class)))
+            any(ResourceCallback.class),
+            anyExecutor()))
         .thenAnswer(new CallResourceCallback(builder.resource));
     SingleRequest<List> request = builder.build();
 
@@ -781,7 +786,8 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterClear() {
             anyBoolean(),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
 
@@ -814,7 +820,8 @@ public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
             eq(true),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
   @Test
@@ -846,7 +853,8 @@ public void testCallsSourceExecutorEngineIfOptionsIsSet() {
             eq(false),
             /*useAnimationPool=*/ anyBoolean(),
             anyBoolean(),
-            any(ResourceCallback.class));
+            any(ResourceCallback.class),
+            anyExecutor());
   }
 
   @Test
@@ -1001,8 +1009,8 @@ SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
           .signature(signature)
           .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
       return SingleRequest.obtain(
-          /*context=*/glideContext,
-          /*glideContext=*/glideContext,
+          /*context=*/ glideContext,
+          /*glideContext=*/ glideContext,
           model,
           transcodeClass,
           requestOptions,
@@ -1014,7 +1022,8 @@ SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
           requestListeners,
           requestCoordinator,
           engine,
-          transitionFactory);
+          transitionFactory,
+          Executors.directExecutor());
     }
   }
 
@@ -1038,6 +1047,10 @@ private static GlideException isAGlideException() {
     return any(Transition.class);
   }
 
+  private static Executor anyExecutor() {
+    return any(Executor.class);
+  }
+
   private static class CallResourceCallback implements Answer {
 
     private final Resource resource;
@@ -1049,9 +1062,8 @@ private static GlideException isAGlideException() {
     @Override
     public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
       ResourceCallback cb =
-          (ResourceCallback) invocationOnMock.getArguments()[
-              invocationOnMock.getArguments().length
-                  - 1];
+          (ResourceCallback)
+              invocationOnMock.getArguments()[invocationOnMock.getArguments().length - 2];
       cb.onResourceReady(resource, DataSource.REMOTE);
       return null;
     }
diff --git a/samples/contacturi/lint.xml b/samples/contacturi/lint.xml
index bd2bae772..a78a6dd3b 100644
--- a/samples/contacturi/lint.xml
+++ b/samples/contacturi/lint.xml
@@ -2,4 +2,5 @@
 <lint>
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
     <issue id="GradleDependency" severity="ignore"/>
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/flickr/lint.xml b/samples/flickr/lint.xml
index 0808ec2c6..948353b6b 100644
--- a/samples/flickr/lint.xml
+++ b/samples/flickr/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore"/>
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
     <issue id="GradleDependency" severity="ignore" />
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/gallery/lint.xml b/samples/gallery/lint.xml
index 0808ec2c6..948353b6b 100644
--- a/samples/gallery/lint.xml
+++ b/samples/gallery/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore"/>
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
     <issue id="GradleDependency" severity="ignore" />
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 665cccffe..53698d6dd 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -43,8 +43,9 @@
     screenWidth = getScreenWidth(context);
   }
 
+  @NonNull
   @Override
-  public ListViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
+  public ListViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) {
     LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext());
     final View view = inflater.inflate(R.layout.recycler_item, viewGroup, false);
     view.getLayoutParams().width = screenWidth;
@@ -66,7 +67,7 @@ public boolean onPreDraw() {
   }
 
   @Override
-  public void onBindViewHolder(ListViewHolder viewHolder, int position) {
+  public void onBindViewHolder(@NonNull ListViewHolder viewHolder, int position) {
     MediaStoreData current = data.get(position);
 
     Key signature =
@@ -97,7 +98,9 @@ public int getItemViewType(int position) {
   @NonNull
   @Override
   public List<MediaStoreData> getPreloadItems(int position) {
-    return Collections.singletonList(data.get(position));
+    return data.isEmpty()
+            ? Collections.<MediaStoreData>emptyList()
+            : Collections.singletonList(data.get(position));
   }
 
   @Nullable
diff --git a/samples/giphy/lint.xml b/samples/giphy/lint.xml
index c02d95c38..1b9db4caa 100644
--- a/samples/giphy/lint.xml
+++ b/samples/giphy/lint.xml
@@ -4,4 +4,5 @@
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
     <issue id="GradleDependency" severity="ignore" />
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
index 825ea2f16..c65feab73 100644
--- a/samples/imgur/build.gradle
+++ b/samples/imgur/build.gradle
@@ -45,7 +45,7 @@ dependencies {
     implementation 'io.reactivex:rxjava:1.3.4'
 
     implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
-    implementation "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "androidx.cardview:cardview:${ANDROID_X_VERSION}"
     implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
 
     // Fixes a compilation warning related to dagger, see
diff --git a/samples/imgur/lint.xml b/samples/imgur/lint.xml
index 0808ec2c6..948353b6b 100644
--- a/samples/imgur/lint.xml
+++ b/samples/imgur/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore"/>
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
     <issue id="GradleDependency" severity="ignore" />
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
index 7b9d639aa..f621aa47f 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
@@ -6,15 +6,15 @@
 import dagger.android.support.AndroidSupportInjectionModule;
 import javax.inject.Singleton;
 
-/**
- * Specifies Dagger modules for {@link ImgurApplication}.
- */
+/** Specifies Dagger modules for {@link ImgurApplication}. */
 @Singleton
-@Component(modules = {
-    AndroidSupportInjectionModule.class,
-    MainActivityModule.class,
-    ApplicationModule.class,
-    ApiModule.class
-})
+@Component(
+    modules = {
+      AndroidSupportInjectionModule.class,
+      MainActivityModule.class,
+      ApplicationModule.class,
+      ApiModule.class
+    })
 public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {
+    // Empty.
 }
diff --git a/samples/imgur/src/main/res/layout/image_card.xml b/samples/imgur/src/main/res/layout/image_card.xml
index 92f2cbb76..68af24c67 100644
--- a/samples/imgur/src/main/res/layout/image_card.xml
+++ b/samples/imgur/src/main/res/layout/image_card.xml
@@ -6,7 +6,7 @@
   android:layout_height="wrap_content"
   android:padding="16dp">
 
-  <android.support.v7.widget.CardView
+  <androidx.cardview.widget.CardView
     android:id="@+id/card_view"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
@@ -31,5 +31,5 @@
         android:paddingTop="16dp"
         />
     </LinearLayout>
-  </android.support.v7.widget.CardView>
+  </androidx.cardview.widget.CardView>
 </FrameLayout>
diff --git a/samples/svg/lint.xml b/samples/svg/lint.xml
index 11fca2666..bc99b5604 100644
--- a/samples/svg/lint.xml
+++ b/samples/svg/lint.xml
@@ -4,4 +4,5 @@
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore"/>
     <issue id="GradleDependency" severity="ignore"/>
+    <issue id="Autofill" severity="ignore" />
 </lint>
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index 8f8d18b7b..f6425ca63 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -218,7 +218,7 @@ afterEvaluate { project ->
             // includes the release aar in archives. Since we've disabled our release variants and
             // want to include an aar, we need to manually specify the task that produces the aar
             // here.
-            archives project.tasks.bundleDebug
+            archives project.tasks.bundleDebugAar
         }
     } else if (project.plugins.hasPlugin('java')) {
         task sourcesJar(type: Jar, dependsOn: classes) {
