diff --git a/README.md b/README.md
index e4a4e3a4c..275469edc 100644
--- a/README.md
+++ b/README.md
@@ -873,7 +873,19 @@ RuntimeCompat：可用进程数
     }
   }
 ```
-SizeConfigStrategy
+SizeConfigStrategy:  
+* RGBA_F16_IN_CONFIGS数组:{Bitmap.Config.ARGB_8888,null,Bitmap.Config.RGBA_F16}
+* ARGB_8888_IN_CONFIGS数组:{Bitmap.Config.ARGB_8888,null}
+* RGB_565_IN_CONFIGS数组:{Bitmap.Config.RGB_565}
+* ARGB_4444_IN_CONFIG数组:{Bitmap.Config.ARGB_4444}
+* ALPHA_8_IN_CONFIG数组:{Bitmap.Config.ALPHA_8}  
+> Bitmap.Config:描述像素如何存储，将影响质量(颜色深度)和透明/半透明颜色。
+> ALPHA_8:每个像素都存储为一个半透明通道，不存储颜色信息。在这种配置下，每个像素需要一个字节的内存
+> RGB_565:每个像素存储为2字节，只有rgb通道被编码：红色存储为5位精度(32个可能值)，绿色存储为6位精度(64个可能值)，蓝色存储为5位精度。当使用不需要高颜色保真度的不透明位图时，这种配置可能很有用
+> ARGB_4444:因为此配置质量较差，推荐使用ARGB_8888
+> ARGB_8888:每个像素被存储为4个字节。每个通道存储为8位(256个可能值)
+> RGBA_F16:每个像素被存储为8个字节。每个通道存储为高精度的浮点值。这个配置适合宽色域和HDR内容
+> HEADWARE:位图仅存储在图形内存中的特殊配置。这个配置的位图不可变，在屏幕上绘制是最优的
 ```java
   @RequiresApi(Build.VERSION_CODES.KITKAT)
   public class SizeConfigStrategy implements LruPoolStrategy{
@@ -991,7 +1003,7 @@ SizeConfigStrategy
       }
       return sb.append(")}").toString();
     }
-    
+    //**Key池**
     static class KeyPool extends BaseKeyPool<Key>{
       public Key get(int size,Bitmap.Config config){
         Key result=get();
@@ -1003,6 +1015,7 @@ SizeConfigStrategy
         return new Key(this);
       }
     }
+    //**Key**:保存Bimap.Config及对应的大小
     static final class Key implements Poolable{
       private final KeyPool pool;
       private Bitmap.Config config;
@@ -1154,7 +1167,7 @@ AttributeStrategy
     }
   }
 ```
-BaseKeyPool
+BaseKeyPool：创建长度为20的队列
 ```java
   abstract class BaseKeyPool<T extends Poolable>{
     private static final int MAX_SIZE=20;
@@ -1311,7 +1324,8 @@ Util
     }
   }
 ```
-GroupedLinkedMap:类似LinkedHashMap
+GroupedLinkedMap:类似LinkedHashMap，思想：找到LRU位图大小，而不是LRU位图对象。当需要减少缓存大小时，我们可以从最近最少使用的位图大小中国删除位图。
+
 ```java
   class GroupedLinkedMap<K extends Poolable,V>{
     private final LinkedEntry<K,V> head=new LinkedEntry<>();
@@ -1391,7 +1405,7 @@ GroupedLinkedMap:类似LinkedHashMap
       entry.prev.next=entry.next;
       entry.next.prev=entry.prev;
     }
-    
+    //**链表条目**：创建一个key为null的链表头
     private static class LinkedEntry<K,V>{
       @Synthetic final K key;
       private List<V> values;
