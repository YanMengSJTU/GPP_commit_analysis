diff --git a/.gitignore b/.gitignore
index 922179395..d8563abe9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,13 +9,19 @@ library/.gradle
 library/.settings
 library/target
 library/install_dependencies/maven-android-sdk-deployer
-*.iml
-.idea/*
+.idea/libraries
+.idea/workspace.xml
+.idea/tasks.xml
+.idea/gradle.xml
+.idea/dictionaries
+.idea/dataSources.ids
+.idea/datasources.xml
+library/.idea
+samples/**/.idea
 *.DS_Store
 *.swp
 *.swo
 proguard-project.txt
-samples/flickr/.idea/*
 samples/flickr/gen
 samples/flickr/out
 samples/flickr/bin
@@ -23,7 +29,6 @@ samples/flickr/target
 integration/volley/target/**
 **local.properties
 *.keystore
-**/.idea/*
 .settings
 /library/.classpath
 /library/.project
diff --git a/.idea/.name b/.idea/.name
new file mode 100644
index 000000000..325497f4e
--- /dev/null
+++ b/.idea/.name
@@ -0,0 +1 @@
+glide-parent
\ No newline at end of file
diff --git a/.idea/androidDexCompiler.xml b/.idea/androidDexCompiler.xml
new file mode 100644
index 000000000..d87fc2258
--- /dev/null
+++ b/.idea/androidDexCompiler.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AndroidDexCompilerConfiguration">
+    <option name="MAX_HEAP_SIZE" value="1024" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/checkstyle-idea.xml b/.idea/checkstyle-idea.xml
new file mode 100644
index 000000000..f103cb3c7
--- /dev/null
+++ b/.idea/checkstyle-idea.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CheckStyle-IDEA">
+    <option name="configuration">
+      <map>
+        <entry key="active-configuration" value="LOCAL_FILE:$PRJ_DIR$/checkstyle.xml:Glide checkstyle" />
+        <entry key="check-nonjava-files" value="false" />
+        <entry key="check-test-classes" value="false" />
+        <entry key="location-0" value="CLASSPATH:/sun_checks.xml:The default CheckStyle rules" />
+        <entry key="location-1" value="LOCAL_FILE:$PRJ_DIR$/checkstyle.xml:Glide checkstyle" />
+        <entry key="property-1.checkStyleConfigDir" value="$PROJECT_DIR$" />
+        <entry key="suppress-errors" value="false" />
+        <entry key="thirdparty-classpath" value="" />
+      </map>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
new file mode 100644
index 000000000..39889475f
--- /dev/null
+++ b/.idea/codeStyleSettings.xml
@@ -0,0 +1,277 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectCodeStyleSettingsManager">
+    <option name="PER_PROJECT_SETTINGS">
+      <value>
+        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
+          <value />
+        </option>
+        <option name="IMPORT_LAYOUT_TABLE">
+          <value>
+            <package name="com.google" withSubpackages="true" static="true" />
+            <package name="" withSubpackages="true" static="true" />
+            <emptyLine />
+            <package name="com.google" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="android" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="antenna" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="antlr" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="ar" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="asposewobfuscated" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="asquare" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="atg" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="au" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="beaver" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="bibtex" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="bmsi" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="bsh" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="ccl" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="cern" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="ChartDirector" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="checkers" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="com" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="COM" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="common" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="contribs" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="corejava" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="cryptix" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="cybervillains" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="dalvik" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="danbikel" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="de" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="EDU" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="eg" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="eu" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="examples" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="fat" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="fit" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="fitlibrary" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="fmpp" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="freemarker" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="gnu" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="groovy" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="groovyjarjarantlr" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="groovyjarjarasm" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="hak" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="hep" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="ie" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="imageinfo" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="info" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="it" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jal" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="Jama" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="japa" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="japacheckers" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jas" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jasmin" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="javancss" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="javanet" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="javassist" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="javazoom" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="java_cup" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jcifs" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jetty" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="JFlex" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jj2000" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jline" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jp" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="JSci" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jsr166y" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="junit" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jxl" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="jxxload_help" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="kawa" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="kea" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="libcore" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="libsvm" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="lti" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="memetic" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="mt" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="mx4j" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="net" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="netscape" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="nl" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="nu" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="oauth" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="ognl" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="opennlp" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="oracle" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="org" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="oz" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="penn2dg" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="pennconverter" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="pl" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="prefuse" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="proguard" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="repackage" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="scm" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="se" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="serp" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="simple" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="social" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="soot" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="sqlj" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="src" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="ssa" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="sun" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="sunlabs" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="tcl" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="testdata" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="testshell" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="testsuite" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="twitter4j" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="uk" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="ViolinStrings" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="weka" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="wet" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="winstone" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="woolfel" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="wowza" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="java" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="javax" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="" withSubpackages="true" static="false" />
+          </value>
+        </option>
+        <option name="WRAP_WHEN_TYPING_REACHES_RIGHT_MARGIN" value="true" />
+        <AndroidXmlCodeStyleSettings>
+          <option name="USE_CUSTOM_SETTINGS" value="true" />
+        </AndroidXmlCodeStyleSettings>
+        <XML>
+          <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
+        </XML>
+        <codeStyleSettings language="JAVA">
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+        </codeStyleSettings>
+        <codeStyleSettings language="XML">
+          <option name="FORCE_REARRANGE_MODE" value="1" />
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+          </indentOptions>
+          <arrangement>
+            <rules />
+          </arrangement>
+        </codeStyleSettings>
+      </value>
+    </option>
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
new file mode 100644
index 000000000..9a8b7e5c4
--- /dev/null
+++ b/.idea/compiler.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <option name="DEFAULT_COMPILER" value="Javac" />
+    <resourceExtensions />
+    <wildcardResourcePatterns>
+      <entry name="!?*.java" />
+      <entry name="!?*.form" />
+      <entry name="!?*.class" />
+      <entry name="!?*.groovy" />
+      <entry name="!?*.scala" />
+      <entry name="!?*.flex" />
+      <entry name="!?*.kt" />
+      <entry name="!?*.clj" />
+    </wildcardResourcePatterns>
+    <annotationProcessing>
+      <profile default="true" name="Default" enabled="false">
+        <processorPath useClasspath="true" />
+      </profile>
+    </annotationProcessing>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/copyright/profiles_settings.xml b/.idea/copyright/profiles_settings.xml
new file mode 100644
index 000000000..e7bedf337
--- /dev/null
+++ b/.idea/copyright/profiles_settings.xml
@@ -0,0 +1,3 @@
+<component name="CopyrightManager">
+  <settings default="" />
+</component>
\ No newline at end of file
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
new file mode 100644
index 000000000..e206d70d8
--- /dev/null
+++ b/.idea/encodings.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding" useUTFGuessing="true" native2AsciiForPropertiesFiles="false" />
+</project>
+
diff --git a/.idea/groovyc.xml b/.idea/groovyc.xml
new file mode 100644
index 000000000..7d42f3ab1
--- /dev/null
+++ b/.idea/groovyc.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="GroovyCompilerProjectConfiguration">
+    <option name="heapSize" value="2048" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
index 000000000..79365f371
--- /dev/null
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -0,0 +1,14 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0" is_locked="false">
+    <option name="myName" value="Project Default" />
+    <option name="myLocal" value="false" />
+    <inspection_tool class="AndroidLintGradleDependency" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="CheckStyle-IDEA" enabled="true" level="ERROR" enabled_by_default="true" />
+    <inspection_tool class="LoggerInitializedWithForeignClass" enabled="false" level="WARNING" enabled_by_default="false">
+      <option name="loggerClassName" value="org.apache.log4j.Logger,org.slf4j.LoggerFactory,org.apache.commons.logging.LogFactory,java.util.logging.Logger" />
+      <option name="loggerFactoryMethodName" value="getLogger,getLogger,getLog,getLogger" />
+    </inspection_tool>
+    <inspection_tool class="OnDemandImport" enabled="true" level="WARNING" enabled_by_default="true" />
+    <inspection_tool class="SamePackageImport" enabled="true" level="WARNING" enabled_by_default="true" />
+  </profile>
+</component>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
new file mode 100644
index 000000000..3b312839b
--- /dev/null
+++ b/.idea/inspectionProfiles/profiles_settings.xml
@@ -0,0 +1,7 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="PROJECT_PROFILE" value="Project Default" />
+    <option name="USE_PROJECT_PROFILE" value="true" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 000000000..19736e2de
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,162 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <option name="DEFAULT_COMPILER" />
+    <resourceExtensions />
+    <wildcardResourcePatterns>
+      <entry name="!?*.java" />
+      <entry name="!?*.form" />
+      <entry name="!?*.class" />
+      <entry name="!?*.groovy" />
+      <entry name="!?*.scala" />
+      <entry name="!?*.flex" />
+      <entry name="!?*.kt" />
+      <entry name="!?*.clj" />
+    </wildcardResourcePatterns>
+    <annotationProcessing>
+      <profile default="true" name="Default" enabled="false">
+        <processorPath useClasspath="true" />
+      </profile>
+    </annotationProcessing>
+  </component>
+  <component name="CopyrightManager" default="" />
+  <component name="DaemonCodeAnalyzer">
+    <disable_hints />
+  </component>
+  <component name="DependencyValidationManager">
+    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
+  </component>
+  <component name="Encoding" useUTFGuessing="true" native2AsciiForPropertiesFiles="false" />
+  <component name="EntryPointsManager">
+    <entry_points version="2.0" />
+  </component>
+  <component name="FrameworkDetectionExcludesConfiguration">
+    <file type="web" url="file://$PROJECT_DIR$" />
+  </component>
+  <component name="GradleLocalSettings">
+    <option name="modificationStamps">
+      <map>
+        <entry key="$PROJECT_DIR$" value="19825412166063" />
+      </map>
+    </option>
+  </component>
+  <component name="IdProvider" IDEtalkID="E5D7B560A0002A20C790AA32CD25F711" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="false">
+    <OptionsSetting value="true" id="Add" />
+    <OptionsSetting value="true" id="Remove" />
+    <OptionsSetting value="true" id="Checkout" />
+    <OptionsSetting value="true" id="Update" />
+    <OptionsSetting value="true" id="Status" />
+    <OptionsSetting value="true" id="Edit" />
+    <ConfirmationsSetting value="0" id="Add" />
+    <ConfirmationsSetting value="0" id="Remove" />
+  </component>
+  <component name="ProjectModuleManager">
+    <modules />
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_6" assert-keyword="true" jdk-15="true" project-jdk-name="1.6" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/build/classes" />
+  </component>
+  <component name="PropertiesComponent">
+    <property name="GoToClass.includeLibraries" value="false" />
+    <property name="GoToClass.toSaveIncludeLibraries" value="false" />
+    <property name="GoToFile.includeJavaFiles" value="false" />
+    <property name="MemberChooser.sorted" value="false" />
+    <property name="MemberChooser.showClasses" value="true" />
+    <property name="MemberChooser.copyJavadoc" value="false" />
+  </component>
+  <component name="RunManager">
+    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
+      <module name="" />
+      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
+      <option name="PROGRAM_PARAMETERS" />
+      <method />
+    </configuration>
+    <configuration default="true" type="Remote" factoryName="Remote">
+      <option name="USE_SOCKET_TRANSPORT" value="true" />
+      <option name="SERVER_MODE" value="false" />
+      <option name="SHMEM_ADDRESS" value="javadebug" />
+      <option name="HOST" value="localhost" />
+      <option name="PORT" value="5005" />
+      <method />
+    </configuration>
+    <configuration default="true" type="Applet" factoryName="Applet">
+      <module name="" />
+      <option name="MAIN_CLASS_NAME" />
+      <option name="HTML_FILE_NAME" />
+      <option name="HTML_USED" value="false" />
+      <option name="WIDTH" value="400" />
+      <option name="HEIGHT" value="300" />
+      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
+      <option name="VM_PARAMETERS" />
+      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
+      <option name="ALTERNATIVE_JRE_PATH" />
+      <method />
+    </configuration>
+    <configuration default="true" type="TestNG" factoryName="TestNG">
+      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
+      <module name="" />
+      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
+      <option name="ALTERNATIVE_JRE_PATH" />
+      <option name="SUITE_NAME" />
+      <option name="PACKAGE_NAME" />
+      <option name="MAIN_CLASS_NAME" />
+      <option name="METHOD_NAME" />
+      <option name="GROUP_NAME" />
+      <option name="TEST_OBJECT" value="CLASS" />
+      <option name="VM_PARAMETERS" value="-ea" />
+      <option name="PARAMETERS" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="OUTPUT_DIRECTORY" />
+      <option name="ANNOTATION_TYPE" />
+      <option name="ENV_VARIABLES" />
+      <option name="PASS_PARENT_ENVS" value="true" />
+      <option name="TEST_SEARCH_SCOPE">
+        <value defaultName="singleModule" />
+      </option>
+      <option name="USE_DEFAULT_REPORTERS" value="false" />
+      <option name="PROPERTIES_FILE" />
+      <envs />
+      <properties />
+      <listeners />
+      <method />
+    </configuration>
+    <configuration default="true" type="Application" factoryName="Application">
+      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
+      <option name="MAIN_CLASS_NAME" />
+      <option name="VM_PARAMETERS" />
+      <option name="PROGRAM_PARAMETERS" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
+      <option name="ALTERNATIVE_JRE_PATH" />
+      <option name="ENABLE_SWING_INSPECTOR" value="false" />
+      <option name="ENV_VARIABLES" />
+      <option name="PASS_PARENT_ENVS" value="true" />
+      <module name="" />
+      <envs />
+      <method />
+    </configuration>
+    <configuration default="true" type="JUnit" factoryName="JUnit">
+      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
+      <module name="" />
+      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
+      <option name="ALTERNATIVE_JRE_PATH" />
+      <option name="PACKAGE_NAME" />
+      <option name="MAIN_CLASS_NAME" />
+      <option name="METHOD_NAME" />
+      <option name="TEST_OBJECT" value="class" />
+      <option name="VM_PARAMETERS" value="-ea" />
+      <option name="PARAMETERS" />
+      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
+      <option name="ENV_VARIABLES" />
+      <option name="PASS_PARENT_ENVS" value="true" />
+      <option name="TEST_SEARCH_SCOPE">
+        <value defaultName="singleModule" />
+      </option>
+      <envs />
+      <patterns />
+      <method />
+    </configuration>
+    <list size="0" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 000000000..adda73dd2
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/third_party/disklrucache/disklrucache.iml" filepath="$PROJECT_DIR$/third_party/disklrucache/disklrucache.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/flickr/flickr.iml" filepath="$PROJECT_DIR$/samples/flickr/flickr.iml" />
+      <module fileurl="file://$PROJECT_DIR$/third_party/gif_decoder/gif_decoder.iml" filepath="$PROJECT_DIR$/third_party/gif_decoder/gif_decoder.iml" />
+      <module fileurl="file://$PROJECT_DIR$/third_party/gif_encoder/gif_encoder.iml" filepath="$PROJECT_DIR$/third_party/gif_encoder/gif_encoder.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/giphy/giphy.iml" filepath="$PROJECT_DIR$/samples/giphy/giphy.iml" />
+      <module fileurl="file://$PROJECT_DIR$/glide/glide.iml" filepath="$PROJECT_DIR$/glide/glide.iml" />
+      <module fileurl="file://$PROJECT_DIR$/glide-parent.iml" filepath="$PROJECT_DIR$/glide-parent.iml" />
+      <module fileurl="file://$PROJECT_DIR$/integration/integration.iml" filepath="$PROJECT_DIR$/integration/integration.iml" />
+      <module fileurl="file://$PROJECT_DIR$/library/library.iml" filepath="$PROJECT_DIR$/library/library.iml" />
+      <module fileurl="file://$PROJECT_DIR$/integration/okhttp/okhttp.iml" filepath="$PROJECT_DIR$/integration/okhttp/okhttp.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/samples.iml" filepath="$PROJECT_DIR$/samples/samples.iml" />
+      <module fileurl="file://$PROJECT_DIR$/samples/svg/svg.iml" filepath="$PROJECT_DIR$/samples/svg/svg.iml" />
+      <module fileurl="file://$PROJECT_DIR$/testutil/testutil.iml" filepath="$PROJECT_DIR$/testutil/testutil.iml" />
+      <module fileurl="file://$PROJECT_DIR$/third_party/third_party.iml" filepath="$PROJECT_DIR$/third_party/third_party.iml" />
+      <module fileurl="file://$PROJECT_DIR$/integration/volley/volley.iml" filepath="$PROJECT_DIR$/integration/volley/volley.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/scopes/scope_settings.xml b/.idea/scopes/scope_settings.xml
new file mode 100644
index 000000000..922003b84
--- /dev/null
+++ b/.idea/scopes/scope_settings.xml
@@ -0,0 +1,5 @@
+<component name="DependencyValidationManager">
+  <state>
+    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
+  </state>
+</component>
\ No newline at end of file
diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
new file mode 100644
index 000000000..3b0002030
--- /dev/null
+++ b/.idea/uiDesigner.xml
@@ -0,0 +1,125 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+</project>
+
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 000000000..8bb10b539
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/third_party/disklrucache" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index 14fe933d2..8640489be 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -5,7 +5,10 @@ android:
   licenses: 
   - 'android-sdk-license.*'
 
+sudo: false
+
 script: 'travis_retry ./gradlew build --parallel'
 
 after_success:
 - scripts/travis-sonatype-publish.sh
+- ./gradlew jacocoTestReport coveralls
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 000000000..5fc10cb16
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,26 @@
+# Contributing
+Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other
+aspects of the library (documentation, the wiki etc.)
+
+## Asking Questions
+The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on
+freenode.org.][3]
+
+## Filing issues
+To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more
+information you can provide, the more likely we are to be able help.
+
+When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if
+you support a particular feature request, feel free to let us know by commenting on the issue.
+
+## Contributing code
+Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find
+instructions on building the project in our README. Our code style is defined in Intellij project files in the repo
+and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel
+free to put up your pull request anyway and we can help you fix the style issues. If you'd like to
+contribute code, you will need to sign [Google's individual contributor license agreement][4].
+
+[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[2]: https://groups.google.com/forum/#!forum/glidelibrary
+[3]: http://webchat.freenode.net/?channels=glide-library
+[4]: https://developers.google.com/open-source/cla/individual.
diff --git a/README.md b/README.md
index 54475fb07..a7931876c 100644
--- a/README.md
+++ b/README.md
@@ -3,8 +3,8 @@ Glide
 
 [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
 
-Glide is a fast and efficient open source media management framework for Android that wraps media decoding, memory and
-disk caching, and resource pooling into a simple and easy to use interface.
+Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
+decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.
 
 ![](static/glide_logo.png)
 
@@ -17,7 +17,7 @@ also effective for almost any case where you need to fetch, resize, and display
 
 Download
 --------
-You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases).
+You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
 
@@ -27,8 +27,8 @@ repositories {
 }
 
 dependencies {
-    compile 'com.github.bumptech.glide:glide:3.3.+'
-    compile 'com.android.support:support-v4:19.0.0'
+    compile 'com.github.bumptech.glide:glide:3.5.2'
+    compile 'com.android.support:support-v4:19.1.0'
 }
 ```
 
@@ -38,7 +38,7 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>3.3.1</version>
+  <version>3.5.2</version>
   <type>aar</type>
 </dependency>
 <dependency>
@@ -50,7 +50,7 @@ Or Maven:
 
 How do I use Glide?
 -------------------
-Checkout the [GitHub wiki](https://github.com/bumptech/glide/wiki) for pages on a variety of topics, and see the [javadocs](http://bumptech.github.io/glide/javadocs/latest/index.html).
+Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [javadocs][3].
 
 Simple use cases will look something like this:
 
@@ -91,85 +91,17 @@ public View getView(int position, View recycled, ViewGroup container) {
 
 ```
 
-Volley
--------
-Volley is now an optional dependency that can be included via a utility library. To use Volley to fetch media over http/https:
-
-With Gradle:
-
-```groovy
-dependencies {
-    compile 'com.github.bumptech.glide:volley-integration:1.0.+'
-    compile 'com.mcxiaoke.volley:library:1.0.+'
-}
-```
-
-Or with Maven:
-
-```xml
-<dependency>
-    <groupId>com.github.bumptech.glide</groupId>
-    <artifactId>volley-integration</artifactId>
-    <version>1.0.1</version>
-    <type>jar</type>
-</dependency>
-<dependency>
-    <groupId>com.mcxiaoke.volley</groupId>
-    <artifactId>library</artifactId>
-    <version>1.0.5</version>
-    <type>aar</type>
-</dependency>
-```
-
-Then in your Activity or Application, register the Volley based model loader:
-```java
-public void onCreate() {
-  Glide.get(this).register(GlideUrl.class, InputStream.class,
-        new VolleyUrlLoader.Factory(yourRequestQueue));
-  ...
-}
-```
-
-After the call to register any requests using http or https will go through Volley.
+OkHttp and Volley
+-----------------
+Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies. The
+integration libraries are available via Maven or the [releases page][1].
 
-OkHttp
-------
-In addition to Volley, Glide also includes support for fetching media using OkHttp. To use OkHttp to fetch media over http/https:
-
-With Gradle:
-
-```groovy
-dependencies {
-    compile 'com.github.bumptech.glide:okhttp-integration:1.0.+'
-    compile 'com.squareup.okhttp:okhttp:2.0.+'
-}
-```
-
-Or with Maven:
+For instructions on including either the OkHttp or the Volley integration libraries, see the
+[Integration Libraries][12] wiki page.
 
-```xml
-<dependency>
-    <groupId>com.github.bumptech.glide</groupId>
-    <artifactId>okhttp-integration</artifactId>
-    <version>1.0.1</version>
-    <type>jar</type>
-</dependency>
-<dependency>
-    <groupId>com.squareup.okhttp</groupId>
-    <artifactId>okhttp</artifactId>
-    <version>2.0.0</version>
-    <type>jar</type>
-</dependency>
-```
-
-Then in your Activity or Application, register the OkHttp based model loader:
-```java
-public void onCreate() {
-  Glide.get(this).register(GlideUrl.class, InputStream.class,
-        new OkHttpUrlLoader.Factory(yourOkHttpClient));
-  ...
-}
-```
+Android SDK Version
+-------------------
+Glide requires a minimum sdk version of 10.
 
 License
 -------
@@ -177,7 +109,8 @@ BSD, part MIT and Apache 2.0. See LICENSE file for details.
 
 Status
 ------
-Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!
+Version 3 is a stable public release used in multiple open source projects at Google including in the Android Camera
+app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!
 
 Build
 ------
@@ -190,7 +123,8 @@ git submodule init && git submodule update
 ./gradlew jar
 ```
 
-Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line.
+Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment
+variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line.
 
 Samples
 -------
@@ -204,29 +138,31 @@ Follow the steps in the 'Build' section to setup the project and then:
 
 Development
 -----------
-Follow the steps in the 'Build' section to setup the project and then edit the files however you wish. Intellij's [IDEA 14 early access build](http://confluence.jetbrains.com/display/IDEADEV/IDEA+14+EAP) cleanly imports both Glide's source and tests and is the recommended way to work with Glide. Earlier versions of intellij do not import the gradle project cleanly. Although Android Studio imports the source cleanly, it is not possible to run or debug the tests without manually modifying the tests' classpath.
+Follow the steps in the 'Build' section to setup the project and then edit the files however you wish.
+[Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
 To open the project in Intellij 14:
 
 1. Go to File.
 2. Click on 'Open...'
 3. Navigate to Glide's root directory.
-4. Select settings.gradle.
+4. Select glide-parent.iml
 
 Getting Help
 ------------
-To report a specific problem or feature request, [open a new issue on Github](https://github.com/bumptech/glide/issues/new). For questions, suggestions, or anything else, join or email [Glide's discussion group](https://groups.google.com/forum/#!forum/glidelibrary)
+To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or
+anything else, join or email [Glide's discussion group][6], or join our irc channel: [irc.freenode.net#glide-library][13].
 
 Contributing
 ------------
-Before submitting pull requests, contributors must sign Google's [individual contribution license agreement](https://developers.google.com/open-source/cla/individual).
+Before submitting pull requests, contributors must sign Google's [individual contributor license agreement][7].
 
 Thanks
 ------
-* The Android team and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) Glide's disk cache is based on.
-* Dave Smith for the [gif decoder gist](https://gist.github.com/devunwired/4479231) Glide's gif decoder is based on.
-* Chris Banes for his [gradle-mvn-push](https://github.com/chrisbanes/gradle-mvn-push) script.
-* Corey Hall for Glide's [amazing logo](static/glide_logo.png).
+* The Android team and Jake Wharton for the [disk cache implementation][8] Glide's disk cache is based on.
+* Dave Smith for the [gif decoder gist][9] Glide's gif decoder is based on.
+* Chris Banes for his [gradle-mvn-push][10] script.
+* Corey Hall for Glide's [amazing logo][11].
 * Everyone who has contributed code and reported issues!
 
 Author
@@ -236,3 +172,17 @@ Sam Judd - @samajudd
 Disclaimer
 ---------
 This is not an official Google product.
+
+[1]: https://github.com/bumptech/glide/releases
+[2]: https://github.com/bumptech/glide/wiki
+[3]: http://bumptech.github.io/glide/javadocs/latest/index.html
+[4]: https://www.jetbrains.com/idea/download/
+[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[6]: https://groups.google.com/forum/#!forum/glidelibrary
+[7]: https://developers.google.com/open-source/cla/individual
+[8]: https://github.com/JakeWharton/DiskLruCache
+[9]: https://gist.github.com/devunwired/4479231
+[10]: https://github.com/chrisbanes/gradle-mvn-push
+[11]: static/glide_logo.png
+[12]: https://github.com/bumptech/glide/wiki/Integration-Libraries
+[13]: http://webchat.freenode.net/?channels=glide-library
diff --git a/build.gradle b/build.gradle
index 797a9ede7..49f4c6670 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,31 +1,25 @@
 buildscript {
     repositories {
         jcenter()
-        // TODO: remove this when robolectric 2.4 is released.
-        maven {
-            url 'https://oss.sonatype.org/content/repositories/snapshots'
-        }
     }
 
     dependencies {
-        classpath 'org.robolectric:robolectric-gradle-plugin:0.12.+'
-        classpath 'com.android.tools.build:gradle:0.13.+'
+        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}"
+        classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
+        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
     }
 }
 
 subprojects { project ->
     repositories {
         jcenter()
-        // TODO: remove this when robolectric 2.4 is released.
-        maven {
-            url 'https://oss.sonatype.org/content/repositories/snapshots'
-        }
     }
 
     apply plugin: 'checkstyle'
 
     checkstyle {
         configFile = new File(rootDir, 'checkstyle.xml')
+        configProperties.checkStyleConfigDir = rootProject.rootDir
     }
 
     task checkstyle(type: Checkstyle) {
@@ -53,5 +47,5 @@ subprojects { project ->
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.1'
+    gradleVersion = '2.2'
 }
diff --git a/checkstyle.xml b/checkstyle.xml
index bdf87125b..34735f1b1 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -5,7 +5,7 @@
     <module name="FileTabCharacter"/>
 
     <module name="SuppressionFilter">
-        <property name="file" value="checkstyle_suppressions.xml" />
+        <property name="file" value="${checkStyleConfigDir}/checkstyle_suppressions.xml" />
     </module>
 
     <!-- Trailing spaces -->
@@ -58,7 +58,9 @@
         <module name="MemberName">
             <property name="format" value="^[a-z][a-zA-Z0-9_\$]*$" />
         </module>
-        <module name="MethodName" />
+        <module name="MethodName" >
+            <property name="format" value="^[a-z][a-zA-Z0-9]*(_[a-zA-Z0-9]+)*$"/>
+        </module>
         <module name="PackageName" />
         <module name="ParameterName" />
         <module name="StaticVariableName" />
@@ -86,6 +88,15 @@
             <property name="illegalPkgs" value="org.mockito.internal" />
             <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />
         </module>
+        <module name="ImportOrder">
+          <!-- Checks for out of order import statements. -->
+
+           <property name="severity" value="error"/>
+           <property name="groups" value="com.google,*,java,javax"/>
+           <!-- This ensures that static imports go first. -->
+           <property name="option" value="top"/>
+           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
+         </module>
 
         <!-- Checks for whitespace. -->
         <!-- See http://checkstyle.sourceforge.net/config_whitespace.html -->
diff --git a/glide-parent.iml b/glide-parent.iml
new file mode 100644
index 000000000..22b239290
--- /dev/null
+++ b/glide-parent.iml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" value="$MODULE_DIR$/build" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/classes/main" />
+    <output-test url="file://$MODULE_DIR$/build/classes/test" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/glide-parent/glide-parent-glide-parent.iml b/glide-parent/glide-parent-glide-parent.iml
new file mode 100644
index 000000000..9f3c1ba2d
--- /dev/null
+++ b/glide-parent/glide-parent-glide-parent.iml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
+
diff --git a/glide/glide-glide.iml b/glide/glide-glide.iml
new file mode 100644
index 000000000..28bde5c8d
--- /dev/null
+++ b/glide/glide-glide.iml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.3.0a-SNAPSHOT" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/classes/main" />
+    <output-test url="file://$MODULE_DIR$/build/classes/test" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
+
diff --git a/glide/glide.iml b/glide/glide.iml
new file mode 100644
index 000000000..73b9964c4
--- /dev/null
+++ b/glide/glide.iml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":glide" />
+      </configuration>
+    </facet>
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/classes/main" />
+    <output-test url="file://$MODULE_DIR$/build/classes/test" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index cd214548a..44808936c 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,8 +1,8 @@
-VERSION_NAME=3.4.0-SNAPSHOT
+VERSION_NAME=3.6.0-SNAPSHOT
 VERSION_MAJOR=3
-VERSION_MINOR=4
+VERSION_MINOR=6
 VERSION_PATCH=0
-VERSION_CODE=7
+VERSION_CODE=12
 GROUP=com.github.bumptech.glide
 
 POM_DESCRIPTION=A fast and efficient image loading library for Android focused on smooth scrolling.
@@ -13,3 +13,23 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
+
+SUPPORT_V4_VERSION=19.1.0
+SUPPORT_V7_VERSION=19.1.0
+# TODO: Upgrade to latest version of Volley when we compile with Java 7.
+VOLLEY_VERSION=1.0.8
+OK_HTTP_VERSION=2.2.0
+ANDROID_GRADLE_VERSION=1.0.0
+
+ROBOLECTRIC_GRADLE_VERSION=0.14.0
+COVERALLS_GRADLE_VERSION=2.0.1
+JUNIT_VERSION=4.11
+MOCKITO_VERSION=1.9.5
+ROBOLECTRIC_VERSION=2.4
+MOCKWEBSERVER_VERSION=1.6.0
+TRUTH_VERSION=0.24
+
+COMPILE_SDK_VERSION=19
+BUILD_TOOLS_VERSION=19.1.0
+TARGET_SDK_VERSION=19
+MIN_SDK_VERSION=10
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 53a7b2a77..efa946a2c 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Fri Sep 19 07:33:32 PDT 2014
+#Sat Dec 20 22:55:19 PST 2014
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.1-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip
diff --git a/integration/integration.iml b/integration/integration.iml
new file mode 100644
index 000000000..b6a88a5d8
--- /dev/null
+++ b/integration/integration.iml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":integration" />
+      </configuration>
+    </facet>
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
+
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index 20b7ae229..3de640c50 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -7,17 +7,17 @@ repositories {
 dependencies {
     compile project(':glide')
 
-    compile 'com.squareup.okhttp:okhttp:2.0.+'
+    compile "com.squareup.okhttp:okhttp:${OK_HTTP_VERSION}"
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
-        applicationId 'com.bumptech.glide.integration.okhttp'
-        minSdkVersion 10
-        targetSdkVersion 19
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
         versionCode = VERSION_CODE
         versionName = VERSION_NAME
     }
diff --git a/integration/okhttp/gradle.properties b/integration/okhttp/gradle.properties
index 9bd5c871f..e4b9bb59c 100644
--- a/integration/okhttp/gradle.properties
+++ b/integration/okhttp/gradle.properties
@@ -2,10 +2,14 @@ POM_NAME=Glide OkHttp Integration
 POM_ARTIFACT_ID=okhttp-integration
 POM_PACKAGING=aar
 
-VERSION_NAME=1.1.0-SNAPSHOT
+VERSION_NAME=1.3.0-SNAPSHOT
 VERSION_MAJOR=1
-VERSION_MINOR=1
+VERSION_MINOR=3
 VERSION_PATCH=0
-VERSION_CODE=3
+VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library to use OkHttp to fetch data over http/https in Glide
+
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-integration
diff --git a/integration/okhttp/okhttp.iml b/integration/okhttp/okhttp.iml
new file mode 100644
index 000000000..c60cfc20b
--- /dev/null
+++ b/integration/okhttp/okhttp.iml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="1.2.0-SNAPSHOT" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":integration:okhttp" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+        <option name="LIBRARY_PROJECT" value="true" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Maven Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />
+    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />
+    <orderEntry type="module" module-name="glide" exported="" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/integration/okhttp/src/main/AndroidManifest.xml b/integration/okhttp/src/main/AndroidManifest.xml
index 53b73913d..4ab340867 100644
--- a/integration/okhttp/src/main/AndroidManifest.xml
+++ b/integration/okhttp/src/main/AndroidManifest.xml
@@ -1,5 +1,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.bumptech.glide.integration.okhttp">
-    <application />
-
+    <application>
+        <meta-data
+            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule"
+            android:value="GlideModule" />
+    </application>
 </manifest>
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
new file mode 100644
index 000000000..fd9a901cf
--- /dev/null
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.integration.okhttp;
+
+import android.content.Context;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.GlideModule;
+
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with an OkHttp based
+ * {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p>
+ *     If you're using gradle, you can include this module simply by depending on the aar, the module will be merged
+ *     in by manifest merger. For other build systems or for more more information, see
+ *     {@link com.bumptech.glide.module.GlideModule}.
+ * </p>
+ */
+public class OkHttpGlideModule implements GlideModule {
+    @Override
+    public void applyOptions(Context context, GlideBuilder builder) {
+        // Do nothing.
+    }
+
+    @Override
+    public void registerComponents(Context context, Glide glide) {
+        glide.register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+    }
+}
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index f361c1ea1..0a8543bf8 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -8,6 +8,7 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.Map;
 
 /**
  * Fetches an {@link InputStream} using the okhttp library.
@@ -15,7 +16,6 @@
 public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
     private final OkHttpClient client;
     private final GlideUrl url;
-    private volatile Request request;
     private InputStream stream;
 
     public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
@@ -25,9 +25,12 @@ public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
 
     @Override
     public InputStream loadData(Priority priority) throws Exception {
-        request = new Request.Builder()
-                .url(url.toString())
-                .build();
+        Request.Builder requestBuilder = new Request.Builder()
+                .url(url.toStringUrl());
+        for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
+          requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
+        }
+        Request request = requestBuilder.build();
 
         stream = client.newCall(request)
                 .execute()
@@ -50,13 +53,11 @@ public void cleanup() {
 
     @Override
     public String getId() {
-        return url.toString();
+        return url.getCacheKey();
     }
 
     @Override
     public void cancel() {
-        if (request != null) {
-            client.cancel(request);
-        }
+        // TODO: call cancel on the client when this method is called on a background thread. See #257
     }
 }
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 9ab592c2a..eb35139b4 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
+
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.GlideUrl;
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index d26466aab..ce85c8b53 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -7,25 +7,25 @@ repositories {
 
 dependencies {
     compile project(':glide')
-    compile 'com.mcxiaoke.volley:library:1.0.+'
+    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
 
-    androidTestCompile 'org.hamcrest:hamcrest-core:1.3'
-    androidTestCompile 'org.hamcrest:hamcrest-library:1.3'
-    androidTestCompile 'junit:junit:4.11'
-    androidTestCompile 'org.mockito:mockito-all:1.9.5'
-    androidTestCompile 'org.robolectric:robolectric:2.4-SNAPSHOT'
+    androidTestCompile project(":testutil")
+    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
+    androidTestCompile "junit:junit:${JUNIT_VERSION}"
+    androidTestCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    androidTestCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
     // TODO: increase this to 2.0.+ when we compile against Java 7.
-    androidTestCompile 'com.squareup.okhttp:mockwebserver:1.2.+'
+    androidTestCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
-        applicationId 'com.bumptech.glide.integration.volley'
-        minSdkVersion 10
-        targetSdkVersion 19
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
         versionCode = VERSION_CODE
         versionName = VERSION_NAME
     }
diff --git a/integration/volley/gradle.properties b/integration/volley/gradle.properties
index 48565fee4..885032e35 100644
--- a/integration/volley/gradle.properties
+++ b/integration/volley/gradle.properties
@@ -2,10 +2,14 @@ POM_NAME=Glide Volley Integration
 POM_ARTIFACT_ID=volley-integration
 POM_PACKAGING=aar
 
-VERSION_NAME=1.1.0-SNAPSHOT
+VERSION_NAME=1.3.0-SNAPSHOT
 VERSION_MAJOR=1
-VERSION_MINOR=1
+VERSION_MINOR=3
 VERSION_PATCH=0
-VERSION_CODE=3
+VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library to use Volley to fetch data over http/https in Glide
+
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-integration
diff --git a/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index e70c61656..b376a93f1 100644
--- a/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -1,6 +1,13 @@
 package com.bumptech.glide.integration.volley;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.os.SystemClock;
+
 import com.android.volley.NoConnectionError;
 import com.android.volley.RequestQueue;
 import com.android.volley.ServerError;
@@ -9,8 +16,11 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.Headers;
+import com.bumptech.glide.testutil.TestUtil;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -22,19 +32,14 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowSystemClock;
 
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.ProtocolException;
 import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.ExecutionException;
 
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.containsString;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.instanceOf;
-import static org.junit.Assert.fail;
-
 /**
  * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server responses.
  */
@@ -67,7 +72,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
                 .setResponseCode(200));
         DataFetcher<InputStream> fetcher = getFetcher();
         InputStream is = fetcher.loadData(Priority.HIGH);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
     }
 
     @Test
@@ -80,7 +85,7 @@ public void testHandlesRedirect301s() throws Exception {
             .setResponseCode(200)
             .setBody(expected));
         InputStream is = getFetcher().loadData(Priority.LOW);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
     }
 
     @Test
@@ -93,7 +98,7 @@ public void testHandlesRedirect302s() throws Exception {
             .setResponseCode(200)
             .setBody(expected));
         InputStream is = getFetcher().loadData(Priority.LOW);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
     }
 
     @Test
@@ -110,11 +115,11 @@ public void testHandlesUpToFiveRedirects() throws Exception {
             .setResponseCode(200).setBody(expected));
 
         InputStream is = getFetcher().loadData(Priority.NORMAL);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
 
-        assertThat(mockWebServer.takeRequest().getPath(), containsString(DEFAULT_PATH));
+        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
         for (int i = 0; i < numRedirects; i++) {
-            assertThat(mockWebServer.takeRequest().getPath(), containsString(redirectBase + i));
+            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
         }
     }
 
@@ -128,7 +133,7 @@ public void testThrowsIfRedirectLocationIsEmpty() throws Exception {
             getFetcher().loadData(Priority.NORMAL);
             fail("Didn't get expected IOException");
         } catch (ExecutionException e) {
-            assertThat(e.getCause(), instanceOf(VolleyError.class));
+            assertThat(e.getCause()).isInstanceOf(VolleyError.class);
         }
     }
 
@@ -139,7 +144,7 @@ public void testThrowsIfStatusCodeIsNegativeOne() throws Exception {
             getFetcher().loadData(Priority.LOW);
             fail("Failed to get expected exception");
         } catch (ExecutionException e) {
-            assertThat(e.getCause(), instanceOf(NoConnectionError.class));
+            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
         }
     }
 
@@ -154,8 +159,8 @@ public void testThrowsAfterTooManyRedirects() throws Exception {
             getFetcher().loadData(Priority.NORMAL);
             fail("Failed to get expected exception");
         } catch (ExecutionException e) {
-            assertThat(e.getCause(), instanceOf(NoConnectionError.class));
-            assertThat(e.getCause().getCause(), instanceOf(ProtocolException.class));
+            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
+            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);
         }
     }
 
@@ -167,7 +172,7 @@ public void testThrowsIfStatusCodeIs500() throws Exception {
             getFetcher().loadData(Priority.NORMAL);
             fail("Failed to get expected exception");
         } catch (ExecutionException e) {
-            assertThat(e.getCause(), instanceOf(ServerError.class));
+            assertThat(e.getCause()).isInstanceOf(ServerError.class);
         }
     }
 
@@ -178,11 +183,30 @@ public void testThrowsIfStatusCodeIs400() throws Exception {
             getFetcher().loadData(Priority.LOW);
             fail("Failed to get expected exception");
         } catch (ExecutionException e) {
-            assertThat(e.getCause(), instanceOf(ServerError.class));
+            assertThat(e.getCause()).isInstanceOf(ServerError.class);
         }
     }
 
+    @Test
+    public void testAppliesHeadersInGlideUrl() throws Exception {
+      mockWebServer.enqueue(new MockResponse().setResponseCode(200));
+      String headerField = "field";
+      String headerValue = "value";
+      Map<String, String> headersMap = new HashMap<String, String>();
+      headersMap.put(headerField, headerValue);
+      Headers headers = mock(Headers.class);
+      when(headers.getHeaders()).thenReturn(headersMap);
+
+      getFetcher(headers).loadData(Priority.HIGH);
+
+      assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
+    }
+
     private DataFetcher<InputStream> getFetcher() {
+      return getFetcher(Headers.NONE);
+    }
+
+    private DataFetcher<InputStream> getFetcher(Headers headers) {
         URL url = mockWebServer.getUrl(DEFAULT_PATH);
         VolleyRequestFuture<InputStream> requestFuture = new VolleyRequestFuture<InputStream>() {
             @Override
@@ -197,17 +221,7 @@ public InputStream get() throws InterruptedException, ExecutionException {
                 return super.get();
             }
         };
-        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString()), requestFuture);
-    }
-
-    private static String isToString(InputStream is) throws IOException {
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        byte[] buffer = new byte[1024];
-        int read;
-        while ((read = is.read(buffer)) != -1) {
-            os.write(buffer, 0, read);
-        }
-        return new String(os.toByteArray());
+        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers), requestFuture);
     }
 
     /** A shadow clock that doesn't rely on running on an Android thread with a Looper. */
diff --git a/integration/volley/src/main/AndroidManifest.xml b/integration/volley/src/main/AndroidManifest.xml
index c2d679aab..554a22600 100644
--- a/integration/volley/src/main/AndroidManifest.xml
+++ b/integration/volley/src/main/AndroidManifest.xml
@@ -1,5 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.bumptech.glide.integration.volley">
-  <application />
+  <application>
+      <meta-data
+          android:name="com.bumptech.glide.integration.volley.VolleyGlideModule"
+          android:value="GlideModule" />
+  </application>
 </manifest>
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
new file mode 100644
index 000000000..eaa05dba7
--- /dev/null
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.integration.volley;
+
+import android.content.Context;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.GlideModule;
+
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a Volley based
+ * {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p>
+ *     If you're using gradle, you can include this module simply by depending on the aar, the module will be merged
+ *     in by manifest merger. For other build systems or for more more information, see
+ *     {@link com.bumptech.glide.module.GlideModule}.
+ * </p>
+ */
+public class VolleyGlideModule implements GlideModule {
+    @Override
+    public void applyOptions(Context context, GlideBuilder builder) {
+        // Do nothing.
+    }
+
+    @Override
+    public void registerComponents(Context context, Glide glide) {
+        glide.register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
+    }
+}
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
new file mode 100644
index 000000000..0c8a4f5eb
--- /dev/null
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide.integration.volley;
+
+import com.android.volley.Request;
+import com.android.volley.Request.Priority;
+
+import java.io.InputStream;
+import java.util.Map;
+
+/**
+ * Used to construct a custom Volley request, such as for authentication header decoration.
+ */
+public interface VolleyRequestFactory {
+
+    /**
+     * Returns a Volley request for the given image url. The given future should be set as a
+     * listener or called when the request completes.
+     */
+    Request<byte[]> create(String url, VolleyRequestFuture<InputStream> future, Priority priority,
+        Map<String, String> headers);
+
+}
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index d78723d80..d14a64405 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.volley;
 
+import com.android.volley.AuthFailureError;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
@@ -11,13 +12,26 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
-import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.Map;
 
 /**
  * A DataFetcher backed by volley for fetching images via http.
  */
 public class VolleyStreamFetcher implements DataFetcher<InputStream> {
+    public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
+
+        @Override
+        public Request<byte[]> create(
+                    String url, VolleyRequestFuture<InputStream> future,
+                    Request.Priority priority, Map<String, String> headers) {
+            return new GlideRequest(url, future, priority, headers);
+        }
+
+    };
+
     private final RequestQueue requestQueue;
+    private final VolleyRequestFactory requestFactory;
     private final GlideUrl url;
     private VolleyRequestFuture<InputStream> requestFuture;
 
@@ -28,8 +42,14 @@ public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
 
     public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
             VolleyRequestFuture<InputStream> requestFuture) {
+        this(requestQueue, url, requestFuture, DEFAULT_REQUEST_FACTORY);
+    }
+
+    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
+            VolleyRequestFuture<InputStream> requestFuture, VolleyRequestFactory requestFactory) {
         this.requestQueue = requestQueue;
         this.url = url;
+        this.requestFactory = requestFactory;
         this.requestFuture = requestFuture;
         if (requestFuture == null) {
             this.requestFuture = VolleyRequestFuture.newFuture();
@@ -39,8 +59,9 @@ public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
     @Override
     public InputStream loadData(Priority priority) throws Exception {
         // Make sure the string url safely encodes non ascii characters.
-        String stringUrl = url.toURL().toString();
-        GlideRequest request = new GlideRequest(stringUrl, requestFuture, glideToVolleyPriority(priority));
+        String stringUrl = url.toStringUrl();
+        Request<byte[]> request = requestFactory.create(
+                stringUrl, requestFuture, glideToVolleyPriority(priority), url.getHeaders());
 
         requestFuture.setRequest(requestQueue.add(request));
 
@@ -54,7 +75,7 @@ public void cleanup() {
 
     @Override
     public String getId() {
-        return url.toString();
+        return url.getCacheKey();
     }
 
     @Override
@@ -81,12 +102,24 @@ public void cancel() {
 
     private static class GlideRequest extends Request<byte[]> {
         private final VolleyRequestFuture<InputStream> future;
-        private Priority priority;
+        private final Priority priority;
+        private final Map<String, String> headers;
 
         public GlideRequest(String url, VolleyRequestFuture<InputStream> future, Priority priority) {
-            super(Method.GET, url, future);
-            this.future = future;
-            this.priority = priority;
+          this(url, future, priority, Collections.<String, String>emptyMap());
+        }
+
+        public GlideRequest(String url, VolleyRequestFuture<InputStream> future, Priority priority,
+                  Map<String, String> headers) {
+              super(Method.GET, url, future);
+              this.future = future;
+              this.priority = priority;
+          this.headers = headers;
+        }
+
+        @Override
+        public Map<String, String> getHeaders() throws AuthFailureError {
+          return headers;
         }
 
         @Override
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index b2093ef52..b1be94abd 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -1,13 +1,14 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
+import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
-import com.bumptech.glide.load.data.DataFetcher;
 
 import java.io.InputStream;
 
@@ -22,6 +23,7 @@
     public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
         private static RequestQueue internalQueue;
         private RequestQueue requestQueue;
+        private final VolleyRequestFactory requestFactory;
 
         private static RequestQueue getInternalQueue(Context context) {
             if (internalQueue == null) {
@@ -45,12 +47,21 @@ public Factory(Context context) {
          * Constructor for a new Factory that runs requests using the given {@link RequestQueue}.
          */
         public Factory(RequestQueue requestQueue) {
+            this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
+        }
+
+        /**
+         * Constructor for a new Factory with a custom Volley request factory that runs requests
+         * using the given {@link RequestQueue}.
+         */
+        public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
+            this.requestFactory = requestFactory;
             this.requestQueue = requestQueue;
         }
 
         @Override
         public ModelLoader<GlideUrl, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new VolleyUrlLoader(requestQueue);
+            return new VolleyUrlLoader(requestQueue, requestFactory);
         }
 
         @Override
@@ -60,13 +71,20 @@ public void teardown() {
     }
 
     private final RequestQueue requestQueue;
+    private final VolleyRequestFactory requestFactory;
 
     public VolleyUrlLoader(RequestQueue requestQueue) {
+        this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
+    }
+
+    public VolleyUrlLoader(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
         this.requestQueue = requestQueue;
+        this.requestFactory = requestFactory;
     }
 
     @Override
     public DataFetcher<InputStream> getResourceFetcher(GlideUrl url, int width, int height) {
-        return new VolleyStreamFetcher(requestQueue, url, new VolleyRequestFuture<InputStream>());
+        return new VolleyStreamFetcher(
+            requestQueue, url, new VolleyRequestFuture<InputStream>(), requestFactory);
     }
 }
diff --git a/integration/volley/volley.iml b/integration/volley/volley.iml
new file mode 100644
index 000000000..a4c96ac9c
--- /dev/null
+++ b/integration/volley/volley.iml
@@ -0,0 +1,114 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":integration:volley" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="1.2.0-SNAPSHOT" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":integration:volley" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+        <option name="LIBRARY_PROJECT" value="true" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Maven Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" scope="TEST" name="commons-codec-1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-2.4" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="mockwebserver-1.6.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="okhttp-1.6.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="objenesis-1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="robolectric-2.4" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="vtd-xml-2.11" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-commons-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-core-1.3" level="project" />
+    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="junit-4.11" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-tree-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-analysis-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="truth-0.24" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="mockito-all-1.9.5" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="ant-launcher-1.8.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="guava-17.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-util-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="bcprov-jdk15on-1.48" level="project" />
+    <orderEntry type="module" module-name="testutil" exported="" />
+    <orderEntry type="module" module-name="glide" exported="" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/library/build.gradle b/library/build.gradle
index 66c86131e..1f64881e4 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -3,38 +3,53 @@ apply plugin: 'robolectric'
 apply plugin: 'maven'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
+apply plugin: 'jacoco'
+apply plugin: 'com.github.kt3k.coveralls'
 
 findbugs {
     toolVersion = "2.0.3"
 }
+jacoco {
+    toolVersion = "0.7.1.201405082137"
+}
+coveralls {
+    jacocoReportPath = 'build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml'
+}
 
 dependencies {
     compile project(':third_party:gif_decoder')
     compile project(':third_party:gif_encoder')
     compile project(':third_party:disklrucache')
-    compile 'com.android.support:support-v4:19.1.+'
-
-    androidTestCompile 'org.hamcrest:hamcrest-core:1.3'
-    androidTestCompile 'org.hamcrest:hamcrest-library:1.3'
-    androidTestCompile 'junit:junit:4.11'
-    androidTestCompile 'org.mockito:mockito-all:1.9.5'
-    androidTestCompile 'org.robolectric:robolectric:2.4-SNAPSHOT'
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+
+    androidTestCompile project(':testutil')
+    androidTestCompile 'com.google.guava:guava-testlib:18.0'
+    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
+    androidTestCompile "junit:junit:${JUNIT_VERSION}"
+    androidTestCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    androidTestCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
     // TODO: increase this to 2.0.+ when we compile against Java 7.
-    androidTestCompile 'com.squareup.okhttp:mockwebserver:1.2.+'
+    androidTestCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
-        applicationId 'com.bumptech.glide'
-        minSdkVersion 10
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
 
-        targetSdkVersion 19
-        versionCode = VERSION_CODE
+        versionCode = VERSION_CODE as int
         versionName = VERSION_NAME
     }
+
+    buildTypes {
+        debug {
+            testCoverageEnabled = true
+        }
+    }
 }
 
 afterEvaluate {
@@ -85,4 +100,30 @@ afterEvaluate {
     }
 
     check.dependsOn('pmd')
+
+    task jacocoTestReport(type:JacocoReport, dependsOn: testDebug) {
+        def coverageSourceDirs = ['src/main/java']
+        group = "Reporting"
+        description = "Generate Jacoco coverage reports"
+
+        classDirectories = fileTree(
+                dir: 'build/intermediates/classes/debug',
+                excludes: ['**/R.class',
+                           '**/R$*.class',
+                           '**/BuildConfig.*',
+                           '**/Manifest*.*',
+                           '**/BitmapRequestBuilder.class',
+                           '**/DrawableRequestBuilder.class',
+                           '**/GifRequestBuilder.class', ]
+        )
+
+        additionalSourceDirs = files(coverageSourceDirs)
+        sourceDirectories = files(coverageSourceDirs)
+        executionData = files('build/jacoco/testDebug.exec')
+
+        reports {
+            xml.enabled = true
+            html.enabled = true
+        }
+    }
 }
diff --git a/library/library.iml b/library/library.iml
new file mode 100644
index 000000000..622e535cb
--- /dev/null
+++ b/library/library.iml
@@ -0,0 +1,123 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":library" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":library" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+        <option name="LIBRARY_PROJECT" value="true" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
+      <excludeFolder url="file://$MODULE_DIR$/build/test-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/test-report" />
+      <excludeFolder url="file://$MODULE_DIR$/build/test-results" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Maven Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="objenesis-1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="guava-18.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="truth-0.24" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-2.4" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="jsr305-1.3.9" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="commons-codec-1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="mockwebserver-1.6.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="okhttp-1.6.0" level="project" />
+    <orderEntry type="library" exported="" name="support-v4-19.1.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="robolectric-2.4" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="guava-testlib-18.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-commons-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="vtd-xml-2.11" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-core-1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-tree-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="junit-4.11" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-analysis-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="mockito-all-1.9.5" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="ant-launcher-1.8.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-util-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="bcprov-jdk15on-1.48" level="project" />
+    <orderEntry type="module" module-name="gif_decoder" exported="" />
+    <orderEntry type="module" module-name="testutil" exported="" />
+    <orderEntry type="module" module-name="disklrucache" exported="" />
+    <orderEntry type="module" module-name="gif_encoder" exported="" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java
index 4af20a424..f972fd54e 100644
--- a/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java
@@ -1,11 +1,20 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.Util.arg;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.provider.LoadProvider;
 import com.bumptech.glide.tests.GlideShadowLooper;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -14,15 +23,8 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import static com.bumptech.glide.tests.Util.arg;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = GlideShadowLooper.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
 public class BitmapTypeRequestTest {
     private RequestManager.OptionsApplier optionsApplier;
     private BitmapTypeRequest request;
diff --git a/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java
index be08f2ad4..491907a8b 100644
--- a/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java
@@ -1,9 +1,17 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.Util.arg;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.tests.GlideShadowLooper;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -12,18 +20,10 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import static com.bumptech.glide.tests.Util.arg;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = GlideShadowLooper.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
 public class DrawableTypeRequestTest {
     private DrawableTypeRequest<String> request;
-    private String model;
     private RequestManager.OptionsApplier optionsApplier;
 
     @SuppressWarnings("unchecked")
diff --git a/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java
index 8e3d04031..bb47ef74b 100644
--- a/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java
@@ -1,6 +1,14 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
@@ -11,21 +19,17 @@
 import com.bumptech.glide.request.animation.GlideAnimationFactory;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.BackgroundUtil;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @SuppressWarnings("unchecked")
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GenericRequestBuilderTest {
     private RequestTracker requestTracker;
 
@@ -71,12 +75,45 @@ public void testThrowsWhenOverrideHeightEqualToZero() {
         getNullModelRequest().override(100, 0);
     }
 
+    @Test
+    public void testDoesNotThrowWhenWidthIsSizeOriginal() {
+        getNullModelRequest().override(Target.SIZE_ORIGINAL, 100);
+    }
+
+    @Test
+    public void testDoesNotThrowWhenHeightIsSizeOriginal() {
+        getNullModelRequest().override(100, Target.SIZE_ORIGINAL);
+    }
+
     @Test
     public void testDoesNotThrowWhenModelAndLoaderNull() {
         new GenericRequestBuilder(Robolectric.application, null, null, Object.class, mock(Glide.class), requestTracker,
                 mock(Lifecycle.class));
     }
 
+    @Test(expected = IllegalArgumentException.class)
+    public void testProvidingSelfAsThumbnailThrows() {
+        GenericRequestBuilder request = getNullModelRequest();
+        request.thumbnail(request);
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testProvidingSelfAsChildOfThumbnailThrows() {
+        GenericRequestBuilder first = getNullModelRequest();
+        GenericRequestBuilder second = first.clone();
+        second.thumbnail(first);
+        first.thumbnail(second);
+        first.into(mock(Target.class));
+    }
+
+    @Test
+    public void testCanPassedClonedSelfToThumbnail() {
+        GenericRequestBuilder first = getNullModelRequest();
+        GenericRequestBuilder second = first.clone();
+        GenericRequestBuilder third = second.clone();
+        first.thumbnail(second.thumbnail(third)).into(mock(Target.class));
+    }
+
     @Test
     public void testDoesNotThrowWithNullModelWhenDecoderSet() {
         getNullModelRequest().decoder(mock(ResourceDecoder.class));
diff --git a/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java
index 68deae218..5c023dc09 100644
--- a/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java
@@ -1,10 +1,18 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.Util.arg;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.tests.GlideShadowLooper;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -13,15 +21,8 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import static com.bumptech.glide.tests.Util.arg;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = GlideShadowLooper.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
 public class GenericTranscodeRequestTest {
     private RequestManager.OptionsApplier optionsApplier;
     private GenericTranscodeRequest<String, Object, Object> request;
diff --git a/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java
index d5eca4fb1..2a0725cd6 100644
--- a/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java
@@ -1,11 +1,19 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.Util.arg;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.provider.LoadProvider;
 import com.bumptech.glide.tests.GlideShadowLooper;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -16,15 +24,8 @@
 
 import java.io.InputStream;
 
-import static com.bumptech.glide.tests.Util.arg;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = GlideShadowLooper.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
 public class GifTypeRequestTest {
     private RequestManager.OptionsApplier optionsApplier;
     private GifTypeRequest<String> request;
diff --git a/library/src/androidTest/java/com/bumptech/glide/GlideTest.java b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java
index 593485f80..df42930d4 100644
--- a/library/src/androidTest/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java
@@ -1,5 +1,17 @@
 package com.bumptech.glide;
 
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.notNull;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.res.AssetFileDescriptor;
@@ -13,6 +25,7 @@
 import android.os.ParcelFileDescriptor;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
@@ -33,12 +46,15 @@
 import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.animation.GlideAnimation;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.testutil.TestResourceUtil;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -50,6 +66,7 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadows.ShadowBitmap;
 
 import java.io.ByteArrayInputStream;
@@ -64,24 +81,12 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.notNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 /**
  * Tests for the {@link Glide} interface and singleton.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = { GlideTest.ShadowFileDescriptorContentResolver.class, GlideTest.ShadowMediaMetadataRetriever.class,
-        GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class })
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { GlideTest.ShadowFileDescriptorContentResolver.class,
+        GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class })
 public class GlideTest {
     private Target target = null;
     private ImageView imageView;
@@ -133,7 +138,8 @@ public Boolean answer(InvocationOnMock invocation) throws Throwable {
 
         Glide.get(getContext()).register(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);
         Lifecycle lifecycle = mock(Lifecycle.class);
-        requestManager = new RequestManager(getContext(), lifecycle);
+        RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
+        requestManager = new RequestManager(getContext(), lifecycle, treeNode);
         requestManager.resumeRequests();
     }
 
@@ -778,7 +784,7 @@ private Context getContext() {
 
 
     private InputStream openResource(String imageName) throws IOException {
-        return getClass().getResourceAsStream("/" + imageName);
+        return TestResourceUtil.openResource(getClass(), imageName);
     }
 
     private static class CallCallback implements Answer<Void> {
@@ -806,7 +812,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     // one content resolver shadow in one part of the test and a different one in a different part of the test. Each
     // one ends up with different registered uris, which causes tests to fail. We shouldn't need to do this, but
     // using static maps seems to fix the issue.
-    @Implements(value = ContentResolver.class, resetStaticState = true)
+    @Implements(value = ContentResolver.class)
     public static class ShadowFileDescriptorContentResolver {
         private static final Map<Uri, AssetFileDescriptor> URI_TO_FILE_DESCRIPTOR =
                 new HashMap<Uri, AssetFileDescriptor>();
@@ -836,6 +842,7 @@ public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String type) {
             return URI_TO_FILE_DESCRIPTOR.get(uri);
         }
 
+        @Resetter
         public static void reset() {
             URI_TO_INPUT_STREAMS.clear();
             URI_TO_FILE_DESCRIPTOR.clear();
diff --git a/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java
index 16b87d92c..cf02f881a 100644
--- a/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java
@@ -1,39 +1,63 @@
 package com.bumptech.glide;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.verification.VerificationMode;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.hamcrest.Matchers.containsInAnyOrder;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ListPreloaderTest {
 
+    @Mock
+    private BitmapRequestBuilder request;
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+    }
+
     @Test
     public void testGetItemsIsCalledIncreasing() {
         final AtomicBoolean called = new AtomicBoolean(false);
-        ListPreloaderAdapter preloader = new ListPreloaderAdapter(10) {
+        final AtomicInteger calledCount = new AtomicInteger();
+
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
             @Override
-            protected List<Object> getItems(int start, int end) {
+            public List<Object> getPreloadItems(int position) {
                 called.set(true);
-                assertEquals(11, start);
-                assertEquals(21, end);
-                return super.getItems(start, end);
+                final int count = calledCount.getAndIncrement();
+                assertEquals(11 + count, position);
+                return super.getPreloadItems(position);
             }
         };
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
         preloader.onScroll(null, 1, 10, 30);
-        assertTrue(called.get());
+        assertEquals(10, calledCount.get());
     }
 
     @Test
@@ -41,48 +65,53 @@ public void testGetItemsIsCalledInOrderIncreasing() {
         final int toPreload = 10;
         final List<Object> objects = new ArrayList<Object>();
         for (int i = 0; i < toPreload; i++) {
-            objects.add(new Object());
+            objects.add(new Integer(i));
         }
 
-        ListPreloader preloader = new ListPreloader(toPreload) {
-            int expectedPosition;
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+
+            public int expectedPosition;
+
             @Override
-            protected int[] getDimensions(Object item) {
-                return new int[] { 10, 10 };
+            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+                return new int[]{10, 10};
             }
 
             @Override
-            protected List getItems(int start, int end) {
-                return objects;
+            public List<Object> getPreloadItems(int position) {
+                return objects.subList(position - 11, position + 1 - 11);
             }
 
             @Override
-            protected BitmapRequestBuilder getRequestBuilder(Object item) {
+            public BitmapRequestBuilder getPreloadRequestBuilder(Object item) {
                 assertEquals(objects.get(expectedPosition), item);
                 expectedPosition++;
                 return mock(BitmapRequestBuilder.class);
             }
         };
-
-        preloader.onScroll(null, 1, 10, 30);
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter,
+                toPreload);
+        preloader.onScroll(null, 1, 10, 20);
     }
 
     @Test
     public void testGetItemsIsCalledDecreasing() {
         final AtomicBoolean called = new AtomicBoolean(false);
-        ListPreloaderAdapter preloader = new ListPreloaderAdapter(10) {
+        final AtomicInteger calledCount = new AtomicInteger();
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
             @Override
-            protected List<Object> getItems(int start, int end) {
+            public List<Object> getPreloadItems(int position) {
                 // Ignore the preload caused from us starting at the end
-                if (start == 40) {
+                if (position >= 40) {
                     return Collections.emptyList();
                 }
+                final int count = calledCount.getAndIncrement();
                 called.set(true);
-                assertEquals(19, start);
-                assertEquals(29, end);
-                return super.getItems(start, end);
+                assertEquals(28 - count, position);
+                return super.getPreloadItems(position);
             }
         };
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
         preloader.onScroll(null, 30, 10, 40);
         preloader.onScroll(null, 29, 10, 40);
         assertTrue(called.get());
@@ -96,45 +125,48 @@ public void testGetItemsIsCalledInOrderDecreasing() {
             objects.add(new Object());
         }
 
-        ListPreloader preloader = new ListPreloader(toPreload) {
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
             int expectedPosition = toPreload - 1;
+
             @Override
-            protected int[] getDimensions(Object item) {
-                return new int[] { 10, 10 };
+            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+                return new int[]{10, 10};
             }
 
             @Override
-            protected List getItems(int start, int end) {
-                if (start == 40) {
-                    return  Collections.emptyList();
+            public List<Object> getPreloadItems(int position) {
+                if (position == 40) {
+                    return null;
                 }
-                return objects;
+                return objects.subList(position, position + 1);
             }
 
             @Override
-            protected BitmapRequestBuilder getRequestBuilder(Object item) {
+            public BitmapRequestBuilder getPreloadRequestBuilder(Object item) {
                 assertEquals(objects.get(expectedPosition), item);
                 expectedPosition--;
                 return mock(BitmapRequestBuilder.class);
             }
         };
-
-        preloader.onScroll(null, 30, 10, 40);
-        preloader.onScroll(null, 29, 10, 40);
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, toPreload);
+        preloader.onScroll(null, 30, 10, 10);
+        preloader.onScroll(null, 29, 10, 10);
     }
 
     @Test
     public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
         final AtomicBoolean called = new AtomicBoolean(false);
-        ListPreloaderAdapter preloader = new ListPreloaderAdapter(10) {
+        final AtomicInteger calledCount = new AtomicInteger();
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
             @Override
-            protected List<Object> getItems(int start, int end) {
+            public List<Object> getPreloadItems(int position) {
                 called.set(true);
-                assertEquals(26, start);
-                assertEquals(30, end);
-                return super.getItems(start, end);
+                final int count = calledCount.getAndIncrement();
+                assertEquals(26 + count, position);
+                return super.getPreloadItems(position);
             }
         };
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
         preloader.onScroll(null, 16, 10, 30);
         assertTrue(called.get());
     }
@@ -142,18 +174,21 @@ public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
     @Test
     public void testGetItemsIsNeverCalledWithStartLessThanZero() {
         final AtomicBoolean called = new AtomicBoolean(false);
-        ListPreloaderAdapter preloader = new ListPreloaderAdapter(10) {
+        final AtomicInteger calledCount = new AtomicInteger();
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
             @Override
-            protected List<Object> getItems(int start, int end) {
-                if (start == 17) {
+            public List<Object> getPreloadItems(int position) {
+                if (position >= 17) {
                     return Collections.emptyList();
                 }
                 called.set(true);
-                assertEquals(0, start);
-                assertEquals(6, end);
-                return super.getItems(start, end);
+                final int count = calledCount.getAndIncrement();
+                assertEquals(5 - count, position);
+                return super.getPreloadItems(position);
             }
         };
+
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
         preloader.onScroll(null, 7, 10, 30);
         preloader.onScroll(null, 6, 10, 30);
         assertTrue(called.get());
@@ -162,99 +197,173 @@ public void testGetItemsIsNeverCalledWithStartLessThanZero() {
     @Test
     public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
         final AtomicInteger called = new AtomicInteger();
-        ListPreloaderAdapter preloader = new ListPreloaderAdapter(10) {
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
             @Override
-            protected List<Object> getItems(int start, int end) {
+            public List<Object> getPreloadItems(int position) {
                 final int current = called.getAndIncrement();
-                if (current == 0) {
-                    assertEquals(11, start);
-                    assertEquals(21, end);
-                } else if (current == 1) {
-                    assertEquals(21, start);
-                    assertEquals(24, end);
-                }
-                return super.getItems(start, end);
+                assertEquals(11 + current, position);
+                return super.getPreloadItems(position);
             }
         };
 
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
         preloader.onScroll(null, 1, 10, 30);
         preloader.onScroll(null, 4, 10, 30);
 
-        assertEquals(2, called.get());
+        assertEquals(13, called.get());
     }
 
     @Test
     public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
         final AtomicInteger called = new AtomicInteger();
-        ListPreloaderAdapter preloader = new ListPreloaderAdapter(10) {
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
             @Override
-            protected List<Object> getItems(int start, int end) {
-                if (start == 30) {
+            public List<Object> getPreloadItems(int position) {
+                if (position >= 20) {
                     return Collections.emptyList();
                 }
                 final int current = called.getAndIncrement();
-                if (current == 0) {
-                    assertEquals(10, start);
-                    assertEquals(20, end);
-                } else if (current == 1) {
-                    assertEquals(7, start);
-                    assertEquals(10, end);
-                }
-                return super.getItems(start, end);
+                assertEquals(19 - current, position);
+                return super.getPreloadItems(position);
             }
         };
 
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
         preloader.onScroll(null, 21, 10, 30);
         preloader.onScroll(null, 20, 10, 30);
         preloader.onScroll(null, 17, 10, 30);
-        assertEquals(2, called.get());
+        assertEquals(13, called.get());
     }
 
     @Test
-    public void testItemsArePreloadedWithGlide() {
+    public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException {
         final List<Object> objects = new ArrayList<Object>();
         objects.add(new Object());
         objects.add(new Object());
-        final HashSet<Object> loadedObjects = new HashSet<Object>();
-        ListPreloaderAdapter preloader = new ListPreloaderAdapter(10) {
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+            public int expectedPosition = (1 + 10) * 2;
+
             @Override
-            protected List<Object> getItems(int start, int end) {
+            public List<Object> getPreloadItems(int position) {
                 return objects;
             }
 
             @Override
-            protected GenericRequestBuilder getRequestBuilder(Object item) {
-                loadedObjects.add(item);
-                return super.getRequestBuilder(item);
+            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+                assertEquals(expectedPosition / 2, adapterPostion);
+                assertEquals(expectedPosition % 2, itemPosition);
+                expectedPosition++;
+                return itemPosition == 0 ? new int[]{10, 11} : new int[]{20, 21};
+            }
+
+            @Override
+            public GenericRequestBuilder getPreloadRequestBuilder(Object item) {
+                return request;
             }
         };
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
+        Iterable<Integer> expected = Arrays.asList(10, 11, 20, 21, 10, 11, 20, 21);
 
-        preloader.onScroll(null, 1, 10, 30);
+        preloader.onScroll(null, 1, 10, 1 + 10 + 2);
 
-        assertThat(loadedObjects, containsInAnyOrder(objects.toArray()));
+        List<Integer> allValues = getTagetsSizes(request, times(4));
+        assertEquals(expected, allValues);
     }
 
-    private static class ListPreloaderAdapter extends ListPreloader<Object> {
+    @Test
+    public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException {
+        final List<Object> objects = new ArrayList<Object>();
+        objects.add(new Object());
+        objects.add(new Object());
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+            int expectedPosition = objects.size() * 2 - 1;
+
+            @Override
+            public List<Object> getPreloadItems(int position) {
+                return objects;
+            }
+
+            @Override
+            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+                assertEquals(expectedPosition / 2, adapterPostion);
+                assertEquals(expectedPosition % 2, itemPosition);
+                expectedPosition--;
+                return itemPosition == 0 ? new int[]{10, 11} : new int[]{20, 21};
+            }
+
+            @Override
+            public GenericRequestBuilder getPreloadRequestBuilder(Object item) {
+                return request;
+            }
+        };
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
+        Iterable<Integer> expected = Arrays.asList(20, 21, 10, 11, 20, 21, 10, 11);
+
+        preloader.onScroll(null, 3, 2, 3 + 2);
+        preloader.onScroll(null, 2, 2, 3 + 2);
 
-        public ListPreloaderAdapter(int maxPreload) {
-            super(maxPreload);
+        List<Integer> allValues = getTagetsSizes(request, times(4));
+        assertEquals(expected, allValues);
+    }
+
+    private List<Integer> getTagetsSizes(BitmapRequestBuilder requestBuilder, VerificationMode callVerificationMode) {
+        ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
+        ArgumentCaptor<Target> targetArgumentCaptor = ArgumentCaptor.forClass(Target.class);
+        SizeReadyCallback cb = mock(SizeReadyCallback.class);
+        VerificationMode mode = atLeastOnce();
+        verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
+        for (Target target : targetArgumentCaptor.getAllValues()) {
+            target.getSize(cb);
         }
+        verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
+        return integerArgumentCaptor.getAllValues();
+    }
 
-        @Override
-        protected int[] getDimensions(Object item) {
-            return new int[] { 100, 100 };
+    @Test
+    public void testItemsArePreloadedWithGlide() {
+        final List<Object> objects = new ArrayList<Object>();
+        objects.add(new Object());
+        objects.add(new Object());
+        final HashSet<Object> loadedObjects = new HashSet<Object>();
+        ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+            @Override
+            public List<Object> getPreloadItems(int position) {
+                return objects.subList(position - 11, position - 10);
+            }
+
+            @Override
+            public GenericRequestBuilder getPreloadRequestBuilder(Object item) {
+                loadedObjects.add(item);
+                return super.getPreloadRequestBuilder(item);
+            }
+        };
+        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);
+
+        preloader.onScroll(null, 1, 10, 13);
+        assertThat(loadedObjects).containsAllIn(objects);
+    }
+
+    private static class ListPreloaderAdapter implements ListPreloader.PreloadModelProvider<Object>,
+            ListPreloader.PreloadSizeProvider<Object> {
+
+        public ListPreloaderAdapter() {
         }
 
         @Override
-        protected List<Object> getItems(int start, int end) {
-            ArrayList<Object> result = new ArrayList<Object>(end - start);
+        public List<Object> getPreloadItems(int position) {
+            ArrayList<Object> result = new ArrayList<Object>(1);
             Collections.fill(result, new Object());
             return result;
         }
 
         @Override
-        protected GenericRequestBuilder getRequestBuilder(Object item) {
+        public GenericRequestBuilder getPreloadRequestBuilder(Object item) {
             return mock(BitmapRequestBuilder.class);
         }
+
+        @Override
+        public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+            return new int[]{100, 100};
+        }
     }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
index c4e681b62..911818fc1 100644
--- a/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
@@ -1,5 +1,15 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.net.Uri;
@@ -14,6 +24,7 @@
 import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
@@ -31,18 +42,8 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 
-import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = GlideShadowLooper.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerTest {
     private RequestManager manager;
     private ConnectivityMonitor connectivityMonitor;
@@ -50,6 +51,7 @@
     private ConnectivityListener connectivityListener;
     private RequestManager.DefaultOptions options;
     private Lifecycle lifecycle = mock(Lifecycle.class);
+    private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
 
     @Before
     public void setUp() {
@@ -64,7 +66,8 @@ public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable
                     }
                 });
         requestTracker = mock(RequestTracker.class);
-        manager = new RequestManager(Robolectric.application, lifecycle, requestTracker, factory);
+        manager =
+            new RequestManager(Robolectric.application, lifecycle, treeNode, requestTracker, factory);
         options = mock(RequestManager.DefaultOptions.class);
         manager.setDefaultOptions(options);
     }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java
index adcb410d1..9f263be41 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -1,10 +1,5 @@
 package com.bumptech.glide.load;
 
-import com.bumptech.glide.load.engine.Resource;
-import org.junit.Test;
-
-import java.util.ArrayList;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
@@ -14,6 +9,15 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.load.engine.Resource;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.ArrayList;
+
+@RunWith(JUnit4.class)
 public class MultiTransformationTest {
     @Test
     public void testReturnsConcatenatedTransformationIds() {
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
new file mode 100644
index 000000000..159c8f96e
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
@@ -0,0 +1,72 @@
+package com.bumptech.glide.load.data;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.AssetFileDescriptor;
+import android.content.res.AssetManager;
+import android.os.ParcelFileDescriptor;
+
+import com.bumptech.glide.Priority;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class FileDescriptorAssetPathFetcherTest {
+    private FileDescriptorAssetPathFetcher fetcher;
+    private ParcelFileDescriptor expected;
+    private String assetPath;
+
+    @Before
+    public void setUp() throws IOException {
+        AssetManager assetManager = mock(AssetManager.class);
+        assetPath = "/some/asset/path";
+        fetcher = new FileDescriptorAssetPathFetcher(assetManager, assetPath);
+        expected = mock(ParcelFileDescriptor.class);
+        AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
+        when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(expected);
+        when(assetManager.openFd(eq(assetPath))).thenReturn(assetFileDescriptor);
+    }
+
+    @Test
+    public void testOpensInputStreamForPathWithAssetManager() throws Exception {
+        assertEquals(expected, fetcher.loadData(Priority.NORMAL));
+    }
+
+    @Test
+    public void testClosesOpenedInputStreamOnCleanup() throws Exception {
+        fetcher.loadData(Priority.NORMAL);
+        fetcher.cleanup();
+
+        verify(expected).close();
+    }
+
+    @Test
+    public void testReturnsAssetPathAsId() {
+        assertEquals(assetPath, fetcher.getId());
+    }
+
+    @Test
+    public void testDoesNothingOnCleanupIfNoDataLoaded() throws IOException {
+        fetcher.cleanup();
+        verify(expected, never()).close();
+    }
+
+    @Test
+    public void testDoesNothingOnCancel() throws Exception {
+        fetcher.loadData(Priority.NORMAL);
+        fetcher.cancel();
+        verify(expected, never()).close();
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index c9067244b..b4f83fe44 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -1,36 +1,42 @@
 package com.bumptech.glide.load.data;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.Headers;
+import com.bumptech.glide.testutil.TestUtil;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
 import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.containsString;
-import static org.hamcrest.Matchers.endsWith;
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.fail;
-
 /**
  * Tests {@link com.bumptech.glide.load.data.HttpUrlFetcher} against server responses. Tests for behavior
  * (connection/disconnection/options) should go in {@link com.bumptech.glide.load.data.HttpUrlFetcherTest}, response
  * handling should go here.
  */
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class HttpUrlFetcherServerTest {
     private static final String DEFAULT_PATH = "/fakepath";
 
@@ -59,7 +65,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
                 .setResponseCode(200));
         HttpUrlFetcher fetcher = getFetcher();
         InputStream is = fetcher.loadData(Priority.HIGH);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
     }
 
     @Test
@@ -72,7 +78,7 @@ public void testHandlesRedirect301s() throws Exception {
             .setResponseCode(200)
             .setBody(expected));
         InputStream is = getFetcher().loadData(Priority.LOW);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
     }
 
     @Test
@@ -85,7 +91,7 @@ public void testHandlesRedirect302s() throws Exception {
             .setResponseCode(200)
             .setBody(expected));
         InputStream is = getFetcher().loadData(Priority.LOW);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
     }
 
     @Test
@@ -98,11 +104,11 @@ public void testHandlesRelativeRedirects() throws Exception {
             .setResponseCode(200)
             .setBody(expected));
         InputStream is = getFetcher().loadData(Priority.NORMAL);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
 
         mockWebServer.takeRequest();
         RecordedRequest second = mockWebServer.takeRequest();
-        assertThat(second.getPath(), endsWith("/redirect"));
+        assertThat(second.getPath()).endsWith("/redirect");
     }
 
     @Test
@@ -119,11 +125,11 @@ public void testHandlesUpToFiveRedirects() throws Exception {
             .setResponseCode(200).setBody(expected));
 
         InputStream is = getFetcher().loadData(Priority.NORMAL);
-        assertThat(isToString(is), equalTo(expected));
+        assertEquals(expected, TestUtil.isToString(is));
 
-        assertThat(mockWebServer.takeRequest().getPath(), containsString(DEFAULT_PATH));
+        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
         for (int i = 0; i < numRedirects; i++) {
-            assertThat(mockWebServer.takeRequest().getPath(), containsString(redirectBase + i));
+            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
         }
     }
 
@@ -209,18 +215,27 @@ public void testSetsReadTimeout() throws Exception {
         }
     }
 
+    @Test
+    public void testAppliesHeadersInGlideUrl() throws Exception {
+      mockWebServer.enqueue(new MockResponse().setResponseCode(200));
+      String headerField = "field";
+      String headerValue = "value";
+      Map<String, String> headersMap = new HashMap<String, String>();
+      headersMap.put(headerField, headerValue);
+      Headers headers = mock(Headers.class);
+      when(headers.getHeaders()).thenReturn(headersMap);
+
+      getFetcher(headers).loadData(Priority.HIGH);
+
+      assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
+    }
+
     private HttpUrlFetcher getFetcher() {
-        URL url = mockWebServer.getUrl(DEFAULT_PATH);
-        return new HttpUrlFetcher(new GlideUrl(url));
+        return getFetcher(Headers.NONE);
     }
 
-    private static String isToString(InputStream is) throws IOException {
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        byte[] buffer = new byte[1024];
-        int read;
-        while ((read = is.read(buffer)) != -1) {
-            os.write(buffer, 0, read);
-        }
-        return new String(os.toByteArray());
+    private HttpUrlFetcher getFetcher(Headers headers) {
+        URL url = mockWebServer.getUrl(DEFAULT_PATH);
+        return new HttpUrlFetcher(new GlideUrl(url, headers));
     }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 72646bd6f..49066f823 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -1,9 +1,21 @@
 package com.bumptech.glide.load.data;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.model.GlideUrl;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
 
 import java.io.ByteArrayInputStream;
@@ -12,15 +24,7 @@
 import java.net.HttpURLConnection;
 import java.net.URL;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class HttpUrlFetcherTest {
     private HttpURLConnection urlConnection;
     private HttpUrlFetcher fetcher;
@@ -45,7 +49,7 @@ public void setUp() throws IOException {
     @Test
     public void testReturnsModelAsString() {
         final String expected = "fakeId";
-        when(glideUrl.toString()).thenReturn(expected);
+        when(glideUrl.getCacheKey()).thenReturn(expected);
         assertEquals(expected, fetcher.getId());
     }
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index af7d5aae2..e5555cb2b 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -1,25 +1,29 @@
 package com.bumptech.glide.load.data;
 
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
+
 import com.bumptech.glide.Priority;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.Closeable;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class LocalUriFetcherTest {
     private TestLocalUriFetcher fetcher;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java
index 588a9d3b2..325f3fc4c 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java
@@ -1,28 +1,31 @@
 package com.bumptech.glide.load.data;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.net.Uri;
 import android.provider.MediaStore;
+
 import com.bumptech.glide.Priority;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class MediaStoreThumbFetcherTest {
     private Harness harness;
 
@@ -88,7 +91,7 @@ public void testDoesNotThrowIfCleanupWithNullInputStream() {
     @Test
     public void testContainsAllRelevantPartsInId() {
         String id = harness.get().getId();
-        assertThat(id, containsString(harness.uri.toString()));
+        assertThat(id).contains(harness.uri.toString());
     }
 
     @SuppressWarnings("unchecked")
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
new file mode 100644
index 000000000..cf768eb65
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
@@ -0,0 +1,69 @@
+package com.bumptech.glide.load.data;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.AssetManager;
+
+import com.bumptech.glide.Priority;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class StreamAssetPathFetcherTest {
+    private StreamAssetPathFetcher fetcher;
+    private InputStream expected;
+    private String assetPath;
+
+    @Before
+    public void setUp() throws IOException {
+        AssetManager assetManager = mock(AssetManager.class);
+        assetPath = "/some/asset/path";
+        fetcher = new StreamAssetPathFetcher(assetManager, assetPath);
+        expected = mock(InputStream.class);
+        when(assetManager.open(eq(assetPath))).thenReturn(expected);
+    }
+
+    @Test
+    public void testOpensInputStreamForPathWithAssetManager() throws Exception {
+        assertEquals(expected, fetcher.loadData(Priority.NORMAL));
+    }
+
+    @Test
+    public void testClosesOpenedInputStreamOnCleanup() throws Exception {
+        fetcher.loadData(Priority.NORMAL);
+        fetcher.cleanup();
+
+        verify(expected).close();
+    }
+
+    @Test
+    public void testReturnsAssetPathAsId() {
+        assertEquals(assetPath, fetcher.getId());
+    }
+
+    @Test
+    public void testDoesNothingOnCleanupIfNoDataLoaded() throws IOException {
+        fetcher.cleanup();
+        verify(expected, never()).close();
+    }
+
+    @Test
+    public void testDoesNothingOnCancel() throws Exception {
+        fetcher.loadData(Priority.NORMAL);
+        fetcher.cancel();
+        verify(expected, never()).close();
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerFactoryTest.java
index 417e54c29..200b1fcf5 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerFactoryTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerFactoryTest.java
@@ -1,16 +1,19 @@
 package com.bumptech.glide.load.data;
 
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
 import android.net.Uri;
 import android.provider.MediaStore;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ThumbnailStreamOpenerFactoryTest {
     private MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory factory;
     private Uri uri;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java
index e26709b45..2ddadbd9a 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java
@@ -1,13 +1,23 @@
 package com.bumptech.glide.load.data;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.provider.MediaStore;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import org.robolectric.tester.android.database.SimpleTestCursor;
 import org.robolectric.tester.android.database.TestCursor;
 
@@ -16,15 +26,8 @@
 import java.io.FileNotFoundException;
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ThumbnailStreamOpenerTest {
     private Harness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java
index b0167308a..fb51d33a1 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java
@@ -1,13 +1,17 @@
 package com.bumptech.glide.load.data.resource;
 
+import static org.junit.Assert.assertEquals;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.ByteArrayFetcher;
+
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-
+@RunWith(JUnit4.class)
 public class ByteArrayFetcherTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index 86804a039..8ce7a540c 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -1,25 +1,27 @@
 package com.bumptech.glide.load.data.resource;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.tests.ContentResolverShadow;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = { ContentResolverShadow.class })
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { ContentResolverShadow.class })
 public class FileDescriptorLocalUriFetcherTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index 2c73889fa..150607b3f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -1,20 +1,24 @@
 package com.bumptech.glide.load.data.resource;
 
+import static org.junit.Assert.assertNotNull;
+
 import android.content.Context;
 import android.graphics.BitmapFactory;
 import android.net.Uri;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.InputStream;
 
-import static org.junit.Assert.assertNotNull;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class StreamLocalUriFetcherTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java
index bed8d7619..aac4e5d2f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java
@@ -1,5 +1,14 @@
 package com.bumptech.glide.load.engine;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.cache.DiskCache;
@@ -8,20 +17,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.File;
 import java.io.IOException;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class CacheLoaderTest {
     private DiskCache diskCache;
     private CacheLoader cacheLoader;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java
index 4c84857c1..b8b3e5b11 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java
@@ -1,5 +1,18 @@
 package com.bumptech.glide.load.engine;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -10,39 +23,30 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.provider.DataLoadProvider;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Arrays;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class DecodeJobTest {
 
     private Harness harness;
 
     @Before
-    public void setUp() {
+    public void setUp() throws FileNotFoundException {
         harness = new Harness();
     }
 
@@ -585,6 +589,7 @@ public void testReturnsNullFromDecodeSourceIfTranscoderReturnsNull() throws Exce
         Transformation<Object> transformation = mock(Transformation.class);
         ResourceTranscoder<Object, Object> transcoder = mock(ResourceTranscoder.class);
         DiskCache diskCache = mock(DiskCache.class);
+        DecodeJob.DiskCacheProvider diskCacheProvider = mock(DecodeJob.DiskCacheProvider.class);
         Priority priority = Priority.IMMEDIATE;
 
         ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
@@ -592,15 +597,17 @@ public void testReturnsNullFromDecodeSourceIfTranscoderReturnsNull() throws Exce
         ResourceEncoder<Object> resultEncoder = mock(ResourceEncoder.class);
         ResourceDecoder<Object, Object> sourceDecoder = mock(ResourceDecoder.class);
         Encoder<Object> sourceEncoder = mock(Encoder.class);
+        DecodeJob.FileOpener fileOpener = mock(DecodeJob.FileOpener.class);
 
         DiskCacheStrategy diskCacheStrategy;
 
-        public Harness() {
+        public Harness() throws FileNotFoundException {
             this(DiskCacheStrategy.RESULT);
         }
 
-        public Harness(DiskCacheStrategy diskCacheStrategy) {
+        public Harness(DiskCacheStrategy diskCacheStrategy) throws FileNotFoundException {
             this.diskCacheStrategy = diskCacheStrategy;
+            when(fileOpener.open(any(File.class))).thenReturn(mock(OutputStream.class));
             when(key.getOriginalKey()).thenReturn(originalKey);
             when(transcoder.transcode(eq(resource))).thenReturn(resource);
             when(transformation.transform(eq(resource), eq(width), eq(height))).thenReturn(resource);
@@ -608,11 +615,12 @@ public Harness(DiskCacheStrategy diskCacheStrategy) {
             when(loadProvider.getEncoder()).thenReturn(resultEncoder);
             when(loadProvider.getSourceDecoder()).thenReturn(sourceDecoder);
             when(loadProvider.getSourceEncoder()).thenReturn(sourceEncoder);
+            when(diskCacheProvider.getDiskCache()).thenReturn(diskCache);
         }
 
         public DecodeJob<Object, Object, Object> getJob() {
             return new DecodeJob<Object, Object, Object>(key, width, height, dataFetcher, loadProvider, transformation,
-                    transcoder, diskCache, diskCacheStrategy, priority);
+                    transcoder, diskCacheProvider, diskCacheStrategy, priority, fileOpener);
         }
     }
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java
index c61801f5a..eb9dec3c3 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -1,8 +1,23 @@
 package com.bumptech.glide.load.engine;
 
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.os.Handler;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.request.ResourceCallback;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -11,6 +26,7 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLooper;
 
 import java.util.ArrayList;
@@ -19,20 +35,8 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class EngineJobTest {
     private EngineJobHarness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java
index a8ef97703..a9a13f6e5 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -1,5 +1,11 @@
 package com.bumptech.glide.load.engine;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -7,8 +13,11 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.tests.KeyAssertions;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -16,17 +25,12 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 /**
  * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object) equals}
  * and SHA-1 disk cache key are different on any difference in ID or existence of a certain workflow part.
  * Also checking whether the equals method is symmetric.
  */
+@RunWith(JUnit4.class)
 public class EngineKeyTest {
     private Harness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index b9d4ef501..465001f5a 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -1,11 +1,5 @@
 package com.bumptech.glide.load.engine;
 
-import com.bumptech.glide.load.Key;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -15,7 +9,16 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.load.Key;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class EngineResourceTest {
     private EngineResource<Object> engineResource;
     private EngineResource.ResourceListener listener;
@@ -136,6 +139,11 @@ public void testThrowsIfReleasedMoreThanAcquired() {
         engineResource.release();
     }
 
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfWrappedResourceIsNull() {
+        new EngineResource<Object>(null, false);
+    }
+
     @Test
     public void testCanSetAndGetIsCacheable() {
         engineResource = new EngineResource<Object>(mock(Resource.class), true);
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineRunnableTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineRunnableTest.java
index 95116d25d..31f0bae1f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineRunnableTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineRunnableTest.java
@@ -1,14 +1,5 @@
 package com.bumptech.glide.load.engine;
 
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.request.ResourceCallback;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
@@ -18,7 +9,19 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.request.ResourceCallback;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class EngineRunnableTest {
 
     private EngineRunnable.EngineRunnableManager manager;
@@ -194,4 +197,35 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
         verify(manager, never()).onException(any(Exception.class));
     }
+
+    @Test
+    public void testDoesNotNotifyManagerOfSuccessIfCancelled() throws Exception {
+        runnable.run();
+        when(job.decodeFromSource()).thenAnswer(new Answer<Object>() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                runnable.cancel();
+                return mock(Resource.class);
+            }
+        });
+        runnable.run();
+
+        verify(manager, never()).onResourceReady(any(Resource.class));
+    }
+
+    @Test
+    public void testRecyclesResourceIfAvailableWhenCancelled() throws Exception {
+        final Resource resource = mock(Resource.class);
+        runnable.run();
+        when(job.decodeFromSource()).thenAnswer(new Answer<Object>() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                runnable.cancel();
+                return resource;
+            }
+        });
+        runnable.run();
+
+        verify(resource).recycle();
+    }
 }
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java
index 81abfc6cc..845c32930 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -1,6 +1,21 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Looper;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -15,15 +30,14 @@
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLooper;
 
 import java.io.File;
 import java.lang.ref.WeakReference;
@@ -31,28 +45,8 @@
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
 
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasEntry;
-import static org.hamcrest.Matchers.hasKey;
-import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = { GlideShadowLooper.class })
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { GlideShadowLooper.class })
 public class EngineTest {
     private static final String ID = "asdf";
     private EngineTestHarness harness;
@@ -93,7 +87,7 @@ public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
     public void testNewRunnerIsAddedToRunnersMap() {
         harness.doLoad();
 
-        assertThat(harness.jobs, hasKey((Key) harness.cacheKey));
+        assertThat(harness.jobs).containsKey(harness.cacheKey);
     }
 
     @Test
@@ -148,7 +142,7 @@ public void testKeyIsRemovedFromActiveResourcesIfRefIsCleared() {
 
         harness.doLoad();
 
-        assertThat(harness.activeResources, not(hasKey((Key) harness.cacheKey)));
+        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
     }
 
     @Test
@@ -189,7 +183,18 @@ public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
     }
 
     @Test
-    public void testCacheIsChecked() {
+    public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
+        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
+
+        harness.isMemoryCacheable = false;
+        harness.doLoad();
+
+        verify(harness.resource, never()).acquire();
+        verify(harness.job).start(any(EngineRunnable.class));
+    }
+
+    @Test
+    public void testCacheIsCheckedIfMemoryCacheable() {
         when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
 
         harness.doLoad();
@@ -197,6 +202,16 @@ public void testCacheIsChecked() {
         verify(harness.cb).onResourceReady(eq(harness.resource));
     }
 
+    @Test
+    public void testCacheIsNotCheckedIfNotMemoryCacheable() {
+        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+        harness.isMemoryCacheable = false;
+        harness.doLoad();
+
+        verify(harness.job).start(any(EngineRunnable.class));
+    }
+
     @Test
     public void testResourceIsReturnedFromCacheIfPresent() {
         when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
@@ -206,7 +221,6 @@ public void testResourceIsReturnedFromCacheIfPresent() {
         verify(harness.cb).onResourceReady(eq(harness.resource));
     }
 
-
     @Test
     public void testHandlesNonEngineResourcesFromCacheIfPresent() {
         final Object expected = new Object();
@@ -270,7 +284,7 @@ public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
 
         harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
 
-        assertThat(harness.jobs, not(hasKey((Key) harness.cacheKey)));
+        assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
     }
 
     @Test
@@ -291,6 +305,7 @@ public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete()
 
     @Test
     public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
+        when(harness.resource.isCacheable()).thenReturn(true);
         harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
 
         WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
@@ -300,7 +315,14 @@ public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
     @Test
     public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
         harness.engine.onEngineJobComplete(harness.cacheKey, null);
-        assertThat(harness.activeResources, not(hasKey((Key) harness.cacheKey)));
+        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
+    }
+
+    @Test
+    public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
+        when(harness.resource.isCacheable()).thenReturn(false);
+        harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
+        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
     }
 
     @Test
@@ -309,10 +331,9 @@ public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
 
         harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);
 
-        assertThat(harness.jobs, not(hasKey((Key) harness.cacheKey)));
+        assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
     }
 
-
     @Test
     public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
         harness.doLoad();
@@ -352,13 +373,9 @@ public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
 
     @Test
     public void testResourceIsRecycledIfNotCacheableWhenReleased() {
-        ShadowLooper shadowLooper = Robolectric.shadowOf(Looper.getMainLooper());
         when(harness.resource.isCacheable()).thenReturn(false);
-        shadowLooper.pause();
         harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-        verify(harness.resource, never()).recycle();
-        shadowLooper.runOneTask();
-        verify(harness.resource).recycle();
+        verify(harness.resourceRecycler).recycle(eq(harness.resource));
     }
 
     @Test
@@ -367,7 +384,7 @@ public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
 
         harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
 
-        assertThat(harness.activeResources, not(hasKey((Key) harness.cacheKey)));
+        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
     }
 
     @Test
@@ -377,20 +394,15 @@ public void testEngineAddedAsListenerToMemoryCache() {
 
     @Test
     public void testResourceIsRecycledWhenRemovedFromCache() {
-        ShadowLooper shadowLooper = Robolectric.shadowOf(Looper.getMainLooper());
-        shadowLooper.pause();
         harness.engine.onResourceRemoved(harness.resource);
-        // We expect the release to be posted
-        verify(harness.resource, never()).recycle();
-        shadowLooper.runOneTask();
-        verify(harness.resource).recycle();
+        verify(harness.resourceRecycler).recycle(eq(harness.resource));
     }
 
     @Test
     public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
         harness.doLoad();
 
-        assertThat(harness.jobs, hasEntry(equalTo((Key) harness.cacheKey), equalTo(harness.job)));
+        assertThat(harness.jobs).containsEntry(harness.cacheKey, harness.job);
     }
 
     @Test
@@ -402,7 +414,6 @@ public void testKeyFactoryIsGivenNecessaryArguments() {
                 eq(harness.transcoder), eq(harness.sourceEncoder));
     }
 
-
     @Test
     public void testFactoryIsGivenNecessaryArguments() {
         harness.doLoad();
@@ -410,6 +421,18 @@ public void testFactoryIsGivenNecessaryArguments() {
         verify(harness.engineJobFactory).build(eq(harness.cacheKey), eq(harness.isMemoryCacheable));
     }
 
+    @Test
+    public void testReleaseReleasesEngineResource() {
+        EngineResource<Object> engineResource = mock(EngineResource.class);
+        harness.engine.release(engineResource);
+        verify(engineResource).release();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsIfAskedToReleaseNonEngineResource() {
+        harness.engine.release(mock(Resource.class));
+    }
+
     @Test(expected = RuntimeException.class)
     public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
         BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
@@ -446,9 +469,10 @@ public void runTest() throws Exception {
         MemoryCache cache = mock(MemoryCache.class);
         EngineJob job;
         Engine engine;
-        boolean isMemoryCacheable;
+        boolean isMemoryCacheable = true;
         Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
         DataLoadProvider<Object, Object> loadProvider = mock(DataLoadProvider.class);
+        ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
 
         public EngineTestHarness() {
             when(loadProvider.getCacheDecoder()).thenReturn(cacheDecoder);
@@ -463,13 +487,13 @@ public EngineTestHarness() {
 
             job = mock(EngineJob.class);
 
-            engine = new Engine(cache, mock(DiskCache.class), mock(ExecutorService.class),
-                    mock(ExecutorService.class), jobs, keyFactory, activeResources, engineJobFactory);
+            engine = new Engine(cache, mock(DiskCache.Factory.class), mock(ExecutorService.class),
+                    mock(ExecutorService.class), jobs, keyFactory, activeResources, engineJobFactory, resourceRecycler);
 
-            when(engineJobFactory.build(eq(cacheKey), eq(isMemoryCacheable))).thenReturn(job);
         }
 
         public Engine.LoadStatus doLoad() {
+            when(engineJobFactory.build(eq(cacheKey), eq(isMemoryCacheable))).thenReturn(job);
             return engine.load(signature, width, height, fetcher, loadProvider, transformation, transcoder, priority,
                     isMemoryCacheable, diskCacheStrategy, cb);
         }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/OriginalKeyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/OriginalKeyTest.java
index c16bbcc02..1d7ac4dbd 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/OriginalKeyTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/OriginalKeyTest.java
@@ -1,8 +1,15 @@
 package com.bumptech.glide.load.engine;
 
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.KeyAssertions;
+
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -10,10 +17,7 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
+@RunWith(JUnit4.class)
 public class OriginalKeyTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
new file mode 100644
index 000000000..15ae73647
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.os.Looper;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class ResourceRecyclerTest {
+
+    private ResourceRecycler recycler;
+
+    @Before
+    public void setUp() {
+        recycler = new ResourceRecycler();
+    }
+
+    @Test
+    public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
+        Resource resource = mock(Resource.class);
+        Robolectric.shadowOf(Looper.getMainLooper()).pause();
+        recycler.recycle(resource);
+        verify(resource).recycle();
+    }
+
+    @Test
+    public void testDoesNotRecycleChildResourceSynchronously() {
+        Resource parent = mock(Resource.class);
+        final Resource child = mock(Resource.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                recycler.recycle(child);
+                return null;
+            }
+        }).when(parent).recycle();
+
+        Robolectric.shadowOf(Looper.getMainLooper()).pause();
+
+        recycler.recycle(parent);
+
+        verify(parent).recycle();
+        verify(child, never()).recycle();
+
+        Robolectric.shadowOf(Looper.getMainLooper()).runOneTask();
+
+        verify(child).recycle();
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
new file mode 100644
index 000000000..946778efc
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import com.google.common.testing.EqualsTester;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.AttributeStrategy.Key;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class AttributeStrategyKeyTest {
+
+    private AttributeStrategy.KeyPool keyPool;
+
+    @Before
+    public void setUp() {
+        keyPool = mock(AttributeStrategy.KeyPool.class);
+    }
+
+    @Test
+    public void testEquality() {
+        Key first = new Key(keyPool);
+        first.init(100, 100, Bitmap.Config.ARGB_4444);
+        Key second = new Key(keyPool);
+        second.init(100, 100, Bitmap.Config.ARGB_4444);
+
+        Key third = new Key(keyPool);
+        third.init(200, 100, Bitmap.Config.ARGB_4444);
+
+        Key fourth = new Key(keyPool);
+        fourth.init(100, 200, Bitmap.Config.ARGB_4444);
+
+        Key fifth = new Key(keyPool);
+        fifth.init(100, 100, Bitmap.Config.RGB_565);
+
+        new EqualsTester()
+                .addEqualityGroup(first, second)
+                .addEqualityGroup(third)
+                .addEqualityGroup(fourth)
+                .addEqualityGroup(fifth)
+                .testEquals();
+    }
+
+    @Test
+    public void testReturnsSelfToPoolOnOffer() {
+        Key key = new Key(keyPool);
+        key.offer();
+
+        verify(keyPool).offer(eq(key));
+    }
+
+    @Test
+    public void testInitSetsAttributes() {
+        Key key = new Key(keyPool);
+        key.init(100, 100, Bitmap.Config.ARGB_4444);
+
+        Key other = new Key(keyPool);
+        other.init(200, 200, Bitmap.Config.RGB_565);
+
+        assertNotEquals(key, other);
+
+        key.init(200, 200, Bitmap.Config.RGB_565);
+
+        assertEquals(key, other);
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
index ee956d391..7f5ec1f86 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -1,16 +1,19 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
 import android.graphics.Bitmap;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowBitmap;
 
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertEquals;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class AttributeStrategyTest {
 
     private AttributeStrategy strategy;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
new file mode 100644
index 000000000..84b360c63
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
@@ -0,0 +1,121 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class GroupedLinkedMapTest {
+
+    private GroupedLinkedMap<Key, Object> map;
+
+    @Before
+    public void setUp() {
+        map = new GroupedLinkedMap<Key, Object>();
+    }
+
+    @Test
+    public void testReturnsNullForGetWithNoBitmap() {
+        assertNull(map.get(mock(Key.class)));
+    }
+
+    @Test
+    public void testCanAddAndRemoveABitmap() {
+        Key key = new Key("key", 1, 1);
+        Object expected = new Object();
+
+        map.put(key, expected);
+
+        assertThat(map.get(key)).isEqualTo(expected);
+    }
+
+    @Test
+    public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
+        Key key = new Key("key", 1, 1);
+        Integer value = 20;
+
+        int numToAdd = 10;
+
+        for (int i = 0; i < numToAdd; i++) {
+            map.put(key, new Integer(value));
+        }
+
+        for (int i = 0; i < numToAdd; i++) {
+            assertThat(map.get(key)).isEqualTo(value);
+        }
+    }
+
+    @Test
+    public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
+        Key firstKey = new Key("key", 1, 1);
+        Integer firstValue = 10;
+        map.put(firstKey, firstValue);
+        map.put(firstKey, new Integer(firstValue));
+
+        Key secondKey = new Key("key", 2, 2);
+        Integer secondValue = 20;
+        map.put(secondKey, secondValue);
+
+        map.get(firstKey);
+
+        assertThat(map.removeLast()).isEqualTo(secondValue);
+    }
+
+    @Test
+    public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
+        Key firstKey = new Key("key", 1, 1);
+        Integer firstValue = 10;
+
+        map.put(firstKey, firstValue);
+        map.put(firstKey, new Integer(firstValue));
+
+        map.get(firstKey);
+
+        Integer secondValue = 20;
+        map.put(new Key("key", 2, 2), secondValue);
+
+        assertThat(map.removeLast()).isEqualTo(secondValue);
+    }
+
+    private static class Key implements Poolable {
+
+        private final String key;
+        private final int width;
+        private final int height;
+
+        public Key(String key, int width, int height) {
+            this.key = key;
+            this.width = width;
+            this.height = height;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof Key) {
+                Key other = (Key) o;
+                return key.equals(other.key) && width == other.width && height == other.height;
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = key != null ? key.hashCode() : 0;
+            result = 31 * result + width;
+            result = 31 * result + height;
+            return result;
+        }
+
+        @Override
+        public void offer() {
+            // Do nothing.
+        }
+    }
+}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index aa8dd8873..0f2386217 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -1,36 +1,45 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
+import static com.google.common.truth.Truth.assertThat;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowBitmap;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
-import static org.hamcrest.Matchers.empty;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
+import java.util.Set;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class LruBitmapPoolTest {
     private static final int MAX_SIZE = 10;
+    private static final Set<Bitmap.Config> ALLOWED_CONFIGS = Collections.singleton(Bitmap.Config.ARGB_8888);
     private MockStrategy strategy;
     private LruBitmapPool pool;
 
     @Before
     public void setUp() throws Exception {
         strategy = new MockStrategy();
-        pool = new LruBitmapPool(MAX_SIZE, strategy);
+        pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);
     }
 
     @Test
@@ -45,7 +54,7 @@ public void testImmutableBitmapsAreNotAdded() {
         Bitmap bitmap = createMutableBitmap();
         Robolectric.shadowOf(bitmap).setMutable(false);
         pool.put(bitmap);
-        assertThat(strategy.bitmaps, empty());
+        assertThat(strategy.bitmaps).isEmpty();
     }
 
     @Test
@@ -62,7 +71,7 @@ public int getSize(Bitmap bitmap) {
                 return 4;
             }
         };
-        pool = new LruBitmapPool(3, strategy);
+        pool = new LruBitmapPool(3, strategy, ALLOWED_CONFIGS);
         pool.put(createMutableBitmap());
         assertEquals(0, strategy.numRemoves);
         assertEquals(0, strategy.numPuts);
@@ -108,9 +117,33 @@ public void testTrimMemoryModerateOrGreaterRemovesAllBitmaps() {
         }
     }
 
+    @Test
+    public void testPassesArgb888ToStrategyAsConfigForRequestsWithNullConfigsOnGet() {
+        LruPoolStrategy strategy = mock(LruPoolStrategy.class);
+        LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);
+
+        Bitmap expected = createMutableBitmap();
+        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);
+        Bitmap result = pool.get(100, 100, null);
+
+        assertEquals(expected, result);
+    }
+
+    @Test
+    public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetDirty() {
+        LruPoolStrategy strategy = mock(LruPoolStrategy.class);
+        LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);
+
+        Bitmap expected = createMutableBitmap();
+        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);
+        Bitmap result = pool.getDirty(100, 100, null);
+
+        assertEquals(expected, result);
+    }
+
     private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
         MockStrategy strategy = new MockStrategy();
-        LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy);
+        LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);
         fillPool(pool, fillSize);
         pool.trimMemory(trimLevel);
         assertEquals("Failed level=" + trimLevel, expectedSize, strategy.numRemoves);
@@ -158,6 +191,28 @@ public void testMaxSizeChangesAfterSizeMultiplier() {
         assertEquals(2 * MAX_SIZE, pool.getMaxSize());
     }
 
+    @Test
+    public void testBitmapsWithDisallowedConfigsAreIgnored() {
+        pool = new LruBitmapPool(100, strategy, Collections.singleton(Bitmap.Config.ARGB_4444));
+
+        Bitmap bitmap = createMutableBitmap(Bitmap.Config.RGB_565);
+        pool.put(bitmap);
+
+        assertEquals(0, strategy.numPuts);
+    }
+
+    @Test
+    public void testBitmapsWithAllowedNullConfigsAreAllowed() {
+        pool = new LruBitmapPool(100, strategy, Collections.<Bitmap.Config>singleton(null));
+
+        Bitmap bitmap = createMutableBitmap();
+        Robolectric.shadowOf(bitmap).setConfig(null);
+
+        pool.put(bitmap);
+
+        assertEquals(1, strategy.numPuts);
+    }
+
     private void fillPool(LruBitmapPool pool, int fillCount) {
         for (int i = 0; i < fillCount; i++) {
             pool.put(createMutableBitmap());
@@ -165,9 +220,14 @@ private void fillPool(LruBitmapPool pool, int fillCount) {
     }
 
     private Bitmap createMutableBitmap() {
-        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        return createMutableBitmap(Bitmap.Config.ARGB_8888);
+    }
+
+    private Bitmap createMutableBitmap(Bitmap.Config config) {
+        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, config);
         Robolectric.shadowOf(bitmap).setMutable(true);
         return bitmap;
+
     }
 
     private static class MockStrategy implements LruPoolStrategy {
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
new file mode 100644
index 000000000..23da6135f
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import com.google.common.testing.EqualsTester;
+
+import android.graphics.Bitmap;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+public class SizeConfigStrategyTest {
+
+    @Mock SizeConfigStrategy.KeyPool pool;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+    }
+
+    @Test
+    public void testKeyEquals() {
+        new EqualsTester()
+                .addEqualityGroup(
+                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
+                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
+                )
+                .addEqualityGroup(
+                        new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888)
+                )
+                .addEqualityGroup(
+                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565)
+                )
+                .addEqualityGroup(
+                        new SizeConfigStrategy.Key(pool, 100, null /*config*/)
+                )
+                .testEquals();
+
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
new file mode 100644
index 000000000..2e3839284
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
@@ -0,0 +1,65 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import com.google.common.testing.EqualsTester;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.SizeStrategy.Key;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SizeStrategyKeyTest {
+
+    private SizeStrategy.KeyPool keyPool;
+
+    @Before
+    public void setUp() {
+        keyPool = mock(SizeStrategy.KeyPool.class);
+    }
+
+    @Test
+    public void testEquality() {
+        Key first = new Key(keyPool);
+        first.init(100);
+        Key second = new Key(keyPool);
+        second.init(100);
+        Key third = new Key(keyPool);
+        third.init(50);
+
+        new EqualsTester()
+                .addEqualityGroup(first, second)
+                .addEqualityGroup(third)
+                .testEquals();
+    }
+
+    @Test
+    public void testReturnsSelfToPoolOnOffer() {
+        Key key = new Key(keyPool);
+        key.offer();
+
+        verify(keyPool).offer(eq(key));
+    }
+
+    @Test
+    public void testInitSetsSize() {
+        Key key = new Key(keyPool);
+        key.init(100);
+
+        Key other = new Key(keyPool);
+        other.init(200);
+
+        assertNotEquals(key, other);
+
+        key.init(200);
+
+        assertEquals(key, other);
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index eab0d9f39..4e8e89eb9 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -1,5 +1,9 @@
 package com.bumptech.glide.load.engine.cache;
 
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.Util;
 
@@ -8,17 +12,15 @@
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class DiskLruCacheWrapperTest {
     private DiskLruCacheWrapper cache;
     private byte[] data;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/KeyGeneratorTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/KeyGeneratorTest.java
index c750cefd8..1f763b927 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/KeyGeneratorTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/KeyGeneratorTest.java
@@ -1,16 +1,20 @@
 package com.bumptech.glide.load.engine.cache;
 
+import static org.junit.Assert.assertTrue;
+
 import com.bumptech.glide.load.Key;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static org.junit.Assert.assertTrue;
-
+@RunWith(JUnit4.class)
 public class KeyGeneratorTest {
     private SafeKeyGenerator keyGenerator;
     private int nextId;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
index 60155e922..dd5428a7e 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -1,13 +1,9 @@
 package com.bumptech.glide.load.engine.cache;
 
-import com.bumptech.glide.util.LruCache;
-import org.junit.Before;
-import org.junit.Test;
-
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.assertFalse;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyObject;
 import static org.mockito.Matchers.eq;
@@ -17,6 +13,14 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.util.LruCache;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
 public class LruCacheTest {
     // 1MB
     private static final int SIZE = 2;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
index 752c03837..9a40b9616 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -1,13 +1,5 @@
 package com.bumptech.glide.load.engine.cache;
 
-import android.content.ComponentCallbacks2;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.Resource;
-import org.junit.Test;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-
 import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -17,6 +9,19 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.content.ComponentCallbacks2;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.Resource;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+
+@RunWith(JUnit4.class)
 public class LruResourceCacheTest {
     private static class TrimClearMemoryCacheHarness {
         LruResourceCache resourceCache = new LruResourceCache(100);
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 20b7f1233..bccc0bcee 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -1,23 +1,28 @@
 package com.bumptech.glide.load.engine.cache;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.Range;
+
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
+
+import com.bumptech.glide.tests.Util;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.Matchers.lessThan;
-import static org.hamcrest.Matchers.lessThanOrEqualTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class MemorySizeCalculatorTest {
     private MemorySizeHarness harness;
     private int initialSdkVersion;
@@ -30,11 +35,7 @@ public void setUp() {
 
     @After
     public void tearDown() {
-        setSdkVersionInt(initialSdkVersion);
-    }
-
-    private void setSdkVersionInt(int version) {
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", version);
+        Util.setSdkVersionInt(initialSdkVersion);
     }
 
     @Test
@@ -55,15 +56,16 @@ public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
 
         int memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
 
-        assertThat(memoryCacheSize, lessThanOrEqualTo(Math.round(memoryClassBytes * harness.sizeMultiplier)));
+        assertThat((float) memoryCacheSize).isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
     }
 
     @Test
-    public void testDefaultBitmapPoolSizeIsThreeTimesScreenSize() {
+    public void testDefaultBitmapPoolSize() {
         Robolectric.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());
 
         int bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
 
+//        assertThat(bitmapPoolSize).isIn(Range.open());
         assertEquals(harness.getScreenSize() * harness.bitmapPoolScreens, bitmapPoolSize);
     }
 
@@ -76,7 +78,7 @@ public void testDefaultBitmapPoolSizeIsLimitedByMemoryClass() {
 
         int bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
 
-        assertThat(bitmapPoolSize, lessThanOrEqualTo(Math.round(memoryClassBytes * harness.sizeMultiplier)));
+        assertThat((float) bitmapPoolSize).isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
     }
 
     @Test
@@ -88,13 +90,8 @@ public void testCumulativePoolAndMemoryCacheSizeAreLimitedByMemoryClass() {
         int memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
         int bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
 
-        String failHelpMessage =
-                  "memoryCacheSize: " + memoryCacheSize
-                + " bitmapPoolSize: " + bitmapPoolSize
-                + " memoryClass: "    + memoryCacheSize
-                + " sizeMultiplier: " + harness.sizeMultiplier;
-        assertThat(failHelpMessage, memoryCacheSize + bitmapPoolSize,
-                lessThanOrEqualTo(Math.round(memoryClassBytes * harness.sizeMultiplier)));
+        assertThat((float) memoryCacheSize + bitmapPoolSize).isIn(
+                Range.atMost(memoryClassBytes * harness.sizeMultiplier));
     }
 
     @Test
@@ -103,19 +100,21 @@ public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices()
         final int normalMemoryCacheSize = harness.getCalculator().getMemoryCacheSize();
         final int normalBitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
 
-        setSdkVersionInt(10);
+        Util.setSdkVersionInt(10);
 
         final int smallMemoryCacheSize = harness.getCalculator().getMemoryCacheSize();
         final int smallBitmapPoolSize = harness.getCalculator().getBitmapPoolSize();
 
-        assertThat(smallMemoryCacheSize, lessThan(normalMemoryCacheSize));
-        assertThat(smallBitmapPoolSize, lessThan(normalBitmapPoolSize));
+        assertThat(smallMemoryCacheSize).isLessThan(normalMemoryCacheSize);
+        assertThat(smallBitmapPoolSize).isLessThan(normalBitmapPoolSize);
     }
 
     private int getLargeEnoughMemoryClass() {
+        float totalScreenBytes = harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens);
         // Memory class is in mb, not bytes!
-        return Math.round(harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens)
-                * (1f / harness.sizeMultiplier) / (1024 * 1024));
+        float totalScreenMb = totalScreenBytes / (1024 * 1024);
+        float memoryClassMb = totalScreenMb / harness.sizeMultiplier;
+        return (int) Math.ceil(memoryClassMb);
     }
 
     private static class MemorySizeHarness {
@@ -131,7 +130,7 @@ private int getLargeEnoughMemoryClass() {
         public MemorySizeCalculator getCalculator() {
             when(screenDimensions.getWidthPixels()).thenReturn(pixelSize);
             when(screenDimensions.getHeightPixels()).thenReturn(pixelSize);
-            return new MemorySizeCalculator(activityManager, screenDimensions);
+            return new MemorySizeCalculator(Robolectric.application, activityManager, screenDimensions);
         }
 
         public int getScreenSize() {
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutorTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutorTest.java
index 0aaa7d7d4..484c8bcb3 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutorTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutorTest.java
@@ -1,20 +1,26 @@
 package com.bumptech.glide.load.engine.executor;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+
+import com.google.common.testing.EqualsTester;
+
+import com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor.LoadTask;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.hasSize;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class FifoPriorityThreadPoolExecutorTest {
 
     @Test
@@ -31,9 +37,10 @@ public void onRun(int priority) {
             }));
         }
 
-        executor.awaitTermination(200, TimeUnit.MILLISECONDS);
+        executor.shutdown();
+        executor.awaitTermination(500, TimeUnit.MILLISECONDS);
 
-        assertThat(resultPriorities, hasSize(numPrioritiesToTest));
+        assertThat(resultPriorities).hasSize(numPrioritiesToTest);
 
         // Since no jobs are queued, the first item added will be run immediately, regardless of priority.
         assertEquals(numPrioritiesToTest, resultPriorities.get(0).intValue());
@@ -46,11 +53,11 @@ public void onRun(int priority) {
     @Test
     public void testLoadsWithSamePriorityAreExecutedInSubmitOrder() throws InterruptedException {
         final int numItemsToTest = 10;
-        final Integer[] executionOrder = new Integer[numItemsToTest];
+        final List<Integer> executionOrder = new ArrayList<Integer>();
         final List<Integer> executedOrder = Collections.synchronizedList(new ArrayList<Integer>());
         FifoPriorityThreadPoolExecutor executor = new FifoPriorityThreadPoolExecutor(1);
         for (int i = 0; i < numItemsToTest; i++) {
-            executionOrder[i] = i;
+            executionOrder.add(i);
         }
         for (int i = 0; i < numItemsToTest; i++) {
             final int finalI = i;
@@ -64,7 +71,49 @@ public void onRun(int priority) {
         }
         executor.awaitTermination(200, TimeUnit.MILLISECONDS);
 
-        assertThat(executedOrder, contains(executionOrder));
+        assertThat(executedOrder).containsAllIn(executionOrder).inOrder();
+    }
+
+    @Test
+    public void testLoadTaskEquality() {
+        new EqualsTester()
+                .addEqualityGroup(
+                        new LoadTask<Object>(new MockRunnable(10), new Object(), 1),
+                        new LoadTask<Object>(new MockRunnable(10), new Object(), 1))
+                .addEqualityGroup(
+                        new LoadTask<Object>(new MockRunnable(5), new Object(), 1)
+                )
+                .addEqualityGroup(
+                        new LoadTask<Object>(new MockRunnable(10), new Object(), 3)
+                )
+                .testEquals();
+    }
+
+    @Test
+    public void testLoadTaskCompareToPrefersHigherPriority() {
+        LoadTask<Object> first = new LoadTask<Object>(new MockRunnable(10), new Object(), 10);
+        LoadTask<Object> second = new LoadTask<Object>(new MockRunnable(0), new Object(), 10);
+
+        assertTrue(first.compareTo(second) > 0);
+        assertTrue(second.compareTo(first) < 0);
+    }
+
+    @Test
+    public void testLoadTaskCompareToFallsBackToOrderIfPriorityIsEqual() {
+        LoadTask<Object> first = new LoadTask<Object>(new MockRunnable(0), new Object(), 2);
+        LoadTask<Object> second = new LoadTask<Object>(new MockRunnable(0), new Object(), 1);
+
+        assertTrue(first.compareTo(second) > 0);
+        assertTrue(second.compareTo(first) < 0);
+    }
+
+    @Test
+    public void testLoadTaskCompareToReturnsZeroIfPriorityAndOrderAreEqual() {
+        LoadTask<Object> first = new LoadTask<Object>(new MockRunnable(0), new Object(), 1);
+        LoadTask<Object> second = new LoadTask<Object>(new MockRunnable(0), new Object(), 1);
+
+        assertEquals(0, first.compareTo(second));
+        assertEquals(0, second.compareTo(first));
     }
 
     private static class MockRunnable implements Runnable, Prioritized {
@@ -75,6 +124,10 @@ public void onRun(int priority) {
             public void onRun(int priority);
         }
 
+        public MockRunnable(int priority) {
+            this(priority, mock(OnRun.class));
+        }
+
         public MockRunnable(int priority, OnRun onRun) {
             this.priority = priority;
             this.onRun = onRun;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
new file mode 100644
index 000000000..8b42ca182
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -0,0 +1,335 @@
+package com.bumptech.glide.load.engine.prefill;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.os.Handler;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.util.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class BitmapPreFillRunnerTest {
+    private BitmapPreFillRunner.Clock clock;
+    private BitmapPool pool;
+    private MemoryCache cache;
+    private List<Bitmap> addedBitmaps = new ArrayList<Bitmap>();
+    private Handler mainHandler;
+
+    @Before
+    public void setUp() {
+        clock = mock(BitmapPreFillRunner.Clock.class);
+
+        pool = mock(BitmapPool.class);
+        when(pool.put(any(Bitmap.class))).thenAnswer(new AddBitmapPoolAnswer(addedBitmaps));
+        cache = mock(MemoryCache.class);
+        when(cache.put(any(Key.class), any(Resource.class))).thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));
+        mainHandler = mock(Handler.class);
+    }
+
+    private BitmapPreFillRunner getHandler(Map<PreFillType, Integer> allocationOrder) {
+        return new BitmapPreFillRunner(pool, cache, new PreFillQueue(allocationOrder), clock, mainHandler);
+    }
+
+    @Test
+    public void testAllocatesABitmapPerSizeInAllocationOrder() {
+        PreFillType size = new PreFillType.Builder(100)
+                .setConfig(Bitmap.Config.ARGB_8888)
+                .build();
+        final int toAdd = 3;
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, toAdd);
+        BitmapPreFillRunner handler = getHandler(allocationOrder);
+        handler.run();
+
+        Bitmap expected = Bitmap.createBitmap(size.getWidth(), size.getHeight(), size.getConfig());
+        assertThat(addedBitmaps).containsExactly(expected, expected, expected);
+    }
+
+    @Test
+    public void testAllocatesBitmapsInOrderGivenByAllocationOrder() {
+        PreFillType smallWidth = new PreFillType.Builder(50, 100)
+                .setConfig(Bitmap.Config.ARGB_8888)
+                .build();
+        PreFillType smallHeight = new PreFillType.Builder(100, 50)
+                .setConfig(Bitmap.Config.RGB_565)
+                .build();
+
+        PreFillType[] expectedOrder = new PreFillType[] {
+                smallWidth,
+                smallHeight,
+                smallWidth,
+                smallHeight,
+        };
+
+        HashMap<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(smallWidth, 2);
+        allocationOrder.put(smallHeight, 2);
+        BitmapPreFillRunner handler = getHandler(allocationOrder);
+        handler.run();
+
+        Bitmap[] expectedBitmaps = new Bitmap[expectedOrder.length];
+        for (int i = 0; i < expectedBitmaps.length; i++) {
+            PreFillType current = expectedOrder[i];
+            expectedBitmaps[i] = Bitmap.createBitmap(current.getWidth(), current.getHeight(), current.getConfig());
+        }
+
+        Bitmap current = addedBitmaps.get(0);
+        for (int i = 1; i < addedBitmaps.size(); i++) {
+            assertNotEquals(current, addedBitmaps.get(i));
+            current = addedBitmaps.get(i);
+        }
+
+        assertThat(addedBitmaps).hasSize(4);
+    }
+
+    @Test
+    public void testStopsAllocatingBitmapsUntilNextIdleCallIfAllocationsTakeLongerThanLimit() {
+        PreFillType size = new PreFillType.Builder(1)
+                .setConfig(Bitmap.Config.ARGB_8888)
+                .build();
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, 3);
+        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+        BitmapPreFillRunner handler = getHandler(allocationOrder);
+        handler.run();
+
+        assertThat(addedBitmaps).hasSize(1);
+
+        handler.run();
+
+        assertThat(addedBitmaps).hasSize(3);
+    }
+
+    @Test
+    public void testPreFillHandlerDoesNotPostIfHasNoBitmapsToAllocate() {
+        BitmapPreFillRunner handler = getHandler(new HashMap<PreFillType, Integer>());
+        handler.run();
+        verify(mainHandler, never()).postDelayed(any(Runnable.class), anyInt());
+    }
+
+    @Test
+    public void testPreFillHandlerPostsIfHasBitmapsToAllocateAfterRunning() {
+        PreFillType size = new PreFillType.Builder(1)
+                .setConfig(Bitmap.Config.ARGB_8888)
+                .build();
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, 2);
+        BitmapPreFillRunner handler = getHandler(allocationOrder);
+        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+
+        handler.run();
+        verify(mainHandler).postDelayed(eq(handler), anyLong());
+    }
+
+    @Test
+    public void testPreFillHandlerPostsWithBackoffIfHasBitmapsToAllocateAfterRunning() {
+        PreFillType size = new PreFillType.Builder(1)
+                .setConfig(Bitmap.Config.ARGB_8888)
+                .build();
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, 100);
+
+        BitmapPreFillRunner handler = getHandler(allocationOrder);
+        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+
+        handler.run();
+        verify(mainHandler).postDelayed(eq(handler), eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS));
+
+        when(clock.now()).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS).thenReturn(
+                BitmapPreFillRunner.MAX_DURATION_MS
+                        + BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO);
+
+        handler.run();
+
+        verify(mainHandler).postDelayed(eq(handler),
+                eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO));
+
+        when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+        handler.run();
+        when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+        handler.run();
+        when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+        handler.run();
+        when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+        handler.run();
+
+        verify(mainHandler, atLeastOnce()).postDelayed(eq(handler), eq(BitmapPreFillRunner.MAX_BACKOFF_MS));
+    }
+
+    @Test
+    public void testPreFillHandlerDoesNotPostIfHasBitmapsButIsCancelled() {
+        PreFillType size = new PreFillType.Builder(1)
+                .setConfig(Bitmap.Config.ARGB_8888)
+                .build();
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, 2);
+
+        BitmapPreFillRunner handler = getHandler(allocationOrder);
+        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
+        handler.cancel();
+        handler.run();
+
+        verify(mainHandler, never()).postDelayed(any(Runnable.class), anyLong());
+    }
+
+    @Test
+    public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
+        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));
+
+        PreFillType size = new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+                .setConfig(bitmap.getConfig())
+                .build();
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, 1);
+
+        getHandler(allocationOrder).run();
+
+        verify(cache).put(any(Key.class), any(Resource.class));
+        verify(pool, never()).put(any(Bitmap.class));
+        assertThat(addedBitmaps).containsExactly(bitmap);
+    }
+
+    @Test
+    public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
+        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        when(cache.getMaxSize()).thenReturn(0);
+
+        PreFillType size = new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+                .setConfig(bitmap.getConfig())
+                .build();
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, 1);
+
+        getHandler(allocationOrder).run();
+
+        verify(cache, never()).put(any(Key.class), any(Resource.class));
+        verify(pool).put(eq(bitmap));
+        assertThat(addedBitmaps).containsExactly(bitmap);
+    }
+
+    @Test
+    public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
+        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);
+
+        PreFillType size = new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+                .setConfig(bitmap.getConfig())
+                .build();
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, 1);
+
+        getHandler(allocationOrder).run();
+
+        verify(cache, never()).put(any(Key.class), any(Resource.class));
+        verify(pool).put(eq(bitmap));
+        assertThat(addedBitmaps).containsExactly(bitmap);
+    }
+
+    @Test
+    public void testDoesAGetFromPoolBeforeAddingForEachSize() {
+        Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+        PreFillType firstSize = new PreFillType.Builder(first.getWidth(), first.getHeight())
+                .setConfig(first.getConfig())
+                .build();
+
+        Bitmap second = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
+        PreFillType secondSize = new PreFillType.Builder(second.getWidth(), second.getHeight())
+                .setConfig(second.getConfig())
+                .build();
+
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(firstSize, 1);
+        allocationOrder.put(secondSize, 1);
+
+        getHandler(allocationOrder).run();
+
+        InOrder firstOrder = inOrder(pool);
+        firstOrder.verify(pool).get(eq(first.getWidth()), eq(first.getHeight()), eq(first.getConfig()));
+        firstOrder.verify(pool).put(eq(first));
+
+        InOrder secondOrder = inOrder(pool);
+        secondOrder.verify(pool).get(eq(second.getWidth()), eq(second.getHeight()), eq(second.getConfig()));
+        secondOrder.verify(pool).put(eq(second));
+    }
+
+    @Test
+    public void testDoesNotGetMoreThanOncePerSize() {
+        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+        PreFillType size = new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+                .setConfig(bitmap.getConfig())
+                .build();
+
+        final int numBitmaps = 5;
+        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();
+        allocationOrder.put(size, numBitmaps);
+
+        getHandler(allocationOrder).run();
+
+        InOrder order = inOrder(pool);
+        order.verify(pool).get(eq(bitmap.getWidth()), eq(bitmap.getHeight()), eq(bitmap.getConfig()));
+        order.verify(pool, times(numBitmaps)).put(eq(bitmap));
+    }
+
+    private static class AddBitmapPoolAnswer implements Answer<Boolean> {
+        private List<Bitmap> bitmaps;
+
+        public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
+            this.bitmaps = bitmaps;
+        }
+
+        @Override
+        public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
+            Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
+            bitmaps.add(bitmap);
+            return null;
+        }
+    }
+
+    private static class AddBitmapCacheAnswer implements Answer<Resource<?>> {
+        private List<Bitmap> bitmaps;
+
+        public AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
+            this.bitmaps = bitmaps;
+        }
+
+        @Override
+        public Resource<?> answer(InvocationOnMock invocationOnMock) throws Throwable {
+            BitmapResource resource = (BitmapResource) invocationOnMock.getArguments()[1];
+            bitmaps.add(resource.get());
+            return null;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java
deleted file mode 100644
index 85d1595af..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java
+++ /dev/null
@@ -1,238 +0,0 @@
-package com.bumptech.glide.load.engine.prefill;
-
-import android.graphics.Bitmap;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.util.Util;
-import org.hamcrest.core.CombinableMatcher;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.either;
-import static org.hamcrest.Matchers.lessThanOrEqualTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-@RunWith(RobolectricTestRunner.class)
-public class BitmapPreFillerAllocationTest {
-    private static final int DEFAULT_BITMAP_WIDTH = 100;
-    private static final int DEFAULT_BITMAP_HEIGHT = 50;
-    private static final Bitmap.Config DEFAULT_BITMAP_CONFIG = PreFillBitmapAttribute.DEFAULT_CONFIG;
-    private static final Bitmap DEFAULT_BITMAP =
-            Bitmap.createBitmap(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT, DEFAULT_BITMAP_CONFIG);
-    private static final int DEFAULT_BITMAP_SIZE = Util.getBitmapByteSize(DEFAULT_BITMAP);
-
-    private static final int DEFAULT_BITMAPS_IN_POOL = 10;
-    private static final int DEFAULT_BITMAPS_IN_CACHE = 10;
-    private static final int POOL_SIZE = DEFAULT_BITMAPS_IN_POOL * DEFAULT_BITMAP_SIZE;
-    private static final int CACHE_SIZE = DEFAULT_BITMAPS_IN_CACHE * DEFAULT_BITMAP_SIZE;
-
-    private BitmapPool pool;
-    private BitmapPreFiller bitmapPreFiller;
-    private MemoryCache cache;
-
-    @Before
-    public void setUp() {
-        pool = mock(BitmapPool.class);
-        when(pool.getMaxSize()).thenReturn(POOL_SIZE);
-        cache = mock(MemoryCache.class);
-        when(cache.getMaxSize()).thenReturn(CACHE_SIZE);
-
-        bitmapPreFiller = new BitmapPreFiller(cache, pool);
-    }
-
-    @Test
-    public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillBitmapAttribute[]{
-                        new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-                }
-        );
-
-        assertEquals(DEFAULT_BITMAPS_IN_POOL + DEFAULT_BITMAPS_IN_CACHE, allocationOrder.getSize());
-    }
-
-    @Test
-    public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
-        PreFillBitmapAttribute[] sizes = new PreFillBitmapAttribute[] {
-                new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT),
-                new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT),
-                new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-        };
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(sizes);
-
-        int byteSize = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillBitmapAttribute current = allocationOrder.remove();
-            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-        }
-
-        int expectedSize = 0;
-        int maxSize = POOL_SIZE + CACHE_SIZE;
-        for (PreFillBitmapAttribute current : sizes) {
-            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-            expectedSize += currentSize * (maxSize / (3 * currentSize));
-        }
-
-        assertEquals(expectedSize, byteSize);
-    }
-
-    @Test
-    public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillBitmapAttribute[] {
-                        new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT),
-                        new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT),
-                        new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-                }
-        );
-
-        int byteSize = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillBitmapAttribute current = allocationOrder.remove();
-            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-        }
-
-        assertThat(byteSize, lessThanOrEqualTo(POOL_SIZE + CACHE_SIZE));
-    }
-
-    @Test
-    public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillBitmapAttribute[]{
-                        new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT,
-                                DEFAULT_BITMAP_CONFIG, 4),
-                        new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT),
-                        new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3,
-                                DEFAULT_BITMAP_CONFIG, 3)
-                }
-        );
-
-        int byteSize = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillBitmapAttribute current = allocationOrder.remove();
-            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-        }
-
-        assertThat(byteSize, lessThanOrEqualTo(POOL_SIZE + CACHE_SIZE));
-    }
-
-    @Test
-    public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillBitmapAttribute[] {
-                    new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-                }
-        );
-
-        while (!allocationOrder.isEmpty()) {
-            PreFillBitmapAttribute size = allocationOrder.remove();
-            assertEquals(DEFAULT_BITMAP_WIDTH, size.getWidth());
-            assertEquals(DEFAULT_BITMAP_HEIGHT, size.getHeight());
-            assertEquals(DEFAULT_BITMAP_CONFIG, size.getConfig());
-        }
-    }
-
-    @Test
-    public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
-        PreFillBitmapAttribute smallWidth = new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT);
-        PreFillBitmapAttribute smallHeight = new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH,
-                DEFAULT_BITMAP_HEIGHT / 2);
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillBitmapAttribute[] { smallWidth, smallHeight, }
-        );
-
-        int numSmallWidth = 0, numSmallHeight = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillBitmapAttribute current = allocationOrder.remove();
-            if (smallWidth.equals(current)) {
-                numSmallWidth++;
-            } else if (smallHeight.equals(current)) {
-                numSmallHeight++;
-            } else {
-                fail("Unexpected size, size: " + current);
-            }
-        }
-
-        assertEquals(numSmallWidth, numSmallHeight);
-    }
-
-    @Test
-    public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualWeights() {
-        PreFillBitmapAttribute smallWidth = new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT);
-        PreFillBitmapAttribute normal = new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT);
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillBitmapAttribute[] { smallWidth, normal }
-        );
-
-        int numSmallWidth = 0, numNormal = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillBitmapAttribute current = allocationOrder.remove();
-            if (smallWidth.equals(current)) {
-                numSmallWidth++;
-            } else if (normal.equals(current)) {
-                numNormal++;
-            } else {
-                fail("Unexpected size, size: " + current);
-            }
-        }
-
-        assertEquals(2 * numNormal, numSmallWidth);
-    }
-
-    @Test
-    public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequalWeights() {
-        PreFillBitmapAttribute doubleWeight = new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH / 2,
-                DEFAULT_BITMAP_HEIGHT, DEFAULT_BITMAP_CONFIG, 2);
-        PreFillBitmapAttribute normal = new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2,
-                DEFAULT_BITMAP_CONFIG, 1);
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillBitmapAttribute[] { doubleWeight, normal }
-        );
-
-        int numDoubleWeight = 0, numNormal = 0;
-        while (!allocationOrder.isEmpty()) {
-            PreFillBitmapAttribute current = allocationOrder.remove();
-            if (doubleWeight.equals(current)) {
-                numDoubleWeight++;
-            } else if (normal.equals(current)) {
-                numNormal++;
-            } else {
-                fail("Unexpected size, size: " + current);
-            }
-        }
-
-        assertEquals(2 * numNormal, numDoubleWeight);
-    }
-
-    @Test
-    public void testAllocationOrderRoundRobinsDifferentSizes() {
-        when(pool.getMaxSize()).thenReturn(DEFAULT_BITMAP_SIZE);
-        when(cache.getMaxSize()).thenReturn(DEFAULT_BITMAP_SIZE);
-        PreFillBitmapAttribute smallWidth = new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT);
-        PreFillBitmapAttribute smallHeight = new PreFillBitmapAttribute(DEFAULT_BITMAP_WIDTH,
-                DEFAULT_BITMAP_HEIGHT / 2);
-
-        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-                new PreFillBitmapAttribute[] { smallWidth, smallHeight, }
-        );
-
-        List<PreFillBitmapAttribute> attributes = new ArrayList<PreFillBitmapAttribute>();
-        while (!allocationOrder.isEmpty()) {
-            attributes.add(allocationOrder.remove());
-        }
-
-        CombinableMatcher.CombinableEitherMatcher<Iterable<? extends PreFillBitmapAttribute>> either =
-                either(contains(smallWidth, smallHeight, smallWidth, smallHeight));
-        assertThat(attributes, either.or(contains(smallHeight, smallWidth, smallHeight, smallWidth)));
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
new file mode 100644
index 000000000..c502d13e9
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -0,0 +1,314 @@
+package com.bumptech.glide.load.engine.prefill;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.Range;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.util.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class BitmapPreFillerTest {
+    private static final int DEFAULT_BITMAP_WIDTH = 100;
+    private static final int DEFAULT_BITMAP_HEIGHT = 50;
+
+    private static final int BITMAPS_IN_POOL = 10;
+    private static final int BITMAPS_IN_CACHE = 10;
+
+    private final Bitmap.Config defaultBitmapConfig = PreFillType.DEFAULT_CONFIG;
+    private final Bitmap defaultBitmap =
+            Bitmap.createBitmap(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT, defaultBitmapConfig);
+    private final int defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
+    private final int poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
+    private final int cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
+
+    private BitmapPool pool;
+    private BitmapPreFiller bitmapPreFiller;
+    private MemoryCache cache;
+
+    @Before
+    public void setUp() {
+        pool = mock(BitmapPool.class);
+        when(pool.getMaxSize()).thenReturn(poolSize);
+        cache = mock(MemoryCache.class);
+        when(cache.getMaxSize()).thenReturn(cacheSize);
+
+        bitmapPreFiller = new BitmapPreFiller(cache, pool, DecodeFormat.DEFAULT);
+    }
+
+    @Test
+    public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
+                new PreFillType[] {
+                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                                .setConfig(defaultBitmapConfig)
+                                .build()
+                }
+        );
+
+        assertEquals(BITMAPS_IN_POOL + BITMAPS_IN_CACHE, allocationOrder.getSize());
+    }
+
+    @Test
+    public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
+        PreFillType[] sizes = new PreFillType[] {
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                        .setConfig(defaultBitmapConfig)
+                        .build(),
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                        .setConfig(defaultBitmapConfig)
+                        .build(),
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+                        .setConfig(defaultBitmapConfig)
+                        .build(),
+        };
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(sizes);
+
+        int byteSize = 0;
+        while (!allocationOrder.isEmpty()) {
+            PreFillType current = allocationOrder.remove();
+            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
+        }
+
+        int expectedSize = 0;
+        int maxSize = poolSize + cacheSize;
+        for (PreFillType current : sizes) {
+            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
+            expectedSize += currentSize * (maxSize / (3 * currentSize));
+        }
+
+        assertEquals(expectedSize, byteSize);
+    }
+
+    @Test
+    public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
+                new PreFillType[]{
+                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                                .setConfig(defaultBitmapConfig)
+                                .build(),
+                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                                .setConfig(defaultBitmapConfig)
+                                .build(),
+                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+                                .setConfig(defaultBitmapConfig)
+                                .build()
+                }
+        );
+
+        int byteSize = 0;
+        while (!allocationOrder.isEmpty()) {
+            PreFillType current = allocationOrder.remove();
+            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
+        }
+
+        assertThat(byteSize).isIn(Range.atMost(poolSize + cacheSize));
+    }
+
+    @Test
+    public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
+                new PreFillType[]{
+                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                                .setConfig(defaultBitmapConfig)
+                                .setWeight(4)
+                                .build(),
+                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                                .setConfig(defaultBitmapConfig)
+                                .build(),
+                        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
+                                .setConfig(defaultBitmapConfig)
+                                .setWeight(3)
+                                .build()
+                }
+        );
+
+        int byteSize = 0;
+        while (!allocationOrder.isEmpty()) {
+            PreFillType current = allocationOrder.remove();
+            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
+        }
+
+        assertThat(byteSize).isIn(Range.atMost(poolSize + cacheSize));
+    }
+
+    @Test
+    public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
+                new PreFillType[] {
+                    new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                            .setConfig(defaultBitmapConfig)
+                            .build()
+                }
+        );
+
+        while (!allocationOrder.isEmpty()) {
+            PreFillType size = allocationOrder.remove();
+            assertEquals(DEFAULT_BITMAP_WIDTH, size.getWidth());
+            assertEquals(DEFAULT_BITMAP_HEIGHT, size.getHeight());
+            assertEquals(defaultBitmapConfig, size.getConfig());
+        }
+    }
+
+    @Test
+    public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
+        PreFillType smallWidth = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build();
+        PreFillType smallHeight =
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+                        .setConfig(defaultBitmapConfig)
+                        .build();
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
+                new PreFillType[] { smallWidth, smallHeight, }
+        );
+
+        int numSmallWidth = 0, numSmallHeight = 0;
+        while (!allocationOrder.isEmpty()) {
+            PreFillType current = allocationOrder.remove();
+            if (smallWidth.equals(current)) {
+                numSmallWidth++;
+            } else if (smallHeight.equals(current)) {
+                numSmallHeight++;
+            } else {
+                fail("Unexpected size, size: " + current);
+            }
+        }
+
+        assertEquals(numSmallWidth, numSmallHeight);
+    }
+
+    @Test
+    public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualWeights() {
+        PreFillType smallWidth =
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                        .setConfig(defaultBitmapConfig)
+                        .build();
+        PreFillType normal =
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                        .setConfig(defaultBitmapConfig)
+                        .build();
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
+                new PreFillType[] { smallWidth, normal }
+        );
+
+        int numSmallWidth = 0, numNormal = 0;
+        while (!allocationOrder.isEmpty()) {
+            PreFillType current = allocationOrder.remove();
+            if (smallWidth.equals(current)) {
+                numSmallWidth++;
+            } else if (normal.equals(current)) {
+                numNormal++;
+            } else {
+                fail("Unexpected size, size: " + current);
+            }
+        }
+
+        assertEquals(2 * numNormal, numSmallWidth);
+    }
+
+    @Test
+    public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequalWeights() {
+        PreFillType doubleWeight =
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                        .setConfig(defaultBitmapConfig)
+                        .setWeight(2)
+                        .build();
+        PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+                .setConfig(defaultBitmapConfig)
+                .build();
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
+                new PreFillType[] { doubleWeight, normal }
+        );
+
+        int numDoubleWeight = 0, numNormal = 0;
+        while (!allocationOrder.isEmpty()) {
+            PreFillType current = allocationOrder.remove();
+            if (doubleWeight.equals(current)) {
+                numDoubleWeight++;
+            } else if (normal.equals(current)) {
+                numNormal++;
+            } else {
+                fail("Unexpected size, size: " + current);
+            }
+        }
+
+        assertEquals(2 * numNormal, numDoubleWeight);
+    }
+
+    @Test
+    public void testAllocationOrderRoundRobinsDifferentSizes() {
+        when(pool.getMaxSize()).thenReturn(defaultBitmapSize);
+        when(cache.getMaxSize()).thenReturn(defaultBitmapSize);
+        PreFillType smallWidth =
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                        .setConfig(defaultBitmapConfig)
+                        .build();
+        PreFillType smallHeight =
+                new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+                        .setConfig(defaultBitmapConfig)
+                        .build();
+
+        PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
+                new PreFillType[] { smallWidth, smallHeight, }
+        );
+
+        List<PreFillType> attributes = new ArrayList<PreFillType>();
+        while (!allocationOrder.isEmpty()) {
+            attributes.add(allocationOrder.remove());
+        }
+
+        // Either width, height, width, height or height, width, height, width.
+        try {
+            assertThat(attributes).containsExactly(smallWidth, smallHeight, smallWidth, smallHeight).inOrder();
+        } catch (AssertionError e) {
+            assertThat(attributes).containsExactly(smallHeight, smallWidth, smallHeight, smallWidth).inOrder();
+        }
+    }
+
+    @Test
+    public void testSetsConfigOnBuildersToDefaultIfNotSet() {
+        PreFillType.Builder builder = mock(PreFillType.Builder.class);
+        when(builder.build()).thenReturn(new PreFillType.Builder(100).setConfig(Bitmap.Config.RGB_565).build());
+
+        bitmapPreFiller.preFill(builder);
+
+        InOrder order = inOrder(builder);
+        order.verify(builder).setConfig(Bitmap.Config.RGB_565);
+        order.verify(builder).build();
+    }
+
+    @Test
+    public void testDoesNotSetConfigOnBuildersIfConfigIsAlreadySet() {
+        PreFillType.Builder builder = mock(PreFillType.Builder.class);
+
+        when(builder.getConfig()).thenReturn(Bitmap.Config.ARGB_4444);
+        when(builder.build()).thenReturn(new PreFillType.Builder(100).setConfig(Bitmap.Config.ARGB_4444).build());
+        bitmapPreFiller.preFill(builder);
+
+        verify(builder, never()).setConfig(any(Bitmap.Config.class));
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
new file mode 100644
index 000000000..68a2a7798
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
@@ -0,0 +1,87 @@
+package com.bumptech.glide.load.engine.prefill;
+
+import static org.junit.Assert.assertEquals;
+
+import com.google.common.testing.EqualsTester;
+
+import android.graphics.Bitmap;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class PreFillTypeTest {
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsIfSizeIsZero() {
+        new PreFillType.Builder(0);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsIfWidthIsZero() {
+        new PreFillType.Builder(0, 100);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsIfHeightIsZero() {
+        new PreFillType.Builder(100, 0);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsIfWeightIsZero() {
+        new PreFillType.Builder(100).setWeight(0);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testConstructorThrowsIfConfigIsNull() {
+        new PreFillType(100, 100, null, 1);
+    }
+
+    @Test
+    public void testGetWidthReturnsGivenWidth() {
+        int width = 500;
+        assertEquals(width, new PreFillType(width, 100, Bitmap.Config.ARGB_4444, 1).getWidth());
+    }
+
+    @Test
+    public void testGetHeightReturnsGivenHeight() {
+        int height = 123;
+        assertEquals(height, new PreFillType(100, height, Bitmap.Config.ARGB_4444, 1).getHeight());
+    }
+
+    @Test
+    public void testGetConfigReturnsGivenConfig() {
+        Bitmap.Config config = Bitmap.Config.ARGB_8888;
+        assertEquals(config, new PreFillType(100, 100, config, 1).getConfig());
+    }
+
+    @Test
+    public void testGetWeightReturnsGivenWeight() {
+        int weight = 400;
+        assertEquals(weight, new PreFillType(100, 100, Bitmap.Config.ARGB_4444, weight).getWeight());
+    }
+
+    @Test
+    public void testEquality() {
+        new EqualsTester()
+                .addEqualityGroup(
+                        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1),
+                        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1))
+                .addEqualityGroup(
+                        new PreFillType(200, 100, Bitmap.Config.ARGB_4444, 1)
+                )
+                .addEqualityGroup(
+                        new PreFillType(100, 200, Bitmap.Config.ARGB_4444, 1)
+                )
+                .addEqualityGroup(
+                        new PreFillType(100, 100, Bitmap.Config.ARGB_8888, 1)
+                )
+                .addEqualityGroup(
+                        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 2)
+                )
+                .testEquals();
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillerHandlerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillerHandlerTest.java
deleted file mode 100644
index 64f17d4f1..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillerHandlerTest.java
+++ /dev/null
@@ -1,235 +0,0 @@
-package com.bumptech.glide.load.engine.prefill;
-
-import android.graphics.Bitmap;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.load.resource.bitmap.BitmapResource;
-import com.bumptech.glide.util.Util;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.hasSize;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(RobolectricTestRunner.class)
-public class PreFillerHandlerTest {
-    private BitmapPreFillIdleHandler.Clock clock;
-    private BitmapPool pool;
-    private MemoryCache cache;
-    private List<Bitmap> addedBitmaps = new ArrayList<Bitmap>();
-
-    @Before
-    public void setUp() {
-        clock = mock(BitmapPreFillIdleHandler.Clock.class);
-
-        pool = mock(BitmapPool.class);
-        when(pool.put(any(Bitmap.class))).thenAnswer(new AddBitmapPoolAnswer(addedBitmaps));
-        cache = mock(MemoryCache.class);
-        when(cache.put(any(Key.class), any(Resource.class))).thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));
-    }
-
-    private BitmapPreFillIdleHandler getHandler(Map<PreFillBitmapAttribute, Integer> allocationOrder) {
-        int total = 0;
-        for (Integer count : allocationOrder.values()) {
-            total += count;
-        }
-        return new BitmapPreFillIdleHandler(pool, cache, new PreFillQueue(allocationOrder), clock);
-    }
-
-    @Test
-    public void testAllocatesABitmapPerSizeInAllocationOrder() {
-        PreFillBitmapAttribute size = new PreFillBitmapAttribute(100, 100);
-        final int toAdd = 3;
-        Map<PreFillBitmapAttribute, Integer> allocationOrder = new HashMap<PreFillBitmapAttribute, Integer>();
-        allocationOrder.put(size, toAdd);
-        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);
-        handler.queueIdle();
-
-        Bitmap expected = Bitmap.createBitmap(size.getWidth(), size.getHeight(), size.getConfig());
-        assertThat(addedBitmaps, contains(expected, expected, expected));
-    }
-
-    @Test
-    public void testAllocatesBitmapsInOrderGivenByAllocationOrder() {
-        PreFillBitmapAttribute smallWidth = new PreFillBitmapAttribute(50, 100);
-        PreFillBitmapAttribute smallHeight = new PreFillBitmapAttribute(100, 50);
-
-        PreFillBitmapAttribute[] expectedOrder = new PreFillBitmapAttribute[] {
-                smallWidth,
-                smallHeight,
-                smallWidth,
-                smallHeight,
-        };
-
-        HashMap<PreFillBitmapAttribute, Integer> allocationOrder = new HashMap<PreFillBitmapAttribute, Integer>();
-        allocationOrder.put(smallWidth, 2);
-        allocationOrder.put(smallHeight, 2);
-        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);
-        handler.queueIdle();
-
-
-        Bitmap[] expectedBitmaps = new Bitmap[expectedOrder.length];
-        for (int i = 0; i < expectedBitmaps.length; i++) {
-            PreFillBitmapAttribute current = expectedOrder[i];
-            expectedBitmaps[i] = Bitmap.createBitmap(current.getWidth(), current.getHeight(), current.getConfig());
-        }
-
-        Bitmap current = addedBitmaps.get(0);
-        for (int i = 1; i < addedBitmaps.size(); i++) {
-            assertNotEquals(current, addedBitmaps.get(i));
-            current = addedBitmaps.get(i);
-        }
-
-        assertThat(addedBitmaps, hasSize(4));
-    }
-
-    @Test
-    public void testStopsAllocatingBitmapsUntilNextIdleCallIfAllocationsTakeLongerThanLimit() {
-        PreFillBitmapAttribute size = new PreFillBitmapAttribute(1, 1);
-        Map<PreFillBitmapAttribute, Integer> allocationOrder = new HashMap<PreFillBitmapAttribute, Integer>();
-        allocationOrder.put(size, 3);
-        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillIdleHandler.MAX_DURATION_MILLIS);
-        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);
-        handler.queueIdle();
-
-        assertThat(addedBitmaps, hasSize(1));
-
-        handler.queueIdle();
-
-        assertThat(addedBitmaps, hasSize(3));
-    }
-
-    @Test
-    public void testPreFillHandlerReturnsFalseFromQueueIdleIfHasNoBitmapsToAllocate() {
-        BitmapPreFillIdleHandler handler = getHandler(new HashMap<PreFillBitmapAttribute, Integer>());
-        assertFalse(handler.queueIdle());
-    }
-
-    @Test
-    public void testPreFillHandlerReturnsTrueFromQueueIdleIfHasBitmapsToAllocate() {
-        PreFillBitmapAttribute size = new PreFillBitmapAttribute(1, 1);
-        Map<PreFillBitmapAttribute, Integer> allocationOrder = new HashMap<PreFillBitmapAttribute, Integer>();
-        allocationOrder.put(size, 2);
-        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);
-        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillIdleHandler.MAX_DURATION_MILLIS);
-        assertTrue(handler.queueIdle());
-    }
-
-    @Test
-    public void testPreFillHandlerReturnsFalseFromQueueIdleIfHasBitmapsButIsCancelled() {
-        PreFillBitmapAttribute size = new PreFillBitmapAttribute(1, 1);
-        Map<PreFillBitmapAttribute, Integer> allocationOrder = new HashMap<PreFillBitmapAttribute, Integer>();
-        allocationOrder.put(size, 2);
-
-        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);
-        when(clock.now()).thenReturn(0L).thenReturn(0L).thenReturn(BitmapPreFillIdleHandler.MAX_DURATION_MILLIS);
-        handler.cancel();
-        handler.queueIdle();
-        assertFalse(handler.queueIdle());
-    }
-
-    @Test
-    public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));
-
-        PreFillBitmapAttribute size = new PreFillBitmapAttribute(bitmap.getWidth(), bitmap.getHeight(),
-                bitmap.getConfig(), 1);
-        Map<PreFillBitmapAttribute, Integer> allocationOrder = new HashMap<PreFillBitmapAttribute, Integer>();
-        allocationOrder.put(size, 1);
-
-        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);
-        handler.queueIdle();
-
-        verify(cache).put(any(Key.class), any(Resource.class));
-        verify(pool, never()).put(any(Bitmap.class));
-        assertThat(addedBitmaps, contains(bitmap));
-    }
-
-    @Test
-    public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(cache.getMaxSize()).thenReturn(0);
-
-        PreFillBitmapAttribute size = new PreFillBitmapAttribute(bitmap.getWidth(), bitmap.getHeight(),
-                bitmap.getConfig(), 1);
-        Map<PreFillBitmapAttribute, Integer> allocationOrder = new HashMap<PreFillBitmapAttribute, Integer>();
-        allocationOrder.put(size, 1);
-
-        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);
-        handler.queueIdle();
-
-        verify(cache, never()).put(any(Key.class), any(Resource.class));
-        verify(pool).put(eq(bitmap));
-        assertThat(addedBitmaps, contains(bitmap));
-    }
-
-    @Test
-    public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
-        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);
-
-        PreFillBitmapAttribute size = new PreFillBitmapAttribute(bitmap.getWidth(), bitmap.getHeight(),
-                bitmap.getConfig(), 1);
-        Map<PreFillBitmapAttribute, Integer> allocationOrder = new HashMap<PreFillBitmapAttribute, Integer>();
-        allocationOrder.put(size, 1);
-
-        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);
-        handler.queueIdle();
-
-        verify(cache, never()).put(any(Key.class), any(Resource.class));
-        verify(pool).put(eq(bitmap));
-        assertThat(addedBitmaps, contains(bitmap));
-    }
-
-    private static class AddBitmapPoolAnswer implements Answer<Boolean> {
-        private List<Bitmap> bitmaps;
-
-        public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
-            this.bitmaps = bitmaps;
-        }
-
-        @Override
-        public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
-            Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
-            bitmaps.add(bitmap);
-            return null;
-        }
-    }
-
-    private static class AddBitmapCacheAnswer implements Answer<Resource<?>> {
-        private List<Bitmap> bitmaps;
-
-        public AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
-            this.bitmaps = bitmaps;
-        }
-
-        @Override
-        public Resource<?> answer(InvocationOnMock invocationOnMock) throws Throwable {
-            BitmapResource resource = (BitmapResource) invocationOnMock.getArguments()[1];
-            bitmaps.add(resource.get());
-            return null;
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java
index 5d0071b01..315aa0518 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -1,15 +1,17 @@
 package com.bumptech.glide.load.model;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.net.MalformedURLException;
 import java.net.URL;
 
-import static org.junit.Assert.assertEquals;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GlideUrlTest {
 
     @Test(expected = IllegalArgumentException.class)
@@ -58,7 +60,7 @@ public void testProducesEquivalentStringFromURL() throws MalformedURLException {
         URL url = new URL(expected);
         GlideUrl glideUrl = new GlideUrl(url);
 
-        assertEquals(expected, glideUrl.toString());
+        assertEquals(expected, glideUrl.toStringUrl());
     }
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java
index 4ce183a58..bf846be10 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java
@@ -1,28 +1,32 @@
 package com.bumptech.glide.load.model;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ImageVideoModelLoaderTest {
     private ImageVideoLoaderHarness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoderTest.java
index 350ea80e3..8ec4828c3 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoderTest.java
@@ -1,11 +1,21 @@
 package com.bumptech.glide.load.model;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.load.Encoder;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -14,15 +24,8 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ImageVideoWrapperEncoderTest {
     private Encoder<InputStream> streamEncoder;
     private Encoder<ParcelFileDescriptor> fileDescriptorEncoder;
@@ -45,8 +48,8 @@ public void testReturnsIdOfStreamAndFileDescriptorEncoders() {
 
         String id = encoder.getId();
 
-        assertThat(id, containsString(streamId));
-        assertThat(id, containsString(fileId));
+        assertThat(id).contains(streamId);
+        assertThat(id).contains(fileId);
     }
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/ModelCacheTest.java
new file mode 100644
index 000000000..f9d461d07
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/ModelCacheTest.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+
+import com.google.common.testing.EqualsTester;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ModelCacheTest {
+
+    private ModelCache<Object, Object> cache;
+
+    @Before
+    public void setUp() {
+        cache = new ModelCache<Object, Object>(10);
+    }
+
+    @Test
+    public void testModelKeyEquivalence() {
+        new EqualsTester()
+                .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 200), ModelCache.ModelKey.get(14f, 100, 200))
+                .addEqualityGroup(ModelCache.ModelKey.get(13f, 100, 200))
+                .addEqualityGroup(ModelCache.ModelKey.get(14f, 200, 200))
+                .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 300))
+                .testEquals();
+    }
+
+    @Test
+    public void testCanSetAndGetModel() {
+        Object model = new Object();
+        int width = 10;
+        int height = 20;
+        Object result = new Object();
+        cache.put(model, width, height, result);
+        assertEquals(result, cache.get(model, width, height));
+    }
+
+    @Test
+    public void testCanSetAndGetMultipleResultsWithDifferentDimensionsForSameObject() {
+        Object model = new Object();
+        int firstWidth = 10, firstHeight = 20;
+        Object firstResult = new Object();
+        int secondWidth = 30, secondHeight = 40;
+        Object secondResult = new Object();
+
+        cache.put(model, firstWidth, firstHeight, firstResult);
+        cache.put(model, secondWidth, secondHeight, secondResult);
+
+        assertEquals(firstResult, cache.get(model, firstWidth, firstHeight));
+        assertEquals(secondResult, cache.get(model, secondWidth, secondHeight));
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/NullResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/NullResourceEncoderTest.java
deleted file mode 100644
index 8b1cf1115..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/NullResourceEncoderTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.resource.NullResourceEncoder;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.ByteArrayOutputStream;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.mockito.Mockito.mock;
-
-public class NullResourceEncoderTest {
-    private NullResourceEncoder<Object> encoder;
-
-    @Before
-    public void setUp() {
-        encoder = new NullResourceEncoder<Object>();
-    }
-
-    @Test
-    public void testReturnsFalse() {
-        assertFalse(encoder.encode(mock(Resource.class), new ByteArrayOutputStream()));
-    }
-
-    @Test
-    public void testReturnsEmptyId() {
-        assertEquals("", encoder.getId());
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/StreamEncoderTest.java
index 5db8ebec9..67b1964eb 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -1,16 +1,18 @@
 package com.bumptech.glide.load.model;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 
-import static org.junit.Assert.assertEquals;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class StreamEncoderTest {
     private StreamEncoder encoder;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
new file mode 100644
index 000000000..cb90a8ca8
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -0,0 +1,136 @@
+package com.bumptech.glide.load.model.stream;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelCache;
+import com.bumptech.glide.load.model.ModelLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class BaseGlideUrlLoaderTest {
+
+    private ModelCache<Object, GlideUrl> modelCache;
+    private ModelLoader<GlideUrl, InputStream> wrapped;
+    private TestLoader urlLoader;
+
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+        modelCache = mock(ModelCache.class);
+        wrapped = mock(ModelLoader.class);
+        urlLoader = new TestLoader(wrapped, modelCache);
+    }
+
+    @Test
+    public void testReturnsNullIfUrlIsNull() {
+        urlLoader.resultUrl = null;
+        assertNull(urlLoader.getResourceFetcher(new Object(), 100, 100));
+    }
+
+    @Test
+    public void testReturnsNullIfUrlIsEmpty() {
+        urlLoader.resultUrl = "    ";
+        assertNull(urlLoader.getResourceFetcher(new Object(), 100, 100));
+    }
+
+    @Test
+    public void testReturnsUrlFromCacheIfPresent() {
+        Object model = new Object();
+        int width = 100;
+        int height = 200;
+        GlideUrl expectedUrl = mock(GlideUrl.class);
+        when(modelCache.get(eq(model), eq(width), eq(height))).thenReturn(expectedUrl);
+        DataFetcher<InputStream> expectedFetcher = mock(DataFetcher.class);
+
+        when(wrapped.getResourceFetcher(eq(expectedUrl), eq(width), eq(height))).thenReturn(expectedFetcher);
+
+        assertEquals(expectedFetcher, urlLoader.getResourceFetcher(model, width, height));
+    }
+
+    @Test
+    public void testBuildsNewUrlIfNotPresentInCache() {
+        int width = 10;
+        int height = 11;
+
+        urlLoader.resultUrl = "fakeUrl";
+        final DataFetcher<InputStream> expected = mock(DataFetcher.class);
+        when(wrapped.getResourceFetcher(any(GlideUrl.class), eq(width), eq(height))).thenAnswer(
+                new Answer<DataFetcher<InputStream>>() {
+                    @Override
+                    public DataFetcher<InputStream> answer(InvocationOnMock invocationOnMock) throws Throwable {
+                        GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
+                        assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
+                        return expected;
+
+                    }
+                });
+        assertEquals(expected, urlLoader.getResourceFetcher(new Object(), width, height));
+    }
+
+    @Test
+    public void testAddsNewUrlToCacheIfNotPresentInCache() {
+        urlLoader.resultUrl = "fakeUrl";
+        Object model = new Object();
+        int width = 400;
+        int height = 500;
+
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
+                assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
+                return null;
+            }
+        }).when(modelCache).put(eq(model), eq(width), eq(height), any(GlideUrl.class));
+
+        urlLoader.getResourceFetcher(model, width, height);
+
+        verify(modelCache).put(eq(model), eq(width), eq(height), any(GlideUrl.class));
+    }
+
+    @Test
+    public void testDoesNotInteractWithModelCacheIfNull() {
+        TestLoader urlLoader = new TestLoader(wrapped, null);
+        urlLoader.resultUrl = "fakeUrl";
+
+        int width = 456;
+        int height = 789;
+
+        DataFetcher<InputStream> expected = mock(DataFetcher.class);
+        when(wrapped.getResourceFetcher(any(GlideUrl.class), eq(width), eq(height))).thenReturn(expected);
+
+        assertEquals(expected, urlLoader.getResourceFetcher(new Object(), width, height));
+    }
+
+    private class TestLoader extends BaseGlideUrlLoader<Object> {
+        public String resultUrl;
+
+        public TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader, ModelCache<Object, GlideUrl> modelCache) {
+            super(concreteLoader, modelCache);
+        }
+
+        @Override
+        protected String getUrl(Object model, int width, int height) {
+            return resultUrl;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoaderTest.java
index 7a08ddbc4..9a6502cf2 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoaderTest.java
@@ -1,17 +1,20 @@
 package com.bumptech.glide.load.model.stream;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.InputStream;
 
-import static org.hamcrest.Matchers.instanceOf;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.mock;
-
+@RunWith(JUnit4.class)
 public class HttpUrlGlideUrlLoaderTest {
     private HttpUrlGlideUrlLoader loader;
     private GlideUrl model;
@@ -25,6 +28,6 @@ public void setUp() {
     @Test
     public void testReturnsValidFetcher() {
         DataFetcher<InputStream> result = loader.getResourceFetcher(model, 100, 100);
-        assertThat(result, instanceOf(HttpUrlFetcher.class));
+        assertThat(result).isInstanceOf(HttpUrlFetcher.class);
     }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoaderTest.java
index 042797bc0..90bfe6c52 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoaderTest.java
@@ -1,19 +1,23 @@
 package com.bumptech.glide.load.model.stream;
 
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
 import android.net.Uri;
+
 import com.bumptech.glide.load.model.ModelLoader;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.InputStream;
 
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class MediaStoreStreamLoaderTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java
index b6346ef4e..178514464 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java
@@ -1,26 +1,30 @@
 package com.bumptech.glide.load.model.stream;
 
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.net.Uri;
+
 import com.bumptech.glide.load.model.ModelLoader;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.InputStream;
 
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 /**
  * Tests for the {@link StreamResourceLoader} class.
  */
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ResourceLoaderTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoaderTest.java
index e53110783..ef7119043 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoaderTest.java
@@ -1,13 +1,17 @@
 package com.bumptech.glide.load.model.stream;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
 import com.bumptech.glide.load.data.DataFetcher;
+
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
+@RunWith(JUnit4.class)
 public class StreamByteArrayLoaderTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java
index f47b7526d..64eda71c4 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java
@@ -1,6 +1,12 @@
 package com.bumptech.glide.load.model.stream;
 
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
 import android.net.Uri;
+
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.tests.Util;
 
@@ -9,20 +15,17 @@
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 /**
  * Tests for the {@link StreamStringLoader} class.
  */
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class StringLoaderTest {
     // Not a magic number, just an arbitrary non zero value.
     private static final int IMAGE_SIDE = 100;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java
index 3aef7d23f..6abdf322a 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java
@@ -1,31 +1,35 @@
 package com.bumptech.glide.load.model.stream;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
 import android.content.Context;
 import android.net.Uri;
+
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.UriLoader;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 /**
  * Tests for the {@link StreamUriLoader} class.
  */
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class UriLoaderTest {
     // Not a magic number, just arbitrary non zero.
     private static final int IMAGE_SIDE = 120;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/NullDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/NullDecoderTest.java
index f0c2126b4..0621fd178 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/NullDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/NullDecoderTest.java
@@ -1,14 +1,17 @@
 package com.bumptech.glide.load.resource;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
+@RunWith(JUnit4.class)
 public class NullDecoderTest {
     private NullDecoder decoder;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/NullResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/NullResourceEncoderTest.java
index dc94f06c2..fa19bf32d 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/NullResourceEncoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/NullResourceEncoderTest.java
@@ -1,14 +1,18 @@
 package com.bumptech.glide.load.resource;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Mockito.mock;
+
 import com.bumptech.glide.load.engine.Resource;
+
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.ByteArrayOutputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.mockito.Mockito.mock;
-
+@RunWith(JUnit4.class)
 public class NullResourceEncoderTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
index a6c651a5a..ea001a5c2 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
@@ -1,10 +1,13 @@
 package com.bumptech.glide.load.resource;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import static org.junit.Assert.assertEquals;
-
+@RunWith(JUnit4.class)
 public class SimpleResourceTest {
     private Anything object;
     private SimpleResource resource;
@@ -27,5 +30,10 @@ public void testReturnsGivenObjectMultipleTimes() {
         assertEquals(object, resource.get());
     }
 
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfGivenNullData() {
+        new SimpleResource<Object>(null);
+    }
+
     private static class Anything { }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
index 28bba5f99..d0cb9f4f1 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -1,12 +1,15 @@
 package com.bumptech.glide.load.resource;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
 import com.bumptech.glide.load.engine.Resource;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
+@RunWith(JUnit4.class)
 public class UnitTransformationTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
index fb7bb3639..e849807b5 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -1,21 +1,25 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class BitmapDrawableResourceTest {
     private BitmapDrawableResourceHarness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 1124828ed..6d9f3e29b 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -1,7 +1,15 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.google.common.truth.Truth.assertThat;
+import static com.bumptech.glide.tests.Util.assertClassHasValidId;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,15 +22,8 @@
 
 import java.io.ByteArrayOutputStream;
 
-import static com.bumptech.glide.tests.Util.assertClassHasValidId;
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = { BitmapEncoderTest.AlphaShadowBitmap.class })
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { BitmapEncoderTest.AlphaShadowBitmap.class })
 public class BitmapEncoderTest {
     private EncoderHarness harness;
 
@@ -90,7 +91,7 @@ public void testReturnsValidId() {
     }
 
     private static void assertContains(String string, String expected) {
-        assertThat(string, containsString(expected));
+        assertThat(string).contains(expected);
     }
 
     @SuppressWarnings("unchecked")
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
index 289384044..54bcf2a38 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -1,25 +1,29 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 import android.os.Build;
+
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.Util;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 //TODO: add a test for bitmap size using getAllocationByteSize when robolectric supports kitkat.
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class BitmapResourceTest {
     private int currentBuildVersion;
     private BitmapResourceHarness harness;
@@ -32,7 +36,7 @@ public void setUp() {
 
     @After
     public void tearDown() {
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", currentBuildVersion);
+        Util.setSdkVersionInt(currentBuildVersion);
     }
 
     @Test
@@ -42,7 +46,7 @@ public void testCanGetBitmap() {
 
     @Test
     public void testSizeIsBasedOnDimensPreKitKat() {
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", 18);
+        Util.setSdkVersionInt(18);
         assertEquals(harness.bitmap.getWidth() * harness.bitmap.getHeight() * 4, harness.resource.getSize());
     }
 
@@ -71,6 +75,21 @@ public void testRecyclesBitmapIfRejectedByPool() {
         assertTrue(harness.bitmap.isRecycled());
     }
 
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfBitmapIsNull() {
+        new BitmapResource(null, mock(BitmapPool.class));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfBitmapPoolIsNull() {
+        new BitmapResource(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565), null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfBitmapAndBitmapPoolAreNull() {
+        new BitmapResource(null, null);
+    }
+
     private static class BitmapResourceHarness {
         Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
         BitmapPool bitmapPool = mock(BitmapPool.class);
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index 09d4f6b90..8606c6fa7 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -1,28 +1,35 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class BitmapTransformationTest {
 
+    @Mock
     private BitmapPool bitmapPool;
 
     @Before
     public void setUp() {
-        bitmapPool = mock(BitmapPool.class);
+        MockitoAnnotations.initMocks(this);
     }
 
     @Test
@@ -39,14 +46,12 @@ public String getId() {
             }
         };
 
-        Resource<Bitmap> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
+        Resource<Bitmap> resource = mockResource(100, 100);
         assertEquals(resource, transformation.transform(resource, 1, 1));
     }
 
     @Test
     public void testReturnsNewResourceWhenBitmapTransformed() {
-        final Bitmap toTransform = Bitmap.createBitmap(1, 2, Bitmap.Config.RGB_565);
         final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
         BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
             @Override
@@ -60,9 +65,7 @@ public String getId() {
             }
         };
 
-        Resource<Bitmap> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(toTransform);
-
+        Resource<Bitmap> resource = mockResource(1, 2);
         assertNotSame(resource, transformation.transform(resource, 100, 100));
     }
 
@@ -70,15 +73,15 @@ public String getId() {
     public void testPassesGivenArgumentsToTransform() {
         final int expectedWidth = 13;
         final int expectedHeight = 148;
-        final Bitmap expected = Bitmap.createBitmap(223, 4123, Bitmap.Config.RGB_565);
+        final Resource<Bitmap> resource = mockResource(223, 4123);
         BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
             @Override
             protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
                 assertEquals(bitmapPool, pool);
-                assertEquals(expected, toTransform);
+                assertEquals(resource.get(), toTransform);
                 assertEquals(expectedWidth, outWidth);
                 assertEquals(expectedHeight, outHeight);
-                return null;
+                return resource.get();
             }
 
             @Override
@@ -86,8 +89,7 @@ public String getId() {
                 return null;
             }
         };
-        Resource<Bitmap> resource = mock(Resource.class);
-        when(resource.get()).thenReturn(expected);
+
         transformation.transform(resource, expectedWidth, expectedHeight);
     }
 
@@ -127,4 +129,73 @@ public String getId() {
         transformation.transform(mock(Resource.class), 100, -1);
     }
 
+    @Test
+    public void testReturnsNullIfTransformReturnsNull() {
+        BitmapTransformation transform = new BitmapTransformation(bitmapPool) {
+
+            @Override
+            public String getId() {
+                return null;
+            }
+
+            @Override
+            protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+                return null;
+            }
+        };
+
+        Resource<Bitmap> resource = mockResource(100, 100);
+        assertNull(transform.transform(resource, 100, 100));
+    }
+
+    @Test
+    public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {
+        SizeTrackingTransform transform = new SizeTrackingTransform();
+
+        int expectedWidth = 200;
+        Resource<Bitmap> resource = mockResource(expectedWidth, 300);
+        transform.transform(resource, Target.SIZE_ORIGINAL, 500);
+
+        assertEquals(expectedWidth, transform.givenWidth);
+    }
+
+    @Test
+    public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
+        SizeTrackingTransform transform = new SizeTrackingTransform();
+
+        int expectedHeight = 500;
+        Resource<Bitmap> resource = mockResource(123, expectedHeight);
+        transform.transform(resource, 444, expectedHeight);
+
+        assertEquals(expectedHeight, transform.givenHeight);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Resource<Bitmap> mockResource(int width, int height) {
+        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+        Resource<Bitmap> resource = mock(Resource.class);
+        when(resource.get()).thenReturn(bitmap);
+        return resource;
+    }
+
+    private class SizeTrackingTransform extends BitmapTransformation {
+        int givenWidth;
+        int givenHeight;
+
+        public SizeTrackingTransform() {
+            super(bitmapPool);
+        }
+
+        @Override
+        protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+            givenWidth = outWidth;
+            givenHeight = outHeight;
+            return null;
+        }
+
+        @Override
+        public String getId() {
+            return null;
+        }
+    }
 }
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index 785da2cea..2b5c03fc8 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -1,24 +1,30 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.graphics.Bitmap;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.Util;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class CenterCropTest {
     private CenterCropHarness harness;
 
@@ -70,6 +76,16 @@ public void testDoesNotRecycleGivenResource() {
         verify(harness.resource, never()).recycle();
     }
 
+    @Test
+    public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
+        Robolectric.shadowOf(harness.bitmap).setConfig(null);
+
+        harness.centerCrop.transform(harness.resource, 10, 10);
+
+        verify(harness.pool).get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888));
+        verify(harness.pool, never()).get(anyInt(), anyInt(), (Bitmap.Config) isNull());
+    }
+
     @Test
     public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarget() {
         int expectedWidth = 75;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
index ee6839cb1..2ec1dc152 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -1,14 +1,20 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -19,10 +25,8 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class DownsamplerTest {
     private File tempFile;
 
@@ -45,7 +49,7 @@ public void testAlwaysArgb8888() throws FileNotFoundException {
         Downsampler downsampler = Downsampler.AT_LEAST;
         InputStream is = new FileInputStream(tempFile);
         try {
-            Bitmap result = downsampler.decode(is, mock(BitmapPool.class), 100, 100, DecodeFormat.ALWAYS_ARGB_8888);
+            Bitmap result = downsampler.decode(is, mock(BitmapPool.class), 100, 100, DecodeFormat.PREFER_ARGB_8888);
             assertEquals(Bitmap.Config.ARGB_8888, result.getConfig());
         } finally {
             try {
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoderTest.java
new file mode 100644
index 000000000..07cd5490a
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoderTest.java
@@ -0,0 +1,58 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.os.ParcelFileDescriptor;
+
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class FileDescriptorBitmapDecoderTest {
+
+    private FileDescriptorBitmapDecoder decoder;
+    private BitmapPool bitmapPool;
+    private VideoBitmapDecoder videoDecoder;
+    private DecodeFormat decodeFormat;
+
+    @Before
+    public void setUp() {
+        bitmapPool = mock(BitmapPool.class);
+        videoDecoder = mock(VideoBitmapDecoder.class);
+        decodeFormat = DecodeFormat.DEFAULT;
+        decoder = new FileDescriptorBitmapDecoder(videoDecoder, bitmapPool, decodeFormat);
+    }
+
+    @Test
+    public void testHasValidId() {
+        assertEquals("FileDescriptorBitmapDecoder.com.bumptech.glide.load.data.bitmap", decoder.getId());
+    }
+
+    @Test
+    public void testReturnsBitmapFromWrappedDecoderAsResource() throws IOException {
+        ParcelFileDescriptor source = mock(ParcelFileDescriptor.class);
+        int width = 100;
+        int height = 200;
+        Bitmap expected = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_4444);
+        when(videoDecoder.decode(eq(source), eq(bitmapPool), eq(width), eq(height), eq(decodeFormat)))
+                .thenReturn(expected);
+
+        Resource<Bitmap> bitmapResource = decoder.decode(source, width, height);
+
+        assertEquals(expected, bitmapResource.get());
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index c2d857a46..555817553 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -1,23 +1,27 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class FitCenterTest {
     private FitCenterHarness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResourceTest.java
index 36ab05f35..f5bd0705e 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableResourceTest.java
@@ -1,5 +1,11 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
 import android.graphics.Bitmap;
 
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -9,14 +15,10 @@
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GlideBitmapDrawableResourceTest {
     private GlideBitmapDrawableResourceHarness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableTest.java
index 170534592..6f51023af 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableTest.java
@@ -1,5 +1,17 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
@@ -8,6 +20,7 @@
 import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -15,22 +28,10 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.instanceOf;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GlideBitmapDrawableTest {
 
     private Bitmap bitmap;
@@ -84,7 +85,7 @@ public void testReturnsNonNullConstantState() {
     @Test
     public void testConstantStateReturnsNewGlideBitmapDrawable() {
         Drawable newDrawable = drawable.getConstantState().newDrawable();
-        assertThat(newDrawable, instanceOf(GlideBitmapDrawable.class));
+        assertThat(newDrawable).isInstanceOf(GlideBitmapDrawable.class);
     }
 
     @Test
@@ -96,7 +97,7 @@ public void testDrawableReturnedByConstantStateWrapsSameBitmap() {
     @Test
     public void testMutatedDrawableIsGlideBitmapDrawable() {
         Drawable newDrawable = drawable.mutate();
-        assertThat(newDrawable, instanceOf(GlideBitmapDrawable.class));
+        assertThat(newDrawable).isInstanceOf(GlideBitmapDrawable.class);
     }
 
     @Test
@@ -116,7 +117,7 @@ public void testRetainsSameBoundsAcrossMutation() {
         Drawable mutated = drawable.mutate();
         mutated.draw(canvas);
 
-        assertThat(mutated.getBounds(), equalTo(bounds));
+        assertEquals(bounds, mutated.getBounds());
         verify(canvas, times(2)).drawBitmap(eq(bitmap), isNull(Rect.class), eq(bounds), any(Paint.class));
     }
 
@@ -132,7 +133,7 @@ public void testMutatedDrawableUsesNewPaint() {
             @Override
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 Paint paint = (Paint) invocation.getArguments()[3];
-                assertThat(paint.getAlpha(), equalTo(1));
+                assertEquals(1, paint.getAlpha());
                 return null;
             }
         }).when(canvas).drawBitmap(any(Bitmap.class), any(Rect.class), any(Rect.class), any(Paint.class));
@@ -154,7 +155,7 @@ public void testMutatedDrawableUsesNewColorFilter() {
             @Override
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 Paint paint = (Paint) invocation.getArguments()[3];
-                assertThat(paint.getColorFilter(), equalTo(originalColorFilter));
+                assertEquals(originalColorFilter, paint.getColorFilter());
                 return null;
             }
         }).when(canvas).drawBitmap(any(Bitmap.class), any(Rect.class), any(Rect.class), any(Paint.class));
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
index 73c848cbd..f82d085cd 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
@@ -1,14 +1,19 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.testutil.TestResourceUtil;
+
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-import static org.junit.Assert.assertEquals;
-
+@RunWith(JUnit4.class)
 public class ImageHeaderParserTest {
 
     private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK = new byte[] {(byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a,
@@ -62,7 +67,21 @@ public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
         InputStream is = new ByteArrayInputStream(new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 });
         ImageHeaderParser parser = new ImageHeaderParser(is);
         assertEquals(ImageType.UNKNOWN, parser.getType());
+    }
 
+    @Test
+    public void testReturnsUnknownTypeForEmptyData() throws IOException {
+        InputStream is = new ByteArrayInputStream(new byte[0]);
+        ImageHeaderParser parser = new ImageHeaderParser(is);
+        assertEquals(ImageType.UNKNOWN, parser.getType());
+    }
+
+    // Test for #286.
+    @Test
+    public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
+        InputStream is = TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg");
+        ImageHeaderParser parser = new ImageHeaderParser(is);
+        assertEquals(-1, parser.getOrientation());
     }
 
     private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoderTest.java
index adaa1f56d..99d28a941 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoderTest.java
@@ -1,29 +1,33 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 import android.os.ParcelFileDescriptor;
-import com.bumptech.glide.load.engine.Resource;
+
 import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
 import com.bumptech.glide.tests.Util;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ImageVideoBitmapDecoderTest {
     private ImageVideoDecoderHarness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
new file mode 100644
index 000000000..999e835f4
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -0,0 +1,293 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+
+@RunWith(JUnit4.class)
+public class RecyclableBufferedInputStreamTest {
+
+    private static final int DATA_SIZE = 30;
+    private static final int BUFFER_SIZE = 10;
+
+    private RecyclableBufferedInputStream stream;
+    private byte[] data;
+
+    @Before
+    public void setUp() {
+        data = new byte[DATA_SIZE];
+        for (int i = 0; i < DATA_SIZE; i++) {
+            data[i] = (byte) i;
+        }
+        InputStream wrapped = new ByteArrayInputStream(data);
+        stream = new RecyclableBufferedInputStream(wrapped, new byte[BUFFER_SIZE]);
+    }
+
+    @Test
+    public void testReturnsTrueForMarkSupported() {
+        assertTrue(stream.markSupported());
+    }
+
+    @Test
+    public void testCanReadIndividualBytes() throws IOException {
+        for (int i = 0; i < data.length; i++) {
+            assertEquals(i, stream.read());
+        }
+        assertEquals(-1, stream.read());
+    }
+
+    @Test
+    public void testCanReadBytesInBulkLargerThanBufferSize() throws IOException {
+        byte[] buffer = new byte[DATA_SIZE];
+        assertEquals(DATA_SIZE, stream.read(buffer, 0, DATA_SIZE));
+        for (int i = 0; i < DATA_SIZE; i++) {
+            assertEquals(i, buffer[i]);
+        }
+    }
+
+    @Test
+    public void testCanReadBytesInBulkSmallerThanBufferSize() throws IOException {
+        int toRead = BUFFER_SIZE / 2;
+        byte[] buffer = new byte[toRead];
+        assertEquals(toRead, stream.read(buffer, 0, toRead));
+        for (int i = 0; i < toRead; i++) {
+            assertEquals(i, buffer[i]);
+        }
+    }
+
+    @Test
+    public void testReadingZeroBytesIntoBufferReadsZeroBytes() throws IOException {
+        // Make sure the next value is not 0.
+        stream.read();
+        byte[] buffer = new byte[BUFFER_SIZE];
+        assertEquals(0, stream.read(buffer, 0, 0));
+
+        for (int i = 0; i < BUFFER_SIZE; i++) {
+            assertEquals(0, buffer[i]);
+        }
+    }
+
+    @Test
+    public void testCanReadIntoBufferLargerThanDataSize() throws IOException {
+        int toRead = DATA_SIZE * 2;
+        byte[] buffer = new byte[toRead];
+        assertEquals(DATA_SIZE, stream.read(buffer, 0, toRead));
+        for (int i = 0; i < DATA_SIZE; i++) {
+            assertEquals(i, buffer[i]);
+        }
+        for (int i = DATA_SIZE; i < toRead; i++) {
+            assertEquals(0, buffer[i]);
+        }
+    }
+
+    @Test
+    public void testCanReadBytesInBulkWithLimit() throws IOException {
+        int toRead = BUFFER_SIZE / 2;
+        byte[] buffer = new byte[BUFFER_SIZE];
+        assertEquals(toRead, stream.read(buffer, 0, toRead));
+
+        // 0, 1, 2, 3, 4, 0, 0, 0, 0, 0
+        for (int i = 0; i < toRead; i++) {
+            assertEquals(i, buffer[i]);
+        }
+        for (int i = toRead; i < BUFFER_SIZE; i++) {
+            assertEquals(0, buffer[i]);
+        }
+    }
+
+    @Test
+    public void testCanReadBytesInBulkWithOffset() throws IOException {
+        int toRead = BUFFER_SIZE / 2;
+        byte[] buffer = new byte[BUFFER_SIZE];
+        assertEquals(toRead, stream.read(buffer, BUFFER_SIZE - toRead, toRead));
+        // 0, 0, 0, 0, 0, 0, 1, 2, 3, 4
+        for (int i = 0; i < toRead; i++) {
+            assertEquals(0, buffer[i]);
+        }
+        for (int i = toRead; i < BUFFER_SIZE; i++) {
+            assertEquals(i - toRead, buffer[i]);
+        }
+    }
+
+    @Test
+    public void testCanReadBytesInBulkWhenSomeButNotAllBytesAreInBuffer() throws IOException {
+        stream.read();
+        byte[] buffer = new byte[BUFFER_SIZE];
+        assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
+        for (int i = 1; i < BUFFER_SIZE + 1; i++) {
+            assertEquals(i, buffer[i - 1]);
+        }
+    }
+
+    @Test
+    public void testCanSkipBytes() throws IOException {
+        int toSkip = data.length / 2;
+        assertEquals(toSkip, stream.skip(toSkip));
+        for (int i = toSkip; i < data.length; i++) {
+            assertEquals(i, stream.read());
+        }
+        assertEquals(-1, stream.read());
+    }
+
+    @Test
+    public void testSkipReturnsZeroIfSkipByteCountIsZero() throws IOException {
+        assertEquals(0, stream.skip(0));
+        assertEquals(0, stream.read());
+    }
+
+    @Test
+    public void testSkipReturnsZeroIfSkipByteCountIsNegative() throws IOException {
+        assertEquals(0, stream.skip(-13));
+        assertEquals(0, stream.read());
+    }
+
+    @Test
+    public void testCloseClosesWrappedStream() throws IOException {
+        InputStream wrapped = mock(InputStream.class);
+        stream = new RecyclableBufferedInputStream(wrapped, new byte[1]);
+        stream.close();
+        verify(wrapped).close();
+    }
+
+    @Test
+    public void testCanSafelyBeClosedMultipleTimes() throws IOException {
+        InputStream wrapped = mock(InputStream.class);
+        stream = new RecyclableBufferedInputStream(wrapped, new byte[1]);
+        stream.close();
+        stream.close();
+        stream.close();
+
+        verify(wrapped, times(1)).close();
+    }
+
+    @Test
+    public void testCanMarkAndReset() throws IOException {
+        byte[] buffer = new byte[BUFFER_SIZE];
+        stream.mark(BUFFER_SIZE);
+        assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
+        for (int i = 0; i < BUFFER_SIZE; i++) {
+            assertEquals(i, buffer[i]);
+        }
+        Arrays.fill(buffer, (byte) 0);
+        stream.reset();
+
+        assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
+        for (int i = 0; i < BUFFER_SIZE; i++) {
+            assertEquals(i, buffer[i]);
+        }
+    }
+
+    @Test
+    public void testCanResetRepeatedlyAfterMarking() throws IOException {
+        byte[] buffer = new byte[BUFFER_SIZE];
+        stream.mark(BUFFER_SIZE);
+        for (int repeat = 0; repeat < 10; repeat++) {
+            assertEquals(BUFFER_SIZE, stream.read(buffer, 0, BUFFER_SIZE));
+            for (int i = 0; i < BUFFER_SIZE; i++) {
+                assertEquals(i, buffer[i]);
+            }
+            stream.reset();
+        }
+    }
+
+    @Test
+    public void testCanMarkInMiddleOfBufferAndStillReadUpToBufferLengthBeforeResetting() throws IOException {
+        int markPos = BUFFER_SIZE / 2;
+        for (int i = 0; i < markPos; i++) {
+            stream.read();
+        }
+        stream.mark(BUFFER_SIZE);
+
+        for (int i = 0; i < BUFFER_SIZE; i++) {
+            stream.read();
+        }
+
+        stream.reset();
+        assertEquals(markPos, stream.read());
+    }
+
+    @Test
+    public void testAvailableReturnsWrappedAvailableIfNoBytesRead() throws IOException {
+        assertEquals(DATA_SIZE, stream.available());
+    }
+
+    @Test
+    public void testAvailableIncludesDataInBufferAndWrappedAvailableIfBytesRead() throws IOException {
+        stream.read();
+        assertEquals(DATA_SIZE - 1, stream.available());
+    }
+
+    @Test(expected = IOException.class)
+    public void testCloseThrowsIfWrappedStreamThrowsOnClose() throws IOException {
+        InputStream wrapped = mock(InputStream.class);
+        doThrow(new IOException()).when(wrapped).close();
+        stream = new RecyclableBufferedInputStream(wrapped, new byte[1]);
+        stream.close();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsIfGivenBufferIsNull() {
+        new RecyclableBufferedInputStream(mock(InputStream.class), null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsIfGivenBufferHasZeroSize() {
+        new RecyclableBufferedInputStream(mock(InputStream.class), new byte[0]);
+    }
+
+    @Test(expected = IOException.class)
+    public void testAvailableThrowsIfStreamIsClosed() throws IOException {
+        stream.close();
+        stream.available();
+    }
+
+    @Test(expected = IOException.class)
+    public void testReadThrowsIfStreamIsClosed() throws IOException {
+        stream.close();
+        stream.read();
+    }
+
+    @Test(expected = IOException.class)
+    public void testReadBulkThrowsIfStreamIsClosed() throws IOException {
+        stream.close();
+        stream.read(new byte[1], 0, 1);
+    }
+
+    @Test(expected = IOException.class)
+    public void testResetThrowsIfStreamIsClosed() throws IOException {
+        stream.close();
+        stream.reset();
+    }
+
+    @Test(expected = IOException.class)
+    public void testSkipThrowsIfStreamIsClosed() throws IOException {
+        stream.close();
+        stream.skip(10);
+    }
+
+    @Test(expected = RecyclableBufferedInputStream.InvalidMarkException.class)
+    public void testResetThrowsIfMarkNotSet() throws IOException {
+        stream.reset();
+    }
+
+    @Test(expected = RecyclableBufferedInputStream.InvalidMarkException.class)
+    public void testResetThrowsIfMarkIsInvalid() throws IOException {
+        stream.mark(1);
+        stream.read(new byte[BUFFER_SIZE], 0, BUFFER_SIZE);
+        stream.read();
+        stream.reset();
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java
index 1546698c8..7f2dfb5ad 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java
@@ -1,27 +1,30 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
-import com.bumptech.glide.load.engine.Resource;
+
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class StreamBitmapDecoderTest {
     private DecoderHarness harness;
 
@@ -50,15 +53,15 @@ public void testHasValidId() {
         when(harness.downsampler.getId()).thenReturn(downsamplerId);
 
         String actualId = harness.decoder.getId();
-        assertThat(actualId, containsString(downsamplerId));
-        assertThat(actualId, containsString(harness.decodeFormat.toString()));
-        assertThat(actualId, containsString(Util.getExpectedClassId(StreamBitmapDecoder.class)));
+        assertThat(actualId).contains(downsamplerId);
+        assertThat(actualId).contains(harness.decodeFormat.toString());
+        assertThat(actualId).contains(Util.getExpectedClassId(StreamBitmapDecoder.class));
     }
 
     private static class DecoderHarness {
         Downsampler downsampler = mock(Downsampler.class);
         BitmapPool bitmapPool = mock(BitmapPool.class);
-        DecodeFormat decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;
+        DecodeFormat decodeFormat = DecodeFormat.PREFER_ARGB_8888;
         InputStream source = new ByteArrayInputStream(new byte[0]);
         int width = 100;
         int height = 100;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
new file mode 100644
index 000000000..42e761a37
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -0,0 +1,443 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.Range;
+
+import android.graphics.Bitmap;
+import android.graphics.Matrix;
+import android.media.ExifInterface;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { TransformationUtilsTest.AlphaShadowBitmap.class })
+public class TransformationUtilsTest {
+
+    @Test
+    public void testFitCenterWithWideBitmap() {
+        final int maxSide = 500;
+
+        Bitmap wide = Bitmap.createBitmap(2000, 100, Bitmap.Config.ARGB_8888);
+
+        Bitmap transformed = TransformationUtils.fitCenter(wide, mock(BitmapPool.class), maxSide, maxSide);
+
+        assertHasOriginalAspectRatio(wide, transformed);
+        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+    }
+
+    @Test
+    public void testFitCenterWithSmallWideBitmap() {
+        final int maxSide = 500;
+
+        Bitmap smallWide = Bitmap.createBitmap(400, 40, Bitmap.Config.ARGB_8888);
+
+        Bitmap transformed = TransformationUtils.fitCenter(smallWide, mock(BitmapPool.class), maxSide, maxSide);
+
+        assertHasOriginalAspectRatio(smallWide, transformed);
+        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+    }
+
+    @Test
+    public void testFitCenterWithTallBitmap() {
+        final int maxSide = 500;
+
+        Bitmap tall = Bitmap.createBitmap(65, 3000, Bitmap.Config.ARGB_8888);
+
+        Bitmap transformed = TransformationUtils.fitCenter(tall, mock(BitmapPool.class), maxSide, maxSide);
+
+        assertHasOriginalAspectRatio(tall, transformed);
+        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+    }
+
+    @Test
+    public void testFitCenterWithSmallTallBitmap() {
+        final int maxSide = 500;
+
+        Bitmap smallTall = Bitmap.createBitmap(10, 400, Bitmap.Config.ARGB_8888);
+
+        Bitmap transformed = TransformationUtils.fitCenter(smallTall, mock(BitmapPool.class), maxSide, maxSide);
+
+        assertHasOriginalAspectRatio(smallTall, transformed);
+        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+    }
+
+    @Test
+    public void testFitCenterWithSquareBitmap() {
+        final int maxSide = 500;
+
+        Bitmap square = Bitmap.createBitmap(600, 600, Bitmap.Config.ARGB_8888);
+
+        Bitmap transformed = TransformationUtils.fitCenter(square, mock(BitmapPool.class), maxSide, maxSide);
+
+        assertHasOriginalAspectRatio(square, transformed);
+        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+    }
+
+    @Test
+    public void testFitCenterWithTooSmallSquareBitmap() {
+        final int maxSide = 500;
+
+        Bitmap smallSquare = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+        Bitmap transformed = TransformationUtils.fitCenter(smallSquare, mock(BitmapPool.class), maxSide, maxSide);
+
+        assertHasOriginalAspectRatio(smallSquare, transformed);
+        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
+    }
+
+    // Test for Issue #195.
+    @Test
+    public void testFitCenterUsesFloorInsteadOfRoundingForOutputBitmapSize() {
+        Bitmap toTransform = Bitmap.createBitmap(1230, 1640, Bitmap.Config.RGB_565);
+
+        Bitmap transformed = TransformationUtils.fitCenter(toTransform, mock(BitmapPool.class), 1075, 1366);
+
+        assertEquals(1024, transformed.getWidth());
+        assertEquals(1366, transformed.getHeight());
+    }
+
+    @Test
+    public void testFitCenterReturnsGivenBitmapIfGivenBitmapMatchesExactly() {
+        Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
+        Bitmap transformed = TransformationUtils.fitCenter(toFit, null, toFit.getWidth(), toFit.getHeight());
+        assertTrue(toFit == transformed);
+    }
+
+    @Test
+    public void testFitCenterReturnsGivenBitmapIfGivenBitmapWidthMatchesExactly() {
+        Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
+        Bitmap transformed = TransformationUtils.fitCenter(toFit, null, toFit.getWidth(), toFit.getHeight() * 2);
+        assertTrue(toFit == transformed);
+    }
+
+    @Test
+    public void testFitCenterReturnsGivenBitmapIfGivenBitmapHeightMatchesExactly() {
+        Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
+        Bitmap transformed = TransformationUtils.fitCenter(toFit, null, toFit.getWidth() * 2, toFit.getHeight());
+        assertTrue(toFit == transformed);
+    }
+
+    @Test
+    public void testCenterCropReturnsNullIfGivenBitmapIsNull() {
+        Bitmap transformed = TransformationUtils.centerCrop(null /*recycled*/, null /*toCrop*/, 100, 100);
+        assertNull(transformed);
+    }
+
+    @Test
+    public void testCenterCropReturnsGivenBitmapIfGivenBitmapExactlyMatchesGivenDimensions() {
+        Bitmap toCrop = Bitmap.createBitmap(200, 300, Bitmap.Config.ARGB_8888);
+        Bitmap transformed = TransformationUtils.centerCrop(null /*recycled*/, toCrop, toCrop.getWidth(),
+                toCrop.getHeight());
+
+        // Robolectric incorrectly implements equals() for Bitmaps, we want the original object not just an equivalent.
+        assertTrue(toCrop == transformed);
+    }
+
+    @Test
+    public void testFitCenterHandlesBitmapsWithNullConfigs() {
+      Bitmap toFit = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+      Robolectric.shadowOf(toFit).setConfig(null);
+      Bitmap transformed = TransformationUtils.fitCenter(toFit, mock(BitmapPool.class), 50, 50);
+      assertEquals(Bitmap.Config.ARGB_8888, transformed.getConfig());
+    }
+
+    @Test
+    public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {
+        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+
+        toReuse.setHasAlpha(false);
+        toTransform.setHasAlpha(true);
+
+        Bitmap result = TransformationUtils.centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());
+
+        assertEquals(toReuse, result);
+        assertTrue(result.hasAlpha());
+    }
+
+    @Test
+    public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
+        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+
+        toReuse.setHasAlpha(true);
+        toTransform.setHasAlpha(false);
+
+        Bitmap result = TransformationUtils.centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());
+
+        assertEquals(toReuse, result);
+        assertFalse(result.hasAlpha());
+    }
+
+    @Test
+    public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
+        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+        toTransform.setHasAlpha(true);
+
+        Bitmap result = TransformationUtils.centerCrop(null, toTransform, toTransform.getWidth() / 2,
+                toTransform.getHeight() / 2);
+
+        assertTrue(result.hasAlpha());
+    }
+
+    @Test
+    public void testCenterCropHandlesBitmapsWithNullConfigs() {
+      Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+      Robolectric.shadowOf(toTransform).setConfig(null);
+
+      Bitmap transformed = TransformationUtils.centerCrop(null /*recycled*/, toTransform, 50, 50);
+
+      assertEquals(Bitmap.Config.ARGB_8888, transformed.getConfig());
+    }
+
+    @Test
+    public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
+        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+        toTransform.setHasAlpha(false);
+
+        Bitmap result = TransformationUtils.centerCrop(null, toTransform, toTransform.getWidth() / 2,
+                toTransform.getHeight() / 2);
+
+        assertFalse(result.hasAlpha());
+    }
+
+    @Test
+    public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {
+        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+        BitmapPool bitmapPool = mock(BitmapPool.class);
+        when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
+                .thenReturn(toReuse);
+
+        toReuse.setHasAlpha(false);
+        toTransform.setHasAlpha(true);
+
+        Bitmap result = TransformationUtils.fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());
+
+        assertEquals(toReuse, result);
+        assertTrue(result.hasAlpha());
+    }
+
+    @Test
+    public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
+        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+
+        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+        BitmapPool bitmapPool = mock(BitmapPool.class);
+        when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
+                .thenReturn(toReuse);
+
+        toReuse.setHasAlpha(true);
+        toTransform.setHasAlpha(false);
+
+        Bitmap result = TransformationUtils.fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());
+
+        assertEquals(toReuse, result);
+        assertFalse(result.hasAlpha());
+    }
+
+    @Test
+    public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
+        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        BitmapPool pool = mock(BitmapPool.class);
+
+        toTransform.setHasAlpha(true);
+
+        Bitmap result = TransformationUtils.fitCenter(toTransform, pool, toTransform.getWidth() / 2,
+                toTransform.getHeight() / 2);
+
+        assertTrue(result.hasAlpha());
+    }
+
+    @Test
+    public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
+        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        BitmapPool pool = mock(BitmapPool.class);
+
+        toTransform.setHasAlpha(false);
+
+        Bitmap result = TransformationUtils.fitCenter(toTransform, pool, toTransform.getWidth() / 2,
+                toTransform.getHeight() / 2);
+
+        assertFalse(result.hasAlpha());
+    }
+
+    private static void assertHasOriginalAspectRatio(Bitmap original, Bitmap transformed) {
+        double originalAspectRatio = (double) original.getWidth() / (double) original.getHeight();
+        double transformedAspectRatio = (double) transformed.getWidth() / (double) transformed.getHeight();
+
+        assertThat(transformedAspectRatio).isIn(Range.open(originalAspectRatio - 0.05f, originalAspectRatio + 0.05f));
+    }
+
+    private static void assertBitmapFitsExactlyWithinBounds(int maxSide, Bitmap bitmap) {
+        final int width = bitmap.getWidth();
+        final int height = bitmap.getHeight();
+
+        assertThat(width).isIn(Range.atMost(maxSide));
+        assertThat(height).isIn(Range.atMost(maxSide));
+
+        assertTrue("one side must match maxSide", width == maxSide || height == maxSide);
+    }
+
+    @Test
+    public void testGetExifOrientationDegrees() {
+        assertEquals(0, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_NORMAL));
+        assertEquals(90, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSPOSE));
+        assertEquals(90, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_90));
+        assertEquals(180, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_180));
+        assertEquals(180, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_FLIP_VERTICAL));
+        assertEquals(270, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSVERSE));
+        assertEquals(270, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_270));
+    }
+
+    @Test
+    public void testRotateImage() {
+        Bitmap toRotate = Bitmap.createBitmap(2, 2, Bitmap.Config.ARGB_8888);
+
+        Bitmap zero = TransformationUtils.rotateImage(toRotate, 0);
+        assertTrue(toRotate == zero);
+
+        Bitmap ninety = TransformationUtils.rotateImage(toRotate, 90);
+        assertTrue(Robolectric.shadowOf(ninety).getDescription().contains("rotate=90.0"));
+        assertEquals(toRotate.getWidth(), toRotate.getHeight());
+    }
+
+    @Test
+    public void testRotateImageExifReturnsGivenBitmapIfRotationIsNormal() {
+        BitmapPool bitmapPool = mock(BitmapPool.class);
+        Bitmap toRotate = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
+        // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want not just an
+        // identical Bitmap, but our original Bitmap object back.
+        Bitmap rotated = TransformationUtils.rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_NORMAL);
+        assertTrue(toRotate == rotated);
+    }
+
+    @Test
+    public void testRotateImageExifReturnsGivenBitmapIfRotationIsUndefined() {
+        BitmapPool bitmapPool = mock(BitmapPool.class);
+        Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+        // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want not just an
+        // identical Bitmap, but our original Bitmap object back.
+        Bitmap rotated = TransformationUtils.rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_UNDEFINED);
+        assertTrue(toRotate == rotated);
+    }
+
+    @Test
+    public void testRotateImageExifReturnsGivenBitmapIfOrientationIsInvalid() {
+        BitmapPool bitmapPool = mock(BitmapPool.class);
+        Bitmap toRotate = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
+        // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want not just an
+        // identical Bitmap, but our original Bitmap object back.
+        Bitmap rotated = TransformationUtils.rotateImageExif(toRotate, bitmapPool, -1);
+        assertTrue(toRotate == rotated);
+    }
+
+    @Test
+    public void testRotateImageExifHandlesEmptyBitmapPool() {
+        Bitmap toRotate = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_4444);
+        BitmapPool bitmapPool = mock(BitmapPool.class);
+        assertNotNull(TransformationUtils.rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_ROTATE_90));
+    }
+
+    @Test
+    public void testRotateImageExifHandlesBitmapsWithNullConfigs() {
+      Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+      Robolectric.shadowOf(toRotate).setConfig(null);
+      BitmapPool bitmapPool = mock(BitmapPool.class);
+      Bitmap rotated = TransformationUtils.rotateImageExif(toRotate, bitmapPool,
+          ExifInterface.ORIENTATION_ROTATE_180);
+      assertEquals(Bitmap.Config.ARGB_8888, rotated.getConfig());
+    }
+
+    @Test
+    public void testInitializeMatrixSetsScaleIfFlipHorizontal() {
+        Matrix matrix = mock(Matrix.class);
+        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_HORIZONTAL, matrix);
+        verify(matrix).setScale(-1, 1);
+    }
+
+    @Test
+    public void testInitializeMatrixSetsScaleAndRotateIfFlipVertical() {
+        Matrix matrix = mock(Matrix.class);
+        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_VERTICAL, matrix);
+        verify(matrix).setRotate(180);
+        verify(matrix).postScale(-1, 1);
+    }
+
+    @Test
+    public void testInitializeMatrixSetsScaleAndRotateIfTranspose() {
+        Matrix matrix = mock(Matrix.class);
+        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_TRANSPOSE, matrix);
+        verify(matrix).setRotate(90);
+        verify(matrix).postScale(-1, 1);
+    }
+
+    @Test
+    public void testInitializeMatrixSetsScaleAndRotateIfTransverse() {
+        Matrix matrix = mock(Matrix.class);
+        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_TRANSVERSE, matrix);
+        verify(matrix).setRotate(-90);
+        verify(matrix).postScale(-1, 1);
+    }
+
+    @Test
+    public void testInitializeMatrixSetsRotateOnRotation() {
+        Matrix matrix = mock(Matrix.class);
+        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_90, matrix);
+        verify(matrix).setRotate(90);
+        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_180, matrix);
+        verify(matrix).setRotate(180);
+        TransformationUtils.initializeMatrixForRotation(ExifInterface.ORIENTATION_ROTATE_270, matrix);
+        verify(matrix).setRotate(-90);
+    }
+
+    @Implements(Bitmap.class)
+    public static class AlphaShadowBitmap extends ShadowBitmap {
+
+        private boolean hasAlpha;
+
+        @Implementation
+        public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
+          // Robolectric doesn't match the framework behavior with null configs, so we have to do
+          // so here.
+          if (config == null) {
+            throw new NullPointerException("config must not be null");
+          }
+          return ShadowBitmap.createBitmap(width, height, config);
+        }
+
+        @Implementation
+        public void setHasAlpha(boolean hasAlpha) {
+            this.hasAlpha = hasAlpha;
+        }
+
+        @Implementation
+        public boolean hasAlpha() {
+            return hasAlpha;
+        }
+    }
+}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
index a09f39bdc..edb54aeb9 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
@@ -1,26 +1,32 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.FileDescriptor;
 import java.io.IOException;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class VideoBitmapDecoderTest {
     private BitmapPool bitmapPool;
     private DecodeFormat decodeFormat;
@@ -32,7 +38,7 @@
     @Before
     public void setup() {
         bitmapPool = mock(BitmapPool.class);
-        decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;
+        decodeFormat = DecodeFormat.PREFER_ARGB_8888;
         resource = mock(ParcelFileDescriptor.class);
         factory = mock(VideoBitmapDecoder.MediaMetadataRetrieverFactory.class);
         retriever = mock(MediaMetadataRetriever.class);
@@ -76,4 +82,41 @@ public void testClosesResource() throws IOException {
     public void testHasValidId() {
         Util.assertClassHasValidId(VideoBitmapDecoder.class, decoder.getId());
     }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsExceptionIfInitializedWithNegativeFrame() {
+        new VideoBitmapDecoder(-1);
+    }
+
+    @Test
+    public void testSpecifiesThumbnailFrameIfInitializedWithFrameNumber() throws IOException {
+        int frame = 5;
+        decoder = new VideoBitmapDecoder(new VideoBitmapDecoder.MediaMetadataRetrieverFactory()  {
+          @Override
+          public MediaMetadataRetriever build() {
+            return factory.build();
+          }
+        }, frame);
+
+        decoder.decode(resource, bitmapPool, 100, 100, decodeFormat);
+
+        verify(retriever).getFrameAtTime(5);
+        verify(retriever, never()).getFrameAtTime();
+    }
+
+    @Test
+    public void testDoesNotSpecifyThumbnailFrameIfInitializedWithoutFrameNumber()
+        throws IOException {
+      decoder = new VideoBitmapDecoder(new VideoBitmapDecoder.MediaMetadataRetrieverFactory()  {
+        @Override
+        public MediaMetadataRetriever build() {
+          return factory.build();
+        }
+      });
+
+      decoder.decode(resource, bitmapPool, 100, 100, decodeFormat);
+
+      verify(retriever).getFrameAtTime();
+      verify(retriever, never()).getFrameAtTime(anyLong());
+    }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
index 600435675..7470be0db 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
@@ -1,9 +1,12 @@
 package com.bumptech.glide.load.resource.bytes;
 
-import org.junit.Test;
-
 import static org.junit.Assert.assertEquals;
 
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
 public class BytesResourceTest {
 
     @Test
@@ -22,4 +25,9 @@ public void testReturnsSizeOfGivenBytes() {
         assertEquals(bytes.length, resource.getSize());
     }
 
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfGivenNullBytes() {
+        new BytesResource(null);
+    }
+
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
index 574bcb31b..3dbc3a079 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -1,5 +1,11 @@
 package com.bumptech.glide.load.resource.drawable;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.drawable.Drawable;
@@ -10,13 +16,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class DrawableResourceTest {
     private TestDrawable drawable;
     private DrawableResource<TestDrawable> resource;
@@ -36,24 +39,39 @@ public void recycle() { }
     }
 
     @Test
-    public void testReturnsDrawableOnFirstGet() {
-        assertEquals(drawable, resource.get());
+    public void testDoesNotReturnOriginalDrawableOnGet() {
+        when(drawable.getConstantState()).thenReturn(mock(Drawable.ConstantState.class));
+        assertNotEquals(drawable, resource.get());
     }
 
     @Test
-    public void testReturnsNewDrawableOnSecondGet() {
+    public void testReturnsNewDrawableOnGet() {
         GifDrawable expected = mock(GifDrawable.class);
         Drawable.ConstantState constantState = mock(Drawable.ConstantState.class);
         when(constantState.newDrawable()).thenReturn(expected);
         when(drawable.getConstantState()).thenReturn(constantState);
 
-        assertEquals(drawable, resource.get());
         assertEquals(expected, resource.get());
 
         verify(drawable).getConstantState();
         verify(constantState).newDrawable();
     }
 
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfDrawableIsNull() {
+        new DrawableResource<TestDrawable>(null) {
+            @Override
+            public int getSize() {
+                return 0;
+            }
+
+            @Override
+            public void recycle() {
+
+            }
+        };
+    }
+
     /** Just to have a type to test with which is not directly Drawable */
     private static class TestDrawable extends Drawable {
         @Override
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
index 9dcc0ef63..7945e50c6 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
@@ -1,15 +1,18 @@
 package com.bumptech.glide.load.resource.file;
 
+import static org.junit.Assert.assertEquals;
+
 import com.bumptech.glide.load.engine.Resource;
 
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.File;
 import java.io.IOException;
 
-import static org.junit.Assert.assertEquals;
-
+@RunWith(JUnit4.class)
 public class FileDecoderTest {
 
     private FileDecoder decoder;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
index d97ba649d..54bab1508 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
@@ -1,12 +1,15 @@
 package com.bumptech.glide.load.resource.file;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.File;
 
-import static org.junit.Assert.assertEquals;
-
+@RunWith(JUnit4.class)
 public class FileResourceTest {
 
     private File file;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileToStreamDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileToStreamDecoderTest.java
index 292f1e1f2..54be3238f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileToStreamDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/file/FileToStreamDecoderTest.java
@@ -1,24 +1,27 @@
 package com.bumptech.glide.load.resource.file;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class FileToStreamDecoderTest {
 
     private ResourceDecoder<InputStream, Object> streamDecoder;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
index 7ac6074e1..4d930f267 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
@@ -1,20 +1,23 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
+
 import com.bumptech.glide.util.Util;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GifDrawableResourceTest {
     private GifDrawable drawable;
     private GifDrawableResource resource;
@@ -25,22 +28,6 @@ public void setUp() {
         resource = new GifDrawableResource(drawable);
     }
 
-    @Test
-    public void testReturnsDrawableOnFirstGet() {
-        assertEquals(drawable, resource.get());
-    }
-
-    @Test
-    public void testReturnsNewDrawableOnSecondGet() {
-        GifDrawable expected = mock(GifDrawable.class);
-        Drawable.ConstantState constantState = mock(Drawable.ConstantState.class);
-        when(constantState.newDrawable()).thenReturn(expected);
-        when(drawable.getConstantState()).thenReturn(constantState);
-
-        resource.get();
-        assertEquals(expected, resource.get());
-    }
-
     @Test
     public void testReturnsDrawableSizePlusFirstFrameSize() {
         final int size = 2134;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index b0bb1fb2d..77aca52a5 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -1,16 +1,36 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+import android.os.Build;
+
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.GlideDrawable;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,41 +38,38 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = GlideShadowLooper.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
 public class GifDrawableTest {
     private GifDecoder gifDecoder;
     private GifDrawable drawable;
-    private GifFrameManager frameManager = mock(GifFrameManager.class);
-    private Drawable.Callback cb = mock(Drawable.Callback.class);
+    private Drawable.Callback cb;
     private int frameHeight;
     private int frameWidth;
     private Bitmap firstFrame;
     private BitmapPool bitmapPool;
+    private int initialSdkVersion;
+    private GifFrameLoader frameLoader;
+    private Paint paint;
 
     @Before
     public void setUp() {
         frameWidth = 120;
         frameHeight = 450;
+        cb = mock(Drawable.Callback.class);
         gifDecoder = mock(GifDecoder.class);
         firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
         bitmapPool = mock(BitmapPool.class);
-        drawable = new GifDrawable(gifDecoder, frameManager, firstFrame, bitmapPool);
+        frameLoader = mock(GifFrameLoader.class);
+        paint = mock(Paint.class);
+        drawable = new GifDrawable(gifDecoder, frameLoader, firstFrame, bitmapPool, paint);
         drawable.setCallback(cb);
+        initialSdkVersion = Build.VERSION.SDK_INT;
+    }
+
+    @After
+    public void tearDown() {
+        Util.setSdkVersionInt(initialSdkVersion);
     }
 
     @Test
@@ -60,26 +77,38 @@ public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
         Canvas canvas = mock(Canvas.class);
         drawable.draw(canvas);
 
-        verify(canvas).drawBitmap(eq(firstFrame), anyInt(), anyInt(), any(Paint.class));
+        verify(canvas).drawBitmap(eq(firstFrame), anyRect(), anyRect(), anyPaint());
     }
 
     @Test
     public void testShouldNotDrawNullBitmapFrame() {
         Canvas canvas = mock(Canvas.class);
-        drawable = new GifDrawable(gifDecoder, frameManager, firstFrame, bitmapPool);
-        drawable.onFrameRead(null, 0);
+        drawable = new GifDrawable(gifDecoder, frameLoader, firstFrame, bitmapPool, paint);
+        drawable.onFrameReady(0);
+        when(frameLoader.getCurrentFrame()).thenReturn(null);
         drawable.draw(canvas);
 
-        verify(canvas).drawBitmap(eq(firstFrame), anyInt(), anyInt(), any(Paint.class));
-        verify(canvas, never()).drawBitmap((Bitmap) isNull(), anyInt(), anyInt(), any(Paint.class));
+        verify(canvas).drawBitmap(eq(firstFrame), anyRect(), anyRect(), anyPaint());
+        verify(canvas, never()).drawBitmap((Bitmap) isNull(), anyRect(), anyRect(), anyPaint());
     }
 
     @Test
     public void testDoesNotDrawNullFirstFrame() {
-        drawable = new GifDrawable(gifDecoder, frameManager, null, bitmapPool);
+        drawable = new GifDrawable(gifDecoder, frameLoader, null, bitmapPool, paint);
         Canvas canvas = mock(Canvas.class);
 
-        verify(canvas, never()).drawBitmap(any(Bitmap.class), anyInt(), anyInt(), any(Paint.class));
+        verify(canvas, never()).drawBitmap(any(Bitmap.class), anyRect(), anyRect(), anyPaint());
+    }
+
+    @Test
+    public void testDoesDrawCurrentFrameIfOneIsAvailable() {
+        Canvas canvas = mock(Canvas.class);
+        Bitmap currentFrame = Bitmap.createBitmap(100123, 123141, Bitmap.Config.ARGB_4444);
+        when(frameLoader.getCurrentFrame()).thenReturn(currentFrame);
+
+        drawable.draw(canvas);
+        verify(canvas).drawBitmap(eq(currentFrame), anyRect(), anyRect(), anyPaint());
+        verify(canvas, never()).drawBitmap(eq(firstFrame), anyRect(), anyRect(), anyPaint());
     }
 
     @Test
@@ -87,14 +116,14 @@ public void testRequestsNextFrameOnStart() {
         drawable.setVisible(true, true);
         drawable.start();
 
-        verify(frameManager).getNextFrame(eq(drawable));
+        verify(frameLoader).start();
     }
 
     @Test
     public void testRequestsNextFrameOnStartWithoutCallToSetVisible() {
         drawable.start();
 
-        verify(frameManager).getNextFrame(eq(drawable));
+        verify(frameLoader).start();
     }
 
     @Test
@@ -102,7 +131,7 @@ public void testDoesNotRequestNextFrameOnStartIfGotCallToSetVisibleWithVisibleFa
         drawable.setVisible(false, false);
         drawable.start();
 
-        verify(frameManager, never()).getNextFrame(any(GifFrameManager.FrameCallback.class));
+        verify(frameLoader, never()).start();
     }
 
     @Test
@@ -111,7 +140,7 @@ public void testDoesNotRequestNextFrameOnStartIfHasSingleFrame() {
         drawable.setVisible(true, false);
         drawable.start();
 
-        verify(frameManager, never()).getNextFrame(any(GifFrameManager.FrameCallback.class));
+        verify(frameLoader, never()).start();
     }
 
     @Test
@@ -137,7 +166,7 @@ public void testShouldNotScheduleItselfIfAlreadyRunning() {
         drawable.start();
         drawable.start();
 
-        verify(frameManager, times(1)).getNextFrame(eq(drawable));
+        verify(frameLoader, times(1)).start();
     }
 
     @Test
@@ -154,45 +183,60 @@ public void testReturnsTrueFromIsRunningWhenRunning() {
     }
 
     @Test
-    public void testStartsLoadingNextFrameWhenCurrentFinishes() {
+    public void testInvalidatesSelfWhenFrameReady() {
         drawable.setIsRunning(true);
-        drawable.onFrameRead(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), 0);
+        drawable.onFrameReady(0);
 
-        verify(frameManager).getNextFrame(eq(drawable));
+        verify(cb).invalidateDrawable(eq(drawable));
     }
 
     @Test
-    public void testInvalidatesSelfWhenFrameReady() {
+    public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfHasNoCallback() {
         drawable.setIsRunning(true);
-        drawable.onFrameRead(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565), 0);
+        drawable.setCallback(null);
+        drawable.onFrameReady(0);
 
-        verify(cb).invalidateDrawable(eq(drawable));
+        verify(frameLoader).stop();
     }
 
     @Test
-    public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfNotRunning() {
-        drawable.setIsRunning(false);
-        drawable.onFrameRead(Bitmap.createBitmap(10, 100, Bitmap.Config.ARGB_8888), 0);
+    public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+        drawable.setIsRunning(true);
+        drawable.setCallback(null);
+        drawable.onFrameReady(0);
 
-        verify(frameManager, never()).getNextFrame(eq(drawable));
+        assertFalse(drawable.isRunning());
     }
 
     @Test
-    public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfHasNoCallback() {
+    public void testDoesNotStopWhenCurrentFrameFinishesIfHasNoCallbackAndIsPreHoneycomb() {
+        Util.setSdkVersionInt(10);
+
         drawable.setIsRunning(true);
         drawable.setCallback(null);
-        drawable.onFrameRead(Bitmap.createBitmap(1, 2, Bitmap.Config.ARGB_8888), 0);
+        drawable.onFrameReady(0);
 
-        verify(frameManager, never()).getNextFrame(eq(drawable));
+        assertTrue(drawable.isRunning());
     }
 
     @Test
-    public void testStopsWhenCurrentFrameFinishesIfHasNoCallback() {
+    public void testResetsFrameManagerWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
         drawable.setIsRunning(true);
         drawable.setCallback(null);
-        drawable.onFrameRead(Bitmap.createBitmap(2, 1, Bitmap.Config.ARGB_8888), 0);
+        drawable.onFrameReady(0);
 
-        assertFalse(drawable.isRunning());
+        verify(frameLoader).clear();
+    }
+
+    @Test
+    public void testDoesNotResetFrameManagerWhenCurrentFinishesIfHasNoCallbackPreHoneycomb() {
+        Util.setSdkVersionInt(10);
+
+        drawable.setIsRunning(true);
+        drawable.setCallback(null);
+        drawable.onFrameReady(0);
+
+        verify(frameLoader, never()).clear();
     }
 
     @Test
@@ -212,6 +256,26 @@ public void testStopsOnSetVisibleFalse() {
         assertFalse(drawable.isRunning());
     }
 
+    @Test
+    public void testDoesNotResetOnStopIfAtLeastAtHoneycomb() {
+        drawable.start();
+        drawable.stop();
+
+        verify(frameLoader, never()).clear();
+        // invalidate once from start.
+        verify(cb, times(1)).invalidateDrawable(eq(drawable));
+    }
+
+    @Test
+    public void testDoesResetOnStopIfPreHoneycomb() {
+        Util.setSdkVersionInt(10);
+        drawable.start();
+        drawable.stop();
+
+        verify(frameLoader).clear();
+        verify(cb, times(2)).invalidateDrawable(eq(drawable));
+    }
+
     @Test
     public void testStartsOnSetVisibleTrueIfRunning() {
         drawable.start();
@@ -246,19 +310,10 @@ public void testDoesNotImmediatelyRunIfStartedWhileNotVisible() {
     }
 
     @Test
-    public void testGetOpacityReturnsTransparentIfDecoderHasTransparency() {
-        when(gifDecoder.isTransparent()).thenReturn(true);
-
+    public void testGetOpacityReturnsTransparent() {
         assertEquals(PixelFormat.TRANSPARENT, drawable.getOpacity());
     }
 
-    @Test
-    public void testGetOpacityReturnsOpaqueIfDecoderDoesNotHaveTransparency() {
-        when(gifDecoder.isTransparent()).thenReturn(false);
-
-        assertEquals(PixelFormat.OPAQUE, drawable.getOpacity());
-    }
-
     @Test
     public void testReturnsFrameCountFromDecoder() {
         int expected = 4;
@@ -271,7 +326,7 @@ public void testReturnsFrameCountFromDecoder() {
     public void testRecycleCallsClearOnFrameManager() {
         drawable.recycle();
 
-        verify(frameManager).clear();
+        verify(frameLoader).clear();
     }
 
     @Test
@@ -304,8 +359,8 @@ public void testReturnsNewDrawableFromConstantState() {
         Transformation<Bitmap> transformation = mock(Transformation.class);
         GifDecoder.BitmapProvider provider = mock(GifDecoder.BitmapProvider.class);
         Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100, "fakeId",
-                gifHeader, new byte[0], firstFrame);
+        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,
+                new byte[0], firstFrame);
 
         assertNotNull(drawable.getConstantState().newDrawable());
         assertNotNull(drawable.getConstantState().newDrawable(Robolectric.application.getResources()));
@@ -333,7 +388,7 @@ public void testLoopsASingleTimeIfLoopCountIsSetToOne() {
 
         runLoops(loopCount, frameCount);
 
-        verify(frameManager, times(loopCount * frameCount)).getNextFrame(eq(drawable));
+        verifyRanLoops(loopCount, frameCount);
         assertFalse(drawable.isRunning());
     }
 
@@ -349,7 +404,7 @@ public void testLoopsForeverIfLoopCountIsSetToLoopForever() {
 
         runLoops(loopCount, frameCount);
 
-        verify(frameManager, times(loopCount * frameCount + 1)).getNextFrame(eq(drawable));
+        verifyRanLoops(loopCount, frameCount);
     }
 
     @Test
@@ -364,7 +419,7 @@ public void testLoopsOnceIfLoopCountIsSetToOneWithThreeFrames() {
 
         runLoops(loopCount, frameCount);
 
-        verify(frameManager, times(frameCount * loopCount)).getNextFrame(eq(drawable));
+        verifyRanLoops(loopCount, frameCount);
         assertFalse(drawable.isRunning());
     }
 
@@ -380,7 +435,7 @@ public void testLoopsThreeTimesIfLoopCountIsSetToThree() {
 
         runLoops(loopCount, frameCount);
 
-        verify(frameManager, times(loopCount * frameCount)).getNextFrame(eq(drawable));
+        verifyRanLoops(loopCount, frameCount);
         assertFalse(drawable.isRunning());
     }
 
@@ -391,15 +446,16 @@ public void testCallingStartResetsLoopCounter() {
         drawable.setVisible(true, true);
         drawable.start();
 
-        drawable.onFrameRead(getBitmap(), 0);
-        drawable.onFrameRead(getBitmap(), 1);
+        drawable.onFrameReady(0);
+        drawable.onFrameReady(1);
 
         drawable.start();
 
-        drawable.onFrameRead(getBitmap(), 0);
-        drawable.onFrameRead(getBitmap(), 1);
+        drawable.onFrameReady(0);
+        drawable.onFrameReady(1);
 
-        verify(frameManager, times(4)).getNextFrame(eq(drawable));
+        // 4 onFrameReady(), 2 start()
+        verify(cb, times(4 + 2)).invalidateDrawable(eq(drawable));
         assertFalse(drawable.isRunning());
     }
 
@@ -422,8 +478,9 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
 
         runLoops(newLoopCount, frameCount);
 
-        int expectedFrames = (initialLoopCount + newLoopCount) * frameCount;
-        verify(frameManager, times(expectedFrames)).getNextFrame(eq(drawable));
+        int numStarts = 2;
+        int expectedFrames = (initialLoopCount + newLoopCount) * frameCount + numStarts;
+        verify(cb, times(expectedFrames)).invalidateDrawable(eq(drawable));
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -443,18 +500,108 @@ public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
 
         runLoops(loopCount, frameCount);
 
-        verify(frameManager, times(frameCount * loopCount)).getNextFrame(eq(drawable));
+        verifyRanLoops(loopCount, frameCount);
+    }
+
+    @Test
+    public void testDoesNotDrawFrameAfterRecycle() {
+        Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
+        drawable.setVisible(true, true);
+        drawable.start();
+        when(frameLoader.getCurrentFrame()).thenReturn(bitmap);
+        drawable.onFrameReady(1);
+        drawable.recycle();
+        Canvas canvas = mock(Canvas.class);
+        drawable.draw(canvas);
+        verify(canvas, never()).drawBitmap(any(Bitmap.class), anyRect(), anyRect(), anyPaint());
+    }
+
+    @Test
+    public void testSetsFrameTransformationOnFrameManager() {
+        Transformation<Bitmap> transformation = mock(Transformation.class);
+        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        drawable.setFrameTransformation(transformation, bitmap);
+
+        verify(frameLoader).setFrameTransformation(eq(transformation));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfSetFrameTransformationIsCalledWithANullFrame() {
+        drawable.setFrameTransformation(mock(Transformation.class), null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfSetFrameTransformationIsCalledWithANullTransformation() {
+        drawable.setFrameTransformation(null, Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfConstructedWIthNullFirstFrame() {
+        new GifDrawable(Robolectric.application, mock(GifDecoder.BitmapProvider.class), mock(BitmapPool.class),
+                mock(Transformation.class), 100, 100, mock(GifHeader.class), new byte[0], null);
+    }
+
+    @Test
+    public void testAppliesGravityOnDrawAfterBoundsChange() {
+        Rect bounds = new Rect(0, 0, frameWidth * 2, frameHeight * 2);
+        drawable.setBounds(bounds);
+
+        Canvas canvas = mock(Canvas.class);
+        drawable.draw(canvas);
+
+        verify(canvas).drawBitmap(any(Bitmap.class), (Rect) isNull(), eq(bounds), eq(paint));
+    }
+
+    @Test
+    public void testSetAlphaSetsAlphaOnPaint() {
+        int alpha = 100;
+        drawable.setAlpha(alpha);
+        verify(paint).setAlpha(eq(alpha));
+    }
+
+    @Test
+    public void testSetColorFilterSetsColorFilterOnPaint() {
+        ColorFilter colorFilter = new ColorFilter();
+        drawable.setColorFilter(colorFilter);
+        verify(paint).setColorFilter(eq(colorFilter));
+    }
+
+    @Test
+    public void testGetDecoderReturnsGivenDecoder() {
+        assertEquals(gifDecoder, drawable.getDecoder());
+    }
+
+    @Test
+    public void testReturnsCurrentTransformationInGetFrameTransformation() {
+        Transformation<Bitmap> newTransformation = mock(Transformation.class);
+        drawable.setFrameTransformation(newTransformation, Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+
+        assertEquals(newTransformation, drawable.getFrameTransformation());
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfCreatedWithNullState() {
+        new GifDrawable(null);
+    }
+
+    private void verifyRanLoops(int loopCount, int frameCount) {
+        // 1 for invalidate in start().
+        verify(cb, times(1 + loopCount * frameCount)).invalidateDrawable(eq(drawable));
+    }
+
+    private static Paint anyPaint() {
+        return any(Paint.class);
+    }
+
+    private static Rect anyRect() {
+        return any(Rect.class);
     }
 
     private void runLoops(int loopCount, int frameCount) {
         for (int loop = 0; loop < loopCount; loop++) {
             for (int frame = 0; frame < frameCount; frame++) {
-                drawable.onFrameRead(getBitmap(), frame);
+                drawable.onFrameReady(frame);
             }
         }
     }
-
-    private static Bitmap getBitmap() {
-        return Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index 773b7ccff..71d1825f6 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -1,5 +1,13 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 
 import com.bumptech.glide.load.Transformation;
@@ -11,16 +19,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GifDrawableTransformationTest {
     Transformation<Bitmap> wrapped;
     GifDrawableTransformation transformation;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
new file mode 100644
index 000000000..bc18c8f97
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -0,0 +1,216 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.common.testing.EqualsTester;
+
+import android.graphics.Bitmap;
+import android.os.Handler;
+import android.os.Message;
+
+import com.bumptech.glide.GenericRequestBuilder;
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.target.Target;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.UUID;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class GifFrameLoaderTest {
+
+    private GifFrameLoader.FrameCallback callback;
+    private GifDecoder gifDecoder;
+    private Handler handler;
+    private GenericRequestBuilder<GifDecoder, GifDecoder, Bitmap, Bitmap> requestBuilder;
+    private GifFrameLoader loader;
+
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+        callback = mock(GifFrameLoader.FrameCallback.class);
+        gifDecoder = mock(GifDecoder.class);
+        handler = mock(Handler.class);
+        when(handler.obtainMessage(anyInt(), anyObject())).thenReturn(mock(Message.class));
+
+        requestBuilder = mock(GenericRequestBuilder.class);
+
+        loader = new GifFrameLoader(callback, gifDecoder, handler, requestBuilder);
+        when(requestBuilder.signature(any(Key.class))).thenReturn(requestBuilder);
+    }
+
+    @Test
+    public void testSetFrameTransformationSetsTransformationOnRequestBuilder() {
+        Transformation<Bitmap> transformation = mock(Transformation.class);
+        loader.setFrameTransformation(transformation);
+
+        verify(requestBuilder).transform(eq(transformation));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testSetFrameTransformationThrowsIfGivenNullTransformation() {
+        loader.setFrameTransformation(null);
+    }
+
+    @Test
+    public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
+        loader.start();
+
+        verify(requestBuilder).into(any(Target.class));
+    }
+
+    @Test
+    public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingLoad() {
+        loader.start();
+
+        InOrder order = inOrder(gifDecoder, requestBuilder);
+        order.verify(gifDecoder).advance();
+        order.verify(requestBuilder).signature(any(Key.class));
+        order.verify(requestBuilder).into(any(Target.class));
+    }
+
+    @Test
+    public void testGetCurrentFrameReturnsNullWhenNoLoadHasCompleted() {
+        assertNull(loader.getCurrentFrame());
+    }
+
+    @Test
+    public void testGetCurrentFrameReturnsCurrentBitmapAfterLoadHasCompleted() {
+        final Bitmap result = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+        GifFrameLoader.DelayTarget target = mock(GifFrameLoader.DelayTarget.class);
+        when(target.getResource()).thenReturn(result);
+        loader.onFrameReady(target);
+
+        assertEquals(result, loader.getCurrentFrame());
+    }
+
+    @Test
+    public void testStartDoesNotStartIfAlreadyRunning() {
+        loader.start();
+        loader.start();
+
+        verify(requestBuilder, times(1)).into(any(Target.class));
+    }
+
+    @Test
+    public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
+        loader.onFrameReady(mock(GifFrameLoader.DelayTarget.class));
+
+        verify(requestBuilder, never()).into(any(Target.class));
+    }
+
+    @Test
+    public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
+        loader.start();
+        loader.stop();
+        loader.start();
+
+        verify(requestBuilder, times(1)).into(any(Target.class));
+    }
+
+    @Test
+    public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
+        loader.start();
+        loader.stop();
+
+        loader.onFrameReady(mock(GifFrameLoader.DelayTarget.class));
+        loader.start();
+
+        verify(requestBuilder, times(2)).into(any(Target.class));
+    }
+
+    @Test
+    public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
+        loader.start();
+        loader.onFrameReady(mock(GifFrameLoader.DelayTarget.class));
+
+        verify(requestBuilder, times(2)).into(any(Target.class));
+    }
+
+    @Test
+    public void testOnFrameReadyClearsPreviousFrame() {
+        // Force the loader to create a real Handler.
+        loader = new GifFrameLoader(callback, gifDecoder, null /*handler*/, requestBuilder);
+
+        GifFrameLoader.DelayTarget previous = mock(GifFrameLoader.DelayTarget.class);
+        Request previousRequest = mock(Request.class);
+        when(previous.getRequest()).thenReturn(previousRequest);
+
+        loader.onFrameReady(previous);
+        loader.onFrameReady(mock(GifFrameLoader.DelayTarget.class));
+
+        verify(previousRequest).clear();
+    }
+
+    @Test
+    public void testDelayTargetSendsMessageWithHandlerDelayed() {
+        long targetTime = 1234;
+        GifFrameLoader.DelayTarget delayTarget = new GifFrameLoader.DelayTarget(handler, 1, targetTime);
+        delayTarget.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null /*glideAnimation*/);
+        verify(handler).sendMessageAtTime(any(Message.class), eq(targetTime));
+    }
+
+    @Test
+    public void testDelayTargetSetsResourceOnResourceReady() {
+        GifFrameLoader.DelayTarget delayTarget = new GifFrameLoader.DelayTarget(handler, 1, 1);
+        Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
+        delayTarget.onResourceReady(expected, null /*glideAnimation*/);
+
+        assertEquals(expected, delayTarget.getResource());
+    }
+
+    @Test
+    public void testClearsCompletedLoadOnFrameReadyIfCleared() {
+        // Force the loader to create a real Handler.
+        loader = new GifFrameLoader(callback, gifDecoder, null /*handler*/, requestBuilder);
+        loader.clear();
+        GifFrameLoader.DelayTarget delayTarget = mock(GifFrameLoader.DelayTarget.class);
+        Request request = mock(Request.class);
+        when(delayTarget.getRequest()).thenReturn(request);
+
+        loader.onFrameReady(delayTarget);
+
+        verify(request).clear();
+    }
+
+    @Test
+    public void testDoesNotReturnResourceForCompletedFrameInGetCurrentFrameIfLoadCompletesWhileCleared() {
+        loader.clear();
+        GifFrameLoader.DelayTarget delayTarget = mock(GifFrameLoader.DelayTarget.class);
+        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        when(delayTarget.getResource()).thenReturn(bitmap);
+
+        loader.onFrameReady(delayTarget);
+
+        assertNull(loader.getCurrentFrame());
+    }
+
+    @Test
+    public void testFrameSignatureEquality() {
+        UUID first = UUID.randomUUID();
+        new EqualsTester()
+                .addEqualityGroup(new GifFrameLoader.FrameSignature(first), new GifFrameLoader.FrameSignature(first))
+                .addEqualityGroup(new GifFrameLoader.FrameSignature())
+                .testEquals();
+    }
+}
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java
deleted file mode 100644
index ad7c8f5a4..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import com.bumptech.glide.gifdecoder.GifDecoder;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.mockito.Mockito.mock;
-
-@RunWith(RobolectricTestRunner.class)
-public class GifFrameManagerTest {
-
-    @Test(expected = NullPointerException.class)
-    public void testThrowsIfTransformationIsNull() {
-        new GifFrameManager(Robolectric.application, mock(GifDecoder.class), null, 100, 100, 75, 75);
-    }
-}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java
index 90bb80704..22b896885 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java
@@ -1,16 +1,19 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.gifdecoder.GifDecoder;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class GifFrameModelLoaderTest {
     private GifFrameModelLoader loader;
     private GifDecoder decoder;
@@ -22,16 +25,14 @@ public void setUp() {
     }
 
     @Test
-    public void testFetcherIdIncludesGifDecoderIdAndFrameIndex() {
+    public void testFetcherIdIncludesFrameIndex() {
         String id = "asdfasd";
         int frameIndex = 124;
-        when(decoder.getId()).thenReturn(id);
         when(decoder.getCurrentFrameIndex()).thenReturn(frameIndex);
 
         String fetcherId = loader.getResourceFetcher(decoder, 1, 2).getId();
 
-        assertThat(fetcherId, containsString(id));
-        assertThat(fetcherId, containsString(String.valueOf(frameIndex)));
+        assertThat(fetcherId).contains(String.valueOf(frameIndex));
     }
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
index 76934d2ad..f5641b34f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
@@ -1,21 +1,26 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.IOException;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GifFrameResourceDecoderTest {
     private GifDecoder gifDecoder;
     private GifFrameResourceDecoder resourceDecoder;
@@ -38,4 +43,11 @@ public void testReturnsFrameFromGifDecoder() throws IOException {
 
         assertEquals(expected, resourceDecoder.decode(gifDecoder, 100, 100).get());
     }
+
+    @Test
+    public void testReturnsNullIfGifDecoderReturnsNullFrame() {
+        when(gifDecoder.getNextFrame()).thenReturn(null);
+
+        assertNull(resourceDecoder.decode(gifDecoder, 100, 100));
+    }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java
index 277ac0b35..b919b7264 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java
@@ -1,10 +1,21 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
-import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.GlideShadowLooper;
 
@@ -20,19 +31,8 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = GlideShadowLooper.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
 public class GifResourceDecoderTest {
     private GifResourceDecoder decoder;
     private GifHeaderParser parser;
@@ -55,8 +55,7 @@ public void setUp() {
         decoderPool = mock(GifResourceDecoder.GifDecoderPool.class);
         when(decoderPool.obtain(any(GifDecoder.BitmapProvider.class))).thenReturn(gifDecoder);
 
-        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, DecodeFormat.PREFER_RGB_565,
-                parserPool, decoderPool);
+        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, parserPool, decoderPool);
     }
 
     @Test
@@ -99,23 +98,6 @@ public void testReturnsParserToPoolWhenParserThrows() {
         verify(parserPool).release(eq(parser));
     }
 
-
-    @Test
-    public void testSetsPreferredConfigOnDecoderBeforeDecoding() {
-        when(gifHeader.getNumFrames()).thenReturn(1);
-        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);
-        when(gifDecoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
-
-        decoder = new GifResourceDecoder(Robolectric.application, mock(BitmapPool.class), DecodeFormat.ALWAYS_ARGB_8888,
-                parserPool, decoderPool);
-
-        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);
-
-        InOrder order = inOrder(gifDecoder);
-        order.verify(gifDecoder).setPreferredConfig(eq(Bitmap.Config.ARGB_8888));
-        order.verify(gifDecoder).getNextFrame();
-    }
-
     @Test
     public void testDecodesFirstFrameAndReturnsGifDecoderToPool() {
         when(gifHeader.getNumFrames()).thenReturn(1);
@@ -127,7 +109,7 @@ public void testDecodesFirstFrameAndReturnsGifDecoderToPool() {
 
         InOrder order = inOrder(decoderPool, gifDecoder);
         order.verify(decoderPool).obtain(any(GifDecoder.BitmapProvider.class));
-        order.verify(gifDecoder).setData(any(String.class), eq(gifHeader), eq(data));
+        order.verify(gifDecoder).setData(eq(gifHeader), eq(data));
         order.verify(gifDecoder).advance();
         order.verify(gifDecoder).getNextFrame();
         order.verify(decoderPool).release(eq(gifDecoder));
@@ -148,6 +130,26 @@ public void testReturnsGifDecoderToPoolWhenDecoderThrows() {
         verify(decoderPool).release(eq(gifDecoder));
     }
 
+    @Test
+    public void testReturnsNullIfGifDecoderFailsToDecodeFirstFrame() {
+        when(gifHeader.getNumFrames()).thenReturn(1);
+        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);
+        when(gifDecoder.getNextFrame()).thenReturn(null);
+
+        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));
+    }
+
+    @Test
+    public void testReturnsGifDecoderToPoolWhenGifDecoderReturnsNullFirstFrame() {
+        when(gifHeader.getNumFrames()).thenReturn(1);
+        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);
+        when(gifDecoder.getNextFrame()).thenReturn(null);
+
+        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);
+
+        verify(decoderPool).release(eq(gifDecoder));
+    }
+
     @Test
     public void testCanObtainNonNullDecoderFromPool() {
         GifDecoder.BitmapProvider provider = mock(GifDecoder.BitmapProvider.class);
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceEncoderTest.java
index 2d75d2cbb..7cfacd0ad 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceEncoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceEncoderTest.java
@@ -1,6 +1,19 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
@@ -9,28 +22,19 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.IOException;
 import java.io.OutputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GifResourceEncoderTest {
     private Resource<GifDrawable> resource;
     private GifResourceEncoder encoder;
@@ -61,6 +65,7 @@ public void setUp() {
 
         gifDrawable = mock(GifDrawable.class);
         when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
+        when(gifDrawable.getData()).thenReturn(new byte[0]);
 
         when(resource.get()).thenReturn(gifDrawable);
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapResourceEncoderTest.java
index cceef2785..02ac57786 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapResourceEncoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapResourceEncoderTest.java
@@ -1,28 +1,31 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
-import com.bumptech.glide.load.engine.Resource;
+
 import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GifBitmapResourceEncoderTest {
     private ResourceEncoder<Bitmap> bitmapEncoder;
     private ResourceEncoder<GifDrawable> gifEncoder;
@@ -94,7 +97,7 @@ public void testReturnsValidId() {
         String bitmapId = "bitmapId";
         when(bitmapEncoder.getId()).thenReturn(bitmapId);
         String id = encoder.getId();
-        assertThat(id, containsString(gifId));
-        assertThat(id, containsString(bitmapId));
+        assertThat(id).contains(gifId);
+        assertThat(id).contains(bitmapId);
     }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapStreamResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapStreamResourceDecoderTest.java
index 5e4370294..bf1290fb3 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapStreamResourceDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapStreamResourceDecoderTest.java
@@ -1,10 +1,20 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
-import com.bumptech.glide.load.engine.Resource;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -12,13 +22,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class GifBitmapStreamResourceDecoderTest {
     ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> gifBitmapDecoder;
     private GifBitmapWrapperStreamResourceDecoder decoder;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java
index ff1ae41a0..8342b6cf3 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java
@@ -1,13 +1,27 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -15,25 +29,14 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GifBitmapWrapperResourceDecoderTest {
     private ResourceDecoder<ImageVideoWrapper, Bitmap> bitmapDecoder;
     private ResourceDecoder<InputStream, GifDrawable> gifDecoder;
@@ -172,6 +175,7 @@ public void testDoesNotRecycleGifResourceWhenGifTypeButGifHasSingleFrame() throw
 
         when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);
         when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifResource);
+        when(gifResource.get().getFirstFrame()).thenReturn(Bitmap.createBitmap(50, 50, Bitmap.Config.RGB_565));
 
         decoder.decode(source, 100, 100);
 
@@ -214,8 +218,8 @@ public void testHasValidId() {
         when(gifDecoder.getId()).thenReturn(gifId);
 
         String id = decoder.getId();
-        assertThat(id, containsString(bitmapId));
-        assertThat(id, containsString(gifId));
+        assertThat(id).contains(bitmapId);
+        assertThat(id).contains(gifId);
     }
 
     @SuppressWarnings("unchecked")
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoderTest.java
index 886e81fd9..076b13618 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoderTest.java
@@ -1,16 +1,20 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class GifBitmapWrapperResourceEncoderTest {
     private ResourceEncoder<Bitmap> bitmapEncoder;
     private ResourceEncoder<GifDrawable> gifEncoder;
@@ -32,7 +36,7 @@ public void testHasValidId() {
         when(gifEncoder.getId()).thenReturn(gifId);
 
         String id = encoder.getId();
-        assertThat(id, containsString(bitmapId));
-        assertThat(id, containsString(gifId));
+        assertThat(id).contains(bitmapId);
+        assertThat(id).contains(gifId);
     }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceTest.java
index cee9b65fd..bc55a52e6 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceTest.java
@@ -1,16 +1,21 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class GifBitmapWrapperResourceTest {
     private GifBitmapWrapper data;
     private GifBitmapWrapperResource resource;
@@ -53,4 +58,9 @@ public void testRecyclesGifResource() {
 
         verify(gifDataResource).recycle();
     }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfGivenWrapperIsNull() {
+        new GifBitmapWrapperResource(null);
+    }
 }
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoderTest.java
index bff3101e2..937d5816b 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperStreamResourceDecoderTest.java
@@ -1,14 +1,18 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class GifBitmapWrapperStreamResourceDecoderTest {
     ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> gifBitmapDecoder;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTest.java
index a11f2288d..f455dece8 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTest.java
@@ -1,14 +1,19 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+@RunWith(JUnit4.class)
 public class GifBitmapWrapperTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java
index a1f9f90d4..b939771ca 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java
@@ -1,23 +1,27 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
-import com.bumptech.glide.load.engine.Resource;
+
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GifBitmapWrapperTransformationTest {
     private Transformation<Bitmap> bitmapTransformation;
     private Transformation<GifDrawable> gifTransformation;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index c93d1c91c..e7711cbd5 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -1,22 +1,24 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.tests.Util;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.Matchers.containsString;
-import static org.hamcrest.Matchers.startsWith;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class BitmapBytesTranscoderTest {
     private BitmapBytesTranscoderHarness harness;
 
@@ -28,14 +30,14 @@ public void setUp() {
     @Test
     public void testReturnsBytesOfGivenBitmap() {
         String transcodedDescription = harness.getTranscodedDescription();
-        assertThat(transcodedDescription, startsWith(harness.description));
+        assertThat(transcodedDescription).startsWith(harness.description);
     }
 
     @Test
     public void testUsesGivenQuality() {
         harness.quality = 66;
         String transcodedDescription = harness.getTranscodedDescription();
-        assertThat(transcodedDescription, containsString(String.valueOf(harness.quality)));
+        assertThat(transcodedDescription).contains(String.valueOf(harness.quality));
     }
 
     @Test
@@ -43,7 +45,7 @@ public void testUsesGivenFormat() {
         for (Bitmap.CompressFormat format : Bitmap.CompressFormat.values()) {
             harness.compressFormat = format;
             String transcodedDescription = harness.getTranscodedDescription();
-            assertThat(transcodedDescription, containsString(format.name()));
+            assertThat(transcodedDescription).contains(format.name());
         }
     }
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoderTest.java
new file mode 100644
index 000000000..bd089b96c
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoderTest.java
@@ -0,0 +1,48 @@
+package com.bumptech.glide.load.resource.transcode;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class BitmapToGlideDrawableTranscoderTest {
+
+    private GlideBitmapDrawableTranscoder wrapped;
+    private BitmapToGlideDrawableTranscoder transcoder;
+
+    @Before
+    public void setUp() {
+        wrapped = mock(GlideBitmapDrawableTranscoder.class);
+        transcoder = new BitmapToGlideDrawableTranscoder(wrapped);
+    }
+
+    @Test
+    public void testReturnsWrappedId() {
+        final String expectedId = "fakeId";
+        when(wrapped.getId()).thenReturn(expectedId);
+        assertEquals(expectedId, transcoder.getId());
+    }
+
+    @Test
+    public void testReturnsResourceFromWrapped() {
+        Resource<Bitmap> toTranscode = mock(Resource.class);
+        Resource<GlideBitmapDrawable> expected = mock(Resource.class);
+
+        when(wrapped.transcode(eq(toTranscode))).thenReturn(expected);
+
+        assertEquals(expected, transcoder.transcode(toTranscode));
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoderTest.java
index 1fb02a9da..9d99931f0 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoderTest.java
@@ -1,5 +1,10 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 
 import com.bumptech.glide.load.engine.Resource;
@@ -12,13 +17,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GifBitmapWrapperDrawableTranscoderTest {
     private GifBitmapWrapperDrawableTranscoder transcoder;
     private ResourceTranscoder<Bitmap, GlideBitmapDrawable> bitmapTranscoder;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index 6d34f75e1..d8ac47c48 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -1,15 +1,19 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static org.junit.Assert.assertArrayEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.tests.Util;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import static org.junit.Assert.assertArrayEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class GifDrawableBytesTranscoderTest {
     private GifDrawableBytesTranscoder transcoder;
     private GifDrawable gifDrawable;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoderTest.java
index aa7d083e5..d23d3553e 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoderTest.java
@@ -1,5 +1,9 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Bitmap;
 
 import com.bumptech.glide.load.engine.Resource;
@@ -12,12 +16,10 @@
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GlideBitmapDrawableTranscoderTest {
     private GlideBitmapDrawableTranscoder transcoder;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
index 49a595fbc..bf236004c 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
@@ -1,13 +1,16 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.File;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
+@RunWith(JUnit4.class)
 public class TranscoderRegistryTest {
     private TranscoderRegistry factories;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
index ee63306d4..8259c3206 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
@@ -1,11 +1,15 @@
 package com.bumptech.glide.load.resource.transcode;
 
-import com.bumptech.glide.load.engine.Resource;
-import org.junit.Test;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 
+import com.bumptech.glide.load.engine.Resource;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
 public class UnitTranscoderTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
index 1ae83bc52..573402a5c 100644
--- a/library/src/androidTest/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
@@ -1,16 +1,17 @@
 package com.bumptech.glide.manager;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.Matchers.instanceOf;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.mock;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ConnectivityMonitorFactoryTest {
     private ConnectivityMonitorFactory factory;
 
@@ -24,13 +25,13 @@ public void testReturnsDefaultConnectivityMonitorWhenHasPermission() {
         Robolectric.getShadowApplication().grantPermissions("android.permission.ACCESS_NETWORK_STATE");
         ConnectivityMonitor connectivityMonitor =
                 factory.build(Robolectric.application, mock(ConnectivityMonitor.ConnectivityListener.class));
-        assertThat(connectivityMonitor, instanceOf(DefaultConnectivityMonitor.class));
+        assertThat(connectivityMonitor).isInstanceOf(DefaultConnectivityMonitor.class);
     }
 
     @Test
     public void testReturnsNullConnectivityMonitorWhenDoesNotHavePermission() {
         ConnectivityMonitor connectivityMonitor =
                 factory.build(Robolectric.application, mock(ConnectivityMonitor.ConnectivityListener.class));
-        assertThat(connectivityMonitor, instanceOf(NullConnectivityMonitor.class));
+        assertThat(connectivityMonitor).isInstanceOf(NullConnectivityMonitor.class);
     }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index c21d49198..d8faae2f5 100644
--- a/library/src/androidTest/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -1,30 +1,31 @@
 package com.bumptech.glide.manager;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowConnectivityManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
 import java.util.List;
 
-import static org.hamcrest.Matchers.empty;
-import static org.hamcrest.Matchers.hasSize;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class DefaultConnectivityMonitorTest {
     private ConnectivityMonitor.ConnectivityListener listener;
     private DefaultConnectivityMonitor monitor;
@@ -39,7 +40,7 @@ public void setUp() {
     public void testRegistersReceiverOnStart() {
         monitor.onStart();
 
-        assertThat(getConnectivityReceivers(), hasSize(1));
+        assertThat(getConnectivityReceivers()).hasSize(1);
     }
 
     @Test
@@ -47,7 +48,7 @@ public void testDoesNotRegisterTwiceOnStart() {
         monitor.onStart();
         monitor.onStart();
 
-        assertThat(getConnectivityReceivers(), hasSize(1));
+        assertThat(getConnectivityReceivers()).hasSize(1);
     }
 
     @Test
@@ -55,7 +56,7 @@ public void testUnregistersReceiverOnStop() {
         monitor.onStart();
         monitor.onStop();
 
-        assertThat(getConnectivityReceivers(), empty());
+        assertThat(getConnectivityReceivers()).isEmpty();
     }
 
     @Test
@@ -63,7 +64,7 @@ public void testHandlesUnregisteringTwiceInARow() {
         monitor.onStop();
         monitor.onStop();
 
-        assertThat(getConnectivityReceivers(), empty());
+        assertThat(getConnectivityReceivers()).isEmpty();
     }
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java b/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java
index 0e0c9f348..0319aaddb 100644
--- a/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -11,6 +11,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+
 import com.bumptech.glide.Glide;
 
 /**
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java
index ef06e17c9..4c364a8f0 100644
--- a/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java
@@ -1,18 +1,20 @@
 package com.bumptech.glide.manager;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class LifecycleTest {
 
     private ActivityFragmentLifecycle lifecycle;
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 2cbe37df7..855e991e1 100644
--- a/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -1,5 +1,12 @@
 package com.bumptech.glide.manager;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
 import android.app.Activity;
 import android.support.v4.app.FragmentActivity;
 
@@ -14,14 +21,8 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ActivityController;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class RequestManagerFragmentTest {
     private static final String TAG = "tag";
     private Harness[] harnesses;
@@ -103,6 +104,60 @@ public void runTest(Harness harness) {
         });
     }
 
+    @Test
+    public void testCallsRequestManagerOnLowMemory() {
+        runTest(new TestCase() {
+            @Override
+            public void runTest(Harness harness) {
+                RequestManager requestManager = mock(RequestManager.class);
+                harness.setRequestManager(requestManager);
+                harness.onLowMemory();
+                verify(requestManager).onLowMemory();
+            }
+        });
+    }
+
+    @Test
+    public void testNonSupportFragmentCallsOnTrimMemory() {
+      RequestManagerHarness requestManagerHarness = new RequestManagerHarness();
+      int level = 100;
+      RequestManager requestManager = mock(RequestManager.class);
+      requestManagerHarness.setRequestManager(requestManager);
+      requestManagerHarness.onTrimMemory(level);
+      verify(requestManager).onTrimMemory(eq(level));
+    }
+
+    @Test
+    public void testOnLowMemoryCallOnNullRequestManagerDoesNotCrash() {
+        runTest(new TestCase() {
+            @Override
+            public void runTest(Harness harness) {
+                harness.onLowMemory();
+            }
+        });
+    }
+
+    @Test
+    public void testOnTrimMemoryCallOnNullRequestManagerDoesNotCrash() {
+        runTest(new TestCase() {
+            @Override
+            public void runTest(Harness harness) {
+                harness.onTrimMemory(100 /*level*/);
+            }
+        });
+    }
+
+    @Test
+    public void testNonSupportFragmentCallsRequestManagerOnTrimMemory() {
+        RequestManagerHarness requestManagerHarness = new RequestManagerHarness();
+        RequestManager requestManager = mock(RequestManager.class);
+        requestManagerHarness.setRequestManager(requestManager);
+        int level = 123;
+        requestManagerHarness.fragment.onTrimMemory(level);
+
+        verify(requestManager).onTrimMemory(eq(level));
+    }
+
     private void runTest(TestCase testCase) {
         for (Harness harness : harnesses) {
             try {
@@ -127,6 +182,10 @@ private void runTest(TestCase testCase) {
         public ActivityFragmentLifecycle getFragmentLifecycle();
 
         public ActivityController getController();
+
+        public void onLowMemory();
+
+        public void onTrimMemory(int level);
     }
 
     private static class RequestManagerHarness implements Harness {
@@ -174,6 +233,16 @@ public ActivityFragmentLifecycle getFragmentLifecycle() {
         public ActivityController getController() {
             return controller;
         }
+
+        @Override
+        public void onLowMemory() {
+          fragment.onLowMemory();
+        }
+
+        @Override
+        public void onTrimMemory(int level) {
+          fragment.onTrimMemory(level);
+        }
     }
 
     private static class SupportRequestManagerHarness implements Harness {
@@ -222,5 +291,15 @@ public ActivityFragmentLifecycle getFragmentLifecycle() {
         public ActivityController getController() {
             return supportController;
         }
+
+        @Override
+        public void onLowMemory() {
+          supportFragment.onLowMemory();
+        }
+
+        @Override
+        public void onTrimMemory(int level) {
+            // Do nothing.
+        }
     }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index a5d4599bf..bd2f8c50f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -1,5 +1,14 @@
 package com.bumptech.glide.manager;
 
+import static com.google.common.truth.Truth.assertThat;
+import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import android.app.Activity;
 import android.content.Context;
 import android.content.ContextWrapper;
@@ -7,9 +16,12 @@
 import android.os.Looper;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
+
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.Util;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,18 +32,8 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ActivityController;
 
-import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.empty;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = GlideShadowLooper.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerRetrieverTest {
     private static final String PARENT_TAG = "parent";
     private RetrieverHarness[] harnesses;
@@ -40,25 +42,21 @@
 
     @Before
     public void setUp() {
-        // Clear out static state.
         retriever = new RequestManagerRetriever();
 
         harnesses = new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
 
         initialSdkVersion = Build.VERSION.SDK_INT;
+        Util.setSdkVersionInt(18);
     }
 
     @After
     public void tearDown() {
-        setSdkVersionInt(initialSdkVersion);
+        Util.setSdkVersionInt(initialSdkVersion);
 
         Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
-        assertThat(retriever.pendingRequestManagerFragments.entrySet(), empty());
-        assertThat(retriever.pendingSupportRequestManagerFragments.entrySet(), empty());
-    }
-
-    private void setSdkVersionInt(int version) {
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", version);
+        assertThat(retriever.pendingRequestManagerFragments).isEmpty();
+        assertThat(retriever.pendingSupportRequestManagerFragments).isEmpty();
     }
 
     @Test
@@ -67,7 +65,7 @@ public void testCreatesNewFragmentIfNoneExists() {
             harness.doGet();
 
             Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
-            assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.TAG));
+            assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));
         }
     }
 
@@ -83,7 +81,7 @@ public void testReturnsExistingRequestManagerIfExists() {
         for (RetrieverHarness harness : harnesses) {
             RequestManager requestManager = mock(RequestManager.class);
 
-            harness.addFragmentWithTag(RequestManagerRetriever.TAG, requestManager);
+            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);
 
             assertEquals(requestManager, harness.doGet());
         }
@@ -92,7 +90,7 @@ public void testReturnsExistingRequestManagerIfExists() {
     @Test
     public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
         for (RetrieverHarness harness : harnesses) {
-            harness.addFragmentWithTag(RequestManagerRetriever.TAG, null);
+            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
 
             assertNotNull(harness.doGet());
         }
@@ -101,7 +99,7 @@ public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager()
     @Test
     public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
         for (RetrieverHarness harness : harnesses) {
-            harness.addFragmentWithTag(RequestManagerRetriever.TAG, null);
+            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
             RequestManager first = harness.doGet();
             RequestManager second = harness.doGet();
 
@@ -111,7 +109,7 @@ public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExisti
 
     @Test
     public void testHasValidTag() {
-        assertEquals(RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.TAG);
+        assertEquals(RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.FRAGMENT_TAG);
     }
 
     @Test
@@ -156,6 +154,56 @@ public void testSupportCanGetRequestManagerFromFragment() {
         assertEquals(manager, retriever.get(fragment));
     }
 
+    @Test
+    public void testCanGetRequestManagerFromDetachedFragment() {
+      helpTestCanGetRequestManagerFromDetachedFragment();
+    }
+
+    @Test
+    public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
+      Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
+      helpTestCanGetRequestManagerFromDetachedFragment();
+    }
+
+    private void helpTestCanGetRequestManagerFromDetachedFragment() {
+      Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
+      android.app.Fragment fragment = new android.app.Fragment();
+      activity.getFragmentManager()
+        .beginTransaction()
+        .add(fragment, PARENT_TAG)
+        .detach(fragment)
+        .commit();
+      activity.getFragmentManager().executePendingTransactions();
+
+      assertTrue(fragment.isDetached());
+      retriever.get(fragment);
+    }
+
+    @Test
+    public void testSupportCanGetRequestManagerFromDetachedFragment() {
+      helpTestSupportCanGetRequestManagerFromDetachedFragment();
+    }
+
+    @Test
+    public void testSupportCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
+      Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
+      helpTestSupportCanGetRequestManagerFromDetachedFragment();
+    }
+
+    private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
+      FragmentActivity activity = Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
+      Fragment fragment = new Fragment();
+      activity.getSupportFragmentManager()
+              .beginTransaction()
+              .add(fragment, PARENT_TAG)
+              .detach(fragment)
+              .commit();
+      activity.getSupportFragmentManager().executePendingTransactions();
+
+      assertTrue(fragment.isDetached());
+      retriever.get(fragment);
+    }
+
     @Test(expected = IllegalArgumentException.class)
     public void testThrowsIfFragmentNotAttached() {
         android.app.Fragment fragment = new android.app.Fragment();
@@ -261,7 +309,7 @@ public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
 
     @Test
     public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
-        setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
+        Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
         Activity activity = mock(Activity.class);
         when(activity.getApplicationContext()).thenReturn(Robolectric.application);
         when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());
@@ -271,7 +319,7 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
 
     @Test
     public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
-        setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
+        Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
         Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
         Activity spyActivity = Mockito.spy(activity);
         when(spyActivity.isDestroyed()).thenThrow(new NoSuchMethodError());
@@ -281,7 +329,7 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
 
     @Test
     public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
-        setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
+        Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
         Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
         android.app.Fragment fragment = new android.app.Fragment();
 
@@ -296,7 +344,7 @@ public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
 
     @Test
     public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
-        setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
+        Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
         Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
         android.app.Fragment fragment = new android.app.Fragment();
 
@@ -348,7 +396,9 @@ public RequestManager doGet() {
 
         @Override
         public boolean hasFragmentWithTag(String tag) {
-            return controller.get().getFragmentManager().findFragmentByTag(RequestManagerRetriever.TAG) != null;
+            return null != controller.get()
+                .getFragmentManager()
+                .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
         }
 
         @Override
@@ -357,7 +407,7 @@ public void addFragmentWithTag(String tag, RequestManager requestManager) {
             fragment.setRequestManager(requestManager);
             controller.get().getFragmentManager()
                     .beginTransaction()
-                    .add(fragment, RequestManagerRetriever.TAG)
+                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
                     .commitAllowingStateLoss();
             controller.get().getFragmentManager().executePendingTransactions();
         }
@@ -392,7 +442,7 @@ public RequestManager doGet() {
 
         @Override
         public boolean hasFragmentWithTag(String tag) {
-            return controller.get().getSupportFragmentManager().findFragmentByTag(RequestManagerRetriever.TAG)
+            return controller.get().getSupportFragmentManager().findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG)
                     != null;
         }
 
@@ -402,7 +452,7 @@ public void addFragmentWithTag(String tag, RequestManager manager) {
             fragment.setRequestManager(manager);
             controller.get().getSupportFragmentManager()
                     .beginTransaction()
-                    .add(fragment, RequestManagerRetriever.TAG)
+                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
                     .commitAllowingStateLoss();
             controller.get().getSupportFragmentManager().executePendingTransactions();
         }
diff --git a/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java
index 96225e16b..fb5ce2979 100644
--- a/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -1,16 +1,23 @@
 package com.bumptech.glide.manager;
 
-import com.bumptech.glide.request.Request;
-import org.junit.Before;
-import org.junit.Test;
-
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.request.Request;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+@RunWith(JUnit4.class)
 public class RequestTrackerTest {
     private RequestTracker tracker;
 
@@ -156,6 +163,63 @@ public void testDoesNotStartStartedRequestsWhenResumed() {
         verify(request, never()).begin();
     }
 
+    @Test
+    public void testAvoidsConcurrentModificationWhenResuming() {
+        Request first = mock(Request.class);
+        Request second = mock(Request.class);
+
+        doAnswer(new RemoveRequest(second)).when(first).begin();
+
+        tracker.addRequest(mock(Request.class));
+        tracker.addRequest(first);
+        tracker.addRequest(second);
+
+        tracker.resumeRequests();
+    }
+
+    @Test
+    public void testAvoidsConcurrentModificationWhenPausing() {
+        Request first = mock(Request.class);
+        Request second = mock(Request.class);
+
+        when(first.isRunning()).thenReturn(true);
+        doAnswer(new RemoveRequest(second)).when(first).pause();
+
+        tracker.addRequest(mock(Request.class));
+        tracker.addRequest(first);
+        tracker.addRequest(second);
+
+        tracker.pauseRequests();
+    }
+
+    @Test
+    public void testAvoidsConcurrentModificationWhenClearing() {
+        Request first = mock(Request.class);
+        Request second = mock(Request.class);
+
+        doAnswer(new RemoveRequest(second)).when(first).clear();
+
+        tracker.addRequest(mock(Request.class));
+        tracker.addRequest(first);
+        tracker.addRequest(second);
+
+        tracker.clearRequests();
+    }
+
+    @Test
+    public void testAvoidsConcurrentModificationWhenRestarting() {
+        Request first = mock(Request.class);
+        Request second = mock(Request.class);
+
+        doAnswer(new RemoveRequest(second)).when(first).pause();
+
+        tracker.addRequest(mock(Request.class));
+        tracker.addRequest(first);
+        tracker.addRequest(second);
+
+        tracker.restartRequests();
+    }
+
     @Test
     public void testRestartsFailedRequestRestart() {
         Request request = mock(Request.class);
@@ -237,4 +301,19 @@ public void testReturnsFalseFromIsPausedWhenResumed() {
         tracker.resumeRequests();
         assertFalse(tracker.isPaused());
     }
+
+    private class RemoveRequest implements Answer<Void> {
+
+        private Request toRemove;
+
+        public RemoveRequest(Request toRemove) {
+            this.toRemove = toRemove;
+        }
+
+        @Override
+        public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+            tracker.removeRequest(toRemove);
+            return null;
+        }
+    }
 }
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/module/ManifestParserTest.java b/library/src/androidTest/java/com/bumptech/glide/module/ManifestParserTest.java
new file mode 100644
index 000000000..e2c37e2d0
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -0,0 +1,152 @@
+package com.bumptech.glide.module;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class ManifestParserTest {
+    private static final String MODULE_VALUE = "GlideModule";
+
+    @Mock Context context;
+    private ManifestParser parser;
+    private ApplicationInfo applicationInfo;
+
+    @Before
+    public void setUp() throws PackageManager.NameNotFoundException {
+        MockitoAnnotations.initMocks(this);
+        applicationInfo = new ApplicationInfo();
+        applicationInfo.metaData = new Bundle();
+
+        String packageName = "com.bumptech.test";
+        when(context.getPackageName()).thenReturn(packageName);
+
+        PackageManager pm = mock(PackageManager.class);
+        when(pm.getApplicationInfo(eq(packageName), eq(PackageManager.GET_META_DATA)))
+                .thenReturn(applicationInfo);
+        when(context.getPackageManager()).thenReturn(pm);
+
+        parser = new ManifestParser(context);
+    }
+
+    @Test
+    public void testParse_returnsEmptyListIfNoModulesListed() {
+        assertThat(parser.parse()).isEmpty();
+    }
+
+    @Test
+    public void testParse_withSingleValidModuleName_returnsListContainingModule() {
+        addModuleToManifest(TestModule1.class);
+
+        List<GlideModule> modules = parser.parse();
+        assertThat(modules).hasSize(1);
+        assertThat(modules.get(0)).isInstanceOf(TestModule1.class);
+    }
+
+    @Test
+    public void testParse_withMultipleValidModuleNames_returnsListContainingModules() {
+        addModuleToManifest(TestModule1.class);
+        addModuleToManifest(TestModule2.class);
+
+        List<GlideModule> modules = parser.parse();
+        assertThat(modules).hasSize(2);
+
+        assertThat(modules).contains(new TestModule1());
+        assertThat(modules).contains(new TestModule2());
+    }
+
+    @Test
+    public void testParse_withValidModuleName_ignoresMetadataWithoutGlideModuleValue() {
+        applicationInfo.metaData.putString(TestModule1.class.getName(), MODULE_VALUE + "test");
+
+        assertThat(parser.parse()).isEmpty();
+    }
+
+    @Test(expected = RuntimeException.class)
+    public void testThrows_whenModuleNameNotFound() {
+        addToManifest("fakeClassName");
+
+        parser.parse();
+    }
+
+    @Test(expected = RuntimeException.class)
+    public void testThrows_whenClassInManifestIsNotAModule() {
+        addModuleToManifest(InvalidClass.class);
+
+        parser.parse();
+    }
+
+    @Test(expected = RuntimeException.class)
+    public void testThrows_whenPackageNameNotFound() {
+        when(context.getPackageName()).thenReturn("fakePackageName");
+
+        parser.parse();
+    }
+
+    private void addModuleToManifest(Class<?> moduleClass) {
+        addToManifest(moduleClass.getName());
+    }
+
+    private void addToManifest(String key) {
+        applicationInfo.metaData.putString(key, MODULE_VALUE);
+    }
+
+    public static class InvalidClass { }
+
+    public static class TestModule1 implements GlideModule {
+        @Override
+        public void applyOptions(Context context, GlideBuilder builder) { }
+
+        @Override
+        public void registerComponents(Context context, Glide glide) { }
+
+        @Override
+        public boolean equals(Object o) {
+            return o instanceof TestModule1;
+        }
+
+        @Override
+        public int hashCode() {
+            return super.hashCode();
+        }
+    }
+
+    public static class TestModule2 implements GlideModule {
+
+        @Override
+        public void applyOptions(Context context, GlideBuilder builder) { }
+
+        @Override
+        public void registerComponents(Context context, Glide glide) { }
+
+        @Override
+        public boolean equals(Object o) {
+            return o instanceof TestModule2;
+        }
+
+        @Override
+        public int hashCode() {
+            return super.hashCode();
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/provider/ChildLoadProviderTest.java b/library/src/androidTest/java/com/bumptech/glide/provider/ChildLoadProviderTest.java
index 693143c03..e12f87644 100644
--- a/library/src/androidTest/java/com/bumptech/glide/provider/ChildLoadProviderTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/provider/ChildLoadProviderTest.java
@@ -1,5 +1,9 @@
 package com.bumptech.glide.provider;
 
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
@@ -8,13 +12,12 @@
 
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.File;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
+@RunWith(JUnit4.class)
 public class ChildLoadProviderTest {
     private ChildLoadHarness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/provider/DataLoadProviderRegistryTest.java b/library/src/androidTest/java/com/bumptech/glide/provider/DataLoadProviderRegistryTest.java
index cff763b72..f1ad80518 100644
--- a/library/src/androidTest/java/com/bumptech/glide/provider/DataLoadProviderRegistryTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/provider/DataLoadProviderRegistryTest.java
@@ -1,13 +1,16 @@
 package com.bumptech.glide.provider;
 
-import org.junit.Before;
-import org.junit.Test;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.mockito.Mockito.mock;
 
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
 public class DataLoadProviderRegistryTest {
     private DataLoadProviderRegistry factory;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java
index 4512d67a5..f4545ee31 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java
@@ -1,10 +1,27 @@
 package com.bumptech.glide.request;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -23,6 +40,7 @@
 import com.bumptech.glide.request.animation.GlideAnimationFactory;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,29 +48,15 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GenericRequestTest {
     private RequestHarness harness;
 
@@ -428,6 +432,15 @@ public void testIsCancelledAfterClear() {
         assertTrue(request.isCancelled());
     }
 
+    @Test
+    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
+        GenericRequest request = harness.getRequest();
+        request.clear();
+        request.clear();
+
+        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
+    }
+
     @Test
     public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
         RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
@@ -922,6 +935,19 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
                 any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
     }
 
+    @Test
+    public void testStartsLoadImmediatelyWhenGivenOverrideWithSizeOriginal() {
+        harness.overrideWidth = Target.SIZE_ORIGINAL;
+        harness.overrideHeight = Target.SIZE_ORIGINAL;
+        GenericRequest<Number, Object, Object, List> request = harness.getRequest();
+        request.begin();
+
+        verify(harness.engine).load(any(Key.class), eq(Target.SIZE_ORIGINAL), eq(Target.SIZE_ORIGINAL),
+                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
+                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
+                any(ResourceCallback.class));
+    }
+
     private static class CallResourceCallback implements Answer {
 
         private Resource resource;
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index 1b40d5c24..c7f5c944e 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -1,5 +1,17 @@
 package com.bumptech.glide.request;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
 import android.os.Handler;
 
 import com.bumptech.glide.request.target.SizeReadyCallback;
@@ -10,25 +22,15 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class RequestFutureTargetTest {
     private int width;
     private int height;
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index a9864288e..df8ad4043 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -1,11 +1,8 @@
 package com.bumptech.glide.request;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.InOrder;
-
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
@@ -13,6 +10,13 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+
+@RunWith(JUnit4.class)
 public class ThumbnailRequestCoordinatorTest {
     private Request full;
     private Request thumb;
@@ -263,4 +267,47 @@ public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
         assertTrue(coordinator.isResourceSet());
     }
 
+    @Test
+    public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
+        coordinator.onRequestSuccess(full);
+        verify(thumb).clear();
+    }
+
+    @Test
+    public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
+        coordinator = new ThumbnailRequestCoordinator(parent);
+        coordinator.setRequests(full, thumb);
+        coordinator.onRequestSuccess(full);
+        verify(parent).onRequestSuccess(eq(coordinator));
+    }
+
+    @Test
+    public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
+        coordinator = new ThumbnailRequestCoordinator(parent);
+        coordinator.setRequests(full, thumb);
+        coordinator.onRequestSuccess(full);
+        verify(thumb).clear();
+    }
+
+    @Test
+    public void testDoesNotClearThumbOnThumbRequestComplete() {
+        coordinator.onRequestSuccess(thumb);
+        verify(thumb, never()).clear();
+    }
+
+    @Test
+    public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
+        when(thumb.isComplete()).thenReturn(true);
+        coordinator.onRequestSuccess(full);
+        verify(thumb, never()).clear();
+    }
+
+    @Test
+    public void testDoesNotNotifyParentOnThumbRequestComplete() {
+        coordinator = new ThumbnailRequestCoordinator(parent);
+        coordinator.setRequests(full, thumb);
+        coordinator.onRequestSuccess(thumb);
+
+        verify(parent, never()).onRequestSuccess(any(Request.class));
+    }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactoryTest.java
new file mode 100644
index 000000000..5293af089
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactoryTest.java
@@ -0,0 +1,44 @@
+package com.bumptech.glide.request.animation;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Mockito.mock;
+
+import android.graphics.drawable.Drawable;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class DrawableCrossFadeFactoryTest {
+
+    private DrawableCrossFadeFactory<Drawable> factory;
+
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+        ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
+        factory = new DrawableCrossFadeFactory<Drawable>(viewAnimationFactory, 100 /*duration*/);
+    }
+
+    @Test
+    public void testReturnsNoAnimationIfFromMemoryCache() {
+        assertEquals(NoAnimation.<Drawable>get(), factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/));
+    }
+
+    @Test
+    public void testReturnsReturnsAnimationIfNotFromMemoryCacheAndIsFirstResource() {
+        assertNotEquals(NoAnimation.<Drawable>get(),
+                factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/));
+    }
+
+    @Test
+    public void testReturnsAnimationIfNotFromMemocyCacheAndNotIsFirstResource() {
+        assertNotEquals(NoAnimation.<Drawable>get(),
+                factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/));
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimationTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimationTest.java
index a4b902486..1cf4622c9 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimationTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimationTest.java
@@ -1,25 +1,28 @@
 package com.bumptech.glide.request.animation;
 
+import static com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
 import android.widget.ImageView;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class DrawableCrossFadeViewAnimationTest {
     private CrossFadeHarness harness;
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationFactoryTest.java
new file mode 100644
index 000000000..511282c9f
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationFactoryTest.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.request.animation;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.view.View;
+import android.view.animation.Animation;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ViewAnimationFactoryTest {
+    private ViewAnimation.AnimationFactory animationFactory;
+    private ViewAnimationFactory<Object> factory;
+
+    @Before
+    public void setUp() {
+        animationFactory = mock(ViewAnimation.AnimationFactory.class);
+        factory = new ViewAnimationFactory<Object>(animationFactory);
+    }
+
+    @Test
+    public void testFactoryReturnsNoAnimationIfFromMemoryCache() {
+        GlideAnimation<Object> animation = factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/);
+        assertEquals(NoAnimation.get(), animation);
+        verify(animationFactory, never()).build();
+    }
+
+    @Test
+    public void testFactoryReturnsNoAnimationIfNotFirstResource() {
+        GlideAnimation<Object> animation = factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/);
+        assertEquals(NoAnimation.get(), animation);
+        verify(animationFactory, never()).build();
+    }
+
+    @Test
+    public void testFactoryReturnsActualAnimationIfNotIsFromMemoryCacheAndIsFirstResource() {
+        GlideAnimation<Object> glideAnimation = factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/);
+
+        Animation animation = mock(Animation.class);
+        when(animationFactory.build()).thenReturn(animation);
+
+        GlideAnimation.ViewAdapter adapter = mock(GlideAnimation.ViewAdapter.class);
+        View view = mock(View.class);
+        when(adapter.getView()).thenReturn(view);
+        glideAnimation.animate(new Object(), adapter);
+
+        verify(view).startAnimation(eq(animation));
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationTest.java
index 6d167a364..5a72ed65a 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewAnimationTest.java
@@ -1,12 +1,5 @@
 package com.bumptech.glide.request.animation;
 
-import android.view.animation.Animation;
-import android.widget.ImageView;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
 import static com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter;
 import static org.junit.Assert.assertFalse;
 import static org.mockito.Matchers.eq;
@@ -14,7 +7,17 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.view.animation.Animation;
+import android.widget.ImageView;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ViewAnimationTest {
     private ViewAnimation<Object> viewAnimation;
     private ViewAdapter adapter;
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactoryTest.java
new file mode 100644
index 000000000..a3b7e6614
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactoryTest.java
@@ -0,0 +1,37 @@
+package com.bumptech.glide.request.animation;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Mockito.mock;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ViewPropertyAnimationFactoryTest {
+
+    private ViewPropertyAnimationFactory<Object> factory;
+
+    @Before
+    public void setUp() {
+        ViewPropertyAnimation.Animator animator = mock(ViewPropertyAnimation.Animator.class);
+        factory = new ViewPropertyAnimationFactory<Object>(animator);
+    }
+
+    @Test
+    public void testReturnsNoAnimationIfFromMemoryCache() {
+        assertEquals(NoAnimation.get(), factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/));
+    }
+
+    @Test
+    public void testReturnsNoAnimationIfNotFirstResource() {
+        assertEquals(NoAnimation.get(), factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/));
+    }
+
+    @Test
+    public void testReturnsAnimationIfNotFromMemoryCacheAndFirstResource() {
+        assertNotEquals(NoAnimation.get(), factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/));
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationTest.java b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationTest.java
index 3d61c7096..3b9cacf18 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/animation/ViewPropertyAnimationTest.java
@@ -1,14 +1,5 @@
 package com.bumptech.glide.request.animation;
 
-import android.view.View;
-import android.widget.ImageView;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-
 import static com.bumptech.glide.request.animation.GlideAnimation.ViewAdapter;
 import static org.junit.Assert.assertFalse;
 import static org.mockito.Matchers.any;
@@ -18,7 +9,18 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.view.View;
+import android.widget.ImageView;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ViewPropertyAnimationTest {
     private ViewPropertyAnimation.Animator animator;
     private ViewPropertyAnimation animation;
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
new file mode 100644
index 000000000..0659bbe14
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -0,0 +1,136 @@
+package com.bumptech.glide.request.target;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import android.appwidget.AppWidgetManager;
+import android.content.ComponentName;
+import android.graphics.Bitmap;
+import android.widget.RemoteViews;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowAppWidgetManager;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = AppWidgetTargetTest.UpdateShadowAppWidgetManager.class)
+public class AppWidgetTargetTest {
+
+    private UpdateShadowAppWidgetManager shadowManager;
+    private RemoteViews views;
+    private int viewId;
+
+    @Before
+    public void setUp() {
+        shadowManager = Robolectric.shadowOf_(AppWidgetManager.getInstance(Robolectric.application));
+        viewId = 1234;
+        views = mock(RemoteViews.class);
+    }
+
+    @Test
+    public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName() {
+        ComponentName componentName = mock(ComponentName.class);
+        AppWidgetTarget target = new AppWidgetTarget(Robolectric.application, views, viewId, componentName);
+
+        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        target.onResourceReady(bitmap, null /*glideAnimation*/);
+
+        verify(views).setImageViewBitmap(eq(viewId), eq(bitmap));
+    }
+
+    @Test
+    public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
+        ComponentName componentName = mock(ComponentName.class);
+        AppWidgetTarget target = new AppWidgetTarget(Robolectric.application, views, viewId, componentName);
+
+        target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null /*glideAnimation*/);
+
+        assertEquals(componentName, shadowManager.updatedComponentName);
+        assertEquals(views, shadowManager.updatedRemoteViews);
+    }
+
+    @Test
+    public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
+        int[] widgetIds = new int[] { 1 };
+        AppWidgetTarget target = new AppWidgetTarget(Robolectric.application, views, viewId, widgetIds);
+
+        Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
+        target.onResourceReady(bitmap, null /*glideAnimation*/);
+
+        verify(views).setImageViewBitmap(eq(viewId), eq(bitmap));
+    }
+
+    @Test
+    public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
+        int[] widgetIds = new int[] { 1 };
+        AppWidgetTarget target = new AppWidgetTarget(Robolectric.application, views, viewId, widgetIds);
+
+        target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null /*glideAnimation*/);
+
+        assertThat(widgetIds).isEqualTo(shadowManager.updatedWidgetIds);
+        assertEquals(views, shadowManager.updatedRemoteViews);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsWhenGivenNullContextWithWidgetIds() {
+        new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, 1 /*widgetIds*/);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsWhenGivenNullContextWithComponentName() {
+        new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, mock(ComponentName.class));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
+        new AppWidgetTarget(Robolectric.application, null /*remoteViews*/, viewId, 1 /*widgetIds*/);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
+        new AppWidgetTarget(Robolectric.application, null /*remoteViews*/, viewId, mock(ComponentName.class));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsWhenGivenNullWidgetIds() {
+        new AppWidgetTarget(Robolectric.application, views, viewId, (int[]) null /*widgetIds*/);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testThrowsWhenGivenEmptyWidgetIds() {
+        new AppWidgetTarget(Robolectric.application, views, viewId);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsWhenGivenNullComponentName() {
+        new AppWidgetTarget(Robolectric.application, views, viewId, (ComponentName) null);
+    }
+
+    @Implements(AppWidgetManager.class)
+    public static class UpdateShadowAppWidgetManager extends ShadowAppWidgetManager {
+        public int[] updatedWidgetIds;
+        public RemoteViews updatedRemoteViews;
+        public ComponentName updatedComponentName;
+
+        @Implementation
+        public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
+            updatedWidgetIds = appWidgetIds;
+            updatedRemoteViews = views;
+        }
+
+        @Implementation
+        public void updateAppWidget(ComponentName componentName, RemoteViews views) {
+            updatedComponentName = componentName;
+            updatedRemoteViews = views;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
index c4541e668..c25b75f8a 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request.target;
 
+import static org.junit.Assert.assertEquals;
+
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.widget.ImageView;
@@ -9,10 +11,10 @@
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class BitmapImageViewTargetTest {
 
     private ImageView view;
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/GlideDrawableImageViewTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/GlideDrawableImageViewTargetTest.java
index 4e736bfa3..a4ca6bbed 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/GlideDrawableImageViewTargetTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/GlideDrawableImageViewTargetTest.java
@@ -1,5 +1,15 @@
 package com.bumptech.glide.request.target;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.drawable.BitmapDrawable;
@@ -14,20 +24,10 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.Matchers.instanceOf;
-import static org.hamcrest.Matchers.not;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class GlideDrawableImageViewTargetTest {
 
     @Test
@@ -66,7 +66,7 @@ public int getIntrinsicWidth() {
             @Override
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 Drawable drawable = (Drawable) invocation.getArguments()[0];
-                assertThat(drawable, instanceOf(SquaringDrawable.class));
+                assertThat(drawable).isInstanceOf(SquaringDrawable.class);
                 return null;
             }
         }).when(mockView).setImageDrawable(any(Drawable.class));
@@ -96,7 +96,7 @@ public int getIntrinsicWidth() {
             @Override
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 Drawable drawable = (Drawable) invocation.getArguments()[0];
-                assertThat(drawable, not(instanceOf(SquaringDrawable.class)));
+                assertThat(drawable).isNotInstanceOf(SquaringDrawable.class);
                 return null;
             }
         }).when(mockView).setImageDrawable(any(Drawable.class));
@@ -126,7 +126,7 @@ public int getIntrinsicWidth() {
             @Override
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 Drawable drawable = (Drawable) invocation.getArguments()[0];
-                assertThat(drawable, not(instanceOf(SquaringDrawable.class)));
+                assertThat(drawable).isNotInstanceOf(SquaringDrawable.class);
                 return null;
             }
         }).when(mockView).setImageDrawable(any(Drawable.class));
@@ -156,7 +156,7 @@ public int getIntrinsicWidth() {
             @Override
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 Drawable drawable = (Drawable) invocation.getArguments()[0];
-                assertThat(drawable, not(instanceOf(SquaringDrawable.class)));
+                assertThat(drawable).isNotInstanceOf(SquaringDrawable.class);
                 return null;
             }
         }).when(mockView).setImageDrawable(any(Drawable.class));
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
index 59f246a6e..0fca40555 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
@@ -1,25 +1,28 @@
 package com.bumptech.glide.request.target;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
 import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
 import com.bumptech.glide.load.resource.drawable.GlideDrawable;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.Matchers.instanceOf;
-import static org.junit.Assert.assertThat;
-import static org.mockito.Mockito.mock;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ImageViewTargetFactoryTest {
     private ImageViewTargetFactory factory;
     private ImageView view;
@@ -35,7 +38,7 @@ public void testReturnsTargetForBitmaps() {
         Bitmap bitmap = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
         Target<Bitmap> target = factory.buildTarget(view, Bitmap.class);
         target.onResourceReady(bitmap, null);
-        assertThat(target, instanceOf(BitmapImageViewTarget.class));
+        assertThat(target).isInstanceOf(BitmapImageViewTarget.class);
     }
 
     @Test
@@ -43,7 +46,7 @@ public void testReturnsTargetForGlideDrawables() {
         GlideDrawable glideDrawable = mock(GlideDrawable.class);
         Target<GlideDrawable> target = factory.buildTarget(view, GlideDrawable.class);
         target.onResourceReady(glideDrawable, null);
-        assertThat(target, instanceOf(GlideDrawableImageViewTarget.class));
+        assertThat(target).isInstanceOf(GlideDrawableImageViewTarget.class);
     }
 
     @Test
@@ -51,7 +54,7 @@ public void testReturnsTargetForGifDrawables() {
         GifDrawable gifDrawable = mock(GifDrawable.class);
         Target target = factory.buildTarget(view, GifDrawable.class);
         target.onResourceReady(gifDrawable, null);
-        assertThat(target, instanceOf(GlideDrawableImageViewTarget.class));
+        assertThat(target).isInstanceOf(GlideDrawableImageViewTarget.class);
     }
 
     @Test
@@ -59,7 +62,7 @@ public void testReturnsTargetForGlideBitmapDrawables() {
         GlideBitmapDrawable drawable = mock(GlideBitmapDrawable.class);
         Target target = factory.buildTarget(view, GlideBitmapDrawable.class);
         target.onResourceReady(drawable, null);
-        assertThat(target, instanceOf(GlideDrawableImageViewTarget.class));
+        assertThat(target).isInstanceOf(GlideDrawableImageViewTarget.class);
     }
 
     @Test
@@ -69,14 +72,14 @@ public void testReturnsTargetForBitmapDrawables() {
 
         Target target = factory.buildTarget(view, BitmapDrawable.class);
         target.onResourceReady(drawable, null);
-        assertThat(target, instanceOf(DrawableImageViewTarget.class));
+        assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
     }
 
     @Test
     public void testReturnsTargetForDrawables() {
         Target<Drawable> target = factory.buildTarget(view, Drawable.class);
         target.onResourceReady(new ColorDrawable(Color.RED), null);
-        assertThat(target, instanceOf(DrawableImageViewTarget.class));
+        assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
     }
 
     @Test(expected = IllegalArgumentException.class)
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index c9c960f78..4cbe7419e 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -1,5 +1,13 @@
 package com.bumptech.glide.request.target;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
@@ -12,16 +20,10 @@
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ImageViewTargetTest {
 
     private ImageView view;
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/NotificationTargetTest.java
new file mode 100644
index 000000000..e32a3a628
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -0,0 +1,96 @@
+package com.bumptech.glide.request.target;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.widget.RemoteViews;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowNotificationManager;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = NotificationTargetTest.UpdateShadowNotificationManager.class)
+public class NotificationTargetTest {
+
+    private UpdateShadowNotificationManager shadowManager;
+    private RemoteViews remoteViews;
+    private int viewId;
+    private Notification notification;
+    private int notificationId;
+    private NotificationTarget target;
+
+    @Before
+    public void setUp() {
+        NotificationManager notificationManager =
+                (NotificationManager) Robolectric.application.getSystemService(Context.NOTIFICATION_SERVICE);
+        shadowManager = Robolectric.shadowOf_(notificationManager);
+
+        remoteViews = mock(RemoteViews.class);
+        viewId = 123;
+        notification = mock(Notification.class);
+        notificationId = 456;
+
+
+        target = new NotificationTarget(Robolectric.application, remoteViews, viewId, 100 /*width*/, 100 /*height*/,
+                notification, notificationId);
+    }
+
+    @Test
+    public void testSetsBitmapOnRemoteViewsWithGivenImageIdOnResourceReady() {
+        Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        target.onResourceReady(bitmap, null /*glideAnimation*/);
+        verify(remoteViews).setImageViewBitmap(eq(viewId), eq(bitmap));
+    }
+
+    @Test
+    public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourceReady() {
+        target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null /*glideAnimation*/);
+
+        assertEquals(notificationId, shadowManager.updatedNotificationId);
+        assertEquals(notification, shadowManager.updatedNotification);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfContextIsNull() {
+        new NotificationTarget(null /*context*/, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
+                100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    }
+
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfNotificationIsNull() {
+        new NotificationTarget(Robolectric.application, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
+                100 /*height*/, null /*notification*/, 456 /*notificationId*/);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testThrowsIfRemoteViewsIsNull() {
+        new NotificationTarget(Robolectric.application, null /*remoteViews*/, 123 /*viewId*/, 100 /*width*/,
+                100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    }
+
+    @Implements(NotificationManager.class)
+    public static class UpdateShadowNotificationManager extends ShadowNotificationManager {
+        int updatedNotificationId;
+        Notification updatedNotification;
+
+        @Implementation
+        public void notify(int notificationId, Notification notification) {
+            updatedNotificationId = notificationId;
+            updatedNotification = notification;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java
index 20ca38a27..31adb437f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java
@@ -1,15 +1,18 @@
 package com.bumptech.glide.request.target;
 
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
 import com.bumptech.glide.request.Request;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class PreloadTargetTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java
index 1e9d28085..509c1d805 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -1,10 +1,14 @@
 package com.bumptech.glide.request.target;
 
+import static org.mockito.Mockito.mock;
+
 import com.bumptech.glide.request.animation.GlideAnimation;
-import org.junit.Test;
 
-import static org.mockito.Mockito.mock;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
+@RunWith(JUnit4.class)
 public class SimpleTargetTest {
 
     @Test(expected = IllegalArgumentException.class)
@@ -32,9 +36,14 @@ public void testCanBeConstructedWithoutDimensions() {
         getTarget();
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void testThrowsOnGetSizeIfConstructedWithoutDimensions() {
-        getTarget().getSize(mock(SizeReadyCallback.class));
+    @Test
+    public void testConstructorDoesNotThrowWithSizeOriginal() {
+        getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+    }
+
+    @Test
+    public void testGetSizeDoesNotThrowWithSizeOriginal() {
+        getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));
     }
 
     private SimpleTarget<Object> getTarget() {
diff --git a/library/src/androidTest/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/androidTest/java/com/bumptech/glide/request/target/ViewTargetTest.java
index 396457479..9339a34ae 100644
--- a/library/src/androidTest/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -1,5 +1,18 @@
 package com.bumptech.glide.request.target;
 
+import static com.google.common.truth.Truth.assertThat;
+import static android.view.ViewGroup.LayoutParams;
+import static android.view.ViewTreeObserver.OnPreDrawListener;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.view.View;
@@ -25,22 +38,9 @@
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 
-import static android.view.ViewGroup.LayoutParams;
-import static android.view.ViewTreeObserver.OnPreDrawListener;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.hasSize;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(shadows = { ViewTargetTest.SizedShadowView.class, ViewTargetTest.PreDrawShadowViewTreeObserver.class })
+@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { ViewTargetTest.SizedShadowView.class,
+        ViewTargetTest.PreDrawShadowViewTreeObserver.class })
 public class ViewTargetTest {
     private View view;
     private ViewTarget target;
@@ -112,22 +112,134 @@ public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet()
         verify(cb).onSizeReady(eq(dimens), eq(dimens));
     }
 
+    private void setDisplayDimens(Integer width, Integer height) {
+        WindowManager windowManager = (WindowManager) Robolectric.application.getSystemService(Context.WINDOW_SERVICE);
+        ShadowDisplay shadowDisplay = Robolectric.shadowOf(windowManager.getDefaultDisplay());
+        if (width != null) {
+            shadowDisplay.setWidth(width);
+        }
+
+        if (height != null) {
+            shadowDisplay.setHeight(height);
+        }
+    }
+
+    private void setDisplayWidth(int width) {
+        setDisplayDimens(width, null);
+    }
+
+    private void setDisplayHeight(int height) {
+        setDisplayDimens(null, height);
+    }
+
     @Test
-    public void testSizeCallbackIsCalledSynchronouslyWithScreenSizeIfLayoutParamsWrapContent() {
+    public void testBothParamsWrapContent() {
         LayoutParams layoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
         view.setLayoutParams(layoutParams);
 
-        int width = 1234;
-        int height = 674;
-        WindowManager windowManager = (WindowManager) view.getContext()
-                .getSystemService(Context.WINDOW_SERVICE);
-        ShadowDisplay shadowDisplay = Robolectric.shadowOf(windowManager.getDefaultDisplay());
-        shadowDisplay.setWidth(width);
-        shadowDisplay.setHeight(height);
+        int width = 123;
+        int height = 456;
+        setDisplayDimens(width, height);
+        SizeReadyCallback cb = mock(SizeReadyCallback.class);
+        target.getSize(cb);
+
+        verify(cb).onSizeReady(eq(width), eq(height));
+    }
+
+    @Test
+    public void testWrapContentWidthWithValidHeight() {
+        int displayWidth = 500;
+        setDisplayWidth(displayWidth);
+
+        int height = 100;
+        LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
+        view.setLayoutParams(params);
+
+        SizeReadyCallback cb = mock(SizeReadyCallback.class);
+        target.getSize(cb);
+
+        verify(cb).onSizeReady(eq(displayWidth), eq(height));
+    }
+
+    @Test
+    public void testWrapContentHeightWithValidWidth() {
+        int displayHeight = 700;
+        setDisplayHeight(displayHeight);
+        int width = 100;
+        LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
+        view.setLayoutParams(params);
 
         SizeReadyCallback cb = mock(SizeReadyCallback.class);
         target.getSize(cb);
 
+        verify(cb).onSizeReady(eq(width), eq(displayHeight));
+    }
+
+    @Test
+    public void testWrapContentWidthWithMatchParentHeight() {
+        int displayWidth = 1234;
+        setDisplayWidth(displayWidth);
+
+        LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
+        view.setLayoutParams(params);
+
+        SizeReadyCallback cb = mock(SizeReadyCallback.class);
+        target.getSize(cb);
+
+        verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+        int height = 32;
+        SizedShadowView shadowView = Robolectric.shadowOf_(view);
+        shadowView.setHeight(height);
+
+        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
+        shadowObserver.fireOnPreDrawListeners();
+
+        verify(cb).onSizeReady(eq(displayWidth), eq(height));
+    }
+
+    @Test
+    public void testWrapContentHeightWithMatchParentWidth() {
+        int displayHeight = 5812;
+        setDisplayHeight(displayHeight);
+
+        LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+        view.setLayoutParams(params);
+
+        SizeReadyCallback cb = mock(SizeReadyCallback.class);
+        target.getSize(cb);
+
+        verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+        int width = 32;
+        SizedShadowView shadowView = Robolectric.shadowOf_(view);
+        shadowView.setWidth(width);
+
+        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
+        shadowObserver.fireOnPreDrawListeners();
+
+        verify(cb).onSizeReady(eq(width), eq(displayHeight));
+    }
+
+    @Test
+    public void testMatchParentWidthAndHeight() {
+        LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        view.setLayoutParams(params);
+
+        SizeReadyCallback cb = mock(SizeReadyCallback.class);
+        target.getSize(cb);
+
+        verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+        int width = 32;
+        int height = 45;
+        SizedShadowView shadowView = Robolectric.shadowOf_(view);
+        shadowView.setWidth(width);
+        shadowView.setHeight(height);
+
+        PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
+        shadowObserver.fireOnPreDrawListeners();
+
         verify(cb).onSizeReady(eq(width), eq(height));
     }
 
@@ -192,7 +304,7 @@ public void testDoesNotAddMultipleListenersIfMultipleCallbacksAreAdded() {
         target.getSize(cb2);
 
         PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
-        assertThat(shadowObserver.getPreDrawListeners(), hasSize(1));
+        assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
     }
 
     @Test
@@ -205,7 +317,7 @@ public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest
         PreDrawShadowViewTreeObserver shadowObserver = Robolectric.shadowOf_(view.getViewTreeObserver());
         shadowObserver.fireOnPreDrawListeners();
 
-        assertThat(shadowObserver.getPreDrawListeners(), hasSize(0));
+        assertThat(shadowObserver.getPreDrawListeners()).hasSize(0);
 
         SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
         view.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
@@ -226,7 +338,7 @@ public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
         shadowObserver.fireOnPreDrawListeners();
 
         verify(cb, never()).onSizeReady(anyInt(), anyInt());
-        assertThat(shadowObserver.getPreDrawListeners(), hasSize(1));
+        assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
     }
 
     @Test
@@ -299,7 +411,7 @@ public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
 
     @Test(expected = NullPointerException.class)
     public void testThrowsIfGivenNullView() {
-        ViewTarget viewTarget = new TestViewTarget(null);
+        new TestViewTarget(null);
     }
 
     @Implements(ViewTreeObserver.class)
diff --git a/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java
index d7f34ee87..69ff5fb6c 100644
--- a/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -1,21 +1,25 @@
 package com.bumptech.glide.resize.load;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.testutil.TestResourceUtil;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.IOException;
 import java.io.InputStream;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ExifTest {
 
     private InputStream open(String imageName) throws IOException {
-        return getClass().getResourceAsStream("/exif-orientation-examples/" + imageName);
+        return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
     }
 
     private void assertOrientation(String filePrefix, int expectedOrientation) {
diff --git a/library/src/androidTest/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/androidTest/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
index 9b31838c7..09386d4ad 100644
--- a/library/src/androidTest/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -1,19 +1,22 @@
 package com.bumptech.glide.signature;
 
+import static org.junit.Assert.assertNotNull;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.KeyAssertions;
+
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.UnsupportedEncodingException;
 import java.security.NoSuchAlgorithmException;
 
-import static org.junit.Assert.assertNotNull;
-
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ApplicationVersionSignatureTest {
 
     @After
diff --git a/library/src/androidTest/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/androidTest/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
index eb23d9cfb..3756c648f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -1,11 +1,15 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.tests.KeyAssertions;
+
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.UnsupportedEncodingException;
 import java.security.NoSuchAlgorithmException;
 
+@RunWith(JUnit4.class)
 public class MediaStoreSignatureTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/signature/StringSignatureTest.java b/library/src/androidTest/java/com/bumptech/glide/signature/StringSignatureTest.java
index 708617b59..3aaed56e1 100644
--- a/library/src/androidTest/java/com/bumptech/glide/signature/StringSignatureTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/signature/StringSignatureTest.java
@@ -1,11 +1,15 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.tests.KeyAssertions;
+
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.io.UnsupportedEncodingException;
 import java.security.NoSuchAlgorithmException;
 
+@RunWith(JUnit4.class)
 public class StringSignatureTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/src/androidTest/java/com/bumptech/glide/tests/ContentResolverShadow.java
index bdc6c35a4..e679dfbe6 100644
--- a/library/src/androidTest/java/com/bumptech/glide/tests/ContentResolverShadow.java
+++ b/library/src/androidTest/java/com/bumptech/glide/tests/ContentResolverShadow.java
@@ -3,6 +3,7 @@
 import android.content.ContentResolver;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
+
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowContentResolver;
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLog.java
new file mode 100644
index 000000000..6a11cac63
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLog.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide.tests;
+
+import android.util.Log;
+
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowLog;
+
+/**
+ * Exists only to "enable" logging for test coverage.
+ *
+ * TODO: when we can ignore Log.* via configuration, remove this class.
+ */
+@Implements(Log.class)
+public class GlideShadowLog extends ShadowLog {
+
+    @Implementation
+    public static boolean isLoggable(String tag, int level) {
+        return true;
+    }
+}
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLooper.java
index 6c0a072f5..de96aa137 100644
--- a/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ b/library/src/androidTest/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -1,13 +1,14 @@
 package com.bumptech.glide.tests;
 
+import static org.mockito.Mockito.mock;
+
 import android.os.Looper;
 import android.os.MessageQueue;
+
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowLooper;
 
-import static org.mockito.Mockito.mock;
-
 @Implements(Looper.class)
 public class GlideShadowLooper extends ShadowLooper  {
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/androidTest/java/com/bumptech/glide/tests/KeyAssertions.java
index d3effec6f..139dad9ba 100644
--- a/library/src/androidTest/java/com/bumptech/glide/tests/KeyAssertions.java
+++ b/library/src/androidTest/java/com/bumptech/glide/tests/KeyAssertions.java
@@ -1,17 +1,15 @@
 package com.bumptech.glide.tests;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+
 import com.bumptech.glide.load.Key;
 
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
-import static org.hamcrest.CoreMatchers.not;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-
 public class KeyAssertions {
 
     public static void assertSame(Key first, Key second) throws UnsupportedEncodingException, NoSuchAlgorithmException {
@@ -24,7 +22,7 @@ private static void assertSameOrdered(Key first, Key second) throws UnsupportedE
         assertEquals(first, second);
         assertEquals(first.hashCode(), second.hashCode());
 
-        assertThat(getDigest(first), equalTo(getDigest(second)));
+        assertThat(getDigest(first)).isEqualTo(getDigest(second));
     }
 
     public static void assertDifferent(Key first, Key second)
@@ -44,7 +42,7 @@ public static void assertDifferent(Key first, Key second, boolean diskCacheDiffe
             MessageDigest secondDigest = MessageDigest.getInstance("SHA-1");
             second.updateDiskCacheKey(secondDigest);
 
-            assertThat(getDigest(first), not(equalTo(getDigest(second))));
+            assertNotEquals(getDigest(first), getDigest(second));
         }
     }
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/tests/Util.java b/library/src/androidTest/java/com/bumptech/glide/tests/Util.java
index b69ac7f4f..08ef49e2a 100644
--- a/library/src/androidTest/java/com/bumptech/glide/tests/Util.java
+++ b/library/src/androidTest/java/com/bumptech/glide/tests/Util.java
@@ -1,7 +1,12 @@
 package com.bumptech.glide.tests;
 
+import static org.junit.Assert.assertEquals;
+
+import android.os.Build;
+
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -10,8 +15,6 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 
-import static org.junit.Assert.assertEquals;
-
 public class Util {
 
     public static String getExpectedClassId(Class clazz) {
@@ -70,4 +73,8 @@ public T answer(InvocationOnMock invocation) {
             }
         };
     }
+
+    public static void setSdkVersionInt(int version) {
+        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", version);
+    }
 }
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/ByteArrayPoolTest.java b/library/src/androidTest/java/com/bumptech/glide/util/ByteArrayPoolTest.java
index b5ac2959d..fb6ffa140 100644
--- a/library/src/androidTest/java/com/bumptech/glide/util/ByteArrayPoolTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/util/ByteArrayPoolTest.java
@@ -1,16 +1,18 @@
 package com.bumptech.glide.util;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ByteArrayPoolTest {
 
     @Before
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
index f709a5c0a..78880ecd5 100644
--- a/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
@@ -1,13 +1,5 @@
 package com.bumptech.glide.util;
 
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketTimeoutException;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -19,14 +11,27 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.SocketTimeoutException;
+
+@RunWith(JUnit4.class)
 public class ExceptionCatchingInputStreamTest {
 
-    private InputStream wrapped;
+    private RecyclableBufferedInputStream wrapped;
     private ExceptionCatchingInputStream is;
 
     @Before
     public void setUp() throws Exception {
-        wrapped = mock(InputStream.class);
+        wrapped = mock(RecyclableBufferedInputStream.class);
         is = new ExceptionCatchingInputStream();
         is.setInputStream(wrapped);
     }
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java b/library/src/androidTest/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
new file mode 100644
index 000000000..e5d39625f
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.util;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class FixedPreloadSizeProviderTest {
+
+    @Test
+    public void testReturnsGivenSize() {
+        int width = 500;
+        int height = 1234;
+        FixedPreloadSizeProvider<Object> provider = new FixedPreloadSizeProvider<Object>(width, height);
+
+        int[] size = provider.getPreloadSize(new Object(), 0, 0);
+
+        assertThat(size).asList().containsExactly(width, height);
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/src/androidTest/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
new file mode 100644
index 000000000..65f1db2e1
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -0,0 +1,164 @@
+package com.bumptech.glide.util;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class MarkEnforcingInputStreamTest {
+    // An arbitrary number > 0.
+    private static final int MARK_LIMIT = 5;
+    // Another arbitrary number > MARK_LIMIT.
+    private static final int DATA_SIZE = MARK_LIMIT + 1;
+
+    @Test
+    public void testReturnsByte_whenReadsUpToMarkLimit_withMoreBytesAvailable() throws IOException {
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[DATA_SIZE]));
+        is.mark(MARK_LIMIT);
+
+         for (int i = 0; i < MARK_LIMIT; i++) {
+             assertThat(is.read()).isAtLeast(0);
+         }
+    }
+
+    @Test
+    public void testReturnsByte_whenReadsUpToMarkLimit_withNoMoreBytesAvailable() throws IOException {
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[MARK_LIMIT]));
+
+        for (int i = 0; i < MARK_LIMIT; i++) {
+            assertThat(is.read()).isAtLeast(0);
+        }
+    }
+
+    @Test
+    public void testReturnsEndOfStream_whenReadsSingleBytePastMarkLimit() throws IOException {
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[DATA_SIZE]));
+
+        is.mark(MARK_LIMIT);
+        for (int i = 0; i < MARK_LIMIT; i++) {
+            assertThat(is.read()).isAtLeast(0);
+        }
+
+        assertEquals(-1, is.read());
+    }
+
+    @Test
+    public void testOverridesByteCount_whenReadBufferLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
+            throws IOException {
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[DATA_SIZE]));
+
+        is.mark(MARK_LIMIT);
+        byte[] buffer = new byte[DATA_SIZE];
+        assertEquals(MARK_LIMIT, is.read(buffer));
+    }
+
+    @Test
+    public void testReturnsEndOfStream_whenReadBufferLargerThanMarkLimit_withZeroBytesRemainingInMarkLimit()
+            throws IOException {
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[DATA_SIZE]));
+        is.mark(MARK_LIMIT);
+
+        byte[] buffer = new byte[MARK_LIMIT];
+        assertEquals(MARK_LIMIT, is.read(buffer));
+        assertEquals(-1, is.read(buffer));
+    }
+
+    @Test
+    public void testDoesNotReadIntoBuffer_withZeroBytesRemainingInMarkLimit() throws IOException {
+        byte[] expected = new byte[MARK_LIMIT];
+        for (int i = 0; i < MARK_LIMIT; i++) {
+            expected[i] = (byte) (i + 1);
+        }
+        byte[] buffer = new byte[MARK_LIMIT];
+        System.arraycopy(expected, 0, buffer, 0, MARK_LIMIT);
+
+        // All zeros.
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[DATA_SIZE]));
+        is.mark(MARK_LIMIT);
+        for (int i = 0; i < MARK_LIMIT; i++) {
+            assertThat(is.read()).isAtLeast(0);
+        }
+
+        assertEquals(-1, is.read(buffer));
+
+        assertThat(buffer).isEqualTo(expected);
+    }
+
+    @Test
+    public void testResetUnsetsLimit() throws IOException {
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[DATA_SIZE]));
+        is.mark(MARK_LIMIT);
+
+        for (int i = 0; i < MARK_LIMIT; i++) {
+            assertThat(is.read()).isAtLeast(0);
+        }
+
+        is.reset();
+
+        for (int i = 0; i < DATA_SIZE; i++) {
+            assertThat(is.read()).isAtLeast(0);
+        }
+    }
+
+    @Test
+    public void testOverridesByteCount_whenSkipCountLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
+            throws IOException {
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[DATA_SIZE]));
+        is.mark(MARK_LIMIT);
+
+        assertEquals(MARK_LIMIT, is.skip(DATA_SIZE));
+    }
+
+    @Test
+    public void testReturnsEndOfStream_whenSkipping_withZeroBytesRemainingInMarkLimit() throws IOException {
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(
+                new ByteArrayInputStream(new byte[DATA_SIZE]));
+        is.mark(MARK_LIMIT);
+
+        assertEquals(MARK_LIMIT, is.skip(DATA_SIZE));
+        assertEquals(-1, is.skip(1));
+    }
+
+    @Test
+    public void testReturnsStreamAvailable_whenMarkIsNotSet() throws IOException {
+        ByteArrayInputStream wrapped = new ByteArrayInputStream(new byte[MARK_LIMIT]);
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(wrapped);
+
+        assertEquals(wrapped.available(), is.available());
+    }
+
+    @Test
+    public void testReturnsStreamAvailable_whenMarkIsSet_withMarkGreaterThanStreamAvailable() throws IOException {
+        ByteArrayInputStream wrapped = new ByteArrayInputStream(new byte[MARK_LIMIT]);
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(wrapped);
+        is.mark(wrapped.available() + 1);
+
+        assertEquals(wrapped.available(), is.available());
+    }
+
+    @Test
+    public void testReturnsMarkLimitAsAvailable_whenMarkIsSet_withMarkLessThanStreamAvailable() throws IOException {
+        ByteArrayInputStream wrapped = new ByteArrayInputStream(new byte[MARK_LIMIT]);
+        MarkEnforcingInputStream is = new MarkEnforcingInputStream(wrapped);
+        int expected = wrapped.available() - 1;
+        is.mark(expected);
+
+        assertEquals(expected, is.available());
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/TransformationUtilsTest.java b/library/src/androidTest/java/com/bumptech/glide/util/TransformationUtilsTest.java
deleted file mode 100644
index 35e07c255..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/util/TransformationUtilsTest.java
+++ /dev/null
@@ -1,265 +0,0 @@
-package com.bumptech.glide.util;
-
-import android.graphics.Bitmap;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.bitmap.TransformationUtils;
-import org.hamcrest.core.CombinableMatcher;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-import static org.hamcrest.Matchers.closeTo;
-import static org.hamcrest.Matchers.either;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.lessThanOrEqualTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(shadows = { TransformationUtilsTest.AlphaShadowBitmap.class })
-public class TransformationUtilsTest {
-
-    @Test
-    public void testFitCenterWithWideBitmap() {
-        final int maxSide = 500;
-
-        Bitmap wide = Bitmap.createBitmap(2000, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(wide, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(wide, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithSmallWideBitmap() {
-        final int maxSide = 500;
-
-        Bitmap smallWide = Bitmap.createBitmap(400, 40, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(smallWide, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(smallWide, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithTallBitmap() {
-        final int maxSide = 500;
-
-        Bitmap tall = Bitmap.createBitmap(65, 3000, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(tall, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(tall, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithSmallTallBitmap() {
-        final int maxSide = 500;
-
-        Bitmap smallTall = Bitmap.createBitmap(10, 400, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(smallTall, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(smallTall, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithSquareBitmap() {
-        final int maxSide = 500;
-
-        Bitmap square = Bitmap.createBitmap(600, 600, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(square, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(square, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    @Test
-    public void testFitCenterWithTooSmallSquareBitmap() {
-        final int maxSide = 500;
-
-        Bitmap smallSquare = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap transformed = TransformationUtils.fitCenter(smallSquare, mock(BitmapPool.class), maxSide, maxSide);
-
-        assertHasOriginalAspectRatio(smallSquare, transformed);
-        assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
-    }
-
-    // Test for Issue #195.
-    @Test
-    public void testFitCenterUsesFloorInsteadofRoundingForOutputBitmapSize() {
-        Bitmap toTransform = Bitmap.createBitmap(1230, 1640, Bitmap.Config.RGB_565);
-
-        Bitmap transformed = TransformationUtils.fitCenter(toTransform, mock(BitmapPool.class), 1075, 1366);
-
-        assertEquals(1024, transformed.getWidth());
-        assertEquals(1366, transformed.getHeight());
-    }
-
-    @Test
-    public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-
-        toReuse.setHasAlpha(false);
-        toTransform.setHasAlpha(true);
-
-        Bitmap result = TransformationUtils.centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());
-
-        assertEquals(toReuse, result);
-        assertTrue(result.hasAlpha());
-    }
-
-    @Test
-    public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-
-        toReuse.setHasAlpha(true);
-        toTransform.setHasAlpha(false);
-
-        Bitmap result = TransformationUtils.centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());
-
-        assertEquals(toReuse, result);
-        assertFalse(result.hasAlpha());
-    }
-
-    @Test
-    public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        toTransform.setHasAlpha(true);
-
-        Bitmap result = TransformationUtils.centerCrop(null, toTransform, toTransform.getWidth() / 2,
-                toTransform.getHeight() / 2);
-
-        assertTrue(result.hasAlpha());
-    }
-
-    @Test
-    public void testSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        toTransform.setHasAlpha(false);
-
-        Bitmap result = TransformationUtils.centerCrop(null, toTransform, toTransform.getWidth() / 2,
-                toTransform.getHeight() / 2);
-
-        assertFalse(result.hasAlpha());
-    }
-
-    @Test
-    public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
-                .thenReturn(toReuse);
-
-        toReuse.setHasAlpha(false);
-        toTransform.setHasAlpha(true);
-
-        Bitmap result = TransformationUtils.fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());
-
-        assertEquals(toReuse, result);
-        assertTrue(result.hasAlpha());
-    }
-
-    @Test
-    public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-
-        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-        BitmapPool bitmapPool = mock(BitmapPool.class);
-        when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
-                .thenReturn(toReuse);
-
-        toReuse.setHasAlpha(true);
-        toTransform.setHasAlpha(false);
-
-        Bitmap result = TransformationUtils.fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());
-
-        assertEquals(toReuse, result);
-        assertFalse(result.hasAlpha());
-    }
-
-    @Test
-    public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        toTransform.setHasAlpha(true);
-
-        Bitmap result = TransformationUtils.fitCenter(toTransform, pool, toTransform.getWidth() / 2,
-                toTransform.getHeight() / 2);
-
-        assertTrue(result.hasAlpha());
-    }
-
-    @Test
-    public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
-        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-        BitmapPool pool = mock(BitmapPool.class);
-
-        toTransform.setHasAlpha(false);
-
-        Bitmap result = TransformationUtils.fitCenter(toTransform, pool, toTransform.getWidth() / 2,
-                toTransform.getHeight() / 2);
-
-        assertFalse(result.hasAlpha());
-    }
-
-    private static void assertHasOriginalAspectRatio(Bitmap original, Bitmap transformed) {
-        double originalAspectRatio = (double) original.getWidth() / (double) original.getHeight();
-        double transformedAspectRatio = (double) transformed.getWidth() / (double) transformed.getHeight();
-
-        assertThat("nearly identical aspect ratios", transformedAspectRatio, closeTo(originalAspectRatio, 0.05));
-    }
-
-    private static void assertBitmapFitsExactlyWithinBounds(int maxSide, Bitmap bitmap) {
-        final int width = bitmap.getWidth();
-        final int height = bitmap.getHeight();
-
-        assertThat("width", width, lessThanOrEqualTo(maxSide));
-        assertThat("height", height, lessThanOrEqualTo(maxSide));
-
-        // See https://code.google.com/p/hamcrest/issues/detail?id=82.
-        CombinableMatcher.CombinableEitherMatcher<Integer> eitherMatcher = either(equalTo(width));
-        assertThat("one side must match maxSide", maxSide, eitherMatcher.or(equalTo(height)));
-    }
-
-    @Implements(Bitmap.class)
-    public static class AlphaShadowBitmap extends ShadowBitmap {
-
-        private boolean hasAlpha;
-
-        @Implementation
-        public void setHasAlpha(boolean hasAlpha) {
-            this.hasAlpha = hasAlpha;
-        }
-
-        @Implementation
-        public boolean hasAlpha() {
-            return hasAlpha;
-        }
-    }
-}
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java
index f4ea53291..540fa16ea 100644
--- a/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java
@@ -1,13 +1,16 @@
 package com.bumptech.glide.util;
 
+import static org.junit.Assert.assertEquals;
+
 import android.graphics.Bitmap;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-
-import static org.junit.Assert.assertEquals;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class UtilTest {
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/src/androidTest/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
new file mode 100644
index 000000000..623db249a
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.util;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class ViewPreloadSizeProviderTest {
+
+    private View view;
+    private ViewPreloadSizeProvider<Object> provider;
+
+    @Before
+    public void setUp() {
+        view = new View(Robolectric.application);
+        provider = new ViewPreloadSizeProvider<Object>();
+    }
+
+    @Test
+    public void testReturnsNullFromGetPreloadSizeBeforeHasSize() {
+        assertNull(provider.getPreloadSize(new Object(), 0, 0));
+    }
+
+    @Test
+    public void testReturnsValidSizeFromGetPreloadSizeAfterHasSize() {
+        int width = 4123;
+        int height = 342;
+        provider.onSizeReady(width, height);
+
+        int[] size = provider.getPreloadSize(new Object(), 0, 0);
+        assertThat(size).asList().containsExactly(width, height);
+    }
+
+    @Test
+    public void testDoesNotObtainSizeFromViewOnceSizeIsSet() {
+        int width = 123;
+        int height = 456;
+        provider.onSizeReady(width, height);
+        view.setLayoutParams(new ViewGroup.LayoutParams(1, 1));
+
+        provider.setView(view);
+
+        int[] size = provider.getPreloadSize(new Object(), 0, 0);
+        assertThat(size).asList().containsExactly(width, height);
+    }
+
+    @Test
+    public void testCanObtainFixedSizeFromView() {
+        int width = 123;
+        int height = 456;
+        view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+
+        provider.setView(view);
+
+        int[] size = provider.getPreloadSize(new Object(), 0, 0);
+        assertThat(size).asList().containsExactly(width, height);
+    }
+
+    @Test
+    public void testIgnoresNewViewIfAlreadyWaitingOnSizeOfAnotherView() {
+        provider.setView(view);
+
+        View newView = new View(Robolectric.application);
+        newView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+        provider.setView(newView);
+
+        assertNull(provider.getPreloadSize(new Object(), 0, 0));
+    }
+
+    @Test
+    public void testCanObtainSizeFromViewWhenGivenViewInConstructor() {
+        int width = 100;
+        int height = 200;
+        view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+
+        provider = new ViewPreloadSizeProvider<Object>(view);
+
+        int[] size = provider.getPreloadSize(new Object(), 0, 0);
+        assertThat(size).asList().containsExactly(width, height);
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/resources/org.robolectric.Config.properties b/library/src/androidTest/resources/org.robolectric.Config.properties
index 89ace4f52..3219ec4f1 100644
--- a/library/src/androidTest/resources/org.robolectric.Config.properties
+++ b/library/src/androidTest/resources/org.robolectric.Config.properties
@@ -1,2 +1,3 @@
-emulateSdk = 18
-reportSdk = 18
+# Exists only to "enable" logging for test coverage.
+# TODO: when we can ignore Log.* via configuration, remove this line.
+shadows=com.bumptech.glide.tests.GlideShadowLog
diff --git a/library/src/androidTest/resources/short_exif_sample.jpg b/library/src/androidTest/resources/short_exif_sample.jpg
new file mode 100644
index 000000000..80f8ebd49
Binary files /dev/null and b/library/src/androidTest/resources/short_exif_sample.jpg differ
diff --git a/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java
index 15b4ca856..07e7c4ab6 100644
--- a/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java
@@ -5,6 +5,7 @@
 import android.os.ParcelFileDescriptor;
 import android.view.animation.Animation;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -391,7 +392,7 @@
      */
     @Override
     public BitmapRequestBuilder<ModelType, TranscodeType> listener(
-            RequestListener<ModelType, TranscodeType> requestListener) {
+            RequestListener<? super ModelType, TranscodeType> requestListener) {
         super.listener(requestListener);
         return this;
     }
diff --git a/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java
index 485b10fda..8e2b227ca 100644
--- a/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java
+++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.load.model.ImageVideoModelLoader;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
 import com.bumptech.glide.load.model.ModelLoader;
diff --git a/library/src/main/java/com/bumptech/glide/DownloadOptions.java b/library/src/main/java/com/bumptech/glide/DownloadOptions.java
index dc4c73baa..ae472c857 100644
--- a/library/src/main/java/com/bumptech/glide/DownloadOptions.java
+++ b/library/src/main/java/com/bumptech/glide/DownloadOptions.java
@@ -21,8 +21,8 @@
      * Loads the original unmodified data into the cache and returns a {@link java.util.concurrent.Future} that can be
      * used to retrieve the cache File containing the data.
      *
-     * @param width The width to use to fetch the data.
-     * @param height The height to use to fetch the data.
+     * @param width The width in pixels to use to fetch the data.
+     * @param height The height in pixels to use to fetch the data.
      * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the data.
      */
     FutureTarget<File> downloadOnly(int width, int height);
diff --git a/library/src/main/java/com/bumptech/glide/DrawableOptions.java b/library/src/main/java/com/bumptech/glide/DrawableOptions.java
index 74e7eae9e..ebc1aa5c1 100644
--- a/library/src/main/java/com/bumptech/glide/DrawableOptions.java
+++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java
@@ -41,6 +41,7 @@
      * asked to start an animation using a single {@link android.view.animation.Animation} object which results in
      * views animating repeatedly. Use {@link #crossFade(int, int)}} instead, or be sure to call this method once
      * per call to {@link com.bumptech.glide.GenericRequestBuilder#load(Object)} to avoid re-using animation objects.
+     * Scheduled to be removed in Glide 4.0.
      * @param animation The Animation to use if no placeholder is set.
      * @param duration The duration of the cross fade animation.
      * @return This request builder.
diff --git a/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java
index 788027650..845a01e8c 100644
--- a/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java
@@ -5,6 +5,7 @@
 import android.graphics.drawable.Drawable;
 import android.view.animation.Animation;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -21,7 +22,7 @@
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.provider.LoadProvider;
 import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.animation.DrawableCrossFadeViewAnimation;
+import com.bumptech.glide.request.animation.DrawableCrossFadeFactory;
 import com.bumptech.glide.request.animation.ViewPropertyAnimation;
 import com.bumptech.glide.request.target.Target;
 
@@ -242,7 +243,7 @@
      * {@inheritDoc}
      */
     public final DrawableRequestBuilder<ModelType> crossFade() {
-        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>());
+        super.animate(new DrawableCrossFadeFactory<GlideDrawable>());
         return this;
     }
 
@@ -250,7 +251,7 @@
      * {@inheritDoc}
      */
     public DrawableRequestBuilder<ModelType> crossFade(int duration) {
-        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(duration));
+        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(duration));
         return this;
     }
 
@@ -259,7 +260,7 @@
      */
     @Deprecated
     public DrawableRequestBuilder<ModelType> crossFade(Animation animation, int duration) {
-        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(animation, duration));
+        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(animation, duration));
         return this;
     }
 
@@ -267,7 +268,7 @@
      * {@inheritDoc}
      */
     public DrawableRequestBuilder<ModelType> crossFade(int animationId, int duration) {
-        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(context, animationId,
+        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(context, animationId,
                 duration));
         return this;
     }
@@ -350,7 +351,8 @@
      * {@inheritDoc}
      */
     @Override
-    public DrawableRequestBuilder<ModelType> listener(RequestListener<ModelType, GlideDrawable> requestListener) {
+    public DrawableRequestBuilder<ModelType> listener(
+            RequestListener<? super ModelType, GlideDrawable> requestListener) {
         super.listener(requestListener);
         return this;
     }
diff --git a/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java
index 84d3a273f..ee67f1a3c 100644
--- a/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java
+++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.load.model.ImageVideoModelLoader;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
 import com.bumptech.glide.load.model.ModelLoader;
diff --git a/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java
index 84b1828f6..065794850 100644
--- a/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java
@@ -4,7 +4,7 @@
 import android.graphics.drawable.Drawable;
 import android.view.animation.Animation;
 import android.widget.ImageView;
-import com.bumptech.glide.signature.EmptySignature;
+
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.MultiTransformation;
@@ -27,10 +27,12 @@
 import com.bumptech.glide.request.ThumbnailRequestCoordinator;
 import com.bumptech.glide.request.animation.GlideAnimationFactory;
 import com.bumptech.glide.request.animation.NoAnimation;
-import com.bumptech.glide.request.animation.ViewAnimation;
+import com.bumptech.glide.request.animation.ViewAnimationFactory;
 import com.bumptech.glide.request.animation.ViewPropertyAnimation;
+import com.bumptech.glide.request.animation.ViewPropertyAnimationFactory;
 import com.bumptech.glide.request.target.PreloadTarget;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.signature.EmptySignature;
 import com.bumptech.glide.util.Util;
 
 import java.io.File;
@@ -60,7 +62,7 @@
     private boolean isModelSet;
     private int placeholderId;
     private int errorId;
-    private RequestListener<ModelType, TranscodeType> requestListener;
+    private RequestListener<? super ModelType, TranscodeType> requestListener;
     private Float thumbSizeMultiplier;
     private GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequestBuilder;
     private Float sizeMultiplier = 1f;
@@ -74,6 +76,7 @@
     private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
     private Transformation<ResourceType> transformation = UnitTransformation.get();
     private boolean isTransformationSet;
+    private boolean isThumbnailBuilt;
 
     GenericRequestBuilder(LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
             Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
@@ -123,6 +126,10 @@
      */
     public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
             GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
+        if (this.equals(thumbnailRequest)) {
+            throw new IllegalArgumentException("You cannot set a request as a thumbnail for itself. Consider using "
+                    + "clone() on the request you are passing to thumbnail()");
+        }
         this.thumbnailRequestBuilder = thumbnailRequest;
 
         return this;
@@ -367,7 +374,7 @@
      * @return This request builder.
      */
     public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(int animationId) {
-        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(context, animationId));
+        return animate(new ViewAnimationFactory<TranscodeType>(context, animationId));
     }
 
     /**
@@ -380,13 +387,14 @@
      * @deprecated If this builder is used for multiple loads, using this method will result in multiple view's being
      * asked to start an animation using a single {@link android.view.animation.Animation} object which results in
      * views animating repeatedly. Use {@link #animate(int)} or
-     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}.
+     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in
+     * Glide 4.0.
      * @param animation The animation to run
      * @return This request builder.
      */
     @Deprecated
     public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(Animation animation) {
-        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(animation));
+        return animate(new ViewAnimationFactory<TranscodeType>(animation));
     }
 
     /**
@@ -399,7 +407,7 @@
      */
     public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
             ViewPropertyAnimation.Animator animator) {
-        return animate(new ViewPropertyAnimation.ViewPropertyAnimationFactory<TranscodeType>(animator));
+        return animate(new ViewPropertyAnimationFactory<TranscodeType>(animator));
     }
 
     GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
@@ -474,7 +482,7 @@
      * @return This request builder.
      */
     public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> listener(
-            RequestListener<ModelType, TranscodeType> requestListener) {
+            RequestListener<? super ModelType, TranscodeType> requestListener) {
         this.requestListener = requestListener;
 
         return this;
@@ -502,16 +510,13 @@
      * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or
      * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}.
      *
-     * @param width The width to use to load the resource.
-     * @param height The height to use to load the resource.
+     * @param width The width in pixels to use to load the resource.
+     * @param height The height in pixels to use to load the resource.
      * @return This request builder.
      */
     public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {
-        if (width <= 0) {
-            throw new IllegalArgumentException("Width must be > 0");
-        }
-        if (height <= 0) {
-            throw new IllegalArgumentException("Height must be > 0");
+        if (!Util.isValidDimensions(width, height)) {
+            throw new IllegalArgumentException("Width and height must be Target#SIZE_ORIGINAL or > 0");
         }
         this.overrideWidth = width;
         this.overrideHeight = height;
@@ -640,8 +645,7 @@
                     break;
                 //$CASES-OMITTED$
                 default:
-                    // silently ignore
-                    break;
+                    // Do nothing.
             }
         }
 
@@ -651,10 +655,10 @@
     /**
      * Returns a future that can be used to do a blocking get on a background thread.
      *
-     * @param width The desired width (note this will be overriden by {@link #override(int, int)} if
-     *              previously called.
-     * @param height The desired height (note this will be overriden by {@link #override(int, int)}}
-     *               if previously called.
+     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
+     *             {@link #override * (int, int)} if previously called.
+     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
+     *              {@link #override * (int, int)}} if previously called).
      *
      * @see Glide#clear(com.bumptech.glide.request.FutureTarget)
      *
@@ -686,13 +690,34 @@ public void run() {
      *     available quickly.
      * </p>
      *
+     *
      * @see com.bumptech.glide.ListPreloader
+     *
+     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
+     *             {@link #override * (int, int)} if previously called.
+     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
+     *              {@link #override * (int, int)}} if previously called).
+     * @return A {@link Target} that can be used to cancel the load via
+     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
      */
     public Target<TranscodeType> preload(int width, int height) {
         final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(width, height);
         return into(target);
     }
 
+    /**
+     * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and height.
+     * Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as the width and height.
+     *
+     * @see #preload(int, int)
+     *
+     * @return A {@link Target} that can be used to cancel the load via
+     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
+     */
+    public Target<TranscodeType> preload() {
+        return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+    }
+
     void applyCenterCrop() {
         // To be implemented by subclasses when possible.
     }
@@ -722,6 +747,10 @@ private Request buildRequest(Target<TranscodeType> target) {
 
     private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
         if (thumbnailRequestBuilder != null) {
+            if (isThumbnailBuilt) {
+                throw new IllegalStateException("You cannot use a request as both the main request and a thumbnail, "
+                        + "consider using clone() on the request(s) passed to thumbnail()");
+            }
             // Recursive case: contains a potentially recursive thumbnail request builder.
             if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
                 thumbnailRequestBuilder.animationFactory = animationFactory;
@@ -731,10 +760,19 @@ private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailReq
                 thumbnailRequestBuilder.priority = getThumbnailPriority();
             }
 
+            if (Util.isValidDimensions(overrideWidth, overrideHeight)
+                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
+                            thumbnailRequestBuilder.overrideHeight)) {
+              thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
+            }
+
             ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
             Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
+            // Guard against infinite recursion.
+            isThumbnailBuilt = true;
             // Recursively generate thumbnail requests.
             Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
+            isThumbnailBuilt = false;
             coordinator.setRequests(fullRequest, thumbRequest);
             return coordinator;
         } else if (thumbSizeMultiplier != null) {
diff --git a/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java
index 9c0b4efa7..ca6292369 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide;
 
 import android.content.Context;
+
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
diff --git a/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java
index ffde6fe1d..474f2e7c0 100644
--- a/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.view.animation.Animation;
+
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -15,7 +16,7 @@
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.provider.LoadProvider;
 import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.animation.DrawableCrossFadeViewAnimation;
+import com.bumptech.glide.request.animation.DrawableCrossFadeFactory;
 import com.bumptech.glide.request.animation.ViewPropertyAnimation;
 
 import java.io.File;
@@ -229,7 +230,7 @@
      */
     @Override
     public GifRequestBuilder<ModelType> crossFade() {
-        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GifDrawable>());
+        super.animate(new DrawableCrossFadeFactory<GifDrawable>());
         return this;
     }
 
@@ -238,7 +239,7 @@
      */
     @Override
     public GifRequestBuilder<ModelType> crossFade(int duration) {
-        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GifDrawable>(duration));
+        super.animate(new DrawableCrossFadeFactory<GifDrawable>(duration));
         return this;
     }
 
@@ -248,7 +249,7 @@
     @Deprecated
     @Override
     public GifRequestBuilder<ModelType> crossFade(Animation animation, int duration) {
-        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GifDrawable>(animation, duration));
+        super.animate(new DrawableCrossFadeFactory<GifDrawable>(animation, duration));
         return this;
     }
 
@@ -257,7 +258,7 @@
      */
     @Override
     public GifRequestBuilder<ModelType> crossFade(int animationId, int duration) {
-        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GifDrawable>(context, animationId,
+        super.animate(new DrawableCrossFadeFactory<GifDrawable>(context, animationId,
                 duration));
         return this;
     }
@@ -341,7 +342,7 @@
      */
     @Override
     public GifRequestBuilder<ModelType> listener(
-            RequestListener<ModelType, GifDrawable> requestListener) {
+            RequestListener<? super ModelType, GifDrawable> requestListener) {
         super.listener(requestListener);
         return this;
     }
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 905c3a5eb..1a7f9a6d9 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -15,12 +15,13 @@
 import android.util.Log;
 import android.view.View;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
-import com.bumptech.glide.load.engine.prefill.PreFillBitmapAttribute;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.prefill.BitmapPreFiller;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.prefill.BitmapPreFiller;
+import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
@@ -55,6 +56,8 @@
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.load.resource.transcode.TranscoderRegistry;
 import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.module.ManifestParser;
 import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.provider.DataLoadProviderRegistry;
 import com.bumptech.glide.request.FutureTarget;
@@ -68,6 +71,7 @@
 import java.io.File;
 import java.io.InputStream;
 import java.net.URL;
+import java.util.List;
 
 /**
  * A singleton to present a simple static interface for building requests with {@link BitmapRequestBuilder} and
@@ -82,7 +86,7 @@
     private static final String TAG = "Glide";
     private static volatile Glide glide;
 
-    private final GenericLoaderFactory loaderFactory = new GenericLoaderFactory();
+    private final GenericLoaderFactory loaderFactory;
     private final Engine engine;
     private final BitmapPool bitmapPool;
     private final MemoryCache memoryCache;
@@ -143,7 +147,17 @@ public static Glide get(Context context) {
         if (glide == null) {
             synchronized (Glide.class) {
                 if (glide == null) {
-                    glide = new GlideBuilder(context).createGlide();
+                    Context applicationContext = context.getApplicationContext();
+                    List<GlideModule> modules = new ManifestParser(applicationContext).parse();
+
+                    GlideBuilder builder = new GlideBuilder(applicationContext);
+                    for (GlideModule module : modules) {
+                        module.applyOptions(applicationContext, builder);
+                    }
+                    glide = builder.createGlide();
+                    for (GlideModule module : modules) {
+                        module.registerComponents(applicationContext, glide);
+                    }
                 }
             }
         }
@@ -156,7 +170,10 @@ public static Glide get(Context context) {
      * {@link #setup(GlideBuilder)}.
      *
      * @see #setup(GlideBuilder)
+     *
+     * @deprecated Use {@link com.bumptech.glide.module.GlideModule} instead. Scheduled to be removed in Glide 4.0.
      */
+    @Deprecated
     public static boolean isSetup() {
         return glide != null;
     }
@@ -167,9 +184,11 @@ public static boolean isSetup() {
      *
      * @see #isSetup()
      *
+     * @deprecated Use {@link com.bumptech.glide.module.GlideModule} instead. Scheduled to be removed in Glide 4.0.
      * @param builder The builder.
      * @throws IllegalArgumentException if the Glide singleton has already been created.
      */
+    @Deprecated
     public static void setup(GlideBuilder builder) {
         if (isSetup()) {
             throw new IllegalArgumentException("Glide is already setup, check with isSetup() first");
@@ -188,8 +207,9 @@ static void tearDown() {
         this.bitmapPool = bitmapPool;
         this.memoryCache = memoryCache;
         this.decodeFormat = decodeFormat;
+        loaderFactory = new GenericLoaderFactory(context);
         mainHandler = new Handler(Looper.getMainLooper());
-        bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool);
+        bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
 
         dataLoadProviderRegistry = new DataLoadProviderRegistry();
 
@@ -206,7 +226,7 @@ static void tearDown() {
         dataLoadProviderRegistry.register(ImageVideoWrapper.class, Bitmap.class, imageVideoDataLoadProvider);
 
         GifDrawableLoadProvider gifDrawableLoadProvider =
-                new GifDrawableLoadProvider(context, bitmapPool, decodeFormat);
+                new GifDrawableLoadProvider(context, bitmapPool);
         dataLoadProviderRegistry.register(InputStream.class, GifDrawable.class, gifDrawableLoadProvider);
 
         dataLoadProviderRegistry.register(ImageVideoWrapper.class, GifBitmapWrapper.class,
@@ -333,17 +353,18 @@ private GenericLoaderFactory getLoaderFactory() {
      *     pre-filling only happens when the Activity is first created, rather than on every rotation.
      * </p>
      *
-     * @param bitmapAttributes The list of {@link com.bumptech.glide.load.engine.prefill.PreFillBitmapAttribute}s
-     *                         representing individual sizes and configurations of {@link android.graphics.Bitmap}s to
-     *                         be pre-filled.
+     * @param bitmapAttributeBuilders The list of
+     *     {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
+     *     individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
      */
-    public void preFillBitmapPool(PreFillBitmapAttribute... bitmapAttributes) {
-        bitmapPreFiller.preFill(bitmapAttributes);
+    public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
+        bitmapPreFiller.preFill(bitmapAttributeBuilders);
     }
 
     /**
      * Clears as much memory as possible.
      *
+     * @see android.content.ComponentCallbacks#onLowMemory()
      * @see android.content.ComponentCallbacks2#onLowMemory()
      */
     public void clearMemory() {
@@ -361,6 +382,18 @@ public void trimMemory(int level) {
         memoryCache.trimMemory(level);
     }
 
+    /**
+     * Clears disk cache.
+     *
+     * <p>
+     *     This method should always be called on a background thread, since it is a blocking call.
+     * </p>
+     */
+    public void clearDiskCache() {
+        Util.assertBackgroundThread();
+        getEngine().clearDiskCache();
+    }
+
     /**
      * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
      *
@@ -458,11 +491,14 @@ public static void clear(View view) {
      * Removes any {@link ModelLoaderFactory} registered for the given model and resource classes if one exists. If a
      * {@link ModelLoaderFactory} is removed, its {@link ModelLoaderFactory#teardown()}} method will be called.
      *
+     * @deprecated Use {@link #register(Class, Class, com.bumptech.glide.load.model.ModelLoaderFactory)} to replace
+     * a registered loader rather than simply removing it.
      * @param modelClass The model class.
      * @param resourceClass The resource class.
      * @param <T> The type of the model.
      * @param <Y> The type of the resource.
      */
+    @Deprecated
     public <T, Y> void unregister(Class<T> modelClass, Class<Y> resourceClass) {
         ModelLoaderFactory<T, Y> removed = loaderFactory.unregister(modelClass, resourceClass);
         if (removed != null) {
@@ -492,7 +528,7 @@ public static void clear(View view) {
             }
             return null;
         }
-        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass, context);
+        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);
     }
 
     /**
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index f7ffcecb2..31fcc98f4 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -2,20 +2,19 @@
 
 import android.content.Context;
 import android.os.Build;
+
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
-import com.bumptech.glide.load.engine.cache.DiskCacheAdapter;
-import com.bumptech.glide.load.engine.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.load.engine.cache.InternalCacheDiskCacheFactory;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
 import com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor;
 
-import java.io.File;
 import java.util.concurrent.ExecutorService;
 
 /**
@@ -27,10 +26,10 @@
     private Engine engine;
     private BitmapPool bitmapPool;
     private MemoryCache memoryCache;
-    private DiskCache diskCache;
     private ExecutorService sourceService;
     private ExecutorService diskCacheService;
     private DecodeFormat decodeFormat;
+    private DiskCache.Factory diskCacheFactory;
 
     public GlideBuilder(Context context) {
         this.context = context.getApplicationContext();
@@ -64,11 +63,32 @@ public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
      * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
      * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
      *
+     * @deprecated Creating a disk cache directory on the main thread causes strict mode violations, use
+     * {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead. Scheduled to be removed
+     * in Glide 4.0.
      * @param diskCache The disk cache to use.
      * @return This builder.
      */
-    public GlideBuilder setDiskCache(DiskCache diskCache) {
-        this.diskCache = diskCache;
+    @Deprecated
+    public GlideBuilder setDiskCache(final DiskCache diskCache) {
+        return setDiskCache(new DiskCache.Factory() {
+            @Override
+            public DiskCache build() {
+                return diskCache;
+            }
+        });
+    }
+
+    /**
+     * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use to construct
+     * the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store
+     * {@link com.bumptech.glide.load.engine.Resource} data on disk.
+     *
+     * @param diskCacheFactory The disk cche factory to use.
+     * @return This builder.
+     */
+    public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
+        this.diskCacheFactory = diskCacheFactory;
         return this;
     }
 
@@ -127,6 +147,10 @@ public GlideBuilder setDiskCacheService(ExecutorService service) {
      *     {@link com.bumptech.glide.load.DecodeFormat#DEFAULT} as its default.
      * </p>
      *
+     * <p>
+     *     Calls to this method are ignored on KitKat and Lollipop. See #301.
+     * </p>
+     *
      * @param decodeFormat The format to use.
      * @return This builder.
      */
@@ -153,7 +177,8 @@ Glide createGlide() {
         MemorySizeCalculator calculator = new MemorySizeCalculator(context);
         if (bitmapPool == null) {
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-                bitmapPool = new LruBitmapPool(calculator.getBitmapPoolSize());
+                int size = calculator.getBitmapPoolSize();
+                bitmapPool = new LruBitmapPool(size);
             } else {
                 bitmapPool = new BitmapPoolAdapter();
             }
@@ -163,18 +188,12 @@ Glide createGlide() {
             memoryCache = new LruResourceCache(calculator.getMemoryCacheSize());
         }
 
-        if (diskCache == null) {
-            File cacheDir = Glide.getPhotoCacheDir(context);
-            if (cacheDir != null) {
-                diskCache = DiskLruCacheWrapper.get(cacheDir, Glide.DEFAULT_DISK_CACHE_SIZE);
-            }
-            if (diskCache == null) {
-                diskCache = new DiskCacheAdapter();
-            }
+        if (diskCacheFactory == null) {
+            diskCacheFactory = new InternalCacheDiskCacheFactory(context, Glide.DEFAULT_DISK_CACHE_SIZE);
         }
 
         if (engine == null) {
-            engine = new Engine(memoryCache, diskCache, diskCacheService, sourceService);
+            engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);
         }
 
         if (decodeFormat == null) {
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index 7d5158a77..6679c20bc 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -16,15 +16,18 @@
  * cache, depending on scrolling speed, cpu speed, and cache size.
  *
  * <p>
- *  Must be set using {@link AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)}, or have its
- *  corresponding methods called from another {@link android.widget.AbsListView.OnScrollListener} to function.
+ * Must be set using {@link AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)}, or have its
+ * corresponding methods called from another {@link android.widget.AbsListView.OnScrollListener} to function.
  * </p>
  *
  * @param <T> The type of the model being displayed in the list.
  */
-public abstract class ListPreloader<T> implements AbsListView.OnScrollListener {
+public class ListPreloader<T> implements AbsListView.OnScrollListener {
+
     private final int maxPreload;
     private final PreloadTargetQueue preloadTargetQueue;
+    private final PreloadModelProvider<T> preloadModelProvider;
+    private final PreloadSizeProvider<T> preloadDimensionProvider;
 
     private int lastEnd;
     private int lastStart;
@@ -34,11 +37,104 @@
     private boolean isIncreasing = true;
 
     /**
-     * Constructor for the preloader.
+     * An implementation of PreloadModelProvider should provide all the models that should be preloaded.
+     *
+     * @param <U> The type of the model being preloaded.
+     */
+    public interface PreloadModelProvider<U> {
+
+        /**
+         * Returns a non null list of all models that need to be loaded for the list to display adapter items in
+         * positions between {@code start} and {@code end}.
+         *
+         * <p>
+         * A list of any size can be returned so there can be multiple models per adapter position.
+         * </p>
+         *
+         * @param position The adapter position.
+         */
+        List<U> getPreloadItems(int position);
+
+        /**
+         * Returns a non null {@link com.bumptech.glide.GenericRequestBuilder} for a given item. Must exactly match
+         * the request used to load the resource in the list.
+         *
+         * <p>
+         * The target and context will be provided by the preloader.
+         * </p>
+         *
+         * @param item The model to load.
+         */
+        GenericRequestBuilder getPreloadRequestBuilder(U item);
+    }
+
+    /**
+     * An implementation of PreloadSizeProvider should provide the size of the view in the list where the resources
+     * will be displayed.
+     *
+     * @param <T> The type of the model the size should be provided for.
+     */
+    public interface PreloadSizeProvider<T> {
+
+        /**
+         * Returns the size of the view in the list where the resources will be displayed in pixels in the format
+         * [x, y], or {@code null} if no size is currently available.
+         *
+         * <p>
+         * Note - The dimensions returned here must precisely match those of the view in the list.
+         * </p>
+         *
+         * @param item A model
+         */
+        int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
+    }
+
+    /**
+     * Constructor for {@link com.bumptech.glide.ListPreloader} that requires users to subclass and override
+     * the {@link #getItems(int, int)} and {@link #getRequestBuilder(Object)} methods.
      *
-     * @param maxPreload The maximum number of items in the list to load ahead (corresponds to adapter positions).
+     * @deprecated Use {@link #ListPreloader(com.bumptech.glide.ListPreloader.PreloadModelProvider,
+     * com.bumptech.glide.ListPreloader.PreloadSizeProvider, int)} instead. This constructor will be removed in Glide
+     * 4.0.
+     * @param maxPreload Maximum number of items to preload.
      */
+    @Deprecated
     public ListPreloader(int maxPreload) {
+        this.preloadModelProvider = new PreloadModelProvider<T>() {
+            @Override
+            public List<T> getPreloadItems(int position) {
+                return getItems(position, position + 1);
+            }
+
+            @Override
+            public GenericRequestBuilder getPreloadRequestBuilder(T item) {
+                return getRequestBuilder(item);
+            }
+        };
+        this.preloadDimensionProvider = new PreloadSizeProvider<T>() {
+
+            @Override
+            public int[] getPreloadSize(T item, int adapterPosition, int perItemPosition) {
+                return getDimensions(item);
+            }
+        };
+        this.maxPreload = maxPreload;
+        preloadTargetQueue = new PreloadTargetQueue(maxPreload + 1);
+
+    }
+
+    /**
+     * Constructor for {@link com.bumptech.glide.ListPreloader} that accepts interfaces for providing the dimensions of
+     * images to preload, the list of models to preload for a given position, and the request to use to load images.
+     *
+     * @param preloadModelProvider     Provides models to load and requests capable of loading them.
+     * @param preloadDimensionProvider Provides the dimensions of images to load.
+     * @param maxPreload               Maximum number of items to preload.
+     */
+    public ListPreloader(PreloadModelProvider<T> preloadModelProvider,
+                         PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+        this.preloadModelProvider = preloadModelProvider;
+        this.preloadDimensionProvider = preloadDimensionProvider;
         this.maxPreload = maxPreload;
         preloadTargetQueue = new PreloadTargetQueue(maxPreload + 1);
     }
@@ -49,7 +145,8 @@ public void onScrollStateChanged(AbsListView absListView, int scrollState) {
     }
 
     @Override
-    public void onScroll(AbsListView absListView, int firstVisible, int visibleCount, int totalCount) {
+    public void onScroll(AbsListView absListView, int firstVisible, int visibleCount,
+                         int totalCount) {
         totalItemCount = totalCount;
         if (firstVisible > lastFirstVisible) {
             preload(firstVisible + visibleCount, true);
@@ -60,34 +157,61 @@ public void onScroll(AbsListView absListView, int firstVisible, int visibleCount
     }
 
     /**
-     * Returns the dimensions of the view in the list where the resources will be displayed.
+     * Returns the size of the view in the list where the resources will be displayed.
+     *
      * <p>
-     *     Note - The dimensions returned here must precisely match those of the view in the list.
+     * Note - The size returned here must precisely match those of the view in the list.
      * </p>
+     *
+     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} instead. This method will be removed
+     * in Glide 4.0.
      * @param item A model
-     * @return The dimensions of the view where the item will be displayed
+     * @return The size of the view where the item will be displayed
      */
-    protected abstract int[] getDimensions(T item);
+    @Deprecated
+    protected int[] getDimensions(T item) {
+        throw new IllegalStateException("You must either provide a PreloadDimensionProvider or override "
+                                         + "getDimensions()");
+    }
 
     /**
-     * Returns a list of all models that need to be loaded for the list to display adapter items {@code start - end}.
+     * Returns a non null list of all models that need to be loaded for the list to display adapter items
+     * between {@code start} and {@code end}.
+     *
+     * <p>
      * A list of any size can be returned so there can be multiple models per adapter position.
+     * </p>
      *
-     * @param start The smallest adapter position. Will be {@code >= 0 && < adapter.getCount() && <= end}
-     * @param end The largest adapter position. Will be {@code >= 0 && < adapter.getCount && >= start}
-     * @return A non null list of all models for adapter positions between {@code start} and {@code end}.
+     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadModelProvider} instead. This method will be
+     * removed in Glide 4.0.
+     * @param start The smallest adapter position. Will be {@code >= 0 && < adapter.getCount() &&
+     *              <= end}
+     * @param end   The largest adapter position. Will be {@code >= 0 && < adapter.getCount && >=
+     *              start}
      */
-    protected abstract List<T> getItems(int start, int end);
+    @Deprecated
+    protected List<T> getItems(int start, int end) {
+        throw new IllegalStateException("You must either provide a PreloadModelProvider or override getItems()");
+    }
 
     /**
-     * Returns a glide request for a given item. Must exactly match the request used to load the resource in the list.
+     * Returns a non null {@link com.bumptech.glide.GenericRequestBuilder} for a given item. Must exactly match the
+     * request used to load the resource in the list.
+     *
+     * <p>
      * The target and context will be provided by the preloader.
+     * </p>
      *
+     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadModelProvider} instead. This method will be
+     * removed in Glide 4.0.
      * @param item The model to load.
-     * @return A non null {@link BitmapRequestBuilder}.
      */
     @SuppressWarnings("rawtypes")
-    protected abstract GenericRequestBuilder getRequestBuilder(T item);
+    @Deprecated
+    protected GenericRequestBuilder getRequestBuilder(T item) {
+        throw new IllegalStateException("You must either provide a PreloadModelProvider, or override "
+                                         + "getRequestBuilder()");
+    }
 
     private void preload(int start, boolean increasing) {
         if (isIncreasing != increasing) {
@@ -109,18 +233,16 @@ private void preload(int from, int to) {
         }
         end = Math.min(totalItemCount, end);
         start = Math.min(totalItemCount, Math.max(0, start));
-        List<T> items = getItems(start, end);
 
         if (from < to) {
             // Increasing
-            final int numItems = items.size();
-            for (int i = 0; i < numItems; i++) {
-                preloadItem(items, i);
+            for (int i = start; i < end; i++) {
+                preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, true);
             }
         } else {
             // Decreasing
-            for (int i = items.size() - 1; i >= 0; i--) {
-                preloadItem(items, i);
+            for (int i = end - 1; i >= start; i--) {
+                preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, false);
             }
         }
 
@@ -128,12 +250,25 @@ private void preload(int from, int to) {
         lastEnd = end;
     }
 
+    private void preloadAdapterPosition(List<T> items, int position, boolean isIncreasing) {
+        final int numItems = items.size();
+        if (isIncreasing) {
+            for (int i = 0; i < numItems; ++i) {
+                preloadItem(items.get(i), position, i);
+            }
+        } else {
+            for (int i = numItems - 1; i >= 0; --i) {
+                preloadItem(items.get(i), position, i);
+            }
+        }
+    }
+
     @SuppressWarnings("unchecked")
-    private void preloadItem(List<T> items, int position) {
-        final T item = items.get(position);
-        final int[] dimensions = getDimensions(item);
+    private void preloadItem(T item, int position, int i) {
+        final int[] dimensions = this.preloadDimensionProvider.getPreloadSize(item, position, i);
         if (dimensions != null) {
-            getRequestBuilder(item).into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
+            GenericRequestBuilder preloadRequestBuilder = this.preloadModelProvider.getPreloadRequestBuilder(item);
+            preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
         }
     }
 
@@ -168,7 +303,8 @@ public PreloadTarget next(int width, int height) {
         private int photoWidth;
 
         @Override
-        public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {
+        public void onResourceReady(Object resource,
+                                    GlideAnimation<? super Object> glideAnimation) {
             // Do nothing.
         }
 
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 17a3f2803..17da8cc61 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -5,10 +5,9 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.MediaStoreSignature;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.file_descriptor.FileDescriptorModelLoader;
 import com.bumptech.glide.load.model.stream.MediaStoreStreamLoader;
@@ -18,7 +17,10 @@
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.LifecycleListener;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
+import com.bumptech.glide.signature.ApplicationVersionSignature;
+import com.bumptech.glide.signature.MediaStoreSignature;
 import com.bumptech.glide.signature.StringSignature;
 import com.bumptech.glide.util.Util;
 
@@ -41,19 +43,21 @@
 public class RequestManager implements LifecycleListener {
     private final Context context;
     private final Lifecycle lifecycle;
+    private final RequestManagerTreeNode treeNode;
     private final RequestTracker requestTracker;
     private final Glide glide;
     private final OptionsApplier optionsApplier;
     private DefaultOptions options;
 
-    public RequestManager(Context context, Lifecycle lifecycle) {
-        this(context, lifecycle, new RequestTracker(), new ConnectivityMonitorFactory());
+    public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+        this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());
     }
 
-    RequestManager(Context context, final Lifecycle lifecycle, RequestTracker requestTracker,
-            ConnectivityMonitorFactory factory) {
-        this.context = context;
+    RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,
+            RequestTracker requestTracker, ConnectivityMonitorFactory factory) {
+        this.context = context.getApplicationContext();
         this.lifecycle = lifecycle;
+        this.treeNode = treeNode;
         this.requestTracker = requestTracker;
         this.glide = Glide.get(context);
         this.optionsApplier = new OptionsApplier();
@@ -77,6 +81,20 @@ public void run() {
         lifecycle.addListener(connectivityMonitor);
     }
 
+    /**
+     * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+     */
+    public void onTrimMemory(int level) {
+        glide.trimMemory(level);
+    }
+
+    /**
+     * @see android.content.ComponentCallbacks2#onLowMemory()
+     */
+    public void onLowMemory() {
+        glide.clearMemory();
+    }
+
     /**
      * An interface that allows a default set of options to be applied to all requests started from an
      * {@link com.bumptech.glide.RequestManager}.
@@ -130,6 +148,27 @@ public void pauseRequests() {
         requestTracker.pauseRequests();
     }
 
+    /**
+     * Performs {@link #pauseRequests()} recursively for all managers that are contextually descendant
+     * to this manager based on the Activity/Fragment hierarchy:
+     *
+     * <ul>
+     * <li>When pausing on an Activity all attached fragments will also get paused.
+     * <li>When pausing on an attached Fragment all descendant fragments will also get paused.
+     * <li>When pausing on a detached Fragment or the application context only the current RequestManager is paused.
+     * </ul>
+     *
+     * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to pause, in this
+     * case either call pause on the Activity or use a support Fragment.
+     */
+    public void pauseRequestsRecursive() {
+        Util.assertMainThread();
+        pauseRequests();
+        for (RequestManager requestManager : treeNode.getDescendants()) {
+            requestManager.pauseRequests();
+        }
+    }
+
     /**
      * Restarts any loads that have not yet completed.
      *
@@ -141,6 +180,19 @@ public void resumeRequests() {
         requestTracker.resumeRequests();
     }
 
+    /**
+     * Performs {@link #resumeRequests()} recursively for all managers that are contextually descendant
+     * to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics are identical as for
+     * {@link #pauseRequestsRecursive()}.
+     */
+    public void resumeRequestsRecursive() {
+        Util.assertMainThread();
+        resumeRequests();
+        for (RequestManager requestManager : treeNode.getDescendants()) {
+            requestManager.resumeRequests();
+        }
+    }
+
     /**
      * Lifecycle callback that registers for connectivity events (if the android.permission.ACCESS_NETWORK_STATE
      * permission is present) and restarts failed or paused requests.
@@ -297,6 +349,10 @@ public void onDestroy() {
      * @see com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)
      * @see com.bumptech.glide.signature.MediaStoreSignature
      *
+     * @deprecated Use {@link #loadFromMediaStore(android.net.Uri)},
+     * {@link com.bumptech.glide.signature.MediaStoreSignature}, and
+     * {@link com.bumptech.glide.DrawableRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be
+     * removed in Glide 4.0.
      * @param uri The uri representing the media.
      * @param mimeType The mime type of the media store media. Ok to default to empty string "". See
      *      {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or
@@ -307,6 +363,7 @@ public void onDestroy() {
      * @param orientation The orientation of the media store media. Ok to default to 0. See
      *      {@link android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
      */
+    @Deprecated
     public DrawableTypeRequest<Uri> loadFromMediaStore(Uri uri, String mimeType, long dateModified, int orientation) {
         Key signature = new MediaStoreSignature(mimeType, dateModified, orientation);
         return (DrawableTypeRequest<Uri>) loadFromMediaStore(uri).signature(signature);
@@ -481,7 +538,8 @@ public void onDestroy() {
      * @see #load(byte[])
      *
      * @deprecated Use {@link #load(byte[])} along with
-     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} instead.
+     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be
+     * removed in Glide 4.0.
      * @param model The data to load.
      * @param id A unique id that identifies the image represented by the model suitable for use as a cache key
      *           (url, filepath etc). If there is no suitable id, use {@link #load(byte[])} instead.
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index afb892a3e..ac28a6353 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load;
 
-import android.os.Build;
-
 /**
  * Options for setting the value of {@link android.graphics.Bitmap#getConfig()} for {@link android.graphics.Bitmap}s
  * returned by a {@link com.bumptech.glide.load.resource.bitmap.BitmapDecoder}.
@@ -17,9 +15,26 @@
     /**
      * All bitmaps returned by the {@link com.bumptech.glide.load.resource.bitmap.BitmapDecoder} should return
      * {@link android.graphics.Bitmap.Config#ARGB_8888} for {@link android.graphics.Bitmap#getConfig()}.
+     *
+     * @deprecated Use the equivalent but less misleadingly named {@link #PREFER_ARGB_8888}. Scheduled to be removed
+     * in Glide 4.0
      */
+    @Deprecated
     ALWAYS_ARGB_8888,
 
+    /**
+     * Bitmaps decoded from most image formats (other than GIFs with hidden configs), will be decoded with the
+     * ARGB_8888 config.
+     *
+     * <p>
+     *     {@link android.graphics.BitmapFactory} does not allow us to guarantee that all returned Bitmaps will
+     *     be of a requested config without resorting to expensive copying. As a result, this is a preference only.
+     *     Most GIFs, for example, will still produce {@link android.graphics.Bitmap}s with null
+     *     {@link android.graphics.Bitmap.Config}s.
+     * </p>
+     */
+    PREFER_ARGB_8888,
+
     /**
      * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc) should
      * return {@link android.graphics.Bitmap.Config#ARGB_8888} for {@link android.graphics.Bitmap#getConfig()}. Bitmaps
@@ -30,6 +45,5 @@
     PREFER_RGB_565;
 
     /** The default value for DecodeFormat. */
-    public static final DecodeFormat DEFAULT = Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT
-            ? ALWAYS_ARGB_8888 : PREFER_RGB_565;
+    public static final DecodeFormat DEFAULT = PREFER_RGB_565;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index 4f686e1bb..b80e8080e 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -26,8 +26,12 @@
      * </p>
      *
      * @param source The data the resource should be decoded from.
-     * @param width The ideal width of the decoded resource.
-     * @param height The ideal height of the decoded resource.
+     * @param width The ideal width in pixels of the decoded resource, or
+     *              {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+     *              width.
+     * @param height The ideal height in pixels of the decoded resource, or
+     *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+     *               height.
      * @throws IOException
      */
     Resource<Z> decode(T source, int width, int height) throws IOException;
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index ae7f3ffef..34db29e56 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -21,8 +21,12 @@
      * </p>
      *
      * @param resource The resource to transform.
-     * @param outWidth The width of the view or target the resource will be displayed in.
-     * @param outHeight The height of the view or target the resource will be displayed in.
+     * @param outWidth The width of the view or target the resource will be displayed in, or
+     *                 {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original
+     *                 resource width.
+     * @param outHeight The height of the view or target the resource will be displayed in, or
+     *                  {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original
+     *                  resource height.
      * @return The transformed resource.
      */
     Resource<T> transform(Resource<T> resource, int outWidth, int outHeight);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 7bac767eb..7c9e62293 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -2,6 +2,7 @@
 
 import android.content.res.AssetManager;
 import android.util.Log;
+
 import com.bumptech.glide.Priority;
 
 import java.io.IOException;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index a2175603a..8ea527416 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data;
 
 import android.text.TextUtils;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.model.GlideUrl;
 
@@ -9,6 +10,7 @@
 import java.net.HttpURLConnection;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.util.Map;
 
 /**
  * A DataFetcher that retrieves an {@link java.io.InputStream} for a Url.
@@ -36,10 +38,11 @@ public HttpUrlFetcher(GlideUrl glideUrl) {
 
     @Override
     public InputStream loadData(Priority priority) throws Exception {
-        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/);
+        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
     }
 
-    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl) throws IOException {
+    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map<String, String> headers)
+            throws IOException {
         if (redirects >= MAXIMUM_REDIRECTS) {
             throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
         } else {
@@ -54,6 +57,9 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl) t
             }
         }
         urlConnection = connectionFactory.build(url);
+        for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
+          urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
+        }
         urlConnection.setConnectTimeout(2500);
         urlConnection.setReadTimeout(2500);
         urlConnection.setUseCaches(false);
@@ -74,7 +80,7 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl) t
                 throw new IOException("Received empty or null redirect url");
             }
             URL redirectUrl = new URL(url, redirectUrlString);
-            return loadDataWithRedirects(redirectUrl, redirects + 1, url);
+            return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
         } else {
             if (statusCode == -1) {
                 throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
@@ -99,7 +105,7 @@ public void cleanup() {
 
     @Override
     public String getId() {
-        return glideUrl.toString();
+        return glideUrl.getCacheKey();
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index 6a9d046af..8c3a999aa 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.net.Uri;
 import android.util.Log;
+
 import com.bumptech.glide.Priority;
 
 import java.io.FileNotFoundException;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java
index af47dd2f9..b9b622a11 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java
@@ -6,6 +6,7 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.text.TextUtils;
+
 import com.bumptech.glide.Priority;
 
 import java.io.File;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 024dfa1c4..43542289f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.SystemClock;
 import android.util.Log;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -10,6 +10,7 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.provider.DataLoadProvider;
+import com.bumptech.glide.util.LogTime;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -28,6 +29,7 @@
  */
 class DecodeJob<A, T, Z> {
     private static final String TAG = "DecodeJob";
+    private static final FileOpener DEFAULT_FILE_OPENER = new FileOpener();
 
     private final EngineKey resultKey;
     private final int width;
@@ -36,14 +38,25 @@
     private final DataLoadProvider<A, T> loadProvider;
     private final Transformation<T> transformation;
     private final ResourceTranscoder<T, Z> transcoder;
+    private final DiskCacheProvider diskCacheProvider;
     private final DiskCacheStrategy diskCacheStrategy;
-    private final DiskCache diskCache;
     private final Priority priority;
+    private final FileOpener fileOpener;
+
     private volatile boolean isCancelled;
 
     public DecodeJob(EngineKey resultKey, int width, int height, DataFetcher<A> fetcher,
             DataLoadProvider<A, T> loadProvider, Transformation<T> transformation, ResourceTranscoder<T, Z> transcoder,
-            DiskCache diskCache, DiskCacheStrategy diskCacheStrategy, Priority priority) {
+            DiskCacheProvider diskCacheProvider, DiskCacheStrategy diskCacheStrategy, Priority priority) {
+        this(resultKey, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider,
+                diskCacheStrategy, priority, DEFAULT_FILE_OPENER);
+    }
+
+    // Visible for testing.
+    DecodeJob(EngineKey resultKey, int width, int height, DataFetcher<A> fetcher,
+            DataLoadProvider<A, T> loadProvider, Transformation<T> transformation, ResourceTranscoder<T, Z> transcoder,
+            DiskCacheProvider diskCacheProvider, DiskCacheStrategy diskCacheStrategy, Priority priority, FileOpener
+            fileOpener) {
         this.resultKey = resultKey;
         this.width = width;
         this.height = height;
@@ -51,9 +64,10 @@ public DecodeJob(EngineKey resultKey, int width, int height, DataFetcher<A> fetc
         this.loadProvider = loadProvider;
         this.transformation = transformation;
         this.transcoder = transcoder;
+        this.diskCacheProvider = diskCacheProvider;
         this.diskCacheStrategy = diskCacheStrategy;
-        this.diskCache = diskCache;
         this.priority = priority;
+        this.fileOpener = fileOpener;
     }
 
     /**
@@ -67,8 +81,17 @@ public DecodeJob(EngineKey resultKey, int width, int height, DataFetcher<A> fetc
             return null;
         }
 
+        long startTime = LogTime.getLogTime();
         Resource<T> transformed = loadFromCache(resultKey);
-        return transcode(transformed);
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            logWithTimeAndKey("Decoded transformed from cache", startTime);
+        }
+        startTime = LogTime.getLogTime();
+        Resource<Z> result = transcode(transformed);
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            logWithTimeAndKey("Transcoded transformed from cache", startTime);
+        }
+        return result;
     }
 
     /**
@@ -82,7 +105,11 @@ public DecodeJob(EngineKey resultKey, int width, int height, DataFetcher<A> fetc
             return null;
         }
 
+        long startTime = LogTime.getLogTime();
         Resource<T> decoded = loadFromCache(resultKey.getOriginalKey());
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            logWithTimeAndKey("Decoded source from cache", startTime);
+        }
         return transformEncodeAndTranscode(decoded);
     }
 
@@ -108,23 +135,42 @@ public void cancel() {
     }
 
     private Resource<Z> transformEncodeAndTranscode(Resource<T> decoded) {
+        long startTime = LogTime.getLogTime();
         Resource<T> transformed = transform(decoded);
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            logWithTimeAndKey("Transformed resource from source", startTime);
+        }
+
         writeTransformedToCache(transformed);
-        return transcode(transformed);
+
+        startTime = LogTime.getLogTime();
+        Resource<Z> result = transcode(transformed);
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            logWithTimeAndKey("Transcoded transformed from source", startTime);
+        }
+        return result;
     }
 
     private void writeTransformedToCache(Resource<T> transformed) {
         if (transformed == null || !diskCacheStrategy.cacheResult()) {
             return;
         }
+        long startTime = LogTime.getLogTime();
         SourceWriter<Resource<T>> writer = new SourceWriter<Resource<T>>(loadProvider.getEncoder(), transformed);
-        diskCache.put(resultKey, writer);
+        diskCacheProvider.getDiskCache().put(resultKey, writer);
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            logWithTimeAndKey("Wrote transformed from source to cache", startTime);
+        }
     }
 
     private Resource<T> decodeSource() throws Exception {
         Resource<T> decoded = null;
         try {
+            long startTime = LogTime.getLogTime();
             final A data = fetcher.loadData(priority);
+            if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                logWithTimeAndKey("Fetched data", startTime);
+            }
             if (isCancelled) {
                 return null;
             }
@@ -140,19 +186,33 @@ private void writeTransformedToCache(Resource<T> transformed) {
         if (diskCacheStrategy.cacheSource()) {
             decoded = cacheAndDecodeSourceData(data);
         } else {
+            long startTime = LogTime.getLogTime();
             decoded = loadProvider.getSourceDecoder().decode(data, width, height);
+            if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                logWithTimeAndKey("Decoded from source", startTime);
+            }
         }
         return decoded;
     }
 
     private Resource<T> cacheAndDecodeSourceData(A data) throws IOException {
+        long startTime = LogTime.getLogTime();
         SourceWriter<A> writer = new SourceWriter<A>(loadProvider.getSourceEncoder(), data);
-        diskCache.put(resultKey.getOriginalKey(), writer);
-        return loadFromCache(resultKey.getOriginalKey());
+        diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            logWithTimeAndKey("Wrote source to cache", startTime);
+        }
+
+        startTime = LogTime.getLogTime();
+        Resource<T> result = loadFromCache(resultKey.getOriginalKey());
+        if (Log.isLoggable(TAG, Log.VERBOSE) && result != null) {
+            logWithTimeAndKey("Decoded source from cache", startTime);
+        }
+        return result;
     }
 
     private Resource<T> loadFromCache(Key key) throws IOException {
-        File cacheFile = diskCache.get(key);
+        File cacheFile = diskCacheProvider.getDiskCache().get(key);
         if (cacheFile == null) {
             return null;
         }
@@ -162,7 +222,7 @@ private void writeTransformedToCache(Resource<T> transformed) {
             result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);
         } finally {
             if (result == null) {
-                diskCache.delete(key);
+                diskCacheProvider.getDiskCache().delete(key);
             }
         }
         return result;
@@ -187,23 +247,26 @@ private void writeTransformedToCache(Resource<T> transformed) {
         return transcoder.transcode(transformed);
     }
 
-    static class SourceWriter<T> implements DiskCache.Writer {
+    private void logWithTimeAndKey(String message, long startTime) {
+        Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + resultKey);
+    }
+
+    class SourceWriter<DataType> implements DiskCache.Writer {
 
-        private final Encoder<T> encoder;
-        private final T data;
+        private final Encoder<DataType> encoder;
+        private final DataType data;
 
-        public SourceWriter(Encoder<T> encoder, T data) {
+        public SourceWriter(Encoder<DataType> encoder, DataType data) {
             this.encoder = encoder;
             this.data = data;
         }
 
         @Override
         public boolean write(File file) {
-            long start = SystemClock.currentThreadTimeMillis();
             boolean success = false;
             OutputStream os = null;
             try {
-                os = new BufferedOutputStream(new FileOutputStream(file));
+                os = fileOpener.open(file);
                 success = encoder.encode(data, os);
             } catch (FileNotFoundException e) {
                 if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -218,10 +281,17 @@ public boolean write(File file) {
                     }
                 }
             }
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "wrote to disk cache in " + (SystemClock.currentThreadTimeMillis() - start));
-            }
             return success;
         }
     }
+
+    interface DiskCacheProvider {
+        DiskCache getDiskCache();
+    }
+
+    static class FileOpener {
+        public OutputStream open(File file) throws FileNotFoundException {
+            return new BufferedOutputStream(new FileOutputStream(file));
+        }
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 822e6d321..9356b5cac 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -1,10 +1,9 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Handler;
 import android.os.Looper;
-import android.os.Message;
 import android.os.MessageQueue;
 import android.util.Log;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
@@ -26,16 +25,20 @@
 /**
  * Responsible for starting loads and managing active and cached resources.
  */
-public class Engine implements EngineJobListener, MemoryCache.ResourceRemovedListener, EngineResource.ResourceListener {
+public class Engine implements EngineJobListener,
+        MemoryCache.ResourceRemovedListener,
+        EngineResource.ResourceListener {
     private static final String TAG = "Engine";
     private final Map<Key, EngineJob> jobs;
     private final EngineKeyFactory keyFactory;
     private final MemoryCache cache;
-    private final DiskCache diskCache;
     private final EngineJobFactory engineJobFactory;
     private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
-    private final ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
-    private final Handler mainHandler;
+    private final ResourceRecycler resourceRecycler;
+    private final LazyDiskCacheProvider diskCacheProvider;
+
+    // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See #295.
+    private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
 
     /**
      * Allows a request to indicate it no longer is interested in a given load.
@@ -54,17 +57,18 @@ public void cancel() {
         }
     }
 
-    public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService diskCacheService,
+    public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory, ExecutorService diskCacheService,
             ExecutorService sourceService) {
-        this(memoryCache, diskCache, diskCacheService, sourceService, null, null, null, null);
+        this(memoryCache, diskCacheFactory, diskCacheService, sourceService, null, null, null, null, null);
     }
 
     // Visible for testing.
-    Engine(MemoryCache cache, DiskCache diskCache, ExecutorService diskCacheService, ExecutorService sourceService,
-            Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
-            Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory) {
+    Engine(MemoryCache cache, DiskCache.Factory diskCacheFactory, ExecutorService diskCacheService,
+            ExecutorService sourceService, Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
+            Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory,
+            ResourceRecycler resourceRecycler) {
         this.cache = cache;
-        this.diskCache = diskCache;
+        this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
         if (activeResources == null) {
             activeResources = new HashMap<Key, WeakReference<EngineResource<?>>>();
@@ -86,12 +90,12 @@ public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService disk
         }
         this.engineJobFactory = engineJobFactory;
 
-        resourceReferenceQueue = new ReferenceQueue<EngineResource<?>>();
-        MessageQueue queue = Looper.myQueue();
-        queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
-        cache.setResourceRemovedListener(this);
+        if (resourceRecycler == null) {
+            resourceRecycler = new ResourceRecycler();
+        }
+        this.resourceRecycler = resourceRecycler;
 
-        mainHandler = new Handler(Looper.getMainLooper(), new ResourceRecyclerCallback());
+        cache.setResourceRemovedListener(this);
     }
 
     /**
@@ -118,8 +122,8 @@ public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService disk
      *
      * @param signature A non-null unique key to be mixed into the cache key that identifies the version of the data to
      *                  be loaded.
-     * @param width The target width of the retrieved resource.
-     * @param height The target height of the retrieved resource.
+     * @param width The target width in pixels of the desired resource.
+     * @param height The target height in pixels of the desired resource.
      * @param fetcher The fetcher to use to retrieve data not in the disk cache.
      * @param loadProvider The load provider containing various encoders and decoders use to decode and encode data.
      * @param transformation The transformation to use to transform the decoded resource.
@@ -145,57 +149,85 @@ public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService disk
                 loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),
                 transcoder, loadProvider.getSourceEncoder());
 
-        EngineResource<?> cached = getFromCache(key);
+        EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
         if (cached != null) {
-            cached.acquire();
-            activeResources.put(key, new ResourceWeakReference(key, cached, resourceReferenceQueue));
             cb.onResourceReady(cached);
             if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "loaded resource from cache in " + LogTime.getElapsedMillis(startTime));
+                logWithTimeAndKey("Loaded resource from cache", startTime, key);
             }
             return null;
         }
 
-        WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
-        if (activeRef != null) {
-            EngineResource<?> active = activeRef.get();
-            if (active != null) {
-                active.acquire();
-                cb.onResourceReady(active);
-                if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                    Log.v(TAG, "loaded resource from active resources in " + LogTime.getElapsedMillis(startTime));
-                }
-                return null;
-            } else {
-                activeResources.remove(key);
+        EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
+        if (active != null) {
+            cb.onResourceReady(active);
+            if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                logWithTimeAndKey("Loaded resource from active resources", startTime, key);
             }
+            return null;
         }
 
         EngineJob current = jobs.get(key);
         if (current != null) {
             current.addCallback(cb);
             if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "added to existing load in " + LogTime.getElapsedMillis(startTime));
+                logWithTimeAndKey("Added to existing load", startTime, key);
             }
             return new LoadStatus(cb, current);
         }
 
         EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);
         DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,
-                transcoder, diskCache, diskCacheStrategy, priority);
+                transcoder, diskCacheProvider, diskCacheStrategy, priority);
         EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);
         jobs.put(key, engineJob);
         engineJob.addCallback(cb);
         engineJob.start(runnable);
 
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "finished load in engine in " + LogTime.getElapsedMillis(startTime));
+            logWithTimeAndKey("Started new load", startTime, key);
         }
         return new LoadStatus(cb, engineJob);
     }
 
+    private static void logWithTimeAndKey(String log, long startTime, Key key) {
+        Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
+    }
+
+    private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
+        if (!isMemoryCacheable) {
+            return null;
+        }
+
+        EngineResource<?> active = null;
+        WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
+        if (activeRef != null) {
+            active = activeRef.get();
+            if (active != null) {
+                active.acquire();
+            } else {
+                activeResources.remove(key);
+            }
+        }
+
+        return active;
+    }
+
+    private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
+        if (!isMemoryCacheable) {
+            return null;
+        }
+
+        EngineResource<?> cached = getEngineResourceFromCache(key);
+        if (cached != null) {
+            cached.acquire();
+            activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));
+        }
+        return cached;
+    }
+
     @SuppressWarnings("unchecked")
-    private EngineResource<?> getFromCache(Key key) {
+    private EngineResource<?> getEngineResourceFromCache(Key key) {
         Resource<?> cached = cache.remove(key);
 
         final EngineResource result;
@@ -211,6 +243,7 @@ public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService disk
     }
 
     public void release(Resource resource) {
+        Util.assertMainThread();
         if (resource instanceof EngineResource) {
             ((EngineResource) resource).release();
         } else {
@@ -221,10 +254,14 @@ public void release(Resource resource) {
     @SuppressWarnings("unchecked")
     @Override
     public void onEngineJobComplete(Key key, EngineResource<?> resource) {
+        Util.assertMainThread();
         // A null resource indicates that the load failed, usually due to an exception.
         if (resource != null) {
             resource.setResourceListener(key, this);
-            activeResources.put(key, new ResourceWeakReference(key, resource, resourceReferenceQueue));
+
+            if (resource.isCacheable()) {
+                activeResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+            }
         }
         // TODO: should this check that the engine job is still current?
         jobs.remove(key);
@@ -232,6 +269,7 @@ public void onEngineJobComplete(Key key, EngineResource<?> resource) {
 
     @Override
     public void onEngineJobCancelled(EngineJob engineJob, Key key) {
+        Util.assertMainThread();
         EngineJob current = jobs.get(key);
         if (engineJob.equals(current)) {
             jobs.remove(key);
@@ -240,36 +278,53 @@ public void onEngineJobCancelled(EngineJob engineJob, Key key) {
 
     @Override
     public void onResourceRemoved(final Resource<?> resource) {
-        recycleResource(resource);
+        Util.assertMainThread();
+        resourceRecycler.recycle(resource);
     }
 
     @Override
     public void onResourceReleased(Key cacheKey, EngineResource resource) {
+        Util.assertMainThread();
         activeResources.remove(cacheKey);
         if (resource.isCacheable()) {
             cache.put(cacheKey, resource);
         } else {
-            recycleResource(resource);
+            resourceRecycler.recycle(resource);
         }
     }
 
-    private void recycleResource(Resource<?> resource) {
-        // If a resource has sub-resources, releasing a sub resource can cause it's parent to be synchronously
-        // evicted which leads to a recycle loop when the parent the releases it's children. Posting breaks this loops.
-        mainHandler.obtainMessage(ResourceRecyclerCallback.RECYCLE_RESOURCE, resource).sendToTarget();
+    public void clearDiskCache() {
+        diskCacheProvider.getDiskCache().clear();
     }
 
-    private static class ResourceRecyclerCallback implements Handler.Callback {
-        public static final int RECYCLE_RESOURCE = 1;
+    private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
+        if (resourceReferenceQueue == null) {
+            resourceReferenceQueue = new ReferenceQueue<EngineResource<?>>();
+            MessageQueue queue = Looper.myQueue();
+            queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
+        }
+        return resourceReferenceQueue;
+    }
+
+    private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
+
+        private final DiskCache.Factory factory;
+        private volatile DiskCache diskCache;
+
+        public LazyDiskCacheProvider(DiskCache.Factory factory) {
+            this.factory = factory;
+        }
 
         @Override
-        public boolean handleMessage(Message message) {
-            if (message.what == RECYCLE_RESOURCE) {
-                Resource resource = (Resource) message.obj;
-                resource.recycle();
-                return true;
+        public DiskCache getDiskCache() {
+            if (diskCache == null) {
+                synchronized (this) {
+                    if (diskCache == null) {
+                        diskCache = factory.build();
+                    }
+                }
             }
-            return false;
+            return diskCache;
         }
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index ef9ffcacc..eb1d77728 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Handler;
+import android.os.Looper;
 import android.os.Message;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.Util;
@@ -19,7 +21,7 @@
  */
 class EngineJob implements EngineRunnable.EngineRunnableManager {
     private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();
-    private static final Handler MAIN_THREAD_HANDLER = new Handler(new MainThreadCallback());
+    private static final Handler MAIN_THREAD_HANDLER = new Handler(Looper.getMainLooper(), new MainThreadCallback());
 
     private static final int MSG_COMPLETE = 1;
     private static final int MSG_EXCEPTION = 2;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 92574e1fd..49bf096aa 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Looper;
+
 import com.bumptech.glide.load.Key;
 
 /**
@@ -22,6 +23,9 @@
     }
 
     EngineResource(Resource<Z> toWrap, boolean isCacheable) {
+        if (toWrap == null) {
+            throw new NullPointerException("Wrapped resource must not be null");
+        }
         resource = toWrap;
         this.isCacheable = isCacheable;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineRunnable.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineRunnable.java
index 949f5978f..98ec65ecf 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineRunnable.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineRunnable.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.util.Log;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.engine.executor.Prioritized;
 import com.bumptech.glide.request.ResourceCallback;
@@ -63,6 +64,9 @@ public void run() {
         }
 
         if (isCancelled) {
+            if (resource != null) {
+                resource.recycle();
+            }
             return;
         }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
new file mode 100644
index 000000000..06ee47b7e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -0,0 +1,43 @@
+package com.bumptech.glide.load.engine;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import com.bumptech.glide.util.Util;
+
+/**
+ * A class that can safely recycle recursive resources.
+ */
+class ResourceRecycler {
+    private boolean isRecycling;
+    private final Handler handler = new Handler(Looper.getMainLooper(), new ResourceRecyclerCallback());
+
+    public void recycle(Resource<?> resource) {
+        Util.assertMainThread();
+
+        if (isRecycling) {
+            // If a resource has sub-resources, releasing a sub resource can cause it's parent to be synchronously
+            // evicted which leads to a recycle loop when the parent releases it's children. Posting breaks this loop.
+            handler.obtainMessage(ResourceRecyclerCallback.RECYCLE_RESOURCE, resource).sendToTarget();
+        } else {
+            isRecycling = true;
+            resource.recycle();
+            isRecycling = false;
+        }
+    }
+
+    private static class ResourceRecyclerCallback implements Handler.Callback {
+        public static final int RECYCLE_RESOURCE = 1;
+
+        @Override
+        public boolean handleMessage(Message message) {
+            if (message.what == RECYCLE_RESOURCE) {
+                Resource resource = (Resource) message.obj;
+                resource.recycle();
+                return true;
+            }
+            return false;
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index ef57437e5..eebd1fd53 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.util.Util;
 
 /**
@@ -56,7 +57,8 @@ private static String getBitmapString(int width, int height, Bitmap.Config confi
         return "[" + width + "x" + height + "], " + config;
     }
 
-    private static class KeyPool extends BaseKeyPool<Key> {
+    // Visible for testing.
+    static class KeyPool extends BaseKeyPool<Key> {
         public Key get(int width, int height, Bitmap.Config config) {
             Key result = get();
             result.init(width, height, config);
@@ -69,7 +71,8 @@ protected Key create() {
         }
     }
 
-    private static class Key implements Poolable {
+    // Visible for testing.
+    static class Key implements Poolable {
         private final KeyPool pool;
         private int width;
         private int height;
@@ -88,26 +91,13 @@ public void init(int width, int height, Bitmap.Config config) {
 
         @Override
         public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-
-            Key key = (Key) o;
-
-            if (height != key.height) {
-                return false;
-            }
-            if (width != key.width) {
-                return false;
+            if (o instanceof Key) {
+                Key other = (Key) o;
+                return width == other.width
+                        && height == other.height
+                        && config == other.config;
             }
-            if (config != key.config) {
-                return false;
-            }
-
-            return true;
+            return false;
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
index 3dd4c38de..0390a6681 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
@@ -71,8 +71,8 @@
      *
      * @see #getDirty(int, int, android.graphics.Bitmap.Config)
      *
-     * @param width The width of the desired {@link android.graphics.Bitmap}.
-     * @param height The height of the desired {@link android.graphics.Bitmap}.
+     * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
+     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
      * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link android.graphics.Bitmap}.
      */
     Bitmap get(int width, int height, Bitmap.Config config);
@@ -89,8 +89,8 @@
      *
      * @see #get(int, int, android.graphics.Bitmap.Config)
      *
-     * @param width The width of the desired {@link android.graphics.Bitmap}.
-     * @param height The height of the desired {@link android.graphics.Bitmap}.
+     * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
+     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
      * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link android.graphics.Bitmap}.
      * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config potentially containing
      * random image data or null if no such {@link android.graphics.Bitmap} could be obtained from the pool.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index c57678691..0a00f5300 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -7,6 +7,7 @@
 import android.os.Build;
 import android.util.Log;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -19,8 +20,10 @@
  */
 public class LruBitmapPool implements BitmapPool {
     private static final String TAG = "LruBitmapPool";
+    private static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.ARGB_8888;
 
     private final LruPoolStrategy strategy;
+    private final Set<Bitmap.Config> allowedConfigs;
     private final int initialMaxSize;
     private final BitmapTracker tracker;
 
@@ -32,10 +35,11 @@
     private int evictions;
 
     // Exposed for testing only.
-    LruBitmapPool(int maxSize, LruPoolStrategy strategy) {
+    LruBitmapPool(int maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
         this.initialMaxSize = maxSize;
         this.maxSize = maxSize;
         this.strategy = strategy;
+        this.allowedConfigs = allowedConfigs;
         this.tracker = new NullBitmapTracker();
     }
 
@@ -45,7 +49,18 @@
      * @param maxSize The initial maximum size of the pool in bytes.
      */
     public LruBitmapPool(int maxSize) {
-        this(maxSize, getDefaultStrategy());
+        this(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());
+    }
+
+    /**
+     * Constructor for LruBitmapPool.
+     *
+     * @param maxSize The initial maximum size of the pool in bytes.
+     * @param allowedConfigs A white listed set of {@link android.graphics.Bitmap.Config} that are allowed to be put
+     *                       into the pool. Configs not in the allowed set will be rejected.
+     */
+    public LruBitmapPool(int maxSize, Set<Bitmap.Config> allowedConfigs) {
+        this(maxSize, getDefaultStrategy(), allowedConfigs);
     }
 
     @Override
@@ -61,7 +76,16 @@ public synchronized void setSizeMultiplier(float sizeMultiplier) {
 
     @Override
     public synchronized boolean put(Bitmap bitmap) {
-        if (!bitmap.isMutable() || strategy.getSize(bitmap) > maxSize) {
+        if (bitmap == null) {
+            throw new NullPointerException("Bitmap must not be null");
+        }
+        if (!bitmap.isMutable() || strategy.getSize(bitmap) > maxSize || !allowedConfigs.contains(bitmap.getConfig())) {
+            if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                Log.v(TAG, "Reject bitmap from pool"
+                        + ", bitmap: " + strategy.logBitmap(bitmap)
+                        + ", is mutable: " + bitmap.isMutable()
+                        + ", is allowed config: " + allowedConfigs.contains(bitmap.getConfig()));
+            }
             return false;
         }
 
@@ -72,8 +96,8 @@ public synchronized boolean put(Bitmap bitmap) {
         puts++;
         currentSize += size;
 
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Put bitmap in pool=" + strategy.logBitmap(bitmap));
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            Log.v(TAG, "Put bitmap in pool=" + strategy.logBitmap(bitmap));
         }
         dump();
 
@@ -101,7 +125,9 @@ public synchronized Bitmap get(int width, int height, Bitmap.Config config) {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
     @Override
     public synchronized Bitmap getDirty(int width, int height, Bitmap.Config config) {
-        final Bitmap result = strategy.get(width, height, config);
+        // Config will be null for non public config types, which can lead to transformations naively passing in
+        // null as the requested config here. See issue #194.
+        final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG);
         if (result == null) {
             if (Log.isLoggable(TAG, Log.DEBUG)) {
                 Log.d(TAG, "Missing bitmap=" + strategy.logBitmap(width, height, config));
@@ -115,8 +141,8 @@ public synchronized Bitmap getDirty(int width, int height, Bitmap.Config config)
                 result.setHasAlpha(true);
             }
         }
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Get bitmap=" + strategy.logBitmap(width, height, config));
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            Log.v(TAG, "Get bitmap=" + strategy.logBitmap(width, height, config));
         }
         dump();
 
@@ -125,12 +151,18 @@ public synchronized Bitmap getDirty(int width, int height, Bitmap.Config config)
 
     @Override
     public void clearMemory() {
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            Log.d(TAG, "clearMemory");
+        }
         trimToSize(0);
     }
 
     @SuppressLint("InlinedApi")
     @Override
     public void trimMemory(int level) {
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+            Log.d(TAG, "trimMemory, level=" + level);
+        }
         if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
             clearMemory();
         } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
@@ -141,6 +173,16 @@ public void trimMemory(int level) {
     private synchronized void trimToSize(int size) {
         while (currentSize > size) {
             final Bitmap removed = strategy.removeLast();
+            // TODO: This shouldn't ever happen, see #331.
+            if (removed == null) {
+                if (Log.isLoggable(TAG, Log.WARN)) {
+                    Log.w(TAG, "Size mismatch, resetting");
+                    dumpUnchecked();
+                }
+                currentSize = 0;
+                return;
+            }
+
             tracker.remove(removed);
             currentSize -= strategy.getSize(removed);
             removed.recycle();
@@ -154,21 +196,39 @@ private synchronized void trimToSize(int size) {
 
     private void dump() {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Hits=" + hits + " misses=" + misses + " puts=" + puts + " evictions=" + evictions
-                    + " currentSize=" + currentSize + " maxSize=" + maxSize + "\nStrategy=" + strategy);
+            dumpUnchecked();
         }
     }
 
+    private void dumpUnchecked() {
+        Log.v(TAG, "Hits="  + hits
+                    + ", misses=" + misses
+                    + ", puts=" + puts
+                    + ", evictions=" + evictions
+                    + ", currentSize=" + currentSize
+                    + ", maxSize=" + maxSize
+                    + "\nStrategy=" + strategy);
+    }
+
     private static LruPoolStrategy getDefaultStrategy() {
         final LruPoolStrategy strategy;
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            strategy = new SizeStrategy();
+            strategy = new SizeConfigStrategy();
         } else {
             strategy = new AttributeStrategy();
         }
         return strategy;
     }
 
+    private static Set<Bitmap.Config> getDefaultAllowedConfigs() {
+        Set<Bitmap.Config> configs = new HashSet<Bitmap.Config>();
+        configs.addAll(Arrays.asList(Bitmap.Config.values()));
+        if (Build.VERSION.SDK_INT >= 19) {
+            configs.add(null);
+        }
+        return Collections.unmodifiableSet(configs);
+    }
+
     private interface BitmapTracker {
         void add(Bitmap bitmap);
         void remove(Bitmap bitmap);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
new file mode 100644
index 000000000..c12e4e34e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import java.util.TreeMap;
+
+class PrettyPrintTreeMap<K, V> extends TreeMap<K, V> {
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("( ");
+        for (Entry<K, V> entry : entrySet()) {
+            sb.append('{').append(entry.getKey()).append(':').append(entry.getValue()).append("}, ");
+        }
+        if (!isEmpty()) {
+            sb.replace(sb.length() - 2, sb.length(), "");
+        }
+        return sb.append(" )").toString();
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
new file mode 100644
index 000000000..a8d5fce88
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -0,0 +1,238 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.os.Build;
+
+import com.bumptech.glide.util.Util;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
+/**
+ * Keys {@link android.graphics.Bitmap Bitmaps} using both {@link android.graphics.Bitmap#getAllocationByteCount()} and
+ * the {@link android.graphics.Bitmap.Config} returned from {@link android.graphics.Bitmap#getConfig()}.
+ *
+ * <p>
+ *     Using both the config and the byte size allows us to safely re-use a greater variety of
+ *     {@link android.graphics.Bitmap Bitmaps}, which increases the hit rate of the pool and therefore the performance
+ *     of applications. This class works around #301 by only allowing re-use of {@link android.graphics.Bitmap Bitmaps}
+ *     with a matching number of bytes per pixel.
+ * </p>
+ */
+@TargetApi(Build.VERSION_CODES.KITKAT)
+public class SizeConfigStrategy implements LruPoolStrategy {
+    private static final int MAX_SIZE_MULTIPLE = 8;
+    private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS = new Bitmap.Config[] {
+            Bitmap.Config.ARGB_8888,
+            // The value returned by Bitmaps with the hidden Bitmap config.
+            null,
+    };
+    // We probably could allow ARGB_4444 and RGB_565 to decode into each other, but ARGB_4444 is deprecated and we'd
+    // rather be safe.
+    private static final Bitmap.Config[] RGB_565_IN_CONFIGS = new Bitmap.Config[] {
+            Bitmap.Config.RGB_565
+    };
+    private static final Bitmap.Config[] ARGB_4444_IN_CONFIGS = new Bitmap.Config[] {
+            Bitmap.Config.ARGB_4444
+    };
+    private static final Bitmap.Config[] ALPHA_8_IN_CONFIGS = new Bitmap.Config[] {
+            Bitmap.Config.ALPHA_8
+    };
+
+    private final KeyPool keyPool = new KeyPool();
+    private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<Key, Bitmap>();
+    private final Map<Bitmap.Config, NavigableMap<Integer, Integer>> sortedSizes =
+            new HashMap<Bitmap.Config, NavigableMap<Integer, Integer>>();
+
+    @Override
+    public void put(Bitmap bitmap) {
+        int size = Util.getBitmapByteSize(bitmap);
+        Key key = keyPool.get(size, bitmap.getConfig());
+
+        groupedMap.put(key, bitmap);
+
+        NavigableMap<Integer, Integer> sizes = getSizesForConfig(bitmap.getConfig());
+        Integer current = sizes.get(key.size);
+        sizes.put(key.size, current == null ? 1 : current + 1);
+    }
+
+    @Override
+    public Bitmap get(int width, int height, Bitmap.Config config) {
+        int size = Util.getBitmapByteSize(width, height, config);
+        Key targetKey = keyPool.get(size, config);
+        Key bestKey = findBestKey(targetKey, size, config);
+
+        Bitmap result = groupedMap.get(bestKey);
+        if (result != null) {
+            // Decrement must be called before reconfigure.
+            decrementBitmapOfSize(Util.getBitmapByteSize(result), result.getConfig());
+            result.reconfigure(width, height,
+                    result.getConfig() != null ? result.getConfig() : Bitmap.Config.ARGB_8888);
+        }
+        return result;
+    }
+
+    private Key findBestKey(Key key, int size, Bitmap.Config config) {
+        Key result = key;
+        for (Bitmap.Config possibleConfig : getInConfigs(config)) {
+            NavigableMap<Integer, Integer> sizesForPossibleConfig = getSizesForConfig(possibleConfig);
+            Integer possibleSize = sizesForPossibleConfig.ceilingKey(size);
+            if (possibleSize != null && possibleSize <= size * MAX_SIZE_MULTIPLE) {
+                if (possibleSize != size
+                        || (possibleConfig == null ? config != null : !possibleConfig.equals(config))) {
+                    keyPool.offer(key);
+                    result = keyPool.get(possibleSize, possibleConfig);
+                }
+                break;
+            }
+        }
+        return result;
+    }
+
+    @Override
+    public Bitmap removeLast() {
+        Bitmap removed = groupedMap.removeLast();
+        if (removed != null) {
+            int removedSize = Util.getBitmapByteSize(removed);
+            decrementBitmapOfSize(removedSize, removed.getConfig());
+        }
+        return removed;
+    }
+
+    private void decrementBitmapOfSize(Integer size, Bitmap.Config config) {
+        NavigableMap<Integer, Integer> sizes = getSizesForConfig(config);
+        Integer current = sizes.get(size);
+        if (current == 1) {
+            sizes.remove(size);
+        } else {
+            sizes.put(size, current - 1);
+        }
+    }
+
+    private NavigableMap<Integer, Integer> getSizesForConfig(Bitmap.Config config) {
+        NavigableMap<Integer, Integer> sizes = sortedSizes.get(config);
+        if (sizes == null) {
+            sizes = new TreeMap<Integer, Integer>();
+            sortedSizes.put(config, sizes);
+        }
+        return sizes;
+    }
+
+    @Override
+    public String logBitmap(Bitmap bitmap) {
+        int size = Util.getBitmapByteSize(bitmap);
+        return getBitmapString(size, bitmap.getConfig());
+    }
+
+    @Override
+    public String logBitmap(int width, int height, Bitmap.Config config) {
+        int size = Util.getBitmapByteSize(width, height, config);
+        return getBitmapString(size, config);
+    }
+
+    @Override
+    public int getSize(Bitmap bitmap) {
+        return Util.getBitmapByteSize(bitmap);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder()
+                .append("SizeConfigStrategy{groupedMap=")
+                .append(groupedMap)
+                .append(", sortedSizes=(");
+        for (Map.Entry<Bitmap.Config, NavigableMap<Integer, Integer>> entry : sortedSizes.entrySet()) {
+            sb.append(entry.getKey()).append('[').append(entry.getValue()).append("], ");
+        }
+        if (!sortedSizes.isEmpty()) {
+            sb.replace(sb.length() - 2, sb.length(), "");
+        }
+        return sb.append(")}").toString();
+    }
+
+    // Visible for testing.
+    static class KeyPool extends BaseKeyPool<Key> {
+
+        public Key get(int size, Bitmap.Config config) {
+            Key result = get();
+            result.init(size, config);
+            return result;
+        }
+
+        @Override
+        protected Key create() {
+            return new Key(this);
+        }
+    }
+
+    // Visible for testing.
+    static final class Key implements Poolable {
+        private final KeyPool pool;
+
+        private int size;
+        private Bitmap.Config config;
+
+        public Key(KeyPool pool) {
+            this.pool = pool;
+        }
+
+        // Visible for testing.
+        Key(KeyPool pool, int size, Bitmap.Config config) {
+            this(pool);
+            init(size, config);
+        }
+
+        public void init(int size, Bitmap.Config config) {
+            this.size = size;
+            this.config = config;
+        }
+
+        @Override
+        public void offer() {
+            pool.offer(this);
+        }
+
+        @Override
+        public String toString() {
+            return getBitmapString(size, config);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof Key) {
+                Key other = (Key) o;
+                return size == other.size && (config == null ? other.config == null : config.equals(other.config));
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = size;
+            result = 31 * result + (config != null ? config.hashCode() : 0);
+            return result;
+        }
+    }
+
+    private static String getBitmapString(int size, Bitmap.Config config) {
+        return "[" + size + "](" + config + ")";
+    }
+
+    private static Bitmap.Config[] getInConfigs(Bitmap.Config requested) {
+        switch (requested) {
+            case ARGB_8888:
+                return ARGB_8888_IN_CONFIGS;
+            case RGB_565:
+                return RGB_565_IN_CONFIGS;
+            case ARGB_4444:
+                return ARGB_4444_IN_CONFIGS;
+            case ALPHA_8:
+                return ALPHA_8_IN_CONFIGS;
+            default:
+                return new Bitmap.Config[] { requested };
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index b33d13ac7..fd7a28c5d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -3,6 +3,7 @@
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
+
 import com.bumptech.glide.util.Util;
 
 import java.util.TreeMap;
@@ -92,24 +93,6 @@ public String toString() {
                 + "  SortedSizes" + sortedSizes;
     }
 
-    private static class PrettyPrintTreeMap<K, V> extends TreeMap<K, V> {
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append("( ");
-            for (Entry<K, V> entry : entrySet()) {
-                sb.append('{').append(entry.getKey()).append(':').append(entry.getValue()).append("}, ");
-            }
-            final String result;
-            if (!isEmpty()) {
-                result = sb.substring(0, sb.length() - 2);
-            } else {
-                result = sb.toString();
-            }
-            return result + " )";
-        }
-    }
-
     private static String getBitmapString(Bitmap bitmap) {
         int size = Util.getBitmapByteSize(bitmap);
         return getBitmapString(size);
@@ -119,7 +102,8 @@ private static String getBitmapString(int size) {
         return "[" + size + "]";
     }
 
-    private static class KeyPool extends BaseKeyPool<Key> {
+    // Visible for testing.
+    static class KeyPool extends BaseKeyPool<Key> {
 
         public Key get(int size) {
             Key result = get();
@@ -133,7 +117,8 @@ protected Key create() {
         }
     }
 
-    private static final class Key implements Poolable {
+    // Visible for testing.
+    static final class Key implements Poolable {
         private final KeyPool pool;
         private int size;
 
@@ -147,16 +132,11 @@ public void init(int size) {
 
         @Override
         public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
+            if (o instanceof Key) {
+                Key other = (Key) o;
+                return size == other.size;
             }
-
-            Key key = (Key) o;
-
-            return size == key.size;
+            return false;
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index c456249be..12ab93d01 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -8,6 +8,17 @@
  * An interface for writing to and reading from a disk cache.
  */
 public interface DiskCache {
+
+    /**
+     * An interface for lazily creating a disk cache.
+     */
+    interface Factory {
+        /**
+         * Returns a new disk cache, or {@code null} if no disk cache could be created.
+         */
+        DiskCache build();
+    }
+
     /**
      * An interface to actually write data to a key in the disk cache.
      */
@@ -49,4 +60,9 @@
      * @param key The key to remove.
      */
     void delete(Key key);
+
+    /**
+     * Clear the cache.
+     */
+    void clear();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
index 7027b0521..5348888be 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
@@ -23,4 +23,9 @@ public void put(Key key, Writer writer) {
     public void delete(Key key) {
         // no op, default for overriders
     }
+
+    @Override
+    public void clear() {
+        // no op, default for overriders
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 12648681f..12a8e7458 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -60,6 +60,10 @@ private synchronized DiskLruCache getDiskCache() throws IOException {
         return diskLruCache;
     }
 
+    private synchronized void resetDiskCache() {
+        diskLruCache = null;
+    }
+
     @Override
     public File get(Key key) {
         String safeKey = safeKeyGenerator.getSafeKey(key);
@@ -114,4 +118,16 @@ public void delete(Key key) {
             }
         }
     }
+
+    @Override
+    public synchronized void clear() {
+        try {
+            getDiskCache().delete();
+            resetDiskCache();
+        }  catch (IOException e) {
+            if (Log.isLoggable(TAG, Log.WARN)) {
+                Log.w(TAG, "Unable to clear disk cache", e);
+            }
+        }
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
new file mode 100644
index 000000000..7d58bc7b5
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -0,0 +1,48 @@
+package com.bumptech.glide.load.engine.cache;
+
+import android.content.Context;
+
+import com.bumptech.glide.Glide;
+
+import java.io.File;
+
+/**
+ * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the internal disk cache
+ * directory.
+ */
+public final class InternalCacheDiskCacheFactory implements DiskCache.Factory {
+    private final Context context;
+    private final String diskCacheName;
+    private final int diskCacheSize;
+
+    public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
+        this(context, null /*diskCacheName*/, diskCacheSize);
+    }
+
+    public InternalCacheDiskCacheFactory(Context context, String diskCacheName, int diskCacheSize) {
+        this.context = context;
+        this.diskCacheName = diskCacheName;
+        this.diskCacheSize = diskCacheSize;
+    }
+
+    @Override
+    public DiskCache build() {
+        DiskCache diskCache = null;
+        final File cacheDir;
+
+        if (diskCacheName != null) {
+            cacheDir = Glide.getPhotoCacheDir(context, diskCacheName);
+        } else {
+            cacheDir = Glide.getPhotoCacheDir(context);
+        }
+
+        if (cacheDir != null) {
+            diskCache = DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
+        }
+
+        if (diskCache == null) {
+            diskCache = new DiskCacheAdapter();
+        }
+        return diskCache;
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 3cb8b5c28..ffe5a6f95 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.annotation.SuppressLint;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index d3f9d758c..3fdd73545 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -4,6 +4,7 @@
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
+import android.text.format.Formatter;
 import android.util.DisplayMetrics;
 import android.util.Log;
 
@@ -14,14 +15,16 @@
 public class MemorySizeCalculator {
     private static final String TAG = "MemorySizeCalculator";
 
+    // Visible for testing.
     static final int BYTES_PER_ARGB_8888_PIXEL = 4;
     static final int MEMORY_CACHE_TARGET_SCREENS = 2;
-    static final int BITMAP_POOL_TARGET_SCREENS = 3;
-
+    static final int BITMAP_POOL_TARGET_SCREENS = 4;
     static final float MAX_SIZE_MULTIPLIER = 0.4f;
     static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER = 0.33f;
+
     private final int bitmapPoolSize;
     private final int memoryCacheSize;
+    private final Context context;
 
     interface ScreenDimensions {
         int getWidthPixels();
@@ -29,11 +32,14 @@
     }
 
     public MemorySizeCalculator(Context context) {
-        this((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE),
+        this(context,
+                (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE),
                 new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics()));
     }
 
-    MemorySizeCalculator(ActivityManager activityManager, ScreenDimensions screenDimensions) {
+    // Visible for testing.
+    MemorySizeCalculator(Context context, ActivityManager activityManager, ScreenDimensions screenDimensions) {
+        this.context = context;
         final int maxSize = getMaxSize(activityManager);
 
         final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
@@ -80,8 +86,8 @@ private static int getMaxSize(ActivityManager activityManager) {
                 * (isLowMemoryDevice ? LOW_MEMORY_MAX_SIZE_MULTIPLIER : MAX_SIZE_MULTIPLIER));
     }
 
-    private static int toMb(int bytes) {
-        return bytes / (1024 * 1024);
+    private String toMb(int bytes) {
+        return Formatter.formatFileSize(context, bytes);
     }
 
     @TargetApi(Build.VERSION_CODES.KITKAT)
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java
index 9972fc6d7..db0a128ac 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java
@@ -34,7 +34,7 @@ public FifoPriorityThreadPoolExecutor(int corePoolSize, int maximumPoolSize, lon
 
     @Override
     protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
-        return new FifoPriorityLoadTask<T>(runnable, value, ordering.getAndIncrement());
+        return new LoadTask<T>(runnable, value, ordering.getAndIncrement());
     }
 
     /**
@@ -57,11 +57,12 @@ public void run() {
         }
     }
 
-    private static class FifoPriorityLoadTask<T> extends FutureTask<T> implements Comparable<FifoPriorityLoadTask<?>> {
+    // Visible for testing.
+    static class LoadTask<T> extends FutureTask<T> implements Comparable<LoadTask<?>> {
         private final int priority;
         private final int order;
 
-        public FifoPriorityLoadTask(Runnable runnable, T result, int order) {
+        public LoadTask(Runnable runnable, T result, int order) {
             super(runnable, result);
             if (!(runnable instanceof Prioritized)) {
                 throw new IllegalArgumentException("FifoPriorityThreadPoolExecutor must be given Runnables that "
@@ -71,25 +72,14 @@ public FifoPriorityLoadTask(Runnable runnable, T result, int order) {
             this.order = order;
         }
 
+        @SuppressWarnings("unchecked")
         @Override
         public boolean equals(Object o) {
-            if (this == o) {
-                return true;
+            if (o instanceof LoadTask) {
+                LoadTask<Object> other = (LoadTask<Object>) o;
+                return order == other.order && priority == other.priority;
             }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-
-            FifoPriorityLoadTask that = (FifoPriorityLoadTask) o;
-
-            if (order != that.order) {
-                return false;
-            }
-            if (priority != that.priority) {
-                return false;
-            }
-
-            return true;
+            return false;
         }
 
         @Override
@@ -100,7 +90,7 @@ public int hashCode() {
         }
 
         @Override
-        public int compareTo(FifoPriorityLoadTask<?> loadTask) {
+        public int compareTo(LoadTask<?> loadTask) {
             int result = priority - loadTask.priority;
             if (result == 0) {
                 result = order - loadTask.order;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillIdleHandler.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillIdleHandler.java
deleted file mode 100644
index 05be13b99..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillIdleHandler.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package com.bumptech.glide.load.engine.prefill;
-
-import android.graphics.Bitmap;
-import android.os.MessageQueue;
-import android.os.SystemClock;
-import android.util.Log;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.load.resource.bitmap.BitmapResource;
-import com.bumptech.glide.util.Util;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-
-/**
- * A class that allocates {@link android.graphics.Bitmap Bitmaps} when the main thread runs out of messages so that the
- * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} is pre-populated.
- */
-final class BitmapPreFillIdleHandler implements MessageQueue.IdleHandler {
-    private static final String TAG = "PreFillIdleHandler";
-    // Visisble for testing.
-    static final long MAX_DURATION_MILLIS = 32;
-
-    private static final Clock DEFAULT_CLOCK = new Clock();
-
-    private final BitmapPool bitmapPool;
-    private final MemoryCache memoryCache;
-    private final PreFillQueue toPrefill;
-    private final Clock clock;
-
-    private boolean isCancelled;
-
-    public BitmapPreFillIdleHandler(BitmapPool bitmapPool, MemoryCache memoryCache,
-            PreFillQueue allocationOrder) {
-        this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK);
-    }
-
-    // Visible for testing.
-    BitmapPreFillIdleHandler(BitmapPool bitmapPool, MemoryCache memoryCache,
-            PreFillQueue allocationOrder, Clock clock) {
-        this.bitmapPool = bitmapPool;
-        this.memoryCache = memoryCache;
-        this.toPrefill = allocationOrder;
-        this.clock = clock;
-    }
-
-    public void cancel() {
-        isCancelled = true;
-    }
-
-    @Override
-    public boolean queueIdle() {
-        long start = clock.now();
-        while (!toPrefill.isEmpty() && (clock.now() - start) < MAX_DURATION_MILLIS) {
-            PreFillBitmapAttribute toAllocate = toPrefill.remove();
-            Bitmap bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
-                    toAllocate.getConfig());
-
-            // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's not empty so
-            // we use all available space.
-            if ((memoryCache.getMaxSize() - memoryCache.getCurrentSize()) >= Util.getBitmapByteSize(bitmap)) {
-                memoryCache.put(new UniqueKey(), new BitmapResource(bitmap, bitmapPool));
-            } else {
-                bitmapPool.put(bitmap);
-            }
-
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] "
-                        + toAllocate.getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
-            }
-        }
-
-        return !isCancelled && !toPrefill.isEmpty();
-    }
-
-    private static class UniqueKey implements Key {
-
-        @Override
-        public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
-            // Do nothing.
-        }
-    }
-
-    // Visible for testing.
-    static class Clock {
-        public long now() {
-            return SystemClock.currentThreadTimeMillis();
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
new file mode 100644
index 000000000..6af89c197
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -0,0 +1,161 @@
+package com.bumptech.glide.load.engine.prefill;
+
+import android.graphics.Bitmap;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.SystemClock;
+import android.util.Log;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.util.Util;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A class that allocates {@link android.graphics.Bitmap Bitmaps} to make sure that the
+ * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} is pre-populated.
+ *
+ * <p>By posting to the main thread with backoffs, we try to avoid ANRs when the garbage collector gets into a state
+ * where a high percentage of {@link Bitmap} allocations trigger a stop the world GC. We try to detect whether or not a
+ * GC has occurred by only allowing our allocator to run for a limited number of milliseconds. Since the allocations
+ * themselves very fast, a GC is the most likely reason for a substantial delay. If we detect our allocator has run for
+ * more than our limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
+ */
+final class BitmapPreFillRunner implements Runnable {
+    private static final String TAG = "PreFillRunner";
+    private static final Clock DEFAULT_CLOCK = new Clock();
+
+    /**
+     * The maximum number of millis we can run before posting. Set to match and detect the duration of non concurrent
+     * GCs.
+     */
+    static final long MAX_DURATION_MS = 32;
+
+    /**
+     * The amount of time in ms we wait before continuing to allocate after the first GC is detected.
+     */
+    static final long INITIAL_BACKOFF_MS = 40;
+
+    /**
+     * The amount by which the current backoff time is multiplied each time we detect a GC.
+     */
+    static final int BACKOFF_RATIO = 4;
+
+    /**
+     * The maximum amount of time in ms we wait before continuing to allocate.
+     */
+    static final long MAX_BACKOFF_MS = TimeUnit.SECONDS.toMillis(1);
+
+    private final BitmapPool bitmapPool;
+    private final MemoryCache memoryCache;
+    private final PreFillQueue toPrefill;
+    private final Clock clock;
+    private final Set<PreFillType> seenTypes = new HashSet<PreFillType>();
+    private final Handler handler;
+
+    private long currentDelay = INITIAL_BACKOFF_MS;
+    private boolean isCancelled;
+
+    public BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {
+        this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK, new Handler(Looper.getMainLooper()));
+    }
+
+    // Visible for testing.
+    BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder, Clock clock,
+            Handler handler) {
+        this.bitmapPool = bitmapPool;
+        this.memoryCache = memoryCache;
+        this.toPrefill = allocationOrder;
+        this.clock = clock;
+        this.handler = handler;
+    }
+
+    public void cancel() {
+        isCancelled = true;
+    }
+
+    /**
+     * Attempts to allocate {@link android.graphics.Bitmap}s and returns {@code true} if there are more
+     * {@link android.graphics.Bitmap}s to allocate and {@code false} otherwise.
+     */
+    private boolean allocate() {
+        long start = clock.now();
+        while (!toPrefill.isEmpty() && !isGcDetected(start)) {
+            PreFillType toAllocate = toPrefill.remove();
+            Bitmap bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
+                    toAllocate.getConfig());
+
+            // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's not empty so
+            // we use all available space.
+            if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
+                memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
+            } else {
+                addToBitmapPool(toAllocate, bitmap);
+            }
+
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] "
+                        + toAllocate.getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
+            }
+        }
+
+        return !isCancelled && !toPrefill.isEmpty();
+    }
+
+    private boolean isGcDetected(long startTimeMs) {
+        return clock.now() - startTimeMs >= MAX_DURATION_MS;
+    }
+
+    private int getFreeMemoryCacheBytes() {
+        return memoryCache.getMaxSize() - memoryCache.getCurrentSize();
+    }
+
+    private void addToBitmapPool(PreFillType toAllocate, Bitmap bitmap) {
+        // The pool may not move sizes to the front of the LRU on put. Do a get here to make sure the size we're adding
+        // is at the front of the queue so that the Bitmap we're adding won't be evicted immediately.
+        if (seenTypes.add(toAllocate)) {
+          Bitmap fromPool = bitmapPool.get(toAllocate.getWidth(), toAllocate.getHeight(),
+              toAllocate.getConfig());
+            if (fromPool != null) {
+                bitmapPool.put(fromPool);
+            }
+        }
+
+        bitmapPool.put(bitmap);
+    }
+
+    @Override
+    public void run() {
+        if (allocate()) {
+            handler.postDelayed(this, getNextDelay());
+        }
+    }
+
+    private long getNextDelay() {
+        long result = currentDelay;
+        currentDelay = Math.min(currentDelay * BACKOFF_RATIO, MAX_BACKOFF_MS);
+        return result;
+    }
+
+    private static class UniqueKey implements Key {
+
+        @Override
+        public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
+            // Do nothing.
+        }
+    }
+
+    // Visible for testing.
+    static class Clock {
+        public long now() {
+            return SystemClock.currentThreadTimeMillis();
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index b4d9f1c47..e9ab19b2a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -1,6 +1,10 @@
 package com.bumptech.glide.load.engine.prefill;
 
+import android.graphics.Bitmap;
+import android.os.Handler;
 import android.os.Looper;
+
+import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.util.Util;
@@ -16,36 +20,51 @@
 
     private final MemoryCache memoryCache;
     private final BitmapPool bitmapPool;
+    private final DecodeFormat defaultFormat;
+    private final Handler handler = new Handler(Looper.getMainLooper());
 
-    private BitmapPreFillIdleHandler current;
+    private BitmapPreFillRunner current;
 
-    public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool) {
+    public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool, DecodeFormat defaultFormat) {
         this.memoryCache = memoryCache;
         this.bitmapPool = bitmapPool;
+        this.defaultFormat = defaultFormat;
     }
 
-    public void preFill(PreFillBitmapAttribute... bitmapAttributes) {
+    public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
         if (current != null) {
             current.cancel();
         }
+
+        PreFillType[] bitmapAttributes = new PreFillType[bitmapAttributeBuilders.length];
+        for (int i = 0; i < bitmapAttributeBuilders.length; i++) {
+            PreFillType.Builder builder = bitmapAttributeBuilders[i];
+            if (builder.getConfig() == null) {
+                builder.setConfig(
+                        defaultFormat == DecodeFormat.ALWAYS_ARGB_8888 || defaultFormat == DecodeFormat.PREFER_ARGB_8888
+                        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
+            }
+            bitmapAttributes[i] = builder.build();
+        }
+
         PreFillQueue allocationOrder = generateAllocationOrder(bitmapAttributes);
-        current = new BitmapPreFillIdleHandler(bitmapPool, memoryCache, allocationOrder);
-        Looper.myQueue().addIdleHandler(current);
+        current = new BitmapPreFillRunner(bitmapPool, memoryCache, allocationOrder);
+        handler.post(current);
     }
 
     // Visible for testing.
-    PreFillQueue generateAllocationOrder(PreFillBitmapAttribute[] preFillSizes) {
+    PreFillQueue generateAllocationOrder(PreFillType[] preFillSizes) {
         final int maxSize = memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
         int totalWeight = 0;
-        for (PreFillBitmapAttribute size : preFillSizes) {
+        for (PreFillType size : preFillSizes) {
             totalWeight += size.getWeight();
         }
 
         final float bytesPerWeight = maxSize / (float) totalWeight;
 
-        Map<PreFillBitmapAttribute, Integer> attributeToCount = new HashMap<PreFillBitmapAttribute, Integer>();
-        for (PreFillBitmapAttribute size : preFillSizes) {
+        Map<PreFillType, Integer> attributeToCount = new HashMap<PreFillType, Integer>();
+        for (PreFillType size : preFillSizes) {
             int bytesForSize = Math.round(bytesPerWeight * size.getWeight());
             int bytesPerBitmap = getSizeInBytes(size);
             int bitmapsForSize = bytesForSize / bytesPerBitmap;
@@ -55,7 +74,7 @@ PreFillQueue generateAllocationOrder(PreFillBitmapAttribute[] preFillSizes) {
         return new PreFillQueue(attributeToCount);
     }
 
-    private static int getSizeInBytes(PreFillBitmapAttribute size) {
+    private static int getSizeInBytes(PreFillType size) {
         return Util.getBitmapByteSize(size.getWidth(), size.getHeight(), size.getConfig());
     }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillBitmapAttribute.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillBitmapAttribute.java
deleted file mode 100644
index b84763fa6..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillBitmapAttribute.java
+++ /dev/null
@@ -1,129 +0,0 @@
-package com.bumptech.glide.load.engine.prefill;
-
-import android.graphics.Bitmap;
-
-/**
- * A container for a set of options used to pre-fill a {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}
- * with {@link Bitmap Bitmaps} of a single size and configuration.
- */
-public final class PreFillBitmapAttribute {
-    // Visible for testing.
-    static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
-    private final int width;
-    private final int height;
-    private final Bitmap.Config config;
-    private final int weight;
-
-    /**
-     * Constructor for a single type of {@link android.graphics.Bitmap}.
-     *
-     * @see #PreFillBitmapAttribute(int, int, int)
-     * @see #PreFillBitmapAttribute(int, int, android.graphics.Bitmap.Config, int)
-     *
-     * @param width The width in pixels of the {@link android.graphics.Bitmap} to pre-fill.
-     * @param height The height in pixels of the {@link android.graphics.Bitmap} to pre-fill.
-     */
-    public PreFillBitmapAttribute(int width, int height) {
-        this(width, height, 1);
-    }
-
-    /**
-     * Constructor for a single type of {@link android.graphics.Bitmap}.
-     *
-     * @see #PreFillBitmapAttribute(int, int)
-     * @see #PreFillBitmapAttribute(int, int, android.graphics.Bitmap.Config, int)
-     *
-     * @param width The width in pixels of the {@link android.graphics.Bitmap} to pre-fill.
-     * @param height The height in pixels of the {@link android.graphics.Bitmap} to pre-fill.
-     * @param weight An integer indicating how to balance pre-filling this size and configuration of
-     * {@link android.graphics.Bitmap} against any other sizes/configurations that may be being pre-filled.
-     */
-    public PreFillBitmapAttribute(int width, int height, int weight) {
-        this(width, height, DEFAULT_CONFIG, weight);
-    }
-
-    /**
-     * Constructor for a single type of {@link android.graphics.Bitmap}.
-     *
-     * @see #PreFillBitmapAttribute(int, int)
-     * @see #PreFillBitmapAttribute(int, int, int)
-     *
-     * @param width The width in pixels of the {@link android.graphics.Bitmap Bitmaps} to
-     *              pre-fill.
-     * @param height The height in pixels of the {@link android.graphics.Bitmap Bitmaps} to
-     *               pre-fill.
-     * @param config The {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap Bitmaps} to
-     *               pre-fill.
-     * @param weight An integer indicating how to balance pre-filling this size and configuration of
-     * {@link android.graphics.Bitmap} against any other sizes/configurations that may be being pre-filled.
-     */
-    public PreFillBitmapAttribute(int width, int height, Bitmap.Config config, int weight) {
-        this.width = width;
-        this.height = height;
-        this.config = config;
-        this.weight = weight;
-    }
-
-    /**
-     * Returns the width in pixels of the {@link android.graphics.Bitmap Bitmaps}.
-     */
-    public int getWidth() {
-        return width;
-    }
-
-    /**
-     * Returns the height in pixels of the {@link android.graphics.Bitmap Bitmaps}.
-     */
-    public int getHeight() {
-        return height;
-    }
-
-    /**
-     * Returns the {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap Bitmaps}.
-     */
-    public Bitmap.Config getConfig() {
-        return config;
-    }
-
-    /**
-     * Returns the weight of the {@link android.graphics.Bitmap Bitmaps} of this type.
-     */
-    public int getWeight() {
-        return weight;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        } else if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
-
-        PreFillBitmapAttribute size = (PreFillBitmapAttribute) o;
-
-        return height == size.height
-                && weight == size.weight
-                && width == size.width
-                && config == size.config;
-    }
-
-    @Override
-    public int hashCode() {
-        int result = width;
-        result = 31 * result + height;
-        result = 31 * result + config.hashCode();
-        result = 31 * result + weight;
-        return result;
-    }
-
-    @Override
-    public String toString() {
-        return "PreFillSize{"
-                + "width=" + width
-                + ", height=" + height
-                + ", config=" + config
-                + ", weight=" + weight
-                + '}';
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillQueue.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillQueue.java
index abdc9e2ba..f88032a80 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillQueue.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillQueue.java
@@ -6,23 +6,23 @@
 
 final class PreFillQueue {
 
-    private final Map<PreFillBitmapAttribute, Integer> bitmapsPerType;
-    private final List<PreFillBitmapAttribute> keyList;
+    private final Map<PreFillType, Integer> bitmapsPerType;
+    private final List<PreFillType> keyList;
     private int bitmapsRemaining;
     private int keyIndex;
 
-    public PreFillQueue(Map<PreFillBitmapAttribute, Integer> bitmapsPerType) {
+    public PreFillQueue(Map<PreFillType, Integer> bitmapsPerType) {
         this.bitmapsPerType = bitmapsPerType;
         // We don't particularly care about the initial order.
-        keyList = new ArrayList<PreFillBitmapAttribute>(bitmapsPerType.keySet());
+        keyList = new ArrayList<PreFillType>(bitmapsPerType.keySet());
 
         for (Integer count : bitmapsPerType.values()) {
             bitmapsRemaining += count;
         }
     }
 
-    public PreFillBitmapAttribute remove() {
-        PreFillBitmapAttribute result = keyList.get(keyIndex);
+    public PreFillType remove() {
+        PreFillType result = keyList.get(keyIndex);
 
         Integer countForResult = bitmapsPerType.get(result);
         if (countForResult == 1) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
new file mode 100644
index 000000000..5037b3524
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -0,0 +1,172 @@
+package com.bumptech.glide.load.engine.prefill;
+
+import android.graphics.Bitmap;
+
+/**
+ * A container for a set of options used to pre-fill a {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}
+ * with {@link Bitmap Bitmaps} of a single size and configuration.
+ */
+public final class PreFillType {
+    // Visible for testing.
+    static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
+    private final int width;
+    private final int height;
+    private final Bitmap.Config config;
+    private final int weight;
+
+    /**
+     * Constructor for a single type of {@link android.graphics.Bitmap}.
+     *
+     * @param width The width in pixels of the {@link android.graphics.Bitmap Bitmaps} to
+     *              pre-fill.
+     * @param height The height in pixels of the {@link android.graphics.Bitmap Bitmaps} to
+     *               pre-fill.
+     * @param config The {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap Bitmaps} to
+     *               pre-fill.
+     * @param weight An integer indicating how to balance pre-filling this size and configuration of
+     * {@link android.graphics.Bitmap} against any other sizes/configurations that may be being pre-filled.
+     */
+    PreFillType(int width, int height, Bitmap.Config config, int weight) {
+        if (config == null) {
+            throw new NullPointerException("Config must not be null");
+        }
+
+        this.width = width;
+        this.height = height;
+        this.config = config;
+        this.weight = weight;
+    }
+
+    /**
+     * Returns the width in pixels of the {@link android.graphics.Bitmap Bitmaps}.
+     */
+    int getWidth() {
+        return width;
+    }
+
+    /**
+     * Returns the height in pixels of the {@link android.graphics.Bitmap Bitmaps}.
+     */
+    int getHeight() {
+        return height;
+    }
+
+    /**
+     * Returns the {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap Bitmaps}.
+     */
+    Bitmap.Config getConfig() {
+        return config;
+    }
+
+    /**
+     * Returns the weight of the {@link android.graphics.Bitmap Bitmaps} of this type.
+     */
+    int getWeight() {
+        return weight;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof PreFillType) {
+            PreFillType other = (PreFillType) o;
+            return height == other.height
+                    && width == other.width
+                    && weight == other.weight
+                    && config == other.config;
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = width;
+        result = 31 * result + height;
+        result = 31 * result + config.hashCode();
+        result = 31 * result + weight;
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "PreFillSize{"
+                + "width=" + width
+                + ", height=" + height
+                + ", config=" + config
+                + ", weight=" + weight
+                + '}';
+    }
+
+    /**
+     * Builder for {@link PreFillType}.
+     */
+    public static class Builder {
+        private final int width;
+        private final int height;
+
+        private Bitmap.Config config;
+        private int weight = 1;
+
+        /**
+         * Constructor for a builder that uses the given size as the width and height of the Bitmaps to prefill.
+         * @param size The width and height in pixels of the Bitmaps to prefill.
+         */
+        public Builder(int size) {
+            this(size, size);
+        }
+
+        /**
+         * Constructor for a builder that uses the given dimensions as the dimensions of the Bitmaps to prefill.
+         * @param width The width in pixels of the Bitmaps to prefill.
+         * @param height The height in pixels of the Bitmaps to prefill.
+         */
+        public Builder(int width, int height) {
+            if (width <= 0) {
+                throw new IllegalArgumentException("Width must be > 0");
+            }
+            if (height <= 0) {
+                throw new IllegalArgumentException("Height must be > 0");
+            }
+            this.width = width;
+            this.height = height;
+        }
+
+        /**
+         * Sets the {@link android.graphics.Bitmap.Config} for the Bitmaps to pre-fill.
+         * @param config The config to use, or null to use Glide's default.
+         * @return This builder.
+         */
+        public Builder setConfig(Bitmap.Config config) {
+            this.config = config;
+            return this;
+        }
+
+        /**
+         * Returns the current {@link android.graphics.Bitmap.Config}.
+         */
+        Bitmap.Config getConfig() {
+            return config;
+        }
+
+        /**
+         * Sets the weight to use to balance how many Bitmaps of this type are prefilled relative to the other requested
+         * types.
+         * @param weight An integer indicating how to balance pre-filling this size and configuration of
+         * {@link android.graphics.Bitmap} against any other sizes/configurations that may be being pre-filled.
+         * @return This builder.
+         */
+        public Builder setWeight(int weight) {
+            if (weight <= 0) {
+                throw new IllegalArgumentException("Weight must be > 0");
+            }
+            this.weight = weight;
+            return this;
+        }
+
+        /**
+         * Returns a new {@link PreFillType}.
+         */
+        PreFillType build() {
+            return new PreFillType(width, height, config, weight);
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/BasicHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/BasicHeaders.java
new file mode 100644
index 000000000..e5ec6f9bb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/BasicHeaders.java
@@ -0,0 +1,77 @@
+package com.bumptech.glide.load.model;
+
+import android.text.TextUtils;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * A wrapper class for a set of headers to be included in a Glide request.
+ */
+public final class BasicHeaders implements Headers {
+
+    private final Map<String, Set<String>> headers;
+    private volatile Map<String, String> combinedHeaders;
+
+    BasicHeaders(Map<String, Set<String>> headers) {
+        this.headers = Collections.unmodifiableMap(headers);
+    }
+
+    public Map<String, String> getHeaders() {
+        if (combinedHeaders == null) {
+            synchronized (this) {
+                if (combinedHeaders == null) {
+                    this.combinedHeaders = generateCombinedHeaders();
+                }
+            }
+        }
+
+        return combinedHeaders;
+    }
+
+    private Map<String, String> generateCombinedHeaders() {
+        Map<String, String> combinedHeaders = new HashMap<String, String>();
+        for (Map.Entry<String, Set<String>> entry : headers.entrySet()) {
+            combinedHeaders.put(entry.getKey(), TextUtils.join(",", entry.getValue()));
+        }
+        return Collections.unmodifiableMap(combinedHeaders);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof BasicHeaders) {
+            BasicHeaders other = (BasicHeaders) o;
+            return headers.equals(other.headers);
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return headers.hashCode();
+    }
+
+    /**
+     * Builder class for {@link Headers}.
+     */
+    public static final class Builder {
+        private final Map<String, Set<String>> headers = new HashMap<String, Set<String>>();
+
+        public void addHeader(String key, String value) {
+            if (headers.containsKey(key)) {
+                headers.get(key).add(value);
+            } else {
+                Set<String> values = new HashSet<String>();
+                values.add(value);
+                headers.put(key, values);
+            }
+        }
+
+        public BasicHeaders build() {
+            return new BasicHeaders(headers);
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index 146b9b3d0..87d951722 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+
 import com.bumptech.glide.load.data.DataFetcher;
 
 import java.io.File;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java
index d8ebf616c..9900322fe 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.content.Context;
+
 import com.bumptech.glide.load.data.DataFetcher;
 
 import java.util.HashMap;
@@ -30,6 +31,12 @@ public String toString() {
         }
     };
 
+    private final Context context;
+
+    public GenericLoaderFactory(Context context) {
+       this.context = context.getApplicationContext();
+    }
+
     /**
      * Removes and returns the registered {@link ModelLoaderFactory} for the given model and resource classes. Returns
      * null if no such factory is registered. Clears all cached model loaders.
@@ -92,13 +99,30 @@ public String toString() {
      * {@link ModelLoader} or building a new a new {@link ModelLoader} using registered {@link ModelLoaderFactory}s.
      * Returns null if no {@link ModelLoaderFactory} is registered for the given classes.
      *
+     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead. Scheduled to be removed in Glide 4.0.
      * @param modelClass The model class.
      * @param resourceClass The resource class.
+     * @param context Unused
      * @param <T> The type of the model.
      * @param <Y> The type of the resource.
      */
+    @Deprecated
     public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass,
-                                                                  Context context) {
+            Context context) {
+        return buildModelLoader(modelClass, resourceClass);
+    }
+
+    /**
+     * Returns a {@link ModelLoader} for the given model and resource classes by either returning a cached
+     * {@link ModelLoader} or building a new a new {@link ModelLoader} using registered {@link ModelLoaderFactory}s.
+     * Returns null if no {@link ModelLoaderFactory} is registered for the given classes.
+     *
+     * @param modelClass The model class.
+     * @param resourceClass The resource class.
+     * @param <T> The type of the model.
+     * @param <Y> The type of the resource.
+     */
+    public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass) {
         ModelLoader<T, Y> result = getCachedLoader(modelClass, resourceClass);
         if (result != null) {
             // We've already tried to create a model loader and can't with the currently registered set of factories,
@@ -152,7 +176,6 @@ public String toString() {
             result = resourceToFactories.get(resourceClass);
         }
 
-
         if (result == null) {
             for (Class<? super T> registeredModelClass : modelClassToResourceFactories.keySet()) {
                 // This accounts for model subclasses, our map only works for exact matches. We should however still
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 3fb16f746..5d3cb3019 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -5,45 +5,69 @@
 
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.Map;
 
 /**
  * A wrapper for strings representing http/https URLs responsible for ensuring URLs are properly escaped and avoiding
  * unnecessary URL instantiations for loaders that require only string urls rather than URL objects.
  *
- * <p>
- *  Users wishing to replace the class for handling URLs must register a factory using GlideUrl.
- * </p>
+ * <p>  Users wishing to replace the class for handling URLs must register a factory using GlideUrl. </p>
  *
- * <p>
- *     To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string URL, call
- *     {@link #toURL()} and then {@link java.net.URL#toString()}.
- * </p>
+ * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string URL, call
+ * {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache key, call
+ * {@link #getCacheKey()}. </p>
+ *
+ * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for convenience. </p>
  */
 public class GlideUrl {
     private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
 
     private final URL url;
-    private String stringUrl;
+    private final Headers headers;
+    private final String stringUrl;
 
+    private String safeStringUrl;
     private URL safeUrl;
 
     public GlideUrl(URL url) {
+        this(url, Headers.NONE);
+    }
+
+    public GlideUrl(String url) {
+        this(url, Headers.NONE);
+    }
+
+    public GlideUrl(URL url, Headers headers) {
         if (url == null) {
             throw new IllegalArgumentException("URL must not be null!");
         }
+        if (headers == null) {
+            throw new IllegalArgumentException("Headers must not be null");
+        }
         this.url = url;
         stringUrl = null;
+        this.headers = headers;
     }
 
-    public GlideUrl(String url) {
+    public GlideUrl(String url, Headers headers) {
         if (TextUtils.isEmpty(url)) {
             throw new IllegalArgumentException("String url must not be empty or null: " + url);
         }
+        if (headers == null) {
+            throw new IllegalArgumentException("Headers must not be null");
+        }
         this.stringUrl = url;
         this.url = null;
+        this.headers = headers;
     }
 
-
+    /**
+     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
+     *
+     * @see #toStringUrl()
+     * @see #getCacheKey()
+     * @throws MalformedURLException
+     */
     public URL toURL() throws MalformedURLException {
         return getSafeUrl();
     }
@@ -52,38 +76,70 @@ public URL toURL() throws MalformedURLException {
     // using it would require both decoding and encoding each string which is more complicated, slower and generates
     // more objects than the solution below. See also issue #133.
     private URL getSafeUrl() throws MalformedURLException {
-        if (safeUrl != null) {
-            return safeUrl;
+        if (safeUrl == null) {
+            safeUrl = new URL(getSafeStringUrl());
         }
-        String unsafe = toString();
-        String safe = Uri.encode(unsafe, ALLOWED_URI_CHARS);
-
-        safeUrl = new URL(safe);
         return safeUrl;
     }
 
+    /**
+     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
+     *
+     * @see #toURL()
+     * @see #getCacheKey()
+     */
+    public String toStringUrl() {
+        return getSafeStringUrl();
+    }
+
+    private String getSafeStringUrl() {
+        if (TextUtils.isEmpty(safeStringUrl)) {
+            String unsafeStringUrl = stringUrl;
+            if (TextUtils.isEmpty(unsafeStringUrl)) {
+                unsafeStringUrl = url.toString();
+            }
+            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
+        }
+        return safeStringUrl;
+    }
+
+    /**
+     * Returns a non-null {@link Map} containing headers.
+     */
+    public Map<String, String> getHeaders() {
+        return headers.getHeaders();
+    }
+
+    /**
+     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
+     *
+     * <p> This method does not include headers. </p>
+     *
+     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
+     */
+    public String getCacheKey() {
+      return stringUrl != null ? stringUrl : url.toString();
+    }
+
     @Override
     public String toString() {
-        if (TextUtils.isEmpty(stringUrl)) {
-            stringUrl = url.toString();
-        }
-        return stringUrl;
+        return getCacheKey() + '\n' + headers.toString();
     }
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) {
-            return true;
+        if (o instanceof GlideUrl) {
+          GlideUrl other = (GlideUrl) o;
+          return getCacheKey().equals(other.getCacheKey())
+              && headers.equals(other.headers);
         }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
-
-        return toString().equals(o.toString());
+        return false;
     }
 
     @Override
     public int hashCode() {
-        return toString().hashCode();
+        int hashCode = getCacheKey().hashCode();
+        hashCode = 31 * hashCode + headers.hashCode();
+        return hashCode;
     }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Headers.java b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
new file mode 100644
index 000000000..52e778735
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.load.model;
+
+import java.util.Map;
+
+/**
+ * An interface for a wrapper for a set of headers to be included in a Glide request.
+ * Implementations must implement equals() and hashcode().
+ */
+public interface Headers {
+
+    /** An empty Headers object that can be used if users don't want to provide headers. */
+    Headers NONE = new BasicHeaders.Builder().build();
+
+    Map<String, String> getHeaders();
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java
index 0e7c37633..3d057baca 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java
@@ -2,6 +2,7 @@
 
 import android.os.ParcelFileDescriptor;
 import android.util.Log;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
new file mode 100644
index 000000000..78f292430
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -0,0 +1,13 @@
+package com.bumptech.glide.load.model;
+
+/**
+ * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
+ * example) to be generated in the background during the first fetch.
+ *
+ * <p> Implementations should implement equals() and hashcode() </p> .
+ */
+public interface LazyHeaderFactory {
+
+    String buildHeader();
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
new file mode 100644
index 000000000..2a5231b57
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -0,0 +1,134 @@
+package com.bumptech.glide.load.model;
+
+import android.text.TextUtils;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * A wrapper class for a set of headers to be included in a Glide request, allowing headers to be
+ * constructed lazily.
+ *
+ * <p> Should be used instead of BasicHeaders when constructing headers requires I/O. </p>
+ */
+public final class LazyHeaders implements Headers {
+    private final Map<String, Set<String>> eagerHeaders;
+    private final Map<String, Set<LazyHeaderFactory>> lazyHeaders;
+    private volatile Map<String, String> combinedHeaders;
+
+    LazyHeaders(Map<String, Set<String>> eagerHeaders,
+        Map<String, Set<LazyHeaderFactory>> lazyHeaders) {
+        this.eagerHeaders = Collections.unmodifiableMap(eagerHeaders);
+        this.lazyHeaders = Collections.unmodifiableMap(lazyHeaders);
+    }
+
+    @Override
+    public Map<String, String> getHeaders() {
+        if (combinedHeaders == null) {
+            synchronized (this) {
+                if (combinedHeaders == null) {
+                    this.combinedHeaders = Collections.unmodifiableMap(generateHeaders());
+                }
+            }
+        }
+
+        return combinedHeaders;
+    }
+
+    private Map<String, String> generateHeaders() {
+        Map<String, String> combinedHeaders = new HashMap<String, String>();
+        Set<String> combinedKeys = new HashSet<String>(eagerHeaders.keySet());
+        combinedKeys.addAll(lazyHeaders.keySet());
+
+        for (String key : combinedKeys) {
+            Set<String> values = new HashSet<String>();
+            if (eagerHeaders.containsKey(key)) {
+                values.addAll(eagerHeaders.get(key));
+            }
+            if (lazyHeaders.containsKey(key)) {
+                for (LazyHeaderFactory factory : lazyHeaders.get(key)) {
+                    values.add(factory.buildHeader());
+                }
+            }
+            combinedHeaders.put(key, TextUtils.join(",", values));
+        }
+
+        return combinedHeaders;
+    }
+
+    @Override
+    public String toString() {
+        Set<String> combinedKeys = new HashSet<String>(eagerHeaders.keySet());
+        combinedKeys.addAll(lazyHeaders.keySet());
+
+        StringBuilder stringBuilder = new StringBuilder();
+        for (String key : combinedKeys) {
+            stringBuilder.append(key)
+                .append(": ");
+            if (eagerHeaders.containsKey(key)) {
+                stringBuilder.append(TextUtils.join(",", eagerHeaders.get(key)));
+            }
+            if (lazyHeaders.containsKey(key)) {
+                for (LazyHeaderFactory factory : lazyHeaders.get(key)) {
+                    stringBuilder.append(factory.toString());
+                    stringBuilder.append(',');
+                }
+            }
+            stringBuilder.append('\n');
+        }
+        return stringBuilder.toString();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+
+        LazyHeaders otherHeaders = (LazyHeaders) o;
+        return eagerHeaders.equals(otherHeaders.eagerHeaders)
+            && lazyHeaders.equals(otherHeaders.lazyHeaders);
+    }
+
+    @Override
+    public int hashCode() {
+        return eagerHeaders.hashCode() + 31 * lazyHeaders.hashCode();
+    }
+
+    /**
+     * Builder class for {@link BasicHeaders}.
+     */
+    public static final class Builder {
+        private final Map<String, Set<String>> eagerHeaders = new HashMap<String, Set<String>>();
+        private final Map<String, Set<LazyHeaderFactory>> lazyHeaders =
+            new HashMap<String, Set<LazyHeaderFactory>>();
+
+        public void addHeader(String key, String value) {
+            Set<String> values = eagerHeaders.get(key);
+            if (values == null) {
+                values = new HashSet<String>();
+                eagerHeaders.put(key, values);
+            }
+            values.add(value);
+        }
+
+        public void addHeader(String key, LazyHeaderFactory factory) {
+            Set<LazyHeaderFactory> factories = lazyHeaders.get(key);
+            if (factories == null) {
+                factories = new HashSet<LazyHeaderFactory>();
+                lazyHeaders.put(key, factories);
+            }
+            factories.add(factory);
+        }
+
+        public LazyHeaders build() {
+          return new LazyHeaders(eagerHeaders, lazyHeaders);
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index 5a46cde64..55c0de0c7 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -35,8 +35,8 @@ protected void onItemEvicted(ModelKey<A> key, B item) {
      * Get a value.
      *
      * @param model The model.
-     * @param width The width of the view the image is being loaded into.
-     * @param height The height of the view the image is being loaded into.
+     * @param width The width in pixels of the view the image is being loaded into.
+     * @param height The height in pixels of the view the image is being loaded into.
      *
      * @return The cached result, or null.
      */
@@ -51,8 +51,8 @@ public B get(A model, int width, int height) {
      * Add a value.
      *
      * @param model The model.
-     * @param width The width of the view the image is being loaded into.
-     * @param height The height of the view the image is being loaded into.
+     * @param width The width in pixels of the view the image is being loaded into.
+     * @param height The height in pixels of the view the image is being loaded into.
      * @param value The value to store.
      */
     public void put(A model, int width, int height, B value) {
@@ -60,14 +60,15 @@ public void put(A model, int width, int height, B value) {
         cache.put(key, value);
     }
 
-    private static final class ModelKey<A> {
+    // Visible for testing.
+    static final class ModelKey<A> {
         private static final Queue<ModelKey<?>> KEY_QUEUE = Util.createQueue(0);
 
         private int height;
         private int width;
         private A model;
 
-        public static <A> ModelKey<A> get(A model, int width, int height) {
+        static <A> ModelKey<A> get(A model, int width, int height) {
             @SuppressWarnings("unchecked")
             ModelKey<A> modelKey = (ModelKey<A>) KEY_QUEUE.poll();
             if (modelKey == null) {
@@ -92,26 +93,11 @@ public void release() {
 
         @Override
         public boolean equals(Object o) {
-            if (this == o) {
-                return true;
+            if (o instanceof ModelKey) {
+                ModelKey other = (ModelKey) o;
+                return width == other.width && height == other.height && model.equals(other.model);
             }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-
-            ModelKey<?> modelKey = (ModelKey<?>) o;
-
-            if (height != modelKey.height) {
-                return false;
-            }
-            if (width != modelKey.width) {
-                return false;
-            }
-            if (!model.equals(modelKey.model)) {
-                return false;
-            }
-
-            return true;
+            return false;
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index f028209a0..4c2e43ff4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -37,8 +37,12 @@
      * </p>
      *
      * @param model The model representing the resource.
-     * @param width The width of the view or target the resource will be loaded into
-     * @param height The height of the view or target the resource will be loaded into
+     * @param width The width in pixels of the view or target the resource will be loaded into, or
+     *              {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that the resource should
+     *              be loaded at its original width.
+     * @param height The height in pixels of the view or target the resource will be loaded into, or
+     *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that the resource should
+     *               be loaded at its original height.
      * @return A {@link DataFetcher} that can obtain the data the resource can be decoded from if the resource is not
      * cached, or null if no valid {@link com.bumptech.glide.load.data.DataFetcher} could be constructed.
      */
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 06bb1e557..efc2bd6a9 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.content.res.Resources;
 import android.net.Uri;
+
 import com.bumptech.glide.load.data.DataFetcher;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index c4f1a7113..1022754da 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -25,8 +25,8 @@ public boolean encode(InputStream data, OutputStream os) {
             }
             return true;
         } catch (IOException e) {
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Failed to encode data onto the OutputStream", e);
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "Failed to encode data onto the OutputStream", e);
             }
             return false;
         } finally {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index a8e793fc5..efdf666c2 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+
 import com.bumptech.glide.load.data.DataFetcher;
 
 import java.io.File;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index 6120db45d..30db4a6c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -3,6 +3,7 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
+
 import com.bumptech.glide.load.data.DataFetcher;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorFileLoader.java
index 895903695..2431df3e8 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorFileLoader.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.model.FileLoader;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
@@ -24,8 +25,7 @@
     public static class Factory implements ModelLoaderFactory<File, ParcelFileDescriptor> {
         @Override
         public ModelLoader<File, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {
-            return new FileDescriptorFileLoader(factories.buildModelLoader(Uri.class, ParcelFileDescriptor.class,
-                    context));
+            return new FileDescriptorFileLoader(factories.buildModelLoader(Uri.class, ParcelFileDescriptor.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorResourceLoader.java
index b69db440c..0f107bd18 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorResourceLoader.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -23,7 +24,7 @@
         @Override
         public ModelLoader<Integer, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {
             return new FileDescriptorResourceLoader(context, factories.buildModelLoader(Uri.class,
-                    ParcelFileDescriptor.class, context));
+                    ParcelFileDescriptor.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorStringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorStringLoader.java
index 23eead660..c6f335fac 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorStringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorStringLoader.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -22,8 +23,7 @@
     public static class Factory implements ModelLoaderFactory<String, ParcelFileDescriptor> {
         @Override
         public ModelLoader<String, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {
-            return new FileDescriptorStringLoader(factories.buildModelLoader(Uri.class, ParcelFileDescriptor.class,
-                    context));
+            return new FileDescriptorStringLoader(factories.buildModelLoader(Uri.class, ParcelFileDescriptor.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorUriLoader.java
index 84a90f56b..d950461ad 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorUriLoader.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
@@ -25,7 +26,7 @@
         @Override
         public ModelLoader<Uri, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {
             return new FileDescriptorUriLoader(context, factories.buildModelLoader(GlideUrl.class,
-                    ParcelFileDescriptor.class, context));
+                    ParcelFileDescriptor.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index a3af90536..94e5dd509 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -4,10 +4,11 @@
 import android.text.TextUtils;
 
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.model.ModelCache;
+import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.Headers;
+import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
-import com.bumptech.glide.load.data.DataFetcher;
 
 import java.io.InputStream;
 
@@ -15,7 +16,7 @@
  * A base class for loading images over http/https. Can be subclassed for use with any model that can be translated
  * in to {@link java.io.InputStream} data.
  *
- * @param <T> The type of the model
+ * @param <T> The type of the model.
  */
 public abstract class BaseGlideUrlLoader<T> implements StreamModelLoader<T> {
     private final ModelLoader<GlideUrl, InputStream> concreteLoader;
@@ -51,7 +52,7 @@ public BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader, Mod
                return null;
             }
 
-            result = new GlideUrl(stringURL);
+            result = new GlideUrl(stringURL, getHeaders(model, width, height));
 
             if (modelCache != null) {
                 modelCache.put(model, width, height, result);
@@ -64,10 +65,22 @@ public BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader, Mod
     /**
      * Get a valid url http:// or https:// for the given model and dimensions as a string.
      *
-     * @param model The model
-     * @param width The width of the view/target the image will be loaded into
-     * @param height The height of the view/target the image will be loaded into
-     * @return The String url
+     * @param model The model.
+     * @param width The width in pixels of the view/target the image will be loaded into.
+     * @param height The height in pixels of the view/target the image will be loaded into.
+     * @return The String url.
      */
     protected abstract String getUrl(T model, int width, int height);
+
+    /**
+     * Get the headers for the given model and dimensions as a map of strings to sets of strings.
+     *
+     * @param model The model.
+     * @param width The width in pixels of the view/target the image will be loaded into.
+     * @param height The height in pixels of the view/target the image will be loaded into.
+     * @return The Headers object containing the headers, or null if no headers should be added.
+     */
+    protected Headers getHeaders(T model, int width, int height) {
+        return Headers.NONE;
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoader.java
index 694537bdc..3ee3060da 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUrlGlideUrlLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model.stream;
 
 import android.content.Context;
+
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoader.java
index e069fd779..980997a6b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreStreamLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.MediaStoreThumbFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java
index a323d0c3c..3f0277dca 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model.stream;
 
 import android.content.Context;
+
 import com.bumptech.glide.load.data.ByteArrayFetcher;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
@@ -22,7 +23,7 @@ public StreamByteArrayLoader() {
 
     /**
      * @deprecated Use {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)}
-     * and the empty constructor instead.
+     * and the empty constructor instead. Scheduled to be removed in Glide 4.0.
      */
     @Deprecated
     public StreamByteArrayLoader(String id) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamFileLoader.java
index 3042a896b..1aca470a9 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamFileLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.model.FileLoader;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
@@ -22,7 +23,7 @@
     public static class Factory implements ModelLoaderFactory<File, InputStream> {
         @Override
         public ModelLoader<File, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamFileLoader(factories.buildModelLoader(Uri.class, InputStream.class, context));
+            return new StreamFileLoader(factories.buildModelLoader(Uri.class, InputStream.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamResourceLoader.java
index a385d3cca..a38255748 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamResourceLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -22,7 +23,7 @@
 
         @Override
         public ModelLoader<Integer, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamResourceLoader(context, factories.buildModelLoader(Uri.class, InputStream.class, context));
+            return new StreamResourceLoader(context, factories.buildModelLoader(Uri.class, InputStream.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamStringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamStringLoader.java
index 1f951ee49..80bbb7af6 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamStringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamStringLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -22,7 +23,7 @@
     public static class Factory implements ModelLoaderFactory<String, InputStream> {
         @Override
         public ModelLoader<String, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamStringLoader(factories.buildModelLoader(Uri.class, InputStream.class, context));
+            return new StreamStringLoader(factories.buildModelLoader(Uri.class, InputStream.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUriLoader.java
index 3b15b2f7b..086f4c4cb 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUriLoader.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.StreamAssetPathFetcher;
@@ -28,7 +29,7 @@
 
         @Override
         public ModelLoader<Uri, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamUriLoader(context, factories.buildModelLoader(GlideUrl.class, InputStream.class, context));
+            return new StreamUriLoader(context, factories.buildModelLoader(GlideUrl.class, InputStream.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUrlLoader.java
index c8d352521..ec6a207d4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamUrlLoader.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.load.model.stream;
 
 import android.content.Context;
-import com.bumptech.glide.load.model.GlideUrl;
+
 import com.bumptech.glide.load.model.GenericLoaderFactory;
+import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.UrlLoader;
@@ -23,7 +24,7 @@
     public static class Factory implements ModelLoaderFactory<URL, InputStream> {
         @Override
         public ModelLoader<URL, InputStream> build(Context context, GenericLoaderFactory factories) {
-            return new StreamUrlLoader(factories.buildModelLoader(GlideUrl.class, InputStream.class, context));
+            return new StreamUrlLoader(factories.buildModelLoader(GlideUrl.class, InputStream.class));
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
index 4dca7fb1a..33ccbb8a0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
@@ -13,6 +13,9 @@
     protected final T data;
 
     public SimpleResource(T data) {
+        if (data == null) {
+            throw new NullPointerException("Data must not be null");
+        }
         this.data = data;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java
index 7ca6f4968..36c4df17d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
 /**
  * A bitmap decoder for a given resource type.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index 616204d57..9d062e173 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
+
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 import com.bumptech.glide.util.Util;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index 5bd2f9353..ab6d8df84 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.util.Log;
+
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LogTime;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 0ce032ea5..10785c6bb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Util;
@@ -12,7 +13,28 @@
     private final Bitmap bitmap;
     private final BitmapPool bitmapPool;
 
+    /**
+     * Returns a new {@link BitmapResource} wrapping the given {@link Bitmap} if the Bitmap is non-null or null if the
+     * given Bitmap is null.
+     *
+     * @param bitmap A Bitmap.
+     * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
+     */
+    public static BitmapResource obtain(Bitmap bitmap, BitmapPool bitmapPool) {
+        if (bitmap == null) {
+            return null;
+        } else {
+            return new BitmapResource(bitmap, bitmapPool);
+        }
+    }
+
     public BitmapResource(Bitmap bitmap, BitmapPool bitmapPool) {
+        if (bitmap == null) {
+            throw new NullPointerException("Bitmap must not be null");
+        }
+        if (bitmapPool == null) {
+            throw new NullPointerException("BitmapPool must not be null");
+        }
         this.bitmap = bitmap;
         this.bitmapPool = bitmapPool;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index 3195504b8..326a50e86 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -2,10 +2,13 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Util;
 
 /**
  * A simple {@link com.bumptech.glide.load.Transformation} for transforming {@link android.graphics.Bitmap}s that
@@ -41,18 +44,20 @@ public BitmapTransformation(BitmapPool bitmapPool) {
 
     @Override
     public final Resource<Bitmap> transform(Resource<Bitmap> resource, int outWidth, int outHeight) {
-        if (outWidth <= 0 || outHeight <= 0) {
+        if (!Util.isValidDimensions(outWidth, outHeight)) {
             throw new IllegalArgumentException("Cannot apply transformation on width: " + outWidth + " or height: "
-                    + outHeight + " less than or equal to zero");
+                    + outHeight + " less than or equal to zero and not Target.SIZE_ORIGINAL");
         }
         Bitmap toTransform = resource.get();
-        Bitmap transformed = transform(bitmapPool, toTransform, outWidth, outHeight);
+        int targetWidth = outWidth == Target.SIZE_ORIGINAL ? toTransform.getWidth() : outWidth;
+        int targetHeight = outHeight == Target.SIZE_ORIGINAL ? toTransform.getHeight() : outHeight;
+        Bitmap transformed = transform(bitmapPool, toTransform, targetWidth, targetHeight);
 
         final Resource<Bitmap> result;
         if (toTransform.equals(transformed)) {
             result = resource;
         } else {
-            result = new BitmapResource(transformed, bitmapPool);
+            result = BitmapResource.obtain(transformed, bitmapPool);
         }
 
         return result;
@@ -62,13 +67,19 @@ public BitmapTransformation(BitmapPool bitmapPool) {
      * Transforms the given {@link android.graphics.Bitmap} based on the given dimensions and returns the transformed
      * result.
      *
+     * <p>
+     *     outWidth and outHeight will never be {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}, this
+     *     class converts them to be the size of the Bitmap we're going to transform before calling this method.
+     * </p>
+     *
      * @param pool A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can be used to obtain and
      *             return intermediate {@link Bitmap}s used in this transformation. For every
      *             {@link android.graphics.Bitmap} obtained from the pool during this transformation, a
      *             {@link android.graphics.Bitmap} must also be returned.
      * @param toTransform The {@link android.graphics.Bitmap} to transform.
-     * @param outWidth The ideal width of the transformed bitmap (does not need to match exactly).
-     * @param outHeight The ideal height of the transformed bitmap (does not need to match exactly).
+     * @param outWidth The ideal width of the transformed bitmap (the transformed width does not need to match exactly).
+     * @param outHeight The ideal height of the transformed bitmap (the transformed heightdoes not need to match
+     *                  exactly).
      */
     protected abstract Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index d3633edd6..62eda0fab 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -25,7 +25,8 @@ public CenterCrop(BitmapPool bitmapPool) {
     @SuppressWarnings("PMD.CompareObjectsWithEquals")
     @Override
     protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-        final Bitmap toReuse = pool.get(outWidth, outHeight, toTransform.getConfig());
+        final Bitmap toReuse = pool.get(outWidth, outHeight, toTransform.getConfig() != null
+                ? toTransform.getConfig() : Bitmap.Config.ARGB_8888);
         Bitmap transformed = TransformationUtils.centerCrop(toReuse, toTransform, outWidth, outHeight);
         if (toReuse != null && toReuse != transformed && !pool.put(toReuse)) {
             toReuse.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index e61431979..56eca774a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -8,8 +8,10 @@
 
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.ByteArrayPool;
 import com.bumptech.glide.util.ExceptionCatchingInputStream;
+import com.bumptech.glide.util.MarkEnforcingInputStream;
 import com.bumptech.glide.util.Util;
 
 import java.io.IOException;
@@ -105,21 +107,31 @@ public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeigh
         final byte[] bytesForOptions = byteArrayPool.getBytes();
         final byte[] bytesForStream = byteArrayPool.getBytes();
         final BitmapFactory.Options options = getDefaultOptions();
-        // TODO(#126): when the framework handles exceptions better, consider removing.
-        final ExceptionCatchingInputStream stream =
-                ExceptionCatchingInputStream.obtain(new RecyclableBufferedInputStream(is, bytesForStream));
+
+        // Use to fix the mark limit to avoid allocating buffers that fit entire images.
+        RecyclableBufferedInputStream bufferedStream = new RecyclableBufferedInputStream(
+                is, bytesForStream);
+        // Use to retrieve exceptions thrown while reading.
+        // TODO(#126): when the framework no longer returns partially decoded Bitmaps or provides a way to determine
+        // if a Bitmap is partially decoded, consider removing.
+        ExceptionCatchingInputStream exceptionStream =
+                ExceptionCatchingInputStream.obtain(bufferedStream);
+        // Use to read data.
+        // Ensures that we can always reset after reading an image header so that we can still attempt to decode the
+        // full image even when the header decode fails and/or overflows our read buffer. See #283.
+        MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);
         try {
-            stream.mark(MARK_POSITION);
+            exceptionStream.mark(MARK_POSITION);
             int orientation = 0;
             try {
-                orientation = new ImageHeaderParser(stream).getOrientation();
+                orientation = new ImageHeaderParser(exceptionStream).getOrientation();
             } catch (IOException e) {
                 if (Log.isLoggable(TAG, Log.WARN)) {
                     Log.w(TAG, "Cannot determine the image orientation from header", e);
                 }
             } finally {
                 try {
-                    stream.reset();
+                    exceptionStream.reset();
                 } catch (IOException e) {
                     if (Log.isLoggable(TAG, Log.WARN)) {
                         Log.w(TAG, "Cannot reset the input stream", e);
@@ -129,27 +141,21 @@ public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeigh
 
             options.inTempStorage = bytesForOptions;
 
-            final int[] inDimens = getDimensions(stream, options);
+            final int[] inDimens = getDimensions(invalidatingStream, bufferedStream, options);
             final int inWidth = inDimens[0];
             final int inHeight = inDimens[1];
 
             final int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
-            final int sampleSize;
-            if (degreesToRotate == 90 || degreesToRotate == 270) {
-                // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is
-                // decreased to near our target's height and the image height is decreased to near our target width.
-                sampleSize = getSampleSize(inHeight, inWidth, outWidth, outHeight);
-            } else {
-                sampleSize = getSampleSize(inWidth, inHeight, outWidth, outHeight);
-            }
+            final int sampleSize = getRoundedSampleSize(degreesToRotate, inWidth, inHeight, outWidth, outHeight);
 
             final Bitmap downsampled =
-                    downsampleWithSize(stream, options, pool, inWidth, inHeight, sampleSize, decodeFormat);
+                    downsampleWithSize(invalidatingStream, bufferedStream, options, pool, inWidth, inHeight, sampleSize,
+                            decodeFormat);
 
-            // BitmapDecoder swallows exceptions during decodes and in some cases when inBitmap is non null, may catch
+            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch
             // and log a stack trace but still return a non null bitmap. To avoid displaying partially decoded bitmaps,
             // we catch exceptions reading from the stream in our ExceptionCatchingInputStream and throw them here.
-            final Exception streamException = stream.getException();
+            final Exception streamException = exceptionStream.getException();
             if (streamException != null) {
                 throw new RuntimeException(streamException);
             }
@@ -167,22 +173,48 @@ public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeigh
         } finally {
             byteArrayPool.releaseBytes(bytesForOptions);
             byteArrayPool.releaseBytes(bytesForStream);
-            stream.release();
+            exceptionStream.release();
             releaseOptions(options);
         }
     }
 
-    protected Bitmap downsampleWithSize(InputStream is, BitmapFactory.Options options,
-            BitmapPool pool, int inWidth, int inHeight, int sampleSize, DecodeFormat decodeFormat) {
+    private int getRoundedSampleSize(int degreesToRotate, int inWidth, int inHeight, int outWidth, int outHeight) {
+        int targetHeight = outHeight == Target.SIZE_ORIGINAL ? inHeight : outHeight;
+        int targetWidth = outWidth == Target.SIZE_ORIGINAL ? inWidth : outWidth;
+
+        final int exactSampleSize;
+        if (degreesToRotate == 90 || degreesToRotate == 270) {
+            // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is
+            // decreased to near our target's height and the image height is decreased to near our target width.
+            exactSampleSize = getSampleSize(inHeight, inWidth, targetWidth, targetHeight);
+        } else {
+            exactSampleSize = getSampleSize(inWidth, inHeight, targetWidth, targetHeight);
+        }
+
+        // BitmapFactory only accepts powers of 2, so it will round down to the nearest power of two that is less than
+        // or equal to the sample size we provide. Because we need to estimate the final image width and height to
+        // re-use Bitmaps, we mirror BitmapFactory's calculation here. For bug, see issue #224. For algorithm see
+        // http://stackoverflow.com/a/17379704/800716.
+        final int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);
+
+        // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code than 0.
+        return Math.max(1, powerOfTwoSampleSize);
+    }
+
+    private Bitmap downsampleWithSize(MarkEnforcingInputStream is, RecyclableBufferedInputStream  bufferedStream,
+            BitmapFactory.Options options, BitmapPool pool, int inWidth, int inHeight, int sampleSize,
+            DecodeFormat decodeFormat) {
         // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
         Bitmap.Config config = getConfig(is, decodeFormat);
         options.inSampleSize = sampleSize;
         options.inPreferredConfig = config;
         if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT) && shouldUsePool(is)) {
+            int targetWidth = (int) Math.ceil(inWidth / (double) sampleSize);
+            int targetHeight = (int) Math.ceil(inHeight / (double) sampleSize);
             // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-            setInBitmap(options, pool.getDirty(inWidth, inHeight, config));
+            setInBitmap(options, pool.getDirty(targetWidth, targetHeight, config));
         }
-        return decodeStream(is, options);
+        return decodeStream(is, bufferedStream, options);
     }
 
     private static boolean shouldUsePool(InputStream is) {
@@ -215,7 +247,8 @@ private static boolean shouldUsePool(InputStream is) {
 
     private static Bitmap.Config getConfig(InputStream is, DecodeFormat format) {
         // Changing configs can cause skewing on 4.1, see issue #128.
-        if (format == DecodeFormat.ALWAYS_ARGB_8888 || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
+        if (format == DecodeFormat.ALWAYS_ARGB_8888 || format == DecodeFormat.PREFER_ARGB_8888
+                || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
             return Bitmap.Config.ARGB_8888;
         }
 
@@ -247,10 +280,10 @@ private static boolean shouldUsePool(InputStream is) {
      *
      * @see android.graphics.BitmapFactory.Options#inSampleSize
      *
-     * @param inWidth The width of the image to be downsampled.
-     * @param inHeight The height of the image to be downsampled.
-     * @param outWidth The width of the view/target the image will be displayed in.
-     * @param outHeight The height of the view/target the imag will be displayed in.
+     * @param inWidth The width in pixels of the image to be downsampled.
+     * @param inHeight The height in piexels of the image to be downsampled.
+     * @param outWidth The width in pixels of the view/target the image will be displayed in.
+     * @param outHeight The height in pixels of the view/target the imag will be displayed in.
      * @return An integer to pass in to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect,
      *          android.graphics.BitmapFactory.Options)}.
      */
@@ -265,15 +298,16 @@ private static boolean shouldUsePool(InputStream is) {
      *              android.graphics.BitmapFactory.Options)}.
      * @return an array containing the dimensions of the image in the form {width, height}.
      */
-    public int[] getDimensions(InputStream is, BitmapFactory.Options options) {
+    public int[] getDimensions(MarkEnforcingInputStream is, RecyclableBufferedInputStream bufferedStream,
+            BitmapFactory.Options options) {
         options.inJustDecodeBounds = true;
-        decodeStream(is, options);
+        decodeStream(is, bufferedStream, options);
         options.inJustDecodeBounds = false;
         return new int[] { options.outWidth, options.outHeight };
     }
 
-
-    private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options) {
+    private static Bitmap decodeStream(MarkEnforcingInputStream is, RecyclableBufferedInputStream bufferedStream,
+            BitmapFactory.Options options) {
          if (options.inJustDecodeBounds) {
              // This is large, but jpeg headers are not size bounded so we need something large enough to minimize
              // the possibility of not being able to fit enough of the header in the buffer to get the image size so
@@ -281,6 +315,11 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
              // original size each time we use up the buffer space without passing the mark so this is a maximum
              // bound on the buffer size, not a default. Most of the time we won't go past our pre-allocated 16kb.
              is.mark(MARK_POSITION);
+         } else {
+             // Once we've read the image header, we no longer need to allow the buffer to expand in size. To avoid
+             // unnecessary allocations reading image data, we fix the mark limit so that it is no larger than our
+             // current buffer size here. See issue #225.
+             bufferedStream.fixMarkLimit();
          }
 
         final Bitmap result = BitmapFactory.decodeStream(is, null, options);
@@ -335,6 +374,9 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
         decodeBitmapOptions.inSampleSize = 1;
         decodeBitmapOptions.inPreferredConfig = null;
         decodeBitmapOptions.inJustDecodeBounds = false;
+        decodeBitmapOptions.outWidth = 0;
+        decodeBitmapOptions.outHeight = 0;
+        decodeBitmapOptions.outMimeType = null;
 
         if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT)  {
             decodeBitmapOptions.inBitmap = null;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDataLoadProvider.java
index cbab42753..af27bc609 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDataLoadProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDataLoadProvider.java
@@ -4,13 +4,13 @@
 import android.os.ParcelFileDescriptor;
 
 import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.NullEncoder;
 import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
+import com.bumptech.glide.provider.DataLoadProvider;
 
 import java.io.File;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java
index 3eb389340..f6f2bfbe7 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java
@@ -3,11 +3,12 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.DecodeFormat;
 
 import java.io.IOException;
 
@@ -42,11 +43,7 @@ public FileDescriptorBitmapDecoder(VideoBitmapDecoder bitmapDecoder, BitmapPool
     @Override
     public Resource<Bitmap> decode(ParcelFileDescriptor source, int width, int height) throws IOException {
         Bitmap bitmap = bitmapDecoder.decode(source, bitmapPool, width, height, decodeFormat);
-        if (bitmap == null) {
-            return null;
-        } else {
-            return new BitmapResource(bitmap, bitmapPool);
-        }
+        return BitmapResource.obtain(bitmap, bitmapPool);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawable.java
index e2589131b..27e05185d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawable.java
@@ -29,6 +29,10 @@ public GlideBitmapDrawable(Resources res, Bitmap bitmap) {
     }
 
     GlideBitmapDrawable(Resources res, BitmapState state) {
+        if (state == null) {
+            throw new NullPointerException("BitmapState must not be null");
+        }
+
         this.state = state;
         final int targetDensity;
         if (res != null) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
index 593bbb422..217870e0d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
@@ -1,5 +1,11 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.GIF;
+import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.JPEG;
+import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG;
+import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG_A;
+import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.UNKNOWN;
+
 import android.util.Log;
 
 import java.io.IOException;
@@ -8,12 +14,6 @@
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.GIF;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.JPEG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG_A;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.UNKNOWN;
-
 /**
  * A class for parsing the exif orientation and other data from an image header.
  */
@@ -84,14 +84,13 @@ public boolean hasAlpha() throws IOException {
     }
 
     public ImageType getType() throws IOException {
-        int firstByte = streamReader.getUInt8();
+        int firstTwoBytes = streamReader.getUInt16();
 
         // JPEG.
-        if (firstByte == EXIF_MAGIC_NUMBER >> 8) {
+        if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
             return JPEG;
         }
 
-        final int firstTwoBytes = firstByte << 8 & 0xFF00 | streamReader.getUInt8() & 0xFF;
         final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | streamReader.getUInt16() & 0xFFFF;
         // PNG.
         if (firstFourBytes == PNG_HEADER) {
@@ -125,7 +124,7 @@ public int getOrientation() throws IOException {
         } else {
             byte[] exifData = getExifSegment();
             boolean hasJpegExifPreamble = exifData != null
-                    && exifData.length >= JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length;
+                    && exifData.length > JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length;
 
             if (hasJpegExifPreamble) {
                 for (int i = 0; i < JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length; i++) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java
index 5edf2ceb2..58cb60364 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java
@@ -3,8 +3,9 @@
 import android.graphics.Bitmap;
 import android.os.ParcelFileDescriptor;
 import android.util.Log;
-import com.bumptech.glide.load.engine.Resource;
+
 import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
 
 import java.io.IOException;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoDataLoadProvider.java
index b02e46c13..002a48f92 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoDataLoadProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoDataLoadProvider.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.os.ParcelFileDescriptor;
+
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index b08115262..8699022b5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -17,6 +17,8 @@
  *  limitations under the License.
  */
 
+import android.util.Log;
+
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -36,32 +38,33 @@
  * </pre>
  */
 public class RecyclableBufferedInputStream extends FilterInputStream {
+    private static final String TAG = "BufferedIs";
 
     /**
      * The buffer containing the current bytes read from the target InputStream.
      */
-    protected volatile byte[] buf;
+    private volatile byte[] buf;
 
     /**
      * The total number of bytes inside the byte array {@code buf}.
      */
-    protected int count;
+    private int count;
 
     /**
      * The current limit, which when passed, invalidates the current mark.
      */
-    protected int marklimit;
+    private int marklimit;
 
     /**
      * The currently marked position. -1 indicates no mark has been set or the
      * mark has been invalidated.
      */
-    protected int markpos = -1;
+    private int markpos = -1;
 
     /**
      * The current position within the byte array {@code buf}.
      */
-    protected int pos;
+    private int pos;
 
     public RecyclableBufferedInputStream(InputStream in, byte[] buffer) {
         super(in);
@@ -94,6 +97,17 @@ private static IOException streamClosed() throws IOException {
         throw new IOException("BufferedInputStream is closed");
     }
 
+    /**
+     * Reduces the mark limit to match the current buffer length to prevent the buffer from
+     * continuing to increase in size.
+     *
+     * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size
+     * to increase.
+     */
+    public synchronized void fixMarkLimit() {
+        marklimit = buf.length;
+    }
+
     /**
      * Closes this stream. The source stream is closed and any resources
      * associated with it are released.
@@ -134,6 +148,9 @@ private int fillbuf(InputStream localIn, byte[] localBuf)
             if (newLength > marklimit) {
                 newLength = marklimit;
             }
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "allocate buffer of length: " + newLength);
+            }
             byte[] newbuf = new byte[newLength];
             System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
             // Reassign buf, which will invalidate any local references
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDataLoadProvider.java
index ae89ec9f5..e05e48459 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDataLoadProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDataLoadProvider.java
@@ -3,13 +3,13 @@
 import android.graphics.Bitmap;
 
 import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.model.StreamEncoder;
 import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
+import com.bumptech.glide.provider.DataLoadProvider;
 
 import java.io.File;
 import java.io.InputStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index b9d8a8dff..407b8cb63 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -2,10 +2,11 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
 import java.io.InputStream;
@@ -47,11 +48,7 @@ public StreamBitmapDecoder(Downsampler downsampler, BitmapPool bitmapPool, Decod
     @Override
     public Resource<Bitmap> decode(InputStream source, int width, int height) {
         Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);
-        if (bitmap == null) {
-            return null;
-        } else {
-            return new BitmapResource(bitmap, bitmapPool);
-        }
+        return BitmapResource.obtain(bitmap, bitmapPool);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 2f3a3ef10..49d074988 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -9,6 +9,7 @@
 import android.media.ExifInterface;
 import android.os.Build;
 import android.util.Log;
+
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
 /**
@@ -30,8 +31,8 @@ private TransformationUtils() {
      * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
      *                 into.
      * @param toCrop The Bitmap to resize.
-     * @param width The width of the final Bitmap.
-     * @param height The height of the final Bitmap.
+     * @param width The width in pixels of the final Bitmap.
+     * @param height The height in pixels of the final Bitmap.
      * @return The resized Bitmap (will be recycled if recycled is not null).
      */
     public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
@@ -58,8 +59,7 @@ public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int h
         if (recycled != null) {
             result = recycled;
         } else {
-            result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null
-                        ? Bitmap.Config.ARGB_8888 : toCrop.getConfig());
+            result = Bitmap.createBitmap(width, height, getSafeConfig(toCrop));
         }
 
         // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
@@ -77,8 +77,8 @@ public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int h
      *
      * @param toFit The Bitmap to shrink.
      * @param pool The BitmapPool to try to reuse a bitmap from.
-     * @param width The width the final image will fit within.
-     * @param height The height the final image will fit within.
+     * @param width The width in pixels the final image will fit within.
+     * @param height The height in pixels the final image will fit within.
      * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
      * given dimensions and toFit fits within the given dimensions
      */
@@ -106,7 +106,7 @@ public static Bitmap fitCenter(Bitmap toFit, BitmapPool pool, int width, int hei
             return toFit;
         }
 
-        Bitmap.Config config = toFit.getConfig() != null ? toFit.getConfig() : Bitmap.Config.ARGB_8888;
+        Bitmap.Config config = getSafeConfig(toFit);
         Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
         if (toReuse == null) {
             toReuse = Bitmap.createBitmap(targetWidth, targetHeight, config);
@@ -149,22 +149,18 @@ public static void setAlpha(Bitmap toTransform, Bitmap outBitmap) {
      * Returns a matrix with rotation set based on Exif orientation tag.
      * If the orientation is undefined or 0 null is returned.
      *
+     * @deprecated No longer used by Glide, scheduled to be removed in Glide 4.0
      * @param pathToOriginal Path to original image file that may have exif data.
      * @return  A rotation in degrees based on exif orientation
      */
     @TargetApi(Build.VERSION_CODES.ECLAIR)
+    @Deprecated
     public static int getOrientation(String pathToOriginal) {
         int degreesToRotate = 0;
         try {
             ExifInterface exif = new ExifInterface(pathToOriginal);
             int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
-            if (orientation == ExifInterface.ORIENTATION_ROTATE_90) {
-                degreesToRotate = 90;
-            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180) {
-                degreesToRotate = 180;
-            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270) {
-                degreesToRotate = 270;
-            }
+            return getExifOrientationDegrees(orientation);
         } catch (Exception e) {
             if (Log.isLoggable(TAG, Log.ERROR)) {
                 Log.e(TAG, "Unable to get orientation for image with path=" + pathToOriginal, e);
@@ -177,10 +173,12 @@ public static int getOrientation(String pathToOriginal) {
      * This is an expensive operation that copies the image in place with the pixels rotated.
      * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
      *
+     * @deprecated No longer used by Glide, scheduled to be removed in Glide 4.0
      * @param pathToOriginal Path to original image file that may have exif data.
      * @param imageToOrient Image Bitmap to orient.
      * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
      */
+    @Deprecated
     public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient) {
         int degreesToRotate = getOrientation(pathToOriginal);
         return rotateImage(imageToOrient, degreesToRotate);
@@ -256,6 +254,39 @@ public static int getExifOrientationDegrees(int exifOrientation) {
      */
     public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifOrientation) {
         final Matrix matrix = new Matrix();
+        initializeMatrixForRotation(exifOrientation, matrix);
+        if (matrix.isIdentity()) {
+            return toOrient;
+        }
+
+        // From Bitmap.createBitmap.
+        final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
+        matrix.mapRect(newRect);
+
+        final int newWidth = Math.round(newRect.width());
+        final int newHeight = Math.round(newRect.height());
+
+        Bitmap.Config config = getSafeConfig(toOrient);
+        Bitmap result = pool.get(newWidth, newHeight, config);
+        if (result == null) {
+            result = Bitmap.createBitmap(newWidth, newHeight, config);
+        }
+
+        matrix.postTranslate(-newRect.left, -newRect.top);
+
+        final Canvas canvas = new Canvas(result);
+        final Paint paint = new Paint(PAINT_FLAGS);
+        canvas.drawBitmap(toOrient, matrix, paint);
+
+        return result;
+    }
+
+    private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
+      return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
+    }
+
+    // Visible for testing.
+    static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
         switch (exifOrientation) {
             case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
                 matrix.setScale(-1, 1);
@@ -281,29 +312,8 @@ public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifO
             case ExifInterface.ORIENTATION_ROTATE_270:
                 matrix.setRotate(-90);
                 break;
-            // case ExifInterface.ORIENTATION_NORMAL
             default:
-                return toOrient;
+                // Do nothing.
         }
-
-        // From Bitmap.createBitmap.
-        final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
-        matrix.mapRect(newRect);
-
-        final int newWidth = Math.round(newRect.width());
-        final int newHeight = Math.round(newRect.height());
-
-        Bitmap result = pool.get(newWidth, newHeight, toOrient.getConfig());
-        if (result == null) {
-            result = Bitmap.createBitmap(newWidth, newHeight, toOrient.getConfig());
-        }
-
-        matrix.postTranslate(-newRect.left, -newRect.top);
-
-        final Canvas canvas = new Canvas(result);
-        final Paint paint = new Paint(PAINT_FLAGS);
-        canvas.drawBitmap(toOrient, matrix, paint);
-
-        return result;
     }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index 159904624..712dc2fbc 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -3,8 +3,9 @@
 import android.graphics.Bitmap;
 import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
 import java.io.IOException;
 
@@ -16,14 +17,25 @@
  */
 public class VideoBitmapDecoder implements BitmapDecoder<ParcelFileDescriptor> {
     private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =  new MediaMetadataRetrieverFactory();
+    private static final int NO_FRAME = -1;
     private MediaMetadataRetrieverFactory factory;
+    private int frame;
 
     public VideoBitmapDecoder() {
-        this(DEFAULT_FACTORY);
+        this(DEFAULT_FACTORY, NO_FRAME);
+    }
+
+    public VideoBitmapDecoder(int frame) {
+      this(DEFAULT_FACTORY, checkValidFrame(frame));
     }
 
     VideoBitmapDecoder(MediaMetadataRetrieverFactory factory) {
+      this(factory, NO_FRAME);
+    }
+
+    VideoBitmapDecoder(MediaMetadataRetrieverFactory factory, int frame) {
         this.factory = factory;
+        this.frame = frame;
     }
 
     @Override
@@ -32,7 +44,12 @@ public Bitmap decode(ParcelFileDescriptor resource, BitmapPool bitmapPool, int o
             throws IOException {
         MediaMetadataRetriever mediaMetadataRetriever = factory.build();
         mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
-        Bitmap result = mediaMetadataRetriever.getFrameAtTime();
+        Bitmap result;
+        if (frame >= 0) {
+          result = mediaMetadataRetriever.getFrameAtTime(frame);
+        } else {
+          result = mediaMetadataRetriever.getFrameAtTime();
+        }
         mediaMetadataRetriever.release();
         resource.close();
         return result;
@@ -49,4 +66,11 @@ public MediaMetadataRetriever build() {
             return new MediaMetadataRetriever();
         }
     }
+
+    private static int checkValidFrame(int frame) {
+      if (frame < 0) {
+        throw new IllegalArgumentException("Requested frame must be non-negative");
+      }
+      return frame;
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
index eb29217d8..a6368d26b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
@@ -9,6 +9,9 @@
     private final byte[] bytes;
 
     public BytesResource(byte[] bytes) {
+        if (bytes == null) {
+            throw new NullPointerException("Bytes must not be null");
+        }
         this.bytes = bytes;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index b3efc6219..a0730a45e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -15,21 +15,20 @@
  */
 public abstract class DrawableResource<T extends Drawable> implements Resource<T> {
     protected final T drawable;
-    private boolean returnedOriginalDrawable;
 
     public DrawableResource(T drawable) {
+        if (drawable == null) {
+            throw new NullPointerException("Drawable must not be null!");
+        }
         this.drawable = drawable;
     }
 
     @SuppressWarnings("unchecked")
-    // drawables should always return a copy of the same class
     @Override
     public final T get() {
-        if (!returnedOriginalDrawable) {
-            returnedOriginalDrawable = true;
-            return drawable;
-        } else {
-            return (T) drawable.getConstantState().newDrawable();
-        }
+        // Drawables contain temporary state related to how they're being displayed (alpha, color filter etc), so
+        // return a new copy each time. If we ever return the original drawable, it's temporary state may be changed
+        // and subsequent copies may end up with that temporary state. See #276.
+        return (T) drawable.getConstantState().newDrawable();
     }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/StreamFileDataLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/file/StreamFileDataLoadProvider.java
index c31e3a4a5..13df0a204 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/StreamFileDataLoadProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/StreamFileDataLoadProvider.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.load.resource.file;
 
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.model.StreamEncoder;
 import com.bumptech.glide.load.resource.NullResourceEncoder;
+import com.bumptech.glide.provider.DataLoadProvider;
 
 import java.io.File;
 import java.io.InputStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index 32008d3e8..de52039fb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -2,6 +2,7 @@
 
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
@@ -14,6 +15,13 @@ public GifBitmapProvider(BitmapPool bitmapPool) {
 
     @Override
     public Bitmap obtain(int width, int height, Bitmap.Config config) {
-        return bitmapPool.get(width, height, config);
+        return bitmapPool.getDirty(width, height, config);
+    }
+
+    @Override
+    public void release(Bitmap bitmap) {
+        if (!bitmapPool.put(bitmap)) {
+            bitmap.recycle();
+        }
     }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 2d740c217..b70794f5d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -8,8 +8,10 @@
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.view.Gravity;
 
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
@@ -20,14 +22,13 @@
 /**
  * An animated {@link android.graphics.drawable.Drawable} that plays the frames of an animated GIF.
  */
-public class GifDrawable extends GlideDrawable implements GifFrameManager.FrameCallback {
-    private final Paint paint = new Paint();
-    private final GifFrameManager frameManager;
+public class GifDrawable extends GlideDrawable implements GifFrameLoader.FrameCallback {
+    private final Paint paint;
+    private final Rect destRect = new Rect();
     private final GifState state;
     private final GifDecoder decoder;
+    private final GifFrameLoader frameLoader;
 
-    /** The current frame to draw, or null if no frame has been loaded yet. */
-    private Bitmap currentFrame;
     /** True if the drawable is currently animating. */
     private boolean isRunning;
     /** True if the drawable should animate while visible. */
@@ -45,6 +46,8 @@
     /** The number of times to loop through the gif animation. */
     private int maxLoopCount = LOOP_FOREVER;
 
+    private boolean applyGravity;
+
     /**
      * Constructor for GifDrawable.
      *
@@ -60,31 +63,35 @@
      *                         {@link com.bumptech.glide.request.target.Target} this drawable is being loaded into).
      * @param targetFrameHeight The desired height of the frames displayed by this drawable (the height of the view or
      *                          {@link com.bumptech.glide.request.target.Target} this drawable is being loaded into).
-     * @param id An id that uniquely identifies this particular gif.
      * @param gifHeader The header data for this gif.
      * @param data The full bytes of the gif.
      * @param firstFrame The decoded and transformed first frame of this gif.
      */
     public GifDrawable(Context context, GifDecoder.BitmapProvider bitmapProvider, BitmapPool bitmapPool,
-            Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight, String id,
+            Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
             GifHeader gifHeader, byte[] data, Bitmap firstFrame) {
-        this(new GifState(id, gifHeader, data, context, frameTransformation, targetFrameWidth, targetFrameHeight,
+        this(new GifState(gifHeader, data, context, frameTransformation, targetFrameWidth, targetFrameHeight,
                 bitmapProvider, bitmapPool, firstFrame));
     }
 
     GifDrawable(GifState state) {
+        if (state == null) {
+            throw new NullPointerException("GifState must not be null");
+        }
+
         this.state = state;
         this.decoder = new GifDecoder(state.bitmapProvider);
-        decoder.setData(state.id, state.gifHeader, state.data);
-        frameManager = new GifFrameManager(state.context, decoder, state.frameTransformation, state.targetWidth,
-                state.targetHeight, state.firstFrame.getWidth(), state.firstFrame.getHeight());
+        this.paint = new Paint();
+        decoder.setData(state.gifHeader, state.data);
+        frameLoader = new GifFrameLoader(state.context, this, decoder, state.targetWidth, state.targetHeight);
     }
 
     // Visible for testing.
-    GifDrawable(GifDecoder decoder, GifFrameManager frameManager, Bitmap firstFrame, BitmapPool bitmapPool) {
+    GifDrawable(GifDecoder decoder, GifFrameLoader frameLoader, Bitmap firstFrame, BitmapPool bitmapPool, Paint paint) {
         this.decoder = decoder;
-        this.frameManager = frameManager;
+        this.frameLoader = frameLoader;
         this.state = new GifState(null);
+        this.paint = paint;
         state.bitmapPool = bitmapPool;
         state.firstFrame = firstFrame;
     }
@@ -94,8 +101,15 @@ public Bitmap getFirstFrame() {
     }
 
     public void setFrameTransformation(Transformation<Bitmap> frameTransformation, Bitmap firstFrame) {
+        if (firstFrame == null) {
+            throw new NullPointerException("The first frame of the GIF must not be null");
+        }
+        if (frameTransformation == null) {
+            throw new NullPointerException("The frame transformation must not be null");
+        }
         state.frameTransformation = frameTransformation;
         state.firstFrame = firstFrame;
+        frameLoader.setFrameTransformation(frameTransformation);
     }
 
     public GifDecoder getDecoder() {
@@ -131,6 +145,22 @@ public void start() {
     public void stop() {
         isStarted = false;
         stopRunning();
+
+        // On APIs > honeycomb we know our drawable is not being displayed anymore when it's callback is cleared and so
+        // we can use the absence of a callback as an indication that it's ok to clear our temporary data. Prior to
+        // honeycomb we can't tell if our callback is null and instead eagerly reset to avoid holding on to resources we
+        // no longer need.
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+            reset();
+        }
+    }
+
+    /**
+     * Clears temporary data and resets the drawable back to the first frame.
+     */
+    private void reset() {
+        frameLoader.clear();
+        invalidateSelf();
     }
 
     private void startRunning() {
@@ -139,13 +169,14 @@ private void startRunning() {
             invalidateSelf();
         }  else if (!isRunning) {
             isRunning = true;
-            frameManager.getNextFrame(this);
+            frameLoader.start();
             invalidateSelf();
         }
     }
 
     private void stopRunning() {
         isRunning = false;
+        frameLoader.stop();
     }
 
     @Override
@@ -179,10 +210,26 @@ void setIsRunning(boolean isRunning) {
         this.isRunning = isRunning;
     }
 
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        applyGravity = true;
+    }
+
     @Override
     public void draw(Canvas canvas) {
+        if (isRecycled) {
+            return;
+        }
+
+        if (applyGravity) {
+            Gravity.apply(GifState.GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(), destRect);
+            applyGravity = false;
+        }
+
+        Bitmap currentFrame = frameLoader.getCurrentFrame();
         Bitmap toDraw = currentFrame != null ? currentFrame : state.firstFrame;
-        canvas.drawBitmap(toDraw, 0, 0, paint);
+        canvas.drawBitmap(toDraw, null, destRect, paint);
     }
 
     @Override
@@ -197,24 +244,20 @@ public void setColorFilter(ColorFilter colorFilter) {
 
     @Override
     public int getOpacity() {
-        return decoder.isTransparent() ? PixelFormat.TRANSPARENT : PixelFormat.OPAQUE;
+        // We can't tell, so default to transparent to be safe.
+        return PixelFormat.TRANSPARENT;
     }
 
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     @Override
-    public void onFrameRead(Bitmap frame, int frameIndex) {
-        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT && getCallback() == null) {
+    public void onFrameReady(int frameIndex) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && getCallback() == null) {
             stop();
-            return;
-        }
-        if (!isRunning) {
+            reset();
             return;
         }
 
-        if (frame != null) {
-            currentFrame = frame;
-            invalidateSelf();
-        }
+        invalidateSelf();
 
         if (frameIndex == decoder.getFrameCount() - 1) {
             loopCount++;
@@ -222,8 +265,6 @@ public void onFrameRead(Bitmap frame, int frameIndex) {
 
         if (maxLoopCount != LOOP_FOREVER && loopCount >= maxLoopCount) {
             stop();
-        } else {
-            frameManager.getNextFrame(this);
         }
     }
 
@@ -238,7 +279,8 @@ public ConstantState getConstantState() {
     public void recycle() {
         isRecycled = true;
         state.bitmapPool.put(state.firstFrame);
-        frameManager.clear();
+        frameLoader.clear();
+        frameLoader.stop();
     }
 
     // For testing.
@@ -266,7 +308,7 @@ public void setLoopCount(int loopCount) {
     }
 
     static class GifState extends ConstantState {
-        String id;
+        private static final int GRAVITY = Gravity.FILL;
         GifHeader gifHeader;
         byte[] data;
         Context context;
@@ -277,10 +319,12 @@ public void setLoopCount(int loopCount) {
         BitmapPool bitmapPool;
         Bitmap firstFrame;
 
-        public GifState(String id, GifHeader header, byte[] data, Context context,
+        public GifState(GifHeader header, byte[] data, Context context,
                 Transformation<Bitmap> frameTransformation, int targetWidth, int targetHeight,
                 GifDecoder.BitmapProvider provider, BitmapPool bitmapPool, Bitmap firstFrame) {
-            this.id = id;
+            if (firstFrame == null) {
+                throw new NullPointerException("The first frame of the GIF must not be null");
+            }
             gifHeader = header;
             this.data = data;
             this.bitmapPool = bitmapPool;
@@ -294,7 +338,6 @@ public GifState(String id, GifHeader header, byte[] data, Context context,
 
         public GifState(GifState original) {
             if (original != null) {
-                id = original.id;
                 gifHeader = original.gifHeader;
                 data = original.data;
                 context = original.context;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java
index 3e0fe3c12..971847d3b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java
@@ -2,14 +2,13 @@
 
 import android.content.Context;
 
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.model.StreamEncoder;
 import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
+import com.bumptech.glide.provider.DataLoadProvider;
 
 import java.io.File;
 import java.io.InputStream;
@@ -24,8 +23,8 @@
     private final StreamEncoder sourceEncoder;
     private final FileToStreamDecoder<GifDrawable> cacheDecoder;
 
-    public GifDrawableLoadProvider(Context context, BitmapPool bitmapPool, DecodeFormat decodeFormat) {
-        decoder = new GifResourceDecoder(context, bitmapPool, decodeFormat);
+    public GifDrawableLoadProvider(Context context, BitmapPool bitmapPool) {
+        decoder = new GifResourceDecoder(context, bitmapPool);
         cacheDecoder = new FileToStreamDecoder<GifDrawable>(decoder);
         encoder = new GifResourceEncoder(bitmapPool);
         sourceEncoder = new StreamEncoder();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 9261e0fc5..2e17d2902 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
new file mode 100644
index 000000000..5b8ae83de
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -0,0 +1,219 @@
+package com.bumptech.glide.load.resource.gif;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.SystemClock;
+
+import com.bumptech.glide.GenericRequestBuilder;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.NullEncoder;
+import com.bumptech.glide.request.animation.GlideAnimation;
+import com.bumptech.glide.request.target.SimpleTarget;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.util.UUID;
+
+class GifFrameLoader {
+
+    private final FrameCallback callback;
+    private final GifDecoder gifDecoder;
+    private final Handler handler;
+
+    private boolean isRunning = false;
+    private boolean isLoadPending = false;
+    private GenericRequestBuilder<GifDecoder, GifDecoder, Bitmap, Bitmap> requestBuilder;
+    private DelayTarget current;
+    private boolean isCleared;
+
+    public interface FrameCallback {
+        void onFrameReady(int index);
+    }
+
+    public GifFrameLoader(Context context, FrameCallback callback, GifDecoder gifDecoder, int width, int height) {
+        this(callback, gifDecoder, null,
+                getRequestBuilder(context, gifDecoder, width, height, Glide.get(context).getBitmapPool()));
+    }
+
+    GifFrameLoader(FrameCallback callback, GifDecoder gifDecoder, Handler handler,
+            GenericRequestBuilder<GifDecoder, GifDecoder, Bitmap, Bitmap>  requestBuilder) {
+        if (handler == null) {
+            handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
+        }
+        this.callback = callback;
+        this.gifDecoder = gifDecoder;
+        this.handler = handler;
+        this.requestBuilder = requestBuilder;
+    }
+
+    @SuppressWarnings("unchecked")
+    public void setFrameTransformation(Transformation<Bitmap> transformation) {
+        if (transformation == null) {
+            throw new NullPointerException("Transformation must not be null");
+        }
+        requestBuilder = requestBuilder.transform(transformation);
+    }
+
+    public void start() {
+        if (isRunning) {
+            return;
+        }
+        isRunning = true;
+        isCleared = false;
+
+        loadNextFrame();
+    }
+
+    public void stop() {
+        isRunning = false;
+    }
+
+    public void clear() {
+        stop();
+        if (current != null) {
+            Glide.clear(current);
+            current = null;
+        }
+        isCleared = true;
+        // test.
+    }
+
+    public Bitmap getCurrentFrame() {
+        return current != null ? current.getResource() : null;
+    }
+
+    private void loadNextFrame() {
+        if (!isRunning || isLoadPending) {
+            return;
+        }
+        isLoadPending = true;
+
+        gifDecoder.advance();
+        long targetTime = SystemClock.uptimeMillis() + gifDecoder.getNextDelay();
+        DelayTarget next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
+        requestBuilder
+                .signature(new FrameSignature())
+                .into(next);
+    }
+
+    // Visible for testing.
+    void onFrameReady(DelayTarget delayTarget) {
+        if (isCleared) {
+            handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, delayTarget).sendToTarget();
+            return;
+        }
+
+        DelayTarget previous = current;
+        current = delayTarget;
+        callback.onFrameReady(delayTarget.index);
+
+        if (previous != null) {
+            handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, previous).sendToTarget();
+        }
+
+        isLoadPending = false;
+        loadNextFrame();
+    }
+
+    private class FrameLoaderCallback implements Handler.Callback {
+        public static final int MSG_DELAY = 1;
+        public static final int MSG_CLEAR = 2;
+
+        @Override
+        public boolean handleMessage(Message msg) {
+            if (msg.what == MSG_DELAY) {
+                GifFrameLoader.DelayTarget target = (DelayTarget) msg.obj;
+                onFrameReady(target);
+                return true;
+            } else if (msg.what == MSG_CLEAR) {
+                GifFrameLoader.DelayTarget target = (DelayTarget) msg.obj;
+                Glide.clear(target);
+            }
+            return false;
+        }
+    }
+
+    // Visible for testing.
+    static class DelayTarget extends SimpleTarget<Bitmap> {
+        private final Handler handler;
+        private final int index;
+        private final long targetTime;
+        private Bitmap resource;
+
+        public DelayTarget(Handler handler, int index, long targetTime) {
+            this.handler = handler;
+            this.index = index;
+            this.targetTime = targetTime;
+        }
+
+        public Bitmap getResource() {
+            return resource;
+        }
+
+        @Override
+        public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {
+            this.resource = resource;
+            Message msg = handler.obtainMessage(FrameLoaderCallback.MSG_DELAY, this);
+            handler.sendMessageAtTime(msg, targetTime);
+        }
+    }
+
+    private static GenericRequestBuilder<GifDecoder, GifDecoder, Bitmap, Bitmap> getRequestBuilder(Context context,
+            GifDecoder gifDecoder, int width, int height, BitmapPool bitmapPool) {
+        GifFrameResourceDecoder frameResourceDecoder = new GifFrameResourceDecoder(bitmapPool);
+        GifFrameModelLoader frameLoader = new GifFrameModelLoader();
+        Encoder<GifDecoder> sourceEncoder = NullEncoder.get();
+        return Glide.with(context)
+                .using(frameLoader, GifDecoder.class)
+                .load(gifDecoder)
+                .as(Bitmap.class)
+                .sourceEncoder(sourceEncoder)
+                .decoder(frameResourceDecoder)
+                .skipMemoryCache(true)
+                .diskCacheStrategy(DiskCacheStrategy.NONE)
+                .override(width, height);
+
+    }
+
+    // Visible for testing.
+    static class FrameSignature implements Key {
+        private final UUID uuid;
+
+        public FrameSignature() {
+            this(UUID.randomUUID());
+        }
+
+        // VisibleForTesting.
+        FrameSignature(UUID uuid) {
+            this.uuid = uuid;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof FrameSignature) {
+                FrameSignature other = (FrameSignature) o;
+                return other.uuid.equals(uuid);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            return uuid.hashCode();
+        }
+
+        @Override
+        public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
+            throw new UnsupportedOperationException("Not implemented");
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java
deleted file mode 100644
index 773203b9a..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java
+++ /dev/null
@@ -1,170 +0,0 @@
-package com.bumptech.glide.load.resource.gif;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.SystemClock;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.load.Encoder;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.ResourceEncoder;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
-import com.bumptech.glide.load.resource.NullDecoder;
-import com.bumptech.glide.load.resource.NullEncoder;
-import com.bumptech.glide.load.resource.NullResourceEncoder;
-import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
-import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
-import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
-import com.bumptech.glide.request.animation.GlideAnimation;
-import com.bumptech.glide.request.target.SimpleTarget;
-
-import java.io.File;
-
-class GifFrameManager {
-    /** 60fps is {@value #MIN_FRAME_DELAY}ms per frame. */
-    private static final long MIN_FRAME_DELAY = 1000 / 60;
-    private final MemorySizeCalculator calculator;
-    private final GifFrameModelLoader frameLoader;
-    private final GifFrameResourceDecoder frameResourceDecoder;
-    private final ResourceDecoder<File, Bitmap> cacheDecoder;
-    private final GifDecoder decoder;
-    private final Handler mainHandler;
-    private final ResourceEncoder<Bitmap> encoder;
-    private final Context context;
-    private final Encoder<GifDecoder> sourceEncoder;
-    private final Transformation<Bitmap>[] transformation;
-    private final int targetWidth;
-    private final int targetHeight;
-    private final int totalFrameSize;
-    private DelayTarget current;
-    private DelayTarget next;
-
-    public interface FrameCallback {
-        void onFrameRead(Bitmap frame, int index);
-    }
-
-    public GifFrameManager(Context context, GifDecoder decoder, Transformation<Bitmap> transformation, int targetWidth,
-            int targetHeight, int frameWidth, int frameHeight) {
-        this(context, Glide.get(context).getBitmapPool(), decoder, new Handler(Looper.getMainLooper()), transformation,
-                targetWidth, targetHeight, frameWidth, frameHeight);
-    }
-
-    @SuppressWarnings("unchecked")
-    public GifFrameManager(Context context, BitmapPool bitmapPool, GifDecoder decoder, Handler mainHandler,
-            Transformation<Bitmap> transformation, int targetWidth, int targetHeight, int frameWidth, int frameHeight) {
-        if (transformation == null) {
-            throw new NullPointerException("Transformation must not be null");
-        }
-
-        this.context = context;
-        this.frameResourceDecoder = new GifFrameResourceDecoder(bitmapPool);
-        this.decoder = decoder;
-        this.mainHandler = mainHandler;
-        this.transformation = new Transformation[] {transformation};
-        this.targetWidth = targetWidth;
-        this.targetHeight = targetHeight;
-        this.totalFrameSize = frameWidth * frameHeight * (decoder.isTransparent() ? 4 : 2);
-
-        this.calculator = new MemorySizeCalculator(context);
-        this.frameLoader = new GifFrameModelLoader();
-        this.sourceEncoder = NullEncoder.get();
-
-        if (!decoder.isTransparent()) {
-            // For non transparent gifs, we can beat the performance of our gif decoder for each frame by decoding jpegs
-            // from disk.
-            this.cacheDecoder = new FileToStreamDecoder<Bitmap>(new StreamBitmapDecoder(context));
-            this.encoder = new BitmapEncoder();
-        } else {
-            // For transparent gifs, we would have to encode as pngs which is actually slower than our gif decoder so we
-            // avoid writing frames to the disk cache entirely.
-            this.cacheDecoder = NullDecoder.get();
-            this.encoder = NullResourceEncoder.get();
-        }
-    }
-
-    Transformation<Bitmap> getTransformation() {
-        return transformation[0];
-    }
-
-    public void getNextFrame(FrameCallback cb) {
-        decoder.advance();
-
-        /**
-         * Note - Using the disk cache can potentially cause frames to be decoded incorrectly because the decoder is
-         * sequential. If earlier frames are evicted for some reason, later ones may then not be decoded correctly.
-         */
-
-        // We don't want to blow out the entire memory cache with frames of gifs, so try to set some
-        // maximum size beyond which we will always just decode one frame at a time.
-        boolean skipCache = totalFrameSize > calculator.getMemoryCacheSize() / 2;
-        // We can decode non transparent (cached as jpegs) frames more quickly from cache, but transparent
-        // (cached as png) frames more quickly from the gif data.
-        boolean skipDiskCache = decoder.isTransparent();
-
-        long targetTime = SystemClock.uptimeMillis() + Math.max(MIN_FRAME_DELAY, decoder.getNextDelay());
-        next = new DelayTarget(cb, targetTime);
-        next.setFrameIndex(decoder.getCurrentFrameIndex());
-
-        Glide.with(context)
-                .using(frameLoader, GifDecoder.class)
-                .load(decoder)
-                .as(Bitmap.class)
-                .sourceEncoder(sourceEncoder)
-                .decoder(frameResourceDecoder)
-                .cacheDecoder(cacheDecoder)
-                .encoder(encoder)
-                .transform(transformation)
-                .skipMemoryCache(skipCache)
-                .diskCacheStrategy(skipDiskCache ? DiskCacheStrategy.NONE : DiskCacheStrategy.RESULT)
-                .into(next);
-    }
-
-    public void clear() {
-        if (current != null) {
-            mainHandler.removeCallbacks(current);
-            Glide.clear(current);
-        }
-        if (next != null) {
-            mainHandler.removeCallbacks(next);
-            Glide.clear(next);
-        }
-    }
-
-    class DelayTarget extends SimpleTarget<Bitmap> implements Runnable {
-        private final FrameCallback cb;
-        private final long targetTime;
-        private Bitmap resource;
-        private int index;
-
-        public DelayTarget(FrameCallback cb, long targetTime) {
-            super(targetWidth, targetHeight);
-            this.cb = cb;
-            this.targetTime = targetTime;
-        }
-
-        public void setFrameIndex(int index) {
-            this.index = index;
-        }
-
-        @Override
-        public void onResourceReady(final Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {
-            this.resource = resource;
-            mainHandler.postAtTime(this, targetTime);
-        }
-
-        @Override
-        public void run() {
-            cb.onFrameRead(resource, index);
-            if (current != null) {
-                Glide.clear(current);
-            }
-            current = this;
-        }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoader.java
index b9c17c200..4db390f91 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoader.java
@@ -31,7 +31,7 @@ public void cleanup() {
 
         @Override
         public String getId() {
-            return decoder.getId() + decoder.getCurrentFrameIndex();
+            return String.valueOf(decoder.getCurrentFrameIndex());
         }
 
         @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index dbc0e1727..1815c99d5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.load.engine.Resource;
+
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 
@@ -17,7 +18,7 @@ public GifFrameResourceDecoder(BitmapPool bitmapPool) {
     @Override
     public Resource<Bitmap> decode(GifDecoder source, int width, int height) {
         Bitmap bitmap = source.getNextFrame();
-        return new BitmapResource(bitmap, bitmapPool);
+        return BitmapResource.obtain(bitmap, bitmapPool);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java
index cf56edfba..55a257fd3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java
@@ -3,11 +3,11 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.util.Log;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
-import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -17,10 +17,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
 import java.util.Queue;
-import java.util.UUID;
 
 /**
  * An {@link com.bumptech.glide.load.ResourceDecoder} that decodes
@@ -34,7 +31,6 @@
     private final Context context;
     private final GifHeaderParserPool parserPool;
     private final BitmapPool bitmapPool;
-    private final DecodeFormat decodeFormat;
     private final GifDecoderPool decoderPool;
     private final GifBitmapProvider provider;
 
@@ -42,24 +38,15 @@ public GifResourceDecoder(Context context) {
         this(context, Glide.get(context).getBitmapPool());
     }
 
-    public GifResourceDecoder(Context context, DecodeFormat decodeFormat) {
-        this(context, Glide.get(context).getBitmapPool(), decodeFormat);
-    }
-
     public GifResourceDecoder(Context context, BitmapPool bitmapPool) {
-        this(context, bitmapPool, DecodeFormat.DEFAULT);
-    }
-
-    public GifResourceDecoder(Context context, BitmapPool bitmapPool, DecodeFormat decodeFormat) {
-        this(context, bitmapPool, decodeFormat, PARSER_POOL, DECODER_POOL);
+        this(context, bitmapPool, PARSER_POOL, DECODER_POOL);
     }
 
     // Visible for testing.
-    GifResourceDecoder(Context context, BitmapPool bitmapPool, DecodeFormat decodeFormat,
-            GifHeaderParserPool parserPool, GifDecoderPool decoderPool) {
+    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParserPool parserPool,
+            GifDecoderPool decoderPool) {
         this.context = context;
         this.bitmapPool = bitmapPool;
-        this.decodeFormat = decodeFormat;
         this.decoderPool = decoderPool;
         this.provider = new GifBitmapProvider(bitmapPool);
         this.parserPool = parserPool;
@@ -70,8 +57,6 @@ public GifDrawableResource decode(InputStream source, int width, int height) {
         byte[] data = inputStreamToBytes(source);
         final GifHeaderParser parser = parserPool.obtain(data);
         final GifDecoder decoder = decoderPool.obtain(provider);
-        decoder.setPreferredConfig(decodeFormat == DecodeFormat.PREFER_RGB_565
-                ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888);
         try {
             return decode(data, width, height, parser, decoder);
         } finally {
@@ -87,18 +72,21 @@ private GifDrawableResource decode(byte[] data, int width, int height, GifHeader
             return null;
         }
 
-        String id = getGifId(data);
-        Bitmap firstFrame = decodeFirstFrame(decoder, id, header, data);
+        Bitmap firstFrame = decodeFirstFrame(decoder, header, data);
+        if (firstFrame == null) {
+            return null;
+        }
+
         Transformation<Bitmap> unitTransformation = UnitTransformation.get();
 
-        GifDrawable gifDrawable = new GifDrawable(context, provider, bitmapPool, unitTransformation, width, height, id,
+        GifDrawable gifDrawable = new GifDrawable(context, provider, bitmapPool, unitTransformation, width, height,
                 header, data, firstFrame);
 
         return new GifDrawableResource(gifDrawable);
     }
 
-    private Bitmap decodeFirstFrame(GifDecoder decoder, String id, GifHeader header, byte[] data) {
-        decoder.setData(id, header, data);
+    private Bitmap decodeFirstFrame(GifDecoder decoder, GifHeader header, byte[] data) {
+        decoder.setData(header, data);
         decoder.advance();
         return decoder.getNextFrame();
     }
@@ -108,20 +96,6 @@ public String getId() {
         return "";
     }
 
-    // A best effort attempt to get a unique id that can be used as a cache key for frames of the decoded GIF.
-    private static String getGifId(byte[] data) {
-        try {
-            MessageDigest digest = MessageDigest.getInstance("SHA-1");
-            digest.update(data);
-            return Util.sha1BytesToHex(digest.digest());
-        } catch (NoSuchAlgorithmException e) {
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Missing sha1 algorithm?", e);
-            }
-        }
-        return UUID.randomUUID().toString();
-    }
-
     private static byte[] inputStreamToBytes(InputStream is) {
         final int bufferSize = 16384;
         ByteArrayOutputStream buffer = new ByteArrayOutputStream(bufferSize);
@@ -170,6 +144,7 @@ public synchronized GifHeaderParser obtain(byte[] data) {
         }
 
         public synchronized void release(GifHeaderParser parser) {
+            parser.clear();
             pool.offer(parser);
         }
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java
index ab2e14c6d..df3b51fb2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.util.Log;
+
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
@@ -110,6 +111,7 @@ private GifDecoder decodeHeaders(byte[] data) {
 
     private Resource<Bitmap> getTransformedFrame(Bitmap currentFrame, Transformation<Bitmap> transformation,
             GifDrawable drawable) {
+        // TODO: what if current frame is null?
         Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
         Resource<Bitmap> transformedResource = transformation.transform(bitmapResource,
                 drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapper.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapper.java
index b5d73154e..0b3b62ba6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapper.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResource.java
index 7e10e008f..0fcd22053 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 
@@ -11,6 +12,9 @@
     private final GifBitmapWrapper data;
 
     public GifBitmapWrapperResource(GifBitmapWrapper data) {
+        if (data == null) {
+            throw new NullPointerException("Data must not be null");
+        }
         this.data = data;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoder.java
index 1ec8d7205..18b198a2a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoder.java
index 175535f82..ee18ab71d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceEncoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformation.java
index a985b3189..791e81bd4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformation.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gifbitmap;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/ImageVideoGifDrawableLoadProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/ImageVideoGifDrawableLoadProvider.java
index 56b2ebfaf..e084fb524 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/ImageVideoGifDrawableLoadProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gifbitmap/ImageVideoGifDrawableLoadProvider.java
@@ -2,14 +2,14 @@
 
 import android.graphics.Bitmap;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.provider.DataLoadProvider;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.model.ImageVideoWrapper;
 import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.provider.DataLoadProvider;
 
 import java.io.File;
 import java.io.InputStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index ef899eaf1..01d944075 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoder.java
index 11783990d..293439161 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapToGlideDrawableTranscoder.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.drawable.GlideDrawable;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoder.java
index 39b3a6a34..d226d68d8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifBitmapWrapperDrawableTranscoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;
 import com.bumptech.glide.load.resource.drawable.GlideDrawable;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoder.java
index 9c7425bc9..bdc03df84 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoder.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
new file mode 100644
index 000000000..41505a86e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.manager;
+
+import com.bumptech.glide.RequestManager;
+
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * A {@link RequestManagerTreeNode} that returns no relatives.
+ */
+final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
+    @Override
+    public Set<RequestManager> getDescendants() {
+        return Collections.emptySet();
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 47d93afd1..edfc3b699 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -2,11 +2,16 @@
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.app.Activity;
 import android.app.Fragment;
 import android.os.Build;
 
 import com.bumptech.glide.RequestManager;
 
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
 /**
  * A view-less {@link android.app.Fragment} used to safely store an {@link com.bumptech.glide.RequestManager} that
  * can be used to start, stop and manage Glide requests started for targets the fragment or activity this fragment is a
@@ -19,7 +24,11 @@
 @TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class RequestManagerFragment extends Fragment {
     private final ActivityFragmentLifecycle lifecycle;
+    private final RequestManagerTreeNode requestManagerTreeNode = new FragmentRequestManagerTreeNode();
     private RequestManager requestManager;
+    private final HashSet<RequestManagerFragment> childRequestManagerFragments
+        = new HashSet<RequestManagerFragment>();
+    private RequestManagerFragment rootRequestManagerFragment;
 
     public RequestManagerFragment() {
         this(new ActivityFragmentLifecycle());
@@ -51,6 +60,76 @@ public RequestManager getRequestManager() {
         return requestManager;
     }
 
+    public RequestManagerTreeNode getRequestManagerTreeNode() {
+        return requestManagerTreeNode;
+    }
+
+    private void addChildRequestManagerFragment(RequestManagerFragment child) {
+        childRequestManagerFragments.add(child);
+    }
+
+    private void removeChildRequestManagerFragment(RequestManagerFragment child) {
+        childRequestManagerFragments.remove(child);
+    }
+
+    /**
+     * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e. our parent is
+     * the fragment that we are annotating).
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    public Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
+        if (rootRequestManagerFragment == this) {
+            return Collections.unmodifiableSet(childRequestManagerFragments);
+        } else if (rootRequestManagerFragment == null || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            // Pre JB MR1 doesn't allow us to get the parent fragment so we can't introspect hierarchy, so just
+            // return an empty set.
+            return Collections.emptySet();
+        } else {
+            HashSet<RequestManagerFragment> descendants = new HashSet<RequestManagerFragment>();
+            for (RequestManagerFragment fragment
+                    : rootRequestManagerFragment.getDescendantRequestManagerFragments()) {
+                if (isDescendant(fragment.getParentFragment())) {
+                    descendants.add(fragment);
+                }
+            }
+            return Collections.unmodifiableSet(descendants);
+        }
+    }
+
+    /**
+     * Returns true if the fragment is a descendant of our parent.
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    private boolean isDescendant(Fragment fragment) {
+        Fragment root = this.getParentFragment();
+        while (fragment.getParentFragment() != null) {
+            if (fragment.getParentFragment() == root) {
+                return true;
+            }
+            fragment = fragment.getParentFragment();
+        }
+        return false;
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        rootRequestManagerFragment = RequestManagerRetriever.get()
+                .getRequestManagerFragment(getActivity().getFragmentManager());
+        if (rootRequestManagerFragment != this) {
+            rootRequestManagerFragment.addChildRequestManagerFragment(this);
+        }
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+        if (rootRequestManagerFragment != null) {
+            rootRequestManagerFragment.removeChildRequestManagerFragment(this);
+            rootRequestManagerFragment = null;
+        }
+    }
+
     @Override
     public void onStart() {
         super.onStart();
@@ -68,4 +147,37 @@ public void onDestroy() {
         super.onDestroy();
         lifecycle.onDestroy();
     }
+
+    @Override
+    public void onTrimMemory(int level) {
+        // If an activity is re-created, onTrimMemory may be called before a manager is ever set.
+        // See #329.
+        if (requestManager != null) {
+            requestManager.onTrimMemory(level);
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        // If an activity is re-created, onLowMemory may be called before a manager is ever set.
+        // See #329.
+        if (requestManager != null) {
+            requestManager.onLowMemory();
+        }
+    }
+
+    private class FragmentRequestManagerTreeNode implements RequestManagerTreeNode {
+        @Override
+        public Set<RequestManager> getDescendants() {
+            Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
+            HashSet<RequestManager> descendants =
+                new HashSet<RequestManager>(descendantFragments.size());
+            for (RequestManagerFragment fragment : descendantFragments) {
+                if (fragment.getRequestManager() != null) {
+                    descendants.add(fragment.getRequestManager());
+                }
+            }
+            return descendants;
+        }
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index d48307961..5d8953072 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -13,6 +13,7 @@
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import android.util.Log;
+
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Util;
 
@@ -24,7 +25,8 @@
  * ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-    static final String TAG = "com.bumptech.glide.manager";
+    private static final String TAG = "RMRetriever";
+    static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
 
     /** The singleton instance of RequestManagerRetriever. */
     private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();
@@ -69,7 +71,7 @@ private RequestManager getApplicationManager(Context context) {
                     // However, in this case since the manager attached to the application will not receive lifecycle
                     // events, we must force the manager to start resumed using ApplicationLifecycle.
                     applicationManager = new RequestManager(context.getApplicationContext(),
-                            new ApplicationLifecycle());
+                            new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
                 }
             }
         }
@@ -110,9 +112,6 @@ public RequestManager get(Fragment fragment) {
         if (Util.isOnBackgroundThread()) {
             return get(fragment.getActivity().getApplicationContext());
         } else {
-            if (fragment.isDetached()) {
-                throw new IllegalArgumentException("You cannot start a load on a detached fragment");
-            }
             FragmentManager fm = fragment.getChildFragmentManager();
             return supportFragmentGet(fragment.getActivity(), fm);
         }
@@ -144,54 +143,59 @@ public RequestManager get(android.app.Fragment fragment) {
         if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
             return get(fragment.getActivity().getApplicationContext());
         } else {
-            assertNotDetached(fragment);
             android.app.FragmentManager fm = fragment.getChildFragmentManager();
             return fragmentGet(fragment.getActivity(), fm);
         }
     }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
-    private static void assertNotDetached(android.app.Fragment fragment) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2 && fragment.isDetached()) {
-            throw new IllegalArgumentException("You cannot start a load on a detached fragment");
-        }
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    RequestManager fragmentGet(Context context, final android.app.FragmentManager fm) {
-        RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(TAG);
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {
+        RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
         if (current == null) {
             current = pendingRequestManagerFragments.get(fm);
             if (current == null) {
                 current = new RequestManagerFragment();
                 pendingRequestManagerFragments.put(fm, current);
-                fm.beginTransaction().add(current, TAG).commitAllowingStateLoss();
+                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
                 handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
             }
         }
+        return current;
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    RequestManager fragmentGet(Context context, android.app.FragmentManager fm) {
+        RequestManagerFragment current = getRequestManagerFragment(fm);
         RequestManager requestManager = current.getRequestManager();
         if (requestManager == null) {
-            requestManager = new RequestManager(context, current.getLifecycle());
+            requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
             current.setRequestManager(requestManager);
         }
         return requestManager;
-
     }
 
-    RequestManager supportFragmentGet(Context context, final FragmentManager fm) {
-        SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(TAG);
+    SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) {
+        SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(
+
+
+            FRAGMENT_TAG);
         if (current == null) {
             current = pendingSupportRequestManagerFragments.get(fm);
             if (current == null) {
                 current = new SupportRequestManagerFragment();
                 pendingSupportRequestManagerFragments.put(fm, current);
-                fm.beginTransaction().add(current, TAG).commitAllowingStateLoss();
+                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
                 handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
             }
         }
+        return current;
+    }
+
+    RequestManager supportFragmentGet(Context context, FragmentManager fm) {
+        SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);
         RequestManager requestManager = current.getRequestManager();
         if (requestManager == null) {
-            requestManager = new RequestManager(context, current.getLifecycle());
+            requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
             current.setRequestManager(requestManager);
         }
         return requestManager;
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
new file mode 100644
index 000000000..c92b8e6d9
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -0,0 +1,17 @@
+package com.bumptech.glide.manager;
+
+import com.bumptech.glide.RequestManager;
+
+import java.util.Set;
+
+/**
+ * Provides access to the relatives of a RequestManager based on the current context. The context hierarchy
+ * is provided by nesting in Activity and Fragments; the application context does not provide access to
+ * any other RequestManagers hierarchically.
+ */
+public interface RequestManagerTreeNode {
+    /**
+     * Returns all descendant {@link RequestManager}s relative to the context of the current {@link RequestManager}.
+     */
+    Set<RequestManager> getDescendants();
+}
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 1fed826d5..621579025 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -2,7 +2,9 @@
 
 import com.bumptech.glide.request.Request;
 
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
 import java.util.Set;
 import java.util.WeakHashMap;
 
@@ -17,6 +19,12 @@
     // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager
     // where holding strong references would steadily leak bitmaps and/or views.
     private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());
+    // A set of requests that have not completed and are queued to be run again. We use this list to maintain hard
+    // references to these requests to ensure that they are not garbage collected before they start running or
+    // while they are paused. See #346.
+    @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
+    private final List<Request> pendingRequests = new ArrayList<Request>();
+
     private boolean isPaused;
 
     /**
@@ -26,10 +34,12 @@ public void runRequest(Request request) {
         requests.add(request);
         if (!isPaused) {
             request.begin();
+        } else {
+            pendingRequests.add(request);
         }
     }
 
-    // Exposed for testing.
+    // Visible for testing.
     void addRequest(Request request) {
         requests.add(request);
     }
@@ -39,6 +49,7 @@ void addRequest(Request request) {
      */
     public void removeRequest(Request request) {
         requests.remove(request);
+        pendingRequests.remove(request);
     }
 
     /**
@@ -53,9 +64,10 @@ public boolean isPaused() {
      */
     public void pauseRequests() {
         isPaused = true;
-        for (Request request : requests) {
+        for (Request request : getSnapshot()) {
             if (request.isRunning()) {
                 request.pause();
+                pendingRequests.add(request);
             }
         }
     }
@@ -65,34 +77,51 @@ public void pauseRequests() {
      */
     public void resumeRequests() {
         isPaused = false;
-        for (Request request : requests) {
+        for (Request request : getSnapshot()) {
             if (!request.isComplete() && !request.isCancelled() && !request.isRunning()) {
                 request.begin();
             }
         }
+        pendingRequests.clear();
     }
 
     /**
      * Cancels all requests and clears their resources.
      */
     public void clearRequests() {
-        for (Request request : requests) {
+        for (Request request : getSnapshot()) {
             request.clear();
         }
+        pendingRequests.clear();
     }
 
     /**
      * Restarts failed requests and cancels and restarts in progress requests.
      */
     public void restartRequests() {
-        for (Request request : requests) {
+        for (Request request : getSnapshot()) {
             if (!request.isComplete() && !request.isCancelled()) {
                 // Ensure the request will be restarted in onResume.
                 request.pause();
                 if (!isPaused) {
                     request.begin();
+                } else {
+                    pendingRequests.add(request);
                 }
             }
         }
     }
+
+    // Avoids a ConcurrentModificationException when requests are started by another request completing. See #303.
+    private List<Request> getSnapshot() {
+        // toArray creates a new ArrayList internally and this way we can guarantee entries will not be
+        // null. See #322.
+        List<Request> result = new ArrayList<Request>(requests.size());
+        // We could also just call new ArrayList<Request>(requests) but that actually creates two new ArrayLists because
+        // that constructor in ArrayList calls toArray().
+        for (Request request : requests) {
+            result.add(request);
+        }
+        return result;
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index c6ad8bd75..640addfac 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -1,9 +1,15 @@
 package com.bumptech.glide.manager;
 
 import android.annotation.SuppressLint;
+import android.app.Activity;
 import android.support.v4.app.Fragment;
+
 import com.bumptech.glide.RequestManager;
 
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
 /**
  * A view-less {@link android.support.v4.app.Fragment} used to safely store an
  * {@link com.bumptech.glide.RequestManager} that can be used to start, stop and manage Glide requests started for
@@ -16,6 +22,11 @@
 public class SupportRequestManagerFragment extends Fragment {
     private RequestManager requestManager;
     private final ActivityFragmentLifecycle lifecycle;
+    private final RequestManagerTreeNode requestManagerTreeNode =
+            new SupportFragmentRequestManagerTreeNode();
+    private final HashSet<SupportRequestManagerFragment> childRequestManagerFragments =
+        new HashSet<SupportRequestManagerFragment>();
+    private SupportRequestManagerFragment rootRequestManagerFragment;
 
     public SupportRequestManagerFragment() {
         this(new ActivityFragmentLifecycle());
@@ -47,6 +58,77 @@ public RequestManager getRequestManager() {
         return requestManager;
     }
 
+    /**
+     * Returns the {@link RequestManagerTreeNode} that provides tree traversal methods relative to the associated
+     * {@link RequestManager}.
+     */
+    public RequestManagerTreeNode getRequestManagerTreeNode() {
+        return requestManagerTreeNode;
+    }
+
+    private void addChildRequestManagerFragment(SupportRequestManagerFragment child) {
+        childRequestManagerFragments.add(child);
+    }
+
+    private void removeChildRequestManagerFragment(SupportRequestManagerFragment child) {
+        childRequestManagerFragments.remove(child);
+    }
+
+    /**
+     * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e. our parent is
+     * the fragment that we are annotating).
+     */
+    public Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
+        if (rootRequestManagerFragment == null) {
+            return Collections.emptySet();
+        } else if (rootRequestManagerFragment == this) {
+            return Collections.unmodifiableSet(childRequestManagerFragments);
+        } else {
+            HashSet<SupportRequestManagerFragment> descendants =
+                new HashSet<SupportRequestManagerFragment>();
+            for (SupportRequestManagerFragment fragment
+                : rootRequestManagerFragment.getDescendantRequestManagerFragments()) {
+                if (isDescendant(fragment.getParentFragment())) {
+                    descendants.add(fragment);
+                }
+            }
+            return Collections.unmodifiableSet(descendants);
+        }
+    }
+
+    /**
+     * Returns true if the fragment is a descendant of our parent.
+     */
+    private boolean isDescendant(Fragment fragment) {
+        Fragment root = this.getParentFragment();
+        while (fragment.getParentFragment() != null) {
+            if (fragment.getParentFragment() == root) {
+                return true;
+            }
+            fragment = fragment.getParentFragment();
+        }
+        return false;
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        rootRequestManagerFragment = RequestManagerRetriever.get()
+                .getSupportRequestManagerFragment(getActivity().getSupportFragmentManager());
+        if (rootRequestManagerFragment != this) {
+            rootRequestManagerFragment.addChildRequestManagerFragment(this);
+        }
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+        if (rootRequestManagerFragment != null) {
+            rootRequestManagerFragment.removeChildRequestManagerFragment(this);
+            rootRequestManagerFragment = null;
+        }
+    }
+
     @Override
     public void onStart() {
         super.onStart();
@@ -64,4 +146,28 @@ public void onDestroy() {
         super.onDestroy();
         lifecycle.onDestroy();
     }
+
+    @Override
+    public void onLowMemory() {
+        super.onLowMemory();
+        // If an activity is re-created, onLowMemory may be called before a manager is ever set.
+        // See #329.
+        if (requestManager != null) {
+            requestManager.onLowMemory();
+        }
+    }
+
+    private class SupportFragmentRequestManagerTreeNode implements RequestManagerTreeNode {
+        @Override
+        public Set<RequestManager> getDescendants() {
+            Set<SupportRequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
+            HashSet<RequestManager> descendants = new HashSet<RequestManager>(descendantFragments.size());
+            for (SupportRequestManagerFragment fragment : descendantFragments) {
+                if (fragment.getRequestManager() != null) {
+                    descendants.add(fragment.getRequestManager());
+                }
+            }
+            return descendants;
+        }
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
new file mode 100644
index 000000000..76b45fd72
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * An interface allowing lazy configuration of Glide including setting options using
+ * {@link com.bumptech.glide.GlideBuilder} and registering
+ * {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders}.
+ *
+ * <p>
+ *     To use this interface:
+ *     <ol>
+ *         <li>
+ *             Implement the GlideModule interface in a class with public visibility, calling
+ *             {@link com.bumptech.glide.Glide#register(Class, Class, com.bumptech.glide.load.model.ModelLoaderFactory)}
+ *             for each {@link com.bumptech.glide.load.model.ModelLoader} you'd like to register:
+ *             <pre>
+ *                  <code>
+ *                      public class FlickrGlideModule implements GlideModule {
+ *                          {@literal @}Override
+ *                          public void applyOptions(Context context, GlideBuilder builder) {
+ *                              buidler.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
+ *                          }
+ *
+ *                          {@literal @}Override
+ *                          public void registerComponents(Context context, Glide glide) {
+ *                              glide.register(Model.class, Data.class, new MyModelLoader());
+ *                          }
+ *                      }
+ *                  </code>
+ *             </pre>
+ *         </li>
+ *         <li>
+ *              Add your implementation to your list of keeps in your proguard.cfg file:
+ *              <pre>
+ *                  {@code
+ *                      -keepnames class * com.bumptech.glide.samples.flickr.FlickrGlideModule
+ *                  }
+ *              </pre>
+ *         </li>
+ *         <li>
+ *             Add a metadata tag to your AndroidManifest.xml with your GlideModule implementation's fully qualified
+ *             classname as the key, and {@code GlideModule} as the value:
+ *             <pre>
+ *                 {@code
+ *                      <meta-data
+ *                          android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
+ *                          android:value="GlideModule" />
+ *                 }
+ *             </pre>
+ *         </li>
+ *     </ol>
+ * </p>
+ *
+ * <p>
+ *     All implementations must be publicly visible and contain only an empty constructor so they can be instantiated
+ *     via reflection when Glide is lazily initialized.
+ * </p>
+ *
+ * <p>
+ *     There is no defined order in which modules are called, so projects should be careful to avoid applying
+ *     conflicting settings in different modules. If an application depends on libraries that have conflicting
+ *     modules, the application should consider avoiding the library modules and instead providing their required
+ *     dependencies in a single application module.
+ * </p>
+ */
+public interface GlideModule {
+
+    /**
+     * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide singleton is
+     * created.
+     *
+     * <p>
+     *     This method will be called once and only once per implementation.
+     * </p>
+     *
+     * @param context An Application {@link android.content.Context}.
+     * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
+     */
+    void applyOptions(Context context, GlideBuilder builder);
+
+    /**
+     * Lazily register components immediately after the Glide singleton is created but before any requests can be
+     * started.
+     *
+     * <p>
+     *     This method will be called once and only once per implementation.
+     * </p>
+     *
+     * @param context An Application {@link android.content.Context}.
+     * @param glide The newly created Glide singleton.
+     */
+    void registerComponents(Context context, Glide glide);
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
new file mode 100644
index 000000000..6b4fde391
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -0,0 +1,63 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
+ */
+public final class ManifestParser {
+    private static final String GLIDE_MODULE_VALUE = "GlideModule";
+
+    private final Context context;
+
+    public ManifestParser(Context context) {
+        this.context = context;
+    }
+
+    public List<GlideModule> parse() {
+        List<GlideModule> modules = new ArrayList<GlideModule>();
+        try {
+            ApplicationInfo appInfo = context.getPackageManager().getApplicationInfo(
+                    context.getPackageName(), PackageManager.GET_META_DATA);
+            if (appInfo.metaData != null) {
+                for (String key : appInfo.metaData.keySet()) {
+                    if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
+                        modules.add(parseModule(key));
+                    }
+                }
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+            throw new RuntimeException("Unable to find metadata to parse GlideModules", e);
+        }
+
+        return modules;
+    }
+
+    private static GlideModule parseModule(String className) {
+        Class<?> clazz;
+        try {
+            clazz = Class.forName(className);
+        } catch (ClassNotFoundException e) {
+            throw new IllegalArgumentException("Unable to find GlideModule implementation", e);
+        }
+
+        Object module;
+        try {
+            module = clazz.newInstance();
+        } catch (InstantiationException e) {
+            throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz, e);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz, e);
+        }
+
+        if (!(module instanceof GlideModule)) {
+            throw new RuntimeException("Expected instanceof GlideModule, but found: " + module);
+        }
+        return (GlideModule) module;
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadProvider.java b/library/src/main/java/com/bumptech/glide/provider/LoadProvider.java
index 568d0ee54..694ab54ba 100644
--- a/library/src/main/java/com/bumptech/glide/provider/LoadProvider.java
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadProvider.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.provider;
 
-import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 
 /**
  * An extension of {@link com.bumptech.glide.provider.DataLoadProvider} that also allows a
diff --git a/library/src/main/java/com/bumptech/glide/request/GenericRequest.java b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java
index 423437cdc..b92c547aa 100644
--- a/library/src/main/java/com/bumptech/glide/request/GenericRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.util.Log;
+
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
@@ -45,10 +46,12 @@
         WAITING_FOR_SIZE,
         /** Finished loading media successfully. */
         COMPLETE,
-        /** Failed to load media. */
+        /** Failed to load media, may be restarted. */
         FAILED,
         /** Cancelled by the user, may not be restarted. */
         CANCELLED,
+        /** Cleared by the user with a placeholder set, may not be restarted. */
+        CLEARED,
         /** Temporarily paused by the system, may be restarted. */
         PAUSED,
     }
@@ -67,7 +70,7 @@
     private boolean isMemoryCacheable;
     private Priority priority;
     private Target<R> target;
-    private RequestListener<A, R> requestListener;
+    private RequestListener<? super A, R> requestListener;
     private float sizeMultiplier;
     private Engine engine;
     private GlideAnimationFactory<R> animationFactory;
@@ -96,7 +99,7 @@
             int placeholderResourceId,
             Drawable errorDrawable,
             int errorResourceId,
-            RequestListener<A, R> requestListener,
+            RequestListener<? super A, R> requestListener,
             RequestCoordinator requestCoordinator,
             Engine engine,
             Transformation<Z> transformation,
@@ -168,7 +171,7 @@ private void init(
             int placeholderResourceId,
             Drawable errorDrawable,
             int errorResourceId,
-            RequestListener<A, R> requestListener,
+            RequestListener<? super A, R> requestListener,
             RequestCoordinator requestCoordinator,
             Engine engine,
             Transformation<Z> transformation,
@@ -181,7 +184,7 @@ private void init(
         this.loadProvider = loadProvider;
         this.model = model;
         this.signature = signature;
-        this.context = context;
+        this.context = context.getApplicationContext();
         this.priority = priority;
         this.target = target;
         this.sizeMultiplier = sizeMultiplier;
@@ -252,7 +255,7 @@ public void begin() {
         }
 
         status = Status.WAITING_FOR_SIZE;
-        if (overrideWidth > 0 && overrideHeight > 0) {
+        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
             onSizeReady(overrideWidth, overrideHeight);
         } else {
             target.getSize(this);
@@ -297,6 +300,9 @@ void cancel() {
     @Override
     public void clear() {
         Util.assertMainThread();
+        if (status == Status.CLEARED) {
+            return;
+        }
         cancel();
         // Resource must be released before canNotifyStatusChanged is called.
         if (resource != null) {
@@ -305,6 +311,8 @@ public void clear() {
         if (canNotifyStatusChanged()) {
             target.onLoadCleared(getPlaceholderDrawable());
         }
+        // Must be after cancel().
+        status = Status.CLEARED;
     }
 
     @Override
@@ -352,7 +360,7 @@ public boolean isResourceSet() {
      */
     @Override
     public boolean isCancelled() {
-        return status == Status.CANCELLED;
+        return status == Status.CANCELLED || status == Status.CLEARED;
     }
 
     /**
@@ -437,6 +445,12 @@ private boolean isFirstReadyResource() {
         return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
     }
 
+    private void notifyLoadSuccess() {
+      if (requestCoordinator != null) {
+        requestCoordinator.onRequestSuccess(this);
+      }
+    }
+
     /**
      * A callback method that should never be invoked directly.
      */
@@ -487,6 +501,7 @@ private void onResourceReady(Resource<?> resource, R result) {
 
         status = Status.COMPLETE;
         this.resource = resource;
+        notifyLoadSuccess();
 
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
             logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: "
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
index 29a3f3abb..c8c717164 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
@@ -25,4 +25,9 @@
      * @see Request#isComplete()
      */
     boolean isAnyResourceSet();
+
+    /**
+     * Must be called when a request coordinated by this object completes successfully.
+     */
+    void onRequestSuccess(Request request);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index eb293eb6d..aecbe32c7 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -58,6 +58,22 @@ public boolean isAnyResourceSet() {
         return parentIsAnyResourceSet() || isResourceSet();
     }
 
+    @Override
+    public void onRequestSuccess(Request request) {
+        if (request.equals(thumb)) {
+            return;
+        }
+        if (coordinator != null) {
+            coordinator.onRequestSuccess(this);
+        }
+        // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
+        // as a layer in a cross fade for example. The only way we know the thumb is not being
+        // displayed and is therefore safe to clear is if the thumb request has not yet completed.
+        if (!thumb.isComplete()) {
+          thumb.clear();
+        }
+    }
+
     private boolean parentIsAnyResourceSet() {
         return coordinator != null && coordinator.isAnyResourceSet();
     }
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java
new file mode 100644
index 000000000..5bd3305f3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java
@@ -0,0 +1,72 @@
+package com.bumptech.glide.request.animation;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.view.animation.AlphaAnimation;
+import android.view.animation.Animation;
+
+/**
+ * A factory class that produces a new {@link com.bumptech.glide.request.animation.GlideAnimation} that varies depending
+ * on whether or not the drawable was loaded from the memory cache and whether or not the drawable is the first
+ * image to be set on the target.
+ *
+ * <p>
+ *     Resources are usually loaded from the memory cache just before the user can see the view,
+ *     for example when the user changes screens or scrolls back and forth in a list. In those cases the user
+ *     typically does not expect to see an animation. As a result, when the resource is loaded from the memory
+ *     cache this factory produces an {@link com.bumptech.glide.request.animation.NoAnimation}.
+ * </p>
+ *
+ * @param <T> The type of the {@link android.graphics.drawable.Drawable} that will be animated.
+ */
+public class DrawableCrossFadeFactory<T extends Drawable> implements GlideAnimationFactory<T> {
+    private static final int DEFAULT_DURATION_MS = 300;
+    private final ViewAnimationFactory<T> animationFactory;
+    private final int duration;
+    private DrawableCrossFadeViewAnimation<T> animation;
+
+    public DrawableCrossFadeFactory() {
+        this(DEFAULT_DURATION_MS);
+    }
+
+    public DrawableCrossFadeFactory(int duration) {
+        this(new ViewAnimationFactory<T>(new DefaultAnimationFactory()), duration);
+    }
+
+    public DrawableCrossFadeFactory(Context context, int defaultAnimationId, int duration) {
+        this(new ViewAnimationFactory<T>(context, defaultAnimationId), duration);
+    }
+
+    public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
+        this(new ViewAnimationFactory<T>(defaultAnimation), duration);
+    }
+
+    DrawableCrossFadeFactory(ViewAnimationFactory<T> animationFactory, int duration) {
+        this.animationFactory = animationFactory;
+        this.duration = duration;
+    }
+
+    @Override
+    public GlideAnimation<T> build(boolean isFromMemoryCache, boolean isFirstResource) {
+        if (isFromMemoryCache) {
+            return NoAnimation.get();
+        }
+
+        if (animation == null) {
+            GlideAnimation<T> defaultAnimation = animationFactory.build(false, isFirstResource);
+            animation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
+        }
+
+        return animation;
+    }
+
+    private static class DefaultAnimationFactory implements ViewAnimation.AnimationFactory {
+
+        @Override
+        public Animation build() {
+            AlphaAnimation animation = new AlphaAnimation(0f, 1f);
+            animation.setDuration(DEFAULT_DURATION_MS / 2);
+            return animation;
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimation.java b/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimation.java
index bf2d3eeae..a721aa1c8 100644
--- a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimation.java
+++ b/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeViewAnimation.java
@@ -1,10 +1,7 @@
 package com.bumptech.glide.request.animation;
 
-import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
-import android.view.animation.AlphaAnimation;
-import android.view.animation.Animation;
 
 /**
  * A cross fade {@link GlideAnimation} for {@link android.graphics.drawable.Drawable}s
@@ -15,64 +12,9 @@
  * @param <T> The type of the {@link android.graphics.drawable.Drawable} that will be animated.
  */
 public class DrawableCrossFadeViewAnimation<T extends Drawable> implements GlideAnimation<T> {
-    // 150 ms.
-    public static final int DEFAULT_DURATION = 300;
     private final GlideAnimation<T> defaultAnimation;
     private final int duration;
 
-    /**
-     * A factory class that produces a new {@link GlideAnimation} that varies depending
-     * on whether or not the drawable was loaded from the memory cache and whether or not the drawable is the first
-     * image to be set on the target.
-     *
-     * <p>
-     *     Resources are usually loaded from the memory cache just before the user can see the view,
-     *     for example when the user changes screens or scrolls back and forth in a list. In those cases the user
-     *     typically does not expect to see an animation. As a result, when the resource is loaded from the memory
-     *     cache this factory producdes an {@link NoAnimation}.
-     * </p>
-     */
-    public static class DrawableCrossFadeFactory<T extends Drawable> implements GlideAnimationFactory<T> {
-        private final ViewAnimation.ViewAnimationFactory<T> animationFactory;
-        private final int duration;
-        private DrawableCrossFadeViewAnimation<T> animation;
-
-        public DrawableCrossFadeFactory() {
-            this(DEFAULT_DURATION);
-        }
-
-        public DrawableCrossFadeFactory(int duration) {
-            this(new ViewAnimation.ViewAnimationFactory<T>(new DefaultAnimationFactory()), duration);
-        }
-
-        public DrawableCrossFadeFactory(Context context, int defaultAnimationId, int duration) {
-            this(new ViewAnimation.ViewAnimationFactory<T>(context, defaultAnimationId), duration);
-        }
-
-        public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
-            this(new ViewAnimation.ViewAnimationFactory<T>(defaultAnimation), duration);
-        }
-
-        DrawableCrossFadeFactory(ViewAnimation.ViewAnimationFactory<T> animationFactory, int duration) {
-            this.animationFactory = animationFactory;
-            this.duration = duration;
-        }
-
-        @Override
-        public GlideAnimation<T> build(boolean isFromMemoryCache, boolean isFirstResource) {
-            if (isFromMemoryCache) {
-                return NoAnimation.get();
-            }
-
-            if (animation == null) {
-                GlideAnimation<T> defaultAnimation = animationFactory.build(false, isFirstResource);
-                animation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
-            }
-
-            return animation;
-        }
-    }
-
     /**
      * Constructor that takes a default animation and a duration in milliseconds that the cross fade animation should
      * last.
@@ -111,14 +53,4 @@ public boolean animate(T current, ViewAdapter adapter) {
             return false;
         }
     }
-
-    private static class DefaultAnimationFactory implements ViewAnimation.AnimationFactory {
-
-        @Override
-        public Animation build() {
-            AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-            animation.setDuration(DEFAULT_DURATION / 2);
-            return animation;
-        }
-    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimation.java b/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimation.java
index aeea71878..7f62719db 100644
--- a/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimation.java
+++ b/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimation.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.request.animation;
 
-import android.content.Context;
 import android.view.View;
 import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
 
 /**
  * A {@link com.bumptech.glide.request.animation.GlideAnimation GlideAnimation} that can apply a
@@ -45,76 +43,6 @@ public boolean animate(R current, ViewAdapter adapter) {
         return false;
     }
 
-    /**
-     * A {@link com.bumptech.glide.request.animation.GlideAnimationFactory} that produces ViewAnimations.
-     */
-    public static class ViewAnimationFactory<R> implements GlideAnimationFactory<R> {
-        private final AnimationFactory animationFactory;
-        private GlideAnimation<R> glideAnimation;
-
-        public ViewAnimationFactory(Animation animation) {
-            this(new ConcreteAnimationFactory(animation));
-        }
-
-        public ViewAnimationFactory(Context context, int animationId) {
-            this(new ResourceAnimationFactory(context, animationId));
-        }
-
-        ViewAnimationFactory(AnimationFactory animationFactory) {
-            this.animationFactory = animationFactory;
-        }
-
-        /**
-         * Returns a new {@link com.bumptech.glide.request.animation.GlideAnimation} for the given arguments. If
-         * isFromMemoryCache is {@code true} or isFirstImage is {@code false}, returns a
-         * {@link com.bumptech.glide.request.animation.NoAnimation} and otherwise returns a new
-         * {@link com.bumptech.glide.request.animation.ViewAnimation}.
-         *
-         * @param isFromMemoryCache {@inheritDoc}
-         * @param isFirstResource {@inheritDoc}
-         */
-        @Override
-        public GlideAnimation<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
-            if (isFromMemoryCache || !isFirstResource) {
-                return NoAnimation.get();
-            }
-
-            if (glideAnimation == null) {
-                glideAnimation = new ViewAnimation<R>(animationFactory);
-            }
-
-            return glideAnimation;
-        }
-    }
-
-    private static class ConcreteAnimationFactory implements AnimationFactory {
-        private final Animation animation;
-
-        public ConcreteAnimationFactory(Animation animation) {
-            this.animation = animation;
-        }
-
-        @Override
-        public Animation build() {
-            return animation;
-        }
-    }
-
-    private static class ResourceAnimationFactory implements AnimationFactory {
-        private final Context context;
-        private final int animationId;
-
-        public ResourceAnimationFactory(Context context, int animationId) {
-            this.context = context.getApplicationContext();
-            this.animationId = animationId;
-        }
-
-        @Override
-        public Animation build() {
-            return AnimationUtils.loadAnimation(context, animationId);
-        }
-    }
-
     interface AnimationFactory {
         Animation build();
     }
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimationFactory.java
new file mode 100644
index 000000000..df2761aa7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/animation/ViewAnimationFactory.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.request.animation;
+
+import android.content.Context;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+
+/**
+ * A {@link com.bumptech.glide.request.animation.GlideAnimationFactory} that produces
+ * {@link com.bumptech.glide.request.animation.ViewAnimation}s.
+ *
+ * @param <R> The type of the resource displayed in the view that is animated
+ */
+public class ViewAnimationFactory<R> implements GlideAnimationFactory<R> {
+    private final ViewAnimation.AnimationFactory animationFactory;
+    private GlideAnimation<R> glideAnimation;
+
+    public ViewAnimationFactory(Animation animation) {
+        this(new ConcreteAnimationFactory(animation));
+    }
+
+    public ViewAnimationFactory(Context context, int animationId) {
+        this(new ResourceAnimationFactory(context, animationId));
+    }
+
+    ViewAnimationFactory(ViewAnimation.AnimationFactory animationFactory) {
+        this.animationFactory = animationFactory;
+    }
+
+    /**
+     * Returns a new {@link com.bumptech.glide.request.animation.GlideAnimation} for the given arguments. If
+     * isFromMemoryCache is {@code true} or isFirstImage is {@code false}, returns a
+     * {@link com.bumptech.glide.request.animation.NoAnimation} and otherwise returns a new
+     * {@link com.bumptech.glide.request.animation.ViewAnimation}.
+     *
+     * @param isFromMemoryCache {@inheritDoc}
+     * @param isFirstResource   {@inheritDoc}
+     */
+    @Override
+    public GlideAnimation<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
+        if (isFromMemoryCache || !isFirstResource) {
+            return NoAnimation.get();
+        }
+
+        if (glideAnimation == null) {
+            glideAnimation = new ViewAnimation<R>(animationFactory);
+        }
+
+        return glideAnimation;
+    }
+
+    private static class ConcreteAnimationFactory implements ViewAnimation.AnimationFactory {
+        private final Animation animation;
+
+        public ConcreteAnimationFactory(Animation animation) {
+            this.animation = animation;
+        }
+
+        @Override
+        public Animation build() {
+            return animation;
+        }
+    }
+
+    private static class ResourceAnimationFactory implements ViewAnimation.AnimationFactory {
+        private final Context context;
+        private final int animationId;
+
+        public ResourceAnimationFactory(Context context, int animationId) {
+            this.context = context.getApplicationContext();
+            this.animationId = animationId;
+        }
+
+        @Override
+        public Animation build() {
+            return AnimationUtils.loadAnimation(context, animationId);
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimation.java b/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimation.java
index 9c664df48..6b42e81f4 100644
--- a/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimation.java
+++ b/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimation.java
@@ -54,34 +54,4 @@ public boolean animate(R current, ViewAdapter adapter) {
         void animate(View view);
     }
 
-    /**
-     * A {@link com.bumptech.glide.request.animation.GlideAnimationFactory} that produces ViewPropertyAnimations.
-     */
-    public static class ViewPropertyAnimationFactory<R> implements GlideAnimationFactory<R> {
-        private final Animator animator;
-        private ViewPropertyAnimation<R> animation;
-
-        public ViewPropertyAnimationFactory(Animator animator) {
-            this.animator = animator;
-        }
-
-        /**
-         * Returns a new {@link com.bumptech.glide.request.animation.GlideAnimation} for the given arguments. If
-         * isMemoryCache is {@code true} or isFirstImage is {@code false}, returns a
-         * {@link com.bumptech.glide.request.animation.NoAnimation} and otherwise returns a new
-         * {@link com.bumptech.glide.request.animation.ViewPropertyAnimation} for the
-         * {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} provided in the constructor.
-         */
-        @Override
-        public GlideAnimation<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
-            if (isFromMemoryCache || !isFirstResource) {
-                return NoAnimation.get();
-            }
-            if (animation == null) {
-                animation = new ViewPropertyAnimation<R>(animator);
-            }
-
-            return animation;
-        }
-    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactory.java
new file mode 100644
index 000000000..f8c5002fa
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/animation/ViewPropertyAnimationFactory.java
@@ -0,0 +1,34 @@
+package com.bumptech.glide.request.animation;
+
+/**
+ * A {@link GlideAnimationFactory} that produces ViewPropertyAnimations.
+ *
+ * @param <R> The type of the resource displayed in the view that is animated
+ */
+public class ViewPropertyAnimationFactory<R> implements GlideAnimationFactory<R> {
+    private final ViewPropertyAnimation.Animator animator;
+    private ViewPropertyAnimation<R> animation;
+
+    public ViewPropertyAnimationFactory(ViewPropertyAnimation.Animator animator) {
+        this.animator = animator;
+    }
+
+    /**
+     * Returns a new {@link GlideAnimation} for the given arguments. If
+     * isMemoryCache is {@code true} or isFirstImage is {@code false}, returns a
+     * {@link NoAnimation} and otherwise returns a new
+     * {@link ViewPropertyAnimation} for the
+     * {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} provided in the constructor.
+     */
+    @Override
+    public GlideAnimation<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
+        if (isFromMemoryCache || !isFirstResource) {
+            return NoAnimation.get();
+        }
+        if (animation == null) {
+            animation = new ViewPropertyAnimation<R>(animator);
+        }
+
+        return animation;
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
new file mode 100644
index 000000000..592de6282
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -0,0 +1,137 @@
+package com.bumptech.glide.request.target;
+
+import android.appwidget.AppWidgetManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.widget.RemoteViews;
+
+import com.bumptech.glide.request.animation.GlideAnimation;
+
+
+/**
+ * This class is used in order to display downloaded Bitmap inside an ImageView
+ * of an AppWidget through RemoteViews.
+ *
+ * <p>
+ *     Note - For cancellation to work correctly, you must pass in the same instance of this class for every subsequent
+ *     load.
+ * </p>
+ */
+public class AppWidgetTarget extends SimpleTarget<Bitmap> {
+
+    private final int[] widgetIds;
+    private final ComponentName componentName;
+    private final RemoteViews remoteViews;
+    private final Context context;
+    private final int viewId;
+
+    /**
+     * Constructor using an int array of widgetIds to get a handle on the Widget in order to update it.
+     *
+     * @param context     Context to use in the AppWidgetManager initialization.
+     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+     * @param viewId      The id of the ImageView view that will load the image.
+     * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be manually set
+     *                    because of RemoteViews limitations.)
+     * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be manually set
+     *                    because of RemoteViews limitations.)
+     * @param widgetIds   The int[] that contains the widget ids of an application.
+     */
+    public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width, int height,
+            int... widgetIds) {
+        super(width, height);
+        if (context == null) {
+            throw new NullPointerException("Context can not be null!");
+        }
+        if (widgetIds == null) {
+            throw new NullPointerException("WidgetIds can not be null!");
+        }
+        if (widgetIds.length == 0) {
+            throw new IllegalArgumentException("WidgetIds must have length > 0");
+        }
+        if (remoteViews == null) {
+            throw new NullPointerException("RemoteViews object can not be null!");
+        }
+        this.context = context;
+        this.remoteViews = remoteViews;
+        this.viewId = viewId;
+        this.widgetIds = widgetIds;
+        componentName = null;
+    }
+
+    /**
+     * Constructor using an int array of widgetIds to get a handle on the Widget in order to update it that uses
+     * {@link #SIZE_ORIGINAL} as the target width and height.
+     *
+     * @param context     Context to use in the AppWidgetManager initialization.
+     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+     * @param viewId      The id of the ImageView view that will load the image.
+     * @param widgetIds   The int[] that contains the widget ids of an application.
+     */
+    public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int... widgetIds) {
+        this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, widgetIds);
+    }
+
+    /**
+     * Constructor using a ComponentName to get a handle on the Widget in order to update it.
+     *
+     * @param context     Context to use in the AppWidgetManager initialization.
+     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+     * @param viewId      The id of the ImageView view that will load the image.
+     * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be manually set
+     *                    because of RemoteViews limitations.)
+     * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be manually set
+     *                    because of RemoteViews limitations.)
+     * @param componentName   The ComponentName that refers to our AppWidget.
+     */
+    public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width, int height,
+            ComponentName componentName) {
+        super(width, height);
+        if (context == null) {
+            throw new NullPointerException("Context can not be null!");
+        }
+        if (componentName == null) {
+            throw new NullPointerException("ComponentName can not be null!");
+        }
+        if (remoteViews == null) {
+            throw new NullPointerException("RemoteViews object can not be null!");
+        }
+        this.context = context;
+        this.remoteViews = remoteViews;
+        this.viewId = viewId;
+        this.componentName = componentName;
+        widgetIds = null;
+    }
+
+    /**
+     * Constructor using a ComponentName, when override has been set to get a handle on the Widget in order to update
+     * it that uses {@link #SIZE_ORIGINAL} as the target width and height.
+     *
+     * @param context     Context to use in the AppWidgetManager initialization.
+     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+     * @param viewId      The id of the ImageView view that will load the image.
+     * @param componentName   The ComponentName that refers to our AppWidget.
+     */
+    public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, ComponentName componentName) {
+        this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, componentName);
+    }
+
+    /**
+     * Updates the AppWidget after the ImageView has loaded the Bitmap.
+     */
+    private void update() {
+        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this.context);
+        if (this.componentName != null) {
+            appWidgetManager.updateAppWidget(this.componentName, this.remoteViews);
+        } else {
+            appWidgetManager.updateAppWidget(this.widgetIds, this.remoteViews);
+        }
+    }
+
+    @Override
+    public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {
+        this.remoteViews.setImageViewBitmap(this.viewId, resource);
+        this.update();
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 24790c741..97e84f377 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -3,6 +3,7 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.resource.drawable.GlideDrawable;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
new file mode 100644
index 000000000..5f1f88b5b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.request.target;
+
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.widget.RemoteViews;
+
+import com.bumptech.glide.request.animation.GlideAnimation;
+
+/**
+ * This class is used to display downloaded Bitmap inside an ImageView of a Notification through RemoteViews.
+ *
+ * <p>
+ *     Note - For cancellation to work correctly, you must pass in the same instance of this class for every subsequent
+ *     load.
+ * </p>
+ */
+public class NotificationTarget extends SimpleTarget<Bitmap> {
+
+    private final RemoteViews remoteViews;
+    private final Context context;
+    private final int notificationId;
+    private final Notification notification;
+    private final int viewId;
+
+    /**
+     * Constructor using a Notification object and a notificationId to get a handle on the Notification in order to
+     * update it that uses {@link #SIZE_ORIGINAL} as the target width and height.
+     *
+     * @param context     Context to use in the AppWidgetManager initialization.
+     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+     * @param viewId      The id of the ImageView view that will load the image.
+     * @param notification The Notification object that we want to update.
+     * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+     */
+    public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, Notification notification,
+            int  notificationId) {
+        this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, notification, notificationId);
+    }
+
+    /**
+     * Constructor using a Notification object and a notificationId to get a handle on the Notification in order to
+     * update it.
+     *
+     * @param context     Context to use in the AppWidgetManager initialization.
+     * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+     * @param viewId      The id of the ImageView view that will load the image.
+     * @param width       Desired width of the bitmap that will be loaded.(Need to be manually set
+     *                    because of RemoteViews limitations.)
+     * @param height      Desired height of the bitmap that will be loaded. (Need to be manually set
+     *                    because of RemoteViews limitations.)
+     * @param notification The Notification object that we want to update.
+     * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+     */
+    public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, int width, int height,
+            Notification notification, int notificationId) {
+        super(width, height);
+        if (context == null) {
+            throw new NullPointerException("Context must not be null!");
+        }
+        if (notification == null) {
+            throw new NullPointerException("Notification object can not be null!");
+        }
+        if (remoteViews == null) {
+            throw new NullPointerException("RemoteViews object can not be null!");
+        }
+        this.context = context;
+        this.viewId = viewId;
+        this.notification = notification;
+        this.notificationId = notificationId;
+        this.remoteViews = remoteViews;
+    }
+
+    /**
+     * Updates the Notification after the Bitmap resource is loaded.
+     */
+    private void update() {
+        NotificationManager manager = (NotificationManager)
+                this.context.getSystemService(Context.NOTIFICATION_SERVICE);
+        manager.notify(this.notificationId, this.notification);
+    }
+
+    @Override
+    public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {
+        this.remoteViews.setImageViewBitmap(this.viewId, resource);
+        this.update();
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
index 8dfbe6008..a8a9b5a2d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
@@ -14,8 +14,8 @@
     /**
      * Returns a PreloadTarget.
      *
-     * @param width The width of the desired resourece.
-     * @param height The height of the desired resource.
+     * @param width The width in pixels of the desired resource.
+     * @param height The height in pixels of the desired resource.
      * @param <Z> The type of the desired resource.
      */
     public static <Z> PreloadTarget<Z> obtain(int width, int height) {
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index 78522c320..b3262c03d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request.target;
 
+import com.bumptech.glide.util.Util;
+
 /**
  * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop) implementations
  * of non essential methods that allows the caller to specify an exact width/height. Typicaly use cases look something
@@ -28,24 +30,17 @@
     private final int height;
 
     /**
-     * Constructor for the target that assumes you will have called
-     * {@link com.bumptech.glide.GenericRequestBuilder#override(int, int)} on the request builder this target is given
-     * to.
-     *
-     * <p>
-     *     Requests that load into this target will throw an {@link java.lang.IllegalArgumentException} if
-     *     {@link com.bumptech.glide.GenericRequestBuilder#override(int, int)} was not called on the request builder.
-     * </p>
+     * Constructor for the target that uses {@link Target#SIZE_ORIGINAL} as the target width and height.
      */
     public SimpleTarget() {
-        this(-1, -1);
+        this(SIZE_ORIGINAL, SIZE_ORIGINAL);
     }
 
     /**
      * Constructor for the target that takes the desired dimensions of the decoded and/or transformed resource.
      *
-     * @param width The desired width of the resource.
-     * @param height The desired height of the resource.
+     * @param width The width in pixels of the desired resource.
+     * @param height The height in pixels of the desired resource.
      */
     public SimpleTarget(int width, int height) {
         this.width = width;
@@ -59,9 +54,10 @@ public SimpleTarget(int width, int height) {
      */
     @Override
     public final void getSize(SizeReadyCallback cb) {
-        if (width <= 0 || height <= 0) {
-            throw new IllegalArgumentException("Width and height must both be > 0, but given width: " + width + " and"
-                    + " height: " + height + ", either provide dimensions in the constructor or call override()");
+        if (!Util.isValidDimensions(width, height)) {
+            throw new IllegalArgumentException("Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given"
+                    + " width: " + width + " and height: " + height + ", either provide dimensions in the constructor"
+                    + " or call override()");
         }
         cb.onSizeReady(width, height);
     }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java b/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
index eb382cd69..f492caf52 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
@@ -8,8 +8,10 @@
     /**
      * A callback called on the main thread.
      *
-     * @param width The width of the target.
-     * @param height The height of the target.
+     * @param width The width in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate that we want the
+     *              resource at its original width.
+     * @param height The height in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate that we want the
+     *               resource at its original height.
      */
     void onSizeReady(int width, int height);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java
index d19bba0d4..554529641 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request.target;
 
 import android.annotation.TargetApi;
+import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.PorterDuff;
@@ -17,12 +18,25 @@
  * that are not square.
  */
 public class SquaringDrawable extends GlideDrawable {
-    private final GlideDrawable wrapped;
-    private final int side;
+    private GlideDrawable wrapped;
+    private State state;
+    private boolean mutated;
 
     public SquaringDrawable(GlideDrawable wrapped, int side) {
-        this.wrapped = wrapped;
-        this.side = side;
+        this(new State(wrapped.getConstantState(), side), wrapped, null /*res*/);
+    }
+
+    SquaringDrawable(State state, GlideDrawable wrapped, Resources res) {
+        this.state = state;
+        if (wrapped == null) {
+          if (res != null) {
+            this.wrapped = (GlideDrawable) state.wrapped.newDrawable(res);
+          } else {
+            this.wrapped = (GlideDrawable) state.wrapped.newDrawable();
+          }
+        } else {
+          this.wrapped = wrapped;
+        }
     }
 
     @Override
@@ -91,12 +105,12 @@ public boolean setVisible(boolean visible, boolean restart) {
 
     @Override
     public int getIntrinsicWidth() {
-        return side;
+        return state.side;
     }
 
     @Override
     public int getIntrinsicHeight() {
-        return side;
+        return state.side;
     }
 
     @Override
@@ -176,4 +190,48 @@ public void stop() {
     public boolean isRunning() {
         return wrapped.isRunning();
     }
+
+    @Override
+    public Drawable mutate() {
+        if (!mutated && super.mutate() == this) {
+            wrapped = (GlideDrawable) wrapped.mutate();
+            state = new State(state);
+            mutated = true;
+        }
+        return this;
+    }
+
+    @Override
+    public ConstantState getConstantState() {
+        return state;
+    }
+
+    static class State extends ConstantState {
+        private final ConstantState wrapped;
+        private final int side;
+
+        State(State other) {
+          this(other.wrapped, other.side);
+        }
+
+        State(ConstantState wrapped, int side) {
+          this.wrapped = wrapped;
+          this.side = side;
+        }
+
+        @Override
+        public Drawable newDrawable() {
+          return newDrawable(null /*res*/);
+        }
+
+        @Override
+        public Drawable newDrawable(Resources res) {
+          return new SquaringDrawable(this, null /*wrapped*/, res);
+        }
+
+        @Override
+        public int getChangingConfigurations() {
+          return 0;
+        }
+    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 4613206fb..4ddd8cad5 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -27,6 +27,10 @@
  * @param <R> The type of resource the target can display.
  */
 public interface Target<R> extends LifecycleListener {
+    /**
+     * Indicates that we want the resource in its original unmodified width and/or height.
+     */
+    int SIZE_ORIGINAL = Integer.MIN_VALUE;
 
     /**
      * A lifecycle callback that is called when a load is started.
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index cff57f707..62e664dac 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -1,12 +1,16 @@
 package com.bumptech.glide.request.target;
 
+import android.annotation.TargetApi;
 import android.content.Context;
+import android.graphics.Point;
+import android.os.Build;
 import android.util.Log;
 import android.view.Display;
 import android.view.View;
-import android.view.ViewGroup;
+import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
+
 import com.bumptech.glide.request.Request;
 
 import java.lang.ref.WeakReference;
@@ -19,9 +23,9 @@
  * {@link android.view.ViewTreeObserver.OnDrawListener}.
  *
  * <p>
- *     To detect {@link View} reuse in {@link android.widget.ListView} or any {@link ViewGroup} that reuses views, this
- *     class uses the {@link View#setTag(Object)} method to store some metadata so that if a view is reused, any
- *     previous loads or resources from previous loads can be cancelled or reused.
+ *     To detect {@link View} reuse in {@link android.widget.ListView} or any {@link android.view.ViewGroup} that reuses
+ *     views, this class uses the {@link View#setTag(Object)} method to store some metadata so that if a view is reused,
+ *     any previous loads or resources from previous loads can be cancelled or reused.
  * </p>
  *
  * <p>
@@ -57,7 +61,7 @@ public T getView() {
     /**
      * Determines the size of the view by first checking {@link android.view.View#getWidth()} and
      * {@link android.view.View#getHeight()}. If one or both are zero, it then checks the view's
-     * {@link android.view.ViewGroup.LayoutParams}. If one or both of the params width and height are less than or
+     * {@link LayoutParams}. If one or both of the params width and height are less than or
      * equal to zero, it then adds an {@link android.view.ViewTreeObserver.OnPreDrawListener} which waits until the view
      * has been measured before calling the callback with the view's drawn width and height.
      *
@@ -110,9 +114,14 @@ public String toString() {
     }
 
     private static class SizeDeterminer {
+        // Some negative sizes (WRAP_CONTENT) are valid, 0 is never valid.
+        private static final int PENDING_SIZE = 0;
+
         private final View view;
         private final List<SizeReadyCallback> cbs = new ArrayList<SizeReadyCallback>();
+
         private SizeDeterminerLayoutListener layoutListener;
+        private Point displayDimens;
 
         public SizeDeterminer(View view) {
             this.view = view;
@@ -130,48 +139,31 @@ private void checkCurrentDimens() {
                 return;
             }
 
-            boolean calledCallback = true;
-            ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            if (isViewSizeValid()) {
-                notifyCbs(view.getWidth(), view.getHeight());
-            } else if (isLayoutParamsSizeValid()) {
-                notifyCbs(layoutParams.width, layoutParams.height);
-            } else {
-                calledCallback = false;
+            int currentWidth = getViewWidthOrParam();
+            int currentHeight = getViewHeightOrParam();
+            if (!isSizeValid(currentWidth) || !isSizeValid(currentHeight)) {
+                return;
             }
 
-            if (calledCallback) {
-                // Keep a reference to the layout listener and remove it here
-                // rather than having the observer remove itself because the observer
-                // we add the listener to will be almost immediately merged into
-                // another observer and will therefore never be alive. If we instead
-                // keep a reference to the listener and remove it here, we get the
-                // current view tree observer and should succeed.
-                ViewTreeObserver observer = view.getViewTreeObserver();
-                if (observer.isAlive()) {
-                    observer.removeOnPreDrawListener(layoutListener);
-                }
-                layoutListener = null;
+            notifyCbs(currentWidth, currentHeight);
+            // Keep a reference to the layout listener and remove it here
+            // rather than having the observer remove itself because the observer
+            // we add the listener to will be almost immediately merged into
+            // another observer and will therefore never be alive. If we instead
+            // keep a reference to the listener and remove it here, we get the
+            // current view tree observer and should succeed.
+            ViewTreeObserver observer = view.getViewTreeObserver();
+            if (observer.isAlive()) {
+                observer.removeOnPreDrawListener(layoutListener);
             }
+            layoutListener = null;
         }
 
         public void getSize(SizeReadyCallback cb) {
-            ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            if (isViewSizeValid()) {
-                cb.onSizeReady(view.getWidth(), view.getHeight());
-            } else if (isLayoutParamsSizeValid()) {
-                cb.onSizeReady(layoutParams.width, layoutParams.height);
-            } else if (isUsingWrapContent()) {
-                WindowManager windowManager =
-                        (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
-                Display display = windowManager.getDefaultDisplay();
-                @SuppressWarnings("deprecation") final int width = display.getWidth(), height = display.getHeight();
-                if (Log.isLoggable(TAG, Log.WARN)) {
-                    Log.w(TAG, "Trying to load image into ImageView using WRAP_CONTENT, defaulting to screen"
-                            + " dimensions: [" + width + "x" + height + "]. Give the view an actual width and height "
-                            + " for better performance.");
-                }
-                cb.onSizeReady(width, height);
+            int currentWidth = getViewWidthOrParam();
+            int currentHeight = getViewHeightOrParam();
+            if (isSizeValid(currentWidth) && isSizeValid(currentHeight)) {
+                cb.onSizeReady(currentWidth, currentHeight);
             } else {
                 // We want to notify callbacks in the order they were added and we only expect one or two callbacks to
                 // be added a time, so a List is a reasonable choice.
@@ -186,19 +178,56 @@ public void getSize(SizeReadyCallback cb) {
             }
         }
 
-        private boolean isViewSizeValid() {
-            return view.getWidth() > 0 && view.getHeight() > 0;
+        private int getViewHeightOrParam() {
+            final LayoutParams layoutParams = view.getLayoutParams();
+            if (isSizeValid(view.getHeight())) {
+                return view.getHeight();
+            } else if (layoutParams != null) {
+                return getSizeForParam(layoutParams.height, true /*isHeight*/);
+            } else {
+                return PENDING_SIZE;
+            }
         }
 
-        private boolean isUsingWrapContent() {
-            final ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            return layoutParams != null && (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT
-                    || layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT);
+        private int getViewWidthOrParam() {
+            final LayoutParams layoutParams = view.getLayoutParams();
+            if (isSizeValid(view.getWidth())) {
+                return view.getWidth();
+            } else if (layoutParams != null) {
+                return getSizeForParam(layoutParams.width, false /*isHeight*/);
+            } else {
+                return PENDING_SIZE;
+            }
+        }
+
+        private int getSizeForParam(int param, boolean isHeight) {
+            if (param == LayoutParams.WRAP_CONTENT) {
+                Point displayDimens = getDisplayDimens();
+                return isHeight ? displayDimens.y : displayDimens.x;
+            } else {
+                return param;
+            }
+        }
+
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+        @SuppressWarnings("deprecation")
+        private Point getDisplayDimens() {
+            if (displayDimens != null) {
+                return displayDimens;
+            }
+            WindowManager windowManager = (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
+            Display display = windowManager.getDefaultDisplay();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+                displayDimens = new Point();
+                display.getSize(displayDimens);
+            } else {
+                displayDimens = new Point(display.getWidth(), display.getHeight());
+            }
+            return displayDimens;
         }
 
-        private boolean isLayoutParamsSizeValid() {
-            final ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            return layoutParams != null && layoutParams.width > 0 && layoutParams.height > 0;
+        private boolean isSizeValid(int size) {
+            return size > 0 || size == LayoutParams.WRAP_CONTENT;
         }
 
         private static class SizeDeterminerLayoutListener implements ViewTreeObserver.OnPreDrawListener {
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 667b3dff8..1ea2ca10c 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+
 import com.bumptech.glide.load.Key;
 
 import java.util.UUID;
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index 4774a69bf..dbeb876de 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -15,6 +15,18 @@
     private final long dateModified;
     private final int orientation;
 
+    /**
+     * Constructor for {@link com.bumptech.glide.signature.MediaStoreSignature}.
+     *
+     * @param mimeType The mime type of the media store media. Ok to default to empty string "". See
+     *      {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or
+     *      {@link android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}.
+     * @param dateModified The date modified time of the media store media. Ok to default to 0. See
+     *      {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or
+     *      {@link android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}.
+     * @param orientation The orientation of the media store media. Ok to default to 0. See
+     *      {@link android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
+     */
     public MediaStoreSignature(String mimeType, long dateModified, int orientation) {
         this.mimeType = mimeType;
         this.dateModified = dateModified;
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
new file mode 100644
index 000000000..f6b001385
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -0,0 +1,30 @@
+package com.bumptech.glide.util;
+
+import com.bumptech.glide.ListPreloader;
+
+import java.util.Arrays;
+
+/**
+ * A {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} with a fixed width and height.
+ *
+ * @param <T> The type of the model the size should be provided for.
+ */
+public class FixedPreloadSizeProvider<T> implements ListPreloader.PreloadSizeProvider<T> {
+
+    private final int[] size;
+
+    /**
+     * Constructor for a PreloadSizeProvider with a fixed size.
+     *
+     * @param width  The width of the preload size in pixels.
+     * @param height The height of the preload size in pixels.
+     */
+    public FixedPreloadSizeProvider(int width, int height) {
+        this.size = new int[]{width, height};
+    }
+
+    @Override
+    public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
+        return Arrays.copyOf(this.size, this.size.length);
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
new file mode 100644
index 000000000..222ffc389
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
@@ -0,0 +1,87 @@
+package com.bumptech.glide.util;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Prevents {@link InputStream InputStreams} from overflowing their buffer by reading data past their read limit.
+ */
+public class MarkEnforcingInputStream extends FilterInputStream {
+    private static final int UNSET = Integer.MIN_VALUE;
+    private static final int END_OF_STREAM = -1;
+
+    private int availableBytes = UNSET;
+
+    public MarkEnforcingInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public void mark(int readlimit) {
+        super.mark(readlimit);
+        availableBytes = readlimit;
+    }
+
+    @Override
+    public int read() throws IOException {
+        if (getBytesToRead(1) == END_OF_STREAM) {
+            return END_OF_STREAM;
+        }
+
+        int result = super.read();
+        updateAvailableBytesAfterRead(1 /* bytesRead */);
+        return result;
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        int toRead = (int) getBytesToRead(byteCount);
+        if (toRead == END_OF_STREAM) {
+            return END_OF_STREAM;
+        }
+
+        int read = super.read(buffer, byteOffset, toRead);
+        updateAvailableBytesAfterRead(read);
+        return read;
+    }
+
+    @Override
+    public void reset() throws IOException {
+        super.reset();
+        availableBytes = UNSET;
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+        long toSkip = getBytesToRead(byteCount);
+        if (toSkip == END_OF_STREAM) {
+            return END_OF_STREAM;
+        }
+
+        long read = super.skip(toSkip);
+        updateAvailableBytesAfterRead(read);
+        return read;
+    }
+
+    @Override
+    public int available() throws IOException {
+        return availableBytes == UNSET ? super.available() : Math.min(availableBytes, super.available());
+    }
+
+    private long getBytesToRead(long targetByteCount) {
+        if (availableBytes == 0) {
+            return END_OF_STREAM;
+        } else if (availableBytes != UNSET && targetByteCount > availableBytes) {
+            return availableBytes;
+        } else {
+            return targetByteCount;
+        }
+    }
+
+    private void updateAvailableBytesAfterRead(long bytesRead) {
+        if (availableBytes != UNSET && bytesRead != END_OF_STREAM) {
+            availableBytes -= bytesRead;
+        }
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 5d03cfddb..b2dff176b 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -5,6 +5,8 @@
 import android.os.Build;
 import android.os.Looper;
 
+import com.bumptech.glide.request.target.Target;
+
 import java.util.ArrayDeque;
 import java.util.Queue;
 
@@ -26,14 +28,18 @@ private Util() {
      * Returns the hex string of the given byte array representing a SHA256 hash.
      */
     public static String sha256BytesToHex(byte[] bytes) {
-        return bytesToHex(bytes, SHA_256_CHARS);
+        synchronized (SHA_256_CHARS) {
+            return bytesToHex(bytes, SHA_256_CHARS);
+        }
     }
 
     /**
      * Returns the hex string of the given byte array representing a SHA1 hash.
      */
     public static String sha1BytesToHex(byte[] bytes) {
-        return bytesToHex(bytes, SHA_1_CHARS);
+        synchronized (SHA_1_CHARS) {
+            return bytesToHex(bytes, SHA_1_CHARS);
+        }
     }
 
     // Taken from:
@@ -53,7 +59,8 @@ private static String bytesToHex(byte[] bytes, char[] hexChars) {
      *
      * @see #getBitmapByteSize(android.graphics.Bitmap)
      *
-     * @deprecated
+     * @deprecated Use {@link #getBitmapByteSize(android.graphics.Bitmap)} instead. Scheduled to be removed in Glide
+     * 4.0.
      */
     @Deprecated
     public static int getSize(Bitmap bitmap) {
@@ -106,6 +113,17 @@ private static int getBytesPerPixel(Bitmap.Config config) {
         return bytesPerPixel;
     }
 
+    /**
+     * Returns true if width and height are both > 0 and/or equal to {@link Target#SIZE_ORIGINAL}.
+     */
+    public static boolean isValidDimensions(int width, int height) {
+        return isValidDimension(width) && isValidDimension(height);
+    }
+
+    private static boolean isValidDimension(int dimen) {
+        return dimen > 0 || dimen == Target.SIZE_ORIGINAL;
+    }
+
     /**
      * Throws an {@link java.lang.IllegalArgumentException} if called on a thread other than the main thread.
      */
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
new file mode 100644
index 000000000..ec309b634
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -0,0 +1,87 @@
+package com.bumptech.glide.util;
+
+import android.view.View;
+
+import com.bumptech.glide.ListPreloader;
+import com.bumptech.glide.request.animation.GlideAnimation;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.ViewTarget;
+
+import java.util.Arrays;
+
+/**
+ * A {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} that will extract the preload size from a given
+ * {@link android.view.View}.
+ *
+ * @param <T> The type of the model the size should be provided for.
+ */
+public class ViewPreloadSizeProvider<T> implements ListPreloader.PreloadSizeProvider<T>, SizeReadyCallback {
+    private int[] size;
+    // We need to keep a strong reference to the Target so that it isn't garbage collected due to a weak reference
+    // while we're waiting to get its size.
+    @SuppressWarnings("unused")
+    private SizeViewTarget viewTarget;
+
+    /**
+     * Constructor that does nothing by default and requires users to call {@link #setView(android.view.View)} when a
+     * View is available to registerComponents the dimensions returned by this class.
+     */
+    public ViewPreloadSizeProvider() {
+        // This constructor is intentionally empty. Nothing special is needed here.
+    }
+
+    /**
+     * Constructor that will extract the preload size from a given {@link android.view.View}.
+     *
+     * @param view A not null View the size will be extracted from async using an {@link android.view.ViewTreeObserver
+     *             .OnPreDrawListener}
+     */
+    public ViewPreloadSizeProvider(View view) {
+        setView(view);
+    }
+
+    @Override
+    public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
+        if (size == null) {
+            return null;
+        } else {
+            return Arrays.copyOf(this.size, this.size.length);
+        }
+    }
+
+    @Override
+    public void onSizeReady(int width, int height) {
+        this.size = new int[]{width, height};
+        viewTarget = null;
+    }
+
+    /**
+     * Sets the {@link android.view.View} the size will be extracted.
+     *
+     * <p>
+     *     Note - only the first call to this method will be obeyed, subsequent requests will be ignored.
+     * </p>
+     *
+     * @param view A not null View the size will be extracted async with an {@link android.view.ViewTreeObserver
+     *             .OnPreDrawListener}
+     */
+    public void setView(View view) {
+        if (this.size != null || viewTarget != null) {
+            return;
+        }
+        this.viewTarget = new SizeViewTarget(view, this);
+    }
+
+    private static final class SizeViewTarget extends ViewTarget<View, Object> {
+
+        public SizeViewTarget(View view, SizeReadyCallback callback) {
+            super(view);
+            getSize(callback);
+        }
+
+        @Override
+        public void onResourceReady(Object resource, GlideAnimation glideAnimation) {
+            // Do nothing
+        }
+    }
+}
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index e69537c81..b4b13e7b3 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -2,19 +2,20 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
-    compile 'com.android.support:support-v4:19.1.+'
-    compile 'com.android.support:appcompat-v7:19.1.+'
-    compile 'com.mcxiaoke.volley:library:1.0.+'
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
+    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.flickr'
-        minSdkVersion 10
-        targetSdkVersion 19
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
         versionCode 1
         versionName '1.0.0'
     }
diff --git a/samples/flickr/flickr.iml b/samples/flickr/flickr.iml
new file mode 100644
index 000000000..6198370d6
--- /dev/null
+++ b/samples/flickr/flickr.iml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":samples:flickr" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.samples" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":samples:flickr" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Maven Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" name="appcompat-v7-19.1.0" level="project" />
+    <orderEntry type="library" exported="" name="support-v4-19.1.0" level="project" />
+    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />
+    <orderEntry type="module" module-name="library" exported="" />
+    <orderEntry type="module" module-name="disklrucache" exported="" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index 242d2cd15..338a135dc 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -23,6 +23,9 @@
 
     <activity android:name=".FullscreenActivity" />
 
+    <meta-data
+        android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
+        android:value="GlideModule" />
   </application>
 
 </manifest>
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
new file mode 100644
index 000000000..a018b268d
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.samples.flickr;
+
+import android.content.Context;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.samples.flickr.api.Photo;
+
+import java.io.InputStream;
+
+/**
+ * {@link com.bumptech.glide.module.GlideModule} for the Flickr sample app.
+ */
+public class FlickrGlideModule implements GlideModule {
+    @Override
+    public void applyOptions(Context context, GlideBuilder builder) {
+        // Do nothing.
+    }
+
+    @Override
+    public void registerComponents(Context context, Glide glide) {
+        glide.register(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
+    }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index ea702047c..9df6d1853 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
+
+import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
-import com.bumptech.glide.load.model.GenericLoaderFactory;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index b6393a7a0..34dff7198 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -9,6 +9,7 @@
 import android.widget.BaseAdapter;
 import android.widget.GridView;
 import android.widget.ImageView;
+
 import com.bumptech.glide.DrawableRequestBuilder;
 import com.bumptech.glide.GenericRequestBuilder;
 import com.bumptech.glide.Glide;
@@ -17,6 +18,7 @@
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
+import com.bumptech.glide.util.FixedPreloadSizeProvider;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -70,12 +72,18 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
         preloadRequest = thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
 
         final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
+
         grid = (GridView) result.findViewById(R.id.images);
         grid.setColumnWidth(photoSize);
-        final FlickrPreloader preloader = new FlickrPreloader(args.getInt(PRELOAD_KEY));
-        grid.setOnScrollListener(preloader);
         adapter = new PhotoAdapter();
         grid.setAdapter(adapter);
+
+        final FixedPreloadSizeProvider<Photo> preloadSizeProvider =
+                new FixedPreloadSizeProvider<Photo>(photoSize, photoSize);
+        final ListPreloader<Photo> preloader =
+                new ListPreloader<Photo>(adapter, preloadSizeProvider, args.getInt(PRELOAD_KEY));
+        grid.setOnScrollListener(preloader);
+
         if (currentPhotos != null) {
             adapter.setPhotos(currentPhotos);
         }
@@ -105,30 +113,7 @@ public void onPhotosUpdated(List<Photo> photos) {
         }
     }
 
-    private class FlickrPreloader extends ListPreloader<Photo> {
-        private final int[] dimens = new int[] { photoSize, photoSize };
-
-        public FlickrPreloader(int toPreload) {
-            super(toPreload);
-        }
-
-        @Override
-        protected int[] getDimensions(Photo item) {
-            return dimens;
-        }
-
-        @Override
-        protected List<Photo> getItems(int start, int end) {
-            return currentPhotos.subList(start, end);
-        }
-
-        @Override
-        protected GenericRequestBuilder getRequestBuilder(Photo item) {
-            return preloadRequest.load(item);
-        }
-    }
-
-    private class PhotoAdapter extends BaseAdapter {
+    private class PhotoAdapter extends BaseAdapter implements ListPreloader.PreloadModelProvider<Photo> {
         private List<Photo> photos = new ArrayList<Photo>(0);
         private final LayoutInflater inflater;
 
@@ -184,5 +169,15 @@ public void onClick(View view) {
 
             return imageView;
         }
+
+        @Override
+        public List<Photo> getPreloadItems(int position) {
+            return photos.subList(position, position + 1);
+        }
+
+        @Override
+        public GenericRequestBuilder getPreloadRequestBuilder(Photo item) {
+            return preloadRequest.load(item);
+        }
     }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index 90a03b4cc..286c817ab 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -12,6 +12,7 @@
 import android.widget.ImageView;
 import android.widget.ListView;
 import android.widget.TextView;
+
 import com.bumptech.glide.DrawableRequestBuilder;
 import com.bumptech.glide.GenericRequestBuilder;
 import com.bumptech.glide.Glide;
@@ -19,6 +20,7 @@
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
+import com.bumptech.glide.util.ViewPreloadSizeProvider;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -27,14 +29,15 @@
  * A fragment that shows cropped image thumbnails half the width of the screen in a scrolling list.
  */
 public class FlickrPhotoList extends Fragment implements PhotoViewer {
+    private static final int PRELOAD_AHEAD_ITEMS = 5;
     private static final String STATE_POSITION_INDEX = "state_position_index";
     private static final String STATE_POSITION_OFFSET = "state_position_offset";
     private FlickrPhotoListAdapter adapter;
     private List<Photo> currentPhotos;
-    private FlickrListPreloader preloader;
     private ListView list;
     private DrawableRequestBuilder<Photo> fullRequest;
     private DrawableRequestBuilder<Photo> thumbRequest;
+    private ViewPreloadSizeProvider<Photo> preloadSizeProvider;
 
     public static FlickrPhotoList newInstance() {
         return new FlickrPhotoList();
@@ -54,8 +57,11 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
         list = (ListView) result.findViewById(R.id.flickr_photo_list);
         adapter = new FlickrPhotoListAdapter();
         list.setAdapter(adapter);
-        preloader = new FlickrListPreloader(5);
+
+        preloadSizeProvider = new ViewPreloadSizeProvider<Photo>();
+        ListPreloader<Photo> preloader = new ListPreloader<Photo>(adapter, preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
         list.setOnScrollListener(preloader);
+
         if (currentPhotos != null) {
             adapter.setPhotos(currentPhotos);
         }
@@ -101,42 +107,7 @@ public ViewHolder(ImageView imageView, TextView titleText) {
         }
     }
 
-    private class FlickrListPreloader extends ListPreloader<Photo> {
-        private int[] photoDimens = null;
-
-        public FlickrListPreloader(int maxPreload) {
-            super(maxPreload);
-        }
-
-        public boolean isDimensSet() {
-            return photoDimens != null;
-        }
-
-        public void setDimens(int width, int height) {
-            if (photoDimens == null) {
-                photoDimens = new int[] { width, height };
-            }
-        }
-
-        @Override
-        protected int[] getDimensions(Photo item) {
-            return photoDimens;
-        }
-
-        @Override
-        protected List<Photo> getItems(int start, int end) {
-            return currentPhotos.subList(start, end);
-        }
-
-        @Override
-        protected GenericRequestBuilder getRequestBuilder(Photo item) {
-            return fullRequest
-                    .thumbnail(thumbRequest.load(item))
-                    .load(item);
-        }
-    }
-
-    private class FlickrPhotoListAdapter extends BaseAdapter {
+    private class FlickrPhotoListAdapter extends BaseAdapter implements ListPreloader.PreloadModelProvider<Photo> {
         private final LayoutInflater inflater;
         private List<Photo> photos = new ArrayList<Photo>(0);
 
@@ -174,14 +145,7 @@ public View getView(int position, View view, ViewGroup container) {
                 TextView titleView = (TextView) view.findViewById(R.id.title_view);
                 viewHolder = new ViewHolder(imageView, titleView);
                 view.setTag(viewHolder);
-                if (!preloader.isDimensSet()) {
-                    imageView.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            preloader.setDimens(imageView.getWidth(), imageView.getHeight());
-                        }
-                    });
-                }
+                preloadSizeProvider.setView(imageView);
             } else {
                 viewHolder = (ViewHolder) view.getTag();
             }
@@ -193,7 +157,7 @@ public void run() {
 
             viewHolder.imageView.setOnClickListener(new View.OnClickListener() {
                 @Override
-               public void onClick(View view) {
+                public void onClick(View view) {
                     Intent intent = FullscreenActivity.getIntent(getActivity(), current);
                     startActivity(intent);
                 }
@@ -202,5 +166,17 @@ public void onClick(View view) {
             viewHolder.titleText.setText(current.getTitle());
             return view;
         }
+
+        @Override
+        public List<Photo> getPreloadItems(int position) {
+            return photos.subList(position, position + 1);
+        }
+
+        @Override
+        public GenericRequestBuilder getPreloadRequestBuilder(Photo item) {
+            return fullRequest
+                    .thumbnail(thumbRequest.load(item))
+                    .load(item);
+        }
     }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index ad1738f6d..4b57a0e33 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -25,14 +25,14 @@
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.TextView;
+
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.engine.prefill.PreFillBitmapAttribute;
+import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
 import java.io.File;
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -89,7 +89,6 @@ public void onAttachFragment(Fragment fragment) {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        Glide.get(this).register(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
         backgroundThread = new HandlerThread("BackgroundThumbnailHandlerThread");
         backgroundThread.start();
         backgroundHandler = new Handler(backgroundThread.getLooper());
@@ -166,9 +165,9 @@ public void onPageScrollStateChanged(int i) { }
         // Weight values determined experimentally by measuring the number of incurred GCs while scrolling through
         // the various photo grids/lists.
         Glide.get(this).preFillBitmapPool(
-                new PreFillBitmapAttribute(smallGridSize, smallGridSize, 1),
-                new PreFillBitmapAttribute(mediumGridSize, mediumGridSize, 1),
-                new PreFillBitmapAttribute(screenWidth / 2, listHeightSize, 6));
+                new PreFillType.Builder(smallGridSize).setWeight(1),
+                new PreFillType.Builder(mediumGridSize).setWeight(1),
+                new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
     }
 
     private int getScreenWidth() {
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index cd78f1092..58087bec1 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -5,6 +5,7 @@
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.widget.ImageView;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index b959aaada..8d32281df 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -1,18 +1,10 @@
 package com.bumptech.glide.samples.flickr.api;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import android.content.Context;
-import android.util.Log;
-
 import android.text.TextUtils;
+import android.util.Log;
 import android.util.SparseArray;
+
 import com.android.volley.DefaultRetryPolicy;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
@@ -21,7 +13,14 @@
 import com.android.volley.toolbox.StringRequest;
 import com.android.volley.toolbox.Volley;
 
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 
 /**
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index 9e73ae18b..f015fc355 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -2,6 +2,7 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
+
 import org.json.JSONException;
 import org.json.JSONObject;
 
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index 6b137e441..0cd221353 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -6,13 +6,13 @@ dependencies {
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
         minSdkVersion 14
-        targetSdkVersion 19
+        targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
         versionName '1.0.0'
     }
diff --git a/samples/giphy/giphy.iml b/samples/giphy/giphy.iml
new file mode 100644
index 000000000..2ae755202
--- /dev/null
+++ b/samples/giphy/giphy.iml
@@ -0,0 +1,91 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":samples:giphy" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.samples" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":samples:giphy" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Maven Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" name="gson-2.2.4" level="project" />
+    <orderEntry type="library" exported="" name="support-v4-19.1.0" level="project" />
+    <orderEntry type="module" module-name="library" exported="" />
+    <orderEntry type="module" module-name="disklrucache" exported="" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index ea0809f59..5d353dcbc 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -6,6 +6,7 @@
     <application
         android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
+        android:largeHeap="true"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
@@ -17,6 +18,11 @@
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
+        <activity android:name=".FullscreenActivity" />
+
+        <meta-data
+            android:name="com.bumptech.glide.samples.giphy.GiphyGlideModule"
+            android:value="GlideModule" />
     </application>
 
 </manifest>
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index 26d71ffdc..eb61bbe36 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.samples.giphy;
 
+import com.google.gson.Gson;
+
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
 
-import com.google.gson.Gson;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -19,7 +19,7 @@
  * A java wrapper for Giphy's http api based on https://github.com/Giphy/GiphyAPI.
  */
 public final class Api {
-    private static Api api = null;
+    private static volatile Api api = null;
     private static final String BETA_KEY = "dc6zaTOxFJmzC";
     private static final String BASE_URL = "http://api.giphy.com";
     private static final String SEARCH_PATH = "/v1/gifs/search";
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
new file mode 100644
index 000000000..2599dc31f
--- /dev/null
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.samples.giphy;
+
+import com.google.gson.Gson;
+
+import android.app.Activity;
+import android.content.ClipData;
+import android.content.ClipboardManager;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.drawable.GlideDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.transcode.BitmapToGlideDrawableTranscoder;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * An {@link android.app.Activity} for displaying full size original GIFs.
+ */
+public class FullscreenActivity extends Activity {
+    private static final String EXTRA_RESULT_JSON = "result_json";
+    private GifDrawable gifDrawable;
+
+    public static Intent getIntent(Context context, Api.GifResult result) {
+        Intent intent = new Intent(context, FullscreenActivity.class);
+        intent.putExtra(EXTRA_RESULT_JSON, new Gson().toJson(result));
+        return intent;
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.fullscreen_activity);
+
+        String resultJson = getIntent().getStringExtra(EXTRA_RESULT_JSON);
+        final Api.GifResult result = new Gson().fromJson(resultJson, Api.GifResult.class);
+
+        ImageView gifView = (ImageView) findViewById(R.id.fullscreen_gif);
+
+        gifView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
+                ClipData clip = ClipData.newPlainText("giphy_url", result.images.original.url);
+                clipboard.setPrimaryClip(clip);
+
+                if (gifDrawable != null) {
+                    if (gifDrawable.isRunning()) {
+                        gifDrawable.stop();
+                    } else {
+                        gifDrawable.start();
+                    }
+                }
+            }
+        });
+
+        Glide.with(this)
+                .load(result.images.original.url)
+                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
+                .thumbnail(Glide.with(this)
+                        .load(result)
+                        .asBitmap()
+                        .transcode(new BitmapToGlideDrawableTranscoder(this), GlideDrawable.class)
+                        .diskCacheStrategy(DiskCacheStrategy.SOURCE)
+                )
+                .listener(new RequestListener<Object, GlideDrawable>() {
+                    @Override
+                    public boolean onException(Exception e, Object model, Target<GlideDrawable> target,
+                            boolean isFirstResource) {
+                        return false;
+                    }
+
+                    @Override
+                    public boolean onResourceReady(GlideDrawable resource, Object model, Target<GlideDrawable> target,
+                            boolean isFromMemoryCache, boolean isFirstResource) {
+                        if (resource instanceof GifDrawable) {
+                            gifDrawable = (GifDrawable) resource;
+                        } else {
+                            gifDrawable = null;
+                        }
+                        return false;
+                    }
+                })
+                .into(gifView);
+    }
+}
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
new file mode 100644
index 000000000..4913e778a
--- /dev/null
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.samples.giphy;
+
+import android.content.Context;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.module.GlideModule;
+
+import java.io.InputStream;
+
+/**
+ * {@link com.bumptech.glide.module.GlideModule} implementation for the Giphy sample app.
+ */
+public class GiphyGlideModule implements GlideModule {
+    @Override
+    public void applyOptions(Context context, GlideBuilder builder) {
+        // Do nothing.
+    }
+
+    @Override
+    public void registerComponents(Context context, Glide glide) {
+        glide.register(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
+    }
+}
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index c501b2cd1..c27dbfa0f 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -55,6 +55,5 @@ protected String getUrl(Api.GifResult model, int width, int height) {
 
     private static int getDifference(Api.GifImage gifImage, int width, int height) {
         return Math.abs(width - gifImage.width) + Math.abs(height - gifImage.height);
-
     }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index e8b25e716..a99cbdc25 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -1,6 +1,10 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.app.Activity;
+import android.content.ClipData;
+import android.content.ClipboardManager;
+import android.content.Context;
+import android.content.Intent;
 import android.os.Bundle;
 import android.util.Log;
 import android.view.View;
@@ -8,12 +12,14 @@
 import android.widget.BaseAdapter;
 import android.widget.ImageView;
 import android.widget.ListView;
+
 import com.bumptech.glide.DrawableRequestBuilder;
 import com.bumptech.glide.GenericRequestBuilder;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.util.ViewPreloadSizeProvider;
 
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -24,15 +30,12 @@
     private static final String TAG = "GiphyActivity";
 
     private GifAdapter adapter;
-    private DrawableRequestBuilder<Api.GifResult> fullRequest;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
 
-        Glide.get(this).register(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
-        Api.get().getTrending();
 
         ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
         Glide.with(this)
@@ -41,14 +44,16 @@ protected void onCreate(Bundle savedInstanceState) {
                 .into(giphyLogoView);
 
         ListView gifList = (ListView) findViewById(R.id.gif_list);
-        GiphyPreloader preloader = new GiphyPreloader(2);
 
-        fullRequest = Glide.with(this)
+        DrawableRequestBuilder<Api.GifResult> gifItemRequest = Glide.with(this)
                 .from(Api.GifResult.class)
+                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
                 .fitCenter();
 
-        adapter = new GifAdapter(this, preloader, fullRequest);
+        ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider = new ViewPreloadSizeProvider<Api.GifResult>();
+        adapter = new GifAdapter(this, gifItemRequest, preloadSizeProvider);
         gifList.setAdapter(adapter);
+        ListPreloader<Api.GifResult> preloader = new ListPreloader<Api.GifResult>(adapter, preloadSizeProvider, 2);
         gifList.setOnScrollListener(preloader);
     }
 
@@ -56,6 +61,9 @@ protected void onCreate(Bundle savedInstanceState) {
     protected void onStart() {
         super.onStart();
         Api.get().addMonitor(this);
+        if (adapter.getCount() == 0) {
+            Api.get().getTrending();
+        }
     }
 
     @Override
@@ -69,48 +77,20 @@ public void onSearchComplete(Api.SearchResult result) {
         adapter.setResults(result.data);
     }
 
-    private class GiphyPreloader extends ListPreloader<Api.GifResult> {
-
-        private int[] dimensions;
-
-        public GiphyPreloader(int maxPreload) {
-            super(maxPreload);
-        }
-
-        @Override
-        protected int[] getDimensions(Api.GifResult item) {
-            return dimensions;
-        }
-
-        @Override
-        protected List<Api.GifResult> getItems(int start, int end) {
-            List<Api.GifResult> items = new ArrayList<Api.GifResult>(end - start);
-            for (int i = start; i < end; i++) {
-                items.add(adapter.getItem(i));
-            }
-            return items;
-        }
-
-        @Override
-        protected GenericRequestBuilder getRequestBuilder(Api.GifResult item) {
-            return fullRequest.load(item);
-        }
-    }
-
-    private static class GifAdapter extends BaseAdapter {
+    private static class GifAdapter extends BaseAdapter implements ListPreloader.PreloadModelProvider<Api.GifResult> {
         private static final Api.GifResult[] EMPTY_RESULTS = new Api.GifResult[0];
 
         private final Activity activity;
-        private final GiphyPreloader preloader;
         private DrawableRequestBuilder<Api.GifResult> requestBuilder;
+        private ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
 
         private Api.GifResult[] results = EMPTY_RESULTS;
 
-        public GifAdapter(Activity activity, GiphyPreloader preloader,
-                DrawableRequestBuilder<Api.GifResult> requestBuilder) {
+        public GifAdapter(Activity activity, DrawableRequestBuilder<Api.GifResult> requestBuilder,
+                ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider) {
             this.activity = activity;
-            this.preloader = preloader;
             this.requestBuilder = requestBuilder;
+            this.preloadSizeProvider = preloadSizeProvider;
         }
 
         public void setResults(Api.GifResult[] results) {
@@ -143,30 +123,43 @@ public View getView(int position, View convertView, ViewGroup parent) {
                 convertView = activity.getLayoutInflater().inflate(R.layout.gif_list_item, parent, false);
             }
 
-            Api.GifResult result = results[position];
+            final Api.GifResult result = results[position];
             if (Log.isLoggable(TAG, Log.DEBUG)) {
                 Log.d(TAG, "load result: " + result);
             }
             final ImageView gifView = (ImageView) convertView.findViewById(R.id.gif_view);
+            gifView.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    ClipboardManager clipboard =
+                            (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+                    ClipData clip = ClipData.newPlainText("giphy_url", result.images.fixed_height_downsampled.url);
+                    clipboard.setPrimaryClip(clip);
+
+                    Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
+                    activity.startActivity(fullscreenIntent);
+                }
+            });
 
             requestBuilder
                     .load(result)
                     .into(gifView);
 
-            if (preloader.dimensions == null) {
-                gifView.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (gifView.getWidth() > 0 && gifView.getHeight() > 0) {
-                            preloader.dimensions = new int[2];
-                            preloader.dimensions[0] = gifView.getWidth();
-                            preloader.dimensions[1] = gifView.getHeight();
-                        }
-                    }
-                });
-            }
+            preloadSizeProvider.setView(gifView);
 
             return convertView;
         }
+
+        @Override
+        public List<Api.GifResult> getPreloadItems(int position) {
+            List<Api.GifResult> items = new ArrayList<Api.GifResult>(1);
+            items.add(getItem(position));
+            return items;
+        }
+
+        @Override
+        public GenericRequestBuilder getPreloadRequestBuilder(Api.GifResult item) {
+            return requestBuilder.load(item);
+        }
     }
 }
diff --git a/samples/giphy/src/main/res/layout/fullscreen_activity.xml b/samples/giphy/src/main/res/layout/fullscreen_activity.xml
new file mode 100644
index 000000000..09967b3e9
--- /dev/null
+++ b/samples/giphy/src/main/res/layout/fullscreen_activity.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ImageView
+   xmlns:android="http://schemas.android.com/apk/res/android"
+   android:id="@+id/fullscreen_gif"
+   android:layout_width="match_parent"
+   android:layout_height="match_parent"/>
diff --git a/samples/giphy/src/main/res/layout/gif_list_item.xml b/samples/giphy/src/main/res/layout/gif_list_item.xml
index 2f403224f..6f79bb1c2 100644
--- a/samples/giphy/src/main/res/layout/gif_list_item.xml
+++ b/samples/giphy/src/main/res/layout/gif_list_item.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
-
 <ImageView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/gif_view"
    android:layout_width="match_parent"
-   android:layout_height="100dp"
+   android:layout_height="125dp"
    android:contentDescription="@string/image_description" />
diff --git a/samples/samples.iml b/samples/samples.iml
new file mode 100644
index 000000000..d5233217a
--- /dev/null
+++ b/samples/samples.iml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":samples" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":samples" />
+      </configuration>
+    </facet>
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
+
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 8f491d205..c0f6301b1 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -1,11 +1,3 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:0.12.+'
-    }
-}
 apply plugin: 'com.android.application'
 
 repositories {
@@ -13,13 +5,14 @@ repositories {
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
         applicationId 'com.bumptech.svgsample.app'
-        minSdkVersion 10
-        targetSdkVersion 19
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
         versionCode 1
         versionName '1.0'
     }
diff --git a/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java b/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java
index 4d60dc36b..dd9228ff9 100644
--- a/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java
@@ -9,6 +9,7 @@
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
+
 import com.bumptech.glide.GenericRequestBuilder;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
diff --git a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java b/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java
index 9ba4c5b20..f4056d35d 100644
--- a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java
+++ b/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Picture;
 import android.graphics.drawable.PictureDrawable;
+
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
diff --git a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java
index 62af871fb..a23a030dd 100644
--- a/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java
+++ b/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java
@@ -4,6 +4,7 @@
 import android.graphics.drawable.PictureDrawable;
 import android.os.Build;
 import android.widget.ImageView;
+
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.ImageViewTarget;
 import com.bumptech.glide.request.target.Target;
diff --git a/samples/svg/svg.iml b/samples/svg/svg.iml
new file mode 100644
index 000000000..1302ad02a
--- /dev/null
+++ b/samples/svg/svg.iml
@@ -0,0 +1,91 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":samples:svg" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.samples" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":samples:svg" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Maven Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" name="support-v4-19.1.0" level="project" />
+    <orderEntry type="library" exported="" name="androidsvg-1.2.1" level="project" />
+    <orderEntry type="module" module-name="library" exported="" />
+    <orderEntry type="module" module-name="disklrucache" exported="" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index f84684b16..a32cd39e7 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -129,10 +129,12 @@ afterEvaluate { project ->
 
         task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
             from androidJavadocs.destinationDir
+            baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
         task androidSourcesJar(type: Jar) {
             from project.android.sourceSets.main.java.source
+            baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
     }
 
diff --git a/settings.gradle b/settings.gradle
index 8e11f3249..caef1261a 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -9,5 +9,6 @@ include ':samples:svg'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
+include ':testutil'
 
 rootProject.name = 'glide-parent'
diff --git a/testutil/build.gradle b/testutil/build.gradle
new file mode 100644
index 000000000..bbfeb03c2
--- /dev/null
+++ b/testutil/build.gradle
@@ -0,0 +1 @@
+apply plugin: 'java'
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
new file mode 100644
index 000000000..e523b67d0
--- /dev/null
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.testutil;
+
+import java.io.InputStream;
+
+/**
+ * Test only utility for opening resources in androidTest/resources.
+ */
+public final class TestResourceUtil {
+    private TestResourceUtil() {
+        // Utility class
+    }
+
+    /**
+     * Returns an InputStream for the given test class and sub-path.
+     *
+     * @param testClass A Junit test class.
+     * @param subPath The sub-path under androidTest/resources where the desired resource is located.
+     *                Should not be prefixed with a '/'
+     */
+    public static InputStream openResource(Class testClass, String subPath) {
+        return testClass.getResourceAsStream("/" + subPath);
+    }
+}
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
new file mode 100644
index 000000000..0ad40e0e6
--- /dev/null
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -0,0 +1,37 @@
+package com.bumptech.glide.testutil;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Shared utility classes for tests.
+ */
+public final class TestUtil {
+    private TestUtil() {
+        // Utility class.
+    }
+
+    public static byte[] resourceToBytes(Class testClass, String resourceName) throws IOException {
+        return isToBytes(TestResourceUtil.openResource(testClass, resourceName));
+    }
+
+    public static byte[] isToBytes(InputStream is) throws IOException {
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        byte[] buffer = new byte[1024];
+        int read;
+        try {
+            while ((read = is.read(buffer)) != -1) {
+                os.write(buffer, 0, read);
+            }
+        } finally {
+            is.close();
+        }
+        return os.toByteArray();
+    }
+
+    public static String isToString(InputStream is) throws IOException {
+        return new String(isToBytes(is));
+    }
+
+}
diff --git a/testutil/testutil.iml b/testutil/testutil.iml
new file mode 100644
index 000000000..920fec434
--- /dev/null
+++ b/testutil/testutil.iml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":testutil" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":testutil" />
+      </configuration>
+    </facet>
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/classes/main" />
+    <output-test url="file://$MODULE_DIR$/build/classes/test" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/third_party/disklrucache b/third_party/disklrucache
index fa2fc5a1e..f744d04f5 160000
--- a/third_party/disklrucache
+++ b/third_party/disklrucache
@@ -1 +1 @@
-Subproject commit fa2fc5a1e19e466d8ffcf63f6a2d717621834c96
+Subproject commit f744d04f5a43f0c04857b22656b7b2614165cdf9
diff --git a/third_party/gif_decoder/README.third_party b/third_party/gif_decoder/README.third_party
index 9e771c5b5..e872bcd16 100644
--- a/third_party/gif_decoder/README.third_party
+++ b/third_party/gif_decoder/README.third_party
@@ -15,6 +15,6 @@ Adapted from:
 http://show.docjava.com/book/cgij/exportToHTML/ip/gif/stills/GifDecoder.java.html
 
 Local Modifications:
-Broke headers and frames out into separate files and added ability to share 
-headers between multiple decoders. Added interface for reusing bitmaps each 
-frame.  
+Broke headers and frames out into separate files and added ability to share
+headers between multiple decoders. Added interface for reusing bitmaps each
+frame. Bugfixes.
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index f7b4d4ab2..3000fb515 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -2,19 +2,20 @@ apply plugin: 'com.android.library'
 apply plugin: 'robolectric'
 
 dependencies {
-    androidTestCompile 'org.hamcrest:hamcrest-core:1.3'
-    androidTestCompile 'org.hamcrest:hamcrest-library:1.3'
-    androidTestCompile 'junit:junit:4.11'
-    androidTestCompile 'org.mockito:mockito-all:1.9.5'
+    androidTestCompile project(':testutil')
+    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
+    androidTestCompile "junit:junit:${JUNIT_VERSION}"
+    androidTestCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    androidTestCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
-        applicationId 'com.bumptech.glide.gifdecoder'
-        minSdkVersion 10
-        targetSdkVersion 19
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
     }
 }
diff --git a/third_party/gif_decoder/gif_decoder.iml b/third_party/gif_decoder/gif_decoder.iml
new file mode 100644
index 000000000..f7e5441b3
--- /dev/null
+++ b/third_party/gif_decoder/gif_decoder.iml
@@ -0,0 +1,114 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":third_party:gif_decoder" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.third_party" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":third_party:gif_decoder" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+        <option name="LIBRARY_PROJECT" value="true" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
+      <excludeFolder url="file://$MODULE_DIR$/build/test-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/test-report" />
+      <excludeFolder url="file://$MODULE_DIR$/build/test-results" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Maven Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" scope="TEST" name="commons-codec-1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-2.4" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="objenesis-1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="robolectric-2.4" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="support-v4-19.1.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="vtd-xml-2.11" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-commons-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-core-1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="junit-4.11" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-tree-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-analysis-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="truth-0.24" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="mockito-all-1.9.5" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="ant-launcher-1.8.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="guava-17.0" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="asm-util-5.0.1" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />
+    <orderEntry type="module" module-name="testutil" exported="" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
new file mode 100644
index 000000000..b3f35e076
--- /dev/null
+++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -0,0 +1,110 @@
+package com.bumptech.glide.gifdecoder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.testutil.TestUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+
+/**
+ * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class GifDecoderTest {
+
+    private MockProvider provider;
+
+    @Before
+    public void setUp() {
+        provider = new MockProvider();
+    }
+
+    @Test
+    public void testCanDecodeFramesFromTestGif() throws IOException {
+        byte[] data = TestUtil.resourceToBytes(getClass(), "partial_gif_decode.gif");
+        GifHeaderParser headerParser = new GifHeaderParser();
+        headerParser.setData(data);
+        GifHeader header = headerParser.parseHeader();
+        GifDecoder decoder = new GifDecoder(provider);
+        decoder.setData(header, data);
+        decoder.advance();
+        Bitmap bitmap = decoder.getNextFrame();
+        assertNotNull(bitmap);
+        assertEquals(GifDecoder.STATUS_OK, decoder.getStatus());
+    }
+
+    @Test
+    public void testFrameIndexStartsAtNegativeOne() {
+        GifHeader gifheader = new GifHeader();
+        gifheader.frameCount = 4;
+        byte[] data = new byte[0];
+        GifDecoder decoder = new GifDecoder(provider);
+        decoder.setData(gifheader, data);
+        assertEquals(-1, decoder.getCurrentFrameIndex());
+    }
+
+    @Test
+    public void testAdvanceIncrementsFrameIndex() {
+        GifHeader gifheader = new GifHeader();
+        gifheader.frameCount = 4;
+        byte[] data = new byte[0];
+        GifDecoder decoder = new GifDecoder(provider);
+        decoder.setData(gifheader, data);
+        decoder.advance();
+        assertEquals(0, decoder.getCurrentFrameIndex());
+    }
+
+    @Test
+    public void testAdvanceWrapsIndexBackToZero() {
+        GifHeader gifheader = new GifHeader();
+        gifheader.frameCount = 2;
+        byte[] data = new byte[0];
+        GifDecoder decoder = new GifDecoder(provider);
+        decoder.setData(gifheader, data);
+        decoder.advance();
+        decoder.advance();
+        decoder.advance();
+        assertEquals(0, decoder.getCurrentFrameIndex());
+    }
+
+    @Test
+    public void testSettingDataResetsFramePointer() {
+        GifHeader gifheader = new GifHeader();
+        gifheader.frameCount = 4;
+        byte[] data = new byte[0];
+        GifDecoder decoder = new GifDecoder(provider);
+        decoder.setData(gifheader, data);
+        decoder.advance();
+        decoder.advance();
+        assertEquals(1, decoder.getCurrentFrameIndex());
+
+        decoder.setData(gifheader, data);
+        assertEquals(-1, decoder.getCurrentFrameIndex());
+    }
+
+    private static class MockProvider implements GifDecoder.BitmapProvider {
+
+        @Override
+        public Bitmap obtain(int width, int height, Bitmap.Config config) {
+            Bitmap result = Bitmap.createBitmap(width, height, config);
+            Robolectric.shadowOf(result).setMutable(true);
+            return result;
+        }
+
+        @Override
+        public void release(Bitmap bitmap) {
+            // Do nothing.
+        }
+    }
+}
diff --git a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index ca9879f24..6f2807906 100644
--- a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -1,22 +1,26 @@
 package com.bumptech.glide.gifdecoder;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
 import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
+import com.bumptech.glide.testutil.TestUtil;
+
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifHeaderParser}.
  */
+@RunWith(JUnit4.class)
 public class GifHeaderParserTest {
     private GifHeaderParser parser;
 
@@ -52,7 +56,7 @@ public void testCanReadValidHeaderAndLSD() {
 
     @Test
     public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOException {
-        byte[] data = readResourceData("gif_without_graphical_control_extension.gif");
+        byte[] data = TestUtil.resourceToBytes(getClass(), "gif_without_graphical_control_extension.gif");
         parser.setData(data);
         GifHeader header = parser.parseHeader();
         assertEquals(1, header.frameCount);
@@ -62,11 +66,101 @@ public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOEx
 
     @Test
     public void testCanReadImageDescriptorWithoutGraphicalExtension() {
-        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH
-                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + 4).order(ByteOrder.LITTLE_ENDIAN);
+        final int lzwMinCodeSize = 2;
+        ByteBuffer buffer = ByteBuffer.allocate(
+                GifBytesTestUtil.HEADER_LENGTH
+                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize)
+        ).order(ByteOrder.LITTLE_ENDIAN);
         GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1);
-        GifBytesTestUtil.writeFakeImageData(buffer, 2);
+        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
+        GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
+
+        parser.setData(buffer.array());
+        GifHeader header = parser.parseHeader();
+        assertEquals(1, header.width);
+        assertEquals(1, header.height);
+        assertEquals(1, header.frameCount);
+        assertNotNull(header.frames.get(0));
+    }
+
+    private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {
+        final int lzwMinCodeSize = 2;
+        ByteBuffer buffer = ByteBuffer.allocate(
+                GifBytesTestUtil.HEADER_LENGTH
+                + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH
+                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize)
+        ).order(ByteOrder.LITTLE_ENDIAN);
+        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+        GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);
+        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
+        GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
+        return buffer;
+    }
+
+    @Test
+    public void testCanParseFrameDelay() {
+        final short frameDelay = 50;
+        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
+
+        parser.setData(buffer.array());
+        GifHeader header = parser.parseHeader();
+        GifFrame frame = header.frames.get(0);
+
+        // Convert delay in 100ths of a second to ms.
+        assertEquals(frameDelay * 10, frame.delay);
+    }
+
+    @Test
+    public void testSetsDefaultFrameDelayIfFrameDelayIsZero() {
+        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay((short) 0);
+
+        parser.setData(buffer.array());
+        GifHeader header = parser.parseHeader();
+        GifFrame frame = header.frames.get(0);
+
+        // Convert delay in 100ths of a second to ms.
+        assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);
+    }
+
+    @Test
+    public void testSetsDefaultFrameDelayIfFrameDelayIsLessThanMinimum() {
+        final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY - 1;
+        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
+
+        parser.setData(buffer.array());
+        GifHeader header = parser.parseHeader();
+        GifFrame frame = header.frames.get(0);
+
+        // Convert delay in 100ths of a second to ms.
+        assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);
+    }
+
+    @Test
+    public void testObeysFrameDelayIfFrameDelayIsAtMinimum() {
+        final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY;
+        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
+
+        parser.setData(buffer.array());
+        GifHeader header = parser.parseHeader();
+        GifFrame frame = header.frames.get(0);
+
+        // Convert delay in 100ths of a second to ms.
+        assertEquals(frameDelay * 10, frame.delay);
+    }
+
+    @Test
+    public void testSetsFrameLocalColorTableToNullIfNoColorTable() {
+        final int lzwMinCodeSize = 2;
+        ByteBuffer buffer = ByteBuffer.allocate(
+                GifBytesTestUtil.HEADER_LENGTH
+                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize)
+        ).order(ByteOrder.LITTLE_ENDIAN);
+        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
+        GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
 
         parser.setData(buffer.array());
         GifHeader header = parser.parseHeader();
@@ -74,33 +168,61 @@ public void testCanReadImageDescriptorWithoutGraphicalExtension() {
         assertEquals(1, header.height);
         assertEquals(1, header.frameCount);
         assertNotNull(header.frames.get(0));
+        assertNull(header.frames.get(0).lct);
     }
 
-    private InputStream openResource(String imageName) throws IOException {
-        return getClass().getResourceAsStream("/" + imageName);
+    @Test
+    public void testSetsFrameLocalColorTableIfHasColorTable() {
+        final int lzwMinCodeSize = 2;
+        final int numColors = 4;
+        ByteBuffer buffer = ByteBuffer.allocate(
+                GifBytesTestUtil.HEADER_LENGTH
+                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize)
+                + GifBytesTestUtil.getColorTableLength(numColors)
+        ).order(ByteOrder.LITTLE_ENDIAN);
+        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, true /*hasLct*/, numColors);
+        GifBytesTestUtil.writeColorTable(buffer, numColors);
+        GifBytesTestUtil.writeFakeImageData(buffer, 2);
+
+        parser.setData(buffer.array());
+        GifHeader header = parser.parseHeader();
+        assertEquals(1, header.width);
+        assertEquals(1, header.height);
+        assertEquals(1, header.frameCount);
+        assertNotNull(header.frames.get(0));
+
+        GifFrame frame = header.frames.get(0);
+        assertNotNull(frame.lct);
     }
 
-    private byte[] readResourceData(String imageName) {
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        byte[] buffer = new byte[1024];
-        InputStream is = null;
-        try {
-            is = openResource(imageName);
-            int read;
-            while ((read = is.read(buffer)) != -1) {
-                os.write(buffer, 0, read);
-            }
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        } finally {
-            if (is != null) {
-                try {
-                    is.close();
-                } catch (IOException e) {
-                    // Ignore.
-                }
-            }
+    @Test
+    public void testCanParseMultipleFrames() {
+        final int lzwMinCodeSize = 2;
+        final int expectedFrames = 3;
+
+        final int frameSize = GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+        ByteBuffer buffer = ByteBuffer.allocate(
+                GifBytesTestUtil.HEADER_LENGTH + expectedFrames * frameSize
+        ).order(ByteOrder.LITTLE_ENDIAN);
+
+        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+        for (int i = 0; i < expectedFrames; i++) {
+            GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+            GifBytesTestUtil.writeFakeImageData(buffer, 2);
         }
-        return os.toByteArray();
+
+        parser.setData(buffer.array());
+        GifHeader header = parser.parseHeader();
+        assertEquals(expectedFrames, header.frameCount);
+        assertEquals(expectedFrames, header.frames.size());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testThrowsIfParseHeaderCalledBeforeSetData() {
+        GifHeaderParser parser = new GifHeaderParser();
+        parser.parseHeader();
     }
 }
\ No newline at end of file
diff --git a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
index 97c3d4fae..b6f3140e5 100644
--- a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
+++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
@@ -10,6 +10,17 @@
     public static final int HEADER_LENGTH = 13;
     // Length in bytes.
     public static final int IMAGE_DESCRIPTOR_LENGTH = 10;
+    // Length in bytes.
+    public static final int GRAPHICS_CONTROL_EXTENSION_LENGTH = 8;
+
+    public static int getColorTableLength(int numColors) {
+        return 3 * numColors;
+    }
+
+    public static int getImageDataSize(int lzwMinCodeSize) {
+        // TODO: fill this out.
+        return 4;
+    }
 
     public static void writeFakeImageData(ByteBuffer out, int lzwMinCodeSize) {
         // 1 for lzwMinCodeSize, 1 for length, 1 for min content, 1 for block terminator.
@@ -25,16 +36,40 @@ public static void writeFakeImageData(ByteBuffer out, int lzwMinCodeSize) {
         out.put((byte) 0x00);
     }
 
+    public static void writeColorTable(ByteBuffer out, int numColors) {
+        verifyRemaining(out, getColorTableLength(numColors));
+        for (int i = 0; i < numColors; i++) {
+            out.put((byte) (0xFF0000 & i));
+            out.put((byte) (0x00FF00 & i));
+            out.put((byte) (0x0000FF & i));
+        }
+    }
+
     public static void writeImageDescriptor(ByteBuffer out, int imageLeft, int imageTop, int imageWidth,
-            int imageHeight) {
+            int imageHeight, boolean hasLct, int numColors) {
         verifyRemaining(out, IMAGE_DESCRIPTOR_LENGTH);
         verifyShortValues(imageLeft, imageTop, imageWidth, imageHeight);
 
+        final byte packed;
+        if (hasLct) {
+            int size = log2(numColors) - 1;
+            packed = (byte) (0x80 | size);
+        } else {
+            packed = 0x00;
+        }
+
         // Image separator
         out.put((byte) 0x2C);
+        out
+                .putShort((short) imageLeft)
+                .putShort((short) imageTop)
+                .putShort((short) imageWidth)
+                .putShort((short) imageHeight)
+                .put(packed);
+    }
 
-        out.putShort((short) imageLeft).putShort((short) imageTop).putShort((short) imageWidth)
-                .putShort((short) imageHeight);
+    private static int log2(int num) {
+        return (int) Math.round(Math.log(num) / Math.log(2));
     }
 
     public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, boolean hasGct, int gctSize) {
@@ -71,6 +106,29 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
         out.put((byte) 0);
     }
 
+    public static void writeGraphicsControlExtension(ByteBuffer out, int delayTime) {
+        verifyRemaining(out, GRAPHICS_CONTROL_EXTENSION_LENGTH);
+        verifyShortValues(delayTime);
+
+        // Extension inducer (constant).
+        out.put((byte) 0x21);
+        // Graphic control label (constant).
+        out.put((byte) 0xF9);
+        // Block size (constant).
+        out.put((byte) 0x04);
+        // Packed (disposal method, user input, transparent color flag)
+        out.put((byte) 0x00);
+
+        // Frame delay in 100ths of a second.
+        out.putShort((short) delayTime);
+
+        // Transparent color index.
+        out.put((byte) 0x00);
+
+        // Block terminator (constant).
+        out.put((byte) 0x00);
+    }
+
     private static void verifyRemaining(ByteBuffer buffer, int expected) {
         if (buffer.remaining() < expected) {
             throw new IllegalArgumentException("Must have at least " + expected + " bytes to write");
diff --git a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
index 7b25c96b4..64a12db02 100644
--- a/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
+++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
@@ -1,14 +1,18 @@
 package com.bumptech.glide.gifdecoder.test;
 
+import static org.junit.Assert.assertArrayEquals;
+
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import java.nio.ByteBuffer;
-
-import static org.junit.Assert.assertArrayEquals;
+import java.util.Arrays;
 
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.test.GifBytesTestUtil}.
  */
+@RunWith(JUnit4.class)
 public class GifBytesTestUtilTest {
 
     @Test
@@ -18,7 +22,7 @@ public void testWriteHeaderAndLsdWithoutGct() {
 
         byte[] expected = new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00, 0x08, 0x00, 0x10, 0x20, 0x00, 0x00};
 
-        assertArrayEquals(expected, buffer.array());
+        assertEquals(expected, buffer);
     }
 
     @Test
@@ -29,17 +33,79 @@ public void testWriteHeaderAndLsdWithGct() {
         byte[] expected = new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00, 0x08, 0x00, 0x10, (byte) 0xA4, 0x00,
                 0x00};
 
-        assertArrayEquals(expected, buffer.array());
+        assertEquals(expected, buffer);
     }
 
     @Test
-    public void testWriteImageDescriptor() {
+    public void testWriteImageDescriptorWithoutColorTable() {
         ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH);
-        GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7);
+        GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7, false, 0);
+
+        byte[] expected = new byte[] {
+                // Image separator.
+                0x2C,
+                // Image left.
+                0x00, 0x0A,
+                // Image right.
+                0x00, 0X09,
+                // Image width.
+                0x00, 0x08,
+                // Image height.
+                0x00, 0x07,
+                // Packed field.
+                0x00
+        };
+
+        assertEquals(expected, buffer);
+    }
 
-        byte[] expected = new byte[] { 0x2C, 0x00, 0x0A, 0x00, 0X09, 0x00, 0x08, 0x000, 0x07, 0x00 };
+    @Test
+    public void testWriteImageDescriptorWithColorTable() {
+        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH);
+        GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7, true, 4);
+
+        byte packedField =
+                // Set LCT flag
+                (byte) 0x80
+                // Size of color table (2^(N + 1) == 4)
+                | 0x01;
+
+        byte[] expected = new byte[] {
+                // Image separator.
+                0x2C,
+                // Image left.
+                0x00, 0x0A,
+                // Image right.
+                0x00, 0X09,
+                // Image width.
+                0x00, 0x08,
+                // Image height.
+                0x00, 0x07,
+                packedField
+        };
+
+        assertEquals(expected, buffer);
+    }
 
-        assertArrayEquals(expected, buffer.array());
+    @Test
+    public void testWriteColorTable() {
+        final int numColors = 4;
+        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.getColorTableLength(numColors));
+        GifBytesTestUtil.writeColorTable(buffer, numColors);
+
+        byte[] expected = new byte[] {
+                // First color.
+                0x00, 0x00, 0x00,
+                // Second color.
+                0x00, 0x00, 0x01,
+                // Third color.
+                0x00, 0x00, 0x02,
+                // Fourth color.
+                0x00, 0x00, 0x03,
+        };
+
+
+        assertEquals(expected, buffer);
     }
 
     @Test
@@ -49,6 +115,37 @@ public void testWriteFakeImageData() {
 
         byte[] expected = new byte[] { 0x02, 0x01, 0x01, 0x00 };
 
-        assertArrayEquals(expected, buffer.array());
+        assertEquals(expected, buffer);
+    }
+
+    @Test
+    public void testWritesGraphicsControlExtension() {
+        short delay = 20;
+        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH);
+        byte[] expected = new byte[] {
+                // Extension inducer.
+                0x21,
+                // Graphic control label.
+                (byte) 0xF9,
+                // Block size.
+                0x04,
+                // Packed byte.
+                0x00,
+                // Frame delay.
+                0x00,
+                0x14,
+                // Transparent color index.
+                0x00,
+                // block terminator.
+                0x00
+        };
+
+        GifBytesTestUtil.writeGraphicsControlExtension(buffer, delay);
+        assertEquals(expected, buffer);
+    }
+
+    private static void assertEquals(byte[] expected, ByteBuffer buffer) {
+        assertArrayEquals("expected=" + Arrays.toString(expected) + " received=" + Arrays.toString(buffer.array()),
+                expected, buffer.array());
     }
 }
diff --git a/third_party/gif_decoder/src/androidTest/resources/partial_gif_decode.gif b/third_party/gif_decoder/src/androidTest/resources/partial_gif_decode.gif
new file mode 100644
index 000000000..2e3b6f279
Binary files /dev/null and b/third_party/gif_decoder/src/androidTest/resources/partial_gif_decode.gif differ
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index efef2392b..cc07c4cf7 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -24,8 +24,9 @@
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.graphics.Color;
+import android.os.Build;
 import android.util.Log;
 
 import java.io.ByteArrayOutputStream;
@@ -67,6 +68,10 @@
      * File read status: Unable to open source.
      */
     public static final int STATUS_OPEN_ERROR = 2;
+    /**
+     * Unable to fully decode the current frame.
+     */
+    public static final int STATUS_PARTIAL_DECODE = 3;
     /**
      * max decoder pixel stack size.
      */
@@ -89,6 +94,15 @@
      */
     private static final int DISPOSAL_PREVIOUS = 3;
 
+    private static final int NULL_CODE = -1;
+
+    private static final int INITIAL_FRAME_POINTER = -1;
+
+    // We can't tell if a gif has transparency to decode a partial frame on top of a previous frame, or if the final
+    // frame will actually have transparent pixels, so we must always use a format that supports transparency. We can't
+    // use ARGB_4444 because of framework issues drawing onto ARGB_4444 Bitmaps using Canvas.
+    private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;
+
     // Global File Header values and parsing flags.
     // Active color table.
     private int[] act;
@@ -97,7 +111,10 @@
     private ByteBuffer rawData;
 
     // Raw data read working array.
-    private byte[] block = new byte[256];
+    private final byte[] block = new byte[256];
+
+    private GifHeaderParser parser;
+
     // LZW decoder working arrays.
     private short[] prefix;
     private byte[] suffix;
@@ -105,15 +122,13 @@
     private byte[] mainPixels;
     private int[] mainScratch;
 
-    private int framePointer = -1;
+    private int framePointer;
     private byte[] data;
     private GifHeader header;
-    private String id;
     private BitmapProvider bitmapProvider;
-    private GifHeaderParser parser = new GifHeaderParser();
     private Bitmap previousImage;
     private boolean savePrevious;
-    private Bitmap.Config config;
+    private int status;
 
     /**
      * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs from constantly
@@ -124,11 +139,16 @@
          * Returns an {@link Bitmap} with exactly the given dimensions and config, or null if no such {@link Bitmap}
          * could be obtained.
          *
-         * @param width The width of the desired {@link android.graphics.Bitmap}.
-         * @param height The height of the desired {@link android.graphics.Bitmap}.
+         * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
+         * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
          * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link android.graphics.Bitmap}.
          */
         public Bitmap obtain(int width, int height, Bitmap.Config config);
+
+        /**
+         * Releases the given Bitmap back to the pool.
+         */
+        public void release(Bitmap bitmap);
     }
 
     public GifDecoder(BitmapProvider provider) {
@@ -144,16 +164,20 @@ public int getHeight() {
         return header.height;
     }
 
-    public boolean isTransparent() {
-        return header.isTransparent;
-    }
-
     public byte[] getData() {
         return data;
     }
 
-    public void setPreferredConfig(Bitmap.Config config) {
-        this.config = config;
+    /**
+     * Returns the current status of the decoder.
+     *
+     * <p>
+     *     Status will update per frame to allow the caller to tell whether or not the current frame was decoded
+     *     successfully and/or completely. Format and open failures persist across frames.
+     * </p>
+     */
+    public int getStatus() {
+        return status;
     }
 
     /**
@@ -178,7 +202,7 @@ public int getDelay(int n) {
     }
 
     /**
-     * Gets display duration for the upcoming frame.
+     * Gets display duration for the upcoming frame in ms.
      */
     public int getNextDelay() {
         if (header.frameCount <= 0 || framePointer < 0) {
@@ -206,6 +230,10 @@ public int getCurrentFrameIndex() {
         return framePointer;
     }
 
+    public void resetFrameIndex() {
+        framePointer = -1;
+    }
+
     /**
      * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
      *
@@ -215,51 +243,64 @@ public int getLoopCount() {
         return header.loopCount;
     }
 
-    public String getId() {
-        return id;
-    }
-
     /**
      * Get the next frame in the animation sequence.
      *
      * @return Bitmap representation of frame.
      */
-    public Bitmap getNextFrame() {
+    public synchronized Bitmap getNextFrame() {
         if (header.frameCount <= 0 || framePointer < 0) {
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer=" + framePointer);
+            }
+            status = STATUS_FORMAT_ERROR;
+        }
+        if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "Unable to decode frame, status=" + status);
+            }
             return null;
         }
+        status = STATUS_OK;
 
-        GifFrame frame = header.frames.get(framePointer);
+        GifFrame currentFrame = header.frames.get(framePointer);
+        GifFrame previousFrame = null;
+        int previousIndex = framePointer - 1;
+        if (previousIndex >= 0) {
+            previousFrame = header.frames.get(previousIndex);
+        }
 
         // Set the appropriate color table.
-        if (frame.lct == null) {
+        if (currentFrame.lct == null) {
             act = header.gct;
         } else {
-            act = frame.lct;
-            if (header.bgIndex == frame.transIndex) {
+            act = currentFrame.lct;
+            if (header.bgIndex == currentFrame.transIndex) {
                 header.bgColor = 0;
             }
         }
 
         int save = 0;
-        if (frame.transparency) {
-            save = act[frame.transIndex];
+        if (currentFrame.transparency) {
+            save = act[currentFrame.transIndex];
             // Set transparent color if specified.
-            act[frame.transIndex] = 0;
+            act[currentFrame.transIndex] = 0;
         }
         if (act == null) {
-            Log.w(TAG, "No Valid Color Table");
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "No Valid Color Table");
+            }
             // No color table defined.
-            header.status = STATUS_FORMAT_ERROR;
+            status = STATUS_FORMAT_ERROR;
             return null;
         }
 
         // Transfer pixel data to image.
-        Bitmap result = setPixels(framePointer);
+        Bitmap result = setPixels(currentFrame, previousFrame);
 
         // Reset the transparent pixel in the color table
-        if (frame.transparency) {
-            act[frame.transIndex] = save;
+        if (currentFrame.transparency) {
+            act[currentFrame.transIndex] = save;
         }
 
         return result;
@@ -288,7 +329,7 @@ public int read(InputStream is, int contentLength) {
                 Log.w(TAG, "Error reading data from stream", e);
             }
         } else {
-            header.status = STATUS_OPEN_ERROR;
+            status = STATUS_OPEN_ERROR;
         }
 
         try {
@@ -299,30 +340,31 @@ public int read(InputStream is, int contentLength) {
             Log.w(TAG, "Error closing stream", e);
         }
 
-        return header.status;
+        return status;
     }
 
     public void clear() {
-        id = null;
         header = null;
         data = null;
         mainPixels = null;
         mainScratch = null;
+        if (previousImage != null) {
+            bitmapProvider.release(previousImage);
+        }
+        previousImage = null;
     }
 
     public void setData(GifHeader header, byte[] data) {
-        setData(null, header, data);
-    }
-
-    public void setData(String id, GifHeader header, byte[] data) {
-        this.id = id;
         this.header = header;
         this.data = data;
+        this.status = STATUS_OK;
+        framePointer = INITIAL_FRAME_POINTER;
         // Initialize the raw data buffer.
         rawData = ByteBuffer.wrap(data);
         rawData.rewind();
         rawData.order(ByteOrder.LITTLE_ENDIAN);
 
+
         // No point in specially saving an old frame if we're never going to use it.
         savePrevious = false;
         for (GifFrame frame : header.frames) {
@@ -337,6 +379,13 @@ public void setData(String id, GifHeader header, byte[] data) {
         mainScratch = new int[header.width * header.height];
     }
 
+    private GifHeaderParser getHeaderParser() {
+        if (parser == null) {
+            parser = new GifHeaderParser();
+        }
+        return parser;
+    }
+
     /**
      * Reads GIF image from byte array.
      *
@@ -345,7 +394,7 @@ public void setData(String id, GifHeader header, byte[] data) {
      */
     public int read(byte[] data) {
         this.data = data;
-        this.header = parser.setData(data).parseHeader();
+        this.header = getHeaderParser().setData(data).parseHeader();
         if (data != null) {
             // Initialize the raw data buffer.
             rawData = ByteBuffer.wrap(data);
@@ -366,19 +415,14 @@ public int read(byte[] data) {
             }
         }
 
-        return header.status;
+        return status;
     }
 
     /**
      * Creates new frame image from current data (and previous frames as specified by their disposition codes).
      */
-    private Bitmap setPixels(int frameIndex) {
-        GifFrame currentFrame = header.frames.get(frameIndex);
-        GifFrame previousFrame = null;
-        int previousIndex = frameIndex - 1;
-        if (previousIndex >= 0) {
-            previousFrame = header.frames.get(previousIndex);
-        }
+    private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
+
         int width = header.width;
         int height = header.height;
 
@@ -458,12 +502,13 @@ private Bitmap setPixels(int frameIndex) {
             }
         }
 
-        //Copy pixels into previous image
-        if (savePrevious && currentFrame.dispose == DISPOSAL_UNSPECIFIED || currentFrame.dispose == DISPOSAL_NONE) {
+        // Copy pixels into previous image
+        if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+            || currentFrame.dispose == DISPOSAL_NONE)) {
             if (previousImage == null) {
                 previousImage = getNextBitmap();
-                previousImage.setPixels(dest, 0, width, 0, 0, width, height);
             }
+            previousImage.setPixels(dest, 0, width, 0, 0, width, height);
         }
 
         // Set pixels for current image.
@@ -481,7 +526,6 @@ private void decodeBitmapData(GifFrame frame) {
             rawData.position(frame.bufferFrameStart);
         }
 
-        int nullCode = -1;
         int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
         int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count, i, datum,
                 dataSize, first, top, bi, pi;
@@ -505,7 +549,7 @@ private void decodeBitmapData(GifFrame frame) {
         clear = 1 << dataSize;
         endOfInformation = clear + 1;
         available = clear + 2;
-        oldCode = nullCode;
+        oldCode = NULL_CODE;
         codeSize = dataSize + 1;
         codeMask = (1 << codeSize) - 1;
         for (code = 0; code < clear; code++) {
@@ -517,73 +561,84 @@ private void decodeBitmapData(GifFrame frame) {
         // Decode GIF pixel stream.
         datum = bits = count = first = top = pi = bi = 0;
         for (i = 0; i < npix; ) {
-            if (top == 0) {
-                if (bits < codeSize) {
-                    // Load bytes until there are enough bits for a code.
-                    if (count == 0) {
-                        // Read a new data block.
-                        count = readBlock();
-                        if (count <= 0) {
-                            break;
-                        }
-                        bi = 0;
-                    }
-                    datum += (((int) block[bi]) & 0xff) << bits;
-                    bits += 8;
-                    bi++;
-                    count--;
-                    continue;
+            // Load bytes until there are enough bits for a code.
+            if (count == 0) {
+                // Read a new data block.
+                count = readBlock();
+                if (count <= 0) {
+                    status = STATUS_PARTIAL_DECODE;
+                    break;
                 }
+                bi = 0;
+            }
+
+            datum += (((int) block[bi]) & 0xff) << bits;
+            bits += 8;
+            bi++;
+            count--;
+
+            while (bits >= codeSize) {
                 // Get the next code.
                 code = datum & codeMask;
                 datum >>= codeSize;
                 bits -= codeSize;
+
                 // Interpret the code.
-                if ((code > available) || (code == endOfInformation)) {
-                    break;
-                }
                 if (code == clear) {
                     // Reset decoder.
                     codeSize = dataSize + 1;
                     codeMask = (1 << codeSize) - 1;
                     available = clear + 2;
-                    oldCode = nullCode;
+                    oldCode = NULL_CODE;
                     continue;
                 }
-                if (oldCode == nullCode) {
+
+                if (code > available) {
+                    status = STATUS_PARTIAL_DECODE;
+                    break;
+                }
+
+                if (code == endOfInformation) {
+                    break;
+                }
+
+                if (oldCode == NULL_CODE) {
                     pixelStack[top++] = suffix[code];
                     oldCode = code;
                     first = code;
                     continue;
                 }
                 inCode = code;
-                if (code == available) {
+                if (code >= available) {
                     pixelStack[top++] = (byte) first;
                     code = oldCode;
                 }
-                while (code > clear) {
+                while (code >= clear) {
                     pixelStack[top++] = suffix[code];
                     code = prefix[code];
                 }
                 first = ((int) suffix[code]) & 0xff;
-                // Add a new string to the string table.
-                if (available >= MAX_STACK_SIZE) {
-                    break;
-                }
                 pixelStack[top++] = (byte) first;
-                prefix[available] = (short) oldCode;
-                suffix[available] = (byte) first;
-                available++;
-                if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-                    codeSize++;
-                    codeMask += available;
+
+                // Add a new string to the string table.
+                if (available < MAX_STACK_SIZE) {
+                    prefix[available] = (short) oldCode;
+                    suffix[available] = (byte) first;
+                    available++;
+                    if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
+                        codeSize++;
+                        codeMask += available;
+                    }
                 }
                 oldCode = inCode;
+
+                while (top > 0) {
+                    // Pop a pixel off the pixel stack.
+                    top--;
+                    mainPixels[pi++] = pixelStack[top];
+                    i++;
+                }
             }
-            // Pop a pixel off the pixel stack.
-            top--;
-            mainPixels[pi++] = pixelStack[top];
-            i++;
         }
 
         // Clear missing pixels.
@@ -600,7 +655,7 @@ private int read() {
         try {
             curByte = rawData.get() & 0xFF;
         } catch (Exception e) {
-            header.status = STATUS_FORMAT_ERROR;
+            status = STATUS_FORMAT_ERROR;
         }
         return curByte;
     }
@@ -624,29 +679,25 @@ private int readBlock() {
                 }
             } catch (Exception e) {
                 Log.w(TAG, "Error Reading Block", e);
-                header.status = STATUS_FORMAT_ERROR;
+                status = STATUS_FORMAT_ERROR;
             }
         }
         return n;
     }
 
-    private Bitmap.Config getPreferredConfig() {
-        if (config == Bitmap.Config.RGB_565 && !header.isTransparent) {
-            return Bitmap.Config.RGB_565;
-        } else {
-            return Bitmap.Config.ARGB_8888;
-        }
-    }
-
     private Bitmap getNextBitmap() {
-        Bitmap.Config targetConfig = getPreferredConfig();
-        Bitmap result = bitmapProvider.obtain(header.width, header.height, targetConfig);
+        Bitmap result = bitmapProvider.obtain(header.width, header.height, BITMAP_CONFIG);
         if (result == null) {
-            result = Bitmap.createBitmap(header.width, header.height, targetConfig);
-        } else {
-            // If we're reusing a bitmap it may have other things drawn in it which we need to remove.
-            result.eraseColor(Color.TRANSPARENT);
+            result = Bitmap.createBitmap(header.width, header.height, BITMAP_CONFIG);
         }
+        setAlpha(result);
         return result;
     }
+
+    @TargetApi(12)
+    private static void setAlpha(Bitmap bitmap) {
+        if (Build.VERSION.SDK_INT >= 12) {
+            bitmap.setHasAlpha(true);
+        }
+    }
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index 157ea57d8..961529014 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -34,7 +34,6 @@
     int pixelAspect;
     //TODO: this is set both during reading the header and while decoding frames...
     int bgColor;
-    boolean isTransparent;
     int loopCount;
 
     public int getHeight() {
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 33c0c6c6e..cf61531cd 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.gifdecoder;
 
+import static com.bumptech.glide.gifdecoder.GifDecoder.STATUS_FORMAT_ERROR;
+
 import android.util.Log;
 
 import java.nio.BufferUnderflowException;
@@ -7,24 +9,21 @@
 import java.nio.ByteOrder;
 import java.util.Arrays;
 
-import static com.bumptech.glide.gifdecoder.GifDecoder.STATUS_FORMAT_ERROR;
-
 /**
  * A class responsible for creating {@link com.bumptech.glide.gifdecoder.GifHeader}s from data representing animated
  * gifs.
  */
 public class GifHeaderParser {
     public static final String TAG = "GifHeaderParser";
-    /**
-     * Max decoder pixel stack size.
-     */
-    private static final int MAX_STACK_SIZE = 4096;
 
+    // The minimum frame delay in hundredths of a second.
+    static final int MIN_FRAME_DELAY = 3;
+    // The default frame delay in hundredths of a second for GIFs with frame delays less than the minimum.
+    static final int DEFAULT_FRAME_DELAY = 10;
+
+    private static final int MAX_BLOCK_SIZE = 256;
     // Raw data read working array.
-    private final byte[] block = new byte[256];
-    // Block size last graphic control extension info.
-    private final short[] prefix = new short[MAX_STACK_SIZE];
-    private final byte[] suffix = new byte[MAX_STACK_SIZE];
+    private final byte[] block = new byte[MAX_BLOCK_SIZE];
 
     private ByteBuffer rawData;
     private GifHeader header;
@@ -43,6 +42,11 @@ public GifHeaderParser setData(byte[] data) {
         return this;
     }
 
+    public void clear() {
+        rawData = null;
+        header = null;
+    }
+
     private void reset() {
         rawData = null;
         Arrays.fill(block, (byte) 0);
@@ -51,6 +55,9 @@ private void reset() {
     }
 
     public GifHeader parseHeader() {
+        if (rawData == null) {
+            throw new IllegalStateException("You must call setData() before parseHeader()");
+        }
         if (err()) {
             return header;
         }
@@ -69,7 +76,7 @@ public GifHeader parseHeader() {
     /**
      * Main file parser. Reads GIF content blocks.
      */
-    protected void readContents() {
+    private void readContents() {
         // Read GIF file content blocks.
         boolean done = false;
         while (!(done || err())) {
@@ -137,7 +144,7 @@ protected void readContents() {
     /**
      * Reads Graphics Control Extension values.
      */
-    protected void readGraphicControlExt() {
+    private void readGraphicControlExt() {
         // Block size.
         read();
         // Packed fields.
@@ -149,9 +156,13 @@ protected void readGraphicControlExt() {
             header.currentFrame.dispose = 1;
         }
         header.currentFrame.transparency = (packed & 1) != 0;
-        header.isTransparent |= header.currentFrame.transparency;
         // Delay in milliseconds.
-        header.currentFrame.delay = readShort() * 10;
+        int delayInHundredthsOfASecond = readShort();
+        // TODO: consider allowing -1 to indicate show forever.
+        if (delayInHundredthsOfASecond < MIN_FRAME_DELAY) {
+            delayInHundredthsOfASecond = DEFAULT_FRAME_DELAY;
+        }
+        header.currentFrame.delay = delayInHundredthsOfASecond * 10;
         // Transparent color index
         header.currentFrame.transIndex = read();
         // Block terminator
@@ -161,7 +172,7 @@ protected void readGraphicControlExt() {
     /**
      * Reads next frame image.
      */
-    protected void readBitmap() {
+    private void readBitmap() {
         // (sub)image position & size.
         header.currentFrame.ix = readShort();
         header.currentFrame.iy = readShort();
@@ -188,9 +199,8 @@ protected void readBitmap() {
         header.currentFrame.bufferFrameStart = rawData.position();
 
         // False decode pixel data to advance buffer.
-        skipBitmapData();
+        skipImageData();
 
-        skip();
         if (err()) {
             return;
         }
@@ -202,7 +212,7 @@ protected void readBitmap() {
     /**
      * Reads Netscape extension to obtain iteration count.
      */
-    protected void readNetscapeExt() {
+    private void readNetscapeExt() {
         do {
             readBlock();
             if (block[0] == 1) {
@@ -236,7 +246,7 @@ private void readHeader() {
     /**
      * Reads Logical Screen Descriptor.
      */
-    protected void readLSD() {
+    private void readLSD() {
         // Logical screen size.
         header.width = readShort();
         header.height = readShort();
@@ -260,7 +270,7 @@ protected void readLSD() {
      * @param ncolors int number of colors to read.
      * @return int array containing 256 colors (packed ARGB with full alpha).
      */
-    protected int[] readColorTable(int ncolors) {
+    private int[] readColorTable(int ncolors) {
         int nbytes = 3 * ncolors;
         int[] tab = null;
         byte[] c = new byte[nbytes];
@@ -268,8 +278,9 @@ protected void readLSD() {
         try {
             rawData.get(c);
 
+            // TODO: what bounds checks are we avoiding if we know the number of colors?
             // Max size to avoid bounds checks.
-            tab = new int[256];
+            tab = new int[MAX_BLOCK_SIZE];
             int i = 0;
             int j = 0;
             while (i < ncolors) {
@@ -279,7 +290,9 @@ protected void readLSD() {
                 tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
             }
         } catch (BufferUnderflowException e) {
-            Log.w(TAG, "Format Error Reading Color Table", e);
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "Format Error Reading Color Table", e);
+            }
             header.status = STATUS_FORMAT_ERROR;
         }
 
@@ -287,102 +300,24 @@ protected void readLSD() {
     }
 
     /**
-     * Skips LZW image data for a single frame to advance buffer. Adapted from John Cristy's BitmapMagick.
+     * Skips LZW image data for a single frame to advance buffer.
      */
-    protected void skipBitmapData() {
-        int nullCode = -1;
-        int npix = header.width * header.height;
-        int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count, i, datum,
-                dataSize, first, top, bi;
-
-        // Initialize GIF data stream decoder.
-        dataSize = read();
-        clear = 1 << dataSize;
-        endOfInformation = clear + 1;
-        available = clear + 2;
-        oldCode = nullCode;
-        codeSize = dataSize + 1;
-        codeMask = (1 << codeSize) - 1;
-        for (code = 0; code < clear; code++) {
-            // XXX ArrayIndexOutOfBoundsException.
-            prefix[code] = 0;
-            suffix[code] = (byte) code;
-        }
-
-        // Decode GIF pixel stream.
-        datum = bits = count = top = bi = 0;
-        for (i = 0; i < npix; ) {
-            if (top == 0) {
-                if (bits < codeSize) {
-                    // Load bytes until there are enough bits for a code.
-                    if (count == 0) {
-                        // Read a new data block.
-                        count = readBlock();
-                        if (count <= 0) {
-                            break;
-                        }
-                        bi = 0;
-                    }
-                    datum += (((int) block[bi]) & 0xff) << bits;
-                    bits += 8;
-                    bi++;
-                    count--;
-                    continue;
-                }
-                // Get the next code.
-                code = datum & codeMask;
-                datum >>= codeSize;
-                bits -= codeSize;
-                // Interpret the code.
-                if ((code > available) || (code == endOfInformation)) {
-                    break;
-                }
-                if (code == clear) {
-                    // Reset decoder.
-                    codeSize = dataSize + 1;
-                    codeMask = (1 << codeSize) - 1;
-                    available = clear + 2;
-                    oldCode = nullCode;
-                    continue;
-                }
-                if (oldCode == nullCode) {
-                    oldCode = code;
-                    continue;
-                }
-                inCode = code;
-                if (code == available) {
-                    code = oldCode;
-                }
-                while (code > clear) {
-                    code = prefix[code];
-                }
-                first = ((int) suffix[code]) & 0xff;
-                // Add a new string to the string table.
-                if (available >= MAX_STACK_SIZE) {
-                    break;
-                }
-                prefix[available] = (short) oldCode;
-                suffix[available] = (byte) first;
-                available++;
-                if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-                    codeSize++;
-                    codeMask += available;
-                }
-                oldCode = inCode;
-            }
-            // Pop a pixel off the pixel stack.
-            top--;
-            i++;
-        }
+    private void skipImageData() {
+        // lzwMinCodeSize
+        read();
+        // data sub-blocks
+        skip();
     }
 
     /**
      * Skips variable length blocks up to and including next zero length block.
      */
-    protected void skip() {
+    private void skip() {
+        int blockSize;
         do {
-            readBlock();
-        } while ((blockSize > 0) && !err());
+            blockSize = read();
+            rawData.position(rawData.position() + blockSize);
+        } while (blockSize > 0);
     }
 
     /**
@@ -390,7 +325,7 @@ protected void skip() {
      *
      * @return number of bytes stored in "buffer"
      */
-    protected int readBlock() {
+    private int readBlock() {
         blockSize = read();
         int n = 0;
         if (blockSize > 0) {
@@ -403,7 +338,9 @@ protected int readBlock() {
                     n += count;
                 }
             } catch (Exception e) {
-                Log.w(TAG, "Error Reading Block n: " + n + " count: " + count + " blockSize: " + blockSize, e);
+                if (Log.isLoggable(TAG, Log.DEBUG)) {
+                    Log.d(TAG, "Error Reading Block n: " + n + " count: " + count + " blockSize: " + blockSize, e);
+                }
                 header.status = STATUS_FORMAT_ERROR;
             }
         }
@@ -426,7 +363,7 @@ private int read() {
     /**
      * Reads next 16-bit value, LSB first.
      */
-    protected int readShort() {
+    private int readShort() {
         // Read 16-bit value.
         return rawData.getShort();
     }
diff --git a/third_party/gif_encoder/README.third_party b/third_party/gif_encoder/README.third_party
index 10fc85b20..981a8a04d 100644
--- a/third_party/gif_encoder/README.third_party
+++ b/third_party/gif_encoder/README.third_party
@@ -1,6 +1,6 @@
 URL: http://java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm
 Version: Downloaded 9/4/2014.
-License: MIT
+License: Notice
 License File: LICENSE
 
 Description:
@@ -11,3 +11,4 @@ http://members.ozemail.com.au/~dekker/NEUQUANT.HTML
 
 Local Modifications:
 Converted BufferedImage to Android's Bitmap class, split apart classes into individual files.
+Support setting transIndex based on the presence of transparent pixels in the Bitmap.
diff --git a/third_party/gif_encoder/build.gradle b/third_party/gif_encoder/build.gradle
index d13e5e10c..240246fc0 100644
--- a/third_party/gif_encoder/build.gradle
+++ b/third_party/gif_encoder/build.gradle
@@ -1,12 +1,11 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
-        applicationId 'com.bumptech.glide.gifencod:'
-        minSdkVersion 10
-        targetSdkVersion 19
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
     }
 }
diff --git a/third_party/gif_encoder/gif_encoder.iml b/third_party/gif_encoder/gif_encoder.iml
new file mode 100644
index 000000000..6aef0b9e2
--- /dev/null
+++ b/third_party/gif_encoder/gif_encoder.iml
@@ -0,0 +1,89 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":third_party:gif_encoder" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.third_party" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":third_party:gif_encoder" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+        <option name="LIBRARY_PROJECT" value="true" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/test/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/test/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/reports" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Maven Android API 19 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index 3db8a1864..aa1123f67 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -4,6 +4,7 @@
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.util.Log;
 
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
@@ -35,46 +36,52 @@
  */
 
 public class AnimatedGifEncoder {
+    private static final String TAG = "AnimatedGifEncoder";
 
-    protected int width; // image size
+    // The minimum % of an images pixels that must be transparent for us to set a transparent index automatically.
+    private static final double MIN_TRANSPARENT_PERCENTAGE = 4d;
 
-    protected int height;
+    private int width; // image size
 
-    protected Integer transparent = null; // transparent color if given
+    private int height;
 
-    protected int transIndex; // transparent index in color table
+    private Integer transparent = null; // transparent color if given
 
-    protected int repeat = -1; // no repeat
+    private int transIndex; // transparent index in color table
 
-    protected int delay = 0; // frame delay (hundredths)
+    private int repeat = -1; // no repeat
 
-    protected boolean started = false; // ready to output frames
+    private int delay = 0; // frame delay (hundredths)
 
-    protected OutputStream out;
+    private boolean started = false; // ready to output frames
 
-    protected Bitmap image; // current frame
+    private OutputStream out;
 
-    protected byte[] pixels; // BGR byte array from frame
+    private Bitmap image; // current frame
 
-    protected byte[] indexedPixels; // converted frame indexed to palette
+    private byte[] pixels; // BGR byte array from frame
 
-    protected int colorDepth; // number of bit planes
+    private byte[] indexedPixels; // converted frame indexed to palette
 
-    protected byte[] colorTab; // RGB palette
+    private int colorDepth; // number of bit planes
 
-    protected boolean[] usedEntry = new boolean[256]; // active palette entries
+    private byte[] colorTab; // RGB palette
 
-    protected int palSize = 7; // color table size (bits-1)
+    private boolean[] usedEntry = new boolean[256]; // active palette entries
 
-    protected int dispose = -1; // disposal code (-1 = use default)
+    private int palSize = 7; // color table size (bits-1)
 
-    protected boolean closeStream = false; // close stream when finished
+    private int dispose = -1; // disposal code (-1 = use default)
 
-    protected boolean firstFrame = true;
+    private boolean closeStream = false; // close stream when finished
 
-    protected boolean sizeSet = false; // if false, get size from first frame
+    private boolean firstFrame = true;
 
-    protected int sample = 10; // default sample interval for quantizer
+    private boolean sizeSet = false; // if false, get size from first frame
+
+    private int sample = 10; // default sample interval for quantizer
+
+    private boolean hasTransparentPixels;
 
     /**
      * Sets the delay time between each frame, or changes it for subsequent frames
@@ -300,7 +307,7 @@ public boolean start(String file) {
     /**
      * Analyzes image colors and creates color map.
      */
-    protected void analyzePixels() {
+    private void analyzePixels() {
         int len = pixels.length;
         int nPix = len / 3;
         indexedPixels = new byte[nPix];
@@ -327,6 +334,8 @@ protected void analyzePixels() {
         // get closest match to transparent color if specified
         if (transparent != null) {
             transIndex = findClosest(transparent);
+        } else if (hasTransparentPixels) {
+            transIndex = findClosest(Color.TRANSPARENT);
         }
     }
 
@@ -334,7 +343,7 @@ protected void analyzePixels() {
      * Returns index of palette color closest to c
      *
      */
-    protected int findClosest(int color) {
+    private int findClosest(int color) {
         if (colorTab == null)
             return -1;
         int r = Color.red(color);
@@ -361,7 +370,7 @@ protected int findClosest(int color) {
     /**
      * Extracts image pixels into byte array "pixels"
      */
-    protected void getImagePixels() {
+    private void getImagePixels() {
         int w = image.getWidth();
         int h = image.getHeight();
 
@@ -379,22 +388,35 @@ protected void getImagePixels() {
         pixels = new byte[pixelsInt.length * 3];
 
         int pixelsIndex = 0;
+        hasTransparentPixels = false;
+        int totalTransparentPixels = 0;
         for (final int pixel : pixelsInt) {
+            if (pixel == Color.TRANSPARENT) {
+                totalTransparentPixels++;
+            }
             pixels[pixelsIndex++] = (byte) (pixel & 0xFF);
             pixels[pixelsIndex++] = (byte) ((pixel >> 8) & 0xFF);
             pixels[pixelsIndex++] = (byte) ((pixel >> 16) & 0xFF);
         }
+
+        double transparentPercentage = 100 * totalTransparentPixels / (double) pixelsInt.length;
+        // Assume images with greater where more than n% of the pixels are transparent actually have transparency.
+        // See issue #214.
+        hasTransparentPixels = transparentPercentage > MIN_TRANSPARENT_PERCENTAGE;
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "got pixels for frame with " + transparentPercentage + "% transparent pixels");
+        }
     }
 
     /**
      * Writes Graphic Control Extension
      */
-    protected void writeGraphicCtrlExt() throws IOException {
+    private void writeGraphicCtrlExt() throws IOException {
         out.write(0x21); // extension introducer
         out.write(0xf9); // GCE label
         out.write(4); // data block size
         int transp, disp;
-        if (transparent == null) {
+        if (transparent == null && !hasTransparentPixels) {
             transp = 0;
             disp = 0; // dispose = no action
         } else {
@@ -420,7 +442,7 @@ protected void writeGraphicCtrlExt() throws IOException {
     /**
      * Writes Image Descriptor
      */
-    protected void writeImageDesc() throws IOException {
+    private void writeImageDesc() throws IOException {
         out.write(0x2c); // image separator
         writeShort(0); // image position x,y = 0,0
         writeShort(0);
@@ -443,7 +465,7 @@ protected void writeImageDesc() throws IOException {
     /**
      * Writes Logical Screen Descriptor
      */
-    protected void writeLSD() throws IOException {
+    private void writeLSD() throws IOException {
         // logical screen size
         writeShort(width);
         writeShort(height);
@@ -460,7 +482,7 @@ protected void writeLSD() throws IOException {
     /**
      * Writes Netscape application extension to define repeat count.
      */
-    protected void writeNetscapeExt() throws IOException {
+    private void writeNetscapeExt() throws IOException {
         out.write(0x21); // extension introducer
         out.write(0xff); // app extension label
         out.write(11); // block size
@@ -474,7 +496,7 @@ protected void writeNetscapeExt() throws IOException {
     /**
      * Writes color table
      */
-    protected void writePalette() throws IOException {
+    private void writePalette() throws IOException {
         out.write(colorTab, 0, colorTab.length);
         int n = (3 * 256) - colorTab.length;
         for (int i = 0; i < n; i++) {
@@ -485,7 +507,7 @@ protected void writePalette() throws IOException {
     /**
      * Encodes and writes pixel data
      */
-    protected void writePixels() throws IOException {
+    private void writePixels() throws IOException {
         LZWEncoder encoder = new LZWEncoder(width, height, indexedPixels, colorDepth);
         encoder.encode(out);
     }
@@ -493,7 +515,7 @@ protected void writePixels() throws IOException {
     /**
      * Write 16-bit value to output stream, LSB first
      */
-    protected void writeShort(int value) throws IOException {
+    private void writeShort(int value) throws IOException {
         out.write(value & 0xff);
         out.write((value >> 8) & 0xff);
     }
@@ -501,7 +523,7 @@ protected void writeShort(int value) throws IOException {
     /**
      * Writes string to output stream
      */
-    protected void writeString(String s) throws IOException {
+    private void writeString(String s) throws IOException {
         for (int i = 0; i < s.length(); i++) {
             out.write((byte) s.charAt(i));
         }
diff --git a/third_party/third_party.iml b/third_party/third_party.iml
new file mode 100644
index 000000000..f1ddc76e2
--- /dev/null
+++ b/third_party/third_party.iml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":third_party" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":third_party" />
+      </configuration>
+    </facet>
+    <facet type="java-gradle" name="Java-Gradle">
+      <configuration>
+        <option name="BUILD_FOLDER_PATH" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
+
