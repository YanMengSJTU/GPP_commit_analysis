diff --git a/.travis.yml b/.travis.yml
index a16977739..a980a467d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,24 +1,37 @@
 language: android
+sudo: required
+dist: trusty
+
 android:
   components:
   - tools
   - platform-tools
+  - tools
   - build-tools-26.0.1
   - android-26
 
-  licenses:
+licenses:
   - 'android-sdk-license.*'
 
 jdk:
   - oraclejdk8
 
-sudo: false
+env:
+  matrix:
+    - COMPONENT=unit
+    - COMPONENT=firebase
+    - COMPONENT=instrumentation ANDROID_TARGET=16
+    - COMPONENT=instrumentation ANDROID_TARGET=22
+    - COMPONENT=samples
+
+before_script:
+  - ./scripts/travis_before_script.sh
 
-script: 'travis_retry ./gradlew build --parallel'
+script:
+  - ./scripts/travis_script.sh
 
 after_success:
-- scripts/travis-sonatype-publish.sh
-- ./gradlew jacocoTestReport coveralls
+  - ./scripts/travis_after_success.sh
 
 before_cache:
   - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock
diff --git a/checkstyle_suppressions.xml b/checkstyle_suppressions.xml
index cda0ec425..0293de43a 100644
--- a/checkstyle_suppressions.xml
+++ b/checkstyle_suppressions.xml
@@ -6,7 +6,8 @@
 
 <suppressions>
     <suppress files=".*[/\\]library[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
-    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>
     <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>
     <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />
 </suppressions>
diff --git a/gcloud-bumptech.json.enc b/gcloud-bumptech.json.enc
new file mode 100644
index 000000000..32dff8de0
Binary files /dev/null and b/gcloud-bumptech.json.enc differ
diff --git a/gcloud-sjudd.json.enc b/gcloud-sjudd.json.enc
new file mode 100644
index 000000000..1c9b64237
Binary files /dev/null and b/gcloud-sjudd.json.enc differ
diff --git a/gradle.properties b/gradle.properties
index bf785e9f6..97bb544a9 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -23,7 +23,9 @@ DAGGER_VERSION=2.11
 
 COVERALLS_GRADLE_VERSION=2.4.0
 JUNIT_VERSION=4.12
-MOCKITO_VERSION=1.10.19
+# Matches the version in Google.
+MOCKITO_VERSION=1.9.5
+MOCKITO_ANDROID_VERSION=2.11.0
 ROBOLECTRIC_VERSION=3.3.2
 MOCKWEBSERVER_VERSION=3.0.0-RC1
 TRUTH_VERSION=0.26
diff --git a/instrumentation/build.gradle b/instrumentation/build.gradle
new file mode 100644
index 000000000..6f2fc3073
--- /dev/null
+++ b/instrumentation/build.gradle
@@ -0,0 +1,35 @@
+apply plugin: 'com.android.application'
+
+dependencies {
+    // Appcompat is required to ensure that Glide's runtime detection the v7 support Drawable
+    // loading classes functions. It's not clear why androidTestCompile isn't sufficient, but for
+    // whatever reason, compile is the only dependency that seems to work.
+    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    androidTestCompile project(':library')
+    androidTestCompile "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}"
+    androidTestCompile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    androidTestCompile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    androidTestCompile 'com.android.support.test:runner:0.5'
+    androidTestCompile 'com.android.support.test:rules:0.5'
+    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.instrumentation'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionCode 1
+        versionName '1.0'
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
new file mode 100644
index 000000000..d7153958f
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -0,0 +1,533 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.request.RequestOptions.bitmapTransform;
+import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.ResourceIds;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class NonBitmapDrawableResourcesTest {
+  private Context context;
+
+  @Rule
+  public ExpectedException expectedException = ExpectedException.none();
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.get(context).clearDiskCache();
+    Glide.tearDown();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(android.R.drawable.star_big_off)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asDrawable_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(android.R.drawable.star_big_off)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(android.R.drawable.star_big_off)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.bitmap_alias)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asDrawable_withTransformation_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.bitmap_alias)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.bitmap_alias)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_sizeOriginal_fails()
+      throws ExecutionException, InterruptedException {
+    expectedException.expect(ExecutionException.class);
+    Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_validSize_succeeds()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(bitmapTransform(new RoundedCorners(10)))
+        .submit(100, 200)
+        .get();
+    assertThat(drawable).isNotNull();
+    assertThat(drawable.getIntrinsicWidth()).isEqualTo(100);
+    assertThat(drawable.getIntrinsicHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withSizeOriginal_fails()
+      throws ExecutionException, InterruptedException {
+    expectedException.expect(ExecutionException.class);
+    Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit()
+        .get();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit(100, 200)
+        .get();
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_nonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(centerCropTransform())
+        .submit(100, 200)
+        .get();
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.state_list_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.state_list_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.state_list_drawable)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asBitmap_withTransformation_nonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.state_list_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.vector_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.vector_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.vector_drawable)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asBitmap_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.vector_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .submit()
+        .get();
+
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asDrawable_withTransformation_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .submit()
+        .get();
+
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asBitmap_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asDrawable_producesNonNullDrawable()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asDrawable_withTransformation_nonNullDrawable()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .apply(centerCropTransform())
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asBitmap_producesNonNullBitmap()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asBitmap_withTransformation_nonNullBitmap()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .apply(centerCropTransform())
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_nonNullDrawable()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .apply(centerCropTransform())
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNullBitmap()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .apply(centerCropTransform())
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  private Set<String> getInstalledPackages() {
+    Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
+    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+    PackageManager packageManager = context.getPackageManager();
+    List<ResolveInfo> pkgAppsList =
+        packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
+    Set<String> result = new HashSet<>();
+    for (ResolveInfo info : pkgAppsList) {
+      int iconResourceId = getResourceId(info.activityInfo.packageName);
+      if (iconResourceId != 0) {
+        result.add(info.activityInfo.packageName);
+      }
+    }
+    return result;
+  }
+
+  private int getResourceId(String packageName) {
+    PackageInfo packageInfo;
+    try {
+      packageInfo = context.getPackageManager().getPackageInfo(packageName, /*flags=*/ 0);
+    } catch (NameNotFoundException e) {
+      return 0;
+    }
+    return packageInfo.applicationInfo.icon;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
new file mode 100644
index 000000000..1447ed9bd
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
@@ -0,0 +1,619 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static android.graphics.Bitmap.CompressFormat.JPEG;
+import static android.graphics.Bitmap.CompressFormat.PNG;
+import static android.graphics.Bitmap.CompressFormat.WEBP;
+import static android.os.Build.VERSION_CODES.KITKAT;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.apis;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.atAndAbove;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.below;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.onAllApisAndAllFormatsExpect;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Formats.Builder.allFormats;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Formats.Builder.formats;
+import static org.junit.Assert.fail;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.Nullable;
+import android.support.test.runner.AndroidJUnit4;
+import android.util.DisplayMetrics;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Runs tests to make sure that DownsampleStrategy provides the output we expect.
+ *
+ * WEBP at and above N rounds. Webp below N floors. PNG always floors. JPEG always rounds.
+ */
+@RunWith(AndroidJUnit4.class)
+@SuppressWarnings("VisibleForTests")
+public class DownsamplerEmulatorTest {
+
+  @Test
+  public void calculateScaling_withAtMost() throws IOException {
+    new Tester(DownsampleStrategy.AT_MOST)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(75, 75))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(99, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(99, 12)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(50, 6))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(13, 100),
+                    formats(PNG)
+                        .expect(12, 100)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 100),
+                    formats(PNG, WEBP)
+                        .expect(12, 100)))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        // This set of examples demonstrate that webp uses round on N+ and floor < N.
+        .setTargetDimensions(13, 13)
+        .givenSquareImageWithDimensionOf(99,
+            atAndAbove(KITKAT)
+                .with(
+                    // 99 / 8.0 = 12.375. ceil(12.375) = 13. round(12.375) = 12. floor(12.375) = 12.
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)))
+        .givenSquareImageWithDimensionOf(100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    // 100 / 8.0 = 12.5. ceil(12.5) = 13. round(12.5) = 13. floor(12.5) = 12.
+                    formats(JPEG, WEBP)
+                        .expect(13, 13),
+                    formats(PNG)
+                        .expect(12, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withAtLeast() throws IOException {
+    new Tester(DownsampleStrategy.AT_LEAST)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(150, 150))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withCenterInside() throws IOException {
+    new Tester(DownsampleStrategy.CENTER_INSIDE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(200, 25),
+                    formats(PNG, WEBP)
+                        .expect(199, 25)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT).with(allFormats().expect(200, 25)))
+        .givenImageWithDimensionsOf(801, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            apis(KITKAT, VERSION_CODES.M)
+              .with(
+                  formats(JPEG)
+                      .expect(100, 13),
+                  formats(PNG, WEBP)
+                      .expect(100, 12)),
+            below(KITKAT)
+                .with(
+                    // JPEG is correct because CENTER_INSIDE wants to give a subsequent
+                    // transformation an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, CENTER_INSIDE can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a subsequent transformation will
+                    // be called.
+                    formats(JPEG)
+                        .expect(101, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
+            below(KITKAT).with(allFormats().expect(25, 200)))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        .setTargetDimensions(897, 897)
+        .givenImageWithDimensionsOf(2208, 1520,
+            atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
+            below(KITKAT).with(allFormats().expect(1104, 760)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withCenterOutside() throws IOException {
+    new Tester(DownsampleStrategy.CENTER_OUTSIDE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78,
+            atAndAbove(KITKAT).with(allFormats().expect(112, 100)),
+            below(KITKAT).with(allFormats().expect(87, 78)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(200, 200)))
+        .givenSquareImageWithDimensionOf(450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(450, 450)))
+        .givenImageWithDimensionsOf(200, 450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 1125)),
+            below(KITKAT).with(allFormats().expect(200, 450)))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withNone() throws IOException {
+    new Tester(DownsampleStrategy.NONE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(400, 400))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(300, 300))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withFitCenter() throws IOException {
+    new Tester(DownsampleStrategy.FIT_CENTER)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(200, 25),
+                    formats(PNG, WEBP)
+                        .expect(199, 25)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT).with(allFormats().expect(200, 25)))
+        .givenImageWithDimensionsOf(801, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            apis(KITKAT, VERSION_CODES.M)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)),
+            below(KITKAT)
+                .with(
+                    // JPEG is correct because FIT_CENTER wants to give a subsequent transformation
+                    // an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, FIT_CENTER can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a transformation will be run
+                    // after it that will fix the rounding error.
+                    formats(JPEG)
+                        .expect(101, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
+            below(KITKAT).with(allFormats().expect(25, 200)))
+        .givenImageWithDimensionsOf(87, 78,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 90)),
+            below(KITKAT).with(allFormats().expect(87, 78)))
+        .setTargetDimensions(897, 897)
+        .givenImageWithDimensionsOf(2208, 1520,
+            atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
+            below(KITKAT).with(allFormats().expect(1104, 760)))
+        .setTargetDimensions(270, 270)
+        // This set of larger image examples exercises sample sizes > 8. Android' scaling logic
+        // varies for jpegs.
+        .givenImageWithDimensionsOf(9014, 1638,
+            // 15 and 16 will OOM so don't run them.
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
+                .with(allFormats().expect(281, 51)))
+        .givenImageWithDimensionsOf(1638, 9014,
+            // 15 and 16 will OOM so don't run them.
+            atAndAbove(KITKAT).with(allFormats().expect(49, 270)),
+            apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
+                .with(allFormats().expect(51, 281)))
+        .givenImageWithDimensionsOf(1638, 1638,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 270)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(410, 410),
+                    formats(PNG, WEBP)
+                        .expect(409, 409)))
+        .givenImageWithDimensionsOf(4507, 819,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            below(KITKAT).with(
+                formats(JPEG)
+                    .expect(282, 51),
+                formats(PNG, WEBP)
+                    .expect(281, 51)))
+        .givenImageWithDimensionsOf(4503, 819,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            below(KITKAT).with(allFormats().expect(281, 51)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(200, 200)))
+        .givenSquareImageWithDimensionOf(450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(450, 450)))
+        .givenImageWithDimensionsOf(200, 450,
+            atAndAbove(KITKAT).with(allFormats().expect(222, 500)),
+            below(KITKAT).with(allFormats().expect(200, 450)))
+        .run();
+  }
+
+  /** Returns an error string if the test failed, and {@code null} otherwise. */
+  @Nullable
+  private static String runScaleTest(
+      CompressFormat format,
+      int initialWidth,
+      int initialHeight,
+      int targetWidth,
+      int targetHeight,
+      DownsampleStrategy strategy,
+      int expectedWidth,
+      int expectedHeight) throws IOException {
+    Downsampler downsampler = buildDownsampler();
+
+    InputStream is = openBitmapStream(format, initialWidth, initialHeight);
+    Options options = new Options()
+        .set(Downsampler.DOWNSAMPLE_STRATEGY, strategy);
+    Bitmap bitmap = downsampler.decode(is, targetWidth, targetHeight, options).get();
+    try {
+      if (bitmap.getWidth() != expectedWidth || bitmap.getHeight() != expectedHeight) {
+        return "API: " + Build.VERSION.SDK_INT + ", os: " + Build.VERSION.RELEASE
+            + ", format: " + format + ", strategy: " + strategy + " -"
+            + " Initial " + readableDimens(initialWidth, initialHeight)
+            + " Target " + readableDimens(targetWidth, targetHeight)
+            + " Expected " + readableDimens(expectedWidth, expectedHeight)
+            + ", but Received " + readableDimens(bitmap.getWidth(), bitmap.getHeight());
+      }
+    } finally {
+      bitmap.recycle();
+    }
+    return null;
+  }
+
+  private static String readableDimens(int width, int height) {
+    return "[" + width + "x" + height + "]";
+  }
+
+  private static Downsampler buildDownsampler() {
+    List<ImageHeaderParser> parsers =
+        Collections.<ImageHeaderParser>singletonList(new DefaultImageHeaderParser());
+    DisplayMetrics displayMetrics = new DisplayMetrics();
+    // XHDPI.
+    displayMetrics.densityDpi = 320;
+    BitmapPool bitmapPool = new BitmapPoolAdapter();
+    ArrayPool arrayPool = new LruArrayPool();
+    return new Downsampler(parsers, displayMetrics, bitmapPool, arrayPool);
+  }
+
+  private static InputStream openBitmapStream(CompressFormat format, int width, int height) {
+    Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(format, 100 /*quality*/, os);
+    bitmap.recycle();
+    byte[] data = os.toByteArray();
+    return new ByteArrayInputStream(data);
+  }
+
+  static final class Tester {
+    private final DownsampleStrategy strategy;
+    private final List<TestCase> testCases = new ArrayList<>();
+
+    private int targetWidth;
+    private int targetHeight;
+
+    Tester(DownsampleStrategy strategy) {
+      this.strategy = strategy;
+    }
+
+    Tester setTargetDimensions(int targetWidth, int targetHeight) {
+      this.targetWidth = targetWidth;
+      this.targetHeight = targetHeight;
+      return this;
+    }
+
+    Tester givenSquareImageWithDimensionOf(int dimension, Api... apis) throws IOException {
+      return givenImageWithDimensionsOf(dimension, dimension, apis);
+    }
+
+    Tester givenImageWithDimensionsOf(
+        int sourceWidth, int sourceHeight, Api... apis) throws IOException {
+      testCases.add(new TestCase(sourceWidth, sourceHeight, targetWidth, targetHeight, apis));
+      return this;
+    }
+
+    void run() throws IOException {
+      List<String> results = new ArrayList<>();
+      for (TestCase testCase : testCases) {
+        results.addAll(testCase.test(strategy));
+      }
+
+      if (results.isEmpty()) {
+        return;
+      }
+
+      String failure = "Failing Tests:\n";
+      for (String result : results) {
+        failure += result + "\n";
+      }
+      fail(failure.substring(0, failure.length() - 1));
+    }
+
+    private static final class TestCase {
+      private final int sourceWidth;
+      private final int sourceHeight;
+      private final int targetWidth;
+      private final int targetHeight;
+      private final Api[] apis;
+
+      TestCase(int sourceWidth, int sourceHeight, int targetWidth, int targetHeight, Api... apis) {
+        this.sourceWidth = sourceWidth;
+        this.sourceHeight = sourceHeight;
+        this.targetWidth = targetWidth;
+        this.targetHeight = targetHeight;
+        this.apis = apis;
+      }
+
+      List<String> test(DownsampleStrategy strategy)
+          throws IOException {
+        List<String> results = new ArrayList<>();
+        for (Api api : apis) {
+          results.addAll(api.test(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
+        }
+        return results;
+      }
+    }
+  }
+
+  static final class Api {
+    private final int startVersion;
+    private final int stopVersion;
+    private Formats[] formats;
+
+    static Builder apis(int min, int max) {
+      return new Builder().min(min).max(max);
+    }
+
+    static Builder atAndAbove(int min) {
+      return new Builder().min(min);
+    }
+
+    static Builder below(int max) {
+      // max is inclusive.
+      return new Builder().max(max - 1);
+    }
+
+    static Builder allApis() {
+      return new Builder();
+    }
+
+    static Api onAllApisAndAllFormatsExpect(int width, int height) {
+      return allApis().with(allFormats().expect(width, height));
+    }
+
+    static final class Builder {
+      private int maxVersion = Integer.MAX_VALUE;
+      private int minVersion = Integer.MIN_VALUE;
+
+      Builder min(int version) {
+        minVersion = version;
+        return this;
+      }
+
+      Builder max(int version) {
+        this.maxVersion = version;
+        return this;
+      }
+
+      Api with(Formats... formats) {
+        return new Api(minVersion, maxVersion, formats);
+      }
+    }
+
+    Api(int startVersion, int stopVersion, Formats... formats) {
+      this.startVersion = startVersion;
+      this.stopVersion = stopVersion;
+      this.formats = formats;
+    }
+
+    List<String> test(
+        int sourceWidth,
+        int sourceHeight,
+        int targetWidth,
+        int targetHeight,
+        DownsampleStrategy strategy)
+        throws IOException {
+      if (Build.VERSION.SDK_INT < startVersion || Build.VERSION.SDK_INT > stopVersion) {
+        return Collections.emptyList();
+      }
+
+      List<String> results = new ArrayList<>();
+      for (Formats format : formats) {
+        results.addAll(
+            format.runTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
+
+      }
+      return results;
+    }
+  }
+
+  static final class Formats {
+    private final int expectedWidth;
+    private final int expectedHeight;
+    private final CompressFormat[] formats;
+
+    static final class Builder {
+      private final CompressFormat[] formats;
+
+      static Builder allFormats() {
+        return formats(CompressFormat.values());
+      }
+
+      static Builder formats(CompressFormat... formats) {
+        return new Builder(formats);
+      }
+
+      Builder(CompressFormat... formats) {
+        this.formats = formats;
+      }
+
+      Formats expect(int width, int height) {
+        return new Formats(formats, width, height);
+      }
+    }
+
+    Formats(CompressFormat[] formats, int expectedWidth, int expectedHeight) {
+      this.formats = formats;
+      this.expectedWidth = expectedWidth;
+      this.expectedHeight = expectedHeight;
+    }
+
+    List<String> runTest(
+        int sourceWidth,
+        int sourceHeight,
+        int targetWidth,
+        int targetHeight,
+        DownsampleStrategy strategy) throws IOException {
+      List<String> result = new ArrayList<>();
+      for (CompressFormat format : formats) {
+        String testResult = runScaleTest(
+            format,
+            sourceWidth,
+            sourceHeight,
+            targetWidth,
+            targetHeight,
+            strategy,
+            expectedWidth,
+            expectedHeight);
+        if (testResult != null) {
+          result.add(testResult);
+        }
+      }
+      return result;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
new file mode 100644
index 000000000..85a97967b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -0,0 +1,109 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.test.ResourceIds;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Emulator tests for Glide transformation utilities.
+ */
+@RunWith(AndroidJUnit4.class)
+public class TransformationUtilsTest {
+  private BitmapPool bitmapPool;
+  private Context context;
+
+  @Before
+  public void setUp() throws Exception {
+    bitmapPool = new BitmapPoolAdapter();
+    context = InstrumentationRegistry.getTargetContext();
+    // TODO: Add Android API specific resources that work > API 16.
+    assumeTrue(Build.VERSION.SDK_INT <= VERSION_CODES.JELLY_BEAN);
+  }
+
+  @Test
+  public void testRoundedCorners() {
+    int width = 20;
+    int height = 30;
+    Bitmap blueRect = createRect(Color.BLUE, width, height, Bitmap.Config.ARGB_8888);
+    Bitmap roundedBlueRect =
+        TransformationUtils.roundedCorners(bitmapPool, blueRect, 5);
+    assertBitmapMatches(ResourceIds.raw.blue_rect_rounded, roundedBlueRect);
+  }
+
+  @Test
+  public void testRoundedCorners_usePool() {
+    int width = 20;
+    int height = 30;
+
+    Bitmap blueRect = createRect(Color.BLUE, width, height, Bitmap.Config.ARGB_8888);
+    Bitmap redRect = createRect(Color.RED, width, height, Bitmap.Config.ARGB_8888);
+    BitmapPool mockBitmapPool = mock(BitmapPool.class);
+    when(mockBitmapPool.get(width, height, Config.ARGB_8888)).thenReturn(redRect);
+
+    Bitmap roundedBlueRect =
+        TransformationUtils.roundedCorners(mockBitmapPool, blueRect, 5);
+    assertBitmapMatches(ResourceIds.raw.blue_rect_rounded, roundedBlueRect);
+    assertThat(roundedBlueRect).isEqualTo(redRect);
+  }
+
+  @Test
+  public void testRoundedCorners_overRounded() {
+    int width = 40;
+    int height = 20;
+    Bitmap blueRect = createRect(Color.BLUE, width, height, Bitmap.Config.RGB_565);
+    Bitmap roundedBlueRect =
+        TransformationUtils.roundedCorners(bitmapPool, blueRect, 20);
+    assertBitmapMatches(ResourceIds.raw.blue_rect_over_rounded, roundedBlueRect);
+  }
+
+  private Bitmap createRect(int color, int width, int height, Bitmap.Config config) {
+    final Bitmap result = Bitmap.createBitmap(width, height, config);
+    Canvas canvas = new Canvas(result);
+    canvas.drawColor(color);
+    return result;
+  }
+
+  private void assertBitmapMatches(int resId, Bitmap actual) {
+    Resources res = context.getResources();
+    // Avoid default density scaling when decoding the expected Bitmap.
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    Bitmap expected = BitmapFactory.decodeResource(res, resId, options);
+    assertPixelDataMatches(expected, actual);
+  }
+
+  /**
+   * TODO(user): Pull this out into a helper library and add tests for it. Would also be good
+   * to get a tool for updating expected bitmaps on functionality changes and new tests.
+   */
+  private void assertPixelDataMatches(Bitmap expected, Bitmap actual) {
+    assertEquals(expected.getWidth(), actual.getWidth());
+    assertEquals(expected.getHeight(), actual.getHeight());
+
+    for (int y = 0; y < expected.getHeight(); y++) {
+      for (int x = 0; x < expected.getWidth(); x++) {
+        assertEquals(expected.getPixel(x, y), actual.getPixel(x, y));
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
new file mode 100644
index 000000000..50e9cff05
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
@@ -0,0 +1,34 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.support.test.InstrumentationRegistry;
+
+/**
+ * Internally in google we don't appear to be able to reference resource ids directly, this class is
+ * a hack around that until we figure out what's going wrong.
+ */
+public final class ResourceIds {
+  private ResourceIds() {
+    // Utility class.
+  }
+
+  public interface raw {
+    int blue_rect_over_rounded = getResourceId("raw", "blue_rect_over_rounded");
+    int blue_rect_rounded = getResourceId("raw", "blue_rect_rounded");
+  }
+
+  public interface drawable {
+    int bitmap_alias = getResourceId("drawable", "bitmap_alias");
+    int googlelogo_color_120x44dp= getResourceId("drawable", "googlelogo_color_120x44dp");
+    int shape_drawable = getResourceId("drawable", "shape_drawable");
+    int state_list_drawable = getResourceId("drawable", "state_list_drawable");
+    int vector_drawable = getResourceId("drawable", "vector_drawable");
+  }
+
+  private static int getResourceId(String type, String resourceName) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    Resources res = context.getResources();
+    return res.getIdentifier(resourceName, type, context.getPackageName());
+  }
+}
diff --git a/instrumentation/src/main/AndroidManifest.xml b/instrumentation/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..706827159
--- /dev/null
+++ b/instrumentation/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.instrumentation">
+  <application />
+</manifest>
diff --git a/library/src/androidTest/res/drawable/bitmap_alias.xml b/instrumentation/src/main/res/drawable/bitmap_alias.xml
similarity index 100%
rename from library/src/androidTest/res/drawable/bitmap_alias.xml
rename to instrumentation/src/main/res/drawable/bitmap_alias.xml
diff --git a/library/src/androidTest/res/drawable/googlelogo_color_120x44dp.9.png b/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png
old mode 100755
new mode 100644
similarity index 100%
rename from library/src/androidTest/res/drawable/googlelogo_color_120x44dp.9.png
rename to instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png
diff --git a/library/src/androidTest/res/drawable/shape_drawable.xml b/instrumentation/src/main/res/drawable/shape_drawable.xml
similarity index 100%
rename from library/src/androidTest/res/drawable/shape_drawable.xml
rename to instrumentation/src/main/res/drawable/shape_drawable.xml
diff --git a/library/src/androidTest/res/drawable/state_list_drawable.xml b/instrumentation/src/main/res/drawable/state_list_drawable.xml
similarity index 100%
rename from library/src/androidTest/res/drawable/state_list_drawable.xml
rename to instrumentation/src/main/res/drawable/state_list_drawable.xml
diff --git a/library/src/androidTest/res/drawable/vector_drawable.xml b/instrumentation/src/main/res/drawable/vector_drawable.xml
similarity index 100%
rename from library/src/androidTest/res/drawable/vector_drawable.xml
rename to instrumentation/src/main/res/drawable/vector_drawable.xml
diff --git a/instrumentation/src/main/res/raw/blue_rect_over_rounded.png b/instrumentation/src/main/res/raw/blue_rect_over_rounded.png
new file mode 100644
index 000000000..c4cc26a1e
Binary files /dev/null and b/instrumentation/src/main/res/raw/blue_rect_over_rounded.png differ
diff --git a/instrumentation/src/main/res/raw/blue_rect_rounded.png b/instrumentation/src/main/res/raw/blue_rect_rounded.png
new file mode 100644
index 000000000..86229d517
Binary files /dev/null and b/instrumentation/src/main/res/raw/blue_rect_rounded.png differ
diff --git a/instrumentation/src/main/res/values/strings.xml b/instrumentation/src/main/res/values/strings.xml
new file mode 100644
index 000000000..55344e519
--- /dev/null
+++ b/instrumentation/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+</resources>
\ No newline at end of file
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 3ef29e0f6..a5defa841 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -6,7 +6,7 @@ dependencies {
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
     testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 }
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index dde1d0243..9d449e805 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -70,6 +70,7 @@ public void setUp() {
     Application context = RuntimeEnvironment.application;
 
     ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
+    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
     when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
     when(factory.buildParser()).thenReturn(parser);
     when(factory.buildEncoder()).thenReturn(gifEncoder);
diff --git a/library/build.gradle b/library/build.gradle
index 5ac346e41..d69a6f3ef 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -19,11 +19,6 @@ dependencies {
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
     testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
     testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
-    androidTestCompile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
-    androidTestCompile 'com.android.support.test:runner:0.5'
-    androidTestCompile 'com.android.support.test:rules:0.5'
-    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    androidTestCompile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
 }
 
 android.testOptions.unitTests.all { Test testTask ->
@@ -44,7 +39,6 @@ android {
         targetSdkVersion TARGET_SDK_VERSION as int
         versionName VERSION_NAME as String
         consumerProguardFiles 'proguard-rules.txt'
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
 
     buildTypes {
diff --git a/library/src/androidTest/java/com/bumptech/glide/test/TestNonBitmapResources.java b/library/src/androidTest/java/com/bumptech/glide/test/TestNonBitmapResources.java
deleted file mode 100644
index 8f8acd531..000000000
--- a/library/src/androidTest/java/com/bumptech/glide/test/TestNonBitmapResources.java
+++ /dev/null
@@ -1,167 +0,0 @@
-package com.bumptech.glide.test;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
-import android.net.Uri;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import com.bumptech.glide.Glide;
-import com.google.common.collect.ImmutableList;
-import java.util.concurrent.ExecutionException;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-@RunWith(AndroidJUnit4.class)
-public class TestNonBitmapResources {
-
-  private Context context;
-
-  @Before
-  public void setUp() {
-    context = InstrumentationRegistry.getTargetContext();
-  }
-
-  @After
-  public void tearDown() {
-    Glide.tearDown();
-  }
-
-  @Test
-  public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable()
-      throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(android.R.drawable.star_big_off)
-        .submit()
-        .get();
-    assertThat(drawable).isNotNull();
-  }
-
-  @Test
-  public void load_withBitmapResourceId_asBitmap_producesNonNullBitmap()
-      throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(android.R.drawable.star_big_off)
-        .submit()
-        .get();
-    assertThat(bitmap).isNotNull();
-  }
-
-  @Test
-  public void load_withBitmapAliasResourceId_asDrawable_producesNonNullDrawable()
-      throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(R.drawable.bitmap_alias)
-        .submit()
-        .get();
-    assertThat(drawable).isNotNull();
-  }
-
-  @Test
-  public void load_withShapeDrawableResourceId_asDrawable_producesNonNullDrawable()
-      throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(R.drawable.shape_drawable)
-        .submit()
-        .get();
-    assertThat(drawable).isNotNull();
-  }
-
-  @Test
-  public void load_withStateListDrawableResourceId_asDrawable_producesNonNullDrawable()
-      throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(R.drawable.state_list_drawable)
-        .submit()
-        .get();
-    assertThat(drawable).isNotNull();
-  }
-
-  @Test
-  public void load_withVectorDrawableResourceId_asDrawable_producesNonNullDrawable()
-      throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(R.drawable.vector_drawable)
-        .submit()
-        .get();
-    assertThat(drawable).isNotNull();
-  }
-
-  @Test
-  public void load_withApplicationIconResourceIdUri_asDrawable_producesNonNullDrawable()
-      throws NameNotFoundException, ExecutionException, InterruptedException {
-    ImmutableList<String> packages = ImmutableList.of(
-        "com.google.android.apps.photos",
-        "com.google.android.apps.messaging"
-    );
-    PackageManager packageManager = context.getPackageManager();
-    for (String packageName : packages) {
-      PackageInfo packageInfo =
-          packageManager.getPackageInfo(packageName, /*flags=*/ 0);
-      int iconResourceId = packageInfo.applicationInfo.icon;
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .submit()
-          .get();
-      assertThat(drawable).isNotNull();
-    }
-  }
-
-  @Test
-  public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
-      throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(R.drawable.googlelogo_color_120x44dp)
-        .submit()
-        .get();
-
-    assertThat(drawable).isNotNull();
-  }
-
-  @Test
-  public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDrawable()
-      throws ExecutionException, InterruptedException, NameNotFoundException {
-     ImmutableList<String> packages = ImmutableList.of(
-        "com.google.android.apps.photos",
-        "com.google.android.apps.messaging"
-    );
-    PackageManager packageManager = context.getPackageManager();
-    for (String packageName : packages) {
-      PackageInfo packageInfo =
-          packageManager.getPackageInfo(packageName, /*flags=*/ 0);
-      int iconResourceId = packageInfo.applicationInfo.icon;
-
-      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
-      Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(resources.getResourceTypeName(iconResourceId))
-          .path(resources.getResourceEntryName(iconResourceId))
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .submit()
-          .get();
-      assertThat(drawable).isNotNull();
-    }
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index c1251eab7..d655e2377 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -52,10 +52,13 @@
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.ResourceBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
 import com.bumptech.glide.load.resource.bytes.ByteBufferRewinder;
 import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;
 import com.bumptech.glide.load.resource.file.FileDecoder;
 import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -299,40 +302,69 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
         new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+    VideoBitmapDecoder videoBitmapDecoder = new VideoBitmapDecoder(bitmapPool);
+    ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
+    StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
+    ResourceDrawableDecoder resourceDrawableDecoder =
+        new ResourceDrawableDecoder(context);
+    ResourceLoader.StreamFactory resourceLoaderStreamFactory =
+        new ResourceLoader.StreamFactory(resources);
+    ResourceLoader.UriFactory resourceLoaderUriFactory =
+        new ResourceLoader.UriFactory(resources);
+    ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
+        new ResourceLoader.FileDescriptorFactory(resources);
+    BitmapEncoder bitmapEncoder = new BitmapEncoder();
 
     registry
         .append(ByteBuffer.class, new ByteBufferEncoder())
         .append(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
-        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class,
-            new ByteBufferBitmapDecoder(downsampler))
-        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class,
-            new StreamBitmapDecoder(downsampler, arrayPool))
-        .append(Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class,
-            new VideoBitmapDecoder(bitmapPool))
-        .append(Bitmap.class, new BitmapEncoder())
-        /* GlideBitmapDrawables */
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, ByteBuffer.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new ByteBufferBitmapDecoder(downsampler)))
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, InputStream.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new StreamBitmapDecoder(downsampler, arrayPool)))
-        .append(Registry.BUCKET_BITMAP_DRAWABLE, ParcelFileDescriptor.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
-        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
+        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)
+        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)
+        .append(
+            Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class, videoBitmapDecoder)
+        .append(
+            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
+        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
+        .append(Bitmap.class, bitmapEncoder)
+        /* BitmapDrawables */
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ByteBuffer.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, bitmapPool, byteBufferBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            InputStream.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, bitmapPool, streamBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ParcelFileDescriptor.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, bitmapPool, videoBitmapDecoder))
+        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
         /* GIFs */
-        .append(Registry.BUCKET_GIF, InputStream.class, GifDrawable.class,
+        .append(
+            Registry.BUCKET_GIF,
+            InputStream.class,
+            GifDrawable.class,
             new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
         .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
         .append(GifDrawable.class, new GifDrawableEncoder())
         /* GIF Frames */
         // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
-        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
-        .append(Registry.BUCKET_BITMAP, GifDecoder.class, Bitmap.class,
+        .append(
+            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP,
+            GifDecoder.class,
+            Bitmap.class,
             new GifFrameResourceDecoder(bitmapPool))
         /* Drawables */
-        .append(Uri.class, Drawable.class, new ResourceDrawableDecoder(context))
+        .append(Uri.class, Drawable.class, resourceDrawableDecoder)
+        .append(
+            Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))
         /* Files */
         .register(new ByteBufferRewinder.Factory())
         .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
@@ -340,21 +372,21 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         .append(File.class, File.class, new FileDecoder())
         .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
         // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
-        .append(File.class, File.class, new UnitModelLoader.Factory<File>())
+        .append(File.class, File.class, UnitModelLoader.Factory.<File>getInstance())
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(int.class, InputStream.class, resourceLoaderStreamFactory)
         .append(
                 int.class,
                 ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+                resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
         .append(
                 Integer.class,
                 ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
-        .append(Integer.class, Uri.class, new ResourceLoader.UriFactory(resources))
-        .append(int.class, Uri.class, new ResourceLoader.UriFactory(resources))
+                resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, Uri.class, resourceLoaderUriFactory)
+        .append(int.class, Uri.class, resourceLoaderUriFactory)
         .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
@@ -378,9 +410,13 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
-        .append(Uri.class, Uri.class, new UnitModelLoader.Factory<Uri>())
+        .append(Uri.class, Uri.class, UnitModelLoader.Factory.<Uri>getInstance())
+        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance())
+        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())
         /* Transcoders */
-        .register(Bitmap.class, BitmapDrawable.class,
+        .register(
+            Bitmap.class,
+            BitmapDrawable.class,
             new BitmapDrawableTranscoder(resources, bitmapPool))
         .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
         .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index e755b07f4..d394cc0cd 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -1,8 +1,11 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
 import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.support.annotation.CheckResult;
 import android.support.annotation.DrawableRes;
@@ -317,7 +320,53 @@ protected RequestOptions getMutableOptions() {
   }
 
   /**
-   * Returns a request builder to load the given {@link java.lang.String}. signature.
+   * Returns a request builder to load the given {@link Bitmap}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
+   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
+   * not supported by Glide by default, consider registering a custom
+   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other
+   * strategies may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @CheckResult
+  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return loadGeneric(bitmap)
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
+
+  /**
+   * Returns a request builder to load the given {@link Drawable}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
+   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
+   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
+   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other
+   * strategies may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @CheckResult
+  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
+    return loadGeneric(drawable)
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
+
+  /**
+   * Returns a request builder to load the given {@link java.lang.String}.
    *
    * <p> Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
@@ -476,10 +525,19 @@ protected RequestOptions getMutableOptions() {
    * @see RequestManager#clear(Target)
    */
   public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
-    return into(target, getMutableOptions());
+    return into(target, /*targetListener=*/ null);
+  }
+
+  private <Y extends Target<TranscodeType>> Y into(
+      @NonNull Y target,
+      @Nullable RequestListener<TranscodeType> targetListener) {
+    return into(target, targetListener, getMutableOptions());
   }
 
-  private <Y extends Target<TranscodeType>> Y into(@NonNull Y target, RequestOptions options) {
+  private <Y extends Target<TranscodeType>> Y into(
+      @NonNull Y target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      RequestOptions options) {
     Util.assertMainThread();
     Preconditions.checkNotNull(target);
     if (!isModelSet) {
@@ -487,7 +545,7 @@ protected RequestOptions getMutableOptions() {
     }
 
     options = options.autoClone();
-    Request request = buildRequest(target, options);
+    Request request = buildRequest(target, targetListener, options);
 
     Request previous = target.getRequest();
     if (request.isEquivalentTo(previous)) {
@@ -557,7 +615,10 @@ protected RequestOptions getMutableOptions() {
       }
     }
 
-    return into(glideContext.buildImageViewTarget(view, transcodeClass), requestOptions);
+    return into(
+        glideContext.buildImageViewTarget(view, transcodeClass),
+        /*targetListener=*/ null,
+        requestOptions);
   }
 
   /**
@@ -617,12 +678,12 @@ protected RequestOptions getMutableOptions() {
         @Override
         public void run() {
           if (!target.isCancelled()) {
-            into(target);
+            into(target, target);
           }
         }
       });
     } else {
-      into(target);
+      into(target, target);
     }
 
     return target;
@@ -717,15 +778,30 @@ private Priority getThumbnailPriority(Priority current) {
     }
   }
 
-  private Request buildRequest(Target<TranscodeType> target, RequestOptions requestOptions) {
-    return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),
-        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions);
-  }
-
-  private Request buildRequestRecursive(Target<TranscodeType> target,
+  private Request buildRequest(
+      Target<TranscodeType> target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      RequestOptions requestOptions) {
+    return buildRequestRecursive(
+        target,
+        targetListener,
+        /*parentCoordinator=*/ null,
+        transitionOptions,
+        requestOptions.getPriority(),
+        requestOptions.getOverrideWidth(),
+        requestOptions.getOverrideHeight(),
+        requestOptions);
+  }
+
+  private Request buildRequestRecursive(
+      Target<TranscodeType> target,
+      @Nullable RequestListener<TranscodeType> targetListener,
       @Nullable RequestCoordinator parentCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) {
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight,
+      RequestOptions requestOptions) {
 
     // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
     ErrorRequestCoordinator errorRequestCoordinator = null;
@@ -737,6 +813,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
     Request mainRequest =
         buildThumbnailRequestRecursive(
             target,
+            targetListener,
             parentCoordinator,
             transitionOptions,
             priority,
@@ -758,6 +835,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
 
     Request errorRequest = errorBuilder.buildRequestRecursive(
         target,
+        targetListener,
         errorRequestCoordinator,
         errorBuilder.transitionOptions,
         errorBuilder.requestOptions.getPriority(),
@@ -768,10 +846,15 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
     return errorRequestCoordinator;
   }
 
-  private Request buildThumbnailRequestRecursive(Target<TranscodeType> target,
-        @Nullable RequestCoordinator parentCoordinator,
-        TransitionOptions<?, ? super TranscodeType> transitionOptions,
-        Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) {
+  private Request buildThumbnailRequestRecursive(
+      Target<TranscodeType> target,
+      RequestListener<TranscodeType> targetListener,
+      @Nullable RequestCoordinator parentCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight,
+      RequestOptions requestOptions) {
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
@@ -800,13 +883,22 @@ private Request buildThumbnailRequestRecursive(Target<TranscodeType> target,
       }
 
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest = obtainRequest(target, requestOptions, coordinator,
-          transitionOptions, priority, overrideWidth, overrideHeight);
+      Request fullRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              requestOptions,
+              coordinator,
+              transitionOptions,
+              priority,
+              overrideWidth,
+              overrideHeight);
       isThumbnailBuilt = true;
       // Recursively generate thumbnail requests.
       Request thumbRequest =
           thumbnailBuilder.buildRequestRecursive(
               target,
+              targetListener,
               coordinator,
               thumbTransitionOptions,
               thumbPriority,
@@ -819,27 +911,55 @@ private Request buildThumbnailRequestRecursive(Target<TranscodeType> target,
     } else if (thumbSizeMultiplier != null) {
       // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
-          priority, overrideWidth, overrideHeight);
+      Request fullRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              requestOptions,
+              coordinator,
+              transitionOptions,
+              priority,
+              overrideWidth,
+              overrideHeight);
       RequestOptions thumbnailOptions = requestOptions.clone()
           .sizeMultiplier(thumbSizeMultiplier);
 
-      Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
-          transitionOptions, getThumbnailPriority(priority), overrideWidth, overrideHeight);
+      Request thumbnailRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              thumbnailOptions,
+              coordinator,
+              transitionOptions,
+              getThumbnailPriority(priority),
+              overrideWidth,
+              overrideHeight);
 
       coordinator.setRequests(fullRequest, thumbnailRequest);
       return coordinator;
     } else {
       // Base case: no thumbnail.
-      return obtainRequest(target, requestOptions, parentCoordinator, transitionOptions, priority,
-          overrideWidth, overrideHeight);
+      return obtainRequest(
+          target,
+          targetListener,
+          requestOptions,
+          parentCoordinator,
+          transitionOptions,
+          priority,
+          overrideWidth,
+          overrideHeight);
     }
   }
 
-  private Request obtainRequest(Target<TranscodeType> target,
-      RequestOptions requestOptions, RequestCoordinator requestCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
-      int overrideWidth, int overrideHeight) {
+  private Request obtainRequest(
+      Target<TranscodeType> target,
+      RequestListener<TranscodeType> targetListener,
+      RequestOptions requestOptions,
+      RequestCoordinator requestCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight) {
     return SingleRequest.obtain(
         context,
         glideContext,
@@ -850,6 +970,7 @@ private Request obtainRequest(Target<TranscodeType> target,
         overrideHeight,
         priority,
         target,
+        targetListener,
         requestListener,
         requestCoordinator,
         glideContext.getEngine(),
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 5c6529ff0..597100ac6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -16,6 +16,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 final class DecodeHelper<Transcode> {
 
@@ -142,7 +143,16 @@ boolean isScaleOnlyOrNoTransform() {
   @SuppressWarnings("unchecked")
   <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
     Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
-     if (result == null) {
+    if (result == null) {
+      for (Entry<Class<?>, Transformation<?>> entry : transformations.entrySet()) {
+        if (entry.getKey().isAssignableFrom(resourceClass)) {
+          result = (Transformation<Z>) entry.getValue();
+          break;
+        }
+      }
+    }
+
+    if (result == null) {
       if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
             "Missing transformation for " + resourceClass + ". If you wish to"
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 045100156..9bc35e27b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -235,6 +235,7 @@ public void run() {
       }
       // When we're encoding we've already notified our callback and it isn't safe to do so again.
       if (stage != Stage.ENCODE) {
+        exceptions.add(e);
         notifyFailed();
       }
       if (!isCancelled) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index b66014a04..02683a922 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -140,7 +140,7 @@ public static GlideExecutor newSourceExecutor() {
    */
   public static GlideExecutor newSourceExecutor(
           UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+    return newSourceExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
                                 DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 602fac513..f19a19deb 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -111,7 +111,7 @@ public UriFactory(Resources resources) {
 
     @Override
     public ModelLoader<Integer, Uri> build(MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(resources, new UnitModelLoader<Uri>());
+      return new ResourceLoader<>(resources, UnitModelLoader.<Uri>getInstance());
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index 8a3eca114..3749e6834 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -14,6 +14,21 @@
  * @param <Model> The type of model that will also be returned as decodable data.
  */
 public class UnitModelLoader<Model> implements ModelLoader<Model, Model> {
+  @SuppressWarnings("deprecation")
+  private static final UnitModelLoader<?> INSTANCE = new UnitModelLoader<>();
+
+  @SuppressWarnings("unchecked")
+  public static <T> UnitModelLoader<T> getInstance() {
+    return (UnitModelLoader<T>) INSTANCE;
+  }
+
+  /**
+   * @deprecated Use {@link #getInstance()} instead.
+   */
+  @Deprecated
+  public UnitModelLoader() {
+    // Intentionally empty.
+  }
 
   @Override
   public LoadData<Model> buildLoadData(Model model, int width, int height,
@@ -68,11 +83,26 @@ public DataSource getDataSource() {
    *
    * @param <Model> The type of model that will also be returned as decodable data.
    */
+  // PMD seems to be just wrong here, maybe confused by getInstance in UnitModelLoader.
+  @SuppressWarnings("PMD.SingleMethodSingleton")
   public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
+    @SuppressWarnings("deprecation")
+    private static final Factory<?> FACTORY = new Factory<>();
+
+    @SuppressWarnings("unchecked")
+    public static <T> Factory<T> getInstance() {
+      return (Factory<T>) FACTORY;
+    }
+
+    /** @deprecated Use {@link #getInstance()} instead. */
+    @Deprecated
+    public Factory() {
+      // Intentionally empty.
+    }
 
     @Override
     public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
-      return new UnitModelLoader<>();
+      return UnitModelLoader.getInstance();
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index 299e31d42..41ea33a35 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -3,7 +3,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.graphics.drawable.Drawable;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -12,13 +12,16 @@
 
 /**
  * Transforms {@link android.graphics.drawable.BitmapDrawable}s.
+ *
+ * @deprecated Use {@link DrawableTransformation} instead.
  */
+@Deprecated
 public class BitmapDrawableTransformation implements Transformation<BitmapDrawable> {
 
-  private final Transformation<Bitmap> wrapped;
+  private final Transformation<Drawable> wrapped;
 
   public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
-    this.wrapped = Preconditions.checkNotNull(wrapped);
+    this.wrapped = Preconditions.checkNotNull(new DrawableTransformation(wrapped));
   }
 
   /**
@@ -45,19 +48,27 @@ public BitmapDrawableTransformation(
   public Resource<BitmapDrawable> transform(
       Context context, Resource<BitmapDrawable> drawableResourceToTransform, int outWidth,
       int outHeight) {
-    BitmapDrawable drawableToTransform = drawableResourceToTransform.get();
-    Bitmap bitmapToTransform = drawableToTransform.getBitmap();
 
-    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
-    BitmapResource bitmapResourceToTransform = BitmapResource.obtain(bitmapToTransform, bitmapPool);
-    Resource<Bitmap> transformedBitmapResource =
-        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
+    Resource<Drawable> toTransform = convertToDrawableResource(drawableResourceToTransform);
+    Resource<Drawable> transformed = wrapped.transform(context, toTransform, outWidth, outHeight);
+    return convertToBitmapDrawableResource(transformed);
+  }
 
-    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
-      return drawableResourceToTransform;
-    } else {
-      return LazyBitmapDrawableResource.obtain(context, transformedBitmapResource.get());
+  @SuppressWarnings("unchecked")
+  private static Resource<BitmapDrawable> convertToBitmapDrawableResource(
+      Resource<Drawable> resource) {
+    if (!(resource.get() instanceof BitmapDrawable)) {
+      throw new IllegalArgumentException(
+          "Wrapped transformation unexpectedly returned a non BitmapDrawable resource: "
+              + resource.get());
     }
+    return (Resource<BitmapDrawable>) (Resource<?>) resource;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<Drawable> convertToDrawableResource(
+      Resource<BitmapDrawable> toConvert) {
+    return (Resource<Drawable>) (Resource<? extends Drawable>) toConvert;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
new file mode 100644
index 000000000..a8027610e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
@@ -0,0 +1,65 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.request.target.Target;
+import java.util.concurrent.locks.Lock;
+
+final class DrawableToBitmapConverter {
+  private static final BitmapPool NO_BITMAP_POOL = new BitmapPoolAdapter();
+  private DrawableToBitmapConverter() {
+    // Utility class.
+  }
+
+  @Nullable
+  static Resource<Bitmap> convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+    // Handle DrawableContainer or StateListDrawables that may contain one or more BitmapDrawables.
+    drawable = drawable.getCurrent();
+    Bitmap result = null;
+    boolean isRecycleable = false;
+    if (drawable instanceof BitmapDrawable) {
+      result = ((BitmapDrawable) drawable).getBitmap();
+    } else if (!(drawable instanceof Animatable)) {
+      result = drawToBitmap(bitmapPool, drawable, width, height);
+      // We created and drew to the Bitmap, so it's safe for us to recycle or re-use.
+      isRecycleable = true;
+    }
+
+    BitmapPool toUse = isRecycleable ? bitmapPool : NO_BITMAP_POOL;
+    return BitmapResource.obtain(result, toUse);
+  }
+
+  private static Bitmap drawToBitmap(
+      BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+    if (width == Target.SIZE_ORIGINAL && drawable.getIntrinsicWidth() <= 0) {
+      throw new IllegalArgumentException("Unable to draw " + drawable + " to Bitmap with "
+          + "Target.SIZE_ORIGINAL because the Drawable has no intrinsic width");
+    }
+    if (height == Target.SIZE_ORIGINAL && drawable.getIntrinsicHeight() <= 0) {
+      throw new IllegalArgumentException("Unable to draw " + drawable + " to Bitmap with "
+          + "Target.SIZE_ORIGINAL because the Drawable has no intrinsic height");
+    }
+    int targetWidth = drawable.getIntrinsicWidth() > 0 ? drawable.getIntrinsicWidth() : width;
+    int targetHeight = drawable.getIntrinsicHeight() > 0 ? drawable.getIntrinsicHeight() : height;
+
+    Lock lock = TransformationUtils.getBitmapDrawableLock();
+    lock.lock();
+    Bitmap result = bitmapPool.get(targetWidth, targetHeight, Bitmap.Config.ARGB_8888);
+    try {
+      Canvas canvas = new Canvas(result);
+      drawable.setBounds(0, 0, targetWidth, targetHeight);
+      drawable.draw(canvas);
+      canvas.setBitmap(null);
+    } finally {
+      lock.unlock();
+    }
+    return result;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
new file mode 100644
index 000000000..c06b78d01
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import java.security.MessageDigest;
+
+/**
+ * Applies a {@link Bitmap} {@link Transformation} to {@link Drawable}s by first attempting to
+ * convert the {@link Drawable} to a {@link Bitmap} and then running the {@link Transformation}
+ * on the converted {@link Bitmap}.
+ *
+ * <p>This class is relatively efficient for {@link BitmapDrawable} where the {@link Bitmap} is
+ * readily accessible. For non-{@link Bitmap} based {@link Drawable}s, this class must first try to
+ * draw the {@link Drawable} to a {@link Bitmap} using {@link android.graphics.Canvas}, which is
+ * less efficient. {@link Drawable}s that implement {@link android.graphics.drawable.Animatable}
+ * will fail with an exception. {@link Drawable}s that return <= 0 for
+ * {@link Drawable#getIntrinsicHeight()} and/or {@link Drawable#getIntrinsicWidth()} will fail
+ * with an exception if the requested size is
+ * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}. {@link Drawable}s without
+ * intrinsic dimensions are drawn using the dimensions provided in
+ * {@link Transformation#transform(Context, Resource, int, int)}. As a result, they may be
+ * transformed incorrectly or in unexpected ways.
+ */
+public class DrawableTransformation implements Transformation<Drawable> {
+
+  private final Transformation<Bitmap> wrapped;
+
+  public DrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped = wrapped;
+  }
+
+  @SuppressWarnings("unchecked")
+  public Transformation<BitmapDrawable> asBitmapDrawable() {
+   return (Transformation<BitmapDrawable>) (Transformation<?>) this;
+  }
+
+  @Override
+  public Resource<Drawable> transform(Context context, Resource<Drawable> resource, int outWidth,
+      int outHeight) {
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    Drawable drawable = resource.get();
+    Resource<Bitmap> bitmapResourceToTransform =
+        DrawableToBitmapConverter.convert(bitmapPool, drawable, outWidth, outHeight);
+    if (bitmapResourceToTransform == null) {
+      throw new IllegalArgumentException("Unable to convert " + drawable + " to a Bitmap");
+    }
+    Resource<Bitmap> transformedBitmapResource =
+        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
+
+    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
+      transformedBitmapResource.recycle();
+      bitmapResourceToTransform.recycle();
+      return resource;
+    } else {
+      return newDrawableResource(context, transformedBitmapResource.get());
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private Resource<Drawable> newDrawableResource(
+      Context context, Bitmap transformed) {
+    Resource<? extends Drawable> result =
+        LazyBitmapDrawableResource.obtain(context, transformed);
+    return (Resource<Drawable>) result;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof DrawableTransformation) {
+      DrawableTransformation other = (DrawableTransformation) o;
+      return wrapped.equals(other.wrapped);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return wrapped.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    wrapped.updateDiskCacheKey(messageDigest);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
new file mode 100644
index 000000000..df92c3d48
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.ContentResolver;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.request.target.Target;
+import java.io.IOException;
+
+/**
+ * Decodes {@link Bitmap}s from resource ids.
+ *
+ * <p>The framework will decode some resources as {@link Drawable}s that do not wrap
+ * {@link Bitmap}s. This decoder will attempt to return a {@link Bitmap} for those
+ * {@link Drawable}s anyway by drawing the {@link Drawable} to a {@link Canvas}s using
+ * the {@link Drawable}'s intrinsic bounds or the dimensions provided to
+ * {@link #decode(Object, int, int, Options)}.
+ *
+ * <p>For non-{@link Bitmap} {@link Drawable}s that return <= 0 for
+ * {@link Drawable#getIntrinsicWidth()} and/or {@link Drawable#getIntrinsicHeight()}, this
+ * decoder will fail if the width and height provided to {@link #decode(Object, int, int, Options)}
+ * are {@link Target#SIZE_ORIGINAL}.
+ */
+public class ResourceBitmapDecoder implements ResourceDecoder<Uri, Bitmap> {
+
+  private final ResourceDrawableDecoder drawableDecoder;
+  private final BitmapPool bitmapPool;
+
+  public ResourceBitmapDecoder(ResourceDrawableDecoder drawableDecoder, BitmapPool bitmapPool) {
+    this.drawableDecoder = drawableDecoder;
+    this.bitmapPool = bitmapPool;
+  }
+
+  @Override
+  public boolean handles(Uri source, Options options) throws IOException {
+    return ContentResolver.SCHEME_ANDROID_RESOURCE.equals(source.getScheme());
+  }
+
+  @Nullable
+  @Override
+  public Resource<Bitmap> decode(Uri source, int width, int height, Options options)
+      throws IOException {
+    Resource<Drawable> drawableResource = drawableDecoder.decode(source, width, height, options);
+    Drawable drawable = drawableResource.get();
+    return DrawableToBitmapConverter.convert(bitmapPool, drawable, width, height);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
new file mode 100644
index 000000000..3cdc950fc
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
@@ -0,0 +1,29 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import java.io.IOException;
+
+/**
+ * Passes through a (hopefully) non-owned {@link Bitmap} as a {@link Bitmap} based {@link Resource}
+ * so that the given {@link Bitmap} is not recycled.
+ */
+public final class UnitBitmapDecoder implements ResourceDecoder<Bitmap, Bitmap> {
+  private static final BitmapPoolAdapter BITMAP_POOL = new BitmapPoolAdapter();
+
+  @Override
+  public boolean handles(Bitmap source, Options options) throws IOException {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public Resource<Bitmap> decode(Bitmap source, int width, int height, Options options)
+      throws IOException {
+    return new BitmapResource(source, BITMAP_POOL);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
new file mode 100644
index 000000000..789d5d925
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
@@ -0,0 +1,38 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.load.engine.Resource;
+
+/**
+ * Handles generic {@link Drawable} types where we may be uncertain of their size or type and
+ * where we don't know that it's safe for us to recycle or re-use the Drawable.
+ */
+final class NonOwnedDrawableResource extends DrawableResource<Drawable> {
+
+  @SuppressWarnings("unchecked")
+  public static Resource<Drawable> newInstance(Drawable drawable) {
+    return new NonOwnedDrawableResource(drawable);
+  }
+
+  private NonOwnedDrawableResource(Drawable drawable) {
+    super(drawable);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public Class<Drawable> getResourceClass() {
+    return (Class<Drawable>) drawable.getClass();
+  }
+
+  @Override
+  public int getSize() {
+    // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If
+    // there are no intrinsic bounds, we can fall back just to 1.
+    return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);
+  }
+
+  @Override
+  public void recycle() {
+    // Do nothing.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
index 2f81607f9..d1f5c1538 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
@@ -7,7 +7,6 @@
 import android.net.Uri;
 import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -42,7 +41,7 @@ public boolean handles(Uri source, Options options) throws IOException {
     return source.getScheme().equals(ContentResolver.SCHEME_ANDROID_RESOURCE);
   }
 
-  @Nullable
+  @NonNull
   @Override
   public Resource<Drawable> decode(Uri source, int width, int height, Options options)
       throws IOException {
@@ -52,7 +51,7 @@ public boolean handles(Uri source, Options options) throws IOException {
         ? context : getContextForPackage(source, packageName);
     // We can't get a theme from another application.
     Drawable drawable = DrawableDecoderCompat.getDrawable(toUse, resId);
-    return new InternalDrawableResource(drawable);
+    return NonOwnedDrawableResource.newInstance(drawable);
   }
 
   @NonNull
@@ -89,29 +88,4 @@ private int loadResourceIdFromUri(Uri source) {
      }
      return result;
   }
-
-  private static final class InternalDrawableResource extends DrawableResource<Drawable> {
-
-    InternalDrawableResource(Drawable drawable) {
-      super(drawable);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public Class<Drawable> getResourceClass() {
-      return (Class<Drawable>) drawable.getClass();
-    }
-
-    @Override
-    public int getSize() {
-      // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If
-      // there are no intrinsic bounds, we can fall back just to 1.
-      return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);
-    }
-
-    @Override
-    public void recycle() {
-      // Do nothing.
-    }
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
new file mode 100644
index 000000000..9c5143780
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import java.io.IOException;
+
+/**
+ * Passes through a {@link Drawable} as a {@link Drawable} based {@link Resource}.
+ */
+public class UnitDrawableDecoder implements ResourceDecoder<Drawable, Drawable> {
+  @Override
+  public boolean handles(Drawable source, Options options) throws IOException {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public Resource<Drawable> decode(Drawable source, int width, int height, Options options)
+      throws IOException {
+    return NonOwnedDrawableResource.newInstance(source);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 2c6125674..7bc94ab03 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -3,9 +3,14 @@
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.support.annotation.Nullable;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
+import java.io.PrintStream;
+import java.io.PrintWriter;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -47,6 +52,7 @@
  * @param <R> The type of the resource that will be loaded.
  */
 public class RequestFutureTarget<R> implements FutureTarget<R>,
+    RequestListener<R>,
     Runnable {
   private static final Waiter DEFAULT_WAITER = new Waiter();
 
@@ -62,6 +68,7 @@
   private boolean isCancelled;
   private boolean resultReceived;
   private boolean loadFailed;
+  @Nullable private GlideException exception;
 
   /**
    * Constructor for a RequestFutureTarget. Should not be used directly.
@@ -162,8 +169,7 @@ public void onLoadStarted(Drawable placeholder) {
    */
   @Override
   public synchronized void onLoadFailed(Drawable errorDrawable) {
-    loadFailed = true;
-    waiter.notifyAll(this);
+    // Ignored, synchronized for backwards compatibility.
   }
 
   /**
@@ -171,10 +177,7 @@ public synchronized void onLoadFailed(Drawable errorDrawable) {
    */
   @Override
   public synchronized void onResourceReady(R resource, Transition<? super R> transition) {
-    // We might get a null result.
-    resultReceived = true;
-    this.resource = resource;
-    waiter.notifyAll(this);
+    // Ignored, synchronized for backwards compatibility.
   }
 
   private synchronized R doGet(Long timeoutMillis)
@@ -186,7 +189,7 @@ private synchronized R doGet(Long timeoutMillis)
     if (isCancelled) {
       throw new CancellationException();
     } else if (loadFailed) {
-      throw new ExecutionException(new IllegalStateException("Load failed"));
+      throw new ExecutionException(exception);
     } else if (resultReceived) {
       return resource;
     }
@@ -200,7 +203,7 @@ private synchronized R doGet(Long timeoutMillis)
     if (Thread.interrupted()) {
       throw new InterruptedException();
     } else if (loadFailed) {
-      throw new ExecutionException(new IllegalStateException("Load failed"));
+      throw new GlideExecutionException(exception);
     } else if (isCancelled) {
       throw new CancellationException();
     } else if (!resultReceived) {
@@ -240,6 +243,25 @@ public void onDestroy() {
     // Do nothing.
   }
 
+  @Override
+  public synchronized boolean onLoadFailed(
+      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource) {
+    loadFailed = true;
+    exception = e;
+    waiter.notifyAll(this);
+    return false;
+  }
+
+  @Override
+  public synchronized boolean onResourceReady(
+      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource) {
+    // We might get a null result.
+    resultReceived = true;
+    this.resource = resource;
+    waiter.notifyAll(this);
+    return false;
+  }
+
   // Visible for testing.
   static class Waiter {
 
@@ -251,4 +273,33 @@ public void notifyAll(Object toNotify) {
       toNotify.notifyAll();
     }
   }
+
+  private static class GlideExecutionException extends ExecutionException {
+
+    private final GlideException cause;
+
+    GlideExecutionException(GlideException cause) {
+      super();
+      this.cause = cause;
+    }
+
+    @Override
+    public void printStackTrace() {
+      printStackTrace(System.err);
+    }
+
+    @Override
+    public void printStackTrace(PrintStream s) {
+      super.printStackTrace(s);
+      s.print("Caused by: ");
+      cause.printStackTrace(s);
+    }
+
+    @Override
+    public void printStackTrace(PrintWriter s) {
+      super.printStackTrace(s);
+      s.print("Caused by: ");
+      cause.printStackTrace(s);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index f661cdbb9..cf322bcdb 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -19,13 +19,13 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.CenterCrop;
 import com.bumptech.glide.load.resource.bitmap.CenterInside;
 import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.DrawableTransformation;
 import com.bumptech.glide.load.resource.bitmap.FitCenter;
 import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -1170,9 +1170,14 @@ public RequestOptions optionalTransform(@NonNull Transformation<Bitmap> transfor
       return clone().optionalTransform(transformation);
     }
 
+    DrawableTransformation drawableTransformation = new DrawableTransformation(transformation);
     optionalTransform(Bitmap.class, transformation);
+    optionalTransform(Drawable.class, drawableTransformation);
     // TODO: remove BitmapDrawable decoder and this transformation.
-    optionalTransform(BitmapDrawable.class, new BitmapDrawableTransformation(transformation));
+    // Registering as BitmapDrawable is simply an optimization to avoid some iteration and
+    // isAssignableFrom checks when obtaining the transformation later on. It can be removed without
+    // affecting the functionality.
+    optionalTransform(BitmapDrawable.class, drawableTransformation.asBitmapDrawable());
     optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
     return selfOrThrowIfLocked();
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 49a6e988a..f33cc4cf7 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -85,6 +85,8 @@
   private final String tag = String.valueOf(super.hashCode());
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
+  @Nullable
+  private RequestListener<R> targetListener;
   private RequestCoordinator requestCoordinator;
   private Context context;
   private GlideContext glideContext;
@@ -119,6 +121,7 @@
       int overrideHeight,
       Priority priority,
       Target<R> target,
+      RequestListener<R> targetListener,
       RequestListener<R> requestListener,
       RequestCoordinator requestCoordinator,
       Engine engine,
@@ -138,6 +141,7 @@
         overrideHeight,
         priority,
         target,
+        targetListener,
         requestListener,
         requestCoordinator,
         engine,
@@ -160,6 +164,7 @@ private void init(
       int overrideHeight,
       Priority priority,
       Target<R> target,
+      RequestListener<R> targetListener,
       RequestListener<R> requestListener,
       RequestCoordinator requestCoordinator,
       Engine engine,
@@ -173,6 +178,7 @@ private void init(
     this.overrideHeight = overrideHeight;
     this.priority = priority;
     this.target = target;
+    this.targetListener = targetListener;
     this.requestListener = requestListener;
     this.requestCoordinator = requestCoordinator;
     this.engine = engine;
@@ -197,6 +203,7 @@ public void recycle() {
     overrideHeight = -1;
     target = null;
     requestListener = null;
+    targetListener = null;
     requestCoordinator = null;
     animationFactory = null;
     loadStatus = null;
@@ -544,8 +551,10 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
 
     isCallingCallbacks = true;
     try {
-      if (requestListener == null
-          || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
+      if ((requestListener == null
+          || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))
+          && (targetListener == null
+          || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) {
         Transition<? super R> animation =
             animationFactory.build(dataSource, isFirstResource);
         target.onResourceReady(result, animation);
@@ -581,8 +590,10 @@ private void onLoadFailed(GlideException e, int maxLogLevel) {
     isCallingCallbacks = true;
     try {
       //TODO: what if this is a thumbnail request?
-      if (requestListener == null
-          || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource())) {
+      if ((requestListener == null
+          || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource()))
+          && (targetListener == null
+          || !targetListener.onLoadFailed(e, model, target, isFirstReadyResource()))) {
         setErrorPlaceholder();
       }
     } finally {
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index dfb45ba0c..1406a02f7 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -3,8 +3,10 @@
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
 import static com.bumptech.glide.request.RequestOptions.errorOf;
 import static com.bumptech.glide.request.RequestOptions.placeholderOf;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -70,6 +72,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
@@ -554,6 +557,40 @@ public void testNullModelPrefersErrorDrawable() {
     verify(target).onLoadFailed(eq(error));
   }
 
+  @Test
+  public void testLoadBitmap_asBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager
+        .asBitmap()
+        .load(bitmap)
+        .into(target);
+
+    verify(target).onResourceReady(eq(bitmap), any(Transition.class));
+  }
+
+  @Test
+  public void testLoadBitmap_asDrawable() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager
+        .load(bitmap)
+        .into(target);
+
+    ArgumentCaptor<Object> captor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(captor.capture(), any(Transition.class));
+    BitmapDrawable drawable = (BitmapDrawable) captor.getValue();
+    assertThat(drawable.getBitmap()).isEqualTo(bitmap);
+  }
+
+  @Test
+  public void testLoadDrawable() {
+    Drawable drawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(drawable)
+        .into(target);
+
+    verify(target).onResourceReady(eq(drawable), any(Transition.class));
+  }
+
   @Test
   public void testNullModelPrefersFallbackDrawable() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index caa85b86c..9f17c6768 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -58,7 +58,7 @@ public void setUp() {
   public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
     harness.doLoad();
 
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
@@ -93,7 +93,7 @@ public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
     harness.doLoad();
     harness.doLoad();
 
-    verify(harness.job, times(1)).start(any(DecodeJob.class));
+    verify(harness.job, times(1)).start((DecodeJob) any());
   }
 
   @Test
@@ -192,7 +192,7 @@ public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
     harness.doLoad();
 
     verify(harness.resource, never()).acquire();
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
@@ -211,7 +211,7 @@ public void testCacheIsNotCheckedIfNotMemoryCacheable() {
     harness.isMemoryCacheable = false;
     harness.doLoad();
 
-    verify(harness.job).start(any(DecodeJob.class));
+    verify(harness.job).start((DecodeJob) any());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index b5fa17830..c4227a0cc 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -37,12 +37,12 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("deprecation")
 public class BitmapDrawableTransformationTest {
 
   @Mock BitmapPool bitmapPool;
   @Mock Transformation<Bitmap> wrapped;
   @Mock Resource<BitmapDrawable> drawableResourceToTransform;
-  @Mock BitmapDrawable drawableToTransform;
 
   private BitmapDrawableTransformation transformation;
   private Bitmap bitmapToTransform;
@@ -52,11 +52,11 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawableToTransform = new BitmapDrawable(bitmapToTransform);
 
     context = RuntimeEnvironment.application;
     Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
     when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
-    when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);
     transformation = new BitmapDrawableTransformation(wrapped);
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index cc3c11cd0..23df8a88f 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -13,6 +13,7 @@
 import static org.mockito.Mockito.verify;
 
 import android.os.Handler;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
@@ -61,7 +62,12 @@ public void testReturnsFalseForDoneBeforeDone() {
 
   @Test
   public void testReturnsTrueFromIsDoneIfDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     assertTrue(future.isDone());
   }
 
@@ -106,7 +112,12 @@ public void testClearsRequestOnRun() {
 
   @Test
   public void testDoesNotClearRequestIfCancelledAfterDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.cancel(true);
 
     verify(request, never()).clear();
@@ -120,7 +131,12 @@ public void testReturnsTrueFromDoneIfCancelled() {
 
   @Test
   public void testReturnsFalseFromIsCancelledIfCancelledAfterDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.cancel(true);
 
     assertFalse(future.isCancelled());
@@ -134,7 +150,12 @@ public void testReturnsTrueFromCancelIfCancelled() {
 
   @Test
   public void testReturnsFalseFromCancelIfDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     assertFalse(future.cancel(true));
   }
 
@@ -142,7 +163,12 @@ public void testReturnsFalseFromCancelIfDone() {
   public void testReturnsResourceOnGetIfAlreadyDone()
       throws ExecutionException, InterruptedException {
     Object expected = new Object();
-    future.onResourceReady(expected, null);
+    future.onResourceReady(
+        /*resource=*/ expected,
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
 
     assertEquals(expected, future.get());
   }
@@ -151,7 +177,12 @@ public void testReturnsResourceOnGetIfAlreadyDone()
   public void testReturnsResourceOnGetWithTimeoutIfAlreadyDone()
       throws InterruptedException, ExecutionException, TimeoutException {
     Object expected = new Object();
-    future.onResourceReady(expected, null);
+    future.onResourceReady(
+        /*resource=*/ expected,
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
 
     assertEquals(expected, future.get(100, TimeUnit.MILLISECONDS));
   }
@@ -173,21 +204,21 @@ public void testThrowsCancellationExceptionIfCancelledBeforeGetWithTimeout()
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGet()
       throws ExecutionException, InterruptedException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get();
   }
 
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionWithNullValueBeforeGet()
       throws ExecutionException, InterruptedException, TimeoutException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get(100, TimeUnit.MILLISECONDS);
   }
 
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGetWithTimeout()
       throws ExecutionException, InterruptedException, TimeoutException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get(100, TimeUnit.MILLISECONDS);
   }
 
@@ -208,7 +239,12 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
   public void testGetSucceedsOnMainThreadIfDone()
       throws ExecutionException, InterruptedException {
     future = new RequestFutureTarget<>(handler, width, height, true, waiter);
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.get();
   }
 
@@ -232,7 +268,7 @@ public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onLoadFailed(null);
+        future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
         return null;
       }
     }).when(waiter).waitForTimeout(eq(future), anyLong());
@@ -266,13 +302,18 @@ public void testThrowsAssertionErrorIfFinishesWaitingWithoutTimeoutAndDoesNotRec
 
   @Test
   public void testNotifiesAllWhenLoadFails() {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     verify(waiter).notifyAll(eq(future));
   }
 
   @Test
   public void testNotifiesAllWhenResourceReady() {
-    future.onResourceReady(null, null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     verify(waiter).notifyAll(eq(future));
   }
 
@@ -297,7 +338,12 @@ public void testReturnsResourceIfReceivedWhileWaiting()
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onResourceReady(expected, null);
+        future.onResourceReady(
+            /*resource=*/ expected,
+            /*model=*/ null,
+            /*target=*/future,
+            DataSource.DATA_DISK_CACHE,
+            true /*isFirstResource*/);
         return null;
       }
     }).when(waiter).waitForTimeout(eq(future), anyLong());
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 86c73fa82..0002b5288 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -1002,6 +1002,7 @@ SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
           overrideHeight,
           priority,
           target,
+          /*targetListener=*/ null,
           requestListener,
           requestCoordinator,
           engine,
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/src/test/java/com/bumptech/glide/tests/Util.java
index e80796ba2..8f80b6049 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/src/test/java/com/bumptech/glide/tests/Util.java
@@ -46,7 +46,7 @@ public static DataSource isADataSource() {
   }
 
   public static Context anyContext() {
-    return any(Context.class);
+    return any();
   }
 
   /**
diff --git a/scripts/travis_after_success.sh b/scripts/travis_after_success.sh
new file mode 100755
index 000000000..b7bc17471
--- /dev/null
+++ b/scripts/travis_after_success.sh
@@ -0,0 +1,8 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$COMPONENT" == "unit" ]; then
+  ./scripts/travis_sonatype_publish.sh
+  ./gradlew jacocoTestReport coveralls
+fi
diff --git a/scripts/travis_before_script.sh b/scripts/travis_before_script.sh
new file mode 100755
index 000000000..14048c2d7
--- /dev/null
+++ b/scripts/travis_before_script.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$COMPONENT" == "instrumentation" ]; then
+  echo "Starting emulator for $COMPONENT tests"
+  ./scripts/travis_create_emulator.sh &
+
+fi
+
diff --git a/scripts/travis_create_emulator.sh b/scripts/travis_create_emulator.sh
new file mode 100755
index 000000000..fd39b3264
--- /dev/null
+++ b/scripts/travis_create_emulator.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+set -e
+
+echo y | android --silent update sdk --no-ui --all --filter android-$ANDROID_TARGET
+echo y | android --silent update sdk --no-ui --all --filter sys-img-armeabi-v7a-android-$ANDROID_TARGET
+echo no | android create avd --force -n test -t android-$ANDROID_TARGET --abi armeabi-v7a
+QEMU_AUDIO_DRV=none emulator -engine classic -avd test -no-window &
+
+exit 0
diff --git a/scripts/travis_firebase.sh b/scripts/travis_firebase.sh
new file mode 100755
index 000000000..932d0c9ab
--- /dev/null
+++ b/scripts/travis_firebase.sh
@@ -0,0 +1,29 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+fi
+
+./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel &
+pid=$!
+
+openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d
+
+wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+echo "y" | ./google-cloud-sdk/bin/gcloud components update beta
+./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json
+
+wait $pid
+
+apk_dir=instrumentation/build/outputs/apk
+./google-cloud-sdk/bin/gcloud firebase test android run \
+  --type instrumentation \
+  --app $apk_dir/instrumentation-debug.apk \
+  --test $apk_dir/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+  --project android-glide \
+  --no-auto-google-login \
diff --git a/scripts/travis_instrumentation.sh b/scripts/travis_instrumentation.sh
new file mode 100755
index 000000000..929dde0cd
--- /dev/null
+++ b/scripts/travis_instrumentation.sh
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel
+
+echo "Waiting for emulator..."
+android-wait-for-emulator
+
+./gradlew :instrumentation:connectedDebugAndroidTest
+
diff --git a/scripts/travis_samples.sh b/scripts/travis_samples.sh
new file mode 100755
index 000000000..4ab3f1451
--- /dev/null
+++ b/scripts/travis_samples.sh
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew :samples:flickr:build \
+  :samples:giphy:build \
+  :samples:contacturi:build \
+  :samples:gallery:build \
+  :samples:imgur:build \
+  :samples:svg:build \
+  --parallel
diff --git a/scripts/travis_script.sh b/scripts/travis_script.sh
new file mode 100755
index 000000000..7c810b219
--- /dev/null
+++ b/scripts/travis_script.sh
@@ -0,0 +1,16 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$COMPONENT" == "unit" ]; then
+  ./scripts/travis_unit.sh
+elif [ "$COMPONENT" == "instrumentation" ]; then
+  ./scripts/travis_instrumentation.sh
+elif [ "$COMPONENT" == "samples" ]; then
+  ./scripts/travis_samples.sh
+elif [ "$COMPONENT" == "firebase" ]; then
+  ./scripts/travis_firebase.sh
+else
+  echo "Unrecognized component: $COMPONENT"
+  exit 1
+fi
diff --git a/scripts/travis-sonatype-publish.sh b/scripts/travis_sonatype_publish.sh
similarity index 100%
rename from scripts/travis-sonatype-publish.sh
rename to scripts/travis_sonatype_publish.sh
diff --git a/scripts/travis_unit.sh b/scripts/travis_unit.sh
new file mode 100755
index 000000000..bc2f576d3
--- /dev/null
+++ b/scripts/travis_unit.sh
@@ -0,0 +1,12 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew build \
+  -x :samples:flickr:build \
+  -x :samples:giphy:build \
+  -x :samples:contacturi:build \
+  -x :samples:gallery:build \
+  -x :samples:imgur:build \
+  -x :samples:svg:build \
+  -x testReleaseUnitTest --parallel
diff --git a/settings.gradle b/settings.gradle
index 20c2b4430..7ba0b29f7 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -2,6 +2,7 @@ exec {
     commandLine "git", "submodule", "update", "--init", "--recursive"
 }
 include ':library'
+include ':instrumentation'
 include ':annotation'
 include ':annotation:compiler'
 include ':glide'
